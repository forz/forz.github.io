<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Prometheus的client_golang - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promht" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/prometheus%E7%9A%84client_golang/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Prometheus的client_golang" />
<meta property="og:description" content="概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promht" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/prometheus%E7%9A%84client_golang/" />
<meta property="article:published_time" content="2020-07-14T17:21:00+00:00" />
<meta property="article:modified_time" content="2020-07-14T17:21:00+00:00" />
<meta itemprop="name" content="Prometheus的client_golang">
<meta itemprop="description" content="概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promht">
<meta itemprop="datePublished" content="2020-07-14T17:21:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-07-14T17:21:00&#43;00:00" />
<meta itemprop="wordCount" content="32147">



<meta itemprop="keywords" content="Prometheus,Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Prometheus的client_golang"/>
<meta name="twitter:description" content="概述 普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promht"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Prometheus的client_golang</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-07-14 </span>
        <div class="post-category">
            <a href="/categories/prometheus/"> Prometheus </a>
            </div>
          <span class="more-meta"> 约 32147 字 </span>
          <span class="more-meta"> 预计阅读 65 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#func-alreadyregisterederror-error">func (AlreadyRegisteredError) Error</a></li>
  </ul>

  <ul>
    <li><a href="#func-newbuildinfocollector">func NewBuildInfoCollector</a></li>
    <li><a href="#func-newexpvarcollector">func NewExpvarCollector</a></li>
    <li><a href="#func-newgocollector">func NewGoCollector</a></li>
    <li><a href="#func-newprocesscollector">func NewProcessCollector</a></li>
  </ul>

  <ul>
    <li><a href="#func-newcounter">func NewCounter</a></li>
    <li><a href="#type-counterfunc">type CounterFunc</a></li>
    <li><a href="#func-newcounterfunc">func NewCounterFunc</a></li>
  </ul>

  <ul>
    <li><a href="#func-newcountervec">func NewCounterVec</a></li>
    <li><a href="#func-countervec-collect">func (CounterVec) Collect</a></li>
    <li><a href="#func-countervec-currywith">func (*CounterVec) CurryWith</a></li>
    <li><a href="#func-countervec-delete">func (CounterVec) Delete</a></li>
    <li><a href="#func-countervec-deletelabelvalues">func (CounterVec) DeleteLabelValues</a></li>
    <li><a href="#func-countervec-describe">func (CounterVec) Describe</a></li>
    <li><a href="#func-countervec-getmetricwith">func (*CounterVec) GetMetricWith</a></li>
    <li><a href="#func-countervec-getmetricwithlabelvalues">func (*CounterVec) GetMetricWithLabelValues</a></li>
    <li><a href="#func-countervec-mustcurrywith">func (*CounterVec) MustCurryWith</a></li>
    <li><a href="#func-countervec-reset">func (CounterVec) Reset</a></li>
    <li><a href="#func-countervec-with">func (*CounterVec) With</a></li>
    <li><a href="#func-countervec-withlabelvalues">func (*CounterVec) WithLabelValues</a></li>
  </ul>

  <ul>
    <li><a href="#func-newgauge">func NewGauge</a></li>
    <li><a href="#type-gaugefunc">type GaugeFunc</a></li>
    <li><a href="#func-newgaugefunc">func NewGaugeFunc</a></li>
  </ul>

  <ul>
    <li><a href="#func-gaugevec-collect">func (GaugeVec) Collect</a></li>
    <li><a href="#func-gaugevec-currywith">func (*GaugeVec) CurryWith</a></li>
    <li><a href="#func-gaugevec-delete">func (GaugeVec) Delete</a></li>
    <li><a href="#func-gaugevec-deletelabelvalues">func (GaugeVec) DeleteLabelValues</a></li>
    <li><a href="#func-gaugevec-describe">func (GaugeVec) Describe</a></li>
    <li><a href="#func-gaugevec-getmetricwith">func (*GaugeVec) GetMetricWith</a></li>
    <li><a href="#func-gaugevec-getmetricwithlabelvalues">func (*GaugeVec) GetMetricWithLabelValues</a></li>
    <li><a href="#func-gaugevec-mustcurrywith">func (*GaugeVec) MustCurryWith</a></li>
    <li><a href="#func-gaugevec-reset">func (GaugeVec) Reset</a></li>
    <li><a href="#func-gaugevec-with">func (*GaugeVec) With</a></li>
    <li><a href="#func-gaugevec-withlabelvalues">func (*GaugeVec) WithLabelValues</a></li>
  </ul>

  <ul>
    <li><a href="#func-newhistogram">func NewHistogram</a></li>
  </ul>

  <ul>
    <li><a href="#func-newhistogramvec">func NewHistogramVec</a></li>
    <li><a href="#func-histogramvec-collect">func (HistogramVec) Collect</a></li>
    <li><a href="#func-histogramvec-currywith">func (*HistogramVec) CurryWith</a></li>
    <li><a href="#func-histogramvec-delete">func (HistogramVec) Delete</a></li>
    <li><a href="#func-histogramvec-deletelabelvalues">func (HistogramVec) DeleteLabelValues</a></li>
    <li><a href="#func-histogramvec-describe">func (HistogramVec) Describe</a></li>
    <li><a href="#func-histogramvec-getmetricwith">func (*HistogramVec) GetMetricWith</a></li>
    <li><a href="#func-histogramvec-getmetricwithlabelvalues">func (*HistogramVec) GetMetricWithLabelValues</a></li>
    <li><a href="#func-histogramvec-mustcurrywith">func (*HistogramVec) MustCurryWith</a></li>
    <li><a href="#func-histogramvec-reset">func (HistogramVec) Reset</a></li>
    <li><a href="#func-histogramvec-with">func (*HistogramVec) With</a></li>
    <li><a href="#func-histogramvec-withlabelvalues">func (*HistogramVec) WithLabelValues</a></li>
  </ul>

  <ul>
    <li><a href="#func-newsummary">func NewSummary</a></li>
  </ul>

  <ul>
    <li><a href="#func-newsummaryvec">func NewSummaryVec</a></li>
    <li><a href="#func-summaryvec-collect">func (SummaryVec) Collect</a></li>
    <li><a href="#func-summaryvec-currywith">func (*SummaryVec) CurryWith</a></li>
    <li><a href="#func-summaryvec-delete">func (SummaryVec) Delete</a></li>
    <li><a href="#func-summaryvec-deletelabelvalues">func (SummaryVec) DeleteLabelValues</a></li>
    <li><a href="#func-summaryvec-describe">func (SummaryVec) Describe</a></li>
    <li><a href="#func-summaryvec-getmetricwith">func (*SummaryVec) GetMetricWith</a></li>
    <li><a href="#func-summaryvec-getmetricwithlabelvalues">func (*SummaryVec) GetMetricWithLabelValues</a></li>
    <li><a href="#func-summaryvec-mustcurrywith">func (*SummaryVec) MustCurryWith</a></li>
    <li><a href="#func-summaryvec-reset">func (SummaryVec) Reset</a></li>
    <li><a href="#func-summaryvec-with">func (*SummaryVec) With</a></li>
    <li><a href="#func-summaryvec-withlabelvalues">func (*SummaryVec) WithLabelValues</a></li>
  </ul>

  <ul>
    <li><a href="#func-newdesc">func NewDesc</a></li>
    <li><a href="#func-newinvaliddesc">func NewInvalidDesc</a></li>
    <li><a href="#func-desc-string">func (*Desc) String</a></li>
  </ul>

  <ul>
    <li><a href="#type-gathererfunc">type GathererFunc</a></li>
    <li><a href="#func-gathererfunc-gather">func (GathererFunc) Gather</a></li>
  </ul>

  <ul>
    <li><a href="#func-gatherers-gather">func (Gatherers) Gather</a></li>
  </ul>

  <ul>
    <li><a href="#func-mustnewconsthistogram">func MustNewConstHistogram</a></li>
    <li><a href="#func-mustnewconstmetric">func MustNewConstMetric</a></li>
    <li><a href="#func-mustnewconstsummary">func MustNewConstSummary</a></li>
    <li><a href="#func-newconsthistogram">func NewConstHistogram</a></li>
    <li><a href="#func-newconstmetric">func NewConstMetric</a></li>
    <li><a href="#func-newconstsummary">func NewConstSummary</a></li>
    <li><a href="#func-newinvalidmetric">func NewInvalidMetric</a></li>
    <li><a href="#func-newmetricwithtimestamp">func NewMetricWithTimestamp</a></li>
  </ul>

  <ul>
    <li><a href="#func-multierror-append">func (*MultiError) Append</a></li>
    <li><a href="#func-multierror-error">func (MultiError) Error</a></li>
    <li><a href="#func-multierror-maybeunwrap">func (MultiError) MaybeUnwrap</a></li>
  </ul>

  <ul>
    <li><a href="#type-observerfunc">type ObserverFunc</a></li>
    <li><a href="#func-observerfunc-observe">func (ObserverFunc) Observe</a></li>
  </ul>

  <ul>
    <li><a href="#func-wrapregistererwith">func WrapRegistererWith</a></li>
    <li><a href="#func-wrapregistererwithprefix">func WrapRegistererWithPrefix</a></li>
  </ul>

  <ul>
    <li><a href="#func-newpedanticregistry">func NewPedanticRegistry</a></li>
    <li><a href="#func-newregistry">func NewRegistry</a></li>
    <li><a href="#func-registry-gather">func (*Registry) Gather</a></li>
    <li><a href="#func-registry-mustregister">func (*Registry) MustRegister</a></li>
    <li><a href="#func-registry-register">func (*Registry) Register</a></li>
    <li><a href="#func-registry-unregister">func (*Registry) Unregister</a></li>
  </ul>

  <ul>
    <li><a href="#func-newtimer">func NewTimer</a></li>
    <li><a href="#func-timer-observeduration">func (*Timer) ObserveDuration</a></li>
  </ul>

  <ul>
    <li><a href="#func-newuntypedfunc">func NewUntypedFunc</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="概述">概述</h1>
<p>普罗米修斯软件包是仪器仪表的核心。它为度量代码提供度量原语以进行监视。它还提供了Metric注册表。子包允许通过HTTP（包promhttp）公开已注册的指标，或将其推送到Pushgateway（包推送）。还有一个子包promauto，它为Metric构造函数提供自动注册。</p>
<p>除非另有说明，否则所有导出的函数和方法都可以安全地并发使用。</p>
<h1 id="一个基本的例子">一个基本的例子</h1>
<p>首先，给出一个非常基本的用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">cpuTemp</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;cpu_temperature_celsius&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Current temperature of the CPU.&#34;</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="nx">hdFailures</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;hd_errors_total&#34;</span><span class="p">,</span>
			<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Number of hard-disk errors.&#34;</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;device&#34;</span><span class="p">},</span>
	<span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Metrics have to be registered to be exposed:
</span><span class="c1"></span>	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cpuTemp</span><span class="p">)</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">hdFailures</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">cpuTemp</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mf">65.3</span><span class="p">)</span>
	<span class="nx">hdFailures</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;device&#34;</span><span class="p">:</span><span class="s">&#34;/dev/sda&#34;</span><span class="p">}).</span><span class="nf">Inc</span><span class="p">()</span>

	<span class="c1">// The Handler function provides a default handler to expose metrics
</span><span class="c1"></span>	<span class="c1">// via an HTTP server. &#34;/metrics&#34; is the usual endpoint for that.
</span><span class="c1"></span>	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是一个完整的程序，可以导出两个指标，一个量规和一个计数器，后者带有标签，可以将其转换为（一维）向量。</p>
<h1 id="指标">指标</h1>
<p>该软件包中导出的标识符的数量可能看起来有点不堪重负。但是，除了上面示例中显示的基本管道外，您仅需要了解不同的Metric类型及其向量版本即可基本使用。此外，如果您不关心何时以及如何在注册表中注册度量的精细控制，请查看promauto软件包，该软件包将有效地使您在简单情况下完全忽略注册。</p>
<p>在上方，您已经触摸了计数器和仪表。有两种更高级的Metric类型：“摘要”和“直方图”。可以在Prometheus docs中找到对这四种Metric类型的更详尽的描述：https://prometheus.io/docs/concepts/metric_types/</p>
<p>除了基本的Metric类型“量规”，“计数器”，“摘要”和“直方图”之外，Prometheus数据模型的一个非常重要的部分是沿称为标签的维度对样本进行划分，这将导致度量向量。基本类型是GaugeVec，CounterVec，SummaryVec和HistogramVec。</p>
<p>虽然仅基本Metric类型实现Metric接口，但Metric及其向量版本均实现了Collector接口。收集器管理许多Metric的收集，但为方便起见，Metric也可以“自行收集”。注意，Gauge，Counter，Summary和Histogram本身是接口，而GaugeVec，CounterVec，SummaryVec和HistogramVec不是接口。</p>
<p>要创建Metric及其向量版本的实例，您需要一个合适的…Opts结构，即GaugeOpts，CounterOpts，SummaryOpts或HistogramOpts。</p>
<h1 id="自定义收集器和常量指标">自定义收集器和常量指标</h1>
<p>尽管您可以创建自己的Metric实现，但很可能仅会自己实现Collector接口。乍一看，自定义收集器似乎很方便将Metric捆绑在一起以进行通用注册（以上述不同Metric向量的主要示例为例，该Metric捆绑了所有相同名称但具有不同标签的Metric）。</p>
<p>还有一个更复杂的用例：如果您已经有在Prometheus上下文之外创建的度量，则不需要各种Metric类型的接口。本质上，您希望在收集过程中将现有数字镜像到PrometheusMetric中。收集器接口的自己实现非常适合此操作。您可以使用NewConstMetric，NewConstHistogram和NewConstSummary（以及它们各自的Must…版本）“动态”创建Metric实例。 NewConstMetric用于仅以float64作为其值的所有Metric类型：Counter，Gauge和称为Untyped的特殊“类型”。如果不确定镜像指标是计数器还是量表，请使用后者。 Metric实例的创建在Collect方法中进行。 Describe方法必须返回单独的Desc实例，以代表稍后将创建的“丢弃”Metric。 NewDesc可以方便地创建这些Desc实例。或者，您可以根本不返回任何Desc，这会将收集器标记为“未选中”。在注册时不会执行任何检查，但是在刮刮时仍将确保Metric一致性，即任何不一致都会导致刮刮错误。因此，对于未经检查的收集器，不收集导致总刮除结果不一致的度量的责任在于收集器的实施者。虽然这不是理想的状态，但有时是必需的。典型的用例是在注册时无法预测要由收集器返回的确切度量的情况，但是实现者对整个系统有足够的知识以保证度量的一致性。</p>
<p>收集器示例说明了用例。您还可以查看processCollector（镜像流程指标），goCollector（镜像Go指标）或expvarCollector（镜像expvar指标）的源代码，作为在此包本身中使用的示例。</p>
<p>如果只需要调用一个函数来获取单个浮点值以作为度量收集，GaugeFunc，CounterFunc或UntypedFunc可能是有趣的快捷方式。</p>
<h1 id="注册表的高级用法">注册表的高级用法</h1>
<p>虽然MustRegister是注册收集器的最常用方法，但有时您可能希望处理注册可能导致的错误。顾名思义，如果发生错误，MustRegister会出现混乱。使用Register方法，可以返回错误并可以处理。</p>
<p>如果注册的收集器与已注册的Metric不兼容或不一致，则返回错误。该注册表旨在根据Prometheus数据模型来确保所收集指标的一致性。理想情况下，在注册时而不是在收集时检测到不一致。通常，前者通常在程序启动时被检测到，而后者只会在抓取时发生，如果不一致仅在以后变得很重要，则可能甚至不会在第一次抓取时发生。这就是收集器和Metric必须向注册表描述自己的主要原因。</p>
<p>到目前为止，我们所做的一切都在所谓的默认注册表上进行，因为可以在全局DefaultRegisterer变量中找到它。使用NewRegistry，您可以创建自定义注册表，甚至可以自己实现Registerer或Gatherer接口。注册和注销方法在自定义注册表上的工作方式与默认注册表上的全局函数注册和注销的工作方式相同。</p>
<p>自定义注册表有多种用途：您可以使用具有特殊属性的注册表，请参阅NewPedanticRegistry。您可以避免由DefaultRegisterer施加的全局状态。您可以同时使用多个注册表，以不同的方式公开不同的指标。您可以将单独的注册表用于测试目的。</p>
<p>还请注意，DefaultRegisterer已注册了Go运行时Metric的收集器（通过NewGoCollector）和过程度量的收集器（通过NewProcessCollector）。使用自定义注册表，您可以控制并自行决定要注册的收集器。</p>
<h1 id="http解释">HTTP解释</h1>
<p>注册表实现了Gatherer接口。然后，Gather方法的调用者可以以某种方式公开收集的指标。通常，度量是通过/metrics端点上的HTTP提供的。在上面的示例中就是这种情况。通过HTTP公开指标的工具位于promhttp子软件包中。</p>
<h1 id="推到pushgateway">推到Pushgateway</h1>
<p>在push子包中可以找到用于推送到Pushgateway的功能。</p>
<h1 id="graphite-bridge">Graphite Bridge</h1>
<p>在Graphite Bridge子包中可以找到将度量从采集器推向Graphite的函数和示例。</p>
<p>通过遵循现有实现的方法，可以轻松添加更多公开指标的方法。</p>
<h1 id="常量">常量</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// DefMaxAge is the default duration for which observations stay
</span><span class="c1"></span>	<span class="c1">// relevant.
</span><span class="c1"></span>	<span class="nx">DefMaxAge</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>
	<span class="c1">// DefAgeBuckets is the default number of buckets used to calculate the
</span><span class="c1"></span>	<span class="c1">// age of observations.
</span><span class="c1"></span>	<span class="nx">DefAgeBuckets</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="c1">// DefBufCap is the standard buffer size for collecting Summary observations.
</span><span class="c1"></span>	<span class="nx">DefBufCap</span> <span class="p">=</span> <span class="mi">500</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>SummaryOpts的默认值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">ExemplarMaxRunes</span> <span class="p">=</span> <span class="mi">64</span>
</code></pre></td></tr></table>
</div>
</div><p>ExemplarMaxRunes是示例标签中允许的最大符文总数。</p>
<h1 id="变量">变量</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">DefaultRegisterer</span> <span class="nx">Registerer</span> <span class="p">=</span> <span class="nx">defaultRegistry</span>
	<span class="nx">DefaultGatherer</span>   <span class="nx">Gatherer</span>   <span class="p">=</span> <span class="nx">defaultRegistry</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>DefaultRegisterer和DefaultGatherer是Registerer和Gatherer接口的实现，此包中的许多便捷功能都作用于该接口。最初，这两个变量都指向同一个注册表，该注册表具有一个进程收集器（当前仅在Linux上，请参阅NewProcessCollector）和一个Go收集器（请参阅NewGoCollector，尤其是有关1.9之前的Go版本的停止世界的注释）已经登记了。这种将默认实例保持为全局状态的方法反映了Go标准库中其他软件包的方法。请注意，有一些警告。仅当您了解后果后，才应谨慎更改变量。希望完全避免全局状态的用户不应使用便捷功能，而应对自定义实例进行操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">DefBuckets</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">.005</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.025</span><span class="p">,</span> <span class="mf">.05</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mf">.25</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>DefBuckets是默认的直方图存储桶。定制了默认存储桶，以广泛地衡量网络服务的响应时间（以秒为单位）。但是，很可能需要您定义针对用例定制的存储桶。</p>
<h1 id="func-buildfqname">func BuildFQName</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BuildFQName</span><span class="p">(</span><span class="nx">namespace</span><span class="p">,</span> <span class="nx">subsystem</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>BuildFQName通过“_”连接给定的三个名称组件。空名称组件将被忽略。如果name参数本身为空，则无论如何都将返回一个空字符串。该库中包含的Metric实现在内部使用此函数从其Opts中的名称组件生成完全限定的Metric名称。库的用户仅在实现自己的Metric或直接实例化Desc（使用NewDesc）时才需要此功能。</p>
<h1 id="func-describebycollect">func DescribeByCollect</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DescribeByCollect</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">,</span> <span class="nx">descs</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>DescribeByCollect是实现自定义收集器的Describe方法的助手。它从提供的收集器收集度量，并将其描述符发送到提供的通道。</p>
<p>如果收集器在其整个生命周期内收集相同的指标，则其Describe方法可以简单地实现为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">customCollector</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">DescribeByCollect</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，如果收集的指标在收集器的整个生命周期中以其描述符组合的集合也发生变化的方式动态变化，则这将不起作用。然后，快捷方式实现将违反Describe方法的约定。如果收集器有时根本不收集任何指标（例如，CounterVec，GaugeVec等向量，它们仅在访问具有完全指定的标签集的指标后才收集指标），它甚至可能注册为未经检查的收集器（参见。Registerer接口的Register方法）。因此，如果您确定要履行合同，请仅使用Describe的此快捷方式实现。</p>
<p>收集器示例演示了DescribeByCollect的用法。</p>
<h1 id="func-exponentialbuckets">func ExponentialBuckets</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ExponentialBuckets</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">factor</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div><p>ExponentialBuckets创建“计数”存储桶，其中最低存储桶的上限为“start”，随后每个存储桶的上限为“factor”乘以上一个存储桶的上限。最终的+ Inf存储桶不计算在内，也不包含在返回的切片中。返回的切片应用于HistogramOpts的Buckets字段。</p>
<p>如果&rsquo;count'为0或负数，如果&rsquo;start'为0或负数，或者&rsquo;factor'小于或等于1，则函数将发生错误。</p>
<h1 id="func-linearbuckets">func LinearBuckets</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">LinearBuckets</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">float64</span>
</code></pre></td></tr></table>
</div>
</div><p>LinearBuckets创建“计数”存储区，每个“宽度”宽，其中最低存储区的上限为“start”。最终的+ Inf存储桶不计算在内，也不包含在返回的切片中。返回的切片应用于HistogramOpts的Buckets字段。</p>
<p>如果“count”为零或负数，该函数将出现panic。</p>
<h1 id="func-mustregister">func MustRegister</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cs</span> <span class="o">...</span><span class="nx">Collector</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>MustRegister会使用DefaultRegisterer注册提供的收集器，如果发生任何错误，则会出现恐慌。</p>
<p>MustRegister是DefaultRegisterer.MustRegister（cs &hellip;）的快捷方式。请参阅此处以获取更多详细信息。</p>
<p>func Register</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Register向DefaultRegisterer注册提供的收集器。</p>
<p>Register是DefaultRegisterer.Register(c)的快捷方式。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Imagine you have a worker pool and want to count the tasks completed.
</span><span class="c1"></span><span class="nx">taskCounter</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
	<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
	<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;completed_tasks_total&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
<span class="p">})</span>
<span class="c1">// This will register fine.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounter</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounter registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Don&#39;t forget to tell the HTTP server about the Prometheus handler.
</span><span class="c1">// (In a real program, you still need to start the HTTP server...)
</span><span class="c1"></span><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>

<span class="c1">// Now you can start workers and give every one of them a pointer to
</span><span class="c1">// taskCounter and let it increment it whenever it completes a task.
</span><span class="c1"></span><span class="nx">taskCounter</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span> <span class="c1">// This has to happen somewhere in the worker code.
</span><span class="c1"></span>
<span class="c1">// But wait, you want to see how individual workers perform. So you need
</span><span class="c1">// a vector of counters, with one element for each worker.
</span><span class="c1"></span><span class="nx">taskCounterVec</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;completed_tasks_total&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Registering will fail because we already have a metric of that name.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterVec</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// To fix, first unregister the old taskCounter.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Unregister</span><span class="p">(</span><span class="nx">taskCounter</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounter unregistered.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Try registering taskCounterVec again.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterVec</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Bummer! Still doesn&#39;t work.
</span><span class="c1"></span>
<span class="c1">// Prometheus will not allow you to ever export metrics with
</span><span class="c1">// inconsistent help strings or label names. After unregistering, the
</span><span class="c1">// unregistered metrics will cease to show up in the /metrics HTTP
</span><span class="c1">// response, but the registry still remembers that those metrics had
</span><span class="c1">// been exported before. For this example, we will now choose a
</span><span class="c1">// different name. (In a real program, you would obviously not export
</span><span class="c1">// the obsolete metric in the first place.)
</span><span class="c1"></span><span class="nx">taskCounterVec</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;completed_tasks_by_id&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">},</span>
<span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterVec</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVec registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Finally it worked!
</span><span class="c1"></span>
<span class="c1">// The workers have to tell taskCounterVec their id to increment the
</span><span class="c1">// right element in the metric vector.
</span><span class="c1"></span><span class="nx">taskCounterVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">).</span><span class="nf">Inc</span><span class="p">()</span> <span class="c1">// Code from worker 42.
</span><span class="c1"></span>
<span class="c1">// Each worker could also keep a reference to their own counter element
</span><span class="c1">// around. Pick the counter at initialization time of the worker.
</span><span class="c1"></span><span class="nx">myCounter</span> <span class="o">:=</span> <span class="nx">taskCounterVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">)</span> <span class="c1">// From worker 42 initialization code.
</span><span class="c1"></span><span class="nx">myCounter</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>                                   <span class="c1">// Somewhere in the code of that worker.
</span><span class="c1"></span>
<span class="c1">// Note that something like WithLabelValues(&#34;42&#34;, &#34;spurious arg&#34;) would
</span><span class="c1">// panic (because you have provided too many label values). If you want
</span><span class="c1">// to get an error instead, use GetMetricWithLabelValues(...) instead.
</span><span class="c1"></span><span class="nx">notMyCounter</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">taskCounterVec</span><span class="p">.</span><span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">,</span> <span class="s">&#34;spurious arg&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Worker initialization failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">notMyCounter</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;notMyCounter is nil.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// A different (and somewhat tricky) approach is to use
</span><span class="c1">// ConstLabels. ConstLabels are pairs of label names and label values
</span><span class="c1">// that never change. Each worker creates and registers an own Counter
</span><span class="c1">// instance where the only difference is in the value of the
</span><span class="c1">// ConstLabels. Those Counters can all be registered because the
</span><span class="c1">// different ConstLabel values guarantee that each worker will increment
</span><span class="c1">// a different Counter metric.
</span><span class="c1"></span><span class="nx">counterOpts</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
	<span class="nx">Subsystem</span><span class="p">:</span>   <span class="s">&#34;worker_pool&#34;</span><span class="p">,</span>
	<span class="nx">Name</span><span class="p">:</span>        <span class="s">&#34;completed_tasks&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>        <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span>
	<span class="nx">ConstLabels</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">:</span> <span class="s">&#34;42&#34;</span><span class="p">},</span>
<span class="p">}</span>
<span class="nx">taskCounterForWorker42</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">counterOpts</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterForWorker42</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVForWorker42 not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterForWorker42 registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Obviously, in real code, taskCounterForWorker42 would be a member
</span><span class="c1">// variable of a worker struct, and the &#34;42&#34; would be retrieved with a
</span><span class="c1">// GetId() method or something. The Counter would be created and
</span><span class="c1">// registered in the initialization code of the worker.
</span><span class="c1"></span>
<span class="c1">// For the creation of the next Counter, we can recycle
</span><span class="c1">// counterOpts. Just change the ConstLabels.
</span><span class="c1"></span><span class="nx">counterOpts</span><span class="p">.</span><span class="nx">ConstLabels</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;worker_id&#34;</span><span class="p">:</span> <span class="s">&#34;2001&#34;</span><span class="p">}</span>
<span class="nx">taskCounterForWorker2001</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">counterOpts</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">taskCounterForWorker2001</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterVForWorker2001 not registered:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;taskCounterForWorker2001 registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">taskCounterForWorker2001</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
<span class="nx">taskCounterForWorker42</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
<span class="nx">taskCounterForWorker2001</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>

<span class="c1">// Yet another approach would be to turn the workers themselves into
</span><span class="c1">// Collectors and register them. See the Collector example for details.
</span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">taskCounter</span> <span class="nx">registered</span><span class="p">.</span>
<span class="nx">taskCounterVec</span> <span class="nx">not</span> <span class="nx">registered</span><span class="p">:</span> <span class="nx">a</span> <span class="nx">previously</span> <span class="nx">registered</span> <span class="nx">descriptor</span> <span class="nx">with</span> <span class="nx">the</span> <span class="nx">same</span> <span class="nx">fully</span><span class="o">-</span><span class="nx">qualified</span> <span class="nx">name</span> <span class="nx">as</span> <span class="nx">Desc</span><span class="p">{</span><span class="nx">fqName</span><span class="p">:</span> <span class="s">&#34;worker_pool_completed_tasks_total&#34;</span><span class="p">,</span> <span class="nx">help</span><span class="p">:</span> <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span> <span class="nx">constLabels</span><span class="p">:</span> <span class="p">{},</span> <span class="nx">variableLabels</span><span class="p">:</span> <span class="p">[</span><span class="nx">worker_id</span><span class="p">]}</span> <span class="nx">has</span> <span class="nx">different</span> <span class="nx">label</span> <span class="nx">names</span> <span class="nx">or</span> <span class="nx">a</span> <span class="nx">different</span> <span class="nx">help</span> <span class="kt">string</span>
<span class="nx">taskCounter</span> <span class="nx">unregistered</span><span class="p">.</span>
<span class="nx">taskCounterVec</span> <span class="nx">not</span> <span class="nx">registered</span><span class="p">:</span> <span class="nx">a</span> <span class="nx">previously</span> <span class="nx">registered</span> <span class="nx">descriptor</span> <span class="nx">with</span> <span class="nx">the</span> <span class="nx">same</span> <span class="nx">fully</span><span class="o">-</span><span class="nx">qualified</span> <span class="nx">name</span> <span class="nx">as</span> <span class="nx">Desc</span><span class="p">{</span><span class="nx">fqName</span><span class="p">:</span> <span class="s">&#34;worker_pool_completed_tasks_total&#34;</span><span class="p">,</span> <span class="nx">help</span><span class="p">:</span> <span class="s">&#34;Total number of tasks completed.&#34;</span><span class="p">,</span> <span class="nx">constLabels</span><span class="p">:</span> <span class="p">{},</span> <span class="nx">variableLabels</span><span class="p">:</span> <span class="p">[</span><span class="nx">worker_id</span><span class="p">]}</span> <span class="nx">has</span> <span class="nx">different</span> <span class="nx">label</span> <span class="nx">names</span> <span class="nx">or</span> <span class="nx">a</span> <span class="nx">different</span> <span class="nx">help</span> <span class="kt">string</span>
<span class="nx">taskCounterVec</span> <span class="nx">registered</span><span class="p">.</span>
<span class="nx">Worker</span> <span class="nx">initialization</span> <span class="nx">failed</span><span class="p">:</span> <span class="nx">inconsistent</span> <span class="nx">label</span> <span class="nx">cardinality</span><span class="p">:</span> <span class="nx">expected</span> <span class="mi">1</span> <span class="nx">label</span> <span class="nx">values</span> <span class="nx">but</span> <span class="nx">got</span> <span class="mi">2</span> <span class="nx">in</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;42&#34;</span><span class="p">,</span> <span class="s">&#34;spurious arg&#34;</span><span class="p">}</span>
<span class="nx">notMyCounter</span> <span class="nx">is</span> <span class="kc">nil</span><span class="p">.</span>
<span class="nx">taskCounterForWorker42</span> <span class="nx">registered</span><span class="p">.</span>
<span class="nx">taskCounterForWorker2001</span> <span class="nx">registered</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-unregister">func Unregister</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Unregister</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Unregister将从DefaultRegisterer中删除提供的收集器的注册。</p>
<p>Unregister是DefaultRegisterer.Unregister(c)的快捷方式。</p>
<h1 id="func-writetotextfile">func WriteToTextfile</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WriteToTextfile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">g</span> <span class="nx">Gatherer</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteToTextfile在提供的Gatherer上调用Gather，将结果编码为Prometheus文本格式，并将其写入临时文件。成功后，临时文件将重命名为提供的文件名。</p>
<p>这旨在与节点导出器的文本文件收集器一起使用。请注意，节点导出器期望文件名后缀为“ .prom”。</p>
<h1 id="type-alreadyregisterederror">type AlreadyRegisteredError</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">AlreadyRegisteredError</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ExistingCollector</span><span class="p">,</span> <span class="nx">NewCollector</span> <span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果以前已经注册了要注册的收集器，或者之前已经注册了收集相同度量的其他收集器，则Register方法将返回AlreadyRegisteredError。在这种情况下，注册失败，但是您可以从错误类型中检测出发生了什么。该错误包含现有收集器和与现有收集器相等的（被拒绝）新收集器的字段。如示例所示，这可用于查找是否已注册了相等的收集器，然后切换到使用旧的收集器。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reqCounter</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounter</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;requests_total&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;The total number of requests served.&#34;</span><span class="p">,</span>
<span class="p">})</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">reqCounter</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">are</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">AlreadyRegisteredError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// A counter for that metric has been registered before.
</span><span class="c1"></span>		<span class="c1">// Use the old counter from now on.
</span><span class="c1"></span>		<span class="nx">reqCounter</span> <span class="p">=</span> <span class="nx">are</span><span class="p">.</span><span class="nx">ExistingCollector</span><span class="p">.(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Counter</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Something else went wrong!
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">reqCounter</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-alreadyregisterederror-error">func (AlreadyRegisteredError) Error</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">err</span> <span class="nx">AlreadyRegisteredError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-collector">type Collector</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Collector</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Describe sends the super-set of all possible descriptors of metrics
</span><span class="c1"></span>	<span class="c1">// collected by this Collector to the provided channel and returns once
</span><span class="c1"></span>	<span class="c1">// the last descriptor has been sent. The sent descriptors fulfill the
</span><span class="c1"></span>	<span class="c1">// consistency and uniqueness requirements described in the Desc
</span><span class="c1"></span>	<span class="c1">// documentation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It is valid if one and the same Collector sends duplicate
</span><span class="c1"></span>	<span class="c1">// descriptors. Those duplicates are simply ignored. However, two
</span><span class="c1"></span>	<span class="c1">// different Collectors must not send duplicate descriptors.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Sending no descriptor at all marks the Collector as “unchecked”,
</span><span class="c1"></span>	<span class="c1">// i.e. no checks will be performed at registration time, and the
</span><span class="c1"></span>	<span class="c1">// Collector may yield any Metric it sees fit in its Collect method.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This method idempotently sends the same descriptors throughout the
</span><span class="c1"></span>	<span class="c1">// lifetime of the Collector. It may be called concurrently and
</span><span class="c1"></span>	<span class="c1">// therefore must be implemented in a concurrency safe way.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If a Collector encounters an error while executing this method, it
</span><span class="c1"></span>	<span class="c1">// must send an invalid descriptor (created with NewInvalidDesc) to
</span><span class="c1"></span>	<span class="c1">// signal the error to the registry.
</span><span class="c1"></span>	<span class="nf">Describe</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
	<span class="c1">// Collect is called by the Prometheus registry when collecting
</span><span class="c1"></span>	<span class="c1">// metrics. The implementation sends each collected metric via the
</span><span class="c1"></span>	<span class="c1">// provided channel and returns once the last metric has been sent. The
</span><span class="c1"></span>	<span class="c1">// descriptor of each sent metric is one of those returned by Describe
</span><span class="c1"></span>	<span class="c1">// (unless the Collector is unchecked, see above). Returned metrics that
</span><span class="c1"></span>	<span class="c1">// share the same descriptor must differ in their variable label
</span><span class="c1"></span>	<span class="c1">// values.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This method may be called concurrently and must therefore be
</span><span class="c1"></span>	<span class="c1">// implemented in a concurrency safe way. Blocking occurs at the expense
</span><span class="c1"></span>	<span class="c1">// of total performance of rendering all registered metrics. Ideally,
</span><span class="c1"></span>	<span class="c1">// Collector implementations support concurrent readers.
</span><span class="c1"></span>	<span class="nf">Collect</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>收集器是由Prometheus可以用来收集Metric的任何东西实现的接口。必须为收集器注册收集器。请参阅Registerer.Register。</p>
<p>此程序包提供的库存指标（量规，计数器，汇总，直方图，无类型）也是收集器（仅收集一个指标，即本身）。但是，收集器的实现者可以以协调的方式收集多个指标和/或即时创建指标。已经在该库中实现的收集器的示例是度量向量（即，同一Metric但具有不同标签值的多个实例的集合），例如GaugeVec或SummaryVec，以及ExpvarCollector。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
<span class="p">)</span>

<span class="c1">// ClusterManager is an example for a system that might have been built without
</span><span class="c1">// Prometheus in mind. It models a central manager of jobs running in a
</span><span class="c1">// cluster. Thus, we implement a custom Collector called
</span><span class="c1">// ClusterManagerCollector, which collects information from a ClusterManager
</span><span class="c1">// using its provided methods and turns them into Prometheus Metrics for
</span><span class="c1">// collection.
</span><span class="c1">//
</span><span class="c1">// An additional challenge is that multiple instances of the ClusterManager are
</span><span class="c1">// run within the same binary, each in charge of a different zone. We need to
</span><span class="c1">// make use of wrapping Registerers to be able to register each
</span><span class="c1">// ClusterManagerCollector instance with Prometheus.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ClusterManager</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Zone</span> <span class="kt">string</span>
	<span class="c1">// Contains many more fields not listed in this example.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// ReallyExpensiveAssessmentOfTheSystemState is a mock for the data gathering a
</span><span class="c1">// real cluster manager would have to do. Since it may actually be really
</span><span class="c1">// expensive, it must only be called once per collection. This implementation,
</span><span class="c1">// obviously, only returns some made-up data.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span> <span class="p">(</span>
	<span class="nx">oomCountByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Just example fake data.
</span><span class="c1"></span>	<span class="nx">oomCountByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mi">2001</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ramUsageByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mf">6.023e23</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mf">3.14</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// ClusterManagerCollector implements the Collector interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ClusterManagerCollector</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ClusterManager</span> <span class="o">*</span><span class="nx">ClusterManager</span>
<span class="p">}</span>

<span class="c1">// Descriptors used by the ClusterManagerCollector below.
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">oomCountDesc</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;clustermanager_oom_crashes_total&#34;</span><span class="p">,</span>
		<span class="s">&#34;Number of OOM crashes.&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">)</span>
	<span class="nx">ramUsageDesc</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;clustermanager_ram_usage_bytes&#34;</span><span class="p">,</span>
		<span class="s">&#34;RAM usage as reported to the cluster manager.&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">)</span>
<span class="p">)</span>

<span class="c1">// Describe is implemented with DescribeByCollect. That&#39;s possible because the
</span><span class="c1">// Collect method will always return the same two metrics with the same two
</span><span class="c1">// descriptors.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="nx">ClusterManagerCollector</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">DescribeByCollect</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Collect first triggers the ReallyExpensiveAssessmentOfTheSystemState. Then it
</span><span class="c1">// creates constant metrics for each host on the fly based on the returned data.
</span><span class="c1">//
</span><span class="c1">// Note that Collect could be called concurrently, so we depend on
</span><span class="c1">// ReallyExpensiveAssessmentOfTheSystemState to be concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="nx">ClusterManagerCollector</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">oomCountByHost</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">ClusterManager</span><span class="p">.</span><span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">oomCount</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oomCountByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">oomCountDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterValue</span><span class="p">,</span>
			<span class="nb">float64</span><span class="p">(</span><span class="nx">oomCount</span><span class="p">),</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">ramUsage</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ramUsageByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">ramUsageDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeValue</span><span class="p">,</span>
			<span class="nx">ramUsage</span><span class="p">,</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NewClusterManager first creates a Prometheus-ignorant ClusterManager
</span><span class="c1">// instance. Then, it creates a ClusterManagerCollector for the just created
</span><span class="c1">// ClusterManager. Finally, it registers the ClusterManagerCollector with a
</span><span class="c1">// wrapping Registerer that adds the zone as a label. In this way, the metrics
</span><span class="c1">// collected by different ClusterManagerCollectors do not collide.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="nx">zone</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">reg</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Registerer</span><span class="p">)</span> <span class="o">*</span><span class="nx">ClusterManager</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClusterManager</span><span class="p">{</span>
		<span class="nx">Zone</span><span class="p">:</span> <span class="nx">zone</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">cc</span> <span class="o">:=</span> <span class="nx">ClusterManagerCollector</span><span class="p">{</span><span class="nx">ClusterManager</span><span class="p">:</span> <span class="nx">c</span><span class="p">}</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">WrapRegistererWith</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;zone&#34;</span><span class="p">:</span> <span class="nx">zone</span><span class="p">},</span> <span class="nx">reg</span><span class="p">).</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleCollector</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Since we are dealing with custom Collector implementations, it might
</span><span class="c1"></span>	<span class="c1">// be a good idea to try it out with a pedantic registry.
</span><span class="c1"></span>	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewPedanticRegistry</span><span class="p">()</span>

	<span class="c1">// Construct cluster managers. In real code, we would assign them to
</span><span class="c1"></span>	<span class="c1">// variables to then do something with them.
</span><span class="c1"></span>	<span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;db&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">)</span>
	<span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;ca&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">)</span>

	<span class="c1">// Add the standard process and Go metrics to the custom registry.
</span><span class="c1"></span>	<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewProcessCollector</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">ProcessCollectorOpts</span><span class="p">{}),</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGoCollector</span><span class="p">(),</span>
	<span class="p">)</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">HandlerFor</span><span class="p">(</span><span class="nx">reg</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nx">HandlerOpts</span><span class="p">{}))</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newbuildinfocollector">func NewBuildInfoCollector</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewBuildInfoCollector</span><span class="p">()</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewBuildInfoCollector返回一个收集器，该收集器收集具有恒定值1和三个标签“ path”，“version”和“checksum”的单个度量“ go_build_info”。它们的标签值分别包含主模块路径，版本和校验和。如果二进制文件是通过Go模块支持并从从源存储库（而不是本地文件系统）检索的源代码构建的，则标签将只有有意义的值。通常，这可以通过从GOPATH外部进行构建来完成，并指定主软件包的完整地址，例如“ GO111MODULE = on go run github.com/prometheus/client_golang/examples/random”。如果构建时不支持Go模块，则所有标签值将为“未知”。如果使用Go模块支持构建，但使用本地文件系统的源代码，“path”将被适当设置，但“checksum”将为空，“version”将为“（devel）”。</p>
<p>该收集器仅将构建信息用于主模块。有关模块依赖项的收集器示例，请参见 <a href="https://github.com/povilasv/prommod">https://github.com/povilasv/prommod</a>。</p>
<h2 id="func-newexpvarcollector">func NewExpvarCollector</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewExpvarCollector</span><span class="p">(</span><span class="nx">exports</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Desc</span><span class="p">)</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewExpvarCollector返回一个新分配的expvar收集器，该收集器仍必须在Prometheus注册表中进行注册。</p>
<p>expvar收集器从expvar接口收集指标。它提供了一种快速的方法来公开已经通过expvar导出为Prometheus指标的数值。请注意，expvar和Prometheus的数据模型本质上是不同的，并且expvar Collector本质上比本地Prometheus指标慢。因此，expvar Collector可能非常适合进行实验和原型制作，但是您应该认真考虑更直接地实现PrometheusMetric以监视生产系统。</p>
<p>exports map具有以下含义：</p>
<p>映射中的键对应于expvar键，即对于要导出为PrometheusMetric的每个expvar键，在导出映射中都需要一个条目。映射到每个键的描述符描述了如何导出expvar值。它定义PrometheusMetric的名称和帮助字符串，以替代expvar值。该类型将始终为“无类型”。</p>
<p>对于没有变量标签的描述符，expvar值必须是数字或布尔值。然后将数字直接导出为Prometheus样本值。（对于布尔值，“false”表示0，“ true”表示1）。不是数字或布尔值的Expvar值将被静默忽略。</p>
<p>如果描述符具有一个变量标签，则expvar值必须是一个expvar映射。expvar映射中的键成为一个Prometheus标签的各种值。如上所述，expvar映射中的值必须再次为数字或布尔值。</p>
<p>对于具有多个变量标签的描述符，expvar必须是嵌套的expvar映射，即，最顶部映射的值再次是映射等，直到达到与标签数量相对应的深度。该结构的叶子必须是上面的数字或布尔值，才能用作样本值。</p>
<p>任何不适合上述方案的内容都会被忽略。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">expvarCollector</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewExpvarCollector</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span><span class="p">{</span>
	<span class="s">&#34;memstats&#34;</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;expvar_memstats&#34;</span><span class="p">,</span>
		<span class="s">&#34;All numeric memstats as one metric family. Not a good role-model, actually... ;-)&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;type&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">),</span>
	<span class="s">&#34;lone-int&#34;</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;expvar_lone_int&#34;</span><span class="p">,</span>
		<span class="s">&#34;Just an expvar int as an example.&#34;</span><span class="p">,</span>
		<span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">),</span>
	<span class="s">&#34;http-request-map&#34;</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
		<span class="s">&#34;expvar_http_request_total&#34;</span><span class="p">,</span>
		<span class="s">&#34;How many http requests processed, partitioned by status code and http method.&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">),</span>
<span class="p">})</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">expvarCollector</span><span class="p">)</span>

<span class="c1">// The Prometheus part is done here. But to show that this example is
</span><span class="c1">// doing anything, we have to manually export something via expvar.  In
</span><span class="c1">// real-life use-cases, some library would already have exported via
</span><span class="c1">// expvar what we want to re-export as Prometheus metrics.
</span><span class="c1"></span><span class="nx">expvar</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="s">&#34;lone-int&#34;</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nx">expvarMap</span> <span class="o">:=</span> <span class="nx">expvar</span><span class="p">.</span><span class="nf">NewMap</span><span class="p">(</span><span class="s">&#34;http-request-map&#34;</span><span class="p">)</span>
<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">expvarMap1</span><span class="p">,</span> <span class="nx">expvarMap2</span>                             <span class="nx">expvar</span><span class="p">.</span><span class="nx">Map</span>
	<span class="nx">expvarInt11</span><span class="p">,</span> <span class="nx">expvarInt12</span><span class="p">,</span> <span class="nx">expvarInt21</span><span class="p">,</span> <span class="nx">expvarInt22</span> <span class="nx">expvar</span><span class="p">.</span><span class="nx">Int</span>
<span class="p">)</span>
<span class="nx">expvarMap1</span><span class="p">.</span><span class="nf">Init</span><span class="p">()</span>
<span class="nx">expvarMap2</span><span class="p">.</span><span class="nf">Init</span><span class="p">()</span>
<span class="nx">expvarInt11</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">expvarInt12</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="nx">expvarInt21</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="nx">expvarInt22</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="nx">expvarMap1</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt11</span><span class="p">)</span>
<span class="nx">expvarMap1</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt12</span><span class="p">)</span>
<span class="nx">expvarMap2</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt21</span><span class="p">)</span>
<span class="nx">expvarMap2</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarInt22</span><span class="p">)</span>
<span class="nx">expvarMap</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarMap1</span><span class="p">)</span>
<span class="nx">expvarMap</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expvarMap2</span><span class="p">)</span>
<span class="c1">// Results in the following expvar map:
</span><span class="c1">// &#34;http-request-count&#34;: {&#34;200&#34;: {&#34;POST&#34;: 11, &#34;GET&#34;: 212}, &#34;404&#34;: {&#34;POST&#34;: 3, &#34;GET&#34;: 13}}
</span><span class="c1"></span>
<span class="c1">// Let&#39;s see what the scrape would yield, but exclude the memstats metrics.
</span><span class="c1"></span><span class="nx">metricStrings</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
<span class="nx">metric</span> <span class="o">:=</span> <span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">metricChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">expvarCollector</span><span class="p">.</span><span class="nf">Collect</span><span class="p">(</span><span class="nx">metricChan</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">metricChan</span><span class="p">)</span>
<span class="p">}()</span>
<span class="k">for</span> <span class="nx">m</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">metricChan</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Desc</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34;expvar_memstats&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">metric</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">metric</span><span class="p">)</span>
		<span class="nx">metricStrings</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">metricStrings</span><span class="p">,</span> <span class="nx">metric</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">sort</span><span class="p">.</span><span class="nf">Strings</span><span class="p">(</span><span class="nx">metricStrings</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">metricStrings</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimRight</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;200&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;GET&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">212</span> <span class="p">&gt;</span>
<span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;200&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;POST&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">11</span> <span class="p">&gt;</span>
<span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;404&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;GET&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">13</span> <span class="p">&gt;</span>
<span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;code&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;404&#34;</span> <span class="p">&gt;</span> <span class="nx">label</span><span class="p">:&lt;</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;method&#34;</span> <span class="nx">value</span><span class="p">:</span><span class="s">&#34;POST&#34;</span> <span class="p">&gt;</span> <span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">3</span> <span class="p">&gt;</span>
<span class="nx">untyped</span><span class="p">:&lt;</span><span class="nx">value</span><span class="p">:</span><span class="mi">42</span> <span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newgocollector">func NewGoCollector</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGoCollector</span><span class="p">()</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGoCollector返回一个收集器，该收集器导出有关当前Go流程的指标。这包括内存统计信息。要收集这些内容，将调用runtime.ReadMemStats。这需要“停止世界”，通常仅在垃圾回收（GC）中发生。在决定是否使用Go收集器时，请考虑以下含义：</p>
<p>1.停止世界对性能的影响越重要，收集指标的频率就越高。但是，使用Go1.9或更高版本时，每个指标收集的世界停止时间非常短（〜25µs），因此对性能的影响仅在极少数情况下才重要。但是，对于较旧的Go版本，“停下世界”的持续时间取决于堆的大小，并且可能相当长（根据https://go-review.googlesource.com/c/go/+/，约为1.7 ms / GiB 34937）。</p>
<p>2.在进行中的GC期间，没有其他事情可以阻止世界。因此，如果指标收集恰好与GC一致，则只有在GC完成后才能完成。通常，GC足够快，不会引起问题。但是，对于非常大的堆，GC可能需要花费几秒钟的时间，这足以在常规设置中引起scrape超时。为避免此问题，如果runtime.ReadMemStats花费的时间超过1s，则Go收集器将使用先前集合中的memstats。但是，如果以前没有收集过memstats，或者它们的收集时间超过5m，则收集将阻塞，直到runtime.ReadMemStats成功。（该问题可能会在Go1.13中解决，有关相关的Go问题，请参见https://github.com/golang/go/issues/19812。）</p>
<h2 id="func-newprocesscollector">func NewProcessCollector</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewProcessCollector</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">ProcessCollectorOpts</span><span class="p">)</span> <span class="nx">Collector</span>
</code></pre></td></tr></table>
</div>
</div><p>NewProcessCollector返回一个收集器，该收集器导出过程度量的当前状态，包括CPU，内存和文件描述符的使用情况以及过程开始时间。详细行为由提供的ProcessCollectorOpts定义。ProcessCollectorOpts的零值将为当前进程创建一个收集器，该收集器具有空的名称空间字符串，并且没有错误报告。</p>
<p>收集器仅适用于具有Linux样式proc文件系统的操作系统以及Microsoft Windows。在其他操作系统上，它将不收集任何指标。</p>
<h1 id="type-counter">type Counter</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Inc increments the counter by 1. Use Add to increment it by arbitrary
</span><span class="c1"></span>	<span class="c1">// non-negative values.
</span><span class="c1"></span>	<span class="nf">Inc</span><span class="p">()</span>
	<span class="c1">// Add adds the given value to the counter. It panics if the value is &lt;
</span><span class="c1"></span>	<span class="c1">// 0.
</span><span class="c1"></span>	<span class="nf">Add</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计数器是一种Metric，它表示只会递增的单个数值。这意味着它不能用于计数数量也可能下降的项目，例如当前正在运行的goroutines的数量。这些“计数器”由量规代表。</p>
<p>计数器通常用于对服务的请求，完成的任务，发生的错误等进行计数。</p>
<p>若要创建Counter实例，请使用NewCounter。</p>
<h2 id="func-newcounter">func NewCounter</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounter</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">CounterOpts</span><span class="p">)</span> <span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounter基于提供的CounterOpts创建一个新的Counter。</p>
<p>返回的实现还实现ExemplarAdder。执行相应的类型声明是安全的。</p>
<p>返回的实现在两个单独的变量float64和uint64中跟踪计数器值。后者用于跟踪Inc方法的调用和具有可以表示为uint64的值的Add方法的调用。这使得计数器的原子增量具有最佳性能。（通常在非常热的执行路径中进行Inc调用。）这两个内部跟踪值都在Write方法中相加。当涉及到精度和溢出行为时，必须考虑到这一点。</p>
<h2 id="type-counterfunc">type CounterFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CounterFunc</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CounterFunc是一个Counter，其值在收集时通过调用提供的函数确定。</p>
<p>若要创建CounterFunc实例，请使用NewCounterFunc。</p>
<h2 id="func-newcounterfunc">func NewCounterFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounterFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">CounterFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterFunc基于提供的CounterOpts创建一个新的CounterFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。如果这导致对Write的并发调用，例如将CounterFunc直接注册到Prometheus的情况，则提供的函数必须是并发安全的。该功能还应遵守计数器合同（值只会上升，不会下降），但不会检查合规性。</p>
<p>查看类似的GaugeFunc的ExampleGaugeFunc示例。</p>
<h1 id="type-counteropts">type CounterOpts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CounterOpts</span> <span class="nx">Opts</span>
</code></pre></td></tr></table>
</div>
</div><p>CounterOpts是Opts的别名。请参阅此处以获取文档注释。</p>
<h1 id="type-countervec">type CounterVec</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CounterVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CounterVec是一个收集器，捆绑了一组共享相同Desc，但其变量标签具有不同值的Counter。如果您要计算按不同维度划分的同一事物（例如，HTTP请求的数量，按响应代码和方法划分的），则使用此方法。使用NewCounterVec创建实例。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">httpReqs</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewCounterVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;http_requests_total&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;How many HTTP requests processed, partitioned by status code and HTTP method.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
<span class="p">)</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">httpReqs</span><span class="p">)</span>

<span class="nx">httpReqs</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;POST&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1">// If you have to access the same set of labels very frequently, it
</span><span class="c1">// might be good to retrieve the metric only once and keep a handle to
</span><span class="c1">// it. But beware of deletion of that metric, see below!
</span><span class="c1"></span><span class="nx">m</span> <span class="o">:=</span> <span class="nx">httpReqs</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// Delete a metric from the vector. If you have previously kept a handle
</span><span class="c1">// to that metric (as above), future updates via that handle will go
</span><span class="c1">// unseen (even if you re-create a metric with the same label set
</span><span class="c1">// later).
</span><span class="c1"></span><span class="nx">httpReqs</span><span class="p">.</span><span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">)</span>
<span class="c1">// Same thing with the more verbose Labels syntax.
</span><span class="c1"></span><span class="nx">httpReqs</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;200&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newcountervec">func NewCounterVec</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCounterVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">CounterOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">CounterVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewCounterVec基于提供的CounterOpts创建新的CounterVec，并按给定的标签名称进行分区。</p>
<h2 id="func-countervec-collect">func (CounterVec) Collect</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Collect 实现 Collector.</p>
<h2 id="func-countervec-currywith">func (*CounterVec) CurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">CounterVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>CounterVec中包含的度量在已管理和未已管理向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h2 id="func-countervec-delete">func (CounterVec) Delete</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Delete会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-countervec-deletelabelvalues">func (CounterVec) DeleteLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h2 id="func-countervec-describe">func (CounterVec) Describe</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Describe 实现 Collector.</p>
<h2 id="func-countervec-getmetricwith">func (*CounterVec) GetMetricWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Counter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定Labels映射的Counter（标签名称必须与Desc中的VariableLabels的名称匹配）。如果是第一次访问该标签映射，则会创建一个新的计数器。不使用计数器创建计数器并保留该计数器供以后使用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-countervec-getmetricwithlabelvalues">func (*CounterVec) GetMetricWithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Counter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的计数器（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的计数器。</p>
<p>可以调用此方法而无需使用返回的Counter来仅创建新的Counter，而将其保留为起始值0。另请参见SummaryVec示例。</p>
<p>可以保留Counter以便以后使用（如果性能至关重要，则应考虑使用），但是请记住，可以使用Reset，DeleteLabelValues和Delete从CounterVec删除Counter。在这种情况下，即使以后创建具有相同标签值的计数器，该计数器仍将存在，但不再导出。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。</p>
<h2 id="func-countervec-mustcurrywith">func (*CounterVec) MustCurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="o">*</span><span class="nx">CounterVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现panic。</p>
<h2 id="func-countervec-reset">func (CounterVec) Reset</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h2 id="func-countervec-with">func (*CounterVec) With</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-countervec-withlabelvalues">func (*CounterVec) WithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">CounterVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Counter</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-gauge">type Gauge</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Gauge</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Set sets the Gauge to an arbitrary value.
</span><span class="c1"></span>	<span class="nf">Set</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="c1">// Inc increments the Gauge by 1. Use Add to increment it by arbitrary
</span><span class="c1"></span>	<span class="c1">// values.
</span><span class="c1"></span>	<span class="nf">Inc</span><span class="p">()</span>
	<span class="c1">// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary
</span><span class="c1"></span>	<span class="c1">// values.
</span><span class="c1"></span>	<span class="nf">Dec</span><span class="p">()</span>
	<span class="c1">// Add adds the given value to the Gauge. (The value can be negative,
</span><span class="c1"></span>	<span class="c1">// resulting in a decrease of the Gauge.)
</span><span class="c1"></span>	<span class="nf">Add</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="c1">// Sub subtracts the given value from the Gauge. (The value can be
</span><span class="c1"></span>	<span class="c1">// negative, resulting in an increase of the Gauge.)
</span><span class="c1"></span>	<span class="nf">Sub</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>

	<span class="c1">// SetToCurrentTime sets the Gauge to the current Unix time in seconds.
</span><span class="c1"></span>	<span class="nf">SetToCurrentTime</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Gauge是一种Metric，代表可以任意增加和减少的单个数值。</p>
<p>仪表通常用于测量值，例如温度或当前的内存使用情况，还用于可能上升和下降的“计数”，例如正在运行的goroutine的数量。</p>
<p>要创建仪表实例，请使用NewGauge。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">opsQueued</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
	<span class="nx">Namespace</span><span class="p">:</span> <span class="s">&#34;our_company&#34;</span><span class="p">,</span>
	<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;blob_storage&#34;</span><span class="p">,</span>
	<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;ops_queued&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Number of blob storage operations waiting to be processed.&#34;</span><span class="p">,</span>
<span class="p">})</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">opsQueued</span><span class="p">)</span>

<span class="c1">// 10 operations queued by the goroutine managing incoming requests.
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1">// A worker goroutine has picked up a waiting operation.
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">Dec</span><span class="p">()</span>
<span class="c1">// And once more...
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">Dec</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newgauge">func NewGauge</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGauge</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">GaugeOpts</span><span class="p">)</span> <span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGauge根据提供的GaugeOpts创建一个新的Gauge。</p>
<p>返回的实现针对快速Set方法进行了优化。如果您可以选择通过Set vs.Inc/Dec/Add/Sub来管理仪表的值，请选择前者。例如，返回的仪表的Inc方法比NewCounter返回的Counter的Inc方法慢。这与“Gauges”和“Counters”的典型方案相符，前者倾向于“重置类重载”，而后者倾向于“增加类重载”。</p>
<h2 id="type-gaugefunc">type GaugeFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GaugeFunc</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>GaugeFunc是一个Gauge，其值是在收集时通过调用提供的函数确定的。</p>
<p>要创建GaugeFunc实例，请使用NewGaugeFunc。</p>
<p>示例（ConstLabels）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// primaryDB and secondaryDB represent two example *sql.DB connections we want to instrument.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">primaryDB</span><span class="p">,</span> <span class="nx">secondaryDB</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Stats</span><span class="p">()</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">OpenConnections</span> <span class="kt">int</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeFunc</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Namespace</span><span class="p">:</span>   <span class="s">&#34;mysql&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>        <span class="s">&#34;connections_open&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>        <span class="s">&#34;Number of mysql connections open.&#34;</span><span class="p">,</span>
		<span class="nx">ConstLabels</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;destination&#34;</span><span class="p">:</span> <span class="s">&#34;primary&#34;</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">primaryDB</span><span class="p">.</span><span class="nf">Stats</span><span class="p">().</span><span class="nx">OpenConnections</span><span class="p">)</span> <span class="p">},</span>
<span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">`GaugeFunc &#39;connections_open&#39; for primary DB connection registered with labels {destination=&#34;primary&#34;}`</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeFunc</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Namespace</span><span class="p">:</span>   <span class="s">&#34;mysql&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>        <span class="s">&#34;connections_open&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>        <span class="s">&#34;Number of mysql connections open.&#34;</span><span class="p">,</span>
		<span class="nx">ConstLabels</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;destination&#34;</span><span class="p">:</span> <span class="s">&#34;secondary&#34;</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">secondaryDB</span><span class="p">.</span><span class="nf">Stats</span><span class="p">().</span><span class="nx">OpenConnections</span><span class="p">)</span> <span class="p">},</span>
<span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">`GaugeFunc &#39;connections_open&#39; for secondary DB connection registered with labels {destination=&#34;secondary&#34;}`</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Note that we can register more than once GaugeFunc with same metric name
</span><span class="c1">// as long as their const labels are consistent.
</span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GaugeFunc &#39;connections_open&#39; for primary DB connection registered with labels {destination=&#34;primary&#34;}
GaugeFunc &#39;connections_open&#39; for secondary DB connection registered with labels {destination=&#34;secondary&#34;}
</code></pre></td></tr></table>
</div>
</div><p>示例（简单）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeFunc</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;runtime&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;goroutines_count&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Number of goroutines that currently exist.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span> <span class="p">},</span>
<span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;GaugeFunc &#39;goroutines_count&#39; registered.&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Note that the count of goroutines is a gauge (and not a counter) as
</span><span class="c1">// it can go up and down.
</span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GaugeFunc &#39;goroutines_count&#39; registered.
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newgaugefunc">func NewGaugeFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGaugeFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">GaugeFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeFunc基于提供的GaugeOpts创建一个新的GaugeFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。因此，必须安全地同时调用提供的函数。</p>
<p>NewGaugeFunc是创建常量值为1的“信息”风格指标的好方法。示例：https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56</p>
<h1 id="type-gaugeopts">type GaugeOpts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GaugeOpts</span> <span class="nx">Opts</span>
</code></pre></td></tr></table>
</div>
</div><p>GaugeOpts是Opts的别名。请参阅此处以获取文档注释。</p>
<h1 id="type-gaugevec">type GaugeVec</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GaugeVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>GaugeVec是一个收集器，它捆绑了一组共享相同Desc，但其变量标签具有不同值的Gauge。如果要统计按不同维度划分的同一事物（例如，排队的操作数，按用户和操作类型划分的分区），则使用此方法。使用NewGaugeVec创建实例。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">opsQueued</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Namespace</span><span class="p">:</span> <span class="s">&#34;our_company&#34;</span><span class="p">,</span>
		<span class="nx">Subsystem</span><span class="p">:</span> <span class="s">&#34;blob_storage&#34;</span><span class="p">,</span>
		<span class="nx">Name</span><span class="p">:</span>      <span class="s">&#34;ops_queued&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>      <span class="s">&#34;Number of blob storage operations waiting to be processed, partitioned by user and type.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
		<span class="c1">// Which user has requested the operation?
</span><span class="c1"></span>		<span class="s">&#34;user&#34;</span><span class="p">,</span>
		<span class="c1">// Of what type is the operation?
</span><span class="c1"></span>		<span class="s">&#34;type&#34;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">)</span>
<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">opsQueued</span><span class="p">)</span>

<span class="c1">// Increase a value using compact (but order-sensitive!) WithLabelValues().
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;bob&#34;</span><span class="p">,</span> <span class="s">&#34;put&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1">// Increase a value with a map using WithLabels. More verbose, but order
</span><span class="c1">// doesn&#39;t matter anymore.
</span><span class="c1"></span><span class="nx">opsQueued</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;delete&#34;</span><span class="p">,</span> <span class="s">&#34;user&#34;</span><span class="p">:</span> <span class="s">&#34;alice&#34;</span><span class="p">}).</span><span class="nf">Inc</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-newgaugevec">func NewGaugeVec</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewGaugeVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">GaugeOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">GaugeVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewGaugeVec基于提供的GaugeOpts创建新的GaugeVec，并按给定的标签名称进行分区。</p>
<h2 id="func-gaugevec-collect">func (GaugeVec) Collect</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Collect 实现 Collector.</p>
<h2 id="func-gaugevec-currywith">func (*GaugeVec) CurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">GaugeVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>GaugeVec中包含的Metric在已固化和未固化向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h2 id="func-gaugevec-delete">func (GaugeVec) Delete</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-gaugevec-deletelabelvalues">func (GaugeVec) DeleteLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h2 id="func-gaugevec-describe">func (GaugeVec) Describe</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span>
</code></pre></td></tr></table>
</div>
</div><p>Describe 实现 Collector.</p>
<h2 id="func-gaugevec-getmetricwith">func (*GaugeVec) GetMetricWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Gauge</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定Labels映射的Gauge（标签名称必须与Desc中的VariableLabels的名称匹配）。如果是第一次访问该标签图，则会创建一个新的Gauge。不使用仪表创建仪表并保留仪表以备后用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-gaugevec-getmetricwithlabelvalues">func (*GaugeVec) GetMetricWithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Gauge</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的量规（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的仪表。</p>
<p>可以在不使用返回的Gauge的情况下调用此方法，仅创建新的Gauge，而将其保留为初始值0。另请参见SummaryVec示例。</p>
<p>可以保留仪表以备后用（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从GaugeVec删除仪表。在这种情况下，即使以后创建具有相同标签值的仪表，该仪表仍将存在，但将不再导出。另请参见CounterVec示例。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。</p>
<h2 id="func-gaugevec-mustcurrywith">func (*GaugeVec) MustCurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="o">*</span><span class="nx">GaugeVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。</p>
<h2 id="func-gaugevec-reset">func (GaugeVec) Reset</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h2 id="func-gaugevec-with">func (*GaugeVec) With</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-gaugevec-withlabelvalues">func (*GaugeVec) WithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">GaugeVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Gauge</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-histogram">type Histogram</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Histogram</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Observe adds a single observation to the histogram.
</span><span class="c1"></span>	<span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>直方图计算来自事件或样本流的可配置存储桶中的单个观察值。与摘要类似，它也提供观察值的总和和观察值。</p>
<p>在Prometheus服务器上，可以使用查询语言中的histogram_quantile函数从直方图计算分位数。</p>
<p>请注意，与摘要相比，直方图可以与Prometheus查询语言进行汇总（有关详细过程，请参见文档）。但是，直方图要求用户预先定义合适的bucket，并且通常精度较低。与摘要的Observe方法相比，直方图的Observe方法具有非常低的性能开销。</p>
<p>要创建直方图实例，请使用NewHistogram。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">temps</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;pond_temperature_celsius&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;The temperature of the frog pond.&#34;</span><span class="p">,</span> <span class="c1">// Sorry, we can&#39;t measure how badly it smells.
</span><span class="c1"></span>	<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>  <span class="c1">// 5 buckets, each 5 centigrade wide.
</span><span class="c1"></span><span class="p">})</span>

<span class="c1">// Simulate some observations.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">120</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the histogram by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">temps</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">histogram: &lt;
  sample_count: 1000
  sample_sum: 29969.50000000001
  bucket: &lt;
    cumulative_count: 192
    upper_bound: 20
  &gt;
  bucket: &lt;
    cumulative_count: 366
    upper_bound: 25
  &gt;
  bucket: &lt;
    cumulative_count: 501
    upper_bound: 30
  &gt;
  bucket: &lt;
    cumulative_count: 638
    upper_bound: 35
  &gt;
  bucket: &lt;
    cumulative_count: 816
    upper_bound: 40
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newhistogram">func NewHistogram</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">HistogramOpts</span><span class="p">)</span> <span class="nx">Histogram</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogram基于提供的HistogramOpts创建新的直方图。如果HistogramOpts中的存储桶未严格按升序排序，则会感到恐慌。</p>
<p>返回的实现还实现ExemplarObserver。执行相应的类型声明是安全的。分别跟踪每个存储桶的示例。</p>
<h1 id="type-histogramopts">type HistogramOpts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HistogramOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Namespace, Subsystem, and Name are components of the fully-qualified
</span><span class="c1"></span>	<span class="c1">// name of the Histogram (created by joining these components with
</span><span class="c1"></span>	<span class="c1">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the
</span><span class="c1"></span>	<span class="c1">// name. Note that the fully-qualified name of the Histogram must be a
</span><span class="c1"></span>	<span class="c1">// valid Prometheus metric name.
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="nx">Subsystem</span> <span class="kt">string</span>
	<span class="nx">Name</span>      <span class="kt">string</span>

	<span class="c1">// Help provides information about this Histogram.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metrics with the same fully-qualified name must have the same Help
</span><span class="c1"></span>	<span class="c1">// string.
</span><span class="c1"></span>	<span class="nx">Help</span> <span class="kt">string</span>

	<span class="c1">// ConstLabels are used to attach fixed labels to this metric. Metrics
</span><span class="c1"></span>	<span class="c1">// with the same fully-qualified name must have the same label names in
</span><span class="c1"></span>	<span class="c1">// their ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ConstLabels are only used rarely. In particular, do not use them to
</span><span class="c1"></span>	<span class="c1">// attach the same labels to all your metrics. Those use cases are
</span><span class="c1"></span>	<span class="c1">// better covered by target labels set by the scraping Prometheus
</span><span class="c1"></span>	<span class="c1">// server, or by one specific metric (e.g. a build_info or a
</span><span class="c1"></span>	<span class="c1">// machine_role metric). See also
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels
</span><span class="c1"></span>	<span class="nx">ConstLabels</span> <span class="nx">Labels</span>

	<span class="c1">// Buckets defines the buckets into which observations are counted. Each
</span><span class="c1"></span>	<span class="c1">// element in the slice is the upper inclusive bound of a bucket. The
</span><span class="c1"></span>	<span class="c1">// values must be sorted in strictly increasing order. There is no need
</span><span class="c1"></span>	<span class="c1">// to add a highest bucket with +Inf bound, it will be added
</span><span class="c1"></span>	<span class="c1">// implicitly. The default value is DefBuckets.
</span><span class="c1"></span>	<span class="nx">Buckets</span> <span class="p">[]</span><span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HistogramOpts捆绑了用于创建直方图度量的选项。必须将Name设置为非空字符串。尽管强烈建议您设置帮助字符串，但所有其他字段都是可选的，可以安全地保留其零值。</p>
<h1 id="type-histogramvec">type HistogramVec</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HistogramVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HistogramVec是一个收集器，它捆绑一组直方图，这些直方图共享相同的Desc，但是其变量标签具有不同的值。如果要计算按不同维度划分的同一事物（例如，HTTP请求等待时间，按状态代码和方法划分的分区），则使用此方法。使用NewHistogramVec创建实例。</p>
<h2 id="func-newhistogramvec">func NewHistogramVec</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewHistogramVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">HistogramOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">HistogramVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewHistogramVec基于提供的HistogramOpts创建一个新的HistogramVec，并按给定的标签名称进行分区。</p>
<h2 id="func-histogramvec-collect">func (HistogramVec) Collect</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Collect 实现 Collector.</p>
<h2 id="func-histogramvec-currywith">func (*HistogramVec) CurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>HistogramVec中包含的度量在已固化和未固化向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h2 id="func-histogramvec-delete">func (HistogramVec) Delete</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-histogramvec-deletelabelvalues">func (HistogramVec) DeleteLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h2 id="func-histogramvec-describe">func (HistogramVec) Describe</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Describe 实现 Collector.</p>
<h2 id="func-histogramvec-getmetricwith">func (*HistogramVec) GetMetricWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定Labels映射的直方图（标签名称必须与Desc中的VariableLabel的名称匹配）。如果是第一次访问该标签图，则会创建一个新的直方图。不使用直方图创建直方图并保留直方图供以后使用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-histogramvec-getmetricwithlabelvalues">func (*HistogramVec) GetMetricWithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的直方图（与Desc中的VariableLabels顺序相同）。如果第一次访问标签值的组合，则会创建一个新的直方图。</p>
<p>可以在不使用返回的直方图的情况下调用此方法，仅创建新的直方图，而将其保留为初始值，即没有任何观察值的直方图。</p>
<p>可以保留直方图供以后使用（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从HistogramVec中删除直方图。在这种情况下，即使以后创建具有相同标签值的直方图，直方图仍将存在，但将不再导出。另请参见CounterVec示例。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。</p>
<h2 id="func-histogramvec-mustcurrywith">func (*HistogramVec) MustCurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">ObserverVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。</p>
<h2 id="func-histogramvec-reset">func (HistogramVec) Reset</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h2 id="func-histogramvec-with">func (*HistogramVec) With</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-histogramvec-withlabelvalues">func (*HistogramVec) WithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">HistogramVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-summary">type Summary</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Summary</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>

	<span class="c1">// Observe adds a single observation to the summary.
</span><span class="c1"></span>	<span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>摘要可从事件或样本流中捕获单个观察值，并以类似于传统摘要统计的方式对其进行摘要：1.观察值总和，2。观察值，3。排名估计。</p>
<p>一个典型的用例是观察请求延迟。默认情况下，摘要提供延迟的中位数，第90％和第99％作为等级估计。但是，默认行为将在即将发布的库v1.0.0中更改。默认情况下，将不会有任何排名估计。对于合理的过渡，建议明确设置所需的排名估计。</p>
<p>请注意，排名估计不能使用Prometheus查询语言以有意义的方式进行汇总（即，您不能对它们进行平均或相加）。如果您需要可汇总的分位数（例如，您希望跨服务的所有实例进行的所有查询的第99个百分位数的延迟），请考虑直方图度量类型。有关更多详细信息，请参见Prometheus文档。</p>
<p>若要创建摘要实例，请使用NewSummary。</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">temps</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewSummary</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">{</span>
	<span class="nx">Name</span><span class="p">:</span>       <span class="s">&#34;pond_temperature_celsius&#34;</span><span class="p">,</span>
	<span class="nx">Help</span><span class="p">:</span>       <span class="s">&#34;The temperature of the frog pond.&#34;</span><span class="p">,</span>
	<span class="nx">Objectives</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">},</span>
<span class="p">})</span>

<span class="c1">// Simulate some observations.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">120</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the summary by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">temps</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">summary: &lt;
  sample_count: 1000
  sample_sum: 29969.50000000001
  quantile: &lt;
    quantile: 0.5
    value: 31.1
  &gt;
  quantile: &lt;
    quantile: 0.9
    value: 41.3
  &gt;
  quantile: &lt;
    quantile: 0.99
    value: 41.9
  &gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newsummary">func NewSummary</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummary</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">SummaryOpts</span><span class="p">)</span> <span class="nx">Summary</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummary基于提供的SummaryOpts创建一个新的Summary。</p>
<h1 id="type-summaryopts">type SummaryOpts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SummaryOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Namespace, Subsystem, and Name are components of the fully-qualified
</span><span class="c1"></span>	<span class="c1">// name of the Summary (created by joining these components with
</span><span class="c1"></span>	<span class="c1">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the
</span><span class="c1"></span>	<span class="c1">// name. Note that the fully-qualified name of the Summary must be a
</span><span class="c1"></span>	<span class="c1">// valid Prometheus metric name.
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="nx">Subsystem</span> <span class="kt">string</span>
	<span class="nx">Name</span>      <span class="kt">string</span>

	<span class="c1">// Help provides information about this Summary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metrics with the same fully-qualified name must have the same Help
</span><span class="c1"></span>	<span class="c1">// string.
</span><span class="c1"></span>	<span class="nx">Help</span> <span class="kt">string</span>

	<span class="c1">// ConstLabels are used to attach fixed labels to this metric. Metrics
</span><span class="c1"></span>	<span class="c1">// with the same fully-qualified name must have the same label names in
</span><span class="c1"></span>	<span class="c1">// their ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Due to the way a Summary is represented in the Prometheus text format
</span><span class="c1"></span>	<span class="c1">// and how it is handled by the Prometheus server internally, “quantile”
</span><span class="c1"></span>	<span class="c1">// is an illegal label name. Construction of a Summary or SummaryVec
</span><span class="c1"></span>	<span class="c1">// will panic if this label name is used in ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ConstLabels are only used rarely. In particular, do not use them to
</span><span class="c1"></span>	<span class="c1">// attach the same labels to all your metrics. Those use cases are
</span><span class="c1"></span>	<span class="c1">// better covered by target labels set by the scraping Prometheus
</span><span class="c1"></span>	<span class="c1">// server, or by one specific metric (e.g. a build_info or a
</span><span class="c1"></span>	<span class="c1">// machine_role metric). See also
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels,-not-static-scraped-labels
</span><span class="c1"></span>	<span class="nx">ConstLabels</span> <span class="nx">Labels</span>

	<span class="c1">// Objectives defines the quantile rank estimates with their respective
</span><span class="c1"></span>	<span class="c1">// absolute error. If Objectives[q] = e, then the value reported for q
</span><span class="c1"></span>	<span class="c1">// will be the φ-quantile value for some φ between q-e and q+e.  The
</span><span class="c1"></span>	<span class="c1">// default value is an empty map, resulting in a summary without
</span><span class="c1"></span>	<span class="c1">// quantiles.
</span><span class="c1"></span>	<span class="nx">Objectives</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span>

	<span class="c1">// MaxAge defines the duration for which an observation stays relevant
</span><span class="c1"></span>	<span class="c1">// for the summary. Must be positive. The default value is DefMaxAge.
</span><span class="c1"></span>	<span class="nx">MaxAge</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// AgeBuckets is the number of buckets used to exclude observations that
</span><span class="c1"></span>	<span class="c1">// are older than MaxAge from the summary. A higher number has a
</span><span class="c1"></span>	<span class="c1">// resource penalty, so only increase it if the higher resolution is
</span><span class="c1"></span>	<span class="c1">// really required. For very high observation rates, you might want to
</span><span class="c1"></span>	<span class="c1">// reduce the number of age buckets. With only one age bucket, you will
</span><span class="c1"></span>	<span class="c1">// effectively see a complete reset of the summary each time MaxAge has
</span><span class="c1"></span>	<span class="c1">// passed. The default value is DefAgeBuckets.
</span><span class="c1"></span>	<span class="nx">AgeBuckets</span> <span class="kt">uint32</span>

	<span class="c1">// BufCap defines the default sample stream buffer size.  The default
</span><span class="c1"></span>	<span class="c1">// value of DefBufCap should suffice for most uses. If there is a need
</span><span class="c1"></span>	<span class="c1">// to increase the value, a multiple of 500 is recommended (because that
</span><span class="c1"></span>	<span class="c1">// is the internal buffer size of the underlying package
</span><span class="c1"></span>	<span class="c1">// &#34;github.com/bmizerany/perks/quantile&#34;).
</span><span class="c1"></span>	<span class="nx">BufCap</span> <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SummaryOpts捆绑了用于创建“摘要”指标的选项。必须将Name设置为非空字符串。尽管所有其他字段都是可选的，并且可以安全地保留为零值，但是建议设置帮助字符串并将“ Objectives”字段明确设置为所需值，因为默认值将在库的即将发布的v1.0.0中更改。</p>
<h1 id="type-summaryvec">type SummaryVec</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SummaryVec</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SummaryVec是一个收集器，捆绑了一组共享相同的Desc，但其变量标签具有不同值的摘要。如果要计算按不同维度划分的同一事物（例如，HTTP请求等待时间，按状态代码和方法划分的分区），则使用此方法。使用NewSummaryVec创建实例。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">temps</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewSummaryVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">SummaryOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>       <span class="s">&#34;pond_temperature_celsius&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>       <span class="s">&#34;The temperature of the frog pond.&#34;</span><span class="p">,</span>
		<span class="nx">Objectives</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;species&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Simulate some observations.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;litoria-caerulea&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">120</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">temps</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;lithobates-catesbeianus&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">32</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.11</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Create a Summary without any observations.
</span><span class="c1"></span><span class="nx">temps</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;leiopelma-hochstetteri&#34;</span><span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the summary vector
</span><span class="c1">// by registering it with a custom registry and then let it collect the
</span><span class="c1">// metrics.
</span><span class="c1"></span><span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewRegistry</span><span class="p">()</span>
<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">temps</span><span class="p">)</span>

<span class="nx">metricFamilies</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">Gather</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">metricFamilies</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unexpected behavior of custom test registry&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metricFamilies</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">name: &#34;pond_temperature_celsius&#34;
help: &#34;The temperature of the frog pond.&#34;
type: SUMMARY
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;leiopelma-hochstetteri&#34;
  &gt;
  summary: &lt;
    sample_count: 0
    sample_sum: 0
    quantile: &lt;
      quantile: 0.5
      value: nan
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: nan
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: nan
    &gt;
  &gt;
&gt;
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;lithobates-catesbeianus&#34;
  &gt;
  summary: &lt;
    sample_count: 1000
    sample_sum: 31956.100000000017
    quantile: &lt;
      quantile: 0.5
      value: 32.4
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: 41.4
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: 41.9
    &gt;
  &gt;
&gt;
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;litoria-caerulea&#34;
  &gt;
  summary: &lt;
    sample_count: 1000
    sample_sum: 29969.50000000001
    quantile: &lt;
      quantile: 0.5
      value: 31.1
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: 41.3
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: 41.9
    &gt;
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newsummaryvec">func NewSummaryVec</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewSummaryVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">SummaryOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">SummaryVec</span>
</code></pre></td></tr></table>
</div>
</div><p>NewSummaryVec基于提供的SummaryOpts创建一个新的SummaryVec，并按给定的标签名称进行分区。</p>
<p>由于摘要以Prometheus文本格式表示的方式以及Prometheus服务器在内部如何处理摘要，因此“quantile”是非法的标签名称。如果使用此标签名称，NewSummaryVec将惊慌。</p>
<h2 id="func-summaryvec-collect">func (SummaryVec) Collect</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>收集器收集器。</p>
<h2 id="func-summaryvec-currywith">func (*SummaryVec) CurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>CurryWith返回使用提供的标签进行咖喱处理的向量，即返回的向量具有针对其执行的所有标记操作预先设置的那些标签。相应地减小了咖喱矢量的基数。其余标签的顺序保持不变（只是将咖喱标签从序列中取出，这与（GetMetric）WithLabelValues方法有关）。可以咖喱咖喱的矢量，但只能使用之前尚未用于咖喱的标签。</p>
<p>SummaryVec中包含的度量在已管理和未已管理向量之间共享。只是以不同的方式访问它们。在集合方面，咖喱和非咖喱向量的行为相同。必须在给定的注册表中注册一个（通常是未更新的版本）。即使对当前向量调用了Reset方法，Reset方法也会删除所有指标。</p>
<h2 id="func-summaryvec-delete">func (SummaryVec) Delete</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>删除会删除指标，其中变量标签与作为标签传入的标签相同。如果删除了指标，则返回true。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致，则不是错误。但是，此类不一致的标签永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>此方法与DeleteLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-summaryvec-deletelabelvalues">func (SummaryVec) DeleteLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>DeleteLabelValues删除Metric，其中变量标签与作为标签传入的变量相同（与Desc中的VariableLabel顺序相同）。如果删除了指标，则返回true。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量不同，这不是错误。但是，这种不一致的标签计数永远无法与实际指标匹配，因此在这种情况下该方法将始终返回false。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用Delete（Labels）来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见CounterVec示例。</p>
<h2 id="func-summaryvec-describe">func (SummaryVec) Describe</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>描述工具收集器。</p>
<h2 id="func-summaryvec-getmetricwith">func (*SummaryVec) GetMetricWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWith返回给定标签映射的摘要（标签名称必须与Desc中的VariableLabel的名称匹配）。如果是第一次访问该标签图，则会创建一个新的摘要。不使用摘要创建摘要并保留摘要供以后使用的含义与GetMetricWithLabelValues相同。</p>
<p>如果标签的编号和名称与Desc中的VariableLabel的编号和名称不一致（减去任何已处理的标签），则会返回错误。</p>
<p>此方法与GetMetricWithLabelValues（&hellip; string）的用途相同。有关两种方法的优缺点，请参见此处。</p>
<h2 id="func-summaryvec-getmetricwithlabelvalues">func (*SummaryVec) GetMetricWithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GetMetricWithLabelValues返回给定标签值切片的摘要（与Desc中的VariableLabels顺序相同）。如果是第一次访问标签值的组合，则会创建一个新的摘要。</p>
<p>可以在不使用返回的Summary的情况下调用此方法，仅创建新的Summary，而将其保留为初始值，即没有任何观察值的Summary。</p>
<p>保留摘要以备后用是可能的（如果性能至关重要，则应考虑使用），但请记住，可以使用Reset，DeleteLabelValues和Delete从SummaryVec中删除摘要。在这种情况下，即使稍后创建具有相同标签值的摘要，摘要仍将存在，但不再导出。另请参见CounterVec示例。</p>
<p>如果标签值的数量与Desc中的VariableLabels的数量（减去任何已固化的标签）不同，则返回错误。</p>
<p>请注意，对于多个标签值，此方法很容易因参数顺序错误而导致错误。考虑使用GetMetricWith（Labels）作为替代方案来避免这种类型的错误。对于更高的标签编号，后者具有更易读（尽管更冗长）的语法，但是它会带来性能开销（用于创建和处理Labels映射）。另请参见GaugeVec示例。</p>
<h2 id="func-summaryvec-mustcurrywith">func (*SummaryVec) MustCurryWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">ObserverVec</span>
</code></pre></td></tr></table>
</div>
</div><p>MustCurryWith可以作为CurryWith使用，但在CurryWith会返回错误的情况下会出现混乱。</p>
<h2 id="func-summaryvec-reset">func (SummaryVec) Reset</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>重置将删除此向量中的所有指标。</p>
<h2 id="func-summaryvec-with">func (*SummaryVec) With</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>With与GetMetricWith一样工作，但在GetMetricWithLabels会返回错误的地方感到慌张。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-summaryvec-withlabelvalues">func (*SummaryVec) WithLabelValues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">SummaryVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Observer</span>
</code></pre></td></tr></table>
</div>
</div><p>WithLabelValues可以用作GetMetricWithLabelValues，但是在GetMetricWithLabelValues会返回错误的地方出现混乱。不返回错误允许使用以下快捷方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="mf">42.21</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-desc">type Desc</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Desc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Desc是每个Prometheus指标使用的描述符。它本质上是Metric的不可变元数据。此程序包中包含的常规Metric实现在后台管理其Desc。如果用户使用诸​​如ExpvarCollector或自定义收集器和Metric之类的高级功能，则仅需处理Desc。</p>
<p>如果在相同的注册表中注册的描述符共享相同的完全限定名称，则它们必须满足某些一致性和唯一性条件：constLabels和variableLabels的描述符必须具有相同的帮助字符串和相同的标签名称（即标签尺寸），但是constLabels的值必须不同。</p>
<p>共享相同常量名称和constLabel相同标签值的描述符被视为相等。</p>
<p>使用NewDesc创建新的Desc实例。</p>
<h2 id="func-newdesc">func NewDesc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewDesc</span><span class="p">(</span><span class="nx">fqName</span><span class="p">,</span> <span class="nx">help</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">variableLabels</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">constLabels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="o">*</span><span class="nx">Desc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewDesc分配并初始化新的Desc。错误记录在Desc中，并将在注册时间报告。如果不应该设置这样的标签，variableLabels和constLabels可以为nil。fqName不能为空。</p>
<p>variableLabels仅包含标签名称。它们的标签值是可变的，因此不是Desc的一部分。（它们在Metric内管理。）</p>
<p>对于constLabels，标签值是恒定的。因此，它们在“描述”中已完全指定。有关用法模式，请参见收集器示例。</p>
<h2 id="func-newinvaliddesc">func NewInvalidDesc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewInvalidDesc</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="o">*</span><span class="nx">Desc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewInvalidDesc返回无效的描述符，即具有提供的错误集的描述符。如果注册了返回此类描述符的收集器，则注册将失败，并显示所提供的错误。收集器可以使用NewInvalidDesc来表示无法描述自己。</p>
<h2 id="func-desc-string">func (*Desc) String</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-exemplaradder">type ExemplarAdder</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ExemplarAdder</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">AddWithExemplar</span><span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">exemplar</span> <span class="nx">Labels</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ExemplarAdder由Counters实现，Counter提供了与示例一起向Counter添加值的选项。它的AddWithExemplar方法的工作方式与Counter接口的Add方法类似，但是也用新的（由提供的值，当前时间作为时间戳记和提供的标签）创建的新示例替换了当前保存的示例（如果有）。空标签将导致有效的（无标签）示例。但是，如果Labels为nil，则当前示例保留不变。如果值&lt;0，提供的任何标签无效或提供的标签总共包含64个以上符文，则AddWithExemplar会发生混乱。</p>
<h1 id="type-exemplarobserver">type ExemplarObserver</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ExemplarObserver</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">ObserveWithExemplar</span><span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">exemplar</span> <span class="nx">Labels</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ExemplarObserver由观察者实现，该观察者提供了与示例一起观察值的选项。它的ObserveWithExemplar方法的工作方式类似于Observer的Observe方法，但也用新的（由提供的值，当前时间作为时间戳记和提供的Label）创建的新示例替换了当前保存的示例（如果有）。空标签将导致有效的（无标签）示例。但是，如果Labels为nil，则当前示例保留不变。如果提供的任何标签无效或提供的标签总共包含64个以上符文，则ObserveWithExemplar会发生混乱。</p>
<h1 id="type-gatherer">type Gatherer</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Gatherer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Gather calls the Collect method of the registered Collectors and then
</span><span class="c1"></span>	<span class="c1">// gathers the collected metrics into a lexicographically sorted slice
</span><span class="c1"></span>	<span class="c1">// of uniquely named MetricFamily protobufs. Gather ensures that the
</span><span class="c1"></span>	<span class="c1">// returned slice is valid and self-consistent so that it can be used
</span><span class="c1"></span>	<span class="c1">// for valid exposition. As an exception to the strict consistency
</span><span class="c1"></span>	<span class="c1">// requirements described for metric.Desc, Gather will tolerate
</span><span class="c1"></span>	<span class="c1">// different sets of label names for metrics of the same metric family.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Even if an error occurs, Gather attempts to gather as many metrics as
</span><span class="c1"></span>	<span class="c1">// possible. Hence, if a non-nil error is returned, the returned
</span><span class="c1"></span>	<span class="c1">// MetricFamily slice could be nil (in case of a fatal error that
</span><span class="c1"></span>	<span class="c1">// prevented any meaningful metric collection) or contain a number of
</span><span class="c1"></span>	<span class="c1">// MetricFamily protobufs, some of which might be incomplete, and some
</span><span class="c1"></span>	<span class="c1">// might be missing altogether. The returned error (which might be a
</span><span class="c1"></span>	<span class="c1">// MultiError) explains the details. Note that this is mostly useful for
</span><span class="c1"></span>	<span class="c1">// debugging purposes. If the gathered protobufs are to be used for
</span><span class="c1"></span>	<span class="c1">// exposition in actual monitoring, it is almost always better to not
</span><span class="c1"></span>	<span class="c1">// expose an incomplete result and instead disregard the returned
</span><span class="c1"></span>	<span class="c1">// MetricFamily protobufs in case the returned error is non-nil.
</span><span class="c1"></span>	<span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Gatherer是注册表的一部分，负责将收集的指标收集到许多MetricFamilies中。Gatherer界面具有与Registerer界面相同的一般含义。</p>
<h2 id="type-gathererfunc">type GathererFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GathererFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>GathererFunc将功能转换为Gatherer。</p>
<h2 id="func-gathererfunc-gather">func (GathererFunc) Gather</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">gf</span> <span class="nx">GathererFunc</span><span class="p">)</span> <span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Gather实现Gatherer。</p>
<h1 id="type-gatherers">type Gatherers</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Gatherers</span> <span class="p">[]</span><span class="nx">Gatherer</span>
</code></pre></td></tr></table>
</div>
</div><p>Gatherers是实现Gatherer接口本身的Gatherer实例的一部分。它的Gather方法按顺序在切片中的所有Gatherer上调用Gather并返回合并的结果。从Gather调用返回的错误全部以扁平化的MultiError返回。跳过重复和不一致的Metric（以分片顺序获胜的方式首次出现），并在返回的错误中报告。</p>
<p>收集器可用于合并来自多个注册表的收集结果。它还提供了一种通过使用Gather方法创建自定义Gatherer的方法，将现有的MetricFamily原型直接注入到集合中，该方法仅返回现有的MetricFamily原型。请注意，不涉及注册（与收集器注册相反），因此显然无法进行注册时检查。收集的MetricFamilies之间的任何不一致都会通过Gather方法报告为错误，并且会删除不一致的Metric。MetricFamilies的无效部分（例如，语法上无效的Metric或标签名称）将不会被检测到。</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewRegistry</span><span class="p">()</span>
<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGaugeVec</span><span class="p">(</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;temperature_kelvin&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Temperature in Kelvin.&#34;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;location&#34;</span><span class="p">},</span>
<span class="p">)</span>
<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span>
<span class="nx">temp</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;outside&#34;</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="mf">273.14</span><span class="p">)</span>
<span class="nx">temp</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;inside&#34;</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="mf">298.44</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">parser</span> <span class="nx">expfmt</span><span class="p">.</span><span class="nx">TextParser</span>

<span class="nx">text</span> <span class="o">:=</span> <span class="s">`
</span><span class="s"># TYPE humidity_percent gauge
</span><span class="s"># HELP humidity_percent Humidity in %.
</span><span class="s">humidity_percent{location=&#34;outside&#34;} 45.4
</span><span class="s">humidity_percent{location=&#34;inside&#34;} 33.2
</span><span class="s"># TYPE temperature_kelvin gauge
</span><span class="s"># HELP temperature_kelvin Temperature in Kelvin.
</span><span class="s">temperature_kelvin{location=&#34;somewhere else&#34;} 4.5
</span><span class="s">`</span>

<span class="nx">parseText</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">parsed</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nf">TextToMetricFamilies</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">mf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parsed</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">mf</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="nx">gatherers</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Gatherers</span><span class="p">{</span>
	<span class="nx">reg</span><span class="p">,</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">GathererFunc</span><span class="p">(</span><span class="nx">parseText</span><span class="p">),</span>
<span class="p">}</span>

<span class="nx">gathering</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gatherers</span><span class="p">.</span><span class="nf">Gather</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">out</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">{}</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">mf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gathering</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">expfmt</span><span class="p">.</span><span class="nf">MetricFamilyToText</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">mf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;----------&#34;</span><span class="p">)</span>

<span class="c1">// Note how the temperature_kelvin metric family has been merged from
</span><span class="c1">// different sources. Now try
</span><span class="c1"></span><span class="nx">text</span> <span class="p">=</span> <span class="s">`
</span><span class="s"># TYPE humidity_percent gauge
</span><span class="s"># HELP humidity_percent Humidity in %.
</span><span class="s">humidity_percent{location=&#34;outside&#34;} 45.4
</span><span class="s">humidity_percent{location=&#34;inside&#34;} 33.2
</span><span class="s"># TYPE temperature_kelvin gauge
</span><span class="s"># HELP temperature_kelvin Temperature in Kelvin.
</span><span class="s"># Duplicate metric:
</span><span class="s">temperature_kelvin{location=&#34;outside&#34;} 265.3
</span><span class="s"> # Missing location label (note that this is undesirable but valid):
</span><span class="s">temperature_kelvin 4.5
</span><span class="s">`</span>

<span class="nx">gathering</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">gatherers</span><span class="p">.</span><span class="nf">Gather</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Note that still as many metrics as possible are returned:
</span><span class="c1"></span><span class="nx">out</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">mf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">gathering</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">expfmt</span><span class="p">.</span><span class="nf">MetricFamilyToText</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">mf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># HELP humidity_percent Humidity in %.
# TYPE humidity_percent gauge
humidity_percent{location=&#34;inside&#34;} 33.2
humidity_percent{location=&#34;outside&#34;} 45.4
# HELP temperature_kelvin Temperature in Kelvin.
# TYPE temperature_kelvin gauge
temperature_kelvin{location=&#34;inside&#34;} 298.44
temperature_kelvin{location=&#34;outside&#34;} 273.14
temperature_kelvin{location=&#34;somewhere else&#34;} 4.5
----------
collected metric &#34;temperature_kelvin&#34; { label:&lt;name:&#34;location&#34; value:&#34;outside&#34; &gt; gauge:&lt;value:265.3 &gt; } was collected before with the same name and label values
# HELP humidity_percent Humidity in %.
# TYPE humidity_percent gauge
humidity_percent{location=&#34;inside&#34;} 33.2
humidity_percent{location=&#34;outside&#34;} 45.4
# HELP temperature_kelvin Temperature in Kelvin.
# TYPE temperature_kelvin gauge
temperature_kelvin 4.5
temperature_kelvin{location=&#34;inside&#34;} 298.44
temperature_kelvin{location=&#34;outside&#34;} 273.14
</code></pre></td></tr></table>
</div>
</div><h2 id="func-gatherers-gather">func (Gatherers) Gather</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">gs</span> <span class="nx">Gatherers</span><span class="p">)</span> <span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="type-labels">type Labels</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Labels</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>标签代表标签名称-&gt;值映射的集合。此类型通常与度量矢量收集器的With（Labels）和GetMetricWith（Labels）方法一起使用，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">myVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="s">&#34;404&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}).</span><span class="nf">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>另一个用例是在Opts中或创建Desc中指定常量标签对。</p>
<h1 id="type-metric">type Metric</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Metric</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Desc returns the descriptor for the Metric. This method idempotently
</span><span class="c1"></span>	<span class="c1">// returns the same descriptor throughout the lifetime of the
</span><span class="c1"></span>	<span class="c1">// Metric. The returned descriptor is immutable by contract. A Metric
</span><span class="c1"></span>	<span class="c1">// unable to describe itself must return an invalid descriptor (created
</span><span class="c1"></span>	<span class="c1">// with NewInvalidDesc).
</span><span class="c1"></span>	<span class="nf">Desc</span><span class="p">()</span> <span class="o">*</span><span class="nx">Desc</span>
	<span class="c1">// Write encodes the Metric into a &#34;Metric&#34; Protocol Buffer data
</span><span class="c1"></span>	<span class="c1">// transmission object.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metric implementations must observe concurrency safety as reads of
</span><span class="c1"></span>	<span class="c1">// this metric may occur at any time, and any blocking occurs at the
</span><span class="c1"></span>	<span class="c1">// expense of total performance of rendering all registered
</span><span class="c1"></span>	<span class="c1">// metrics. Ideally, Metric implementations should support concurrent
</span><span class="c1"></span>	<span class="c1">// readers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// While populating dto.Metric, it is the responsibility of the
</span><span class="c1"></span>	<span class="c1">// implementation to ensure validity of the Metric protobuf (like valid
</span><span class="c1"></span>	<span class="c1">// UTF-8 strings or syntactically valid metric and label names). It is
</span><span class="c1"></span>	<span class="c1">// recommended to sort labels lexicographically. Callers of Write should
</span><span class="c1"></span>	<span class="c1">// still make sure of sorting if they depend on it.
</span><span class="c1"></span>	<span class="nf">Write</span><span class="p">(</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Metric将单个样本值建模，并将其元数据导出到Prometheus。此程序包中Metric的实现是仪表，计数器，直方图，摘要和无类型的。</p>
<h2 id="func-mustnewconsthistogram">func MustNewConstHistogram</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustNewConstHistogram</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>MustNewConstHistogram是NewConstHistogram的一个版本，它会惊慌于NewConstHistogram返回错误的地方。</p>
<h2 id="func-mustnewconstmetric">func MustNewConstMetric</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustNewConstMetric</span><span class="p">(</span><span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span> <span class="nx">valueType</span> <span class="nx">ValueType</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>MustNewConstMetric是NewConstMetric的一个版本，它会惊慌于NewConstMetric返回错误的地方。</p>
<h2 id="func-mustnewconstsummary">func MustNewConstSummary</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MustNewConstSummary</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">quantiles</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>MustNewConstSummary是NewConstSummary的一个版本，它会惊慌，NewConstMetric将返回错误。</p>
<h2 id="func-newconsthistogram">func NewConstHistogram</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewConstHistogram</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">Metric</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>NewConstHistogram返回一个表示Prometheus直方图的度量，该度量具有用于计数，总和和存储桶计数的固定值。由于无法更改这些参数，因此返回的值不会实现直方图接口（而只能实现公制接口）。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即用即弃的Metric，可以即时生成以用Collect方法将其发送给Prometheus。</p>
<p>buckets是上限到累积计数的映射，不包括+ Inf buckets。</p>
<p>如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstHistogram返回错误。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">desc</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
	<span class="s">&#34;http_request_duration_seconds&#34;</span><span class="p">,</span>
	<span class="s">&#34;A histogram of the HTTP request durations.&#34;</span><span class="p">,</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;owner&#34;</span><span class="p">:</span> <span class="s">&#34;example&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Create a constant histogram from values we got from a 3rd party telemetry system.
</span><span class="c1"></span><span class="nx">h</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstHistogram</span><span class="p">(</span>
	<span class="nx">desc</span><span class="p">,</span>
	<span class="mi">4711</span><span class="p">,</span> <span class="mf">403.34</span><span class="p">,</span>
	<span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">{</span><span class="mi">25</span><span class="p">:</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">50</span><span class="p">:</span> <span class="mi">2403</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span> <span class="mi">3221</span><span class="p">,</span> <span class="mi">200</span><span class="p">:</span> <span class="mi">4233</span><span class="p">},</span>
	<span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the histogram by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">h</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">label: &lt;
  name: &#34;code&#34;
  value: &#34;200&#34;
&gt;
label: &lt;
  name: &#34;method&#34;
  value: &#34;get&#34;
&gt;
label: &lt;
  name: &#34;owner&#34;
  value: &#34;example&#34;
&gt;
histogram: &lt;
  sample_count: 4711
  sample_sum: 403.34
  bucket: &lt;
    cumulative_count: 121
    upper_bound: 25
  &gt;
  bucket: &lt;
    cumulative_count: 2403
    upper_bound: 50
  &gt;
  bucket: &lt;
    cumulative_count: 3221
    upper_bound: 100
  &gt;
  bucket: &lt;
    cumulative_count: 4233
    upper_bound: 200
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newconstmetric">func NewConstMetric</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewConstMetric</span><span class="p">(</span><span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span> <span class="nx">valueType</span> <span class="nx">ValueType</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Metric</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>NewConstMetric返回具有一个固定值且无法更改的度量。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即时生成的一次性指标，可以通过Collect方法将其发送给Prometheus。如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstMetric返回错误。</p>
<h2 id="func-newconstsummary">func NewConstSummary</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewConstSummary</span><span class="p">(</span>
	<span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span>
	<span class="nx">count</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="nx">sum</span> <span class="kt">float64</span><span class="p">,</span>
	<span class="nx">quantiles</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
	<span class="nx">labelValues</span> <span class="o">...</span><span class="kt">string</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">Metric</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>NewConstSummary返回一个Metric，该Metric表示Prometheus摘要，其计数，总和和分位数具有固定值。由于无法更改这些参数，因此返回的值不会实现Summary接口（而只能实现Metric接口）。使用此软件包的用户在常规操作中将不会使用太多。但是，在实现自定义收集器时，它是一种即时生成的一次性指标，可以通过Collect方法将其发送给Prometheus。</p>
<p>分位数图将等级排名为分位数。例如，中值等待时间为0.23s，第99个百分位等待时间为0.56s表示为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">0.23</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">:</span> <span class="mf">0.56</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果labelValues的长度与Desc中的变量标签不一致，或者Desc无效，则NewConstSummary返回错误。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">desc</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
	<span class="s">&#34;http_request_duration_seconds&#34;</span><span class="p">,</span>
	<span class="s">&#34;A summary of the HTTP request durations.&#34;</span><span class="p">,</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;code&#34;</span><span class="p">,</span> <span class="s">&#34;method&#34;</span><span class="p">},</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;owner&#34;</span><span class="p">:</span> <span class="s">&#34;example&#34;</span><span class="p">},</span>
<span class="p">)</span>

<span class="c1">// Create a constant summary from values we got from a 3rd party telemetry system.
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstSummary</span><span class="p">(</span>
	<span class="nx">desc</span><span class="p">,</span>
	<span class="mi">4711</span><span class="p">,</span> <span class="mf">403.34</span><span class="p">,</span>
	<span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.5</span><span class="p">:</span> <span class="mf">42.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">:</span> <span class="mf">323.3</span><span class="p">},</span>
	<span class="s">&#34;200&#34;</span><span class="p">,</span> <span class="s">&#34;get&#34;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the summary by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">s</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">label: &lt;
  name: &#34;code&#34;
  value: &#34;200&#34;
&gt;
label: &lt;
  name: &#34;method&#34;
  value: &#34;get&#34;
&gt;
label: &lt;
  name: &#34;owner&#34;
  value: &#34;example&#34;
&gt;
summary: &lt;
  sample_count: 4711
  sample_sum: 403.34
  quantile: &lt;
    quantile: 0.5
    value: 42.3
  &gt;
  quantile: &lt;
    quantile: 0.9
    value: 323.3
  &gt;
&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newinvalidmetric">func NewInvalidMetric</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewInvalidMetric</span><span class="p">(</span><span class="nx">desc</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>NewInvalidMetric返回一个指标，该指标的Write方法始终返回提供的错误。如果收集器发现自己无法收集Metric并希望向注册表报告错误，这将很有用。</p>
<h2 id="func-newmetricwithtimestamp">func NewMetricWithTimestamp</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewMetricWithTimestamp</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Metric</span><span class="p">)</span> <span class="nx">Metric</span>
</code></pre></td></tr></table>
</div>
</div><p>NewMetricWithTimestamp返回一个新的Metric，该Metric以将显式时间戳记设置为所提供的Time的方式包装所提供的Metric。这仅在极少数情况下有用，因为PrometheusMetric的时间戳通常应由Prometheus服务器在抓取期间设置。例外情况包括具有来自其他Metric来源的给定时间戳的镜像Metric。</p>
<p>NewMetricWithTimestamp与MustNewConstMetric，MustNewConstHistogram和MustNewConstSummary一起使用效果最佳，请参见示例。</p>
<p>当前，Prometheus使用的展示格式仅限于毫秒分辨率。因此，提供的时间将舍入到下一个完整的毫秒值。</p>
<p>例子</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">desc</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
	<span class="s">&#34;temperature_kelvin&#34;</span><span class="p">,</span>
	<span class="s">&#34;Current temperature in Kelvin.&#34;</span><span class="p">,</span>
	<span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">// Create a constant gauge from values we got from an external
</span><span class="c1">// temperature reporting system. Those values are reported with a slight
</span><span class="c1">// delay, so we want to add the timestamp of the actual measurement.
</span><span class="c1"></span><span class="nx">temperatureReportedByExternalSystem</span> <span class="o">:=</span> <span class="mf">298.15</span>
<span class="nx">timeReportedByExternalSystem</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">November</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12345678</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">)</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewMetricWithTimestamp</span><span class="p">(</span>
	<span class="nx">timeReportedByExternalSystem</span><span class="p">,</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
		<span class="nx">desc</span><span class="p">,</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeValue</span><span class="p">,</span> <span class="nx">temperatureReportedByExternalSystem</span><span class="p">,</span>
	<span class="p">),</span>
<span class="p">)</span>

<span class="c1">// Just for demonstration, let&#39;s check the state of the gauge by
</span><span class="c1">// (ab)using its Write method (which is usually only used by Prometheus
</span><span class="c1">// internally).
</span><span class="c1"></span><span class="nx">metric</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dto</span><span class="p">.</span><span class="nx">Metric</span><span class="p">{}</span>
<span class="nx">s</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">metric</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">proto</span><span class="p">.</span><span class="nf">MarshalTextString</span><span class="p">(</span><span class="nx">metric</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">gauge: &lt;
  value: 298.15
&gt;
timestamp_ms: 1257894000012
</code></pre></td></tr></table>
</div>
</div><h1 id="type-multierror">type MultiError</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MultiError</span> <span class="p">[]</span><span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>MultiError是实现错误接口的错误片段。收集器使用它来报告MetricFamily收集期间的多个错误。</p>
<h2 id="func-multierror-append">func (*MultiError) Append</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">errs</span> <span class="o">*</span><span class="nx">MultiError</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果错误不是nil，则追加会附加提供的错误。</p>
<h2 id="func-multierror-error">func (MultiError) Error</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">errs</span> <span class="nx">MultiError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-multierror-maybeunwrap">func (MultiError) MaybeUnwrap</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">errs</span> <span class="nx">MultiError</span><span class="p">)</span> <span class="nf">MaybeUnwrap</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>如果len（errs）为0，则MaybeUnwrap返回nil。如果len（errs）为1，则返回第一个且仅包含错误的错误。在所有其他情况下，它直接返回MultiError。这对于以仅在需要时使用MultiError的方式返回MultiError很有帮助。</p>
<h1 id="type-observer">type Observer</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Observer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Observer是包装Observe方法的接口，直方图和摘要用于添加观察值。</p>
<h2 id="type-observerfunc">type ObserverFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ObserverFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ObserverFunc类型是一个适配器，允许将普通功能用作Observers。如果f是具有适当签名的函数，则ObserverFunc（f）是调用f的Observer。</p>
<p>此适配器通常与Timer类型结合使用，并且有两种常规使用情况：</p>
<p>最常见的一种是将仪表用作计时器的观察器。请参见“仪表”计时器示例。</p>
<p>更高级的用例是创建一个功能，该功能可动态决定使用哪个观察者来观察持续时间。请参见“复杂”计时器示例。</p>
<h2 id="func-observerfunc-observe">func (ObserverFunc) Observe</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">ObserverFunc</span><span class="p">)</span> <span class="nf">Observe</span><span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Observe 调用 f(value)。它实现了observer。</p>
<h1 id="type-observervec">type ObserverVec</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ObserverVec</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Observer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">With</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="nx">Observer</span>
	<span class="nf">WithLabelValues</span><span class="p">(</span><span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Observer</span>
	<span class="nf">CurryWith</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">ObserverVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">Labels</span><span class="p">)</span> <span class="nx">ObserverVec</span>

	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ObserverVec是由“HistogramVec”和“SummaryVec”实现的接口。</p>
<h1 id="type-opts">type Opts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Opts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Namespace, Subsystem, and Name are components of the fully-qualified
</span><span class="c1"></span>	<span class="c1">// name of the Metric (created by joining these components with
</span><span class="c1"></span>	<span class="c1">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the
</span><span class="c1"></span>	<span class="c1">// name. Note that the fully-qualified name of the metric must be a
</span><span class="c1"></span>	<span class="c1">// valid Prometheus metric name.
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="nx">Subsystem</span> <span class="kt">string</span>
	<span class="nx">Name</span>      <span class="kt">string</span>

	<span class="c1">// Help provides information about this metric.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Metrics with the same fully-qualified name must have the same Help
</span><span class="c1"></span>	<span class="c1">// string.
</span><span class="c1"></span>	<span class="nx">Help</span> <span class="kt">string</span>

	<span class="c1">// ConstLabels are used to attach fixed labels to this metric. Metrics
</span><span class="c1"></span>	<span class="c1">// with the same fully-qualified name must have the same label names in
</span><span class="c1"></span>	<span class="c1">// their ConstLabels.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ConstLabels are only used rarely. In particular, do not use them to
</span><span class="c1"></span>	<span class="c1">// attach the same labels to all your metrics. Those use cases are
</span><span class="c1"></span>	<span class="c1">// better covered by target labels set by the scraping Prometheus
</span><span class="c1"></span>	<span class="c1">// server, or by one specific metric (e.g. a build_info or a
</span><span class="c1"></span>	<span class="c1">// machine_role metric). See also
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels,-not-static-scraped-labels
</span><span class="c1"></span>	<span class="nx">ConstLabels</span> <span class="nx">Labels</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Opts捆绑了用于创建大多数指标类型的选项。每个度量实现XXX都有其自己的XXXOpts类型，但在大多数情况下，它只是该类型的别名（可能在需求出现时更改）。</p>
<p>必须将Name设置为非空字符串。尽管强烈建议您设置帮助字符串，但所有其他字段都是可选的，可以安全地保留其零值。</p>
<h1 id="type-processcollectoropts">type ProcessCollectorOpts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ProcessCollectorOpts</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// PidFn returns the PID of the process the collector collects metrics
</span><span class="c1"></span>	<span class="c1">// for. It is called upon each collection. By default, the PID of the
</span><span class="c1"></span>	<span class="c1">// current process is used, as determined on construction time by
</span><span class="c1"></span>	<span class="c1">// calling os.Getpid().
</span><span class="c1"></span>	<span class="nx">PidFn</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// If non-empty, each of the collected metrics is prefixed by the
</span><span class="c1"></span>	<span class="c1">// provided string and an underscore (&#34;_&#34;).
</span><span class="c1"></span>	<span class="nx">Namespace</span> <span class="kt">string</span>
	<span class="c1">// If true, any error encountered during collection is reported as an
</span><span class="c1"></span>	<span class="c1">// invalid metric (see NewInvalidMetric). Otherwise, errors are ignored
</span><span class="c1"></span>	<span class="c1">// and the collected metrics will be incomplete. (Possibly, no metrics
</span><span class="c1"></span>	<span class="c1">// will be collected at all.) While that&#39;s usually not desired, it is
</span><span class="c1"></span>	<span class="c1">// appropriate for the common &#34;mix-in&#34; of process metrics, where process
</span><span class="c1"></span>	<span class="c1">// metrics are nice to have, but failing to collect them should not
</span><span class="c1"></span>	<span class="c1">// disrupt the collection of the remaining metrics.
</span><span class="c1"></span>	<span class="nx">ReportErrors</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ProcessCollectorOpts定义使用NewProcessCollector创建的过程指标收集器的行为。</p>
<h1 id="type-registerer">type Registerer</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Registerer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Register registers a new Collector to be included in metrics
</span><span class="c1"></span>	<span class="c1">// collection. It returns an error if the descriptors provided by the
</span><span class="c1"></span>	<span class="c1">// Collector are invalid or if they — in combination with descriptors of
</span><span class="c1"></span>	<span class="c1">// already registered Collectors — do not fulfill the consistency and
</span><span class="c1"></span>	<span class="c1">// uniqueness criteria described in the documentation of metric.Desc.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If the provided Collector is equal to a Collector already registered
</span><span class="c1"></span>	<span class="c1">// (which includes the case of re-registering the same Collector), the
</span><span class="c1"></span>	<span class="c1">// returned error is an instance of AlreadyRegisteredError, which
</span><span class="c1"></span>	<span class="c1">// contains the previously registered Collector.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A Collector whose Describe method does not yield any Desc is treated
</span><span class="c1"></span>	<span class="c1">// as unchecked. Registration will always succeed. No check for
</span><span class="c1"></span>	<span class="c1">// re-registering (see previous paragraph) is performed. Thus, the
</span><span class="c1"></span>	<span class="c1">// caller is responsible for not double-registering the same unchecked
</span><span class="c1"></span>	<span class="c1">// Collector, and for providing a Collector that will not cause
</span><span class="c1"></span>	<span class="c1">// inconsistent metrics on collection. (This would lead to scrape
</span><span class="c1"></span>	<span class="c1">// errors.)
</span><span class="c1"></span>	<span class="nf">Register</span><span class="p">(</span><span class="nx">Collector</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// MustRegister works like Register but registers any number of
</span><span class="c1"></span>	<span class="c1">// Collectors and panics upon the first registration that causes an
</span><span class="c1"></span>	<span class="c1">// error.
</span><span class="c1"></span>	<span class="nf">MustRegister</span><span class="p">(</span><span class="o">...</span><span class="nx">Collector</span><span class="p">)</span>
	<span class="c1">// Unregister unregisters the Collector that equals the Collector passed
</span><span class="c1"></span>	<span class="c1">// in as an argument.  (Two Collectors are considered equal if their
</span><span class="c1"></span>	<span class="c1">// Describe method yields the same set of descriptors.) The function
</span><span class="c1"></span>	<span class="c1">// returns whether a Collector was unregistered. Note that an unchecked
</span><span class="c1"></span>	<span class="c1">// Collector cannot be unregistered (as its Describe method does not
</span><span class="c1"></span>	<span class="c1">// yield any descriptor).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Note that even after unregistering, it will not be possible to
</span><span class="c1"></span>	<span class="c1">// register a new Collector that is inconsistent with the unregistered
</span><span class="c1"></span>	<span class="c1">// Collector, e.g. a Collector collecting metrics with the same name but
</span><span class="c1"></span>	<span class="c1">// a different help string. The rationale here is that the same registry
</span><span class="c1"></span>	<span class="c1">// instance must only collect consistent metrics throughout its
</span><span class="c1"></span>	<span class="c1">// lifetime.
</span><span class="c1"></span>	<span class="nf">Unregister</span><span class="p">(</span><span class="nx">Collector</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注册器是注册表中负责注册和注销的部分的接口。定制注册表的用户应将Registerer用作注册的类型（而不是直接使用Registry类型）。这样，他们可以自由使用自定义的Registerer实现（例如，出于测试目的）。</p>
<h2 id="func-wrapregistererwith">func WrapRegistererWith</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WrapRegistererWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">,</span> <span class="nx">reg</span> <span class="nx">Registerer</span><span class="p">)</span> <span class="nx">Registerer</span>
</code></pre></td></tr></table>
</div>
</div><p>WrapRegistererWith返回包装提供的注册器的注册器。在返回的注册器中注册的收集器将以修改后的方式在包装的注册器中注册。修改后的收集器会将提供的标签添加到它收集的所有Metric中（作为ConstLabels）。未经修改的收集器收集的Metric不得重复任何这些标签。包装一个nil值是有效的，导致没有操作的register。</p>
<p>WrapRegistererWith提供了一种向收集器的子集添加固定标签的方法。不应将其用于向所有公开的指标添加固定标签。</p>
<p>仍将检测到通过原始注册器注册的收集器与通过包装注册器注册的收集器之间的冲突。由任一注册器的Register方法返回的任何AlreadyRegisteredError都将包含ExistingCollector，其形式已提供给相应的注册表。</p>
<p>收集器示例演示了WrapRegistererWith的用法。</p>
<h2 id="func-wrapregistererwithprefix">func WrapRegistererWithPrefix</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WrapRegistererWithPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">reg</span> <span class="nx">Registerer</span><span class="p">)</span> <span class="nx">Registerer</span>
</code></pre></td></tr></table>
</div>
</div><p>WrapRegistererWithPrefix返回包装提供的注册器的注册器。在返回的注册器中注册的收集器将以修改后的方式在包装的注册器中注册。修改后的收集器会将提供的前缀添加到它收集的所有Metric的名称中。包装一个nil值是有效的，导致没有操作寄存器。</p>
<p>WrapRegistererWithPrefix对于在一个子系统前面放置所有度量的前缀很有用。为此，请使用WrapRegistererWithPrefix返回的包装注册器注册子系统的度量。对于所有公开的指标，使用相同的前缀很少有用。特别是，不要在跨应用程序标准化的Metric名称前添加前缀，因为这会破坏水平监视，例如Go收集器（请参阅NewGoCollector）和流程收集器（请参阅NewProcessCollector）提供的Metric。（实际上，这些指标已经分别以“ go_”或“ process_”为前缀。）</p>
<p>仍将检测到通过原始注册器注册的收集器与通过包装注册器注册的收集器之间的冲突。由任一注册器的Register方法返回的任何AlreadyRegisteredError都将包含ExistingCollector，其形式已提供给相应的注册表。</p>
<h1 id="type-registry">type Registry</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Registry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注册表注册Prometheus收集器，收集其度量，然后将其收集到MetricFamilies中进行说明。它同时实现了Registerer和Gatherer。零值不可用。使用NewRegistry或NewPedanticRegistry创建实例。</p>
<h2 id="func-newpedanticregistry">func NewPedanticRegistry</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewPedanticRegistry</span><span class="p">()</span> <span class="o">*</span><span class="nx">Registry</span>
</code></pre></td></tr></table>
</div>
</div><p>NewPedanticRegistry返回一个注册表，该注册表在收集期间检查每个收集的指标是否与其报告的Desc一致，以及Desc是否实际上已在注册表中注册。未检查的收集器（其Describe方法不产生任何描述符的收集器）从检查中排除。</p>
<p>通常，只要所有收集的Metric的并集一致且有效，即使某些Metric与其自己的Desc或由其注册收集者提供的Desc不一致，注册管理机构也会很高兴。行为良好的收集器和指标只会提供一致的描述。该注册表对于测试收集器和Metric的实现很有用。</p>
<h2 id="func-newregistry">func NewRegistry</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewRegistry</span><span class="p">()</span> <span class="o">*</span><span class="nx">Registry</span>
</code></pre></td></tr></table>
</div>
</div><p>NewRegistry会创建一个新的普通注册表，而无需预先注册任何收集器。</p>
<h2 id="func-registry-gather">func (*Registry) Gather</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">Gather</span><span class="p">()</span> <span class="p">([]</span><span class="o">*</span><span class="nx">dto</span><span class="p">.</span><span class="nx">MetricFamily</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Gather实现Gatherer。</p>
<h2 id="func-registry-mustregister">func (*Registry) MustRegister</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">MustRegister</span><span class="p">(</span><span class="nx">cs</span> <span class="o">...</span><span class="nx">Collector</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>MustRegister实现Registerer。</p>
<h2 id="func-registry-register">func (*Registry) Register</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Register实现Registerer。</p>
<h2 id="func-registry-unregister">func (*Registry) Unregister</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Registry</span><span class="p">)</span> <span class="nf">Unregister</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Collector</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Unregister 实现 Registerer.</p>
<h1 id="type-timer">type Timer</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计时器是计时功能的辅助类型。使用NewTimer创建新实例。</p>
<p>例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Code</span><span class="p">:</span>

<span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">requestDuration</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogram</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;example_request_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;Histogram for the runtime of a simple example function.&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
	<span class="p">})</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">ExampleTimer</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// timer times this example function. It uses a Histogram, but a Summary
</span><span class="c1"></span>	<span class="c1">// would also work, as both implement Observer. Check out
</span><span class="c1"></span>	<span class="c1">// https://prometheus.io/docs/practices/histograms/ for differences.
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">requestDuration</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>

	<span class="c1">// Do something here that takes time.
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NormFloat64</span><span class="p">()</span><span class="o">*</span><span class="mi">10000</span><span class="o">+</span><span class="mi">50000</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Microsecond</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例（复杂）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// apiRequestDuration tracks the duration separate for each HTTP status
</span><span class="c1"></span>	<span class="c1">// class (1xx, 2xx, ...). This creates a fair amount of time series on
</span><span class="c1"></span>	<span class="c1">// the Prometheus server. Usually, you would track the duration of
</span><span class="c1"></span>	<span class="c1">// serving HTTP request without partitioning by outcome. Do something
</span><span class="c1"></span>	<span class="c1">// like this only if needed. Also note how only status classes are
</span><span class="c1"></span>	<span class="c1">// tracked, not every single status code. The latter would create an
</span><span class="c1"></span>	<span class="c1">// even larger amount of time series. Request counters partitioned by
</span><span class="c1"></span>	<span class="c1">// status code are usually OK as each counter only creates one time
</span><span class="c1"></span>	<span class="c1">// series. Histograms are way more expensive, so partition with care and
</span><span class="c1"></span>	<span class="c1">// only where you really need separate latency tracking. Partitioning by
</span><span class="c1"></span>	<span class="c1">// status class is only an example. In concrete cases, other partitions
</span><span class="c1"></span>	<span class="c1">// might make more sense.
</span><span class="c1"></span>	<span class="nx">apiRequestDuration</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span>
		<span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;api_request_duration_seconds&#34;</span><span class="p">,</span>
			<span class="nx">Help</span><span class="p">:</span>    <span class="s">&#34;Histogram for the request duration of the public API, partitioned by status class.&#34;</span><span class="p">,</span>
			<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">ExponentialBuckets</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;status_class&#34;</span><span class="p">},</span>
	<span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span>
	<span class="c1">// The ObserverFunc gets called by the deferred ObserveDuration and
</span><span class="c1"></span>	<span class="c1">// decides which Histogram&#39;s Observe method is called.
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">ObserverFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">500</span><span class="p">:</span> <span class="c1">// Server error.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;5xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">400</span><span class="p">:</span> <span class="c1">// Client error.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;4xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">300</span><span class="p">:</span> <span class="c1">// Redirection.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;3xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">:</span> <span class="c1">// Success.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;2xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span> <span class="c1">// Informational.
</span><span class="c1"></span>			<span class="nx">apiRequestDuration</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="s">&#34;1xx&#34;</span><span class="p">).</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}))</span>
	<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>

	<span class="c1">// Handle the request. Set status accordingly.
</span><span class="c1"></span>	<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleTimer_complex</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/api&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例（量规）</p>
<p>Code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prometheus_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// If a function is called rarely (i.e. not more often than scrapes
</span><span class="c1"></span>	<span class="c1">// happen) or ideally only once (like in a batch job), it can make sense
</span><span class="c1"></span>	<span class="c1">// to use a Gauge for timing the function call. For timing a batch job
</span><span class="c1"></span>	<span class="c1">// and pushing the result to a Pushgateway, see also the comprehensive
</span><span class="c1"></span>	<span class="c1">// example in the push package.
</span><span class="c1"></span>	<span class="nx">funcDuration</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewGauge</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;example_function_duration_seconds&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;Duration of the last call of an example function.&#34;</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// The Set method of the Gauge is used to observe the duration.
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nf">ObserverFunc</span><span class="p">(</span><span class="nx">funcDuration</span><span class="p">.</span><span class="nx">Set</span><span class="p">))</span>
	<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>

	<span class="c1">// Do something. Return errors as encountered. The use of &#39;defer&#39; above
</span><span class="c1"></span>	<span class="c1">// makes sure the function is still timed properly.
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleTimer_gauge</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">run</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newtimer">func NewTimer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Observer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Timer</span>
</code></pre></td></tr></table>
</div>
</div><p>NewTimer创建一个新的计时器。提供的观察者用于观察持续时间（以秒为单位）。计时器通常用于通过以下方式为函数调用计时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TimeMe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">timer</span> <span class="o">:=</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">myHistogram</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">ObserveDuration</span><span class="p">()</span>
    <span class="c1">// Do actual work.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-timer-observeduration">func (*Timer) ObserveDuration</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">ObserveDuration</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</code></pre></td></tr></table>
</div>
</div><p>ObserveDuration记录自使用NewTimer创建计时器以来经过的持续时间。它调用构造期间提供的Observer的Observe方法，以持续时间（以秒为单位）作为参数。观察到的持续时间也将返回。通常使用defer语句调用ObserveDuration。</p>
<p>请注意，只有与Go1.9+一起使用时，才能保证此方法永远不会观察到负持续时间。</p>
<h1 id="type-untypedfunc">type UntypedFunc</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UntypedFunc</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Metric</span>
	<span class="nx">Collector</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>UntypedFunc的作用类似于GaugeFunc，但收集的指标类型为“Untyped”。UntypedFunc可用于镜像未知类型的外部指标。</p>
<p>要创建UntypedFunc实例，请使用NewUntypedFunc。</p>
<h2 id="func-newuntypedfunc">func NewUntypedFunc</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewUntypedFunc</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">UntypedOpts</span><span class="p">,</span> <span class="nx">function</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">float64</span><span class="p">)</span> <span class="nx">UntypedFunc</span>
</code></pre></td></tr></table>
</div>
</div><p>NewUntypedFunc基于提供的UntypedOpts创建一个新的UntypedFunc。报告的值是通过在Write方法中调用给定的函数确定的。考虑到指标收集可能会同时发生。如果这导致对Write的并发调用，例如在UntypedFunc直接向Prometheus注册的情况下，则提供的函数必须是并发安全的。</p>
<h1 id="type-untypedopts">type UntypedOpts</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UntypedOpts</span> <span class="nx">Opts</span>
</code></pre></td></tr></table>
</div>
</div><p>UntypedOpts是Opts的别名。请参阅此处以获取文档注释。</p>
<h1 id="type-valuetype">type ValueType</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ValueType</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>ValueType是代表简单值的指标类型的枚举。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">CounterValue</span> <span class="nx">ValueType</span>
	<span class="nx">GaugeValue</span>
	<span class="nx">UntypedValue</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ValueType枚举的可能值。使用UntypedValue可以将指标标记为未知类型。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-07-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/prometheus/">Prometheus</a>
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/promethues%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">prometheus的四种指标类型</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93jennifer/">
            <span class="next-text nav-default">Go的代码生成库:jennifer</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
