<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>并发原语Cond源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="Cond 标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。 首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="并发原语Cond源码剖析" />
<meta property="og:description" content="Cond 标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。 首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-21T14:35:25&#43;00:00" />
<meta property="article:modified_time" content="2021-05-21T14:35:25&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并发原语Cond源码剖析"/>
<meta name="twitter:description" content="Cond 标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。 首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "并发原语Cond源码剖析",
      "item": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "并发原语Cond源码剖析",
  "name": "并发原语Cond源码剖析",
  "description": "Cond 标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。 首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "Cond 标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。\n首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它内部维护着一个先入先出的等待队列。\n然后,我们分别看下它的三个方法 Broadcast、Signal 和 Wait 方法。\n Signal 方法,允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine,显然无需通知 waiter;如果 Cond 等待队列中有一个或者多个等待的 goroutine,则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中,比如 Java 语言中,Signal 方法也被叫做 notify 方法。  调用 Signal 方法时,不强求你一定要持有 c.L 的锁。   Broadcast 方法,允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine,显然无需通知 waiter;如果 Cond 等待队列中有一个或者多个等待的 goroutine,则清空所有等待的 goroutine,并全部唤醒。在其他编程语言中,比如 Java 语言中,Broadcast 方法也被叫做 notifyAll 方法。  同样地,调用 Broadcast 方法时,也不强求你一定持有 c.L 的锁。   Wait 方法,会把调用者 Caller 放入 Cond 的等待队列中并阻塞,直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。  调用 Wait 方法时必须要持有 c.L 的锁。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  // Cond implements a condition variable, a rendezvous point // for goroutines waiting for or announcing the occurrence // of an event. // // Each Cond has an associated Locker L (often a *Mutex or *RWMutex), // which must be held when changing the condition and // when calling the Wait method. // // A Cond must not be copied after first use. type Cond struct { noCopy noCopy // L is held while observing or changing the condition \t// 当观察或者修改等待条件的时候需要加锁 \tL Locker // 等待队列 \tnotify notifyList checker copyChecker } // NewCond returns a new Cond with Locker l. func NewCond(l Locker) *Cond { return \u0026Cond{L: l} } // Wait atomically unlocks c.L and suspends execution // of the calling goroutine. After later resuming execution, // Wait locks c.L before returning. Unlike in other systems, // Wait cannot return unless awoken by Broadcast or Signal. // // Because c.L is not locked when Wait first resumes, the caller // typically cannot assume that the condition is true when // Wait returns. Instead, the caller should Wait in a loop: // // c.L.Lock() // for !condition() { // c.Wait() // } // ... make use of condition ... // c.L.Unlock() // // Wait 把调用者加入到等待队列时会释放锁,在被唤醒之后还会请求锁。在阻塞休眠期间, 调用者是不持有锁的,这样能让其他 goroutine 有机会检查或者更新等待变量。 // Wait 原子式的 unlock c.L， 并暂停执行调用的 goroutine。 // 在稍后执行后，Wait 会在返回前 lock c.L. 与其他系统不同， // 除非被 Broadcast 或 Signal 唤醒，否则等待无法返回。 // // 因为等待第一次 resume 时 c.L 没有被锁定，所以当 Wait 返回时， // 调用者通常不能认为条件为真。相反，调用者应该在循环中使用 Wait()： // // c.L.Lock() // for !condition() { // c.Wait() // } // ... make use of condition ... // c.L.Unlock() // func (c *Cond) Wait() { // 增加到等待队列中 \tc.checker.check() t := runtime_notifyListAdd(\u0026c.notify) c.L.Unlock() // 阻塞休眠直到被唤醒 \truntime_notifyListWait(\u0026c.notify, t) c.L.Lock() } // Signal wakes one goroutine waiting on c, if there is any. // // It is allowed but not required for the caller to hold c.L // during the call. // Signal 和 Broadcast 只涉及到 notifyList 数据结构,不涉及到锁。 // Signal 唤醒一个等待 c 的 goroutine（如果存在） // // 在调用时它可以（不必须）持有一个 c.L func (c *Cond) Signal() { c.checker.check() runtime_notifyListNotifyOne(\u0026c.notify) } // Broadcast wakes all goroutines waiting on c. // // It is allowed but not required for the caller to hold c.L // during the call. // Broadcast 唤醒等待 c 的所有 goroutine // // 调用时它可以（不必须）持久有个 c.L func (c *Cond) Broadcast() { c.checker.check() runtime_notifyListNotifyAll(\u0026c.notify) }   copyChecker copyChecker 非常简单，它实现了一个 check() 方法，这个方法以 copyChecker 的指针作为 reciever， 因为 copyChecker 在一个 Cond 中并非指针，因此当 Cond 发生拷贝行为后，这个 reciever 会 发生变化，从而检测到拷贝行为，使用 panic 以警示用户：\n1 2 3 4 5 6 7 8 9 10 11 12  // copyChecker holds back pointer to itself to detect object copying. // copyChecker 是一个辅助结构,可以在运行时检查 Cond 是否被复制使用。 // copyChecker 保存指向自身的指针来检测对象的复制行为。 type copyChecker uintptr func (c *copyChecker) check() { if uintptr(*c) != uintptr(unsafe.Pointer(c)) \u0026\u0026 !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) \u0026\u0026 uintptr(*c) != uintptr(unsafe.Pointer(c)) { panic(\"sync.Cond is copied\") } }   notifyList runtime_notifyListXXX 是运行时实现的方法,实现了一个等待 / 通知的队列。\nnotifyList 结构本质上是一个队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // notifyList 基于 ticket 实现通知列表 type notifyList struct { // wait 为下一个 waiter 的 ticket 编号 \t// 在没有 lock 的情况下原子自增 \twait uint32 // notify 是下一个被通知的 waiter 的 ticket 编号 \t// 它可以在没有 lock 的情况下进行读取，但只有在持有 lock 的情况下才能进行写 \t// \t// wait 和 notify 会产生 wrap around，只要它们 \"unwrapped\" \t// 的差别小于 2^31，这种情况可以被正确处理。对于 wrap around 的情况而言， \t// 我们需要超过 2^31+ 个 goroutine 阻塞在相同的 condvar 上，这是不可能的。 \t// \tnotify uint32 // waiter 列表. \tlock mutex head *sudog tail *sudog }   当一个 Cond 调用 Wait 方法时候，向 wait 字段加 1，并返回一个 ticket 编号：\n1 2 3 4 5 6 7  // notifyListAdd 将调用者添加到通知列表，以便接收通知。 // 调用者最终必须调用 notifyListWait 等待这样的通知，并传递返回的 ticket 编号。 //go:linkname notifyListAdd sync.runtime_notifyListAdd func notifyListAdd(l *notifyList) uint32 { // 这可以并发调用，例如，当在 read 模式下保持 RWMutex 时从 sync.Cond.Wait 调用时。 \treturn atomic.Xadd(\u0026l.wait, 1) - 1 }   而后使用这个 ticket 编号来等待通知，这个过程会将等待通知的 goroutine 进行停泊，进入等待状态， 并将其 M 与 P 解绑，从而将 G 从 M 身上剥离，放入等待队列 sudog 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // notifyListWait 等待通知。如果在调用 notifyListAdd 后发送了一个，则立即返回。否则，它会阻塞。 //go:linkname notifyListWait sync.runtime_notifyListWait func notifyListWait(l *notifyList, t uint32) { lock(\u0026l.lock) // 如果 ticket 编号对应的 goroutine 已经被通知到，则立刻返回 \tif less(t, l.notify) { unlock(\u0026l.lock) return } s := acquireSudog() s.g = getg() s.ticket = t s.releasetime = 0 t0 := int64(0) if blockprofilerate  0 { t0 = cputicks() s.releasetime = -1 } if l.tail == nil { l.head = s } else { l.tail.next = s } l.tail = s // 将 M/P/G 解绑，并将 G 调整为等待状态，放入 sudog 等待队列中 \tgoparkunlock(\u0026l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, 3) if t0 != 0 { blockevent(s.releasetime-t0, 2) } releaseSudog(s) } // 将当前 goroutine 置于等待状态并解锁 lock。 // 通过调用 goready(gp) 可让 goroutine 再次 runnable func goparkunlock(lock *mutex, reason waitReason, traceEv byte, traceskip int) { gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip) }   当调用 Signal 时，会有一个在等待的 goroutine 被通知到，具体过程就是从 sudog 列表中找到 要通知的 goroutine，而后将其 goready 来等待调度循环将其调度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // notifyListNotifyOne 通知列表中的一个条目 //go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne func notifyListNotifyOne(l *notifyList) { // Fast-path: 如果上次通知后没有新的 waiter \t// 则无需加锁 \tif atomic.Load(\u0026l.wait) == atomic.Load(\u0026l.notify) { return } lock(\u0026l.lock) // slow-path 的二次检查 \tt := l.notify if t == atomic.Load(\u0026l.wait) { unlock(\u0026l.lock) return } // 更新下一个需要唤醒的 ticket 编号 \tatomic.Store(\u0026l.notify, t+1) // 尝试找到需要被通知的 g \t// 如果目前还没来得及入队，是无法找到的 \t// 但是，当它看到通知编号已经发生改变是不会被 park 的 \t// \t// 这个查找过程看起来是线性复杂度，但实际上很快就停了 \t// 因为 g 的队列与获取编号不同，因而队列中会出现少量重排，但我们希望找到靠前的 g \t// 而 g 只有在不再 race 后才会排在靠前的位置，因此这个迭代也不会太久， \t// 同时，即便找不到 g，这个情况也成立： \t// 它还没有休眠，并且已经失去了我们在队列上找到的（少数）其他 g 的 race。 \tfor p, s := (*sudog)(nil), l.head; s != nil; p, s = s, s.next { if s.ticket == t { n := s.next if p != nil { p.next = n } else { l.head = n } if n == nil { l.tail = p } unlock(\u0026l.lock) s.next = nil readyWithTime(s, 4) return } } unlock(\u0026l.lock) } func readyWithTime(s *sudog, traceskip int) { if s.releasetime != 0 { s.releasetime = cputicks() } goready(s.g, traceskip) }   如果是全员通知，基本类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // notifyListNotifyAll 通知列表里的所有人 //go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll func notifyListNotifyAll(l *notifyList) { // Fast-path: 如果上次通知后没有新的 waiter \t// 则无需加锁 \tif atomic.Load(\u0026l.wait) == atomic.Load(\u0026l.notify) { return } // 从列表中取一个，保存到局部变量，waiter 则可以在无锁的情况下 ready \tlock(\u0026l.lock) s := l.head l.head = nil l.tail = nil // 更新要通知的下一个 ticket。 \t// 可以将它设置为等待的当前值，因为任何以前的 waiter 已经在列表中， \t// 或者会他们在尝试将自己添加到列表时已经收到通知。 \tatomic.Store(\u0026l.notify, atomic.Load(\u0026l.wait)) unlock(\u0026l.lock) // 遍历整个本地列表，并 ready 所有的 waiter \tfor s != nil { next := s.next s.next = nil readyWithTime(s, 4) s = next } }   参考 https://colobu.com/2017/07/11/dive-into-sync-Map\nhttps://segmentfault.com/a/1190000015242373\nhttps://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/\nhttp://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html\nhttp://www.gogodjzhu.com/index.php/code/basic/397/\nhttp://russellluo.com/2017/06/go-sync-map-diagram.html\n5.4 条件变量\n5.5 同步组\nGo 标准库源码分析 - sync 包的Pool\n5.7 并发安全散列表\n6.1 上下文 Context\ngo context剖析之源码分析\n5.3 原子操作\n",
  "wordCount" : "2910",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-21T14:35:25Z",
  "dateModified": "2021-05-21T14:35:25Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      并发原语Cond源码剖析
    </h1>
    <div class="post-meta">May 21, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="cond">Cond<a hidden class="anchor" aria-hidden="true" href="#cond">#</a></h2>
<p>标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。</p>
<p>首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它内部维护着一个先入先出的等待队列。</p>
<p>然后,我们分别看下它的三个方法 Broadcast、Signal 和 Wait 方法。</p>
<ul>
<li>Signal 方法,允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine,显然无需通知 waiter;如果 Cond 等待队列中有一个或者多个等待的 goroutine,则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中,比如 Java 语言中,Signal 方法也被叫做 notify 方法。
<ul>
<li>调用 Signal 方法时,不强求你一定要持有 c.L 的锁。</li>
</ul>
</li>
<li>Broadcast 方法,允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine,显然无需通知 waiter;如果 Cond 等待队列中有一个或者多个等待的 goroutine,则清空所有等待的 goroutine,并全部唤醒。在其他编程语言中,比如 Java 语言中,Broadcast 方法也被叫做 notifyAll 方法。
<ul>
<li>同样地,调用 Broadcast 方法时,也不强求你一定持有 c.L 的锁。</li>
</ul>
</li>
<li>Wait 方法,会把调用者 Caller 放入 Cond 的等待队列中并阻塞,直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。
<ul>
<li>调用 Wait 方法时必须要持有 c.L 的锁。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Cond implements a condition variable, a rendezvous point
</span><span class="c1">// for goroutines waiting for or announcing the occurrence
</span><span class="c1">// of an event.
</span><span class="c1">//
</span><span class="c1">// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
</span><span class="c1">// which must be held when changing the condition and
</span><span class="c1">// when calling the Wait method.
</span><span class="c1">//
</span><span class="c1">// A Cond must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Cond</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">noCopy</span> <span class="nx">noCopy</span>

	<span class="c1">// L is held while observing or changing the condition
</span><span class="c1"></span>	<span class="c1">// 当观察或者修改等待条件的时候需要加锁
</span><span class="c1"></span>	<span class="nx">L</span> <span class="nx">Locker</span>
	<span class="c1">// 等待队列
</span><span class="c1"></span>	<span class="nx">notify</span>  <span class="nx">notifyList</span>
	<span class="nx">checker</span> <span class="nx">copyChecker</span>
<span class="p">}</span>

<span class="c1">// NewCond returns a new Cond with Locker l.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewCond</span><span class="p">(</span><span class="nx">l</span> <span class="nx">Locker</span><span class="p">)</span> <span class="o">*</span><span class="nx">Cond</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Cond</span><span class="p">{</span><span class="nx">L</span><span class="p">:</span> <span class="nx">l</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Wait atomically unlocks c.L and suspends execution
</span><span class="c1">// of the calling goroutine. After later resuming execution,
</span><span class="c1">// Wait locks c.L before returning. Unlike in other systems,
</span><span class="c1">// Wait cannot return unless awoken by Broadcast or Signal.
</span><span class="c1">//
</span><span class="c1">// Because c.L is not locked when Wait first resumes, the caller
</span><span class="c1">// typically cannot assume that the condition is true when
</span><span class="c1">// Wait returns. Instead, the caller should Wait in a loop:
</span><span class="c1">//
</span><span class="c1">//    c.L.Lock()
</span><span class="c1">//    for !condition() {
</span><span class="c1">//        c.Wait()
</span><span class="c1">//    }
</span><span class="c1">//    ... make use of condition ...
</span><span class="c1">//    c.L.Unlock()
</span><span class="c1">//
</span><span class="c1">// Wait 把调用者加入到等待队列时会释放锁,在被唤醒之后还会请求锁。在阻塞休眠期间, 调用者是不持有锁的,这样能让其他 goroutine 有机会检查或者更新等待变量。
</span><span class="c1">// Wait 原子式的 unlock c.L， 并暂停执行调用的 goroutine。
</span><span class="c1">// 在稍后执行后，Wait 会在返回前 lock c.L. 与其他系统不同，
</span><span class="c1">// 除非被 Broadcast 或 Signal 唤醒，否则等待无法返回。
</span><span class="c1">//
</span><span class="c1">// 因为等待第一次 resume 时 c.L 没有被锁定，所以当 Wait 返回时，
</span><span class="c1">// 调用者通常不能认为条件为真。相反，调用者应该在循环中使用 Wait()：
</span><span class="c1">//
</span><span class="c1">//    c.L.Lock()
</span><span class="c1">//    for !condition() {
</span><span class="c1">//        c.Wait()
</span><span class="c1">//    }
</span><span class="c1">//    ... make use of condition ...
</span><span class="c1">//    c.L.Unlock()
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 增加到等待队列中
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">runtime_notifyListAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 阻塞休眠直到被唤醒
</span><span class="c1"></span>	<span class="nf">runtime_notifyListWait</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Signal wakes one goroutine waiting on c, if there is any.
</span><span class="c1">//
</span><span class="c1">// It is allowed but not required for the caller to hold c.L
</span><span class="c1">// during the call.
</span><span class="c1">// Signal 和 Broadcast 只涉及到 notifyList 数据结构,不涉及到锁。
</span><span class="c1">// Signal 唤醒一个等待 c 的 goroutine（如果存在）
</span><span class="c1">//
</span><span class="c1">// 在调用时它可以（不必须）持有一个 c.L
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Signal</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nf">runtime_notifyListNotifyOne</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Broadcast wakes all goroutines waiting on c.
</span><span class="c1">//
</span><span class="c1">// It is allowed but not required for the caller to hold c.L
</span><span class="c1">// during the call.
</span><span class="c1">// Broadcast 唤醒等待 c 的所有 goroutine
</span><span class="c1">//
</span><span class="c1">// 调用时它可以（不必须）持久有个 c.L
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Broadcast</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nf">runtime_notifyListNotifyAll</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="copychecker">copyChecker<a hidden class="anchor" aria-hidden="true" href="#copychecker">#</a></h3>
<p>copyChecker 非常简单，它实现了一个 check() 方法，这个方法以 copyChecker 的指针作为 reciever， 因为 copyChecker 在一个 Cond 中并非指针，因此当 Cond 发生拷贝行为后，这个 reciever 会 发生变化，从而检测到拷贝行为，使用 panic 以警示用户：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// copyChecker holds back pointer to itself to detect object copying.
</span><span class="c1">// copyChecker 是一个辅助结构,可以在运行时检查 Cond 是否被复制使用。
</span><span class="c1">// copyChecker 保存指向自身的指针来检测对象的复制行为。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">copyChecker</span> <span class="kt">uintptr</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">copyChecker</span><span class="p">)</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">c</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
		<span class="nb">uintptr</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync.Cond is copied&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="notifylist">notifyList<a hidden class="anchor" aria-hidden="true" href="#notifylist">#</a></h3>
<p>runtime_notifyListXXX 是运行时实现的方法,实现了一个等待 / 通知的队列。</p>
<p>notifyList 结构本质上是一个队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyList 基于 ticket 实现通知列表
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">notifyList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// wait 为下一个 waiter 的 ticket 编号
</span><span class="c1"></span>	<span class="c1">// 在没有 lock 的情况下原子自增
</span><span class="c1"></span>	<span class="nx">wait</span> <span class="kt">uint32</span>

	<span class="c1">// notify 是下一个被通知的 waiter 的 ticket 编号
</span><span class="c1"></span>	<span class="c1">// 它可以在没有 lock 的情况下进行读取，但只有在持有 lock 的情况下才能进行写
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// wait 和 notify 会产生 wrap around，只要它们 &#34;unwrapped&#34;
</span><span class="c1"></span>	<span class="c1">// 的差别小于 2^31，这种情况可以被正确处理。对于 wrap around 的情况而言，
</span><span class="c1"></span>	<span class="c1">// 我们需要超过 2^31+ 个 goroutine 阻塞在相同的 condvar 上，这是不可能的。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">notify</span> <span class="kt">uint32</span>

	<span class="c1">// waiter 列表.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">tail</span> <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当一个 Cond 调用 Wait 方法时候，向 wait 字段加 1，并返回一个 ticket 编号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListAdd 将调用者添加到通知列表，以便接收通知。
</span><span class="c1">// 调用者最终必须调用 notifyListWait 等待这样的通知，并传递返回的 ticket 编号。
</span><span class="c1">//go:linkname notifyListAdd sync.runtime_notifyListAdd
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListAdd</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="c1">// 这可以并发调用，例如，当在 read 模式下保持 RWMutex 时从 sync.Cond.Wait 调用时。
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而后使用这个 ticket 编号来等待通知，这个过程会将等待通知的 goroutine 进行停泊，进入等待状态， 并将其 M 与 P 解绑，从而将 G 从 M 身上剥离，放入等待队列 sudog 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListWait 等待通知。如果在调用 notifyListAdd 后发送了一个，则立即返回。否则，它会阻塞。
</span><span class="c1">//go:linkname notifyListWait sync.runtime_notifyListWait
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListWait</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 如果 ticket 编号对应的 goroutine 已经被通知到，则立刻返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">less</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">ticket</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">t0</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="p">}</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="c1">// 将 M/P/G 解绑，并将 G 调整为等待状态，放入 sudog 等待队列中
</span><span class="c1"></span>	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonSyncCondWait</span><span class="p">,</span> <span class="nx">traceEvGoBlockCond</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 将当前 goroutine 置于等待状态并解锁 lock。
</span><span class="c1">// 通过调用 goready(gp) 可让 goroutine 再次 runnable
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goparkunlock</span><span class="p">(</span><span class="nx">lock</span> <span class="o">*</span><span class="nx">mutex</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">gopark</span><span class="p">(</span><span class="nx">parkunlock_c</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">reason</span><span class="p">,</span> <span class="nx">traceEv</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当调用 Signal 时，会有一个在等待的 goroutine 被通知到，具体过程就是从 sudog 列表中找到 要通知的 goroutine，而后将其 goready 来等待调度循环将其调度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListNotifyOne 通知列表中的一个条目
</span><span class="c1">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListNotifyOne</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Fast-path: 如果上次通知后没有新的 waiter
</span><span class="c1"></span>	<span class="c1">// 则无需加锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// slow-path 的二次检查
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">notify</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 更新下一个需要唤醒的 ticket 编号
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 尝试找到需要被通知的 g
</span><span class="c1"></span>	<span class="c1">// 如果目前还没来得及入队，是无法找到的
</span><span class="c1"></span>	<span class="c1">// 但是，当它看到通知编号已经发生改变是不会被 park 的
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 这个查找过程看起来是线性复杂度，但实际上很快就停了
</span><span class="c1"></span>	<span class="c1">// 因为 g 的队列与获取编号不同，因而队列中会出现少量重排，但我们希望找到靠前的 g
</span><span class="c1"></span>	<span class="c1">// 而 g 只有在不再 race 后才会排在靠前的位置，因此这个迭代也不会太久，
</span><span class="c1"></span>	<span class="c1">// 同时，即便找不到 g，这个情况也成立：
</span><span class="c1"></span>	<span class="c1">// 它还没有休眠，并且已经失去了我们在队列上找到的（少数）其他 g 的 race。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">sudog</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ticket</span> <span class="o">==</span> <span class="nx">t</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
			<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="p">}</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nf">readyWithTime</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">readyWithTime</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goready</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是全员通知，基本类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListNotifyAll 通知列表里的所有人
</span><span class="c1">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListNotifyAll</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Fast-path: 如果上次通知后没有新的 waiter
</span><span class="c1"></span>	<span class="c1">// 则无需加锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 从列表中取一个，保存到局部变量，waiter 则可以在无锁的情况下 ready
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// 更新要通知的下一个 ticket。
</span><span class="c1"></span>	<span class="c1">// 可以将它设置为等待的当前值，因为任何以前的 waiter 已经在列表中，
</span><span class="c1"></span>	<span class="c1">// 或者会他们在尝试将自己添加到列表时已经收到通知。
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 遍历整个本地列表，并 ready 所有的 waiter
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nf">readyWithTime</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://colobu.com/2017/07/11/dive-into-sync-Map">https://colobu.com/2017/07/11/dive-into-sync-Map</a></p>
<p><a href="https://segmentfault.com/a/1190000015242373">https://segmentfault.com/a/1190000015242373</a></p>
<p><a href="https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/">https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/</a></p>
<p><a href="http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html">http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html</a></p>
<p><a href="http://www.gogodjzhu.com/index.php/code/basic/397/">http://www.gogodjzhu.com/index.php/code/basic/397/</a></p>
<p><a href="http://russellluo.com/2017/06/go-sync-map-diagram.html">http://russellluo.com/2017/06/go-sync-map-diagram.html</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/cond/">5.4 条件变量</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/waitgroup/">5.5 同步组</a></p>
<p><a href="https://blog.csdn.net/sinat_41790904/article/details/115416237">Go 标准库源码分析 - sync 包的Pool</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/map/">5.7 并发安全散列表</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">6.1 上下文 Context</a></p>
<p><a href="https://juejin.cn/post/6844903741842259975">go context剖析之源码分析</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/atomic/">5.3 原子操作</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
