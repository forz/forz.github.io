<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的timer源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.88.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84timer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的timer源码剖析" />
<meta property="og:description" content="前言 准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84timer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-21T15:23:59+00:00" />
<meta property="article:modified_time" content="2019-10-21T15:23:59+00:00" />

<meta itemprop="name" content="Go的timer源码剖析">
<meta itemprop="description" content="前言 准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把"><meta itemprop="datePublished" content="2019-10-21T15:23:59+00:00" />
<meta itemprop="dateModified" content="2019-10-21T15:23:59+00:00" />
<meta itemprop="wordCount" content="16548">
<meta itemprop="keywords" content="Go,计时器," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的timer源码剖析"/>
<meta name="twitter:description" content="前言 准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的timer源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-21 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 16548 字 </span>
          <span class="more-meta"> 预计阅读 34 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#设计原理">设计原理</a>
      <ul>
        <li><a href="#全局四叉堆">全局四叉堆</a></li>
        <li><a href="#分片四叉堆">分片四叉堆</a></li>
        <li><a href="#timer-114">timer 1.14</a></li>
      </ul>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ul>
        <li><a href="#timer">timer</a></li>
        <li><a href="#timer-1">Timer</a></li>
        <li><a href="#四叉小顶堆">四叉小顶堆</a></li>
      </ul>
    </li>
    <li><a href="#状态机">状态机</a>
      <ul>
        <li><a href="#addtimer">addtimer</a></li>
        <li><a href="#deltimer">deltimer</a></li>
        <li><a href="#modtimer">modtimer</a></li>
        <li><a href="#cleantimers">cleantimers</a></li>
        <li><a href="#adjusttimers">adjusttimers</a></li>
        <li><a href="#runtimer">runtimer</a></li>
      </ul>
    </li>
    <li><a href="#触发时机">触发时机</a>
      <ul>
        <li><a href="#调度器">调度器</a></li>
        <li><a href="#系统监控">系统监控</a></li>
      </ul>
    </li>
    <li><a href="#核心api">核心API</a>
      <ul>
        <li><a href="#newtimer">NewTimer</a></li>
        <li><a href="#timerafter">timer.After</a></li>
        <li><a href="#timerafterfunc">Timer.AfterFunc</a></li>
        <li><a href="#timertick">timer.Tick</a></li>
        <li><a href="#timerreset">Timer.Reset</a></li>
        <li><a href="#timerstop--tickerstop">Timer.Stop &amp; Ticker.Stop</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>准确的时间对于任何一个正在运行的应用非常重要，但是在分布式系统中我们很难保证各个节点的绝对时间一致，哪怕通过 NTP 这种标准的对时协议也只能把各个节点上时间的误差控制在毫秒级，所以准确的相对时间在分布式系统中显得更为重要，本节会分析用于获取相对时间的计时器的设计与实现原理。</p>
<h2 id="设计原理">设计原理</h2>
<p>Go 语言从实现计时器到现在经历过很多个版本的迭代，到最新的版本为止，计时器的实现分别经历了以下几个过程：</p>
<ol>
<li>Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；</li>
<li>Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；</li>
<li>Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；</li>
</ol>
<p>我们在这一节会分别介绍计时器在不同版本的不同设计，梳理计时器实现的演进过程。</p>
<h3 id="全局四叉堆">全局四叉堆</h3>
<p>Go 1.10 之前的计时器都使用最小四叉堆实现，所有的计时器都会存储在如下所示的结构体 runtime.timers:093adee 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">timers</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>         <span class="nx">mutex</span>
	<span class="nx">gp</span>           <span class="o">*</span><span class="nx">g</span>
	<span class="nx">created</span>      <span class="kt">bool</span>
	<span class="nx">sleeping</span>     <span class="kt">bool</span>
	<span class="nx">rescheduling</span> <span class="kt">bool</span>
	<span class="nx">sleepUntil</span>   <span class="kt">int64</span>
	<span class="nx">waitnote</span>     <span class="nx">note</span>
	<span class="nx">t</span>            <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个结构体中的字段 t 就是最小四叉堆，运行时创建的所有计时器都会加入到四叉堆中。<code>runtime.timerproc:093adee Goroutine</code> 会运行时间驱动的事件，运行时会在发生以下事件时唤醒计时器：</p>
<ul>
<li>四叉堆中的计时器到期；</li>
<li>四叉堆中加入了触发时间更早的新计时器；</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210706235449.png" alt=""></p>
<p>然而全局四叉堆共用的互斥锁对计时器的影响非常大，计时器的各种操作都需要获取全局唯一的互斥锁，这会严重影响计时器的性能.</p>
<h3 id="分片四叉堆">分片四叉堆</h3>
<p>Go 1.10 将全局的四叉堆分割成了 64 个更小的四叉堆。在理想情况下，四叉堆的数量应该等于处理器的数量，但是这需要实现动态的分配过程，所以经过权衡最终选择初始化 64 个四叉堆，以牺牲内存占用的代价换取性能的提升。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">timersLen</span> <span class="p">=</span> <span class="mi">64</span>

<span class="kd">var</span> <span class="nx">timers</span> <span class="p">[</span><span class="nx">timersLen</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">timersBucket</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">timersBucket</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>         <span class="nx">mutex</span>
	<span class="nx">gp</span>           <span class="o">*</span><span class="nx">g</span>
	<span class="nx">created</span>      <span class="kt">bool</span>
	<span class="nx">sleeping</span>     <span class="kt">bool</span>
	<span class="nx">rescheduling</span> <span class="kt">bool</span>
	<span class="nx">sleepUntil</span>   <span class="kt">int64</span>
	<span class="nx">waitnote</span>     <span class="nx">note</span>
	<span class="nx">t</span>            <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前机器上的处理器 P 的个数超过了 64，多个处理器上的计时器就可能存储在同一个桶中。每一个计时器桶都由一个运行 <code>runtime.timerproc:76f4fd8</code> 函数的 Goroutine 处理。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210707001631.png" alt=""></p>
<p>将全局计时器分片的方式，虽然能够降低锁的粒度，提高计时器的性能，但是 <code>runtime.timerproc:76f4fd8</code> 造成的处理器和线程之间频繁的上下文切换却成为了影响计时器性能的首要因素</p>
<h3 id="timer-114">timer 1.14</h3>
<ul>
<li>调整:
<ul>
<li>Timerheap和GMP中的P绑定</li>
<li>去除唤醒 goroutine: timerproc</li>
</ul>
</li>
<li>检查:
<ul>
<li>检查 timer 到期在特殊函数 checkTimers 中进行</li>
<li>检查 timer 操作移至调度循环中进行</li>
</ul>
</li>
<li>工作窃取:
<ul>
<li>在 work-stealing 中，会从其它 P 那里偷 timer</li>
</ul>
</li>
<li>兜底:
<ul>
<li>runtime.sysmon 中会为 timer 未被触发(timeSleepUntil)兜底，启动新线程</li>
</ul>
</li>
</ul>
<p>在最新版本的实现中，计时器桶已经被移除，所有的计时器都以最小四叉堆的形式存储在处理器 runtime.p 中。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210707144554.png" alt=""></p>
<p>处理器 runtime.p 中与计时器相关的有以下字段：</p>
<ul>
<li>timersLock — 用于保护计时器的互斥锁；</li>
<li>timers — 存储计时器的最小四叉堆；</li>
<li>numTimers — 处理器中的计时器数量；</li>
<li>adjustTimers — 处理器中处于 timerModifiedEarlier 状态的计时器数量；</li>
<li>deletedTimers — 处理器中处于 timerDeleted 状态的计时器数量；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 互斥锁
</span><span class="c1"></span>    <span class="nx">timersLock</span> <span class="nx">mutex</span>
    <span class="c1">// 存储计时器的最小四叉堆
</span><span class="c1"></span>    <span class="nx">timers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
    <span class="c1">// 计时器数量
</span><span class="c1"></span>    <span class="nx">numTimers</span> <span class="kt">uint32</span>
    <span class="c1">// 处于 timerModifiedEarlier 状态的计时器数量
</span><span class="c1"></span>    <span class="nx">adjustTimers</span> <span class="kt">uint32</span>
    <span class="c1">// 处于 timerDeleted 状态的计时器数量
</span><span class="c1"></span>    <span class="nx">deletedTimers</span> <span class="kt">uint32</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>原本用于管理计时器的 <code>runtime.timerproc:76f4fd8</code> 也已经被移除，目前计时器都交由处理器的网络轮询器和调度器触发，这种方式能够充分利用本地性、减少上下文的切换开销，也是目前性能最好的实现方式。</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="timer">timer</h3>
<p>runtime.timer 是 Go 语言计时器的内部表示，每一个计时器都存储在对应处理器的最小四叉堆中，下面是运行时计时器对应的结构体：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810212645.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">timer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">pp</span> <span class="nx">puintptr</span>

	<span class="nx">when</span>     <span class="kt">int64</span>
	<span class="nx">period</span>   <span class="kt">int64</span>
	<span class="nx">f</span>        <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">uintptr</span><span class="p">)</span>
	<span class="nx">arg</span>      <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">seq</span>      <span class="kt">uintptr</span>
	<span class="nx">nextwhen</span> <span class="kt">int64</span>
	<span class="nx">status</span>   <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>when — 当前计时器被唤醒的时间；</li>
<li>period — 唤醒间隔时间，定时器为Timer数据类型时，此字段值为 0 时，否则为 Ticker 数据类型.</li>
<li>f — 唤醒后执行的函数，不能为 闭包匿名函数</li>
<li>arg — 计时器被唤醒时调用 f 传入的参数；</li>
<li>nextWhen — 当定时器状态为 timerModifiedEarlier 或 timerModifiedLater 时，需要使用此字段值刷新为 when 字段</li>
<li>status — 计时器的状态；</li>
<li>pp - 当前对应的处理器P的指针</li>
</ul>
<h3 id="timer-1">Timer</h3>
<p>Timer 类型代表单次时间事件。当 Timer 到期时，当时的时间会被发送给 C (channel)，除非 Timer 是被 AfterFunc 函数创建的。</p>
<p>注意：Timer 的实例必须通过 NewTimer 或 AfterFunc 获得。</p>
<p>然而这里的 <code>runtime.timer</code> 只是计时器运行时的私有结构体，对外暴露的计时器使用 <code>time.Timer</code> 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/sleep.go
</span><span class="c1">// The Timer type represents a single event.
</span><span class="c1">// When the Timer expires, the current time will be sent on C,
</span><span class="c1">// unless the Timer was created by AfterFunc.
</span><span class="c1">// A Timer must be created with NewTimer or AfterFunc.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">C</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span>
    <span class="nx">r</span> <span class="nx">runtimeTimer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>time.Timer 计时器必须通过 time.NewTimer、time.AfterFunc 或者 time.After 函数创建。 当计时器失效时，订阅计时器 Channel 的 Goroutine 会收到计时器失效的时间。</p>
<p>C 已经解释了，我们看看 runtimeTimer。它定义在 sleep.go 文件中，必须和 runtime 包中 time.go 文件中的 timer 必须保持一致：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Interface to timers implemented in package runtime.
</span><span class="c1">// Must be in sync with ../runtime/time.go:/^type timer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">runtimeTimer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tb</span> <span class="kt">uintptr</span>
	<span class="nx">i</span>  <span class="kt">int</span>

	<span class="nx">when</span>   <span class="kt">int64</span>
	<span class="nx">period</span> <span class="kt">int64</span>
	<span class="nx">f</span>      <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="c1">// NOTE: must not be closure
</span><span class="c1"></span>	<span class="nx">arg</span>    <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">seq</span>    <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="四叉小顶堆">四叉小顶堆</h3>
<p>四叉堆高度上比二叉堆要矮一些。一个节点的所有(最多有4个)孩子节点都比这个节点要大。一个节点的(只有一个)父节点一定比当前节点小。下面是填好值之后的一个典型的四叉堆:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210707193528.png" alt=""></p>
<p>和二叉堆一样，对于一个节点的要求只有和其父节点以及子节点之间的大小关系。相邻节点之间没有任何关系。</p>
<h4 id="向上调整">向上调整</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Heap maintenance algorithms.
</span><span class="c1">// These algorithms check for slice index errors manually.
</span><span class="c1">// Slice index error can happen if the program is using racy
</span><span class="c1">// access to timers. We don&#39;t want to panic here, because
</span><span class="c1">// it will cause the program to crash with a mysterious
</span><span class="c1">// &#34;panic holding locks&#34; message. Instead, we panic while not
</span><span class="c1">// holding a lock.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">siftupTimer</span><span class="p">(</span><span class="nx">t</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">badTimer</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">// 先暂存当前刚插入到数组尾部的节点
</span><span class="c1"></span>	<span class="nx">when</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">when</span>
	<span class="k">if</span> <span class="nx">when</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">badTimer</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="c1">// 从当前插入节点的父节点开始
</span><span class="c1"></span>    <span class="c1">// 如果最新插入的那个节点的触发时间要比父节点的触发时间更早
</span><span class="c1"></span>    <span class="c1">// 那么就把这个父节点下移
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">// parent
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">when</span> <span class="o">&gt;=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">when</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">p</span>
	<span class="p">}</span>
    <span class="c1">// 如果发生过移动，用最新插入的节点
</span><span class="c1"></span>    <span class="c1">// 覆盖掉最后一个下移的父节点
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="向下调整">向下调整</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在所有孩子节点中先找出最小的那一个，如果最小的比当前要下移的节点还要大，那么就 break。反之，则将最小的节点上移，然后再判断这个最小节点的 4 个子节点是否都比要下移的节点大。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">t</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nf">badTimer</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">when</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">when</span>
	<span class="k">if</span> <span class="nx">when</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">badTimer</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">i</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// left child
</span><span class="c1"></span>		<span class="nx">c3</span> <span class="o">:=</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1">// mid child
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">w</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="p">].</span><span class="nx">when</span>
		<span class="k">if</span> <span class="nx">c</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">w</span> <span class="p">{</span>
			<span class="nx">w</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span>
			<span class="nx">c</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">c3</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nx">w3</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c3</span><span class="p">].</span><span class="nx">when</span>
			<span class="k">if</span> <span class="nx">c3</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">w3</span> <span class="p">{</span>
				<span class="nx">w3</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c3</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">when</span>
				<span class="nx">c3</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">w3</span> <span class="p">&lt;</span> <span class="nx">w</span> <span class="p">{</span>
				<span class="nx">w</span> <span class="p">=</span> <span class="nx">w3</span>
				<span class="nx">c</span> <span class="p">=</span> <span class="nx">c3</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">w</span> <span class="o">&gt;=</span> <span class="nx">when</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="状态机">状态机</h2>
<p>运行时使用状态机的方式处理全部的计时器，其中包括 10 种状态和几种操作。由于 Go 语言的计时器需要同时支持增加、删除、修改和重置等操作，所以它的状态非常复杂，目前会包含以下 10 种可能：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>timerNoStatus</td>
<td>还没有设置状态</td>
</tr>
<tr>
<td>timerWaiting</td>
<td>等待计时器启动,定时器在P堆中</td>
</tr>
<tr>
<td>timerRunning</td>
<td>定时器运行中，只很短暂的时间持有此状态</td>
</tr>
<tr>
<td>timerDeleted</td>
<td>定时器删除状态，后期不会运行，但仍会存在于P堆中</td>
</tr>
<tr>
<td>timerRemoving</td>
<td>正在移除，只有很短暂的时间持有此状态</td>
</tr>
<tr>
<td>timerRemoved</td>
<td>已移除，不在P堆中</td>
</tr>
<tr>
<td>timerModifying</td>
<td>正在修改中，只有很短暂的时间持有此状态</td>
</tr>
<tr>
<td>timerModifiedEarlier</td>
<td>定时器已修改为较早的时间，此时新的when值存储于 nextwhen 字段中。在P堆中，但有可以存储在错误的地方</td>
</tr>
<tr>
<td>timerModifiedLater</td>
<td>定时器修改为相同或较晚的状态，此时新的when值存储于 nextwhen 字段中。在P堆中，但有可以存储在错误的地方</td>
</tr>
<tr>
<td>timerMoving</td>
<td>定时器已修改并正在动</td>
</tr>
</tbody>
</table>
<p>上述表格已经展示了不同状态的含义，但是我们还需要展示一些重要的信息，例如状态的存在时间、计时器是否在堆上等：</p>
<ul>
<li>timerRunning、timerRemoving、timerModifying 和 timerMoving — 停留的时间都比较短；</li>
<li>timerWaiting、timerRunning、timerDeleted、timerRemoving、timerModifying、timerModifiedEarlier、timerModifiedLater 和 timerMoving — 计时器在处理器的堆上；</li>
<li>timerNoStatus 和 timerRemoved — 计时器不在堆上；</li>
<li>timerModifiedEarlier 和 timerModifiedLater — 计时器虽然在堆上，但是可能位于错误的位置上，需要重新排序；</li>
</ul>
<p>当我们操作计时器时，运行时会根据状态的不同而做出反应，所以在分析计时器时会将状态作为切入点分析其实现原理。计时器的状态机中包含如下所示的 7 种不同操作，它们分别承担了不同的职责：</p>
<ul>
<li>runtime.addtimer — 向当前处理器增加新的计时器；</li>
<li>runtime.deltimer — 将计时器标记成 timerDeleted 删除处理器中的计时器；</li>
<li>runtime.modtimer — 网络轮询器会调用该函数修改计时器10；</li>
<li>runtime.cleantimers — 清除队列头中的计时器，能够提升程序创建和删除计时器的性能；</li>
<li>runtime.adjusttimers — 调整处理器持有的计时器堆，包括移动会稍后触发的计时器、删除标记为 timerDeleted 的计时器；</li>
<li>runtime.runtimer — 检查队列头中的计时器，在其准备就绪时运行该计时器；</li>
</ul>
<p>我们在这里会依次分析计时器的上述 7 个不同操作。</p>
<h3 id="addtimer">addtimer</h3>
<p>当我们调用 time.NewTimer 增加新的计时器时，会执行程序中的 runtime.addtimer 函数根据以下的规则处理计时器：</p>
<ul>
<li>timerNoStatus -&gt; timerWaiting</li>
<li>其他状态 -&gt; 崩溃：不合法的状态</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// addtimer adds a timer to the current P.
</span><span class="c1">// This should only be called with a newly created timer.
</span><span class="c1">// That avoids the risk of changing the when field of a timer in some P&#39;s heap,
</span><span class="c1">// which could cause the heap to become unsorted.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">addtimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// addtimer 会对 timer 被唤醒的时间 when 进行校验，以及校验 status 必须是新出初始化的 timer；
</span><span class="c1"></span>    <span class="c1">// 定时器被唤醒的时间的时间不能为负数
</span><span class="c1"></span>	<span class="c1">// when must be positive. A negative value will cause runtimer to
</span><span class="c1"></span>	<span class="c1">// overflow during its delta calculation and never expire other runtime
</span><span class="c1"></span>	<span class="c1">// timers. Zero will cause checkTimers to fail to notice the timer.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;timer when must be positive&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;timer period must be non-negative&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 状态必须为初始化
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">timerNoStatus</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;addtimer called with initialized timer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 设置为等待调度
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">timerWaiting</span>

	<span class="nx">when</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span>

	<span class="c1">// Disable preemption while using pp to avoid changing another P&#39;s heap.
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
    <span class="c1">// 获取当前 P
</span><span class="c1"></span>	<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
    <span class="c1">// 接着会在加锁后调用 cleantimers 对 P 中对应的 timer 列表的头节点进行清理工作，清理完后调用 doaddtimer 将 timer 加入到 P 的最小堆中，并释放锁；
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
    <span class="c1">// 清理 P 的 timer 列表头中的 timer
</span><span class="c1"></span>	<span class="nf">cleantimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
    <span class="c1">// 将 timer 加入到 P 的最小堆中
</span><span class="c1"></span>	<span class="nf">doaddtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
    <span class="c1">// 唤醒 netpoller 中休眠的线程
</span><span class="c1"></span>    <span class="c1">// 调用 wakeNetPoller 唤醒 netpoller 中休眠的线程。
</span><span class="c1"></span>	<span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span><span class="p">)</span>

	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>操作顺序为</p>
<ol>
<li>检查定时器状态和当前P的状态(初始化状态)是否满足条件</li>
<li>获取当前G所在的P</li>
<li>加P加 timerLock 锁</li>
<li>调用 cleantimers() 函数清除P队列头中的 timers，并将 timer 添加的P的最小堆中</li>
<li>解 timerLock 锁</li>
<li>调用 wakeNetPoller 函数，唤醒网络轮询器中休眠的线程,检查计时器被唤醒的时间（when）是否在当前轮询预期运行的时间（pollerPollUntil）内，若是则唤醒。</li>
</ol>
<p>每次增加新的计时器都会中断正在阻塞的轮询，触发调度器检查是否有计时器到期，我们会在后面详细介绍计时器的触发过程。</p>
<h4 id="doaddtimer">doaddtimer</h4>
<p>doaddtimer 函数实际上很简单，主要是将 timer 与 P 设置关联关系，并将 timer 加入到 P 的 timer 列表中，并维护 timer 列表最小堆的顺序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// doaddtimer adds t to the current P&#39;s heap.
</span><span class="c1">// The caller must have locked the timers for pp.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">doaddtimer</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Timers rely on the network poller, so make sure the poller
</span><span class="c1"></span>	<span class="c1">// has started.
</span><span class="c1"></span>    <span class="c1">// Timers 依赖于 netpoller
</span><span class="c1"></span>    <span class="c1">// 所以如果 netpoller 没有启动，需要启动一下
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">netpollInited</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">netpollGenericInit</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">// 校验是否早已在 timer 列表中
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;doaddtimer: P already set in timer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">// 设置 timer 与 P 的关联
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span>
    <span class="c1">// 将 timer 加入到 P 的 timer 列表中
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
    <span class="c1">// 维护 timer 在 最小堆中的位置
</span><span class="c1"></span>	<span class="nf">siftupTimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="c1">// 如果 timer 是列表中头节点，需要设置一下 timer0When
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timer0When</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">when</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">numTimers</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="wakenetpoller">wakeNetPoller</h4>
<p>wakeNetPoller 主要是将 timer 下次调度的时间和 netpoller 的下一次轮询时间相比，如果小于的话，调用 netpollBreak 向 netpollBreakWr 里面写入数据，立即中断netpoll.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// wakeNetPoller wakes up the thread sleeping in the network poller if it isn&#39;t
</span><span class="c1">// going to wake up before the when argument; or it wakes an idle P to service
</span><span class="c1">// timers and the network poller if there isn&#39;t one already.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果计时器的触发时间小于netpoller的下一次轮询时间
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// In findrunnable we ensure that when polling the pollUntil
</span><span class="c1"></span>		<span class="c1">// field is either zero or the time to which the current
</span><span class="c1"></span>		<span class="c1">// poll is expected to run. This can have a spurious wakeup
</span><span class="c1"></span>		<span class="c1">// but should never miss a wakeup.
</span><span class="c1"></span>		<span class="nx">pollerPollUntil</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pollUntil</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">pollerPollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pollerPollUntil</span> <span class="p">&gt;</span> <span class="nx">when</span> <span class="p">{</span>
            <span class="c1">// 向netpollBreakWr里面写入数据，立即中断netpoll
</span><span class="c1"></span>			<span class="nf">netpollBreak</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// There are no threads in the network poller, try to get
</span><span class="c1"></span>		<span class="c1">// one there so it can handle new timers.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// Temporary workaround - see issue #42303.
</span><span class="c1"></span>			<span class="nf">wakep</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// netpollBreak interrupts a kevent.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollBreak</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWakeSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nf">write</span><span class="p">(</span><span class="nx">netpollBreakWr</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EAGAIN</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="o">-</span><span class="nx">_EINTR</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: netpollBreak write failed with&#34;</span><span class="p">,</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpollBreak write failed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那么它是如何做到的？我们下面先来看一个官方的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestNetpollBreak</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Skip</span><span class="p">(</span><span class="s">&#34;skipping: GOMAXPROCS=1&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 初始化 netpoll
</span><span class="c1"></span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">NetpollGenericInit</span><span class="p">()</span>

    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">c</span> <span class="o">&lt;-</span> <span class="kc">true</span>
        <span class="c1">// netpoll 等待时间
</span><span class="c1"></span>        <span class="nx">runtime</span><span class="p">.</span><span class="nf">Netpoll</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">.</span><span class="nf">Nanoseconds</span><span class="p">())</span>
        <span class="nx">c</span> <span class="o">&lt;-</span> <span class="kc">true</span>
    <span class="p">}()</span>
    <span class="o">&lt;-</span><span class="nx">c</span>
<span class="nx">loop</span><span class="p">:</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">runtime</span><span class="p">.</span><span class="nf">Usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="c1">// 中断netpoll 等待
</span><span class="c1"></span>        <span class="nx">runtime</span><span class="p">.</span><span class="nf">NetpollBreak</span><span class="p">()</span>
        <span class="nx">runtime</span><span class="p">.</span><span class="nf">NetpollBreak</span><span class="p">()</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
            <span class="k">break</span> <span class="nx">loop</span>
        <span class="k">default</span><span class="p">:</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span> <span class="nx">dur</span> <span class="p">&gt;</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;netpollBreak did not interrupt netpoll: slept for: %v&#34;</span><span class="p">,</span> <span class="nx">dur</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上面这个例子中，首先会调用 <code>runtime.Netpoll</code>进行阻塞等待，然后循环调度 <code>runtime.NetpollBreak</code>进行中断阻塞。</p>
<p>runtime.netpoll</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">netpoll</span><span class="p">(</span><span class="nx">delay</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">gList</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">gList</span><span class="p">{}</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">waitms</span> <span class="kt">int32</span>
    <span class="c1">// 因为传入delay单位是纳秒，下面将纳秒转换成毫秒
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">waitms</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">waitms</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mf">1e6</span> <span class="p">{</span>
        <span class="nx">waitms</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delay</span> <span class="p">&lt;</span> <span class="mf">1e15</span> <span class="p">{</span>
        <span class="nx">waitms</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delay</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">waitms</span> <span class="p">=</span> <span class="mf">1e9</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">events</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="nx">epollevent</span>
<span class="nx">retry</span><span class="p">:</span>
    <span class="c1">// 等待文件描述符转换成可读或者可写
</span><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nf">epollwait</span><span class="p">(</span><span class="nx">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">events</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">events</span><span class="p">)),</span> <span class="nx">waitms</span><span class="p">)</span>
    <span class="c1">// 返回负值，那么重新调用epollwait进行等待
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">goto</span> <span class="nx">retry</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">toRun</span> <span class="nx">gList</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">ev</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">events</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 如果是 NetpollBreak 中断的，那么执行 continue 跳过
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ev</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">netpollBreakRd</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span> <span class="o">!=</span> <span class="nx">_EPOLLIN</span> <span class="p">{</span>
                <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: netpoll: break fd ready for&#34;</span><span class="p">,</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">events</span><span class="p">)</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: netpoll: break fd ready for something unexpected&#34;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">delay</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">tmp</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
                <span class="nf">read</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nx">netpollBreakRd</span><span class="p">),</span> <span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tmp</span><span class="p">)))</span>
                <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWakeSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">toRun</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在调用runtime.findrunnable执行抢占时，最后会传入一个时间，超时阻塞调用 netpoll，如果没有事件中断，那么循环调度会一直等待直到 netpoll 超时后才往下进行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// checkTimers ensures that polluntil &gt; now.
</span><span class="c1"></span>        <span class="nx">delta</span> <span class="p">=</span> <span class="nx">pollUntil</span> <span class="o">-</span> <span class="nx">now</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="c1">// poll network
</span><span class="c1"></span>    <span class="c1">// 休眠前再次检查 poll 网络
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">pollUntil</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">// 阻塞调用
</span><span class="c1"></span>        <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span>

    <span class="p">}</span>
    <span class="o">...</span>
    <span class="c1">// 休眠当前 M
</span><span class="c1"></span>    <span class="nf">stopm</span><span class="p">()</span>
    <span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所以在调用 runtime.addtimer 添加 timer 的时候进行 netpoll 的中断操作可以更加灵敏的响应 timer 这类时间敏感的任务。</p>
<h3 id="deltimer">deltimer</h3>
<p><code>runtime.deltimer</code> 函数会标记需要删除的计时器，它会根据以下的规则处理计时器：</p>
<ul>
<li>timerWaiting -&gt; timerModifying -&gt; timerDeleted</li>
<li>timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted</li>
<li>timerModifiedLater -&gt; timerModifying -&gt; timerDeleted</li>
<li>其他状态 -&gt; 等待状态改变或者直接返回</li>
</ul>
<p>对于timer 的删除不能直接从堆中删除，因为它可能不在当前的P，而是在在其它的P堆上，所以只能将其标记为删除状态，并由持有计时器的处理器完成清除工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// deltimer deletes the timer t. It may be on some other P, so we can&#39;t
</span><span class="c1">// actually remove it from the timers heap. We can only mark it as deleted.
</span><span class="c1">// It will be removed in due course by the P whose heap it is on.
</span><span class="c1">// Reports whether the timer was removed before it was run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deltimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">timerWaiting</span><span class="p">,</span> <span class="nx">timerModifiedLater</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// Must fetch t.pp before changing status,
</span><span class="c1"></span>				<span class="c1">// as cleantimers in another goroutine
</span><span class="c1"></span>				<span class="c1">// can clear t.pp of a timerDeleted timer.
</span><span class="c1"></span>				<span class="nx">tpp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">,</span> <span class="nx">timerDeleted</span><span class="p">)</span> <span class="p">{</span>
					<span class="nf">badTimer</span><span class="p">()</span>
				<span class="p">}</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tpp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="c1">// Timer was not yet run.
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">timerModifiedEarlier</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// Must fetch t.pp before setting status
</span><span class="c1"></span>				<span class="c1">// to timerDeleted.
</span><span class="c1"></span>				<span class="nx">tpp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tpp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">,</span> <span class="nx">timerDeleted</span><span class="p">)</span> <span class="p">{</span>
					<span class="nf">badTimer</span><span class="p">()</span>
				<span class="p">}</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tpp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="c1">// Timer was not yet run.
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">timerDeleted</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">:</span>
			<span class="c1">// Timer was already run.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">false</span>
		<span class="k">case</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">:</span>
			<span class="c1">// The timer is being run or moved, by a different P.
</span><span class="c1"></span>			<span class="c1">// Wait for it to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">timerNoStatus</span><span class="p">:</span>
			<span class="c1">// Removing timer that was never added or
</span><span class="c1"></span>			<span class="c1">// has already been run. Also see issue 21874.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">false</span>
		<span class="k">case</span> <span class="nx">timerModifying</span><span class="p">:</span>
			<span class="c1">// Simultaneous calls to deltimer and modtimer.
</span><span class="c1"></span>			<span class="c1">// Wait for the other call to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="modtimer">modtimer</h3>
<p>runtime.modtimer 会修改已经存在的计时器，它会根据以下的规则处理计时器：</p>
<ul>
<li>timerWaiting -&gt; timerModifying -&gt; timerModifiedXX</li>
<li>timerModifiedXX -&gt; timerModifying -&gt; timerModifiedYY</li>
<li>timerNoStatus -&gt; timerModifying -&gt; timerWaiting</li>
<li>timerRemoved -&gt; timerModifying -&gt; timerWaiting</li>
<li>timerDeleted -&gt; timerModifying -&gt; timerWaiting</li>
<li>其他状态 -&gt; 等待状态改变</li>
</ul>
<p>modtimer 进入到 for 循环后会根据不同的状态做状态设置以及必要字段的处理；如果是 timer 已被删除，那么需要重新添加到 timer 列表中；如果 timer 修改后的时间小于修改前的时间，将状态设置为 timerModifiedEarlier，修改时间提前，还需要触发 netpoll 中断。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// modtimer modifies an existing timer.
</span><span class="c1">// This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset.
</span><span class="c1">// Reports whether the timer was modified before it was run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">modtimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">when</span><span class="p">,</span> <span class="nx">period</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">uintptr</span><span class="p">),</span> <span class="nx">arg</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">when</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;timer when must be positive&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">period</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;timer period must be non-negative&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">status</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">timerNoStatus</span><span class="p">)</span>
	<span class="nx">wasRemoved</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">var</span> <span class="nx">pending</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span>
<span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 修改 timer 状态
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">status</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="nx">status</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">timerWaiting</span><span class="p">,</span> <span class="nx">timerModifiedEarlier</span><span class="p">,</span> <span class="nx">timerModifiedLater</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">pending</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// timer not yet run
</span><span class="c1"></span>				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">timerNoStatus</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>

			<span class="c1">// Timer was already run and t is no longer in a heap.
</span><span class="c1"></span>			<span class="c1">// Act like addtimer.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">wasRemoved</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">pending</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// timer already run or stopped
</span><span class="c1"></span>				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">timerDeleted</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="nx">pending</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// timer already stopped
</span><span class="c1"></span>				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">:</span>
			<span class="c1">// The timer is being run or moved, by a different P.
</span><span class="c1"></span>			<span class="c1">// Wait for it to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">timerModifying</span><span class="p">:</span>
			<span class="c1">// Multiple simultaneous calls to modtimer.
</span><span class="c1"></span>			<span class="c1">// Wait for the other call to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="p">=</span> <span class="nx">period</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">f</span> <span class="p">=</span> <span class="nx">f</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">arg</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">seq</span> <span class="p">=</span> <span class="nx">seq</span>
    <span class="c1">// 如果 timer 已被删除，那么需要重新添加到 timer 列表中
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wasRemoved</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">when</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="nf">doaddtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">,</span> <span class="nx">timerWaiting</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// The timer is in some other P&#39;s heap, so we can&#39;t change
</span><span class="c1"></span>		<span class="c1">// the when field. If we did, the other P&#39;s heap would
</span><span class="c1"></span>		<span class="c1">// be out of order. So we put the new when value in the
</span><span class="c1"></span>		<span class="c1">// nextwhen field, and let the other P set the when field
</span><span class="c1"></span>		<span class="c1">// when it is prepared to resort the heap.
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">nextwhen</span> <span class="p">=</span> <span class="nx">when</span>

		<span class="nx">newStatus</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">timerModifiedLater</span><span class="p">)</span>
        <span class="c1">// 如果修改后的时间小于修改前的时间，将状态设置为 timerModifiedEarlier
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">{</span>
			<span class="nx">newStatus</span> <span class="p">=</span> <span class="nx">timerModifiedEarlier</span>
		<span class="p">}</span>

		<span class="nx">tpp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>

		<span class="c1">// Update the adjustTimers field.  Subtract one if we
</span><span class="c1"></span>		<span class="c1">// are removing a timerModifiedEarlier, add one if we
</span><span class="c1"></span>		<span class="c1">// are adding a timerModifiedEarlier.
</span><span class="c1"></span>		<span class="nx">adjust</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
			<span class="nx">adjust</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">newStatus</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
			<span class="nx">adjust</span><span class="o">++</span>
			<span class="nf">updateTimerModifiedEarliest</span><span class="p">(</span><span class="nx">tpp</span><span class="p">,</span> <span class="nx">when</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">adjust</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tpp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">,</span> <span class="nx">adjust</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Set the new status of the timer.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">,</span> <span class="nx">newStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

		<span class="c1">// If the new status is earlier, wake up the poller.
</span><span class="c1"></span>        <span class="c1">// 如果修改时间提前，那么触发 netpoll 中断
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">newStatus</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
			<span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">pending</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果待修改的计时器已经被删除，那么该函数会调用 runtime.doaddtimer 创建新的计时器。在正常情况下会根据修改后的时间进行不同的处理：</p>
<ul>
<li>如果修改后的时间大于或者等于修改前时间，设置计时器的状态为 timerModifiedLater；</li>
<li>如果修改后的时间小于修改前时间，设置计时器的状态为 timerModifiedEarlier 并调用 runtime.netpollBreak 触发调度器的重新调度；</li>
</ul>
<p>因为修改后的时间会影响计时器的处理，所以用于修改计时器的 runtime.modtimer 也是状态机中最复杂的函数了。</p>
<h3 id="cleantimers">cleantimers</h3>
<p>runtime.cleantimers 函数会根据状态清理处理器队列头中的计时器，该函数会遵循以下的规则修改计时器的触发时间：</p>
<ul>
<li>timerDeleted -&gt; timerRemoving -&gt; timerRemoved</li>
<li>timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</li>
</ul>
<p>cleantimers 函数中使用了一个无限循环来获取头节点。如果头节点的状态是 timerDeleted ，那么需要从 timer 列表中删除；如果头节点的状态是 timerModifiedEarlier 或 timerModifiedLater ，表示头节点的触发的时间被修改到了更早或更晚的时间，那么就先从timer队列中删除再重新添加。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// cleantimers cleans up the head of the timer queue. This speeds up
</span><span class="c1">// programs that create and delete timers; leaving them in the heap
</span><span class="c1">// slows down addtimer. Reports whether no timer problems were found.
</span><span class="c1">// The caller must have locked the timers for pp.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">cleantimers</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 调度器列表为空，直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// This loop can theoretically run for a while, and because
</span><span class="c1"></span>		<span class="c1">// it is holding timersLock it cannot be preempted.
</span><span class="c1"></span>		<span class="c1">// If someone is trying to preempt us, just return.
</span><span class="c1"></span>		<span class="c1">// We can clean the timers later.
</span><span class="c1"></span>        <span class="c1">// 如果当前 G 被抢占了，直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 获取第一个 timer
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">pp</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cleantimers: bad p&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">timerDeleted</span><span class="p">:</span>
            <span class="c1">// 设置 timer 的状态
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="c1">// 删除第一个 timer
</span><span class="c1"></span>			<span class="nf">dodeltimer0</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
            <span class="c1">// 删除完毕后重置状态为 timerRemoved
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">badTimer</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// timer 被修改到了更早或更晚的时间
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">timerModifiedEarlier</span><span class="p">,</span> <span class="nx">timerModifiedLater</span><span class="p">:</span>
            <span class="c1">// 将 timer 状态设置为 timerMoving
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// Now we can change the when field.
</span><span class="c1"></span>            <span class="c1">// 重新设置 when 字段
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nextwhen</span>
			<span class="c1">// Move t to the right position.
</span><span class="c1"></span>            <span class="c1">// 在列表中删除后重新加入
</span><span class="c1"></span>			<span class="nf">dodeltimer0</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
			<span class="nf">doaddtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
            <span class="c1">// 设置状态为 timerWaiting
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">,</span> <span class="nx">timerWaiting</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">badTimer</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// Head of timers does not need adjustment.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.cleantimers 函数只会处理计时器状态为 timerDeleted、timerModifiedEarlier 和 timerModifiedLater 的情况：</p>
<ul>
<li>如果计时器的状态为 timerDeleted；
<ul>
<li>将计时器的状态修改成 timerRemoving；</li>
<li>调用 runtime.dodeltimer0 删除四叉堆顶上的计时器；</li>
<li>将计时器的状态修改成 timerRemoved；</li>
</ul>
</li>
<li>如果计时器的状态为 timerModifiedEarlier 或者 timerModifiedLater；
<ul>
<li>将计时器的状态修改成 timerMoving；</li>
<li>使用计时器下次触发的时间 nextWhen 覆盖 when；</li>
<li>调用 runtime.dodeltimer0 删除四叉堆顶上的计时器；</li>
<li>调用 runtime.doaddtimer 将计时器加入四叉堆中；</li>
<li>将计时器的状态修改成 timerWaiting；</li>
</ul>
</li>
</ul>
<p>runtime.cleantimers 会删除已经标记的计时器，修改状态为 timerModifiedXX 的计时器。</p>
<h3 id="adjusttimers">adjusttimers</h3>
<p><code>runtime.adjusttimers</code> 与 <code>runtime.cleantimers</code> 的作用相似，它们都会删除堆中的计时器并修改状态为 <code>timerModifiedEarlier</code> 和 <code>timerModifiedLater</code> 的计时器的时间，它们也会遵循相同的规则处理计时器状态：</p>
<ul>
<li>timerDeleted -&gt; timerRemoving -&gt; timerRemoved</li>
<li>timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// adjusttimers looks through the timers in the current P&#39;s heap for
</span><span class="c1">// any timers that have been modified to run earlier, and puts them in
</span><span class="c1">// the correct place in the heap. While looking for those timers,
</span><span class="c1">// it also moves timers that have been modified to run later,
</span><span class="c1">// and removes deleted timers. The caller must have locked the timers for pp.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">adjusttimers</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">verifyTimers</span> <span class="p">{</span>
			<span class="nf">verifyTimerHeap</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// There are no timers to adjust, so it is safe to clear
</span><span class="c1"></span>		<span class="c1">// timerModifiedEarliest. Do so in case it is stale.
</span><span class="c1"></span>		<span class="c1">// Everything will work if we don&#39;t do this,
</span><span class="c1"></span>		<span class="c1">// but clearing here may save future calls to adjusttimers.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerModifiedEarliest</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// If we haven&#39;t yet reached the time of the first timerModifiedEarlier
</span><span class="c1"></span>	<span class="c1">// timer, don&#39;t do anything. This speeds up programs that adjust
</span><span class="c1"></span>	<span class="c1">// a lot of timers back and forth if the timers rarely expire.
</span><span class="c1"></span>	<span class="c1">// We&#39;ll postpone looking through all the adjusted timers until
</span><span class="c1"></span>	<span class="c1">// one would actually expire.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">first</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerModifiedEarliest</span><span class="p">);</span> <span class="nx">first</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">verifyTimers</span> <span class="p">{</span>
				<span class="nf">verifyTimerHeap</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// We are going to clear all timerModifiedEarlier timers.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerModifiedEarliest</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">moved</span> <span class="p">[]</span><span class="o">*</span><span class="nx">timer</span>
<span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">pp</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;adjusttimers: bad p&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">timerDeleted</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">dodeltimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">)</span> <span class="p">{</span>
					<span class="nf">badTimer</span><span class="p">()</span>
				<span class="p">}</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="c1">// Look at this heap position again.
</span><span class="c1"></span>				<span class="nx">i</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">timerModifiedEarlier</span><span class="p">,</span> <span class="nx">timerModifiedLater</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// Now we can change the when field.
</span><span class="c1"></span>				<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nextwhen</span>
				<span class="c1">// Take t off the heap, and hold onto it.
</span><span class="c1"></span>				<span class="c1">// We don&#39;t add it back yet because the
</span><span class="c1"></span>				<span class="c1">// heap manipulation could cause our
</span><span class="c1"></span>				<span class="c1">// loop to skip some other timer.
</span><span class="c1"></span>				<span class="nf">dodeltimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
				<span class="nx">moved</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">moved</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="k">break</span> <span class="nx">loop</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="c1">// Look at this heap position again.
</span><span class="c1"></span>				<span class="nx">i</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">timerNoStatus</span><span class="p">,</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">:</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">timerWaiting</span><span class="p">:</span>
			<span class="c1">// OK, nothing to do.
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">timerModifying</span><span class="p">:</span>
			<span class="c1">// Check again after modification is complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
			<span class="nx">i</span><span class="o">--</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">moved</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">addAdjustedTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">moved</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">verifyTimers</span> <span class="p">{</span>
		<span class="nf">verifyTimerHeap</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>与 runtime.cleantimers 不同的是，上述函数可能会遍历处理器堆中的全部计时器（包含退出条件），而不是只修改四叉堆顶部。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// dodeltimer removes timer i from the current P&#39;s heap.
</span><span class="c1">// We are locked on the P when this is called.
</span><span class="c1">// It reports whether it saw no problems due to races.
</span><span class="c1">// The caller must have locked the timers for pp.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">dodeltimer</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">pp</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;dodeltimer: wrong P&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">pp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1">// 把 timer[i] 替换为 timer[last]
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="nx">last</span> <span class="p">{</span>
		<span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
	<span class="p">}</span>
    <span class="c1">// 删除 timer[last]，并缩小 slice
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
    <span class="c1">// 判断是不是删的最后一个
</span><span class="c1"></span>    <span class="c1">// 如果不是的话，需要重新调整堆
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="nx">last</span> <span class="p">{</span>
		<span class="c1">// Moving to i may have moved the last timer to a new parent,
</span><span class="c1"></span>		<span class="c1">// so sift up to preserve the heap guarantee.
</span><span class="c1"></span>        <span class="c1">// 最后一个节点当前来的分叉可能并不是它那个分叉
</span><span class="c1"></span>        <span class="c1">// 所以向上走或者向下走都是有可能的
</span><span class="c1"></span>        <span class="c1">// 即使是二叉堆，也是有这种可能的
</span><span class="c1"></span>		<span class="nf">siftupTimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">updateTimer0When</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">numTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="runtimer">runtimer</h3>
<p>runtime.runtimer 函数会检查处理器四叉堆上最顶上的计时器，该函数也会处理计时器的删除以及计时器时间的更新，它会遵循以下的规则处理计时器：</p>
<ul>
<li>timerNoStatus -&gt; 崩溃：未初始化的计时器</li>
<li>timerWaiting
<ul>
<li>-&gt; timerWaiting</li>
<li>-&gt; timerRunning -&gt; timerNoStatus</li>
<li>-&gt; timerRunning -&gt; timerWaiting</li>
</ul>
</li>
<li>timerModifying -&gt; 等待状态改变</li>
<li>timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</li>
<li>timerDeleted -&gt; timerRemoving -&gt; timerRemoved</li>
<li>timerRunning -&gt; 崩溃：并发调用该函数</li>
<li>timerRemoved、timerRemoving、timerMoving -&gt; 崩溃：计时器堆不一致</li>
</ul>
<p>timer 的运行是交给 runtime.runtimer函数执行的，这个函数会检查 P 上最小堆的最顶上的 timer 的状态，根据状态做不同的处理。</p>
<p>runtimer 里面会启动一个 for 循环，不停的检查 P 的 timer 列表的第一个元素的状态。</p>
<ul>
<li>如果该 timer 处于 timerWaiting，那么判断当前的时间大于 timer 执行的时间，则调用 runOneTimer 执行；</li>
<li>如果该 timer 处于 timerDeleted，表示该 timer 是需要被删除的，那么调用 dodeltimer0 删除最小堆的第一个 timer ，并修改其状态；</li>
<li>如果该 timer 状态是 timerModifiedEarlier 、timerModifiedLater，那么表示该 timer 的执行时间被修改过，需要重新调整它在最小堆中的位置，所以先调用 dodeltimer0 删除该 timer，再调用 doaddtimer 将该 timer 重新添加到最小堆。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtimer examines the first timer in timers. If it is ready based on now,
</span><span class="c1">// it runs the timer and removes or updates it.
</span><span class="c1">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time
</span><span class="c1">// when the first timer should run.
</span><span class="c1">// The caller must have locked the timers for pp.
</span><span class="c1">// If a timer is run, this will temporarily unlock the timers.
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtimer</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 获取最小堆的第一个元素
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">pp</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtimer: bad p&#34;</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">// 获取 timer 状态
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">timerWaiting</span><span class="p">:</span>
            <span class="c1">// 还没到时间，返回下次执行时间
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="c1">// Not ready to run.
</span><span class="c1"></span>				<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span>
			<span class="p">}</span>
            <span class="c1">// 修改状态为 timerRunning
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerRunning</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// Note that runOneTimer may temporarily unlock
</span><span class="c1"></span>			<span class="c1">// pp.timersLock.
</span><span class="c1"></span>            <span class="c1">// 运行该 timer
</span><span class="c1"></span>			<span class="nf">runOneTimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span>

		<span class="k">case</span> <span class="nx">timerDeleted</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="c1">// 删除最小堆的第一个 timer
</span><span class="c1"></span>			<span class="nf">dodeltimer0</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">badTimer</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
        <span class="c1">// 需要重新移动位置的 timer
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">timerModifiedEarlier</span><span class="p">,</span> <span class="nx">timerModifiedLater</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">nextwhen</span>
            <span class="c1">// 删除最小堆的第一个 timer
</span><span class="c1"></span>			<span class="nf">dodeltimer0</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
            <span class="c1">// 将该 timer 重新添加到最小堆
</span><span class="c1"></span>			<span class="nf">doaddtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">,</span> <span class="nx">timerWaiting</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">badTimer</span><span class="p">()</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="nx">timerModifying</span><span class="p">:</span>
			<span class="c1">// Wait for modification to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>

		<span class="k">case</span> <span class="nx">timerNoStatus</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">:</span>
			<span class="c1">// Should not see a new or inactive timer on the heap.
</span><span class="c1"></span>			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">:</span>
			<span class="c1">// These should only be set when timers are locked,
</span><span class="c1"></span>			<span class="c1">// and we didn&#39;t do it.
</span><span class="c1"></span>			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="runonetimer">runOneTimer</h4>
<p>runOneTimer 会根据 period 是否大于0判断该 timer 是否需要反复执行，如果是的话需要重新调整 when 下次执行时间后重新调整该 timer 在堆中的位置。一次性 timer 的话会执行 dodeltimer0 删除该 timer ，最后运行 timer 中的函数；</p>
<p>如果处理器四叉堆顶部的计时器没有到触发时间会直接返回，否则调用 runtime.runOneTimer 运行堆顶的计时器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runOneTimer runs a single timer.
</span><span class="c1">// The caller must have locked the timers for pp.
</span><span class="c1">// This will temporarily unlock the timers while running the timer function.
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runOneTimer</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">ppcur</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ppcur</span><span class="p">.</span><span class="nx">timerRaceCtx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ppcur</span><span class="p">.</span><span class="nx">timerRaceCtx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">runtimer</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">raceacquirectx</span><span class="p">(</span><span class="nx">ppcur</span><span class="p">.</span><span class="nx">timerRaceCtx</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
	<span class="p">}</span>
    <span class="c1">// 需要被执行的函数
</span><span class="c1"></span>	<span class="nx">f</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">f</span>
    <span class="c1">// 被执行函数的参数
</span><span class="c1"></span>	<span class="nx">arg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">arg</span>
	<span class="nx">seq</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">seq</span>
    <span class="c1">// 表示该 timer 为 ticker，需要再次触发
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Leave in heap but adjust next time to fire.
</span><span class="c1"></span>        <span class="c1">// 放入堆中并调整触发时间
</span><span class="c1"></span>		<span class="nx">delta</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="o">-</span> <span class="nx">now</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="o">+=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="nx">delta</span><span class="o">/</span><span class="nx">t</span><span class="p">.</span><span class="nx">period</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// check for overflow.
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">maxWhen</span>
		<span class="p">}</span>
		<span class="nf">siftdownTimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerWaiting</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">updateTimer0When</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Remove from heap.
</span><span class="c1"></span>		<span class="nf">dodeltimer0</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerNoStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="c1">// Temporarily use the current P&#39;s racectx for g0.
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">racectx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runOneTimer: unexpected racectx&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">timerRaceCtx</span>
	<span class="p">}</span>

	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>

	<span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">seq</span><span class="p">)</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>根据计时器的 period 字段，上述函数会做出不同的处理：</p>
<ul>
<li>如果 period 字段大于 0；
<ul>
<li>修改计时器下一次触发的时间并更新其在堆中的位置；</li>
<li>将计时器的状态更新至 timerWaiting；</li>
<li>调用 runtime.updateTimer0When 函数设置处理器的 timer0When 字段；</li>
</ul>
</li>
<li>如果 period 字段小于或者等于 0；
<ul>
<li>调用 runtime.dodeltimer0 函数删除计时器；</li>
<li>将计时器的状态更新至 timerNoStatus；</li>
</ul>
</li>
</ul>
<p>更新计时器之后，上述函数会运行计时器中存储的函数并传入触发时间等参数。</p>
<h2 id="触发时机">触发时机</h2>
<p>我们在上一小节已经分析了计时器状态机中的 10 种状态以及几种操作。这里将分析器的触发过程，Go 语言会在两个模块触发计时器，运行计时器中保存的函数：</p>
<ul>
<li>调度器调度时会检查处理器中的计时器是否准备就绪；</li>
<li>系统监控会检查是否有未执行的到期计时器；</li>
</ul>
<p>我们将依次分析上述这两个触发过程。</p>
<h3 id="调度器">调度器</h3>
<p>runtime.checkTimers 是调度器用来运行处理器中计时器的函数，它会在发生以下情况时被调用：</p>
<ul>
<li>调度器调用 runtime.schedule 执行调度时；</li>
<li>调度器调用 runtime.findrunnable 获取可执行的 Goroutine 时；</li>
<li>调度器调用 runtime.findrunnable 从其他处理器窃取计时器时；</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810212721.png" alt=""></p>
<p>runtime.schedule</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="o">...</span>
<span class="nx">top</span><span class="p">:</span>
    <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="c1">// 检查是否有可执行 timer 并执行
</span><span class="c1"></span>    <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="o">...</span>
    <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.findrunnable</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Finds a runnable goroutine to execute.
</span><span class="c1">// Tries to steal from other P&#39;s, get g from local or global queue, poll network.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// The conditions here and in handoffp must agree: if
</span><span class="c1"></span>	<span class="c1">// findrunnable would return a G to run, handoffp must start
</span><span class="c1"></span>	<span class="c1">// an M.
</span><span class="c1"></span>
<span class="nx">top</span><span class="p">:</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>checkTimers 中主要做了这么几件事：</p>
<ol>
<li>检查是否有timer， 如果没有需要执行的计时器时，直接返回；如果下一个要执行的 timer 没有到期并且需要删除的计时器较少（四分之一）时也会直接返回；</li>
<li>调用 adjusttimers 进行 timer 列表的调整，主要是维护 timer 列表的最小堆的顺序；</li>
<li>调用 runtime.runtimer查找堆中是否存在需要执行的timer， runtime.runtimer上面已经讲过了，这里不再赘述；</li>
<li>如果当前 Goroutine 的 P 和传入的 P 相同，并且需要删除的 timer 超过了 timer 列表数量的四分之一，那么调用 clearDeletedTimers 清理需要删除的 timer；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// checkTimers runs any timers for the P that are ready.
</span><span class="c1">// If now is not 0 it is the current time.
</span><span class="c1">// It returns the current time or 0 if it is not known,
</span><span class="c1">// and the time when the next timer should run or 0 if there is no next timer,
</span><span class="c1">// and reports whether it ran any timers.
</span><span class="c1">// If the time when the next timer should run is not 0,
</span><span class="c1">// it is always larger than the returned time.
</span><span class="c1">// We pass now in and out to avoid extra calls of nanotime.
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">pp</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">rnow</span><span class="p">,</span> <span class="nx">pollUntil</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">ran</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// If it&#39;s not yet time for the first timer, or the first adjusted
</span><span class="c1"></span>	<span class="c1">// timer, then there is nothing to do.
</span><span class="c1"></span>    <span class="c1">// 获取 timer0 的执行时间
</span><span class="c1"></span>	<span class="nx">next</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timer0When</span><span class="p">))</span>
	<span class="nx">nextAdj</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerModifiedEarliest</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="nx">nextAdj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nextAdj</span> <span class="p">&lt;</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="nx">nextAdj</span>
	<span class="p">}</span>
    <span class="c1">// 如果没有timer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// No timers to run or adjust.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">now</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="p">}</span>
    <span class="c1">// 下次执行大于当前时间，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">next</span> <span class="p">{</span>
		<span class="c1">// Next timer is not ready to run, but keep going
</span><span class="c1"></span>		<span class="c1">// if we would clear deleted timers.
</span><span class="c1"></span>		<span class="c1">// This corresponds to the condition below where
</span><span class="c1"></span>		<span class="c1">// we decide whether to call clearDeletedTimers.
</span><span class="c1"></span>        <span class="c1">// 如果需要删除的 timer 个数小于 timer列表个数的4分之1，直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">pp</span> <span class="o">!=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">||</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">numTimers</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 如果有计时器，则调用函数 adjusttimers() 进行调用（堆维护)
</span><span class="c1"></span>		<span class="nf">adjusttimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
        <span class="c1">// 调整了堆中的计时器之后，会通过 runtime.runtimer 依次查找堆中是否存在需要执行的计时器：
</span><span class="c1"></span>        <span class="c1">// * 如果存在，直接运行计时器；
</span><span class="c1"></span>        <span class="c1">// * 如果不存在，获取最新计时器的触发时间；
</span><span class="c1"></span>		<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Note that runtimer may temporarily unlock
</span><span class="c1"></span>			<span class="c1">// pp.timersLock.
</span><span class="c1"></span>            <span class="c1">// 查找堆中是否存在需要执行的 timer
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">tw</span> <span class="o">:=</span> <span class="nf">runtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">now</span><span class="p">);</span> <span class="nx">tw</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">tw</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">tw</span>
				<span class="p">}</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">ran</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// If this is the local P, and there are a lot of deleted timers,
</span><span class="c1"></span>	<span class="c1">// clear them out. We only do this for the local P to reduce
</span><span class="c1"></span>	<span class="c1">// lock contention on timersLock.
</span><span class="c1"></span>    <span class="c1">// 如果需要删除的 timer 超过了 timer 列表数量的四分之一，那么清理需要删除的 timer
</span><span class="c1"></span>    <span class="c1">// 在 runtime.checkTimers 的最后，如果当前 Goroutine 的处理器和传入的处理器相同，并且处理器中删除的计时器是堆中计时器的 1/4 以上，就会调用 runtime.clearDeletedTimers 删除处理器全部被标记为 timerDeleted 的计时器，保证堆中靠后的计时器被删除。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deletedTimers</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
        <span class="c1">// runtime.clearDeletedTimers 能够避免堆中出现大量长时间运行的计时器，该函数和 runtime.moveTimers 也是唯二会遍历计时器堆的函数。
</span><span class="c1"></span>		<span class="nf">clearDeletedTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">ran</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="系统监控">系统监控</h3>
<p>系统监控其实就是 Go 语言的守护进程，它们能够在后台监控系统的运行状态，在出现意外情况时及时响应。它会每隔一段时间检查 Go 语言运行时状态，确保没有异常发生。我们这里不主要去讲系统监控，只抽离出其中的和 timer 相关的代码进行讲解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="o">...</span>
		<span class="c1">// sysmon should not enter deep sleep if schedtrace is enabled so that
</span><span class="c1"></span>		<span class="c1">// it can print that information at the right time.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// It should also not enter deep sleep if there are any active P&#39;s so
</span><span class="c1"></span>		<span class="c1">// that it can retake P&#39;s from syscalls, preempt long running G&#39;s, and
</span><span class="c1"></span>		<span class="c1">// poll the network if all P&#39;s are busy for long stretches.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// It should wakeup from deep sleep if any P&#39;s become active either due
</span><span class="c1"></span>		<span class="c1">// to exiting a syscall or waking up due to a timer expiring so that it
</span><span class="c1"></span>		<span class="c1">// can resume performing those duties. If it wakes from a syscall it
</span><span class="c1"></span>		<span class="c1">// resets idle and delay as a bet that since it had retaken a P from a
</span><span class="c1"></span>		<span class="c1">// syscall before, it may need to do it again shortly after the
</span><span class="c1"></span>		<span class="c1">// application starts work again. It does not reset idle when waking
</span><span class="c1"></span>		<span class="c1">// from a timer to avoid adding system load to applications that spend
</span><span class="c1"></span>		<span class="c1">// most of their time sleeping.
</span><span class="c1"></span>		<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">syscallWake</span> <span class="o">:=</span> <span class="kc">false</span>
                <span class="c1">// 获取下一次计时器启动的时间和持有该堆的P
</span><span class="c1"></span>				<span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">next</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="c1">// Make wake-up period small enough
</span><span class="c1"></span>					<span class="c1">// for the sampling to be correct.
</span><span class="c1"></span>                    <span class="c1">// 计算离下次启动计时器的时间
</span><span class="c1"></span>					<span class="nx">sleep</span> <span class="o">:=</span> <span class="nx">forcegcperiod</span> <span class="o">/</span> <span class="mi">2</span>
					<span class="k">if</span> <span class="nx">next</span><span class="o">-</span><span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">sleep</span> <span class="p">{</span>
						<span class="nx">sleep</span> <span class="p">=</span> <span class="nx">next</span> <span class="o">-</span> <span class="nx">now</span>
					<span class="p">}</span>
                     <span class="c1">// 休眠一段时间，唤醒后将直接执行堆中的timers
</span><span class="c1"></span>					<span class="nx">shouldRelax</span> <span class="o">:=</span> <span class="nx">sleep</span> <span class="o">&gt;=</span> <span class="nx">osRelaxMinNS</span>
					<span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
						<span class="nf">osRelax</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="nx">syscallWake</span> <span class="p">=</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">,</span> <span class="nx">sleep</span><span class="p">)</span>
					<span class="nf">mDoFixup</span><span class="p">()</span>
					<span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
						<span class="nf">osRelax</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
					<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">syscallWake</span> <span class="p">{</span>
					<span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
					<span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
		<span class="c1">// Update now in case we blocked on sysmonnote or spent a long time
</span><span class="c1"></span>		<span class="c1">// blocked on schedlock or sysmonlock above.
</span><span class="c1"></span>		<span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>

		<span class="c1">// trigger libc interceptors if needed
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">// 如果超过 10ms 没有 poll，则 poll 一下网络
</span><span class="c1"></span>        <span class="nx">lastpoll</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">))</span>
        <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lastpoll</span><span class="p">),</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
            <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 非阻塞，返回 G 列表
</span><span class="c1"></span>            <span class="c1">// G 列表不为空
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">// 将获取到的 G 列表插入到空闲的 P 中或全局列表中
</span><span class="c1"></span>                <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
                <span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 如果有 timer 到期
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">next</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
            <span class="c1">// 启动新的 M 处理 timer
</span><span class="c1"></span>            <span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>sysmon 会调用 timeSleepUntil() 函数，遍历所有的P，找出下次最先执行(时间值最小)的时间和其所在的P.</li>
<li>调用 notesleep() 函数休眠一段时间。待唤醒后将自动执行堆上的timers。另外还有一个 notesleepg() 函数，区域是 notesleep() 调用者是否为g0</li>
<li>如果超过 10ms 没有 poll，则 poll 一下网络；</li>
<li>如果有 timer 到期，这个时候直接启动新的 M 处理 timer；</li>
</ol>
<p>在上述过程中 runtime.timeSleepUntil 会遍历运行时的全部处理器并查找下一个需要执行的计时器。</p>
<p>说明一下，在sysmon 监控线程里没有找到过期 timer 情况下的处理逻辑，只有未过期的处理逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// timeSleepUntil returns the time when the next timer should fire,
</span><span class="c1">// and the P that holds the timer heap that that timer is on.
</span><span class="c1">// This is only called by sysmon and checkdead.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">timeSleepUntil</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">maxWhen</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">pret</span> <span class="o">*</span><span class="nx">p</span>

	<span class="c1">// Prevent allp slice changes. This is like retake.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// This can happen if procresize has grown
</span><span class="c1"></span>			<span class="c1">// allp but not yet created new Ps.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">w</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timer0When</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">next</span> <span class="p">{</span>
			<span class="nx">next</span> <span class="p">=</span> <span class="nx">w</span>
			<span class="nx">pret</span> <span class="p">=</span> <span class="nx">pp</span>
		<span class="p">}</span>

		<span class="nx">w</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timerModifiedEarliest</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">next</span> <span class="p">{</span>
			<span class="nx">next</span> <span class="p">=</span> <span class="nx">w</span>
			<span class="nx">pret</span> <span class="p">=</span> <span class="nx">pp</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">pret</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="核心api">核心API</h2>
<h3 id="newtimer">NewTimer</h3>
<p>我们先看看NewTimer方法是如何创建一个Timer的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewTimer creates a new Timer that will send
</span><span class="c1">// the current time on its channel after at least duration d.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 创建一个带有一个Time结构缓冲的通道
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
		<span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
		<span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span><span class="c1">// 运行时定时器
</span><span class="c1"></span>			<span class="nx">when</span><span class="p">:</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span><span class="c1">// 定时多久
</span><span class="c1"></span>			<span class="nx">f</span><span class="p">:</span>    <span class="nx">sendTime</span><span class="p">,</span><span class="c1">// Golang写入时间的回调接口
</span><span class="c1"></span>			<span class="nx">arg</span><span class="p">:</span>  <span class="nx">c</span><span class="p">,</span><span class="c1">// 往哪个通道写入时间
</span><span class="c1"></span>		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span><span class="c1">// 启动提交定时器
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="c1">// when is a helper function for setting the &#39;when&#39; field of a runtimeTimer.
</span><span class="c1">// It returns what the time will be, in nanoseconds, Duration d in the future.
</span><span class="c1">// If d is negative, it is ignored. If the returned value would be less than
</span><span class="c1">// zero because of an overflow, MaxInt64 is returned.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">runtimeNano</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">runtimeNano</span><span class="p">()</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// math.MaxInt64
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>when 表示时间到时，会往 Timer.C 中发送当前时间。when 表示的时间是纳秒时间，正常通过 runtimeNano() + int64(d) 赋值。</li>
<li>f 参数的值是 sendTime，定时器时间到时，会调用 f，并将 arg 和 seq 传给 f。</li>
<li>因为 Timer 是一次性的，所以 period 保留默认值 0。</li>
<li>runtimeTimer 结构中的 i 字段，表示在堆中的索引.</li>
</ul>
<p>在time包中，函数f有三种类型：</p>
<ul>
<li>sendTime：发送当前时间到channel或者在发送被阻塞的情况下丢弃。被time.Timer和time.Ticker使用。</li>
<li>goFunc：在goroutine中执行一些函数。被time.AfterFunc使用。</li>
<li>goroutineReady：唤醒特定的goroutine。被runtime.timeSleep使用。</li>
</ul>
<p>NewTimer方法主要是初始化一个Timer，然后调用startTimer方法，并返回Timer。startTimer方法的真正逻辑并不在time包里面，我们可以使用dlv调试汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">sleep.go</span><span class="o">:</span><span class="m">94</span>     <span class="mh">0xd8ea09</span>        <span class="n">e872c7faff</span>              <span class="n">call</span> <span class="o">$</span><span class="n">time.startTimer</span>
</code></pre></td></tr></table>
</div>
</div><p>得知startTimer实际上调用的是<code>runtime.time.startTimer</code>方法。也就是说<code>time.Timer</code>只是对runtime包中timer的一层wrap。这层自身实现的最核心功能是将底层的超时回调转换为发送channel消息。</p>
<p>startTimer方法会将传入的runtimeTimer转为timer，然后调用addtimer方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// startTimer adds t to the timer heap.
</span><span class="c1">//go:linkname startTimer time.startTimer
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">startTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racerelease</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nf">addtimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Timer在超时(timer expire)后，执行一个标准库中内置的函数：sendTime。sendTime将当前当前事件send到timer的时间Channel中.</p>
<p>我们看到NewTimer中创建了一个buffered channel，size = 1。正常情况下，当timer expire，t.C无论是否有goroutine在read，sendTime都可以non-block的将当前时间发送到C中；同时，我们看到sendTime还加了双保险：通过一个select判断c buffer是否已满，一旦满了，直接退出，依然不会block，这种情况在reuse active timer时可能会遇到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 时间到后，Golang自动调用sendTime接口，尝试往c通道写入时间
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendTime</span><span class="p">(</span><span class="nx">c</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Non-blocking send of time on c.
</span><span class="c1"></span>	<span class="c1">// Used in NewTimer, it cannot block anyway (buffer).
</span><span class="c1"></span>	<span class="c1">// Used in NewTicker, dropping sends on the floor is
</span><span class="c1"></span>	<span class="c1">// the desired behavior when the reader gets behind,
</span><span class="c1"></span>    <span class="c1">// because the sends are periodic.
</span><span class="c1"></span>    <span class="c1">// 给c通道以非阻塞方式发送时间
</span><span class="c1"></span>    <span class="c1">// 如果被用于NewTimer, 无论如何不能阻塞.
</span><span class="c1"></span>    <span class="c1">// 如果被用于NewTicker，接收方未及时接受时间，则会丢弃掉，因为发送时间是周期性的。
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="nf">Now</span><span class="p">():</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="timerafter">timer.After</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// After waits for the duration to elapse and then sends the current time
</span><span class="c1">// on the returned channel.
</span><span class="c1">// It is equivalent to NewTimer(d).C.
</span><span class="c1">// The underlying Timer is not recovered by the garbage collector
</span><span class="c1">// until the timer fires. If efficiency is a concern, use NewTimer
</span><span class="c1">// instead and call Timer.Stop if the timer is no longer needed.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">After</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span><span class="p">).</span><span class="nx">C</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="timerafterfunc">Timer.AfterFunc</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AfterFunc waits for the duration to elapse and then calls f
</span><span class="c1">// in its own goroutine. It returns a Timer that can
</span><span class="c1">// be used to cancel the call using its Stop method.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
		<span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span>
			<span class="nx">when</span><span class="p">:</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
			<span class="nx">f</span><span class="p">:</span>    <span class="nx">goFunc</span><span class="p">,</span>
			<span class="nx">arg</span><span class="p">:</span>  <span class="nx">f</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">goFunc</span><span class="p">(</span><span class="nx">arg</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nx">arg</span><span class="p">.(</span><span class="kd">func</span><span class="p">())()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：从AfterFunc源码可以看到，外面传入的f参数并非直接赋值给了内部的f，而是作为wrapper function：goFunc的arg传入的。而goFunc则是启动了一个新的goroutine来执行那个外部传入的f。这是因为timer expire对应的事件处理函数的执行是在go runtime内唯一的timer events maintenance goroutine: timerproc中。为了不block timerproc的执行，必须启动一个新的goroutine。</p>
<h3 id="timertick">timer.Tick</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Tick</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">NewTicker</span><span class="p">(</span><span class="nx">d</span><span class="p">).</span><span class="nx">C</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewTicker 会返回一个 Ticker 对象，其 channel 每隔 period 时间
</span><span class="c1">// 会收到一个时间值
</span><span class="c1">// 如果 receiver 接收慢了，Ticker 会把不需要的 tick drop 掉
</span><span class="c1">// d 必须比 0 大，否则 panic
</span><span class="c1">// Stop ticker 才能释放相关的资源
</span><span class="c1">// NewTicker returns a new Ticker containing a channel that will send
</span><span class="c1">// the time on the channel after each tick. The period of the ticks is
</span><span class="c1">// specified by the duration argument. The ticker will adjust the time
</span><span class="c1">// interval or drop ticks to make up for slow receivers.
</span><span class="c1">// The duration d must be greater than zero; if not, NewTicker will
</span><span class="c1">// panic. Stop the ticker to release associated resources.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTicker</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">*</span><span class="nx">Ticker</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;non-positive interval for NewTicker&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// Give the channel a 1-element time buffer.
</span><span class="c1"></span>	<span class="c1">// If the client falls behind while reading, we drop ticks
</span><span class="c1"></span>	<span class="c1">// on the floor until the client catches up.
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Ticker</span><span class="p">{</span>
		<span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
		<span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span>
			<span class="nx">when</span><span class="p">:</span>   <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
			<span class="nx">period</span><span class="p">:</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>
			<span class="nx">f</span><span class="p">:</span>      <span class="nx">sendTime</span><span class="p">,</span>
			<span class="nx">arg</span><span class="p">:</span>    <span class="nx">c</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到， Ticker 和 Timer 的 r 成员就只差在 period 这一个字段上，每隔一个 period 就往 channel 里发数据的就是 Ticker，而 fire and disappear 的就是 Timer。</p>
<h3 id="timerreset">Timer.Reset</h3>
<p>对于 timer.Reset() 函数，对应的是resetTimer</p>
<p>这与修改操作对应的是同一个 modtimer() 函数。</p>
<p>对于这个函数的一般会被网络轮询、timer.Ticker.Reset 或 timer.Timer.Reset 函数调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Reset changes the timer to expire after duration d.
</span><span class="c1">// It returns true if the timer had been active, false if the timer had
</span><span class="c1">// expired or been stopped.
</span><span class="c1">//
</span><span class="c1">// For a Timer created with NewTimer, Reset should be invoked only on
</span><span class="c1">// stopped or expired timers with drained channels.
</span><span class="c1">//
</span><span class="c1">// If a program has already received a value from t.C, the timer is known
</span><span class="c1">// to have expired and the channel drained, so t.Reset can be used directly.
</span><span class="c1">// If a program has not yet received a value from t.C, however,
</span><span class="c1">// the timer must be stopped and—if Stop reports that the timer expired
</span><span class="c1">// before being stopped—the channel explicitly drained:
</span><span class="c1">//
</span><span class="c1">// 	if !t.Stop() {
</span><span class="c1">// 		&lt;-t.C
</span><span class="c1">// 	}
</span><span class="c1">// 	t.Reset(d)
</span><span class="c1">//
</span><span class="c1">// This should not be done concurrent to other receives from the Timer&#39;s
</span><span class="c1">// channel.
</span><span class="c1">//
</span><span class="c1">// Note that it is not possible to use Reset&#39;s return value correctly, as there
</span><span class="c1">// is a race condition between draining the channel and the new timer expiring.
</span><span class="c1">// Reset should always be invoked on stopped or expired channels, as described above.
</span><span class="c1">// The return value exists to preserve compatibility with existing programs.
</span><span class="c1">//
</span><span class="c1">// For a Timer created with AfterFunc(d, f), Reset either reschedules
</span><span class="c1">// when f will run, in which case Reset returns true, or schedules f
</span><span class="c1">// to run again, in which case it returns false.
</span><span class="c1">// When Reset returns false, Reset neither waits for the prior f to
</span><span class="c1">// complete before returning nor does it guarantee that the subsequent
</span><span class="c1">// goroutine running f does not run concurrently with the prior
</span><span class="c1">// one. If the caller needs to know whether the prior execution of
</span><span class="c1">// f is completed, it must coordinate with f explicitly.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;time: Reset called on uninitialized Timer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">w</span> <span class="o">:=</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">resetTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// resetTimer resets an inactive timer, adding it to the heap.
</span><span class="c1">//go:linkname resetTimer time.resetTimer
</span><span class="c1">// Reports whether the timer was modified before it was run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">resetTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">when</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racerelease</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">resettimer</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">when</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// resettimer resets the time when a timer should fire.
</span><span class="c1">// If used for an inactive timer, the timer will become active.
</span><span class="c1">// This should be called instead of addtimer if the timer value has been,
</span><span class="c1">// or may have been, used previously.
</span><span class="c1">// Reports whether the timer was modified before it was run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">resettimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">when</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">modtimer</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">when</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">period</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">f</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">seq</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// modtimer modifies an existing timer.
</span><span class="c1">// This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset.
</span><span class="c1">// Reports whether the timer was modified before it was run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">modtimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">,</span> <span class="nx">when</span><span class="p">,</span> <span class="nx">period</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">uintptr</span><span class="p">),</span> <span class="nx">arg</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">when</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;timer when must be positive&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">period</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;timer period must be non-negative&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">status</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">timerNoStatus</span><span class="p">)</span>
	<span class="nx">wasRemoved</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">var</span> <span class="nx">pending</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span>
<span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 先是用一个for自旋修改定时器状态
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">status</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span> <span class="nx">status</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">timerWaiting</span><span class="p">,</span> <span class="nx">timerModifiedEarlier</span><span class="p">,</span> <span class="nx">timerModifiedLater</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">pending</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// timer not yet run
</span><span class="c1"></span>				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">timerNoStatus</span><span class="p">,</span> <span class="nx">timerRemoved</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>

			<span class="c1">// Timer was already run and t is no longer in a heap.
</span><span class="c1"></span>			<span class="c1">// Act like addtimer.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">wasRemoved</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">pending</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// timer already run or stopped
</span><span class="c1"></span>				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">timerDeleted</span><span class="p">:</span>
			<span class="c1">// Prevent preemption while the timer is in timerModifying.
</span><span class="c1"></span>			<span class="c1">// This could lead to a self-deadlock. See #38070.
</span><span class="c1"></span>			<span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">deletedTimers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="nx">pending</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// timer already stopped
</span><span class="c1"></span>				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">timerRunning</span><span class="p">,</span> <span class="nx">timerRemoving</span><span class="p">,</span> <span class="nx">timerMoving</span><span class="p">:</span>
			<span class="c1">// The timer is being run or moved, by a different P.
</span><span class="c1"></span>			<span class="c1">// Wait for it to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">timerModifying</span><span class="p">:</span>
			<span class="c1">// Multiple simultaneous calls to modtimer.
</span><span class="c1"></span>			<span class="c1">// Wait for the other call to complete.
</span><span class="c1"></span>			<span class="nf">osyield</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">t</span><span class="p">.</span><span class="nx">period</span> <span class="p">=</span> <span class="nx">period</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">f</span> <span class="p">=</span> <span class="nx">f</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">arg</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">seq</span> <span class="p">=</span> <span class="nx">seq</span>
    <span class="c1">// 如果已从P中移除，重新加入到P中 timerModifiying =&gt; timerWaiting
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wasRemoved</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">=</span> <span class="nx">when</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="nf">doaddtimer</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">timersLock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">,</span> <span class="nx">timerWaiting</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// The timer is in some other P&#39;s heap, so we can&#39;t change
</span><span class="c1"></span>		<span class="c1">// the when field. If we did, the other P&#39;s heap would
</span><span class="c1"></span>		<span class="c1">// be out of order. So we put the new when value in the
</span><span class="c1"></span>		<span class="c1">// nextwhen field, and let the other P set the when field
</span><span class="c1"></span>		<span class="c1">// when it is prepared to resort the heap.
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">nextwhen</span> <span class="p">=</span> <span class="nx">when</span>
        <span class="c1">// 如果修改后的时间&lt;修改之前的时间，则修改状态为 timerModifiedEarlier
</span><span class="c1"></span>		<span class="nx">newStatus</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">timerModifiedLater</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">when</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">when</span> <span class="p">{</span>
			<span class="nx">newStatus</span> <span class="p">=</span> <span class="nx">timerModifiedEarlier</span>
		<span class="p">}</span>

		<span class="nx">tpp</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>

		<span class="c1">// Update the adjustTimers field.  Subtract one if we
</span><span class="c1"></span>		<span class="c1">// are removing a timerModifiedEarlier, add one if we
</span><span class="c1"></span>		<span class="c1">// are adding a timerModifiedEarlier.
</span><span class="c1"></span>		<span class="nx">adjust</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
			<span class="nx">adjust</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">newStatus</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
			<span class="nx">adjust</span><span class="o">++</span>
			<span class="nf">updateTimerModifiedEarliest</span><span class="p">(</span><span class="nx">tpp</span><span class="p">,</span> <span class="nx">when</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">adjust</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tpp</span><span class="p">.</span><span class="nx">adjustTimers</span><span class="p">,</span> <span class="nx">adjust</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Set the new status of the timer.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">timerModifying</span><span class="p">,</span> <span class="nx">newStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">badTimer</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

		<span class="c1">// If the new status is earlier, wake up the poller.
</span><span class="c1"></span>        <span class="c1">// 如果新状态提前 timerModifiedEarlier，则调用 wakeNetPooler 唤醒网络轮询器中休眠的线程,检查计时器被唤醒的时间（when）是否在当前轮询预期运行的时间（pollerPollUntil）内，若是则唤醒。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">newStatus</span> <span class="o">==</span> <span class="nx">timerModifiedEarlier</span> <span class="p">{</span>
			<span class="nf">wakeNetPoller</span><span class="p">(</span><span class="nx">when</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">pending</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前定时器已从P堆中删除，则重新加入P堆中；</p>
<p>如果修改后的时间提前了，则修改状态为 timerModifiedEarlier，同时唤醒netpool中休眠的线程。</p>
<h3 id="timerstop--tickerstop">Timer.Stop &amp; Ticker.Stop</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stop turns off a ticker. After Stop, no more ticks will be sent.
</span><span class="c1">// Stop does not close the channel, to prevent a concurrent goroutine
</span><span class="c1">// reading from the channel from seeing an erroneous &#34;tick&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Ticker</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">stopTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stop prevents the Timer from firing.
</span><span class="c1">// It returns true if the call stops the timer, false if the timer has already
</span><span class="c1">// expired or been stopped.
</span><span class="c1">// Stop does not close the channel, to prevent a read from the channel succeeding
</span><span class="c1">// incorrectly.
</span><span class="c1">//
</span><span class="c1">// To ensure the channel is empty after a call to Stop, check the
</span><span class="c1">// return value and drain the channel.
</span><span class="c1">// For example, assuming the program has not received from t.C already:
</span><span class="c1">//
</span><span class="c1">// 	if !t.Stop() {
</span><span class="c1">// 		&lt;-t.C
</span><span class="c1">// 	}
</span><span class="c1">//
</span><span class="c1">// This cannot be done concurrent to other receives from the Timer&#39;s
</span><span class="c1">// channel or other calls to the Timer&#39;s Stop method.
</span><span class="c1">//
</span><span class="c1">// For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer
</span><span class="c1">// has already expired and the function f has been started in its own goroutine;
</span><span class="c1">// Stop does not wait for f to complete before returning.
</span><span class="c1">// If the caller needs to know whether f is completed, it must coordinate
</span><span class="c1">// with f explicitly.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;time: Stop called on uninitialized Timer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Timer 和 Ticker 都是调用的 stopTimer。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// stopTimer stops a timer.
</span><span class="c1">// It reports whether t was stopped before being run.
</span><span class="c1">//go:linkname stopTimer time.stopTimer
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">deltimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>deltimer 在上面也看到过了。</p>
<h2 id="小结">小结</h2>
<p>Go 语言的计时器在并发编程起到了非常重要的作用，它能够为我们提供比较准确的相对时间，基于它的功能，标准库中还提供了定时器、休眠等接口能够我们在 Go 语言程序中更好地处理过期和超时等问题。</p>
<p>标准库中的计时器在大多数情况下是能够正常工作并且高效完成任务的，但是在遇到极端情况或者性能敏感场景时，它可能没有办法胜任，而在 10ms 的这个粒度中，作者在社区中也没有找到能够使用的计时器实现，一些使用时间轮算法的开源库也不能很好地完成这个任务。</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.luozhiyun.com/archives/458">Go中定时器实现原理及源码解析</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/#63-%e8%ae%a1%e6%97%b6%e5%99%a8">6.3 计时器</a></p>
<p><a href="https://blog.haohtml.com/archives/25962">Runtime: Golang 定时器实现原理及源码解析</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-10-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/%E8%AE%A1%E6%97%B6%E5%99%A8/">计时器</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的timer和ticker用法</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/linux%E5%86%85%E6%A0%B8%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0/">
            <span class="next-text nav-default">Linux内核时钟系统和定时器实现</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
