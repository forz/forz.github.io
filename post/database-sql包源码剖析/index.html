<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>database-sql包源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.1 with theme even" />


<link rel="canonical" href="/post/database-sql%E5%8C%85%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="database-sql包源码剖析" />
<meta property="og:description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/database-sql%E5%8C%85%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-12-20T15:40:47+00:00" />
<meta property="article:modified_time" content="2018-12-20T15:40:47+00:00" />

<meta itemprop="name" content="database-sql包源码剖析">
<meta itemprop="description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，"><meta itemprop="datePublished" content="2018-12-20T15:40:47+00:00" />
<meta itemprop="dateModified" content="2018-12-20T15:40:47+00:00" />
<meta itemprop="wordCount" content="31642">
<meta itemprop="keywords" content="Go,Mysql," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="database-sql包源码剖析"/>
<meta name="twitter:description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">database-sql包源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-12-20 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 31642 字 </span>
          <span class="more-meta"> 预计阅读 64 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#连接与连接池">连接与连接池</a>
      <ul>
        <li><a href="#databasesql">database/sql</a></li>
        <li><a href="#快速开始">快速开始</a></li>
        <li><a href="#连接池">连接池</a></li>
        <li><a href="#连接失败">连接失败</a></li>
        <li><a href="#连接池配置">连接池配置</a></li>
        <li><a href="#源码分析">源码分析</a></li>
      </ul>
    </li>
    <li><a href="#curd">CURD</a>
      <ul>
        <li><a href="#数据库查询">数据库查询</a></li>
        <li><a href="#源码分析-1">源码分析</a></li>
        <li><a href="#读取数据">读取数据</a></li>
        <li><a href="#读取单条记录">读取单条记录</a></li>
        <li><a href="#字段转换">字段转换</a></li>
        <li><a href="#空值处理">空值处理</a></li>
        <li><a href="#自动匹配字段">自动匹配字段</a></li>
        <li><a href="#exec">Exec</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#prepare">Prepare</a>
      <ul>
        <li><a href="#prepare-1">prepare</a></li>
        <li><a href="#参数占位符语法">参数占位符语法</a></li>
        <li><a href="#dbquery">db.Query</a></li>
        <li><a href="#dbprepare">db.Prepare</a></li>
        <li><a href="#源码分析-2">源码分析</a></li>
        <li><a href="#总结-1">总结</a></li>
      </ul>
    </li>
    <li><a href="#transaction">Transaction</a>
      <ul>
        <li><a href="#tx对象">tx对象</a></li>
        <li><a href="#事务与连接">事务与连接</a></li>
        <li><a href="#事务并发">事务并发</a></li>
        <li><a href="#事务中的准备语句">事务中的准备语句</a></li>
        <li><a href="#总结-2">总结</a></li>
      </ul>
    </li>
    <li><a href="#错误处理">错误处理</a>
      <ul>
        <li><a href="#遍历结果集的错误">遍历结果集的错误</a></li>
        <li><a href="#关闭结果集的错误">关闭结果集的错误</a></li>
        <li><a href="#queryrow的错误">QueryRow()的错误</a></li>
        <li><a href="#识别特定的数据库错误">识别特定的数据库错误</a></li>
        <li><a href="#处理连接错误">处理连接错误</a></li>
      </ul>
    </li>
    <li><a href="#惊喜反模式和限制">惊喜，反模式和限制</a>
      <ul>
        <li><a href="#资源枯竭">资源枯竭</a></li>
        <li><a href="#巨大的uint64值">巨大的uint64值</a></li>
        <li><a href="#连接状态不匹配">连接状态不匹配</a></li>
        <li><a href="#数据库特定的语法">数据库特定的语法</a></li>
        <li><a href="#多个结果集">多个结果集</a></li>
        <li><a href="#调用存储过程">调用存储过程</a></li>
        <li><a href="#多个声明支持">多个声明支持</a></li>
      </ul>
    </li>
    <li><a href="#连接的有效性">连接的有效性</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="连接与连接池">连接与连接池</h2>
<h3 id="databasesql">database/sql</h3>
<p>database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，那些特有的方法交给数据库驱动去实现。</p>
<p>database/sql库提供了一些type。这些类型对掌握它的用法非常重要。</p>
<ul>
<li>DB 数据库对象。 sql.DB类型代表了数据库。和其他语言不一样，它并是数据库连接。golang中的连接来自内部实现的连接池，连接的建立是惰性的，当你需要连接的时候，连接池会自动帮你创建。通常你不需要操作连接池。一切都有go来帮你完成。</li>
<li>Results 结果集。数据库查询的时候，都会有结果集。sql.Rows类型表示查询返回多行数据的结果集。sql.Row则表示单行查询结果的结果集。当然，对于插入更新和删除，返回的结果集类型为sql.Result。</li>
<li>Statements 语句。sql.Stmt类型表示sql查询语句，例如DDL，DML等类似的sql语句。可以把当成prepare语句构造查询，也可以直接使用sql.DB的函数对其操作。</li>
</ul>
<h3 id="快速开始">快速开始</h3>
<p>下面就开始我们的sql数据库之旅，我们使用mysql数据库为例子，驱动使用go-sql-driver/mysql。</p>
<p>对于其他语言，查询数据的时候需要创建一个连接，对于go而言则是需要创建一个数据库抽象对象。连接将会在查询需要的时候，由连接池创建并维护。使用sql.Open函数创建数据库对象。它的第一个参数是数据库驱动名，第二个参数是一个连接字串（符合DSN风格，可以是一个tcp连接，一个unix socket等）。</p>
<p>构建连接, 格式是：&ldquo;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&rdquo;</p>
<p>打开数据库,前者是驱动名，所以要导入： _ &ldquo;github.com/go-sql-driver/mysql&rdquo;</p>
<p>设置数据库最大连接数和设置上数据库最大闲置连接数</p>
<p>验证连接：使用Ping()函数</p>
<p>代码参考如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//数据库配置
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">userName</span> <span class="p">=</span> <span class="s">&#34;root&#34;</span>
    <span class="nx">password</span> <span class="p">=</span> <span class="s">&#34;123456&#34;</span>
    <span class="nx">ip</span> <span class="p">=</span> <span class="s">&#34;127.0.0.1&#34;</span>
    <span class="nx">port</span> <span class="p">=</span> <span class="s">&#34;3306&#34;</span>
    <span class="nx">dbName</span> <span class="p">=</span> <span class="s">&#34;loginserver&#34;</span>
<span class="p">)</span>
<span class="c1">//Db数据库连接池
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DB</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span>

<span class="c1">//注意方法名大写，就是public
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">InitDB</span><span class="p">()</span>  <span class="p">{</span>
    <span class="c1">//构建连接：&#34;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&#34;
</span><span class="c1"></span>    <span class="nx">path</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">userName</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="s">&#34;@tcp(&#34;</span><span class="p">,</span><span class="nx">ip</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="s">&#34;)/&#34;</span><span class="p">,</span> <span class="nx">dbName</span><span class="p">,</span> <span class="s">&#34;?charset=utf8&#34;</span><span class="p">},</span> <span class="s">&#34;&#34;</span><span class="p">)</span>

    <span class="c1">//打开数据库,前者是驱动名，所以要导入： _ &#34;github.com/go-sql-driver/mysql&#34;
</span><span class="c1"></span>    <span class="nx">DB</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
    <span class="c1">//设置数据库最大连接数
</span><span class="c1"></span>    <span class="nx">DB</span><span class="p">.</span><span class="nf">SetConnMaxLifetime</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1">//设置上数据库最大闲置连接数
</span><span class="c1"></span>    <span class="nx">DB</span><span class="p">.</span><span class="nf">SetMaxIdleConns</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="c1">//验证连接
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">DB</span><span class="p">.</span><span class="nf">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;opon database fail&#34;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;connnect success&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>创建了数据库对象之后，在函数退出的时候，需要释放连接，即调用sql.Close方法。例子使用了defer语句设置释放连接。
接下来进行一些基本的数据库操作，首先我们使用Exec方法执行一条sql，创建一个数据表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;CREATE TABLE IF NOT EXISTS test.hello(world varchar(50))&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此时可以看见，数据库生成了一个新的表。接下来再插入一些数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>

    <span class="o">...</span>

    <span class="nx">rs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;INSERT INTO test.hello(world) VALUES (&#39;hello world&#39;)&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rowCount</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;inserted %d rows&#34;</span><span class="p">,</span> <span class="nx">rowCount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同样使用Exec方法即可插入数据，返回的结果集对象是是一个sql.Result类型，它有一个LastInsertId方法，返回插入数据后的id。当然此例的数据表并没有id字段，就返回一个0.</p>
<p>插入了一些数据，接下来再简单的查询一下数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>

    <span class="o">...</span>

    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found row containing %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们使用了Query方法执行select查询语句，返回的是一个sql.Rows类型的结果集。迭代后者的Next方法，然后使用Scan方法给变量s赋值，以便取出结果。最后再把结果集关闭（释放连接）。</p>
<p>通过上面一个简单的例子，介绍了database/sql的基本数据查询操作。而对于开篇所说的几个结构类型尚未进行详细的介绍。下面我们再针对database/sql库的类型和数据库交互做更深的探究。</p>
<h3 id="连接池">连接池</h3>
<p>正如上文所言，sql.DB是数据库的抽象，虽然通常它容易被误以为是数据库连接。它提供了一些跟数据库交互的函数，同时管理维护一个数据库连接池，帮你处理了单调而重复的管理工作，并且在多个goroutines也是十分安全。</p>
<p>虽然在完成数据库之后Close()数据库是惯用的，但是sql.DB对象被设计为长连接。不要经常Open()和Close()数据库。相反，为你需要访问的每个不同的数据存储创建一个sql.DB对象，并保留它，直到程序访问数据存储完毕。在需要时传递它，或在全局范围内使其可用，但要保持开放。并且不要从短暂的函数中Open()和Close()。相反，通过sql.DB作为参数传递给该短暂的函数。</p>
<p>如果你不把sql.DB视为长期存在的对象，则可能会遇到诸如重复使用和连接共享不足，耗尽可用的网络资源以及由于TIME_WAIT中剩余大量TCP连接而导致的零星故障的状态。这些问题表明你没有像设计的那样使用database/sql的迹象。</p>
<p>创建数据库对象需要引入标准库database/sql，同时还需要引入驱动go-sql-driver/mysql。使用_表示引入驱动的变量，这样做的目的是为了在你的代码中不至于和标注库的函数变量namespace冲突。</p>
<p>连接池的工作原理相当简单。当你的函数(例如Exec，Query)调用需要访问底层数据库的时候，函数首先会向连接池请求一个连接。如果连接池有空闲的连接，则返回给函数。否则连接池将会创建一个新的连接给函数。一旦连接给了函数，连接则归属于函数。函数执行完毕后，要不把连接所属权归还给连接池，要么传递给下一个需要连接的（Rows）对象，最后使用完连接的对象也会把连接释放回到连接池。</p>
<p>database/sql包中有一个基本的连接池。没有很多的控制或检查能力，但这里有一些你可能会发现有用的知识：</p>
<ul>
<li>连接池意味着在单个数据库上执行两个连续的语句可能会打开两个链接并单独执行它们。对于程序员来说，为什么它们的代码行为不当，这是相当普遍的。例如，后面跟着INSERT的LOCK TABLES可能会被阻塞，因为INSERT位于不具有表锁定的连接上。</li>
<li>连接是在需要时创建的，池中没有空闲连接。</li>
<li>默认情况下，连接数量没有限制。如果你尝试同时执行很多操作，可以创建任意数量的连接。这可能导致数据库返回错误，例如“连接太多”。</li>
<li>在Golang1.1或更新版本中，你可以使用db.SetMaxIdleConns(N)来限制池中的空闲连接数。这并不限制池的大小。</li>
<li>在Golang1.2.1或更新版本中，可以使用db.SetMaxOpenConns(N)来限制于数据库的总打开连接数。不幸的是，一个死锁bug（修复）阻止db.SetMaxOpenConns(N)在1.2中安全使用。</li>
<li>连接回收相当快。使用db.SetMaxIdleConns(N)设置大量空闲连接可以减少此流失，并有助于保持连接以重新使用。</li>
<li>长期保持连接空闲可能会导致问题（例如在微软azure上的这个问题）。尝试db.SetMaxIdleConns(0)如果你连接超时，因为连接空闲时间太长。</li>
</ul>
<p>请求一个连接的函数有好几种，执行完毕处理连接的方式稍有差别，大致如下：</p>
<ul>
<li>db.Ping() 调用完毕后会马上把连接返回给连接池。</li>
<li>db.Exec() 调用完毕后会马上把连接返回给连接池，但是它返回的Result对象还保留这连接的引用，当后面的代码需要处理结果集的时候连接将会被重用。</li>
<li>db.Query() 调用完毕后会将连接传递给sql.Rows类型，当然后者迭代完毕或者显示的调用.Close()方法后，连接将会被释放回到连接池。</li>
<li>db.QueryRow()调用完毕后会将连接传递给sql.Row类型，当.Scan()方法调用之后把连接释放回到连接池。</li>
<li>db.Begin() 调用完毕后将连接传递给sql.Tx类型对象，当.Commit()或.Rollback()方法调用后释放连接。</li>
</ul>
<p>因为每一个连接都是惰性创建的，如何验证sql.Open调用之后，sql.DB对象可用呢？通常使用db.Ping()方法初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;driverName&#34;</span><span class="p">,</span> <span class="s">&#34;dataSourceName&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Ping</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用了Ping之后，连接池一定会初始化一个数据库连接。当然，实际上对于失败的处理，应该定义一个符合自己需要的方式，现在为了演示，简单的使用log.Fatalln(err)表示了。</p>
<h3 id="连接失败">连接失败</h3>
<p>关于连接池另外一个知识点就是你不必检查或者尝试处理连接失败的情况。当你进行数据库操作的时候，如果连接失败了，database/sql会帮你处理。实际上，当从连接池取出的连接断开的时候，database/sql会自动尝试重连10次。仍然无法重连的情况下会自动从连接池再获取一个或者新建另外一个。</p>
<h3 id="连接池配置">连接池配置</h3>
<p>无论哪一个版本的go都不会提供很多控制连接池的接口。知道1.2版本以后才有一些简单的配置。可是1.2版本的连接池有一个bug，请升级更高的版本。</p>
<p>配置连接池有两个的方法：</p>
<ul>
<li>db.SetMaxOpenConns(n int) 设置打开数据库的最大连接数。包含正在使用的连接和连接池的连接。如果你的函数调用需要申请一个连接，并且连接池已经没有了连接或者连接数达到了最大连接数。此时的函数调用将会被block，直到有可用的连接才会返回。设置这个值可以避免并发太高导致连接mysql出现too many connections的错误。该函数的默认设置是0，表示无限制。</li>
<li>db.SetMaxIdleConns(n int) 设置连接池中的保持连接的最大连接数。默认也是0，表示连接池不会保持释放会连接池中的连接的连接状态：即当连接释放回到连接池的时候，连接将会被关闭。这会导致连接再连接池中频繁的关闭和创建。</li>
</ul>
<p>对于连接池的使用依赖于你是如何配置连接池，如果使用不当会导致下面问题：</p>
<ul>
<li>大量的连接空闲，导致额外的工作和延迟。</li>
<li>连接数据库的连接过多导致错误。</li>
<li>连接阻塞。</li>
<li>连接池有超过十个或者更多的死连接，限制就是10次重连。</li>
</ul>
<p>大多数时候，如何使用sql.DB对连接的影响大过连接池配置的影响。这些具体问题我们会在使用sql.DB的时候逐一介绍。</p>
<p>MaxOpenConns 应该和实际的打开的连接数的监测值相关。然后按照 MaxOpenConns 的一定比值设置 MaxIdleConns，比方说 50%，这个值取决于你对业务的预估。每维持一个闲散连接，会造成 1MB 左右的客户端内存开销和 2MB 左右的数据库内存开销，CPU 开销相对小一点。</p>
<p>掌握了database/sql关于数据库连接池管理内容，下一步则是使用这些连接，进行数据的交互操作啦。</p>
<h3 id="源码分析">源码分析</h3>
<h4 id="数据结构">数据结构</h4>
<p>sql.DB:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DB is a database handle representing a pool of zero or more
</span><span class="c1">// underlying connections. It&#39;s safe for concurrent use by multiple
</span><span class="c1">// goroutines.
</span><span class="c1">//
</span><span class="c1">// The sql package creates and frees connections automatically; it
</span><span class="c1">// also maintains a free pool of idle connections. If the database has
</span><span class="c1">// a concept of per-connection state, such state can be reliably observed
</span><span class="c1">// within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the
</span><span class="c1">// returned Tx is bound to a single connection. Once Commit or
</span><span class="c1">// Rollback is called on the transaction, that transaction&#39;s
</span><span class="c1">// connection is returned to DB&#39;s idle connection pool. The pool size
</span><span class="c1">// can be controlled with SetMaxIdleConns.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DB</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Atomic access only. At top of struct to prevent mis-alignment
</span><span class="c1"></span>	<span class="c1">// on 32-bit platforms. Of type time.Duration.
</span><span class="c1"></span>	<span class="nx">waitDuration</span> <span class="kt">int64</span> <span class="c1">// Total time waited for new connections.
</span><span class="c1"></span>    <span class="c1">//数据库实现驱动
</span><span class="c1"></span>	<span class="nx">connector</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Connector</span>
	<span class="c1">// numClosed is an atomic counter which represents a total number of
</span><span class="c1"></span>	<span class="c1">// closed connections. Stmt.openStmt checks it before cleaning closed
</span><span class="c1"></span>	<span class="c1">// connections in Stmt.css.
</span><span class="c1"></span>	<span class="nx">numClosed</span> <span class="kt">uint64</span>
    <span class="c1">// 锁
</span><span class="c1"></span>    <span class="nx">mu</span>           <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// protects following fields
</span><span class="c1"></span>    <span class="c1">// 空闲连接
</span><span class="c1"></span>    <span class="nx">freeConn</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">driverConn</span>
    <span class="c1">// 阻塞请求队列，等连接数达到最大限制时，后续请求将插入此队列等待可用连接
</span><span class="c1"></span>    <span class="nx">connRequests</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kd">chan</span> <span class="nx">connRequest</span>
    <span class="c1">// 记录下一个key用于connRequests map的key
</span><span class="c1"></span>	<span class="nx">nextRequest</span>  <span class="kt">uint64</span> <span class="c1">// Next key to use in connRequests.
</span><span class="c1"></span>    <span class="c1">// 已经打开的和将要打开的连接的总数
</span><span class="c1"></span>    <span class="nx">numOpen</span>      <span class="kt">int</span>    <span class="c1">// number of opened and pending open connections
</span><span class="c1"></span>	<span class="c1">// Used to signal the need for new connections
</span><span class="c1"></span>	<span class="c1">// a goroutine running connectionOpener() reads on this chan and
</span><span class="c1"></span>	<span class="c1">// maybeOpenNewConnections sends on the chan (one send per needed connection)
</span><span class="c1"></span>	<span class="c1">// It is closed during db.Close(). The close tells the connectionOpener
</span><span class="c1"></span>	<span class="c1">// goroutine to exit.
</span><span class="c1"></span>    <span class="c1">// 用来接收创建新连接的信号
</span><span class="c1"></span>    <span class="c1">// connectionOpener方法会读取该channel的信号，而当需要创建连接的时候，maybeOpenNewConnections就会往该channel发信号。
</span><span class="c1"></span>    <span class="c1">// 当调用db.Close()的时候，该channel就会被关闭
</span><span class="c1"></span>    <span class="nx">openerCh</span>          <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">closed</span>            <span class="kt">bool</span>
	<span class="nx">dep</span>               <span class="kd">map</span><span class="p">[</span><span class="nx">finalCloser</span><span class="p">]</span><span class="nx">depSet</span>
	<span class="nx">lastPut</span>           <span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">driverConn</span><span class="p">]</span><span class="kt">string</span> <span class="c1">// stacktrace of last conn&#39;s put; debug only
</span><span class="c1"></span>    <span class="nx">maxIdleCount</span>      <span class="kt">int</span>                    <span class="c1">// zero means defaultMaxIdleConns; negative means 0
</span><span class="c1"></span>    <span class="c1">// 最大打开连接数
</span><span class="c1"></span>    <span class="nx">maxOpen</span>           <span class="kt">int</span>                    <span class="c1">// &lt;= 0 means unlimited
</span><span class="c1"></span>    <span class="c1">// 连接最大存活时间
</span><span class="c1"></span>	<span class="nx">maxLifetime</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>          <span class="c1">// maximum amount of time a connection may be reused
</span><span class="c1"></span>	<span class="nx">maxIdleTime</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>          <span class="c1">// maximum amount of time a connection may be idle before being closed
</span><span class="c1"></span>	<span class="nx">cleanerCh</span>         <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
    <span class="nx">waitCount</span>         <span class="kt">int64</span> <span class="c1">// Total number of connections waited for.
</span><span class="c1"></span>	<span class="nx">maxIdleClosed</span>     <span class="kt">int64</span> <span class="c1">// Total number of connections closed due to idle count.
</span><span class="c1"></span>    <span class="nx">maxIdleTimeClosed</span> <span class="kt">int64</span> <span class="c1">// Total number of connections closed due to idle time.
</span><span class="c1"></span>    <span class="c1">// 因为超过存活时间而被关闭的连接总数
</span><span class="c1"></span>	<span class="nx">maxLifetimeClosed</span> <span class="kt">int64</span> <span class="c1">// Total number of connections closed due to max connection lifetime limit.
</span><span class="c1"></span>
	<span class="nx">stop</span> <span class="kd">func</span><span class="p">()</span> <span class="c1">// stop cancels the connection opener and the session resetter.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>driverConn代表了一个具体的数据库连接，每一条sql的执行最终都会落实到一个具体的driverConn</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// driverConn wraps a driver.Conn with a mutex, to
</span><span class="c1">// be held during all calls into the Conn. (including any calls onto
</span><span class="c1">// interfaces returned via that Conn, such as calls on Tx, Stmt,
</span><span class="c1">// Result, Rows)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">driverConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">db</span>        <span class="o">*</span><span class="nx">DB</span>   <span class="c1">// 数据库句柄
</span><span class="c1"></span>	<span class="nx">createdAt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

	<span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>  <span class="c1">// guards following  // 锁
</span><span class="c1"></span>	<span class="nx">ci</span>          <span class="nx">driver</span><span class="p">.</span><span class="nx">Conn</span><span class="c1">// 对应具体的连接
</span><span class="c1"></span>	<span class="nx">needReset</span>   <span class="kt">bool</span> <span class="c1">// The connection session should be reset before use if true.
</span><span class="c1"></span>	<span class="nx">closed</span>      <span class="kt">bool</span>    <span class="c1">// 是否标记关闭
</span><span class="c1"></span>	<span class="nx">finalClosed</span> <span class="kt">bool</span> <span class="c1">// ci.Close has been called    // 是否最终关闭
</span><span class="c1"></span>	<span class="nx">openStmt</span>    <span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">driverStmt</span><span class="p">]</span><span class="kt">bool</span>    <span class="c1">// 在这个连接上打开的状态
</span><span class="c1"></span>
	<span class="c1">// guarded by db.mu
</span><span class="c1"></span>	<span class="nx">inUse</span>      <span class="kt">bool</span><span class="c1">// 连接是否占用
</span><span class="c1"></span>    <span class="nx">returnedAt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="c1">// Time the connection was created or returned.
</span><span class="c1"></span>    <span class="c1">// 连接归还时要运行的函数，在 noteUnusedDriverStatement 添加
</span><span class="c1"></span>    <span class="nx">onPut</span>      <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>  <span class="c1">// code (with db.mu held) run when conn is next returned
</span><span class="c1"></span>     <span class="c1">// 和 closed 状态一致，但是由锁保护，用于 removeClosedStmtLocked
</span><span class="c1"></span>	<span class="nx">dbmuClosed</span> <span class="kt">bool</span>      <span class="c1">// same as closed, but guarded by db.mu, for removeClosedStmtLocked
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="sqlopen">sql.Open</h4>
<p>该方法返回的DB对象是线程安全的，可以放心使用，它自己会保持一个空闲的连接池。所以，Open方法在程序里应该只被调用一次，通常情况是不需要去关闭的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Open opens a database specified by its database driver name and a
</span><span class="c1">// driver-specific data source name, usually consisting of at least a
</span><span class="c1">// database name and connection information.
</span><span class="c1">//
</span><span class="c1">// Most users will open a database via a driver-specific connection
</span><span class="c1">// helper function that returns a *DB. No database drivers are included
</span><span class="c1">// in the Go standard library. See https://golang.org/s/sqldrivers for
</span><span class="c1">// a list of third-party drivers.
</span><span class="c1">//
</span><span class="c1">// Open may just validate its arguments without creating a connection
</span><span class="c1">// to the database. To verify that the data source name is valid, call
</span><span class="c1">// Ping.
</span><span class="c1">//
</span><span class="c1">// The returned DB is safe for concurrent use by multiple goroutines
</span><span class="c1">// and maintains its own pool of idle connections. Thus, the Open
</span><span class="c1">// function should be called just once. It is rarely necessary to
</span><span class="c1">// close a DB.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">driverName</span><span class="p">,</span> <span class="nx">dataSourceName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">DB</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">driversMu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">driveri</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">drivers</span><span class="p">[</span><span class="nx">driverName</span><span class="p">]</span>
	<span class="nx">driversMu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;sql: unknown driver %q (forgotten import?)&#34;</span><span class="p">,</span> <span class="nx">driverName</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">driverCtx</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">driveri</span><span class="p">.(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">DriverContext</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">connector</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">driverCtx</span><span class="p">.</span><span class="nf">OpenConnector</span><span class="p">(</span><span class="nx">dataSourceName</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">OpenDB</span><span class="p">(</span><span class="nx">connector</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">OpenDB</span><span class="p">(</span><span class="nx">dsnConnector</span><span class="p">{</span><span class="nx">dsn</span><span class="p">:</span> <span class="nx">dataSourceName</span><span class="p">,</span> <span class="nx">driver</span><span class="p">:</span> <span class="nx">driveri</span><span class="p">}),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// OpenDB opens a database using a Connector, allowing drivers to
</span><span class="c1">// bypass a string based data source name.
</span><span class="c1">//
</span><span class="c1">// Most users will open a database via a driver-specific connection
</span><span class="c1">// helper function that returns a *DB. No database drivers are included
</span><span class="c1">// in the Go standard library. See https://golang.org/s/sqldrivers for
</span><span class="c1">// a list of third-party drivers.
</span><span class="c1">//
</span><span class="c1">// OpenDB may just validate its arguments without creating a connection
</span><span class="c1">// to the database. To verify that the data source name is valid, call
</span><span class="c1">// Ping.
</span><span class="c1">//
</span><span class="c1">// The returned DB is safe for concurrent use by multiple goroutines
</span><span class="c1">// and maintains its own pool of idle connections. Thus, the OpenDB
</span><span class="c1">// function should be called just once. It is rarely necessary to
</span><span class="c1">// close a DB.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">OpenDB</span><span class="p">(</span><span class="nx">c</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Connector</span><span class="p">)</span> <span class="o">*</span><span class="nx">DB</span> <span class="p">{</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">db</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">DB</span><span class="p">{</span>
		<span class="nx">connector</span><span class="p">:</span>    <span class="nx">c</span><span class="p">,</span>
		<span class="nx">openerCh</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">connectionRequestQueueSize</span><span class="p">),</span>
		<span class="nx">lastPut</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">driverConn</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
		<span class="nx">connRequests</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kd">chan</span> <span class="nx">connRequest</span><span class="p">),</span>
		<span class="nx">stop</span><span class="p">:</span>         <span class="nx">cancel</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="nx">db</span><span class="p">.</span><span class="nf">connectionOpener</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">db</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用sql.Open函数创建连接池，可是此时只是初始化了连接池，并没有创建任何连接。连接创建都是惰性的，只有当你真正使用到连接的时候，连接池才会创建连接。连接池很重要，它直接影响着你的程序行为。</p>
<h4 id="dbclose">db.Close</h4>
<p>关闭数据库，并释放所有相关资源。</p>
<p>再次强调：通常不需要执行该操作。DB句柄应该是长期生存的，可以安全的共享于众多的协程中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span> <span class="c1">// Make DB.Close idempotent
</span><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">openerCh</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">fns</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">{</span>
		<span class="nx">fns</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">fns</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">closeDBLocked</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span> <span class="p">{</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fns</span> <span class="p">{</span>
		<span class="nx">err1</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">err1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="连接池-1">连接池</h4>
<p>这个连接池有几个特征参数：</p>
<ul>
<li>maxLifetime
maximum amount of time a connection may be reused</li>
<li>maxIdle
允许的最大空闲连接数</li>
<li>maxOpen
允许的打开的最大连接数</li>
</ul>
<p>连接池中的连接数最大会增长到maxOpen，当请求高峰过后，连接池的可用连接数又会慢慢缩回到maxIdle</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryContext</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">QueryContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">rows</span> <span class="o">*</span><span class="nx">Rows</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="c1">// 优先用池子里的连接
</span><span class="c1"></span>    <span class="c1">// maxBadConnRetries是一个常量，值为2
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maxBadConnRetries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// cacheOrNewConn: 是获取连接策略常量，优先从连接池中获取一个可用的连接，如果没有可用连接，此时如果连接数已经达到上限，则等待，否则则直接创建一个新连接。
</span><span class="c1"></span>        <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">cachedOrNewConn</span><span class="p">)</span>
        <span class="c1">// 如果连接异常，则重试
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 当然池子里的连接有可能会过期，如果重试两次还取不到可以用的连接
</span><span class="c1"></span>    <span class="c1">// 那就从数据库请求一个新的
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
        <span class="c1">// 再重试一遍，使用创建连接的策略
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">alwaysNewConn</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
  <span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">query</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">conn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">queryDC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">dc</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="获取连接">获取连接</h5>
<p>下面就是获取连接的逻辑了，流程如下：</p>
<ul>
<li>如果策略是优先使用缓存连接且连接池中还有空闲连接，则直接从连接池中取一个连接返回</li>
<li>如果连接池里当前已打开的连接数已超出maxOpen限制，则阻塞一直等待有连接归还到连接池后再取用</li>
<li>否则就新建一个连接返回</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201228181455.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// conn returns a newly-opened or cached *driverConn.
</span><span class="c1">// conn 获取一个缓存中的或者新打开的连接
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">conn</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//从连接池中获取连接时首先要对整个连接池加锁，如果连接池已经事先被关掉了，直接返回 errDBClosed 错误。如果连接池无恙，将会评估连接请求是否取消或过期。
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="c1">// 如果数据库已经关闭，会直接返回错误，而且外部不会对这个错误做处理
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errDBClosed</span>
	<span class="p">}</span>
    <span class="c1">// Check if the context is expired.
</span><span class="c1"></span>    <span class="c1">// 检查是否已被取消
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 一个连接的最大生命周期
</span><span class="c1"></span>	<span class="nx">lifetime</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span>
    <span class="c1">//尽可能优先使用空闲的连接而不是新建一条连接（这也是连接池存在的意义）。看一下是否还剩下空闲连接，如果还有，就取第 0 条连接出来，然后左移所有连接填补空位。这里对连接本身操作都会上锁。
</span><span class="c1"></span>    <span class="c1">// Prefer a free connection, if possible.
</span><span class="c1"></span>    <span class="c1">// 查看是否有空闲的连接 如果有则直接使用空闲连接
</span><span class="c1"></span>    <span class="c1">// 获取空闲的连接，判断是否超时，无超时返回调用方，超时返回err, 调用方会重试，默认是重试2次
</span><span class="c1"></span>	<span class="nx">numFree</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">strategy</span> <span class="o">==</span> <span class="nx">cachedOrNewConn</span> <span class="o">&amp;&amp;</span> <span class="nx">numFree</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 取第一个空闲连接，并生成新的空闲连接列表
</span><span class="c1"></span>        <span class="nx">conn</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">// 复制数组，去除第一个连接
</span><span class="c1"></span>        <span class="c1">// 这是在更新空闲的数据库连接数组，最开始的那个连接现在已经要被占用了
</span><span class="c1"></span>        <span class="nb">copy</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1">// 移除掉末尾那个无用的元素
</span><span class="c1"></span>        <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[:</span><span class="nx">numFree</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">// 通过以上两步，成功从freeConn中删掉了开头的第一个连接
</span><span class="c1"></span>        <span class="nx">conn</span><span class="p">.</span><span class="nx">inUse</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="c1">// 检查连接是否已经过期
</span><span class="c1"></span>        <span class="c1">// 注意如果过期并没有尝试取下一个，而是直接返回了错误
</span><span class="c1"></span>        <span class="c1">// 由上层来继续发起连接，我理解这样会保持不同层之间逻辑的干净
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">expired</span><span class="p">(</span><span class="nx">lifetime</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果超时了，则关闭该连接，返回该错误时，外部会重试
</span><span class="c1"></span>			<span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetimeClosed</span><span class="o">++</span>
			<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
		<span class="p">}</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="c1">// Reset the session if required.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">resetSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">conn</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Out of free connections or we were asked not to use one. If we&#39;re not
</span><span class="c1"></span>    <span class="c1">// allowed to open any more connections, make a request and wait.
</span><span class="c1"></span>    <span class="c1">// 如果当前打开的连接数已经超过了db.maxOpen
</span><span class="c1"></span>    <span class="c1">//如果没有空闲连接了，而且已打开的 + 即将打开的连接数超过了限定的最大打开的连接数，就要发送一条连接请求然后排队（不会新建连接）。等待排队期间同时监听连接请求是否取消或过期，如果此时连接被取消很不巧正好有连接来了，就将连接放回连接池中；如果等着等着连接来了，会先检查这个连接的上一次会话是否被重置，确认没问题就用这条连接。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxOpen</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span> <span class="o">&gt;=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxOpen</span> <span class="p">{</span>
		<span class="c1">// Make the connRequest channel. It&#39;s buffered so that the
</span><span class="c1"></span>        <span class="c1">// connectionOpener doesn&#39;t block while waiting for the req to be read.
</span><span class="c1"></span>        <span class="c1">// 创建一个chan
</span><span class="c1"></span>        <span class="nx">req</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">connRequest</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">// 获取下一个request 作为map 中的key
</span><span class="c1"></span>		<span class="nx">reqKey</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">nextRequestKeyLocked</span><span class="p">()</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span><span class="p">[</span><span class="nx">reqKey</span><span class="p">]</span> <span class="p">=</span> <span class="nx">req</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">waitCount</span><span class="o">++</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="nx">waitStart</span> <span class="o">:=</span> <span class="nf">nowFunc</span><span class="p">()</span>

		<span class="c1">// Timeout the connection request with the context.
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
        <span class="c1">//下面就是select+ctx判断请求有没有超时，还有等待队列是否接收到数据
</span><span class="c1"></span>        <span class="c1">// 注意这个select没有default分支，所以会一直阻塞在这两个分支上
</span><span class="c1"></span>        <span class="c1">// 直到任何一个分支的条件满足，即：1. query被取消了 2. 有free连接可用了
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="c1">// Remove the connection request and ensure no value has been sent
</span><span class="c1"></span>			<span class="c1">// on it after removing.
</span><span class="c1"></span>			<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span><span class="p">,</span> <span class="nx">reqKey</span><span class="p">)</span>
			<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

			<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">db</span><span class="p">.</span><span class="nx">waitDuration</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">waitStart</span><span class="p">)))</span>

			<span class="k">select</span> <span class="p">{</span>
			<span class="k">default</span><span class="p">:</span>
			<span class="k">case</span> <span class="nx">ret</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">db</span><span class="p">.</span><span class="nf">putConn</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">err</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
        <span class="c1">// 如果没有取消则从req chan中获取数据 阻塞主一直等待有conn数据传入
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">ret</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">db</span><span class="p">.</span><span class="nx">waitDuration</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">waitStart</span><span class="p">)))</span>

			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span><span class="c1">// 连接被关闭
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errDBClosed</span><span class="c1">// 说明 DB 已经关闭了
</span><span class="c1"></span>			<span class="p">}</span>
			<span class="c1">// Only check if the connection is expired if the strategy is cachedOrNewConns.
</span><span class="c1"></span>			<span class="c1">// If we require a new connection, just re-use the connection without looking
</span><span class="c1"></span>			<span class="c1">// at the expiry time. If it is expired, it will be checked when it is placed
</span><span class="c1"></span>			<span class="c1">// back into the connection pool.
</span><span class="c1"></span>			<span class="c1">// This prioritizes giving a valid connection to a client over the exact connection
</span><span class="c1"></span>            <span class="c1">// lifetime, which could expire exactly after this point anyway.
</span><span class="c1"></span>            <span class="c1">// 判断超时
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">strategy</span> <span class="o">==</span> <span class="nx">cachedOrNewConn</span> <span class="o">&amp;&amp;</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">expired</span><span class="p">(</span><span class="nx">lifetime</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetimeClosed</span><span class="o">++</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">err</span>
			<span class="p">}</span>

			<span class="c1">// Reset the session if required.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">resetSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
				<span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">err</span>
		<span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 如果还没到限定的最大打开的连接数，新建一条
</span><span class="c1"></span>    <span class="c1">// 如果没有空闲连接且尚未达到最大连接数的限制
</span><span class="c1"></span>    <span class="c1">// 那就开一个新连接
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span><span class="o">++</span> <span class="c1">// optimistically
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="c1">// 调用connector的Connect方法建立连接
</span><span class="c1"></span>	<span class="nx">ci</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">connector</span><span class="p">.</span><span class="nf">Connect</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span><span class="o">--</span> <span class="c1">// correct for earlier optimism
</span><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nf">maybeOpenNewConnections</span><span class="p">()</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">dc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">driverConn</span><span class="p">{</span>
		<span class="nx">db</span><span class="p">:</span>         <span class="nx">db</span><span class="p">,</span>
		<span class="nx">createdAt</span><span class="p">:</span>  <span class="nf">nowFunc</span><span class="p">(),</span>
		<span class="nx">returnedAt</span><span class="p">:</span> <span class="nf">nowFunc</span><span class="p">(),</span>
		<span class="nx">ci</span><span class="p">:</span>         <span class="nx">ci</span><span class="p">,</span>
		<span class="nx">inUse</span><span class="p">:</span>      <span class="kc">true</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">addDepLocked</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">dc</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">dc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="释放连接">释放连接</h5>
<p>下面是归还连接的逻辑：</p>
<ul>
<li>如果有connRequests，那么优先满足它</li>
<li>否则就要准备归还到池子中了，但这里还有一个check，如果当前空闲连接书freeConn大于允许的最大空闲连接限制的话就不归还了，会把连接直接关闭掉</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20201228181528.png" alt=""></p>
<p>当归还连接到连接池的时候，发现当前的连接数已经大于我们自己配置的maxOpen，那么就直接close连接。如果正常连接池，那么观察下db.connRequests是否有人等待连接。
如果在等待，那么就把连接通过channel传递过去。如果没有人正在等待获取sql连接，那么就把连接放到db.freeConn里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">)</span> <span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">putConn</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// putConn adds a connection to the db&#39;s free pool.
</span><span class="c1">// err is optionally the last error that occurred on this connection.
</span><span class="c1">// 释放连接
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">putConn</span><span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">resetSession</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">dc</span><span class="p">.</span><span class="nf">validateConnection</span><span class="p">(</span><span class="nx">resetSession</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="c1">// 检查连接是否在使用中
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">dc</span><span class="p">.</span><span class="nx">inUse</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">debugGetPut</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;putConn(%v) DUPLICATE was: %s\n\nPREVIOUS was: %s&#34;</span><span class="p">,</span> <span class="nx">dc</span><span class="p">,</span> <span class="nf">stack</span><span class="p">(),</span> <span class="nx">db</span><span class="p">.</span><span class="nx">lastPut</span><span class="p">[</span><span class="nx">dc</span><span class="p">])</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sql: connection returned that was never out&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="o">&amp;&amp;</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">expired</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 连接有问题
</span><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetimeClosed</span><span class="o">++</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">debugGetPut</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">lastPut</span><span class="p">[</span><span class="nx">dc</span><span class="p">]</span> <span class="p">=</span> <span class="nf">stack</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 设置已经在使用中
</span><span class="c1"></span>	<span class="nx">dc</span><span class="p">.</span><span class="nx">inUse</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">returnedAt</span> <span class="p">=</span> <span class="nf">nowFunc</span><span class="p">()</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">onPut</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">dc</span><span class="p">.</span><span class="nx">onPut</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="c1">// 判断连接是否有错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
		<span class="c1">// Don&#39;t reuse bad connections.
</span><span class="c1"></span>		<span class="c1">// Since the conn is considered bad and is being discarded, treat it
</span><span class="c1"></span>		<span class="c1">// as closed. Don&#39;t decrement the open count here, finalClose will
</span><span class="c1"></span>		<span class="c1">// take care of that.
</span><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nf">maybeOpenNewConnections</span><span class="p">()</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">dc</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">putConnHook</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">putConnHook</span><span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">dc</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 调用方法 释放连接
</span><span class="c1"></span>    <span class="c1">// 函数名带 Locked 表示已经加过锁
</span><span class="c1"></span>	<span class="nx">added</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">putConnDBLocked</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="c1">// 判断如果没有加到了空闲列表中 dc关闭
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">added</span> <span class="p">{</span>
        <span class="c1">// 回池出现问题，强行关闭连接
</span><span class="c1"></span>		<span class="nx">dc</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Satisfy a connRequest or put the driverConn in the idle pool and return true
</span><span class="c1">// or return false.
</span><span class="c1">// putConnDBLocked will satisfy a connRequest if there is one, or it will
</span><span class="c1">// return the *driverConn to the freeConn list if err == nil and the idle
</span><span class="c1">// connection limit will not be exceeded.
</span><span class="c1">// If err != nil, the value of dc is ignored.
</span><span class="c1">// If err == nil, then dc must not equal nil.
</span><span class="c1">// If a connRequest was fulfilled or the *driverConn was placed in the
</span><span class="c1">// freeConn list, then true is returned, otherwise false is returned.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">putConnDBLocked</span><span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// 即将打开 + 已打开的连接数超过了最大打开的连接数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxOpen</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span> <span class="p">&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxOpen</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// 如果等待chan列表大于0
</span><span class="c1"></span>    <span class="c1">// 判断有没有等待队列
</span><span class="c1"></span>    <span class="c1">// 如果有connRequests（连接需求），优先满足它
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span><span class="p">);</span> <span class="nx">c</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">req</span> <span class="kd">chan</span> <span class="nx">connRequest</span>
        <span class="kd">var</span> <span class="nx">reqKey</span> <span class="kt">uint64</span>
        <span class="c1">// 获取map 中chan和key
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">reqKey</span><span class="p">,</span> <span class="nx">req</span> <span class="p">=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span> <span class="p">{</span>
            <span class="c1">// 从表中随便拿一个
</span><span class="c1"></span>			<span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// 从列表中删除chan
</span><span class="c1"></span>		<span class="nb">delete</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span><span class="p">,</span> <span class="nx">reqKey</span><span class="p">)</span> <span class="c1">// Remove from pending requests.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">dc</span><span class="p">.</span><span class="nx">inUse</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="c1">// 把连接传入chan中 让之前获取连接被阻塞的获取函数继续
</span><span class="c1"></span>        <span class="c1">// 将连接发送给连接请求
</span><span class="c1"></span>		<span class="nx">req</span> <span class="o">&lt;-</span> <span class="nx">connRequest</span><span class="p">{</span>
			<span class="nx">conn</span><span class="p">:</span> <span class="nx">dc</span><span class="p">,</span>
			<span class="nx">err</span><span class="p">:</span>  <span class="nx">err</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
        <span class="c1">// 判断是否超过最大空闲连接数
</span><span class="c1"></span>        <span class="c1">// 如果连接池 &lt; 最大闲散连接数，放回连接池
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nf">maxIdleConnsLocked</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">)</span> <span class="p">{</span>
             <span class="c1">// 如果没有等待列表，则把连接放到空闲列表中
</span><span class="c1"></span>             <span class="c1">// 将连接放回池子
</span><span class="c1"></span>			<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">,</span> <span class="nx">dc</span><span class="p">)</span>
			<span class="nx">db</span><span class="p">.</span><span class="nf">startCleanerLocked</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="c1">// 为啥直接增加了maxIdleClosed而没有做什么呢？
</span><span class="c1"></span>        <span class="c1">// 因为这种情况下本函数会返回false，进而导致
</span><span class="c1"></span>        <span class="c1">// 连接被关闭
</span><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleClosed</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>即将打开 + 已打开的连接数不能超过最大打开的连接数限制。如果有连接请求，就从表中随便拿一个，拿出来的要从表中删掉，并把准备回池的连接直接发送给这个请求；没有连接请求的话就正常回池。</p>
<h4 id="connectionopener">connectionOpener</h4>
<p>connectionOpener:</p>
<ul>
<li>用于处理连接请求 openerCh</li>
<li>如果没有设置 maxIdleClosed，则不会有 openerCh，也不会用到 connectionOpener</li>
<li>只在调用 maybeOpenNewConnections 时检查有无 connRequests，有则触发 connectionOpener</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This is the size of the connectionOpener request chan (DB.openerCh).
</span><span class="c1">// This value should be larger than the maximum typical value
</span><span class="c1">// used for db.maxOpen. If maxOpen is significantly larger than
</span><span class="c1">// connectionRequestQueueSize then it is possible for ALL calls into the *DB
</span><span class="c1">// to block until the connectionOpener can satisfy the backlog of requests.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">connectionRequestQueueSize</span> <span class="p">=</span> <span class="mi">1000000</span>

<span class="c1">// Runs in a separate goroutine, opens new connections when requested.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">connectionOpener</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">db</span><span class="p">.</span><span class="nx">openerCh</span><span class="p">:</span>
			<span class="nx">db</span><span class="p">.</span><span class="nf">openNewConnection</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Open one new connection
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">openNewConnection</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 在发送到db.openerCh之前，maybeOpenNewConnections之前已经将numOpen++
</span><span class="c1"></span>    <span class="c1">// 如果新连接创建失败，或者已经被关闭，则在返回之前必须减1
</span><span class="c1"></span>	<span class="nx">ci</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">driver</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">dsn</span><span class="p">)</span>

    <span class="c1">// 创建连接的过程加了互斥锁
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ci</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span><span class="o">--</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span><span class="o">--</span>
		<span class="nx">db</span><span class="p">.</span><span class="nf">putConnDBLocked</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">db</span><span class="p">.</span><span class="nf">maybeOpenNewConnections</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">dc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">driverConn</span><span class="p">{</span>
		<span class="nx">db</span><span class="p">:</span>        <span class="nx">db</span><span class="p">,</span>
		<span class="nx">createdAt</span><span class="p">:</span> <span class="nf">nowFunc</span><span class="p">(),</span>
		<span class="nx">ci</span><span class="p">:</span>        <span class="nx">ci</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nf">putConnDBLocked</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nf">addDepLocked</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">dc</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span><span class="o">--</span>
		<span class="nx">ci</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果有连接请求，并且没有达到连接数的限制，告知 connectionOpener 打开新的连接</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Assumes db.mu is locked.
</span><span class="c1">// If there are connRequests and the connection limit hasn&#39;t been reached,
</span><span class="c1">// then tell the connectionOpener to open new connections.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">maybeOpenNewConnections</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">numRequests</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">connRequests</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxOpen</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">numCanOpen</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxOpen</span> <span class="o">-</span> <span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span>
        <span class="k">if</span> <span class="nx">numRequests</span> <span class="p">&gt;</span> <span class="nx">numCanOpen</span> <span class="p">{</span> <span class="c1">// 连接请求超过限制，即最大打开连接数 - 已打开的连接数
</span><span class="c1"></span>            <span class="nx">numRequests</span> <span class="p">=</span> <span class="nx">numCanOpen</span> <span class="c1">// 以限制为准
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">numRequests</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span><span class="o">++</span> <span class="c1">// optimistically
</span><span class="c1"></span>        <span class="nx">numRequests</span><span class="o">--</span>
        <span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">openerCh</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// 告知 connectionOpener 打开新的连接，由 connectionOpener 执行打开连接的操作
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>也就是说，如果没有设置最大连接数，就不会有 connRequests，也不会触发 connectionOpener。调用 maybeOpenNewConnections 的时机包括：获取连接失败、连接被标记为 bad、关闭连接。因为正常情况下，打开的连接数是不变的，connRequests 只能等有连接释放的时候才能被满足。</p>
<h4 id="connectioncleaner">connectionCleaner</h4>
<p>以下逻辑实现连接的生命周期的管理，基本逻辑为：</p>
<p>定期遍历连接池中的每一个连接，检查其是存活时间是否超出了设定的maxLifetime，若超出则将它从池子中删除并关闭它</p>
<ul>
<li>用于定期清理连接池中闲散连接</li>
<li>如果没有设置 maxLifetime 则不会启动</li>
<li>在将连接放回连接池、设置连接最大存活时间的时候执行检查，符合条件则启动</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.
</span><span class="c1">//
</span><span class="c1">// Expired connections may be closed lazily before reuse.
</span><span class="c1">//
</span><span class="c1">// If d &lt;= 0, connections are not closed due to a connection&#39;s idle time.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">SetConnMaxIdleTime</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Wake cleaner up when idle time is shortened.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span> <span class="p">&lt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleTime</span> <span class="o">&amp;&amp;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleTime</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">startCleanerLocked</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// startCleanerLocked starts connectionCleaner if needed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">startCleanerLocked</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 尽管每次putConnDBLocked的时候都会被调用，但注意它的条件db.cleanerCh == nil
</span><span class="c1"></span>    <span class="c1">// 这意味着其实db.connectionCleaner只会被启动一次
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nx">db</span><span class="p">.</span><span class="nf">connectionCleaner</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
 <span class="c1">// 清理过期连接的逻辑
</span><span class="c1"></span> <span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">connectionCleaner</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">minInterval</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
    <span class="c1">// 精度最高为秒级
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">d</span> <span class="p">&lt;</span> <span class="nx">minInterval</span> <span class="p">{</span>
        <span class="nx">d</span> <span class="p">=</span> <span class="nx">minInterval</span>
    <span class="p">}</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 这个写法很有意思
</span><span class="c1"></span>        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span><span class="p">:</span> <span class="c1">// maxLifetime was changed or db was closed.
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="nx">d</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span>
        <span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">closed</span> <span class="o">||</span> <span class="nx">db</span><span class="p">.</span><span class="nx">numOpen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">db</span><span class="p">.</span><span class="nx">cleanerCh</span> <span class="p">=</span> <span class="kc">nil</span>
            <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">expiredSince</span> <span class="o">:=</span> <span class="nf">nowFunc</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">d</span><span class="p">)</span>
        <span class="kd">var</span> <span class="nx">closing</span> <span class="p">[]</span><span class="o">*</span><span class="nx">driverConn</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">c</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">createdAt</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">expiredSince</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">closing</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">closing</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
                <span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="c1">// 数组中经典的删除元素的方法
</span><span class="c1"></span>                <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
                <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
                <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
                <span class="c1">// 后退一步是为了可以检查刚刚置换过来的元素
</span><span class="c1"></span>                <span class="nx">i</span><span class="o">--</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetimeClosed</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">closing</span><span class="p">))</span>
        <span class="nx">db</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">closing</span> <span class="p">{</span>
            <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">d</span> <span class="p">&lt;</span> <span class="nx">minInterval</span> <span class="p">{</span>
            <span class="nx">d</span> <span class="p">=</span> <span class="nx">minInterval</span>
        <span class="p">}</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
      <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">connectionCleanerRunLocked</span><span class="p">()</span> <span class="p">(</span><span class="nx">closing</span> <span class="p">[]</span><span class="o">*</span><span class="nx">driverConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">expiredSince</span> <span class="o">:=</span> <span class="nf">nowFunc</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetime</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">createdAt</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">expiredSince</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">closing</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">closing</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
				<span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
				<span class="nx">i</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">maxLifetimeClosed</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">closing</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleTime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">expiredSince</span> <span class="o">:=</span> <span class="nf">nowFunc</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleTime</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">expiredCount</span> <span class="kt">int64</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleTime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">returnedAt</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">expiredSince</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">closing</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">closing</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
				<span class="nx">expiredCount</span><span class="o">++</span>
				<span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">freeConn</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
				<span class="nx">i</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">maxIdleTimeClosed</span> <span class="o">+=</span> <span class="nx">expiredCount</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="connectionresetter">connectionResetter</h4>
<p>connectionResetter:</p>
<ul>
<li>将连接放回连接池的时候检查，重置连接</li>
<li>连接池从逻辑上来说也是一个会话池，应当有类似重置会话的功能，避免把 bad connection 放回连接池</li>
<li>需要数据库驱动支持</li>
</ul>
<h2 id="curd">CURD</h2>
<h3 id="数据库查询">数据库查询</h3>
<p>我们了解了数据库连接与连接池。拿到了连接当然就是为了跟数据库交互。对于数据库交互，无怪乎两类操作，读和写。其中怎么读，怎么写，读和写的过程糅合一起就会遇到复杂的事务。本篇内容主要关注数据库的读写操作，后面再涉及事务的介绍。</p>
<h3 id="源码分析-1">源码分析</h3>
<h4 id="数据结构-1">数据结构</h4>
<p>一次Query查询会返回一个Rows对象，代表的是一个查询集合，里面是一行一行的记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Rows</span> <span class="kd">struct</span> <span class="p">{</span>
      <span class="nx">dc</span>          <span class="o">*</span><span class="nx">driverConn</span> <span class="c1">// owned; must call releaseConn when closed to release
</span><span class="c1"></span>      <span class="nx">releaseConn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>
      <span class="nx">rowsi</span>       <span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span>
      <span class="nx">cancel</span>      <span class="kd">func</span><span class="p">()</span>      <span class="c1">// called when Rows is closed, may be nil.
</span><span class="c1"></span>      <span class="nx">closeStmt</span>   <span class="o">*</span><span class="nx">driverStmt</span> <span class="c1">// if non-nil, statement to Close on close
</span><span class="c1"></span>
      <span class="c1">// closemu prevents Rows from closing while there
</span><span class="c1"></span>      <span class="c1">// is an active streaming result. It is held for read during non-close operations
</span><span class="c1"></span>      <span class="c1">// and exclusively during close.
</span><span class="c1"></span>      <span class="c1">//
</span><span class="c1"></span>      <span class="c1">// closemu guards lasterr and closed.
</span><span class="c1"></span>      <span class="nx">closemu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
      <span class="nx">closed</span>  <span class="kt">bool</span>
      <span class="nx">lasterr</span> <span class="kt">error</span> <span class="c1">// non-nil only if closed is true
</span><span class="c1"></span>
      <span class="c1">// lastcols is only used in Scan, Next, and NextResultSet which are expected
</span><span class="c1"></span>      <span class="c1">// not to be called concurrently.
</span><span class="c1"></span>      <span class="nx">lastcols</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="query">Query</h4>
<p>query方法逻辑很简单，通过db.conn方法返回一个新创建或者缓存的空闲连接。调用queryConn方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">query</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ci</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">conn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="c1">// 执行查询
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">queryConn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ci</span><span class="p">,</span> <span class="nx">ci</span><span class="p">.</span><span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// queryConn 执行查询
</span><span class="c1">// The connection gets released by the releaseConn function.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">queryConn</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">releaseConn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">),</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 判断驱动是否实现了Queryer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">queryer</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">ci</span><span class="p">.(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Queryer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">dargs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">driverArgs</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
        <span class="kd">var</span> <span class="nx">rowsi</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span>
        <span class="c1">// 调用驱动的查询方法
</span><span class="c1"></span>		<span class="nf">withLock</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">rowsi</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">ctxDriverQuery</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">queryer</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">dargs</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="c1">// 不带参数的返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrSkip</span> <span class="p">{</span>
            <span class="c1">// 说明用户没有要求用Prepared Statement
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="c1">// Note: ownership of dc passes to the *Rows, to be freed
</span><span class="c1"></span>            <span class="c1">// with releaseConn.
</span><span class="c1"></span>            <span class="c1">// 注意：这里将驱动返回的行信息rowsi在这里封装成了
</span><span class="c1"></span>            <span class="c1">// sql.Rows
</span><span class="c1"></span>			<span class="nx">rows</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Rows</span><span class="p">{</span>
				<span class="nx">dc</span><span class="p">:</span>          <span class="nx">dc</span><span class="p">,</span>
				<span class="nx">releaseConn</span><span class="p">:</span> <span class="nx">releaseConn</span><span class="p">,</span>
				<span class="nx">rowsi</span><span class="p">:</span>       <span class="nx">rowsi</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="nx">rows</span><span class="p">.</span><span class="nf">initContextClose</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// 如果驱动没有实现Queryer接口或者用户指定要使用Prepared Statement(返回了driver.ErrSkip），则使用Prepared Statement来做查询
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">si</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Stmt</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="c1">// 带参数的返回，创建prepare对象
</span><span class="c1"></span>	<span class="nf">withLock</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">si</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">ctxDriverPrepare</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">ci</span><span class="p">,</span> <span class="nx">query</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

    <span class="nx">ds</span> <span class="o">:=</span> <span class="nx">driverStmt</span><span class="p">{</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">si</span><span class="p">}</span>
    <span class="c1">// 执行语句
</span><span class="c1"></span>	<span class="nx">rowsi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">rowsiFromStatement</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ds</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">withLock</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">si</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">})</span>
		<span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// Note: ownership of ci passes to the *Rows, to be freed
</span><span class="c1"></span>	<span class="c1">// with releaseConn.
</span><span class="c1"></span>	<span class="nx">rows</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Rows</span><span class="p">{</span>
		<span class="nx">dc</span><span class="p">:</span>          <span class="nx">dc</span><span class="p">,</span>
		<span class="nx">releaseConn</span><span class="p">:</span> <span class="nx">releaseConn</span><span class="p">,</span>
		<span class="nx">rowsi</span><span class="p">:</span>       <span class="nx">rowsi</span><span class="p">,</span>
		<span class="nx">closeStmt</span><span class="p">:</span>   <span class="nx">si</span><span class="p">,</span>     <span class="c1">// close的时候，这个也需要关闭
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">rows</span><span class="p">.</span><span class="nf">initContextClose</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>queryConn函数内容比较多。先判断驱动是否实现了Queryer，如果实现了即调用其Query方法。方法会针对sql查询语句做查询。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ctxDriverQuery</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">queryerCtx</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">QueryerContext</span><span class="p">,</span> <span class="nx">queryer</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Queryer</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">nvdargs</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">NamedValue</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">queryerCtx</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">queryerCtx</span><span class="p">.</span><span class="nf">QueryContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">nvdargs</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">dargs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">namedValueToValue</span><span class="p">(</span><span class="nx">nvdargs</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
    <span class="c1">// 注意这里ctx的用法，根据ctx是否已被取消，提早返回
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 从这里以后就会到驱动的代码了
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">queryer</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">dargs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>例如mysql的驱动如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="kd">func</span> <span class="p">(</span><span class="nx">mc</span> <span class="o">*</span><span class="nx">mysqlConn</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
  <span class="p">}</span>

    <span class="kd">func</span> <span class="p">(</span><span class="nx">mc</span> <span class="o">*</span><span class="nx">mysqlConn</span><span class="p">)</span> <span class="nf">query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">textRows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">closed</span><span class="p">.</span><span class="nf">IsSet</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">errLog</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">ErrInvalidConn</span><span class="p">)</span>
          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
          <span class="c1">// 是否转义sql中的参数来防止sql注入
</span><span class="c1"></span>          <span class="c1">// 如果指定不转义的话会使用 prepared statement
</span><span class="c1"></span>          <span class="k">if</span> <span class="p">!</span><span class="nx">mc</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">InterpolateParams</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrSkip</span>
          <span class="p">}</span>
          <span class="c1">// try client-side prepare to reduce roundtrip
</span><span class="c1"></span>          <span class="nx">prepared</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">interpolateParams</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
          <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
          <span class="p">}</span>
          <span class="nx">query</span> <span class="p">=</span> <span class="nx">prepared</span>
      <span class="p">}</span>
      <span class="c1">// Send command
</span><span class="c1"></span>      <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">writeCommandPacketStr</span><span class="p">(</span><span class="nx">comQuery</span><span class="p">,</span> <span class="nx">query</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="c1">// Read Result
</span><span class="c1"></span>          <span class="kd">var</span> <span class="nx">resLen</span> <span class="kt">int</span>
          <span class="nx">resLen</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readResultSetHeaderPacket</span><span class="p">()</span>
          <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
              <span class="nx">rows</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">textRows</span><span class="p">)</span>
              <span class="nx">rows</span><span class="p">.</span><span class="nx">mc</span> <span class="p">=</span> <span class="nx">mc</span>

              <span class="k">if</span> <span class="nx">resLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                  <span class="nx">rows</span><span class="p">.</span><span class="nx">rs</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="kc">true</span>

                  <span class="k">switch</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">NextResultSet</span><span class="p">();</span> <span class="nx">err</span> <span class="p">{</span>
                  <span class="k">case</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="p">:</span>
                      <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="kc">nil</span>
                  <span class="k">default</span><span class="p">:</span>
                      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
                  <span class="p">}</span>
              <span class="p">}</span>

              <span class="c1">// Columns
</span><span class="c1"></span>              <span class="nx">rows</span><span class="p">.</span><span class="nx">rs</span><span class="p">.</span><span class="nx">columns</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readColumns</span><span class="p">(</span><span class="nx">resLen</span><span class="p">)</span>
              <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">markBadConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Query先检查参数是否为0，然后调用writeCommandPacketStr方法执行sql并通过readResultSetHeaderPacket读取数据库服务返回的结果。</p>
<p>如果参数不为0，会先判断是否是prepared语句。这里会返回一个driver.ErrSkip错误。把函数执行权再返回到queryConn函数中。然后再调用si, err = ctxDriverPrepare(ctx, dc.ci, query)创建Stmt对象.</p>
<p>在 database/sql 执行 QueryDC 逻辑时，会调用 ctxDriverPrepare 方法来进行 SQL Query 的预处理，我们来看看这段逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ctxDriverPrepare</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">ci</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ciCtx</span><span class="p">,</span> <span class="nx">is</span> <span class="o">:=</span> <span class="nx">ci</span><span class="p">.(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">ConnPrepareContext</span><span class="p">);</span> <span class="nx">is</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ciCtx</span><span class="p">.</span><span class="nf">PrepareContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">si</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ci</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">si</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">si</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在其中，ctxDriverPrepare 会调用 ci.Prepare(query) 来执行对应 SQL Driver 实现的 Prepare 或者 PrepareContext 方法来对 SQL 预处理，在 go-mysql-driver 中，对应的实现是这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mc</span> <span class="o">*</span><span class="nx">mysqlConn</span><span class="p">)</span> <span class="nf">PrepareContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">watchCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>
	<span class="nx">mc</span><span class="p">.</span><span class="nf">finish</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stmt</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这一段的逻辑是 go-mysql-driver 会向 MySQL 发起 prepared statement 请求，获取到对应的 Stmt 后将其返回</p>
<p>在 stmt 中包含了对应的参数数量，stmt name 等信息。在这里，SQL 会将 ? 等参数占位符进行解析，并告知客户端需要传入的参数数量</p>
<p>接下来调用rowsiFromStatement执行查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">rowsiFromStatement</span><span class="p">(</span><span class="nx">ds</span> <span class="nx">driverStmt</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">ds</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="nx">want</span> <span class="o">:=</span> <span class="nx">ds</span><span class="p">.</span><span class="nx">si</span><span class="p">.</span><span class="nf">NumInput</span><span class="p">()</span>
 <span class="nx">ds</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

 <span class="c1">// -1 means the driver doesn&#39;t know how to count the number of
</span><span class="c1"></span> <span class="c1">// placeholders, so we won&#39;t sanity check input here and instead let the
</span><span class="c1"></span> <span class="c1">// driver deal with errors.
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">want</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;sql: statement expects %d inputs; got %d&#34;</span><span class="p">,</span> <span class="nx">want</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">))</span>
 <span class="p">}</span>

 <span class="nx">dargs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">driverArgs</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ds</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">ds</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="nx">rowsi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ds</span><span class="p">.</span><span class="nx">si</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">dargs</span><span class="p">)</span>
 <span class="nx">ds</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">rowsi</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>rowsiFromStatement方法会调用驱动的ds.si.Query(dargs)方法，执行最后的查询。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">stmt</span> <span class="o">*</span><span class="nx">mysqlStmt</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">mc</span><span class="p">.</span><span class="nx">netConn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">errLog</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">ErrInvalidConn</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
 <span class="p">}</span>

 <span class="c1">// Send command
</span><span class="c1"></span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">writeExecutePacket</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">mc</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">mc</span>

 <span class="c1">// Read Result
</span><span class="c1"></span> <span class="nx">resLen</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readResultSetHeaderPacket</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">rows</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">binaryRows</span><span class="p">)</span>

 <span class="k">if</span> <span class="nx">resLen</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">rows</span><span class="p">.</span><span class="nx">mc</span> <span class="p">=</span> <span class="nx">mc</span>
  <span class="c1">// Columns
</span><span class="c1"></span>  <span class="c1">// If not cached, read them and cache them
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">columns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readColumns</span><span class="p">(</span><span class="nx">resLen</span><span class="p">)</span>
   <span class="nx">stmt</span><span class="p">.</span><span class="nx">columns</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">columns</span>
   <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readUntilEOF</span><span class="p">()</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 stmt和参数执行sql查询。查询完毕之后，返回到queryConn方法中，使用releaseConn释放查询的数据库连接。</p>
<p>Query返回的结果集是sql.Rows类型。它有一个Next方法，可以迭代数据库的游标，进而获取每一行的数据</p>
<h4 id="next">Next</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">doClose</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span>
      <span class="nf">withLock</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RLocker</span><span class="p">(),</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">doClose</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">nextLocked</span><span class="p">()</span>
      <span class="p">})</span>
      <span class="k">if</span> <span class="nx">doClose</span> <span class="p">{</span>
          <span class="nx">rs</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">ok</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">nextLocked</span><span class="p">()</span> <span class="p">(</span><span class="nx">doClose</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
      <span class="p">}</span>

      <span class="c1">// Lock the driver connection before calling the driver interface
</span><span class="c1"></span>      <span class="c1">// rowsi to prevent a Tx from rolling back the connection at the same time.
</span><span class="c1"></span>      <span class="nx">rs</span><span class="p">.</span><span class="nx">dc</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
      <span class="k">defer</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">dc</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

      <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()))</span>
      <span class="p">}</span>
      <span class="c1">// 从此进入驱动的代码
</span><span class="c1"></span>      <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="p">=</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="c1">// Close the connection if there is a driver error.
</span><span class="c1"></span>          <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
          <span class="p">}</span>
          <span class="nx">nextResultSet</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">RowsNextResultSet</span><span class="p">)</span>
          <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
          <span class="p">}</span>
          <span class="c1">// The driver is at the end of the current result set.
</span><span class="c1"></span>          <span class="c1">// Test to see if there is another result set after the current one.
</span><span class="c1"></span>          <span class="c1">// Only close Rows if there is no further result sets to read.
</span><span class="c1"></span>          <span class="k">if</span> <span class="p">!</span><span class="nx">nextResultSet</span><span class="p">.</span><span class="nf">HasNextResultSet</span><span class="p">()</span> <span class="p">{</span>
              <span class="nx">doClose</span> <span class="p">=</span> <span class="kc">true</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">doClose</span><span class="p">,</span> <span class="kc">false</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="c1">// mysql驱动的代码，位于rows.go中
</span><span class="c1"></span>  <span class="kd">func</span> <span class="p">(</span><span class="nx">rows</span> <span class="o">*</span><span class="nx">textRows</span><span class="p">)</span> <span class="nf">Next</span><span class="p">(</span><span class="nx">dest</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">mc</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nx">mc</span><span class="p">;</span> <span class="nx">mc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nb">error</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>

        <span class="c1">// Fetch next row from stream
</span><span class="c1"></span>        <span class="c1">// 这里会读取MySQL的查询结果
</span><span class="c1"></span>        <span class="c1">// 想了解MySQL的client与server间的交互协议的可以看这个函数
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">readRow</span><span class="p">(</span><span class="nx">dest</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="scan">Scan</h4>
<p>执行Next之后，会将从mysql读到的行数据保存在Rows对象的一个私有字段里(lastcols)，然后终于来到了Scan阶段</p>
<p>为Scan方法准备下一行结果，如果成功则返回true，而没有更多下一行或者错误发生时，则返回false</p>
<p>注意：每次调用Scan之前，必须先调用Next</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">dest</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
      <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>

      <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
          <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
          <span class="k">return</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
          <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">lasterrOrErrLocked</span><span class="p">(</span><span class="nx">errRowsClosed</span><span class="p">)</span>
          <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
          <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

      <span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;sql: Scan called without calling Next&#34;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;sql: expected %d destination arguments in Scan, not %d&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dest</span><span class="p">))</span>
      <span class="p">}</span>
      <span class="c1">// 遍历这一行的每一个字段
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lastcols</span> <span class="p">{</span>
          <span class="c1">// 转成Golang内部类型
</span><span class="c1"></span>          <span class="c1">// 对于数据库里的某个字段类型会被转成Golang里哪种类型
</span><span class="c1"></span>          <span class="c1">// 有疑问的可以看这个函数的实现
</span><span class="c1"></span>          <span class="nx">err</span> <span class="o">:=</span> <span class="nf">convertAssignRows</span><span class="p">(</span><span class="nx">dest</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">sv</span><span class="p">,</span> <span class="nx">rs</span><span class="p">)</span>
          <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">`sql: Scan error on column index %d, name %q: %v`</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">err</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="close">Close</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Close closes the Rows, preventing further enumeration. If Next is called
</span><span class="c1">// and returns false and there are no further result sets,
</span><span class="c1">// the Rows are closed automatically and it will suffice to check the
</span><span class="c1">// result of Err. Close is idempotent and does not affect the result of Err.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rs</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="o">*</span><span class="nx">Rows</span><span class="p">)</span> <span class="nb">close</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">lasterr</span> <span class="p">=</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nf">withLock</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">rowsi</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nf">rowsCloseHook</span><span class="p">();</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">(</span><span class="nx">rs</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">cancel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">closeStmt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rs</span><span class="p">.</span><span class="nx">closeStmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">rs</span><span class="p">.</span><span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读取数据">读取数据</h3>
<p>database/sql提供了Query和QueryRow方法进行查询数据库。对于Query方法的原理，正如前文介绍的主要分为三步：</p>
<ol>
<li>从连接池中请求一个连接</li>
<li>执行查询的sql语句</li>
<li>将数据库连接的所属权传递给Result结果集</li>
</ol>
<p>Query方法我们很熟悉了，它的内部调用了db.query方法，并且根据连接重连的状况选择是cachedOrNewConn模式还是alwaysNewConn模式。前者会从返回一个cached连接或者等待一个可用连接，甚至也可能建立一个新的连接；后者表示打开连接时的策略为每次建立一个新的连接。这就是所说的retry2次连接。</p>
<p>大概使用范式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found row containing %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码我们已经见过好多次了，想必大家都轻车熟路啦。rows.Next方法设计用来迭代。当它迭代到最后一行数据之后，会触发一个io.EOF的信号，即引发一个错误，同时go会自动调用rows.Close方法释放连接，然后返回false。此时循环将会结束退出。</p>
<p>通常你会正常迭代完数据然后退出循环。可是如果并没有正常的循环而因其他错误导致退出了循环。此时rows.Next处理结果集的过程并没有完成，归属于rows的连接不会被释放回到连接池。因此十分有必要正确的处理rows.Close事件。如果没有关闭rows连接，将导致大量的连接并且不会被其他函数重用，就像溢出了一样。最终将导致数据库无法使用。</p>
<p>那么如何阻止这样的行为呢？上述代码已经展示，无论循环是否完成或者因为其他原因退出，都显示的调用rows.Close方法，确保连接释放。又或者使用defer指令在函数退出的时候释放连接，即使连接已经释放了，rows.Close仍然可以调用多次，是无害的。</p>
<p>使用defer的时候需要注意，如果一个函数执行很长的逻辑，例如main函数，那么rows的连接释放就会也很长，好的实践方案是尽可能的越早释放连接。</p>
<p>rows.Next循环迭代的时候，因为触发了io.EOF而退出循环。为了检查是否是迭代正常退出还是异常退出，需要检查rows.Err。例如上面的代码应该改成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found row containing %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的几个部分很容易出错，可能会产生不良后果。</p>
<ul>
<li>你应该总是检查rows.Next()循环结尾处的错误。如果循环中出现错误，则需要了解它。不要仅仅假设循环遍历，直到你已经处理了所有的行。</li>
<li>第二，只要有一个打开的结果集(由行代表)，底层连接就很忙，不能用于任何其他查询。这意味着它在连接池中不可用。如果你使用rows.Next()遍历所有行，最终将读取最后一行，rows.Next()将遇到内部EOF错误，并为你调用rows.Close()。但是，如果由于某种原因退出该循环-提前返回，那么行不会关闭，并且连接保持打开状态。(如果rows.Next()由于错误而返回false，则会自动关闭)。这是一种简单耗尽资源的方法。</li>
<li>rows.Close()是一种无害的操作，如果它已经关闭，所以你可以多次调用它。但是请注意，我们首先检查错误，如果没有错误，则调用rows.Close()，以避免运行时的panic。</li>
<li>你应该总是用延迟语句defer推迟rows.Close()，即使你也在循环结束时调用rows.Close()，这不是一个坏主意。</li>
<li>不要在循环中用defer推迟。延迟语句在函数退出之前不会执行，所以长时间运行的函数不应该使用它。如果你这样做，你会慢慢积累记忆。如果你在循环中反复查询和使用结果集，则在完成每个结果后应显示的调用rows.Close()，而不用延迟语句defer。</li>
</ul>
<h3 id="读取单条记录">读取单条记录</h3>
<p>Query方法是读取多行结果集，实际开发中，很多查询只需要单条记录，不需要再通过Next迭代。golang提供了QueryRow方法用于查询单条记录的结果集。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello LIMIT 1&#34;</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">ErrNoRows</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;There is not row&#34;</span><span class="p">)</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;found a row&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>QueryRow方法的使用很简单，它要么返回sql.Row类型，要么返回一个error，如果是发送了错误，则会延迟到Scan调用结束后返回，如果没有错误，则Scan正常执行。只有当查询的结果为空的时候，会触发一个sql.ErrNoRows错误。</p>
<p>Scan在获取数据之前，会先调用Rows.Next来判断是否有记录，如果没有会返回ErrNowRows错误。其内部调用Rows.Scan方法获取数据。</p>
<p>如果结果集记录多于一条，则只返回第一条。并会调用Rows.Close来关闭。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Row</span><span class="p">)</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">dest</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// TODO(bradfitz): for now we need to defensively clone all
</span><span class="c1"></span>	<span class="c1">// []byte that the driver returned (not permitting
</span><span class="c1"></span>	<span class="c1">// *RawBytes in Rows.Scan), since we&#39;re about to close
</span><span class="c1"></span>	<span class="c1">// the Rows in our defer, when we return from this function.
</span><span class="c1"></span>	<span class="c1">// the contract with the driver.Next(...) interface is that it
</span><span class="c1"></span>	<span class="c1">// can return slices into read-only temporary memory that&#39;s
</span><span class="c1"></span>	<span class="c1">// only valid until the next Scan/Close. But the TODO is that
</span><span class="c1"></span>	<span class="c1">// for a lot of drivers, this copy will be unnecessary. We
</span><span class="c1"></span>	<span class="c1">// should provide an optional interface for drivers to
</span><span class="c1"></span>	<span class="c1">// implement to say, &#34;don&#39;t worry, the []bytes that I return
</span><span class="c1"></span>	<span class="c1">// from Next will not be modified again.&#34; (for instance, if
</span><span class="c1"></span>	<span class="c1">// they were obtained from the network anyway) But for now we
</span><span class="c1"></span>	<span class="c1">// don&#39;t care.
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dest</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dp</span><span class="p">.(</span><span class="o">*</span><span class="nx">RawBytes</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;sql: RawBytes isn&#39;t allowed on Row.Scan&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">rows</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">ErrNoRows</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="nx">dest</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="c1">// Make sure the query can be processed to completion with no errors.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你可以选择先检查错误再调用Scan方法，或者先调用Scan再检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果id为1的不存在，err为sql.ErrNoRows，一般应用中不存在的情况都需要单独处理。此外，Query返回的错误都会延迟到Scan被调用，所以应该写成如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">ErrNoRows</span> <span class="p">{</span>
        <span class="c1">// there were no rows, but otherwise no error occurred
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>把空结果当做Error处理是为了强行让程序员处理结果为空的情况</p>
<h3 id="字段转换">字段转换</h3>
<p>结果集方法Scan可以把数据库取出的字段值赋值给指定的数据结构。它的参数是一个空接口的切片，这就意味着可以传入任何值。通常把需要赋值的目标变量的指针当成参数传入，它能将数据库取出的值赋值到指针值对象上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">var1</span><span class="p">,</span> <span class="nx">var2</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">row</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">var1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">var2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在一些特殊案例中，如果你不想把值赋值给指定的目标变量，那么需要使用*sql.RawBytes类型。如何使用<em>sql.RawBytes需要参考更细的官方文档。大多数情况下我们不必这么做。但是还是需要注意在db.QueryRow().Scan()中不能使用</em>sql.RawBytes。</p>
<p>Scan还会帮我们自动推断除数据字段匹配目标变量。比如有个数据库字段的类型是VARCHAR，而他的值是一个数字串，例如&quot;1&quot;。如果我们定义目标变量是string，则scan赋值后目标变量是数字string。如果声明的目标变量是一个数字类型，那么scan会自动调用strconv.ParseInt()或者strconv.ParseInt()方法将字段转换成和声明的目标变量一致的类型。当然如果有些字段无法转换成功，则会返回错误。因此在调用scan后都需要检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="kt">int</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>此时scan会把字段转变成数字整型的赋值给world变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>此时scan取出的字段就是字串。同样的如果字段是int类型，声明的变量是string类型，scan也会自动将数字转换成字串赋值给目标变量。</p>
<p>但是scan仅支持为某一个变量赋值,不支持对结构体或map赋值,如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="kt">int</span>
    <span class="nx">name</span> <span class="kt">string</span>
    <span class="nx">weight</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="nx">rows</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from test where id = ?&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">line</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">{}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">line</span><span class="p">)</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">{0 0}
</code></pre></td></tr></table>
</div>
</div><p>SELECT * 这样做的习惯可不好，一般都是指定字段，这样在scan的时候也相对容易把握变量顺序和个数。scan必须指明所有字段并且顺序要符合查询时候的顺序,正确的做法应该是将line的每个变量分别赋值,而且要保证查询语句里的字段顺序和 struct的字段顺序是一致的，如果sql语句里简单的用＊代替，在sql表字段不变，但顺序改变的时候就会出错。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">line</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">line</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">line</span><span class="p">.</span><span class="nx">weight</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="空值处理">空值处理</h3>
<p>数据库有一个特殊的类型，NULL空值。可是NULL不能通过scan直接跟普遍变量赋值，甚至也不能将null赋值给nil。对于null必须指定特殊的类型，这些类型定义在database/sql库中。例如sql.NullFloat64。如果在标准库中找不到匹配的类型，可以尝试在驱动中寻找。下面是一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">s1</span> <span class="kt">string</span>
    <span class="nx">s2</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">NullString</span>
    <span class="nx">i1</span> <span class="kt">int</span>
    <span class="nx">f1</span> <span class="kt">float64</span>
    <span class="nx">f2</span> <span class="kt">float64</span>
<span class="p">)</span>
<span class="c1">// 假设数据库的记录为 [&#34;hello&#34;, NULL, 12345, &#34;12345.6789&#34;, &#34;not-a-float&#34;]
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f2</span><span class="p">)</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为最后一个f2字段的值不是float，这会引发一个错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">sql</span><span class="o">:</span> <span class="n">Scan</span> <span class="n">error</span> <span class="n">on</span> <span class="n">column</span> <span class="n">index</span> <span class="m">4</span><span class="o">:</span> <span class="n">converting</span> <span class="n">string</span> <span class="s">&#34;not-a- oat&#34;</span> <span class="n">to</span> <span class="n">a</span>  <span class="n">oat64</span><span class="o">:</span> <span class="n">strconv.ParseFloat</span><span class="o">:</span> <span class="n">parsing</span> <span class="s">&#34;not-a- oat&#34;</span><span class="o">:</span> <span class="n">invalid</span> <span class="n">syntax</span>
</code></pre></td></tr></table>
</div>
</div><p>如果忽略err，强行读取目标变量，可以看到最后一个值转换错误会处理，而不是抛出异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f2</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q %#v %d %f %f&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="nx">i1</span><span class="p">,</span> <span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span><span class="p">)</span>

<span class="c1">// 输出 &#34;hello&#34;  sql.NullString{String:&#34;&#34;, Valid:false} 12345 12345.678900 0.000000
</span></code></pre></td></tr></table>
</div>
</div><p>可以看到，除了最后一个转换失败变成了零值之外，其他都正常的取出了值，尤其是null匹配了NullString类型的目标变量。</p>
<p>对于null的操作，通常仍然需要验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">NullString</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT world FROM hello WHERE id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">if</span> <span class="nx">world</span><span class="p">.</span><span class="nx">Valid</span> <span class="p">{</span>
      <span class="nx">wrold</span><span class="p">.</span><span class="nx">String</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 数据库的value是不是null的时候，输出 world的字符串值， 空字符串
</span><span class="c1"></span>    <span class="nx">world</span><span class="p">.</span><span class="nx">String</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对应的，如果world字段是一个int，那么声明的目标变量类似是sql.NullInt64，读取其值的方法为world.Int64。</p>
<p>但是有时候我们并不关心值是不是Null,我们只需要把他当一个空字符串来对待就行。这时候我们可以使用[]byte（null byte[]可以转化为空string）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT world FROM hello WHERE id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span>
<span class="o">...</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">real_name</span><span class="p">))</span> <span class="c1">// 有值则取出字串值，null则转换成 空字串。
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><h3 id="自动匹配字段">自动匹配字段</h3>
<p>在执行查询的时候，我们定义了目标变量，同时查询的时候也写明了字段，如果不指名字段，或者字段的顺序和查询的不一样，都有可能出错。因此如果能够自动匹配查询的字段值，将会十分节省代码，同时也易于维护。</p>
<p>go提供了Columns方法用获取字段名，与大多数函数一样，读取失败将会返回一个err，因此需要检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">cols</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">er</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于不定字段查询，我们可以定义一个map的key和value用来表示数据库一条记录的row的值。通过rows.Columns得到的col作为map的key值。下面是一个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = 1&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>


    <span class="nx">cols</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cols</span><span class="p">)</span>
    <span class="nx">vals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cols</span><span class="p">))</span>
    <span class="nx">scans</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cols</span><span class="p">))</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span><span class="p">{</span>
        <span class="nx">scans</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">results</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="nx">scans</span><span class="o">...</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">row</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span><span class="p">{</span>
            <span class="nx">key</span> <span class="o">:=</span> <span class="nx">cols</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
            <span class="nx">row</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">results</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span><span class="k">range</span> <span class="nx">results</span><span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>数据表user有三个字段，id（int），gid（int），real_name（varchar）。我们使用*取出所有的字段。使用rows.Columns()获取字段名，是一个string的数组。然后创建一个切片vals，用来存放所取出来的数据结果，类似是byte的切片。接下来还需要定义一个切片，这个切片用来scan，将数据库的值复制到给它。</p>
<p>完成这一步之后，vals则得到了scan复制给他的值，因为是byte的切片，因此在循环一次，将其转换成string即可。</p>
<p>转换后的row即我们取出的数据行值，最后组装到result切片中。</p>
<p>运行结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">[</span><span class="nx">id</span> <span class="nx">gid</span> <span class="nx">real_name</span><span class="p">]</span>
<span class="mi">0</span> <span class="kd">map</span><span class="p">[</span><span class="nx">id</span><span class="p">:</span><span class="mi">4</span> <span class="nx">gid</span><span class="p">:</span><span class="mi">1</span> <span class="nx">real_name</span><span class="p">:</span><span class="nx">瑟兰督依</span><span class="p">]</span>
<span class="mi">1</span> <span class="kd">map</span><span class="p">[</span><span class="nx">real_name</span><span class="p">:</span><span class="nx">来格拉斯</span> <span class="nx">id</span><span class="p">:</span><span class="mi">5</span> <span class="nx">gid</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span> <span class="kd">map</span><span class="p">[</span><span class="nx">id</span><span class="p">:</span><span class="mi">15</span> <span class="nx">gid</span><span class="p">:</span><span class="mi">1</span> <span class="nx">real_name</span><span class="p">:]</span>
</code></pre></td></tr></table>
</div>
</div><p>有一条记录的 real_name 值为空字串，因为其数据库存储的是NULL。</p>
<h3 id="exec">Exec</h3>
<p>前面介绍了很多关于查询方面的内容，查询是读方便的内容，对于写，即插入更新和删除。这类操作与query不太一样，写的操作只关系是否写成功了。database/sql提供了Exec方法用于执行写的操作。</p>
<p>我们也见识到了，Eexc返回一个sql.Result类型，它有两个方法LastInsertId和RowsAffected。LastInsertId返回是一个数据库自增的id，这是一个int64类型的值。</p>
<p>Exec执行完毕之后，连接会立即释放回到连接池中，因此不需要像query那样再手动调用row的close方法。</p>
<p>使用Exec()，最好用一个准备好的statement来完成INSERT,UPDATE,DELETE或者其他不返回行的语句。下面的示例演示如何插入行并检查有关操作的元数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT INTO users(name) VALUES(?)&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;Dolly&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">lastId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">LastInsertId</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">rowCnt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;ID = %d, affected = %d\n&#34;</span><span class="p">,</span> <span class="nx">lastId</span><span class="p">,</span> <span class="nx">rowCnt</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>执行该语句将生成一个sql.Result，该语句提供对statement元数据的访问：最后插入的ID和行数受到影响。</p>
<p>如果你不在乎结果怎么办？如果你只想执行一个语句并检查是否有错误，但忽略结果该怎么办？下面两个语句不会做同样的事情吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;DELETE FROM users&#34;</span><span class="p">)</span>  <span class="c1">// OK
</span><span class="c1"></span><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;DELETE FROM users&#34;</span><span class="p">)</span> <span class="c1">// BAD
</span></code></pre></td></tr></table>
</div>
</div><p>虽然用_忽略了返回值,但文件描述符(磁盘io或网络io)需要手动关闭，GC并不会自动处理</p>
<p>答案是否定的。他们不做同样的事情，你不应该使用Query()。Query()将返回一个sql.Rows，它保留数据库连接，直到sql.Rows关闭。由于可能有未读数据(例如更多的数据行)，所以不能使用连接。在上面的示例中，连接将永远不会被释放。垃圾回收器最终会关闭底层的net.Conn，但这可能需要很长时间。此外，database/sql包将继续跟踪池中的连接，希望在某个时候释放它，以便可以再次使用连接。因此，这种反模式是耗尽资源的好方法(例如连接数太多)。</p>
<h3 id="总结">总结</h3>
<p>目前，我们大致了解了数据库的CURD操作。对于读的操作，需要定义目标变量才能scan数据记录。scan会智能的帮我们转换一些数据，取决于定义的目标变量类型。对于null的处理，可以使用database/sql或驱动提供的类型声明，也可以使用[]byte将其转换成空字串。除了读数据之外，对于写的操作，database/sql也提供了Exec方法，并且对于sql.Result提供了LastInsertId和RowsAffected方法用于获取写后的结果。</p>
<p>在实际应用中，与数据库交互，往往写的sql语句还带有参数，这类sql可以称之为prepare语句。prepare语句有很多好处，可以防止sql注入，可以批量执行等。但是prepare的连接管理有其自己的机制，也有其使用上的陷阱，关于prepare的使用，我们将会在以后讨论。</p>
<h2 id="prepare">Prepare</h2>
<h3 id="prepare-1">prepare</h3>
<p>前面我们已经学习了sql的基本curd操作。总体而言，有两类操作Query和Exec。前者返回数据库记录，后者返回数据库影响或插入相关的结果。上面两种操作，多数是针对单次操作的查询。如果需要批量插入一堆数据，就可以使用Prepared语句。golang处理prepared语句有其独特的行为，了解其底层的实现，对于用好它十分重要。</p>
<p>所谓prepared，即带有占位符的sql语句，客户端将该语句和参数发给mysql服务器。mysql服务器编译成一个prepared语句，这个语句可以根据不同的参数多次调用。prepared语句执行的方式如下：</p>
<ol>
<li>准备prepare语句</li>
<li>执行prepared语句和参数</li>
<li>关闭prepared语句</li>
</ol>
<p>之所以会出现prepare语句方式，主要因为这样有下面的两个好处：</p>
<ol>
<li>避免通过引号组装拼接sql语句。避免sql注入带来的安全风险</li>
<li>可以多次执行的sql语句。</li>
</ol>
<p>这里需要注意一点的是，Prepared Statement 存在 Session 限制，一般情况下一个 Prepared Statement 仅存活于它被创建的 Session 。当连接断开，者在其余情况下 Session 失效的时候，Prepared Statement 会自动被销毁。</p>
<h3 id="参数占位符语法">参数占位符语法</h3>
<p>预处理语句中的占位符参数的语法是特定于数据库的。例如，比较MySql,PostgreSQL,Oracle：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">MySQL</span>               <span class="nx">PostgreSQL</span>            <span class="nx">Oracle</span>
<span class="o">====</span><span class="p">=</span>               <span class="o">==========</span>            <span class="o">======</span>
<span class="nx">WHERE</span> <span class="nx">col</span> <span class="p">=</span> <span class="err">?</span>       <span class="nx">WHERE</span> <span class="nx">col</span> <span class="p">=</span> <span class="err">$</span><span class="mi">1</span>        <span class="nx">WHERE</span> <span class="nx">col</span> <span class="p">=</span> <span class="p">:</span><span class="nx">col</span>
<span class="nf">VALUES</span><span class="p">(</span><span class="err">?</span><span class="p">,</span> <span class="err">?</span><span class="p">,</span> <span class="err">?</span><span class="p">)</span>     <span class="nf">VALUES</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">)</span>    <span class="nf">VALUES</span><span class="p">(:</span><span class="nx">val1</span><span class="p">,</span> <span class="p">:</span><span class="nx">val2</span><span class="p">,</span> <span class="p">:</span><span class="nx">val3</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="dbquery">db.Query</h3>
<p>我们可以使用Query方式查询记录，Query函数提供了两种选择，第一种情况下参数是拼接好的sql，另外一种情况，第一参数是带有占位符的sql，第二个参数为sql的实际参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = 1&#34;</span><span class="p">)</span>

<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面两种方式都能获取数据，那么他们的底层实现是一样的么？实际上，上面两种方式的底层通信不完全一样。一种是plaintext方式，另外一种是prepared方式。</p>
<h3 id="dbprepare">db.Prepare</h3>
<p>在数据库级别，将准备好的语句绑定到单个数据库连接。典型的流程是：客户端向服务器发送带有占位符的SQL语句以进行准备，服务器使用语句ID进行响应，然后客户端通过发送其ID和参数来执行该语句。</p>
<p>然而在Golang中，连接不会直接暴露给database/sql包的用户。你不准备连接上语句。你准备好在一个db或tx。并且database/sql具有一些便捷的行为，如自动重试。由于这些原因，准备好的语句和连接(存在于驱动级别)之间的潜在关联被隐藏在代码中。</p>
<p>下面是它的工作原理：</p>
<ol>
<li>准备一个语句时，它会在池中的连接上准备好。</li>
<li>Stmt对象记住使用哪个连接。</li>
<li>当你执行Stmt时，它试图使用Stmt对象记住的那个连接(后面我们将这里的连接称为原始连接)。如果它不可用，因为它关闭或忙于做其他事情，它从池中获取另一个连接，并在另一个连接上重新准备与数据库的语句。</li>
</ol>
<p>因为在原始连接繁忙时将根据需要重新准备语句，所以数据库的高并发使用可能会使很多连接繁忙，从而创建大量预准备语句。这可能导致语句的明显泄漏，正在准备和重新准备的语句比您想象的更频繁，甚至在语句数量上遇到服务器端限制。</p>
<p>从query查询可以看到，对于占位符的prepare语句，go内部会自动创建一个 stmt对象。其实我们也可以自定义stmt语句，使用方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = ?&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

 <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span>  <span class="nx">stmt</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>即通过Prepare方法创建一个stmt对象，然后执行stmt对象的Query（Exec）方法得到sql.Rows结果集。最后关闭stmt.Close。这个过程就和之前所说的prepare三步骤匹配了。</p>
<p>创建stmt的prepare方式是golang的一个设计，其目的是Prepare once, execute many times。为了批量执行sql语句。但是通常会造成所谓的三次网络请求（ three network round-trips）。即preparing executing和closing三次请求。</p>
<p>对于大多数数据库，prepread的过程都是，先发送一个带占位符的sql语句到服务器，服务器返回一个statement id，然后再把这个id和参数发送给服务器执行，最后再发送关闭statement命令。</p>
<p>golang的实现了连接池，处理prepare方式也需要特别注意。调用Prepare方法返回stmt的时候，golang会在某个空闲的连接上进行prepare语句，然后就把连接释放回到连接池，可是golang会记住这个连接，当需要执行参数的时候，就再次找到之前记住的连接进行执行，等到stmt.Close调用的时候，再释放该连接。</p>
<p>在执行参数的时候，如果记住的连接正处于忙碌阶段，此时golang将会从新选一个新的空闲连接进行prepare（re-prepare）。当然，即使是重新reprepare，同样也会遇到刚才的问题。那么将会一而再再而三的进行reprepare。直到找到空闲连接进行查询的时候。</p>
<p>这种情况将会导致leak连接的情况，尤其是高并发的情景。将会导致大量的prepare过程。因此使用stmt的情况需要仔细考虑应用场景，通常在应用程序中。多次执行同一个sql语句的情况并不多，因此减少prepare语句的使用。</p>
<p>之前有一个疑问，是不是所有sql语句都不能带占位符，因为这是prepare语句。只要看了一遍database/sql和驱动的源码才恍然大悟，对于query(prepare, args)的方式，正如我们前面所分析的，database/sql会使用si, err = ctxDriverPrepare(ctx, dc.ci, query)创建stmt的，然后就立即执行prepare和参数，最后关闭stmt。整个过程都是同一个连接上完成，因此不存在reprepare的情况。当然也无法使用所谓的创建一次，执行多次的方式。</p>
<p>对于prepare的使用方式，目前需要注意的大致就是：</p>
<ol>
<li>
<p>单次查询不需要使用prepared，每次使用stmt语句都是三次网络请求次数，prepared execute close</p>
</li>
<li>
<p>不要循环中创建prepare语句</p>
</li>
<li>
<p>注意关闭 stmt</p>
</li>
</ol>
<p>如果不是批量的操作，是没必要使用db.Papare方法的，否则即多了Stmt创建和关闭的性能开销，又多写了两行代码，有点得不偿失。如果是批量的操作，那么毋庸置疑，肯定是db.Papare拿到Stmt，再由Stmt去执行sql，这样保证批量操作只进行一次预处理。</p>
<p>尽管会有reprepare过程，这些操作依然是database/sql帮我们所做的，与连接retry2次一样，开发者无需担心。</p>
<p>对于Qeruy操作如此，同理Exec操作也一样。</p>
<h3 id="源码分析-2">源码分析</h3>
<h4 id="stmt">Stmt</h4>
<p>数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="c1">// Stmt is a prepared statement.
</span><span class="c1"></span>  <span class="c1">// A Stmt is safe for concurrent use by multiple goroutines.
</span><span class="c1"></span>  <span class="c1">//
</span><span class="c1"></span>  <span class="c1">// If a Stmt is prepared on a Tx or Conn, it will be bound to a single
</span><span class="c1"></span>  <span class="c1">// underlying connection forever. If the Tx or Conn closes, the Stmt will
</span><span class="c1"></span>  <span class="c1">// become unusable and all operations will return an error.
</span><span class="c1"></span>  <span class="c1">// If a Stmt is prepared on a DB, it will remain usable for the lifetime of the
</span><span class="c1"></span>  <span class="c1">// DB. When the Stmt needs to execute on a new underlying connection, it will
</span><span class="c1"></span>  <span class="c1">// prepare itself on the new connection automatically.
</span><span class="c1"></span>  <span class="kd">type</span> <span class="nx">Stmt</span> <span class="kd">struct</span> <span class="p">{</span>
      <span class="c1">// Immutable:
</span><span class="c1"></span>      <span class="nx">db</span>        <span class="o">*</span><span class="nx">DB</span>    <span class="c1">// where we came from
</span><span class="c1"></span>      <span class="nx">query</span>     <span class="kt">string</span> <span class="c1">// that created the Stmt
</span><span class="c1"></span>      <span class="nx">stickyErr</span> <span class="kt">error</span>  <span class="c1">// if non-nil, this error is returned for all operations
</span><span class="c1"></span>
      <span class="nx">closemu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// held exclusively during close, for read otherwise.
</span><span class="c1"></span>
      <span class="c1">// If Stmt is prepared on a Tx or Conn then cg is present and will
</span><span class="c1"></span>      <span class="c1">// only ever grab a connection from cg.
</span><span class="c1"></span>      <span class="c1">// If cg is nil then the Stmt must grab an arbitrary connection
</span><span class="c1"></span>      <span class="c1">// from db and determine if it must prepare the stmt again by
</span><span class="c1"></span>      <span class="c1">// inspecting css.
</span><span class="c1"></span>      <span class="nx">cg</span>   <span class="nx">stmtConnGrabber</span>
      <span class="nx">cgds</span> <span class="o">*</span><span class="nx">driverStmt</span>

      <span class="c1">// parentStmt is set when a transaction-specific statement
</span><span class="c1"></span>      <span class="c1">// is requested from an identical statement prepared on the same
</span><span class="c1"></span>      <span class="c1">// conn. parentStmt is used to track the dependency of this statement
</span><span class="c1"></span>      <span class="c1">// on its originating (&#34;parent&#34;) statement so that parentStmt may
</span><span class="c1"></span>      <span class="c1">// be closed by the user without them having to know whether or not
</span><span class="c1"></span>      <span class="c1">// any transactions are still using it.
</span><span class="c1"></span>      <span class="nx">parentStmt</span> <span class="o">*</span><span class="nx">Stmt</span>

      <span class="nx">mu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// protects the rest of the fields
</span><span class="c1"></span>      <span class="nx">closed</span> <span class="kt">bool</span>

      <span class="c1">// css is a list of underlying driver statement interfaces
</span><span class="c1"></span>      <span class="c1">// that are valid on particular connections. This is only
</span><span class="c1"></span>      <span class="c1">// used if cg == nil and one is found that has idle
</span><span class="c1"></span>      <span class="c1">// connections. If cg != nil, cgds is always used.
</span><span class="c1"></span>      <span class="nx">css</span> <span class="p">[]</span><span class="nx">connStmt</span>

      <span class="c1">// lastNumClosed is copied from db.numClosed when Stmt is created
</span><span class="c1"></span>      <span class="c1">// without tx and closed connections in css are removed.
</span><span class="c1"></span>      <span class="nx">lastNumClosed</span> <span class="kt">uint64</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// connStmt is a prepared statement on a particular connection.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">connStmt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span>
	<span class="nx">ds</span> <span class="o">*</span><span class="nx">driverStmt</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="准备阶段">准备阶段</h4>
<p>准备阶段，分别可以从DB、Conn和Tx上发起Prepare，先分析在DB上的Prepare</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Prepare creates a prepared statement for later queries or executions.
</span><span class="c1">// Multiple queries or executions may be run concurrently from the
</span><span class="c1">// returned statement.
</span><span class="c1">// The caller must call the statement&#39;s Close method
</span><span class="c1">// when the statement is no longer needed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Prepare</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">PrepareContext</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">query</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PrepareContext creates a prepared statement for later queries or executions.
</span><span class="c1">// Multiple queries or executions may be run concurrently from the
</span><span class="c1">// returned statement.
</span><span class="c1">// The caller must call the statement&#39;s Close method
</span><span class="c1">// when the statement is no longer needed.
</span><span class="c1">//
</span><span class="c1">// The provided context is used for the preparation of the statement, not for the
</span><span class="c1">// execution of the statement.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">PrepareContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">stmt</span> <span class="o">*</span><span class="nx">Stmt</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maxBadConnRetries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 从连接池中尝试获取连接
</span><span class="c1"></span>		<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">prepare</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">cachedOrNewConn</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">prepare</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">alwaysNewConn</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">prepare</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: check if db.driver supports an optional
</span><span class="c1"></span>	<span class="c1">// driver.Preparer interface and call that instead, if so,
</span><span class="c1"></span>	<span class="c1">// otherwise we make a prepared statement that&#39;s bound
</span><span class="c1"></span>	<span class="c1">// to a connection, and to execute this prepared statement
</span><span class="c1"></span>	<span class="c1">// we either need to use this connection (if it&#39;s free), else
</span><span class="c1"></span>    <span class="c1">// get a new connection + re-prepare + execute on that one.
</span><span class="c1"></span>    <span class="c1">// 先从池子中获取一个连接
</span><span class="c1"></span>	<span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">conn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">si</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Stmt</span>
	<span class="nf">withLock</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 这里是调用驱动来向server发起Prepare命令
</span><span class="c1"></span>		<span class="nx">si</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">dc</span><span class="p">.</span><span class="nf">prepareLocked</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nf">putConn</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">stmt</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Stmt</span><span class="p">{</span>
		<span class="nx">db</span><span class="p">:</span>            <span class="nx">db</span><span class="p">,</span>
		<span class="nx">query</span><span class="p">:</span>         <span class="nx">query</span><span class="p">,</span>
		<span class="nx">css</span><span class="p">:</span>           <span class="p">[]</span><span class="nx">connStmt</span><span class="p">{{</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">si</span><span class="p">}},</span>
		<span class="nx">lastNumClosed</span><span class="p">:</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">db</span><span class="p">.</span><span class="nx">numClosed</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="c1">// 记住这个stmt是在哪个conn上Prepare的，便于后续exec时再继续用
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nf">addDep</span><span class="p">(</span><span class="nx">stmt</span><span class="p">,</span> <span class="nx">stmt</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">putConn</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">stmt</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="执行阶段">执行阶段</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">ExecContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
      <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

      <span class="kd">var</span> <span class="nx">res</span> <span class="nx">Result</span>
      <span class="nx">strategy</span> <span class="o">:=</span> <span class="nx">cachedOrNewConn</span>
      <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maxBadConnRetries</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">maxBadConnRetries</span> <span class="p">{</span>
              <span class="nx">strategy</span> <span class="p">=</span> <span class="nx">alwaysNewConn</span>
          <span class="p">}</span>
          <span class="c1">// 这里是尝试取回当时进行Prepare的连接以待继续操作
</span><span class="c1"></span>          <span class="nx">dc</span><span class="p">,</span> <span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">ds</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">connStmt</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">)</span>
          <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
              <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
                  <span class="k">continue</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
          <span class="p">}</span>
          <span class="c1">// 从驱动读取执行结果
</span><span class="c1"></span>          <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">resultFromStatement</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">ci</span><span class="p">,</span> <span class="nx">ds</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
          <span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
          <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Stmt在执行Exec和Query等方法时，会先执行connStmt方法</p>
<p>拿到type connStmt struct中的driverConn和driver.Stmt，再由resultFromStatement方法去做具体的数据库操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">connStmt</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">releaseConn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">),</span> <span class="nx">ds</span> <span class="o">*</span><span class="nx">driverStmt</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">stickyErr</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span>
      <span class="p">}</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
      <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
          <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
          <span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;sql: statement is closed&#34;</span><span class="p">)</span>
          <span class="k">return</span>
      <span class="p">}</span>

      <span class="c1">// In a transaction or connection, we always use the connection that the
</span><span class="c1"></span>      <span class="c1">// stmt was created on.
</span><span class="c1"></span>      <span class="c1">// 在Tx或者Conn上Prepare的情况
</span><span class="c1"></span>      <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
          <span class="nx">dc</span><span class="p">,</span> <span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cg</span><span class="p">.</span><span class="nf">grabConn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="c1">// blocks, waiting for the connection.
</span><span class="c1"></span>          <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
              <span class="k">return</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">dc</span><span class="p">,</span> <span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cgds</span><span class="p">,</span> <span class="kc">nil</span>
      <span class="p">}</span>

      <span class="nx">s</span><span class="p">.</span><span class="nf">removeClosedStmtLocked</span><span class="p">()</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
      <span class="c1">// 以下是在DB上Prepare时的处理逻辑
</span><span class="c1"></span>      <span class="c1">// 直接从池子里遍历取连接，
</span><span class="c1"></span>      <span class="c1">// 然后判断这个连接是不是之前prepare过，
</span><span class="c1"></span>      <span class="c1">// 若prepare过，则直接返回这个连接即可，
</span><span class="c1"></span>      <span class="c1">// 若没有，则直接重新prepare后再返回
</span><span class="c1"></span>      <span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">conn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
      <span class="p">}</span>

      <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">css</span> <span class="p">{</span>
          <span class="c1">// css是type connStmt的一个slice：css []connStm
</span><span class="c1"></span>          <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">dc</span> <span class="o">==</span> <span class="nx">dc</span> <span class="p">{</span>
              <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
              <span class="k">return</span> <span class="nx">dc</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ds</span><span class="p">,</span> <span class="kc">nil</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

      <span class="c1">// No luck; we need to prepare the statement on this connection
</span><span class="c1"></span>      <span class="nf">withLock</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">ds</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">prepareOnConnLocked</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">dc</span><span class="p">)</span>
      <span class="p">})</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="nx">dc</span><span class="p">.</span><span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
          <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nx">dc</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">ds</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="关闭阶段">关闭阶段</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="c1">// Close closes the statement.
</span><span class="c1"></span>  <span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stmt</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
      <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

      <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">stickyErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">stickyErr</span>
      <span class="p">}</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
      <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
          <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
          <span class="k">return</span> <span class="kc">nil</span>
      <span class="p">}</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>
      <span class="nx">txds</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cgds</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">cgds</span> <span class="p">=</span> <span class="kc">nil</span>

      <span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

      <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">removeDep</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">parentStmt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="c1">// If parentStmt is set, we must not close s.txds since it&#39;s stored
</span><span class="c1"></span>          <span class="c1">// in the css array of the parentStmt.
</span><span class="c1"></span>          <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">removeDep</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">parentStmt</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="c1">// txds是驱动端的stmt，最终调了驱动端的Close来关闭
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">txds</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="总结-1">总结</h3>
<p>目前我们学习database/sql提供两类查询操作，Query和Exec方法。他们都可以使用plaintext和preprea方式查询。对于后者，可以有效的避免数据库注入。而prepare方式又可以有显示的声明stmt对象，也有隐藏的方式。显示的创建stmt会有3次网络请求，创建-&gt;执行-&gt;关闭，再批量操作可以考虑这种做法，另外一种方式创建prepare后就执行，因此不会因为reprepare导致高并发下的leak连接问题。</p>
<p>具体使用那种方式，还得基于应用场景，安全过滤和连接管理等考虑。至此，关于查询和执行操作已经介绍了很多。关系型数据库的另外一个特性就是关系和事务处理。下一节，我们将会讨论database/sql的数据库事务功能。</p>
<h2 id="transaction">Transaction</h2>
<p>事务处理是数据的重要特性。尤其是对于一些支付系统，事务保证性对业务逻辑会有重要影响。golang的mysql驱动也封装好了事务相关的操作。我们已经学习了db的Query和Exec方法处理查询和修改数据库。</p>
<h3 id="tx对象">tx对象</h3>
<p>一般查询使用的是db对象的方法，事务则是使用另外一个对象。sql.Tx对象。使用db的Begin方法可以创建tx对象。tx对象也有数据库交互的Query,Exec和Prepare方法。用法和db的相关用法类似。查询或修改的操作完毕之后，需要调用tx对象的Commit提交或者Rollback方法回滚。</p>
<p>一旦创建了tx对象，事务处理都依赖与tx对象，这个对象会从连接池中取出一个空闲的连接，接下来的sql执行都基于这个连接，直到commit或者rollback调用之后，才会把连接释放到连接池。</p>
<p>在事务处理的时候，不能使用db的查询方法，虽然后者可以获取数据，可是这不属于同一个事务处理，将不会接受commit和rollback的改变，一个简单的事务例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query1</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query2</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>在tx中使用db是错误的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query1</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query2</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码在调用db的Eexc方法的时候，tx会绑定连接到事务中，db则是额外的一个连接，两者不是同一个事务。需要注意，Begin和Commit方法，与sql语句中的BEGIN或COMMIT语句没有关系。</p>
<h3 id="事务与连接">事务与连接</h3>
<p>创建Tx对象的时候，会从连接池中取出连接，然后调用相关的Exec方法的时候，连接仍然会绑定在改事务处理中。在实际的事务处理中，go可能创建不同的连接，但是那些其他连接都不属于该事务。例如上面例子中db创建的连接和tx的连接就不是一回事。</p>
<p>事务的连接生命周期从Beigin函数调用起，直到Commit和Rollback函数的调用结束。事务也提供了prepare语句的使用方式，但是需要使用Tx.Stmt方法创建。prepare设计的初衷是多次执行，对于事务，有可能需要多次执行同一个sql。然而无论是正常的prepare和事务处理，prepare对于连接的管理都有点小复杂。因此尽量避免在事务中使用prepare方式。例如下面例子就容易导致错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
<span class="nx">stmt</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT ...&#34;</span><span class="p">)</span>
<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>因为stmt.Close使用defer语句，即函数退出的时候再清理stmt，可是实际执行过程的时候，tx.Commit就已经释放了连接。当函数退出的时候，再执行stmt.Close的时候，连接可能有被使用了。</p>
<p>你不应该在SQL代码中混合BEGIN和COMMIT相关的函数(如Begin()和Commit()的SQL语句)，可能会导致悲剧：</p>
<ul>
<li>Tx对象可以保持打开状态，从池中保留连接而不返回。</li>
<li>数据库的状态可能与代表它的Golang变量的状态不同步。</li>
<li>你可能会认为你是在事务内部的单个连接上执行查询，实际上Golang已经为你创建了几个连接，而且一些语句不是事务的一部分。</li>
</ul>
<p>当你在事务中工作时，你应该注意不要对Db变量进行调用。应当使用db.Begin()创建的Tx变量进行所有调用。Db不在一个事务中，只有Tx是。如果你进一步调用db.Exec()或类似的函数，那么这些调用将发生在事务范围之外，是在其他的连接上。</p>
<p>如果你需要处理修改连接状态的多个语句，即使你不希望事务本身，也需要一个Tx。例如：</p>
<ul>
<li>创建仅在一个连接中可见的临时表。</li>
<li>设置变量，如MySql&rsquo;s SET @var := somevalue语法。</li>
<li>更改连接选项，如字符集或超时。</li>
</ul>
<p>如果你需要执行任何这些操作，则需要把你的作业(也可以说Tx操作语句)绑定到单个连接，而在Golang中执行此操作的唯一方法是使用Tx。</p>
<h3 id="事务并发">事务并发</h3>
<p>对于sql.Tx对象，因为事务过程只有一个连接，事务内的操作都是顺序执行的，在开始下一个数据库交互之前，必须先完成上一个数据库交互。例如下面的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT id FROM user&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">did</span> <span class="kt">int</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mid</span><span class="p">)</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT id FROM detail_user WHERE master = ?&#34;</span><span class="p">,</span> <span class="nx">mid</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">did</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用了Query方法之后，在Next方法中取结果的时候，rows是维护了一个连接，再次调用QueryRow的时候，db会再从连接池取出一个新的连接。rows和db的连接两者可以并存，并且相互不影响。</p>
<p>可是，这样逻辑在事务处理中将会失效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT id FROM user&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">did</span> <span class="kt">int</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mid</span><span class="p">)</span>
   <span class="nx">tx</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT id FROM detail_user WHERE master = ?&#34;</span><span class="p">,</span> <span class="nx">mid</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">did</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>tx执行了Query方法后，连接转移到rows上，在Next方法中，tx.QueryRow将尝试获取该连接进行数据库操作。因为还没有调用rows.Close，因此底层的连接属于busy状态，tx是无法再进行查询的。上面的例子看起来有点傻，毕竟涉及这样的操作，使用query的join语句就能规避这个问题。例子只是为了说明tx的使用问题。</p>
<h3 id="事务中的准备语句">事务中的准备语句</h3>
<p>在Tx中创建的准备语句仅限于它，因此早期关于重新准备的注意事项不适用。当你对Tx对象进行操作时，你的操作直接映射到它下面唯一的一个连接上。</p>
<p>这也意味着在Tx内创建的准备语句不能与之分开使用。同样，在DB中创建的准备语句不能在事务中使用，因为它们将被绑定到不同的连接。</p>
<p>要在Tx中使用事务外的预处理语句，可以使用Tx.Stmt()，它将从事务外部准备一个新的特定于事务的语句。它通过采用现有的预处理语句，设置与事务的连接，并在执行时重新准备所有语句。这个行为及其实现是不可取的，甚至在databse/sql源代码中有一个TODO来改进它；我们建议不要使用这个。</p>
<p>在处理事务中的预处理语句时，必须小心谨慎。请考虑下面的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT INTO foo VALUES (?)&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// danger!
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// stmt.Close() runs here!
</span></code></pre></td></tr></table>
</div>
</div><p>之前Golang1.4关闭*sql.Tx将与之关联的连接返还到池中，但是，在预处理语句结束后，延迟调用时在那之后发生的，这可能导致并发访问底层的连接，使连接状态不一致。如果使用Golang1.4或更高的版本，则应确保在提交事务或回滚之前声明始终关闭。</p>
<h4 id="源码分析-3">源码分析</h4>
<p>下面分析下对数据库事务的支持。同prepared statement一样，在数据库层面事务也只能在一个连接上进行，但在底层实现上，Tx的实现与prepared statement有明显不同，它底层从始至终只使用了一个连接。不过，我不太明白prepared statement为啥没有这样实现。</p>
<p>开启事务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">BeginTx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">*</span><span class="nx">TxOptions</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maxBadConnRetries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">begin</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">cachedOrNewConn</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">begin</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">alwaysNewConn</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">begin</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">*</span><span class="nx">TxOptions</span><span class="p">,</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 依然是先从池子中取出一个空闲连接
</span><span class="c1"></span>    <span class="nx">dc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">conn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">strategy</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">beginDC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">dc</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">beginDC</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">release</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">),</span> <span class="nx">opts</span> <span class="o">*</span><span class="nx">TxOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">txi</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">Tx</span>
    <span class="nf">withLock</span><span class="p">(</span><span class="nx">dc</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 调用driver来开启事务
</span><span class="c1"></span>        <span class="nx">txi</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">ctxDriverBegin</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">ci</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">release</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="c1">// Schedule the transaction to rollback when the context is cancelled.
</span><span class="c1"></span>    <span class="c1">// The cancel function in Tx will be called after done is set to true.
</span><span class="c1"></span>    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="c1">// 注意返回的tx对象记了启动事务的连接dc
</span><span class="c1"></span>    <span class="c1">// 后续所有的操作都会在这一个dc上进行
</span><span class="c1"></span>    <span class="nx">tx</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Tx</span><span class="p">{</span>
        <span class="nx">db</span><span class="p">:</span>          <span class="nx">db</span><span class="p">,</span>
        <span class="nx">dc</span><span class="p">:</span>          <span class="nx">dc</span><span class="p">,</span>
        <span class="nx">releaseConn</span><span class="p">:</span> <span class="nx">release</span><span class="p">,</span>
        <span class="nx">txi</span><span class="p">:</span>         <span class="nx">txi</span><span class="p">,</span>
        <span class="nx">cancel</span><span class="p">:</span>      <span class="nx">cancel</span><span class="p">,</span>
        <span class="nx">ctx</span><span class="p">:</span>         <span class="nx">ctx</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">awaitDone</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">tx</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行阶段，exec和query过程类似，下面只分析exec的过程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">QueryContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 取出之前保存在tx上的连接dc
</span><span class="c1"></span>    <span class="nx">dc</span><span class="p">,</span> <span class="nx">release</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">grabConn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// 其实就是db.queryDC的逻辑
</span><span class="c1"></span>    <span class="c1">// 现在知道为什么tx上要记一个db对象了
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">queryDC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">dc</span><span class="p">,</span> <span class="nx">release</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">grabConn</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">releaseConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">default</span><span class="p">:</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// closeme.RLock must come before the check for isDone to prevent the Tx from
</span><span class="c1"></span>    <span class="c1">// closing while a query is executing.
</span><span class="c1"></span>    <span class="c1">// 这个读写锁的目的是保证当tx被关闭时已经没有任何其它的查询在进行了
</span><span class="c1"></span>    <span class="c1">// 注意到一般每一个资源对象都有这样一个锁，比如Row、Stmt
</span><span class="c1"></span>    <span class="nx">tx</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">isDone</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">tx</span><span class="p">.</span><span class="nx">closemu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrTxDone</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">hookTxGrabConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// test hook
</span><span class="c1"></span>        <span class="nf">hookTxGrabConn</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 返回的是tx上记的那个dc
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">closemuRUnlockRelease</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="总结-2">总结</h3>
<p>database/sql提供了事务处理的功能。通过Tx对象实现。db.Begin会创建tx对象，后者的Exec和Query执行事务的数据库操作，最后在tx的Commit和Rollback中完成数据库事务的提交和回滚，同时释放连接。
tx事务环境中，只有一个数据库连接，事务内的Eexc都是依次执行的，事务中也可以使用db进行查询，但是db查询的过程会新建连接，这个连接的操作不属于该事务。
关于database/sql和mysql的驱动，我们已经分三部分内容介绍了。下一节，将会对之前的内容进行梳理总结，包括错误处理和注意事项的补充。</p>
<h2 id="错误处理">错误处理</h2>
<p>几乎所有使用database/sql类型的操作都会返回一个错误作为最后一个值。你应该总是检查这些错误，千万不要忽视它们。有几个地方错误行为是特殊情况，还有一些额外的东西可能需要知道。</p>
<h3 id="遍历结果集的错误">遍历结果集的错误</h3>
<p>请思考下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// handle the error here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>来自rows.Err()的错误可能是rows.Next()循环中各种错误的结果。除了正常完成循环之外，循环可能会退出，因此你总是需要检查循环是否正常终止。异常终止自动调用rows.Close()，尽管多次调用它是无害的。</p>
<h3 id="关闭结果集的错误">关闭结果集的错误</h3>
<p>如上所述，如果你过早的退出循环，则应该总是显式的关闭sql.Rows。如果循环正常退出或通过错误，它会自动关闭，但你可能会错误的执行此操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">break</span><span class="p">;</span> <span class="c1">// whoops, rows is not closed! memory leak...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// do the usual &#34;if err = rows.Err()&#34; [omitted here]...
</span><span class="c1">// it&#39;s always safe to [re?]close here:
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// but what should we do if there&#39;s an error?
</span><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>rows.Close()返回的错误是一般规则的唯一例外，最好是捕获并检查所有数据库操作中的错误。如果rows.Close()返回错误，那么你应该怎么做。记录错误信息或panic可能是唯一明智的事情，如果这不明智，那么也许你应该忽略错误。</p>
<h3 id="queryrow的错误">QueryRow()的错误</h3>
<p>思考下面的代码来获取一行数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有id = 1的用户怎么办？那么结果中不会有行，而.Scan()不会将值扫描到name中。那会怎么样？</p>
<p>Golang定义了一个特殊的错误常量，称为sql.ErrNoRows，当结果为空时，它将从QueryRow()返回。这在大多数情况下需要作为特殊情况来处理。空的结果通常不被应用程序代码认为是错误的，如果不检查错误是不是这个特殊常量，那么会导致你意想不到的应用程序代码错误。</p>
<p>来自查询的错误被推迟到调用Scan()，然后从中返回。上面的代码可以更好地写成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">ErrNoRows</span> <span class="p">{</span>
        <span class="c1">// there were no rows, but otherwise no error occurred
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>有人可能会问为什么一个空的结果集被认为是一个错误。空集没有什么错误。原因是QueryRow()方法需要使用这种特殊情况才能让调用者区分是否QueryRow()实际上找到一行；没有它，Scan(0)不会做任何事情，你可能不会意识到你的变量毕竟没有从数据库中获取任何值。</p>
<p>当你使用QueryRow()时，你应该只会遇到此错误。如果你在别处遇到这个错误，你就做错了什么。</p>
<h3 id="识别特定的数据库错误">识别特定的数据库错误</h3>
<p>像下面这样编写代码是很有诱惑力的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT someval FROM sometable&#34;</span><span class="p">)</span>
<span class="c1">// err contains:
</span><span class="c1">// ERROR 1045 (28000): Access denied for user &#39;foo&#39;@&#39;::1&#39; (using password: NO)
</span><span class="c1"></span><span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="s">&#34;Access denied&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle the permission-denied error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这不是最好的方法。例如，字符串值可能会取决于服务器使用什么语言发送错误消息。比较错误编号以确定具体错误是啥要好得多。
但是，驱动的机制不同，因为这不是database/sql本身的一部分。在本教程重点介绍的MySql驱动中，你可以编写以下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">driverErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">mysql</span><span class="p">.</span><span class="nx">MySQLError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span> <span class="c1">// Now the error number is accessible directly
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">driverErr</span><span class="p">.</span><span class="nx">Number</span> <span class="o">==</span> <span class="mi">1045</span> <span class="p">{</span>
        <span class="c1">// Handle the permission-denied error
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再次，这里的MySQLError类型由此特定驱动程序提供，并且驱动程序之间的.Number字段可能不同。然而，该值是从MySql的错误消息中提取的，因此是特定于数据库的，而不是特定于驱动的。</p>
<p>这段代码还是很丑相对于1045，一个魔术数字是一种代码气味。一些驱动(虽然不是MySql的驱动程序，因为这里的主题的原因)提供错误标识符的列表。例如Postgres pg驱动程序在error.go中。还有一个由VividCortex维护的MySql错误号的外部包。使用这样的列表，上面的代码写的更漂亮：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">driverErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">mysql</span><span class="p">.</span><span class="nx">MySQLError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">driverErr</span><span class="p">.</span><span class="nx">Number</span> <span class="o">==</span> <span class="nx">mysqlerr</span><span class="p">.</span><span class="nx">ER_ACCESS_DENIED_ERROR</span> <span class="p">{</span>
        <span class="c1">// Handle the permission-denied error
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="处理连接错误">处理连接错误</h3>
<p>如果与数据库的连接被丢弃，杀死或发生错误该怎么办？</p>
<p>当发生这种情况时，你不需要实现任何逻辑来重试失败的语句。作为database/sql连接池的一部分，处理失败的连接是内置的。如果你执行查询或其他语句，底层连接失败，则Golang将重新打开一个新的连接(或从连接池中获取另一个连接)，并重试10次。</p>
<p>然而，可能会产生一些意想不到的后果。当某些类型错误可能会发生其他错误条件。这也可能是驱动程序特定的。MySql驱动程序发生的一个例子是使用KILL取消不需要的语句(例如长时间运行的查询)会导致语句被重试10次。</p>
<h2 id="惊喜反模式和限制">惊喜，反模式和限制</h2>
<p>虽然database/sql很简单，但一旦你习惯了它，你可能会对它支持的用例的微妙之处感到惊讶。这是Golang的核心库通用的。</p>
<h3 id="资源枯竭">资源枯竭</h3>
<p>如果你不按预期使用database/sql，你一定会为自己造成麻烦，通常是通过消耗一些资源或阻止它们被有效的重用：</p>
<ul>
<li>打开和关闭数据库可能会导致资源耗尽。</li>
<li>没有读取所有行或使用rows.Close()保留来自池的连接。</li>
<li>对于不返回行的语句，使用Query()将从池中预留一个连接。</li>
<li>没有意识到预处理语句如何工作会导致大量额外的数据库活动。</li>
</ul>
<h3 id="巨大的uint64值">巨大的uint64值</h3>
<p>这里有一个令人吃惊的错误。如果设置了高位，就不能将大的无符号整数作为参数传递给语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;INSERT INTO users(id) VALUES&#34;</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxUint64</span><span class="p">)</span> <span class="c1">// Error
</span></code></pre></td></tr></table>
</div>
</div><p>这将抛出一个错误。如果你使用uint64值要小心，因为它们可能开始小而且无错误的工作，但会随着时间的推移而增加，并开始抛出错误。</p>
<h3 id="连接状态不匹配">连接状态不匹配</h3>
<p>有些事情可以改变连接状态，这可能导致的问题有两个原因：</p>
<ol>
<li>某些连接状态，比如你是否处于事务中，应该通过Golang类型来处理。</li>
<li>你可能假设你的查询在单个连接上运行。</li>
</ol>
<p>例如，使用USE语句设置当前数据库对于很多人来说是一个典型的事情。但是在Golang中，它只会影响你运行的连接。除非你处于事务中，否则你认为在该连接上执行的其他语句实际上可能在从池中获取的不同的连接上运行，因此它们不会看到这些更改的影响。</p>
<p>此外，在更改连接后，它将返回到池，并可能会污染其他代码的状态。这就是为什么你不应该直接将BEGIN或COMMIT语句作为SQL命令发出的原因之一。</p>
<h3 id="数据库特定的语法">数据库特定的语法</h3>
<p>database/sql API提供了面向行的数据库抽象，但是具体的数据库和驱动程序可能会在行为或语法上有差异，例如预处理语句占位符。</p>
<h3 id="多个结果集">多个结果集</h3>
<p>Golang驱动程序不以任何方式支持单个查询中的多个结果集，尽管有一个支持大容量操作（如批量复制）的功能请求似乎没有任何计划。
这意味着，除了别的以外，返回多个结果集的存储过程将无法正常工作。</p>
<h3 id="调用存储过程">调用存储过程</h3>
<p>调用存储过程是特定于驱动程序的，但在MySql驱动程序中，目前无法完成。看来你可以调用一个简单的过程来返回一个单一的结果集，通过执行如下的操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;CALL mydb.myprocedure&#34;</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">)</span> <span class="c1">// Error
</span></code></pre></td></tr></table>
</div>
</div><p>事实上这行不通。你将收到以下错误1312：PROCEDURE mydb.myprocedure无法返回给定上下文中的结果集。这是因为MySql希望将连接设置为多语句模式，即使单个结果，并且驱动程序当前没有执行此操作（尽管看到这个问题）。</p>
<h3 id="多个声明支持">多个声明支持</h3>
<p>database/sql没有显式的拥有多个语句支持，这意味着这个行为是后端依赖的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;DELETE FROM tbl1; DELETE FROM tbl2&#34;</span><span class="p">)</span> <span class="c1">// Error/unpredictable result
</span></code></pre></td></tr></table>
</div>
</div><p>服务器可以解释它想要的，它可以包括返回的错误，只执行第一个语句，或执行两者。</p>
<p>同样，在事务中没有办法批处理语句。事务中的每个语句必须连续执行，并且结果中的资源（如行或行）必须被扫描或关闭，以便底层连接可供下一个语句使用。这与通常不在事务中工作时的行为不同。在这种情况下，完全可以执行查询，循环遍历行，并在循环中对数据库进行查询（这将发生在一个新的连接上)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl1&#34;</span><span class="p">)</span> <span class="c1">// Uses connection 1
</span><span class="c1"></span><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">myvariable</span><span class="p">)</span>
    <span class="c1">// The following line will NOT use connection 1, which is already in-use
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl2 where id = ?&#34;</span><span class="p">,</span> <span class="nx">myvariable</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是事务只绑定到一个连接，所以事务不可能做到这一点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl1&#34;</span><span class="p">)</span> <span class="c1">// Uses tx&#39;s connection
</span><span class="c1"></span><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">myvariable</span><span class="p">)</span>
    <span class="c1">// ERROR! tx&#39;s connection is already busy!
</span><span class="c1"></span>    <span class="nx">tx</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl2 where id = ?&#34;</span><span class="p">,</span> <span class="nx">myvariable</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不过，Golang不会阻止你去尝试。因此，如果你试图在第一个释放资源并自行清理之前尝试执行另一个语句，可能会导致一个损坏的连接。这也意味着事务中的每个语句都会产生一组单独的网络往返数据库。</p>
<h2 id="连接的有效性">连接的有效性</h2>
<p>连接失效会有什么问题？</p>
<ul>
<li>如果连接是客户端主动关闭的，那会在write packets 的时候返回一个 ErrBadConn，连接池会在重试次数内，获取新的连接</li>
<li>如果连接时数据库服务器主动关闭的，那客户端对此是不知道的，拿到连接后，write packets 是不会报错的，但是连接的，但是在读服务器的 response 包的时候会有一个 unexpected EOF 错误。但是在读失败的时候一般是不能返回ErrBadConn的，因为客户端拿到新的连接会重新执行语句，可能会导致插入语句的 duplicate err。</li>
</ul>
<p>解决思路 1：设置 maxLifetime</p>
<ul>
<li>DB 会定期清理连接池中过期的连接</li>
<li>如果没有设置maxLifetime，表示连接池中的连接可以一直复用，如果服务器关闭了这一条连接，连接池是不知道的，返回给客户端的就会是一条已经关闭的连接。</li>
<li>获取数据库服务器的 wait_timeout，然后设置 maxLifetime 比这个数值小 10 s 左右</li>
</ul>
<p>解决思路 2：检查连接的有效性</p>
<ul>
<li>mysql 推荐的在获取连接、放回连接池、定期检查</li>
<li>sql 包在 1.10 版本加了一个 connectionResetter 相关的逻辑，在连接放回连接池前校验，但需要数据库 driver 的支持。</li>
<li>mysql driver 包会发送新的请求之前，校验 tcp 连接的有效性，同样也没有 release。</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://www.jianshu.com/p/bc8120bec94e">https://www.jianshu.com/p/bc8120bec94e</a>
<a href="http://go-database-sql.org/index.html">http://go-database-sql.org/index.html</a>
<a href="https://segmentfault.com/a/1190000019389922">Gorm 源码分析(一) database/sql</a>
<a href="https://cs50mu.github.io/blog/2019/10/17/golang-database-sql/">Database/sql 源码学习</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-12-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/mysql/">Mysql</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/gin%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"> Gin实现自动注册路由</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/">
            <span class="next-text nav-default">Go连接MySql数据库too many connections错误解决</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
