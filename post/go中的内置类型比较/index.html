<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go中的内置类型比较 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go中的内置类型比较" />
<meta property="og:description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-16T16:25:53&#43;00:00" />
<meta property="article:modified_time" content="2019-08-16T16:25:53&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的内置类型比较"/>
<meta name="twitter:description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go中的内置类型比较",
      "item": "/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go中的内置类型比较",
  "name": "Go中的内置类型比较",
  "description": "概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A",
  "keywords": [
    "Go"
  ],
  "articleBody": "概念 首先区分几个概念：变量可比较，可排序，可赋值\n可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#Assignability\nA value x is assignable to a variable of type T (“x is assignable to T”) in any of these cases:\n x’s type is identical to T. x’s type V and T have identical underlying types and at least one of V or T is not a defined type. T is an interface type and x implements T. x is a bidirectional channel value, T is a channel type, x’s type V and T have identical element types, and at least one of V or T is not a defined type. x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type. x is an untyped constant representable by a value of type T.  概括起来就是他们的类型需要满足某种条件，或者类型相同，或者底层类型(underlying types)相同。\n可比较 规范里面对比较操作是这么定义的：https://golang.org/ref/spec#Comparison_operators\n可比较又可以分为两个小类\n 可比较，包括相等(==)，和不相等(!=) 可排序，包括大于()，大于等于(=)，小于()，小于等于(  可排序的一定是可比较的，反之不成立，即可比较的不一定是可排序的，例如struct类型就是可比较的，但不可排序。\n 可排序的数据类型有三种，Integer，Floating-point，和String 可比较的数据类型除了上述三种外，还有Boolean，Complex，Pointer，Channel，Interface，Struct，和Array 不可比较的数据类型包括，Slice, Map, 和Function  上述规范里面对哪种数据类型如何进行比较，如何相等都做了描述，不细说，请参考原文。\n至于如何定义他们相等的规则，也请参考上述规范文档。\n可赋值和可比较的关系 规范里是这么说的：\nIn any comparison, the first operand must be assignable to the type of the second operand, or vice versa.\n也就是说如果两个变量可比较，那么他们必然是可赋值的，要么左边变量可赋值给右边变量，要么右边变量可赋值给左边变量。反之则不一定，即可赋值的变量，不一定可比较，比如前面提到的map类型变量。\n所以两个可比较的变量，也必须满足他们或者类型相同，或者他们的底层类型(underlying types)相同。\n两个变量是否可比较这个规则是在编译的时候由编译器负责静态检查的。\nstring 比较   “==”：逐个比较且不分大小写，相等返回true，不相等返回false\n1 2 3  fmt.Println(\"你好\" == \"你好\")\t//true fmt.Println(\"sa\" == \"sa\")\t//true fmt.Println(\"SA\" == \"Sa\")\t//false     strings.EqualFold：区分utf-8字符在忽略大小写的情况下是否相等，相等返回true，不相等返回false\n1 2  fmt.Println(strings.EqualFold(\"das\",\"Das\"))\t//true fmt.Println(strings.EqualFold(\"你好\",\"你好\"))\t//true     strings.Compare：相当于“==”比较，效率更高一些，相等返回0，不相等返回1\n1 2  fmt.Println(strings.Compare(\"你好\",\"你好\"))\t//0 fmt.Println(strings.Compare(\"das\",\"Das\"))\t//1     float 比较 golang 支持两种浮点float32和float64，众所众知，涉及浮点数比较或运算是会遇到精度问题，具体要根据golang实现IEEE 754的情况定。\n默认情况下，float32精度是小数后7位，float64精度是小数点后15位。\n如例1：\nfloat32\n1 2 3 4 5 6 7 8 9  var a float32 = 1.00000001 var b float32 = 1.000000000001 var c float32 = 1.0000001 var d float32 = 1.000000000001 fmt.Println(a == b) //true  fmt.Println(a  b) //false  fmt.Println(c == d) //false  fmt.Println(c  d) //true   float64\n1 2 3 4 5 6 7 8 9  var a float64 = 1.0000000000000001 var b float64 = 1.000000000000000001 var c float64 = 1.000000000000001 var d float64 = 1.0000000000000000001 fmt.Println(a == b) //true  fmt.Println(a  b) //false  fmt.Println(c == d) //false  fmt.Println(c  d) //true   这里写了一个根据精度进行float比较的简单的类，注意最大精度为小数点后15位，超出会丢失精度。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  package main import ( \"fmt\" \"math\" ) type Floater struct { Accuracy float64 //精度,最大为小数点后15位 } //是否相等 func (f Floater) IsEqual(a, b float64) bool { return math.Abs(a-b)  f.Accuracy } //0为相等 1为a大于b -1为a小于b func (f Floater) Bccomp(a, b float64) int8 { if math.Abs(a-b)  f.Accuracy { return 0 } if math.Max(a, b) == a { return 1 } else { return -1 } } func main() { f := Floater{Accuracy: 0.000000000001} var a float64 = 1.0000000002 var b float64 = 1.0000000001 fmt.Println(f.Bccomp(a, b)) //1  fmt.Println(f.Bccomp(b, a)) //-1  fmt.Println(f.Bccomp(a, a)) //0 }   指针类型比较 1 2 3 4  a := \"hello\" b := \u0026a c := \u0026a fmt.Println(b == c)   当变量是相同或者都为nil时，指针值相等。\ninterface 比较 两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝=操作相等。\n在Go语言中，interface的实际实现结构可以理解为下图：\n其中type就是它的类型（动态类型），value部分是它的值（动态值）。\n一个interface类型的变量 w 为nil，就代表着其动态类型和动态值都为 nil 。考虑这种情况：\n图中代表着类型不为空，但是interface的动态值是 nil ，那么这种情况下，如果去判断 w 是否为 nil 时，会得到一个false\n1  fmt.Println(w == nil) //输出 false   要特别注意这钟情况，因为我们可能会犯这样的错误：\n1 2 3  if w != nil { w.Write([]byte(\"done!\\n\")) // 当w的动态值为nil时，会发生panic }   当interface的动态类型是指针的时候，且其动态值不为 nil 时，我们可以理解为其结构如下图所示。\n这里为什么需要特别拿出来说明呢？因为动态类型为指针的interface的动态值保存的就是一个指针值，这个指针指向一块内存。下面以Golang的error接口来说明这个问题。\n下面是error包的代码：\n1 2 3 4 5 6 7 8 9  type error interface { Error() string } func New(text string) error { return \u0026errorString{text} } type errorString struct { text string } func (e *errorString) Error() string { return e.text }   这里需要理解的：是指针类型 *errorString 实现了error接口，而不是 errorString 。\n1 2 3  w1 := errors.New(\"ERR\") w2 := errors.New(\"ERR\") fmt.Println(w1 == w2) // 输出false   以 w1 为例子， 由于是指针类型 *errorString 实现了error接口，所以 w1 的动态类型是 *errorString，那么 w1 的动态值就是一个指针，w2 也是同理。那么上面的等于(==)比较我们可以用下图和伪代码来理解。\n1  w1.type == w2.type \u0026\u0026 w1.value == w2.value   由于 w1.value 和 w2.value 都是指针类型，它们又分别保存着不同的内存地址，所以他们的比较是得出 false\n也正是这种实现，每个New函数的调用都分配了一个独特的和其他错误不相同的实例，这能方便的让我们可以定义自己特定的错误，就如同Golang定义的 io.EOF 一样，不必担心刚好有相同的错误消息：\n1  fmt.Println(errors.New(\"EOF\") == io.EOF) //输出false   如果想要让w1 := errors.New(\"ERR\")和 w2 := errors.New(\"ERR\")比较指针指向的真实值呢?需要使用reflect.DeepEqual()函数\n1 2 3  w1 := errors.New(\"ERR\") w2 := errors.New(\"ERR\") fmt.Println(reflect.DeepEqual(w1,w2))   结果返回true\narray 比较 两个数组只要他们包括的元素，每个元素的值相同，则他们相等。\n1 2 3 4 5 6 7 8 9 10 11 12  package main import ( \"fmt\" ) func main() { var arr = [3]int{1, 2, 3} var brr = [3]int{1, 2, 3} fmt.Println(arr==brr) //true }   struct 比较 注意这里指的是相等比较，而不是排序比较，因为struct不是可排序的。\n规范里面对struct比较的规则定义：\nStruct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.\n类型是否相同 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import \"fmt\" type T1 struct { name string } type T2 struct { name string } func main() { v11 := T1 { \"foo\" } v12 := T1 { \"foo\" } v21 := T2 { \"foo\" } v22 := T2 { \"foo\" } fmt.Printf(\"v11 == v12 is %v\\n\", v11 == v12) // output: v11 == v12 is true  //fmt.Printf(\"v11 == v21 is %v\\n\", v11 == v21) // compile error, invalid operation: v11 == v21 (mismatched types T1 and T2)  //fmt.Printf(\"v11 == v22 is %v\\n\", v11 == v22) // compile error, invalid operation: v11 == v22 (mismatched types T1 and T2)  //fmt.Printf(\"v12 == v21 is %v\\n\", v12 == v21) // compile error, invalid operation: v12 == v21 (mismatched types T1 and T2)  //fmt.Printf(\"v12 == v22 is %v\\n\", v12 == v22) // compile error, invalid operation: v12 == v22 (mismatched types T1 and T2)  fmt.Printf(\"v21 == v22 is %v\\n\", v21 == v22) // output: v21 == v22 is true }   这个例子说明，struct类型不相同时，他们是不可进行比较的，编译器在编译的时候静态检查类型；此例中变量v1x和v2x的类型不相同，一个是T1，另一个是T2，所以他们不能进行比较，虽然他们的内部底层类型一样，因为T1和T2的定义内容是一样的，但是go认定他们是不同的类型。\n因为这违背了可比较的第一个限定条件，即变量必须是可赋值的；T1和T2不是可相互赋值的类型。\n关于类型相同判断的问题，再举一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import \"fmt\" type Int int func main() { var v11 int = 1 var v12 int = 1 var v21 Int = 1 var v22 Int = 1 fmt.Printf(\"v11 == v12 is %v\\n\", v11 == v12) // output: v11 == v12 is true  //fmt.Printf(\"v11 == v21 is %v\\n\", v11 == v21) // compile error, invalid operation: v11 == v21 (mismatched types int and Int)  //fmt.Printf(\"v11 == v22 is %v\\n\", v11 == v22) // compile error, invalid operation: v11 == v22 (mismatched types int and Int)  //fmt.Printf(\"v12 == v21 is %v\\n\", v12 == v21) // compile error, invalid operation: v12 == v21 (mismatched types int and Int)  //fmt.Printf(\"v12 == v22 is %v\\n\", v12 == v22) // compile error, invalid operation: v12 == v22 (mismatched types int and Int)  fmt.Printf(\"v21 == v22 is %v\\n\", v21 == v22) // output: v21 == v22 is true }   这个例子中我们定义了一种新数据类型Int，虽然实际上他就是int，Int只是int的一个wrapper，go语言还是认为他们是不同的数据类型。\n如果结构体能够通过强制转换成为相同的结构体,那么他们可以比较:w\n是否所有的域(field)都可比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \"fmt\" type T1 struct { name string } type T2 struct { name string; attrs map[string]interface{} } func main() { v11 := T1 { \"foo\" } v12 := T1 { \"foo\" } v21 := T2 { \"foo\", make(map[string]interface{}) } v22 := T2 { \"foo\", make(map[string]interface{}) } fmt.Printf(\"v11 == v12 is %v\\n\", v11 == v12) // output: v11 == v12 is true  fmt.Printf(\"v21 == v22 is %v\\n\", v21 == v22) // compile error: invalid operation: v21 == v22 (struct containing map[string]interface {} cannot be compared) }   按照规范描述类型T2是否可比较需要它的所有域都是可比较的，这里因为T2含有一个attrs域，其类型是map，而map是不可比较的，所以T2不可比较。\n包含空域(Blank Field) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import \"fmt\" type T1 struct { i int64 j int32 _ int32 } // About blank field: // You cannot set or get a blank field; it cannot be refered. // You can't do it in a composite literal either. // The only use for a blank field in a struct is for padding.  func main() { v11 := T1 { i:10, j:10 } v12 := T1 { i:10, j:10 } fmt.Printf(\"v11 == v12 is %v\\n\", v11 == v12) // output: v11 == v12 is true }   这个例子使用了blank field，可见struct在比较的时候是丢弃blank field的，不管blank field的值是什么；进而我们猜测，go语言内部比较struct类型的逻辑是遍历递归所有的域，针对每个域分别比较，当所有的递归域都返回true时，就返回true，当任何一个返回false时，就返回false；可见struct并不是比较对象地址，也不是比较对象内存块值，而是一个一个域遍历递归比较的，而blank field不可以引用，因而不参与比较。\n匿名类型比较 go语言定义了两种类型：命名类型，和匿名类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import \"fmt\" import \"reflect\" type T1 struct { name string } type T2 struct { name string } func main() { v1 := T1 { \"foo\" } v2 := T2 { \"foo\" } v3 := struct{ name string } {\"foo\"} v4 := struct{ name string } {\"foo\"} fmt.Println(\"v1: type=\", reflect.TypeOf(v1), \"value=\", reflect.ValueOf(v1)) // v1: type= main.T1 value= {foo}  fmt.Println(\"v2: type=\", reflect.TypeOf(v2), \"value=\", reflect.ValueOf(v2)) // v2: type= main.T2 value= {foo}  fmt.Println(\"v3: type=\", reflect.TypeOf(v3), \"value=\", reflect.ValueOf(v3)) // v3: type= struct { name string } value= {foo}  fmt.Println(\"v4: type=\", reflect.TypeOf(v4), \"value=\", reflect.ValueOf(v4)) // v4: type= struct { name string } value= {foo}  //fmt.Println(v1 == v2) // compiler error: invalid operation: v1 == v2 (mismatched types T1 and T2)  fmt.Println(v1 == v3) // true, why? their type is different  fmt.Println(v2 == v3) // true, why?  fmt.Println(v3 == v4) // true }   这个地方比较好理解的是v1和v2是不同的类型，一个是T1一个是T2，前面我们讲过虽然T1和T2底层类型一样，但是go认为他们就是不同的类型。\n然后v3和v4也好理解，他们的类型是一样的匿名类型。\n不好理解的是v1和v3，v2和v3明明他们的类型是不一样的，为什么输出true呢？\n要回答这个问题，我们还是回到规范定义上面\nStruct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.\n关于struct是否可比较，只看一点，是不是他的所有域都是可比较的，在这个例子总，只有一个域即name string，它是可比较的，所以这一条是满足的，即此struct是可比较的。\n再看规范里的另一条定义，这条定义是针对通用变量的，不只是struct\nIn any comparison, the first operand must be assignable to the type of the second operand, or vice versa.\n只有这条规则也能满足的时候，两个变量才可以比较；在我们例子中v1和v2就不满足这条，所以不可比较，而v3和v4是满足这条的，所以v3和v4是可比较的。\n总结：struct的比较 struct的比较只需要满足两个条件：\n 从所有比较操作继承下来的规则，即两个变量必须是可赋值的。 针对struct本身的规则，即struct的所有域必须都是可比较的；注意这里并不管struct本身的定义类型。  只要满足这两个条件，struct就是可比较的；可见并没有限定两个struct的类型必须一致，从而解释了命名类型和匿名类型struct的比较规则，就是它并不管名字，反之都是struct类型就行\ntime.time 比较 先把当前时间格式化成相同格式的字符串,然后使用time的Before, After, Equal 方法即可.\n1 2 3 4 5 6 7 8 9  time1 := \"2015-03-20 08:50:29\" time2 := \"2015-03-21 09:04:25\" //先把时间字符串格式化成相同的时间类型  t1, err := time.Parse(\"2006-01-02 15:04:05\", time1) t2, err := time.Parse(\"2006-01-02 15:04:05\", time2) if err == nil \u0026\u0026 t1.Before(t2) { //处理逻辑  fmt.Println(\"true\") }   DeepEqual slice/struct/map 这三个都可以用reflect.DeepEqual来判断是否相等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package main import ( \"fmt\" \"reflect\" ) type S struct { s string } func main() { s1 := S{s: \"hello\"} s2 := S{s: \"hello\"} if reflect.DeepEqual(s1, s2) { fmt.Println(s1, \"==\", s2) } a1 := []int{1, 2} a2 := []int{1, 2} if reflect.DeepEqual(a1, a2) { fmt.Println(a1, \"==\", a2) } m1 := map[int]string{1: \"a\", 2: \"b\"} m2 := map[int]string{1: \"a\", 2: \"b\"} if reflect.DeepEqual(m1, m2) { fmt.Println(m1, \"==\", m2) } }   但因为reflect.DeepEqual的性能不好,实际上只针对特定环境使用.详情参加另一篇博文\n参考:\nhttps://studygolang.com/articles/11342 https://blog.csdn.net/double_happiness/article/details/80098816\nhttps://www.veaxen.com/golang%E6%8E%A5%E5%8F%A3%E5%80%BC%EF%BC%88interface%EF%BC%89%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90.html\n",
  "wordCount" : "4999",
  "inLanguage": "zh-cn",
  "datePublished": "2019-08-16T16:25:53Z",
  "dateModified": "2019-08-16T16:25:53Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go中的内置类型比较
    </h1>
    <div class="post-meta">August 16, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h1>
<p>首先区分几个概念：变量可比较，可排序，可赋值</p>
<h2 id="可赋值">可赋值<a hidden class="anchor" aria-hidden="true" href="#可赋值">#</a></h2>
<p>规范里面对赋值是这么定义的：https://golang.org/ref/spec#Assignability</p>
<p>A value x is assignable to a variable of type T (&ldquo;x is assignable to T&rdquo;) in any of these cases:</p>
<ul>
<li>x&rsquo;s type is identical to T.</li>
<li>x&rsquo;s type V and T have identical underlying types and at least one of V or T is not a defined type.</li>
<li>T is an interface type and x implements T.</li>
<li>x is a bidirectional channel value, T is a channel type, x&rsquo;s type V and T have identical element types, and at least one of V or T is not a defined type.</li>
<li>x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type.</li>
<li>x is an untyped constant representable by a value of type T.</li>
</ul>
<p>概括起来就是他们的类型需要满足某种条件，或者类型相同，或者底层类型(underlying types)相同。</p>
<h2 id="可比较">可比较<a hidden class="anchor" aria-hidden="true" href="#可比较">#</a></h2>
<p>规范里面对比较操作是这么定义的：https://golang.org/ref/spec#Comparison_operators</p>
<p>可比较又可以分为两个小类</p>
<ol>
<li>可比较，包括相等(==)，和不相等(!=)</li>
<li>可排序，包括大于(&gt;)，大于等于(&gt;=)，小于(&gt;)，小于等于(&lt;=)</li>
</ol>
<p>可排序的一定是可比较的，反之不成立，即可比较的不一定是可排序的，例如struct类型就是可比较的，但不可排序。</p>
<ol>
<li>可排序的数据类型有三种，Integer，Floating-point，和String</li>
<li>可比较的数据类型除了上述三种外，还有Boolean，Complex，Pointer，Channel，Interface，Struct，和Array</li>
<li>不可比较的数据类型包括，Slice, Map, 和Function</li>
</ol>
<p>上述规范里面对哪种数据类型如何进行比较，如何相等都做了描述，不细说，请参考原文。</p>
<p>至于如何定义他们相等的规则，也请参考上述规范文档。</p>
<h2 id="可赋值和可比较的关系">可赋值和可比较的关系<a hidden class="anchor" aria-hidden="true" href="#可赋值和可比较的关系">#</a></h2>
<p>规范里是这么说的：</p>
<p>In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.</p>
<p>也就是说如果两个变量可比较，那么他们必然是可赋值的，要么左边变量可赋值给右边变量，要么右边变量可赋值给左边变量。反之则不一定，即可赋值的变量，不一定可比较，比如前面提到的map类型变量。</p>
<p>所以两个可比较的变量，也必须满足他们或者类型相同，或者他们的底层类型(underlying types)相同。</p>
<p>两个变量是否可比较这个规则是在编译的时候由编译器负责静态检查的。</p>
<h1 id="string-比较">string 比较<a hidden class="anchor" aria-hidden="true" href="#string-比较">#</a></h1>
<ol>
<li>
<p>“==”：逐个比较且不分大小写，相等返回true，不相等返回false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;你好&#34;</span> <span class="o">==</span> <span class="s">&#34;你好&#34;</span><span class="p">)</span>	<span class="c1">//true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sa&#34;</span> <span class="o">==</span> <span class="s">&#34;sa&#34;</span><span class="p">)</span>	<span class="c1">//true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;SA&#34;</span> <span class="o">==</span> <span class="s">&#34;Sa&#34;</span><span class="p">)</span>	<span class="c1">//false
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>strings.EqualFold：区分utf-8字符在忽略大小写的情况下是否相等，相等返回true，不相等返回false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">EqualFold</span><span class="p">(</span><span class="s">&#34;das&#34;</span><span class="p">,</span><span class="s">&#34;Das&#34;</span><span class="p">))</span>	<span class="c1">//true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">EqualFold</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">,</span><span class="s">&#34;你好&#34;</span><span class="p">))</span>	<span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>strings.Compare：相当于“==”比较，效率更高一些，相等返回0，不相等返回1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">,</span><span class="s">&#34;你好&#34;</span><span class="p">))</span>	<span class="c1">//0
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="s">&#34;das&#34;</span><span class="p">,</span><span class="s">&#34;Das&#34;</span><span class="p">))</span>	<span class="c1">//1
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h1 id="float-比较">float 比较<a hidden class="anchor" aria-hidden="true" href="#float-比较">#</a></h1>
<p>golang 支持两种浮点float32和float64，众所众知，涉及浮点数比较或运算是会遇到精度问题，具体要根据golang实现IEEE 754的情况定。</p>
<p>默认情况下，float32精度是小数后7位，float64精度是小数点后15位。</p>
<p>如例1：</p>
<p>float32</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.00000001</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.000000000001</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.0000001</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.000000000001</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//true
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">)</span>  <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="p">&gt;</span> <span class="nx">d</span><span class="p">)</span>  <span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div><p>float64</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000000000001</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.000000000000000001</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.000000000000001</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000000000000001</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//true
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">)</span>  <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="p">&gt;</span> <span class="nx">d</span><span class="p">)</span>  <span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div><p>这里写了一个根据精度进行float比较的简单的类，注意最大精度为小数点后15位，超出会丢失精度。</p>
<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;math&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Floater</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Accuracy</span> <span class="kt">float64</span>   <span class="c1">//精度,最大为小数点后15位
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//是否相等
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Floater</span><span class="p">)</span> <span class="nf">IsEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Accuracy</span>
<span class="p">}</span>
<span class="c1">//0为相等 1为a大于b -1为a小于b
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Floater</span><span class="p">)</span> <span class="nf">Bccomp</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int8</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Accuracy</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">==</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">Floater</span><span class="p">{</span><span class="nx">Accuracy</span><span class="p">:</span> <span class="mf">0.000000000001</span><span class="p">}</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000002</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000001</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Bccomp</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">//1
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Bccomp</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="c1">//-1
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Bccomp</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="c1">//0
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="指针类型比较">指针类型比较<a hidden class="anchor" aria-hidden="true" href="#指针类型比较">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span> <span class="o">==</span> <span class="nx">c</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当变量是相同或者都为nil时，指针值相等。</p>
<h1 id="interface-比较">interface 比较<a hidden class="anchor" aria-hidden="true" href="#interface-比较">#</a></h1>
<p>两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝=操作相等。</p>
<p>在Go语言中，interface的实际实现结构可以理解为下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819194747.png" alt=""  />
</p>
<p>其中type就是它的类型（动态类型），value部分是它的值（动态值）。</p>
<p>一个interface类型的变量 w 为nil，就代表着其动态类型和动态值都为 nil 。考虑这种情况：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819194805.png" alt=""  />
</p>
<p>图中代表着类型不为空，但是interface的动态值是 nil ，那么这种情况下，如果去判断 w 是否为 nil 时，会得到一个false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>  <span class="c1">//输出 false
</span></code></pre></td></tr></table>
</div>
</div><p>要特别注意这钟情况，因为我们可能会犯这样的错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;done!\n&#34;</span><span class="p">))</span> <span class="c1">// 当w的动态值为nil时，会发生panic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当interface的动态类型是指针的时候，且其动态值不为 nil 时，我们可以理解为其结构如下图所示。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819194939.png" alt=""  />
</p>
<p>这里为什么需要特别拿出来说明呢？因为动态类型为指针的interface的动态值保存的就是一个指针值，这个指针指向一块内存。下面以Golang的error接口来说明这个问题。</p>
<p>下面是error包的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="nx">errorString</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">text</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">text</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里需要理解的：是指针类型 *errorString 实现了error接口，而不是 errorString 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">w1</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
<span class="nx">w2</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w1</span> <span class="o">==</span> <span class="nx">w2</span><span class="p">)</span> <span class="c1">// 输出false
</span></code></pre></td></tr></table>
</div>
</div><p>以 w1 为例子， 由于是指针类型 *errorString 实现了error接口，所以 w1 的动态类型是 *errorString，那么 w1 的动态值就是一个指针，w2 也是同理。那么上面的等于(==)比较我们可以用下图和伪代码来理解。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819195208.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">w1</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="nx">w2</span><span class="p">.</span><span class="kd">type</span> <span class="o">&amp;&amp;</span> <span class="nx">w1</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="nx">w2</span><span class="p">.</span><span class="nx">value</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 w1.value 和 w2.value 都是指针类型，它们又分别保存着不同的内存地址，所以他们的比较是得出 false</p>
<p>也正是这种实现，每个New函数的调用都分配了一个独特的和其他错误不相同的实例，这能方便的让我们可以定义自己特定的错误，就如同Golang定义的 io.EOF 一样，不必担心刚好有相同的错误消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;EOF&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="p">)</span>  <span class="c1">//输出false
</span></code></pre></td></tr></table>
</div>
</div><p>如果想要让<code>w1 := errors.New(&quot;ERR&quot;)</code>和 <code>w2 := errors.New(&quot;ERR&quot;)</code>比较指针指向的真实值呢?需要使用<code>reflect.DeepEqual()</code>函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="nx">w1</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
	<span class="nx">w2</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">w1</span><span class="p">,</span><span class="nx">w2</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>结果返回true</p>
<h1 id="array-比较">array 比较<a hidden class="anchor" aria-hidden="true" href="#array-比较">#</a></h1>
<p>两个数组只要他们包括的元素，每个元素的值相同，则他们相等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">brr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">arr</span><span class="o">==</span><span class="nx">brr</span><span class="p">)</span> <span class="c1">//true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="struct-比较">struct 比较<a hidden class="anchor" aria-hidden="true" href="#struct-比较">#</a></h1>
<p>注意这里指的是相等比较，而不是排序比较，因为struct不是可排序的。</p>
<p>规范里面对struct比较的规则定义：</p>
<p>Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.</p>
<h2 id="类型是否相同">类型是否相同<a hidden class="anchor" aria-hidden="true" href="#类型是否相同">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v11</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v12</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v21</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v22</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v21 is %v\n&#34;, v11 == v21)    // compile error, invalid operation: v11 == v21 (mismatched types T1 and T2)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v22 is %v\n&#34;, v11 == v22)    // compile error, invalid operation: v11 == v22 (mismatched types T1 and T2)
</span><span class="c1"></span>
  <span class="c1">//fmt.Printf(&#34;v12 == v21 is %v\n&#34;, v12 == v21)    // compile error, invalid operation: v12 == v21 (mismatched types T1 and T2)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v12 == v22 is %v\n&#34;, v12 == v22)    // compile error, invalid operation: v12 == v22 (mismatched types T1 and T2)
</span><span class="c1"></span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v21 == v22 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v21</span> <span class="o">==</span> <span class="nx">v22</span><span class="p">)</span>    <span class="c1">// output: v21 == v22 is true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子说明，struct类型不相同时，他们是不可进行比较的，编译器在编译的时候静态检查类型；此例中变量v1x和v2x的类型不相同，一个是T1，另一个是T2，所以他们不能进行比较，虽然他们的内部底层类型一样，因为T1和T2的定义内容是一样的，但是go认定他们是不同的类型。</p>
<p>因为这违背了可比较的第一个限定条件，即变量必须是可赋值的；T1和T2不是可相互赋值的类型。</p>
<p>关于类型相同判断的问题，再举一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
 
<span class="kd">type</span> <span class="nx">Int</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">v11</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">v12</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">v21</span> <span class="nx">Int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">v22</span> <span class="nx">Int</span> <span class="p">=</span> <span class="mi">1</span>
     
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v21 is %v\n&#34;, v11 == v21)    // compile error, invalid operation: v11 == v21 (mismatched types int and Int)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v22 is %v\n&#34;, v11 == v22)    // compile error, invalid operation: v11 == v22 (mismatched types int and Int)
</span><span class="c1"></span>
  <span class="c1">//fmt.Printf(&#34;v12 == v21 is %v\n&#34;, v12 == v21)    // compile error, invalid operation: v12 == v21 (mismatched types int and Int)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v12 == v22 is %v\n&#34;, v12 == v22)    // compile error, invalid operation: v12 == v22 (mismatched types int and Int)
</span><span class="c1"></span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v21 == v22 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v21</span> <span class="o">==</span> <span class="nx">v22</span><span class="p">)</span>    <span class="c1">// output: v21 == v22 is true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子中我们定义了一种新数据类型Int，虽然实际上他就是int，Int只是int的一个wrapper，go语言还是认为他们是不同的数据类型。</p>
<p>如果结构体能够通过强制转换成为相同的结构体,那么他们可以比较:w</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190827104720.png" alt=""  />
</p>
<h2 id="是否所有的域field都可比较">是否所有的域(field)都可比较<a hidden class="anchor" aria-hidden="true" href="#是否所有的域field都可比较">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">;</span> <span class="nx">attrs</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v11</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v12</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v21</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">}</span>
    <span class="nx">v22</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v21 == v22 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v21</span> <span class="o">==</span> <span class="nx">v22</span><span class="p">)</span>    <span class="c1">// compile error: invalid operation: v21 == v22 (struct containing map[string]interface {} cannot be compared)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>按照规范描述类型T2是否可比较需要它的所有域都是可比较的，这里因为T2含有一个attrs域，其类型是map，而map是不可比较的，所以T2不可比较。</p>
<h2 id="包含空域blank-field">包含空域(Blank Field)<a hidden class="anchor" aria-hidden="true" href="#包含空域blank-field">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> 
    <span class="nx">i</span> <span class="kt">int64</span>
    <span class="nx">j</span> <span class="kt">int32</span>
    <span class="nx">_</span> <span class="kt">int32</span>
<span class="p">}</span>

<span class="c1">// About blank field:
</span><span class="c1">// You cannot set or get a blank field; it cannot be refered.
</span><span class="c1">// You can&#39;t do it in a composite literal either.
</span><span class="c1">// The only use for a blank field in a struct is for padding.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v11</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="nx">i</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="nx">j</span><span class="p">:</span><span class="mi">10</span> <span class="p">}</span>
    <span class="nx">v12</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="nx">i</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="nx">j</span><span class="p">:</span><span class="mi">10</span> <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子使用了blank field，可见struct在比较的时候是丢弃blank field的，不管blank field的值是什么；进而我们猜测，go语言内部比较struct类型的逻辑是遍历递归所有的域，针对每个域分别比较，当所有的递归域都返回true时，就返回true，当任何一个返回false时，就返回false；可见struct并不是比较对象地址，也不是比较对象内存块值，而是一个一个域遍历递归比较的，而blank field不可以引用，因而不参与比较。</p>
<h2 id="匿名类型比较">匿名类型比较<a hidden class="anchor" aria-hidden="true" href="#匿名类型比较">#</a></h2>
<p>go语言定义了两种类型：命名类型，和匿名类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;reflect&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v2</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v3</span> <span class="o">:=</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span> <span class="p">{</span><span class="s">&#34;foo&#34;</span><span class="p">}</span>
    <span class="nx">v4</span> <span class="o">:=</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span> <span class="p">{</span><span class="s">&#34;foo&#34;</span><span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v1: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v1</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v1</span><span class="p">))</span> <span class="c1">// v1: type= main.T1 value= {foo}
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v2: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v2</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v2</span><span class="p">))</span> <span class="c1">// v2: type= main.T2 value= {foo}
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v3: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v3</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v3</span><span class="p">))</span> <span class="c1">// v3: type= struct { name string } value= {foo}
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v4: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v4</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v4</span><span class="p">))</span> <span class="c1">// v4: type= struct { name string } value= {foo}
</span><span class="c1"></span>
    <span class="c1">//fmt.Println(v1 == v2) // compiler error: invalid operation: v1 == v2 (mismatched types T1 and T2)
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v1</span> <span class="o">==</span> <span class="nx">v3</span><span class="p">)</span>   <span class="c1">// true, why? their type is different
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v2</span> <span class="o">==</span> <span class="nx">v3</span><span class="p">)</span>   <span class="c1">// true, why?
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v3</span> <span class="o">==</span> <span class="nx">v4</span><span class="p">)</span>   <span class="c1">// true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个地方比较好理解的是v1和v2是不同的类型，一个是T1一个是T2，前面我们讲过虽然T1和T2底层类型一样，但是go认为他们就是不同的类型。</p>
<p>然后v3和v4也好理解，他们的类型是一样的匿名类型。</p>
<p>不好理解的是v1和v3，v2和v3明明他们的类型是不一样的，为什么输出true呢？</p>
<p>要回答这个问题，我们还是回到规范定义上面</p>
<p>Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.</p>
<p>关于struct是否可比较，只看一点，是不是他的所有域都是可比较的，在这个例子总，只有一个域即name string，它是可比较的，所以这一条是满足的，即此struct是可比较的。</p>
<p>再看规范里的另一条定义，这条定义是针对通用变量的，不只是struct</p>
<p>In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.</p>
<p>只有这条规则也能满足的时候，两个变量才可以比较；在我们例子中v1和v2就不满足这条，所以不可比较，而v3和v4是满足这条的，所以v3和v4是可比较的。</p>
<h2 id="总结struct的比较">总结：struct的比较<a hidden class="anchor" aria-hidden="true" href="#总结struct的比较">#</a></h2>
<p>struct的比较只需要满足两个条件：</p>
<ol>
<li>从所有比较操作继承下来的规则，即两个变量必须是可赋值的。</li>
<li>针对struct本身的规则，即struct的所有域必须都是可比较的；注意这里并不管struct本身的定义类型。</li>
</ol>
<p>只要满足这两个条件，struct就是可比较的；可见并没有限定两个struct的类型必须一致，从而解释了命名类型和匿名类型struct的比较规则，就是它并不管名字，反之都是struct类型就行</p>
<h1 id="timetime-比较">time.time 比较<a hidden class="anchor" aria-hidden="true" href="#timetime-比较">#</a></h1>
<p>先把当前时间格式化成相同格式的字符串,然后使用time的Before, After, Equal 方法即可.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">time1</span> <span class="o">:=</span> <span class="s">&#34;2015-03-20 08:50:29&#34;</span>
    <span class="nx">time2</span> <span class="o">:=</span> <span class="s">&#34;2015-03-21 09:04:25&#34;</span>
    <span class="c1">//先把时间字符串格式化成相同的时间类型
</span><span class="c1"></span>    <span class="nx">t1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">,</span> <span class="nx">time1</span><span class="p">)</span>
    <span class="nx">t2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">,</span> <span class="nx">time2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">t1</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">t2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//处理逻辑
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;true&#34;</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="deepequal">DeepEqual<a hidden class="anchor" aria-hidden="true" href="#deepequal">#</a></h1>
<p>slice/struct/map 这三个都可以用reflect.DeepEqual来判断是否相等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s1</span> <span class="o">:=</span> <span class="nx">S</span><span class="p">{</span><span class="nx">s</span><span class="p">:</span> <span class="s">&#34;hello&#34;</span><span class="p">}</span>
    <span class="nx">s2</span> <span class="o">:=</span> <span class="nx">S</span><span class="p">{</span><span class="nx">s</span><span class="p">:</span> <span class="s">&#34;hello&#34;</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="s">&#34;==&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">a1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="nx">a2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="nx">a2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="s">&#34;==&#34;</span><span class="p">,</span> <span class="nx">a2</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">m1</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;b&#34;</span><span class="p">}</span>
    <span class="nx">m2</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;b&#34;</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="s">&#34;==&#34;</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但因为reflect.DeepEqual的性能不好,实际上只针对特定环境使用.详情参加另一篇博文</p>
<p>参考:<br>
<a href="https://studygolang.com/articles/11342https://studygolang.com/articles/11342">https://studygolang.com/articles/11342</a>
<a href="https://blog.csdn.net/double_happiness/article/details/80098816">https://blog.csdn.net/double_happiness/article/details/80098816</a><br>
<a href="https://www.veaxen.com/golang%E6%8E%A5%E5%8F%A3%E5%80%BC%EF%BC%88interface%EF%BC%89%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90.html">https://www.veaxen.com/golang%E6%8E%A5%E5%8F%A3%E5%80%BC%EF%BC%88interface%EF%BC%89%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90.html</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
