<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go中的内置类型比较 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go中的内置类型比较" />
<meta property="og:description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/" />
<meta property="article:published_time" content="2019-08-16T16:25:53+00:00" />
<meta property="article:modified_time" content="2019-08-16T16:25:53+00:00" />
<meta itemprop="name" content="Go中的内置类型比较">
<meta itemprop="description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A">
<meta itemprop="datePublished" content="2019-08-16T16:25:53&#43;00:00" />
<meta itemprop="dateModified" content="2019-08-16T16:25:53&#43;00:00" />
<meta itemprop="wordCount" content="4999">



<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的内置类型比较"/>
<meta name="twitter:description" content="概念 首先区分几个概念：变量可比较，可排序，可赋值 可赋值 规范里面对赋值是这么定义的：https://golang.org/ref/spec#A"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go中的内置类型比较</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-08-16 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 4999 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#可赋值">可赋值</a></li>
    <li><a href="#可比较">可比较</a></li>
    <li><a href="#可赋值和可比较的关系">可赋值和可比较的关系</a></li>
  </ul>

  <ul>
    <li><a href="#类型是否相同">类型是否相同</a></li>
    <li><a href="#是否所有的域field都可比较">是否所有的域(field)都可比较</a></li>
    <li><a href="#包含空域blank-field">包含空域(Blank Field)</a></li>
    <li><a href="#匿名类型比较">匿名类型比较</a></li>
    <li><a href="#总结struct的比较">总结：struct的比较</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="概念">概念</h1>
<p>首先区分几个概念：变量可比较，可排序，可赋值</p>
<h2 id="可赋值">可赋值</h2>
<p>规范里面对赋值是这么定义的：https://golang.org/ref/spec#Assignability</p>
<p>A value x is assignable to a variable of type T (&ldquo;x is assignable to T&rdquo;) in any of these cases:</p>
<ul>
<li>x&rsquo;s type is identical to T.</li>
<li>x&rsquo;s type V and T have identical underlying types and at least one of V or T is not a defined type.</li>
<li>T is an interface type and x implements T.</li>
<li>x is a bidirectional channel value, T is a channel type, x&rsquo;s type V and T have identical element types, and at least one of V or T is not a defined type.</li>
<li>x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type.</li>
<li>x is an untyped constant representable by a value of type T.</li>
</ul>
<p>概括起来就是他们的类型需要满足某种条件，或者类型相同，或者底层类型(underlying types)相同。</p>
<h2 id="可比较">可比较</h2>
<p>规范里面对比较操作是这么定义的：https://golang.org/ref/spec#Comparison_operators</p>
<p>可比较又可以分为两个小类</p>
<ol>
<li>可比较，包括相等(==)，和不相等(!=)</li>
<li>可排序，包括大于(&gt;)，大于等于(&gt;=)，小于(&gt;)，小于等于(&lt;=)</li>
</ol>
<p>可排序的一定是可比较的，反之不成立，即可比较的不一定是可排序的，例如struct类型就是可比较的，但不可排序。</p>
<ol>
<li>可排序的数据类型有三种，Integer，Floating-point，和String</li>
<li>可比较的数据类型除了上述三种外，还有Boolean，Complex，Pointer，Channel，Interface，Struct，和Array</li>
<li>不可比较的数据类型包括，Slice, Map, 和Function</li>
</ol>
<p>上述规范里面对哪种数据类型如何进行比较，如何相等都做了描述，不细说，请参考原文。</p>
<p>至于如何定义他们相等的规则，也请参考上述规范文档。</p>
<h2 id="可赋值和可比较的关系">可赋值和可比较的关系</h2>
<p>规范里是这么说的：</p>
<p>In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.</p>
<p>也就是说如果两个变量可比较，那么他们必然是可赋值的，要么左边变量可赋值给右边变量，要么右边变量可赋值给左边变量。反之则不一定，即可赋值的变量，不一定可比较，比如前面提到的map类型变量。</p>
<p>所以两个可比较的变量，也必须满足他们或者类型相同，或者他们的底层类型(underlying types)相同。</p>
<p>两个变量是否可比较这个规则是在编译的时候由编译器负责静态检查的。</p>
<h1 id="string-比较">string 比较</h1>
<ol>
<li>
<p>“==”：逐个比较且不分大小写，相等返回true，不相等返回false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;你好&#34;</span> <span class="o">==</span> <span class="s">&#34;你好&#34;</span><span class="p">)</span>	<span class="c1">//true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sa&#34;</span> <span class="o">==</span> <span class="s">&#34;sa&#34;</span><span class="p">)</span>	<span class="c1">//true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;SA&#34;</span> <span class="o">==</span> <span class="s">&#34;Sa&#34;</span><span class="p">)</span>	<span class="c1">//false
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>strings.EqualFold：区分utf-8字符在忽略大小写的情况下是否相等，相等返回true，不相等返回false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">EqualFold</span><span class="p">(</span><span class="s">&#34;das&#34;</span><span class="p">,</span><span class="s">&#34;Das&#34;</span><span class="p">))</span>	<span class="c1">//true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">EqualFold</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">,</span><span class="s">&#34;你好&#34;</span><span class="p">))</span>	<span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>strings.Compare：相当于“==”比较，效率更高一些，相等返回0，不相等返回1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">,</span><span class="s">&#34;你好&#34;</span><span class="p">))</span>	<span class="c1">//0
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="s">&#34;das&#34;</span><span class="p">,</span><span class="s">&#34;Das&#34;</span><span class="p">))</span>	<span class="c1">//1
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h1 id="float-比较">float 比较</h1>
<p>golang 支持两种浮点float32和float64，众所众知，涉及浮点数比较或运算是会遇到精度问题，具体要根据golang实现IEEE 754的情况定。</p>
<p>默认情况下，float32精度是小数后7位，float64精度是小数点后15位。</p>
<p>如例1：</p>
<p>float32</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.00000001</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.000000000001</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.0000001</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">1.000000000001</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//true
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">)</span>  <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="p">&gt;</span> <span class="nx">d</span><span class="p">)</span>  <span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div><p>float64</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000000000001</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.000000000000000001</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.000000000000001</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000000000000001</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//true
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">)</span>  <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">//false
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span> <span class="p">&gt;</span> <span class="nx">d</span><span class="p">)</span>  <span class="c1">//true
</span></code></pre></td></tr></table>
</div>
</div><p>这里写了一个根据精度进行float比较的简单的类，注意最大精度为小数点后15位，超出会丢失精度。</p>
<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;math&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Floater</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Accuracy</span> <span class="kt">float64</span>   <span class="c1">//精度,最大为小数点后15位
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//是否相等
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Floater</span><span class="p">)</span> <span class="nf">IsEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Accuracy</span>
<span class="p">}</span>
<span class="c1">//0为相等 1为a大于b -1为a小于b
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Floater</span><span class="p">)</span> <span class="nf">Bccomp</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int8</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Accuracy</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">==</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">Floater</span><span class="p">{</span><span class="nx">Accuracy</span><span class="p">:</span> <span class="mf">0.000000000001</span><span class="p">}</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000002</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">1.0000000001</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Bccomp</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">//1
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Bccomp</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="c1">//-1
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Bccomp</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="c1">//0
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="指针类型比较">指针类型比较</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span> <span class="o">==</span> <span class="nx">c</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当变量是相同或者都为nil时，指针值相等。</p>
<h1 id="interface-比较">interface 比较</h1>
<p>两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝=操作相等。</p>
<p>在Go语言中，interface的实际实现结构可以理解为下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819194747.png" alt=""></p>
<p>其中type就是它的类型（动态类型），value部分是它的值（动态值）。</p>
<p>一个interface类型的变量 w 为nil，就代表着其动态类型和动态值都为 nil 。考虑这种情况：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819194805.png" alt=""></p>
<p>图中代表着类型不为空，但是interface的动态值是 nil ，那么这种情况下，如果去判断 w 是否为 nil 时，会得到一个false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>  <span class="c1">//输出 false
</span></code></pre></td></tr></table>
</div>
</div><p>要特别注意这钟情况，因为我们可能会犯这样的错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;done!\n&#34;</span><span class="p">))</span> <span class="c1">// 当w的动态值为nil时，会发生panic
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当interface的动态类型是指针的时候，且其动态值不为 nil 时，我们可以理解为其结构如下图所示。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819194939.png" alt=""></p>
<p>这里为什么需要特别拿出来说明呢？因为动态类型为指针的interface的动态值保存的就是一个指针值，这个指针指向一块内存。下面以Golang的error接口来说明这个问题。</p>
<p>下面是error包的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="nx">errorString</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">text</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">text</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里需要理解的：是指针类型 *errorString 实现了error接口，而不是 errorString 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">w1</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
<span class="nx">w2</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w1</span> <span class="o">==</span> <span class="nx">w2</span><span class="p">)</span> <span class="c1">// 输出false
</span></code></pre></td></tr></table>
</div>
</div><p>以 w1 为例子， 由于是指针类型 *errorString 实现了error接口，所以 w1 的动态类型是 *errorString，那么 w1 的动态值就是一个指针，w2 也是同理。那么上面的等于(==)比较我们可以用下图和伪代码来理解。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190819195208.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">w1</span><span class="p">.</span><span class="kd">type</span> <span class="o">==</span> <span class="nx">w2</span><span class="p">.</span><span class="kd">type</span> <span class="o">&amp;&amp;</span> <span class="nx">w1</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="nx">w2</span><span class="p">.</span><span class="nx">value</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 w1.value 和 w2.value 都是指针类型，它们又分别保存着不同的内存地址，所以他们的比较是得出 false</p>
<p>也正是这种实现，每个New函数的调用都分配了一个独特的和其他错误不相同的实例，这能方便的让我们可以定义自己特定的错误，就如同Golang定义的 io.EOF 一样，不必担心刚好有相同的错误消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;EOF&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="p">)</span>  <span class="c1">//输出false
</span></code></pre></td></tr></table>
</div>
</div><p>如果想要让<code>w1 := errors.New(&quot;ERR&quot;)</code>和 <code>w2 := errors.New(&quot;ERR&quot;)</code>比较指针指向的真实值呢?需要使用<code>reflect.DeepEqual()</code>函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">w1</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
	<span class="nx">w2</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ERR&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">w1</span><span class="p">,</span><span class="nx">w2</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>结果返回true</p>
<h1 id="array-比较">array 比较</h1>
<p>两个数组只要他们包括的元素，每个元素的值相同，则他们相等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">brr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">arr</span><span class="o">==</span><span class="nx">brr</span><span class="p">)</span> <span class="c1">//true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="struct-比较">struct 比较</h1>
<p>注意这里指的是相等比较，而不是排序比较，因为struct不是可排序的。</p>
<p>规范里面对struct比较的规则定义：</p>
<p>Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.</p>
<h2 id="类型是否相同">类型是否相同</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v11</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v12</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v21</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v22</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v21 is %v\n&#34;, v11 == v21)    // compile error, invalid operation: v11 == v21 (mismatched types T1 and T2)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v22 is %v\n&#34;, v11 == v22)    // compile error, invalid operation: v11 == v22 (mismatched types T1 and T2)
</span><span class="c1"></span>
  <span class="c1">//fmt.Printf(&#34;v12 == v21 is %v\n&#34;, v12 == v21)    // compile error, invalid operation: v12 == v21 (mismatched types T1 and T2)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v12 == v22 is %v\n&#34;, v12 == v22)    // compile error, invalid operation: v12 == v22 (mismatched types T1 and T2)
</span><span class="c1"></span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v21 == v22 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v21</span> <span class="o">==</span> <span class="nx">v22</span><span class="p">)</span>    <span class="c1">// output: v21 == v22 is true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子说明，struct类型不相同时，他们是不可进行比较的，编译器在编译的时候静态检查类型；此例中变量v1x和v2x的类型不相同，一个是T1，另一个是T2，所以他们不能进行比较，虽然他们的内部底层类型一样，因为T1和T2的定义内容是一样的，但是go认定他们是不同的类型。</p>
<p>因为这违背了可比较的第一个限定条件，即变量必须是可赋值的；T1和T2不是可相互赋值的类型。</p>
<p>关于类型相同判断的问题，再举一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
 
<span class="kd">type</span> <span class="nx">Int</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">v11</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">v12</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">v21</span> <span class="nx">Int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">v22</span> <span class="nx">Int</span> <span class="p">=</span> <span class="mi">1</span>
     
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v21 is %v\n&#34;, v11 == v21)    // compile error, invalid operation: v11 == v21 (mismatched types int and Int)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v11 == v22 is %v\n&#34;, v11 == v22)    // compile error, invalid operation: v11 == v22 (mismatched types int and Int)
</span><span class="c1"></span>
  <span class="c1">//fmt.Printf(&#34;v12 == v21 is %v\n&#34;, v12 == v21)    // compile error, invalid operation: v12 == v21 (mismatched types int and Int)
</span><span class="c1"></span>  <span class="c1">//fmt.Printf(&#34;v12 == v22 is %v\n&#34;, v12 == v22)    // compile error, invalid operation: v12 == v22 (mismatched types int and Int)
</span><span class="c1"></span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v21 == v22 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v21</span> <span class="o">==</span> <span class="nx">v22</span><span class="p">)</span>    <span class="c1">// output: v21 == v22 is true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子中我们定义了一种新数据类型Int，虽然实际上他就是int，Int只是int的一个wrapper，go语言还是认为他们是不同的数据类型。</p>
<p>如果结构体能够通过强制转换成为相同的结构体,那么他们可以比较:w</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190827104720.png" alt=""></p>
<h2 id="是否所有的域field都可比较">是否所有的域(field)都可比较</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">;</span> <span class="nx">attrs</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v11</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v12</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v21</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">}</span>
    <span class="nx">v22</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v21 == v22 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v21</span> <span class="o">==</span> <span class="nx">v22</span><span class="p">)</span>    <span class="c1">// compile error: invalid operation: v21 == v22 (struct containing map[string]interface {} cannot be compared)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>按照规范描述类型T2是否可比较需要它的所有域都是可比较的，这里因为T2含有一个attrs域，其类型是map，而map是不可比较的，所以T2不可比较。</p>
<h2 id="包含空域blank-field">包含空域(Blank Field)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> 
    <span class="nx">i</span> <span class="kt">int64</span>
    <span class="nx">j</span> <span class="kt">int32</span>
    <span class="nx">_</span> <span class="kt">int32</span>
<span class="p">}</span>

<span class="c1">// About blank field:
</span><span class="c1">// You cannot set or get a blank field; it cannot be refered.
</span><span class="c1">// You can&#39;t do it in a composite literal either.
</span><span class="c1">// The only use for a blank field in a struct is for padding.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v11</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="nx">i</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="nx">j</span><span class="p">:</span><span class="mi">10</span> <span class="p">}</span>
    <span class="nx">v12</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="nx">i</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="nx">j</span><span class="p">:</span><span class="mi">10</span> <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v11 == v12 is %v\n&#34;</span><span class="p">,</span> <span class="nx">v11</span> <span class="o">==</span> <span class="nx">v12</span><span class="p">)</span>    <span class="c1">// output: v11 == v12 is true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个例子使用了blank field，可见struct在比较的时候是丢弃blank field的，不管blank field的值是什么；进而我们猜测，go语言内部比较struct类型的逻辑是遍历递归所有的域，针对每个域分别比较，当所有的递归域都返回true时，就返回true，当任何一个返回false时，就返回false；可见struct并不是比较对象地址，也不是比较对象内存块值，而是一个一个域遍历递归比较的，而blank field不可以引用，因而不参与比较。</p>
<h2 id="匿名类型比较">匿名类型比较</h2>
<p>go语言定义了两种类型：命名类型，和匿名类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;reflect&#34;</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="o">:=</span> <span class="nx">T1</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v2</span> <span class="o">:=</span> <span class="nx">T2</span> <span class="p">{</span> <span class="s">&#34;foo&#34;</span> <span class="p">}</span>
    <span class="nx">v3</span> <span class="o">:=</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span> <span class="p">{</span><span class="s">&#34;foo&#34;</span><span class="p">}</span>
    <span class="nx">v4</span> <span class="o">:=</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">name</span> <span class="kt">string</span> <span class="p">}</span> <span class="p">{</span><span class="s">&#34;foo&#34;</span><span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v1: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v1</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v1</span><span class="p">))</span> <span class="c1">// v1: type= main.T1 value= {foo}
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v2: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v2</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v2</span><span class="p">))</span> <span class="c1">// v2: type= main.T2 value= {foo}
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v3: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v3</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v3</span><span class="p">))</span> <span class="c1">// v3: type= struct { name string } value= {foo}
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;v4: type=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v4</span><span class="p">),</span> <span class="s">&#34;value=&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v4</span><span class="p">))</span> <span class="c1">// v4: type= struct { name string } value= {foo}
</span><span class="c1"></span>
    <span class="c1">//fmt.Println(v1 == v2) // compiler error: invalid operation: v1 == v2 (mismatched types T1 and T2)
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v1</span> <span class="o">==</span> <span class="nx">v3</span><span class="p">)</span>   <span class="c1">// true, why? their type is different
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v2</span> <span class="o">==</span> <span class="nx">v3</span><span class="p">)</span>   <span class="c1">// true, why?
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v3</span> <span class="o">==</span> <span class="nx">v4</span><span class="p">)</span>   <span class="c1">// true
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个地方比较好理解的是v1和v2是不同的类型，一个是T1一个是T2，前面我们讲过虽然T1和T2底层类型一样，但是go认为他们就是不同的类型。</p>
<p>然后v3和v4也好理解，他们的类型是一样的匿名类型。</p>
<p>不好理解的是v1和v3，v2和v3明明他们的类型是不一样的，为什么输出true呢？</p>
<p>要回答这个问题，我们还是回到规范定义上面</p>
<p>Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.</p>
<p>关于struct是否可比较，只看一点，是不是他的所有域都是可比较的，在这个例子总，只有一个域即name string，它是可比较的，所以这一条是满足的，即此struct是可比较的。</p>
<p>再看规范里的另一条定义，这条定义是针对通用变量的，不只是struct</p>
<p>In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.</p>
<p>只有这条规则也能满足的时候，两个变量才可以比较；在我们例子中v1和v2就不满足这条，所以不可比较，而v3和v4是满足这条的，所以v3和v4是可比较的。</p>
<h2 id="总结struct的比较">总结：struct的比较</h2>
<p>struct的比较只需要满足两个条件：</p>
<ol>
<li>从所有比较操作继承下来的规则，即两个变量必须是可赋值的。</li>
<li>针对struct本身的规则，即struct的所有域必须都是可比较的；注意这里并不管struct本身的定义类型。</li>
</ol>
<p>只要满足这两个条件，struct就是可比较的；可见并没有限定两个struct的类型必须一致，从而解释了命名类型和匿名类型struct的比较规则，就是它并不管名字，反之都是struct类型就行</p>
<h1 id="timetime-比较">time.time 比较</h1>
<p>先把当前时间格式化成相同格式的字符串,然后使用time的Before, After, Equal 方法即可.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">time1</span> <span class="o">:=</span> <span class="s">&#34;2015-03-20 08:50:29&#34;</span>
    <span class="nx">time2</span> <span class="o">:=</span> <span class="s">&#34;2015-03-21 09:04:25&#34;</span>
    <span class="c1">//先把时间字符串格式化成相同的时间类型
</span><span class="c1"></span>    <span class="nx">t1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">,</span> <span class="nx">time1</span><span class="p">)</span>
    <span class="nx">t2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">,</span> <span class="nx">time2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">t1</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">t2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//处理逻辑
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;true&#34;</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="deepequal">DeepEqual</h1>
<p>slice/struct/map 这三个都可以用reflect.DeepEqual来判断是否相等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s1</span> <span class="o">:=</span> <span class="nx">S</span><span class="p">{</span><span class="nx">s</span><span class="p">:</span> <span class="s">&#34;hello&#34;</span><span class="p">}</span>
    <span class="nx">s2</span> <span class="o">:=</span> <span class="nx">S</span><span class="p">{</span><span class="nx">s</span><span class="p">:</span> <span class="s">&#34;hello&#34;</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="s">&#34;==&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">a1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="nx">a2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="nx">a2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="s">&#34;==&#34;</span><span class="p">,</span> <span class="nx">a2</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">m1</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;b&#34;</span><span class="p">}</span>
    <span class="nx">m2</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;b&#34;</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="s">&#34;==&#34;</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但因为reflect.DeepEqual的性能不好,实际上只针对特定环境使用.详情参加另一篇博文</p>
<p>参考:<br>
<a href="https://studygolang.com/articles/11342https://studygolang.com/articles/11342">https://studygolang.com/articles/11342</a>
<a href="https://blog.csdn.net/double_happiness/article/details/80098816">https://blog.csdn.net/double_happiness/article/details/80098816</a><br>
<a href="https://www.veaxen.com/golang%E6%8E%A5%E5%8F%A3%E5%80%BC%EF%BC%88interface%EF%BC%89%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90.html">https://www.veaxen.com/golang%E6%8E%A5%E5%8F%A3%E5%80%BC%EF%BC%88interface%EF%BC%89%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90.html</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-08-16
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E4%B8%ADmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go中map的使用方式</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/">
            <span class="next-text nav-default">Go语言的浮点数计算</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
