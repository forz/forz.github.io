<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>负载均衡P2C&#43;EWMA算法 | Forz Blog</title>
<meta name="keywords" content="算法" />
<meta name="description" content="P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Con">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c&#43;ewma%E7%AE%97%E6%B3%95/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="负载均衡P2C&#43;EWMA算法" />
<meta property="og:description" content="P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Con" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c&#43;ewma%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-24T11:29:23&#43;00:00" />
<meta property="article:modified_time" content="2021-01-24T11:29:23&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="负载均衡P2C&#43;EWMA算法"/>
<meta name="twitter:description" content="P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Con"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "负载均衡P2C+EWMA算法",
      "item": "/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c+ewma%E7%AE%97%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "负载均衡P2C+EWMA算法",
  "name": "负载均衡P2C\u002bEWMA算法",
  "description": "P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Con",
  "keywords": [
    "算法"
  ],
  "articleBody": "P2C算法 介绍 常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Consistent hash等应该都耳熟能详，这些算法都在实践中有广泛的应用，例如Nginx、Haproxy等负载均衡模块都有相应算法的实现。本文将和大家分享一种全新的Load balance算法：Power of Two Random Choices，也算是Fast 2019 best paper解读《Distcache: Provable load balancing for large-scale storage systems with distributed caching》 的续篇，DistCache利用Power of two random choices实现Cache Query的Load balance：就是在查询Cache中item的时候，从命中的2个Cache节点中选择负载较低的Cache节点来服务；实现简单，效果却不简单。除此之外，新版本的Nginx和Haproxy最近都增加了对Power of Two Random Choices算法的支持，可见一斑。\n本文将从Power of Two Random Choices算法的起源说起（也就是数学里面经典的Balls into Bins问题），向大家展示Power of Two Random Choices算法背后的数学原理。并介绍其在解决Hash冲突中的应用，想必能进一步加深大家对Cuckoo Hash、BloomFilter等使用多个hash function做法的理解。\nBalls into Bins 首先看数学一个经典的Balls into Bins问题：\n假如顺序地将n个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择任意一个bin\n那么当抛球结束的时候，以非常高的概率（ 也就是以概率1-ｏ(1)），n个bin中最大负载为(1+ｏ(1))logn/loglogn个balls。注意o(1)指的是高阶无穷小，可以直接忽略掉。\n这实际上就是一个无状态的Load balance问题，考虑一个负载均衡器（LB）将n个请求随机等概率的发送给n个Server，那么就可以知道Server上最大的可能负载会是多少。\nPower of two random choices 如果选择上做一个小改动，也就是今天要说的Power of two random choices：\n假如顺序地将n个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择d个bin，然后选择Ball最少的bin放入\n那么当抛球结束的时候，将以非常高的概率（ 也就是以概率1-ｏ(1)），n个bin中最大负载为(1+ｏ(1))loglogn/logd+Ｏ(1)个balls。\n现在情况Balls的数量往往远大于Bins的数量，所以扩展一下：\n假如顺序地将m个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择d个bin，然后选择Ball最少的bin放入，其中m=n，d=2\n下面给出一个一组计算的算例，分别m=n={2^2,2^3,2^4……,2^64}，其中红色为普通的Balls into Bins问题的最大负载，蓝色为Power of two random choices d=2情况下的最大负载：\n通过上图可以发现，Power of two random choices负载均衡的效果是不错的。尽管上面的模型太过理想，假定了所有的key都是必须均匀分布，每个request的size都是相同，和实际生产环境相差巨大，但仍然不妨碍我们认定这种做法的有效性。\nApp Load balance 得益于Power of Two Random Choices的实现简单和效果良好，开源的NGINX在版本1.15.1中开始支持，Haproxy也在2.0版本中开始支持，且将其替换成了默认的随机算法，文献中Haproxy有一些对比测试，大家可以参考。\nHash 如果使用这种方法来解决Hash冲突，以开链（separate chaining）法为例，如果每次选择哈希映射的桶时，通过两个hash function随机挑出两个桶，并从中选择链表长度相对更短的桶插入[10]（如下图），根据Power of Two Rand Choices理论，那么每个hash bucket的开链长度肯定会更加均衡。\n实际上回过头来看Cuckoo Hash、BloomFilter设计多个hash function是有道理的。\n如上图，是一个Cuckoo Hash一种典型实现，通过两个hash函数来映射key，且每个bucket都可以存放多个items，实际上根据Power of Two Random Choices的原理，这样，可以使得每个bucket的冲突更加均衡，从而可以在设计Cuckoo hash的时候设置较小的Bucket容量，避免空间浪费，或者换一个角度，可以延迟resize hash的发生。\nSummary Power of two random choices尽管是一种理想的理论模型，但是方法和思路仍然可以作为生产实践的指导，这也大概是理论研究的意义所在。\n负载均衡 P2C算法通过随机选择两个节点后在这俩节点里选择优胜者来避免羊群效应，并通过指数加权移动平均算法统计服务端的实时状态，从而做出最优选择。\n工作流程 $M=inflightweightlatency$\nP2C算法下的每个节点（下称Node）必须含有下方图中几个指标，它们的计算方法已经标出：\n因此最终loadbalancer里保存的节点就会变成下图的结构，pick节点时需要做如下比较：\n通过上面的流程可以看到，大体流程还是随机，相比普通的随机LB，它是随机选择两个node，然后比较它们的负载率，然后选出当前负载率最小的node。\n数据统计 通过上面的简单介绍，可以知道P2C算法的大体流程，那么现在问题就变得简单多了，只需要知道负载率，就可以完成这个“简单”的负载均衡器，但是负载率是由上图五个指标共同参与计算完成的，那现在问题的关键就是如何完成这五个指标的统计，下面来介绍下这五个指标如何计算。\nweight 这个很简单，主要是人为配置的定制，用于给不同的机器按照机器配置分配上不同的权重，权重越高，越容易被pick到。这个值可以做在服务注册与发现里，进行为每个节点分配一个权重值。\nserver_cpu 这个值可以通过服务端回写元数据来搞定，比如一次请求：\n所以这个值可以通过服务端埋点的方式解决掉。\ninflight 这个代表节点请求拥塞度，代表着当前节点有多少个请求未完成或者正开始请求，它的统计也很简单：\n按照这种，每次pick到发送请求前先原子+1，response后说明一次请求完成，这时再原子-1，这样一增一减，在超多线程pick下（即高qps），当前线程获取到的inflight瞬间值，就是在这个时段的拥塞度，比如一个节点如果很闲，响应速度也快，那么它的拥塞度肯定极低（因为一增一减的操作很快就完成，不会淤积过多）。\nlatency \u0026 client_success 前面的都很好了理解，这俩属性比较麻烦，它们分别代表请求延迟率和成功率。\n这俩值该怎么计算？一般来说是通过平均数的方式来计算，但计算平均数的方式有很多，可以先用我们最熟悉的算术平均数来计算，它的计算公式如下：\n利用此算法套入我们的场景后，请求总耗时比上请求总次数，就是latency：\n请求总成功数比上请求总次数，就是client_success：\n整个过程可以抽象成下面这样：\n根据图5的流程，可以通过每次请求，累加总请求数、总耗时、总成功数，然后利用算术平均法更新latency和client_success的值，这一切可以运作的很好，可是算术平均有个很大的缺陷，不够敏感，出现的网络波动一下就被平均了.\n算术平均数模拟 首先模拟1000次请求，让每次请求在0~25之间产生随机数用来作为本次请求的耗时（为了模拟真实情况，让一些请求耗时过高），每次请求计算当前的算术平均数，然后可以得到下面的统计图：\n可以看到，正常情况下，算术平均数表现出很好的稳定性，红线一致维持在黑线的中间，且浮动不大。\n现在让我们搞点事情，假设在第100次请求到第200次请求间，模拟下网络抖动，让这期间的响应时间变成125ms（相比正常情况翻五倍），得到统计图如下：\n可以看到平均数受到这次抖动的影响，需要非常长的时间才能感知到抖动的到来，然后恢复时又需要花很长时间才能恢复到抖动前的较正常的水平，也就是说，第100~200间的100次慢请求，不光要到140次请求后才能较明显的感知平均值的上涨，还导致网络恢复后，到第1000次请求时，平均值还没有恢复到正常水平（但其实从第200次请求后，响应时间就正常了），算术平均数导致的这类问题显然是很严重的，因为我需要的算法是可以立马感知到网络波动，网络恢复后又可以在较短的时间内恢复正常水平。\n有没有更好的统计办法来避免这类问题并且达到我们的要求呢？\nEWMA算法 概述 　加权移动平均法，是对观察值分别给予不同的权数，按不同权数求得移动平均值，并以最后的移动平均值为基础，确定预测值的方法。采用加权移动平均法，是因为观察期的近期观察值对预测值有较大影响，它更能反映近期变化的趋势。\n指数移动加权平均法，是指各数值的加权系数随时间呈指数式递减，越靠近当前时刻的数值加权系数就越大。\n指数移动加权平均较传统的平均法来说，一是不需要保存过去所有的数值；二是计算量显著减小。\n算法理解 引入一个例子，例子为美国一年内每天的温度分布情况，具体如下图所示\nEWMA 的表达式如下：\n𝑣𝑡=𝛽𝑣𝑡−1+(1−𝛽)𝜃𝑡\n上式中 𝜃𝑡 为时刻 𝑡 的实际温度；系数 𝛽 表示加权下降的速率，其值越小下降的越快；𝑣𝑡 为 𝑡 时刻 EWMA 的值。\n在上图中有两条不同颜色的线，分别对应着不同的 𝛽 值。\n当 𝛽=0.9 时，有 𝑣𝑡=0.9𝑣𝑡−1+0.1𝜃𝑡 ，对应着图中的红线，此时虽然曲线有些波动，但总体能拟合真实数据\n当 𝛽=0.98 时，有 𝑣𝑡=0.98𝑣𝑡−1+0.02𝜃𝑡 ，对应着图中的绿线，此时曲线较平，但却有所偏离真实数据\n在 𝑡=0 时刻，一般初始化 𝑣0=0 ，对 EWMA 的表达式进行归纳可以将 𝑡 时刻的表达式写成：\n𝑣𝑡=(1−𝛽)(𝜃𝑡+𝛽𝜃𝑡−1+…+𝛽𝑡−1𝜃1)\n从上面式子中可以看出，数值的加权系数随着时间呈指数下降。在数学中一般会以 1/𝑒 来作为一个临界值，小于该值的加权系数的值不作考虑，接着来分析上面 𝛽=0.9 和 𝛽=0.98 的情况。\n当 𝛽=0.9 时，0.9^10 约等于 1/𝑒 ，因此认为此时是近10个数值的加权平均。\n当 𝛽=0.98 时，0.9^50 约等于 1/𝑒，因此认为此时是近50个数值的加权平均。这种情况也正是移动加权平均的来源。\n具体的分析如下图所示：\n偏差修正 在初始化 𝑣0=0 时实际上会存在一个问题。具体的如下图所示：\n从上图中可以看出有一条绿色和紫色的曲线，都是对应于 𝛽=0.98 时的曲线。理想状况下应该是绿色的曲线，但当初始化 𝑣0=0 时却会得到紫色的曲线，这是因为初始化的值太小，导致初期的数值都偏小，而随着时间的增长，初期的值的影响减小，紫色的曲线就慢慢和绿色的曲线重合。我们对公式做一些修改：\n当 𝑡 很小时，分母可以很好的放大当前的数值；当 𝑡 很大时，分母的数值趋于1，对当前数值几乎没有影响。\nEWMA 主要是被应用在动量优化算法中，比如Adam算法中的一阶矩和二阶矩都采用了上面修改后的EWMA算法。\nEWMA模拟 公式如下：\n解释：vt代表第t次请求的指数加权平均耗时，vt-1代表上次请求的指数加权平均耗时，θt代表第t次请求的实际耗时。\nβ值的定义如下：\nvt ≈ 1/(1 - β) \u0008次的平均耗时\n例：假设β等于0.9，1/(1 - β) 就等于10，也就是vt约等于它前10次请求的平均耗时；假设把β值调大道接近1，例如，将β等于0.98，1/(1-β)=50，按照刚刚的说法也就是当前请求的前50次请求的平均耗时。\n由此可以推导出：\nβ值越大，统计区间越大，当前平均值的计算受到之前平均值的影响也就越大（曲线越平滑，呈现一个平缓的变化趋势）\nβ值越小，统计区间越小，当前平均值的计算受到之前平均值的影响也就越小（曲线贴近统计原值）\nβ极小时，便可以认为当次的平均耗时约等于当次本身的实际耗时。\n上面的结论接下来会通过实验来进行验证。\n其实这些根据上面的公式很容易推到出来，比如现在有两次请求，第一次耗时25ms，第二次耗时50ms，代入公式，计算出第一次和第二次的指数加权平均值为：\nv1 = β 0 + (1 - β) 25\nv2 = β v1 + (1 - β) 50\n可以看到，β值越小，意味着本次请求的实际耗时占比越大，β值越大，之前计算得到的平均值占比越大。\n根据上面的理解，相比普通平均值的计算，它更在乎的是一段时间内的平均趋势，而不是直接把当前实际耗时累加到总耗时里参与算术平均运算，这样有一个好处，那就是平均数变化会更加平滑（这个取决于β值的大小，后续会给出证明）。\n我们再来利用此算法来模拟下1000次请求（同样为了模拟真实情况，让一些请求耗时过高），β我们取值0.9，代表最新请求时的平均值计算会受到最近10次耗时的影响进行平滑过渡，运行结果绘制如下图：\n可以看到它得出的平均数曲线并没有算术平均那么稳定，但可以看出，每次网络波动会提升其加权均值，不像算术平均值那样完全不受网络波动影响。\n接下来同样假设第100~200次请求，发生了网络延迟，延时5倍，再次利用ewma算法做下模拟：\n请将这张图跟图7进行对比，你会发现，利用指数加权平均算法计算出的平均值在网络恢复时，以极快的速度恢复到了正常水平。\n相比算术平均的绝对平均值，指数加权移动平均算法更重要的是它平滑的模拟了平均值的趋势，平均值曲线的峰值和负峰值受β影响，β越大，则当前平均数受到前面数据的影响越大，反之越小，比如我们把图9里的β值调整为0.98，此时在计算当前平均值时则受到前面(1/0.02) = 50个平均值的影响，便得到下图：\n因为β值大，所以后续每个平均值都会受到更多前面值的影响，而自己的部分仅占很少影响（参考公式理解），所以它相比图9，在出现网络抖动后，更缓慢的恢复为正常均值，但由于它所统计的范围更大，因此平均数曲线会非常平缓，β值越大，统计周期越长，越能体现某个时段的平均趋势（比如图10里的平均数曲线已经趋近于算术平均数）。\n再比如，我们将β设置为0.32，那么计算均值时仅受到前面(1/0.68) = 1.47个均值影响，说白了就是平均值轨迹几乎和正常响应时间重叠：\n可以看到，当β很小时，受影响因子无限趋近于1，越趋近于1则越贴近原本值。\n结论    实验组 对照组 目的 结论     图6 图8（β=0.9） 模拟网络正常情况下，两种算法对均值的统计区别 算术平均值非常稳定，对单次网络抖动完全无感知，ewma均值则会随着响应时间动态变化，因此单次网络抖动后会稍微提升均值，之后便很快恢复   图7 图9（β=0.9） 模拟一段网络延迟，看两种算法的均值变化 算术平均值会缓慢提升，之后再次以极慢的速度下降，对网络延迟反映迟钝，网络延迟结束后仍然要花很长时间才能恢复到正常均值水平，ewma均值则迅速提升，恢复后迅速下降至正常水平   图9（β=0.9） 图10（β=0.98） 调大ewma的β值 β值越大，每次计算均值时受到之前均值影响越大，则平均曲线更加平滑，因此图10的曲线要比图9表现更加平滑，但付出的代价是对网络延迟反应也变的迟钝（但也碾压算术平均）   图9（β=0.9） 图11（β=0.32） 调小ewma的β值 β值越小，每次计算均值时受到之前均值影响越小，则平均曲线更加趋近于每次的实际耗时，因此图11的曲线要比图9表现的更加趋近于每次的实际耗时，顺理成章的，它对网络延迟的反映极迅速    通过实验，可以看出ewma的优势极大，但β的取值需要仔细斟酌，若β太小，则无法很好的体现出平均值，若β太大，很好的体现了平均值，但对网络波动的反应相对迟钝，这里就考虑到一个折中的方案：\n实时调整β值，比如ewma可以在网络波动时适当降低β的值，使其快速感知到波动的存在，当网络波动结束后，适当提升β的值，这样就可以在网络稳定的情况下较好的反映一个区段内的均值情况，这样等于结合了图10和图11各自的优点，实现后将达到一种效果：快速感知网络延迟并迅速提高其均值，当网络恢复后，慢慢降回正常水平（均值恢复需要慢慢进行，因为刚恢复的节点稳定性不可信，慢慢恢复到正常水平，以信任其稳定性）\n利用衰减函数动态调整β值 通过上面的要求，我们需要完善这个变化的β，那么它该如何变化呢？如何能达到碰到网络波动时迅速感知，当波动过后慢慢恢复的效果呢？慢慢恢复需要多慢？可不可以通过调整某个阈值来控制恢复的速率？\n带着上面的问题，需要了解一下：衰减函数（参考：牛顿冷却定律）\n计算方法为：\ne是数学常量，△t表示第t次请求的耗时，k表示衰减系数，它的函数图如下：\n我们把k*△t看做x的取值，那么k和△t成正比，即：k和△t取值越大，β就越小\n现在来看看这个结论支不支持我们要实现的功能：\n 网络抖动时，假设△t非常大，即便不乘k值，β值也会变得很小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知 网络恢复时，△t迅速降低，假设此时△t非常小，则k值越大，图12里对应的x越大，β的值就越小，事实上通过实验可以得出，如果k值很大，得出的曲线近乎等于图11。 经过上面的梳理，发现k值似乎没有起到衰减作用，反而因为它的存在导致β值降低，它的取值在网络抖动恢复后依旧在削弱β的值，导致网络恢复后迅速降低到正常水平，这是我们不愿意看到的，那么上面的函数需要做下变体，即让△t和k值成反比即可：  此时结论如下：\n 网络抖动时，假设△t非常大，即便k值起到中和作用，β值较之前也会明显变小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知 网络恢复时，即使△t迅速降低，那么由于k值的中和（△t/k的值大小和k值成反比），k越大，β越大，则均值计算受之前波动期的均值影响越大，曲线恢复越缓慢。  这点可以通过下方的验证得到证实，调整衰减系数k，的确可以控制在遇到波动时恢复到正常水平时的速度，衰减系数设置越大，波幅越大（恢复越慢），反之越小（恢复越快）。\n衰减系数验证 第一组：随机次数的网络抖动，衰减系数分别为600和50\n衰减系数为600时的走势图，可以看出，网络恢复后均值变化衰减速度很慢\n衰减系数为50时的走势图，可以看出，网络恢复后均值变化衰减速度很快\n第二组：第100~200次请求响应时间扩大5倍，衰减系数仍然是600和50\n衰减系数为600时的走势图，可以看出在抖动发生时，仍然可以迅速感知，后续恢复时的衰减速度跟上面结果一样慢\n衰减系数为50时的走势图，可以看出在抖动发生时，可以非常迅速的感知，后续恢复时的衰减速度跟上面结果一样快\n利用JAVA实现P2C算法 首先定义Node类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  public class Node { //惩罚值  private static final long penalty = 250_000_000_000L; //单位：纳秒（250s）  //衰减系数  private static final long tau = 600_000_000L; //单位：纳秒（600ms）  protected final String host; protected final int weight; //权重  // client统计数据  protected final AtomicLong lag = new AtomicLong(); //加权移动平均算法计算出的请求延迟度  protected final AtomicLong success = new AtomicLong(1000); // 加权移动平均算法计算出的请求成功率（只记录grpc内部错误，比如context deadline）  protected final AtomicLong inflight = new AtomicLong(1); // 当前客户端正在发送并等待response的请求数（pending request）  protected final AtomicLong svrCPU = new AtomicLong(500); //对应服务端的CPU使用率  // 最近一次resp时间戳  protected final AtomicLong stamp = new AtomicLong(); // 最近被pick的时间戳，利用该值可以统计被选中后，一次请求的耗时  protected final AtomicLong pick = new AtomicLong(); public Node(String host, int weight) { this.host = host; this.weight = weight; } public boolean valid() { return health()  500 \u0026\u0026 svrCPU.get()  900; } public long health() { return success.get(); //成功率  } public long load() { long lag = (long) (Math.sqrt((double) this.lag.get()) + 1); long load = this.svrCPU.get() * lag * this.inflight.get(); //根据cpu使用率、延迟率、拥塞度计算出负载率  if (load == 0) { // penalty是初始化没有数据时的惩罚值，默认为1e9 * 250  load = penalty; } return load; } //被pick后，完成请求后触发逻辑  public void responseTrigger(long pickTime, long cpu, boolean error) { this.inflight.decrementAndGet(); long now = System.nanoTime(); long stamp = this.stamp.getAndSet(now); long td = now - stamp; //计算距离上次response的时间差，节点本身闲置越久，这个值越大  if (td  0) { td = 0; } //实时计算β值，利用衰减函数计算，公式为：β = e^(-t/k)，相比前文给出的衰减公式这里是按照k值的反比计算的，即k值和β值成正比  double w = Math.exp((double) -td / (double) tau); long lag = now - pickTime; //实际耗时  if (lag  0) { lag = 0; } long oldLag = this.lag.get(); if (oldLag == 0) { w = 0; } //计算指数加权移动平均响应时间  lag = (int) ((double) oldLag * w + (double) lag * (1.0 - w)); this.lag.set(lag); //更新  int success = error ? 0 : 1000; //计算指数加权移动平均成功率  success = (int) ((double) this.success.get() * w + (double) success * (1.0 - w)); this.success.set(success); //更新  //更新本次请求服务端返回的cpu使用率  if (cpu  0) { this.svrCPU.set(cpu); } } }   再来定义LoadBalancer：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  public class P2CLoadBalancer { //闲置时间的最大容忍值  private static final long forceGap = 3000_000_000L; //单位：纳秒（3s）  private static final Random r = new Random(); private final ListNode nodes; //保存了参与lb的节点集合  public P2CLoadBalancer(ListNode nodes) { this.nodes = nodes; } public Node pick(long start) { //外界给入start，值为当前时间，resp后应给recycle传同样的值  Node pc, upc; if (nodes == null || nodes.size()  0) { throw new IllegalArgumentException(\"no node!\"); } if (nodes.size() == 1) { return nodes.get(0); } Node[] randomPair = prePick(); /** * 这里根据各自当前指标，计算出谁更合适被pick * 计算方式： * nodeA.load nodeB.load * ---------------------------- : ---------------------------- * nodeA.health * nodeA.weight nodeB.health * nodeB.weight * * health和weight都是提权用的，而load是降权用的，所以用load除以heal和weight的乘积，计算出的值越大，越不容易被pick */ if (randomPair[0].load() * randomPair[1].health() * randomPair[1].weight  randomPair[1].load() * randomPair[0].health() * randomPair[0].weight) { pc = randomPair[1]; upc = randomPair[0]; } else { pc = randomPair[0]; upc = randomPair[1]; } // 如果落选的节点，在forceGap期间内没有被选中一次，那么强制选中一次，利用强制的机会，来触发成功率、延迟的衰减  long pick = upc.pick.get(); if ((start - pick)  forceGap \u0026\u0026 upc.pick.compareAndSet(pick, start)) { pc = upc; //强制选中  } // 节点未发生切换才更新pick时间  if (pc != upc) { pc.pick.set(start); } pc.inflight.incrementAndGet(); return pc; } //pick出去后，等来了response后，应触发该方法  public void recycle(Node node, long pickTime, long cpu, boolean error) { node.responseTrigger(pickTime, cpu, error); } // 随机选择俩节点  public Node[] prePick() { Node[] randomPair = new Node[2]; for (int i = 0; i  3; i++) { int a = r.nextInt(nodes.size()); int b = r.nextInt(nodes.size() - 1); if (b = a) { b += 1; //防止随机出的节点相同  } randomPair[0] = nodes.get(a); randomPair[1] = nodes.get(b); if (randomPair[0].valid() || randomPair[1].valid()) { break; } } return randomPair; } }   参考 The Power of Two Random Choices 深入解析TensorFlow中滑动平均模型与代码实现 负载均衡-P2C算法\n",
  "wordCount" : "8824",
  "inLanguage": "zh-cn",
  "datePublished": "2021-01-24T11:29:23Z",
  "dateModified": "2021-01-24T11:29:23Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1p2c+ewma%E7%AE%97%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      负载均衡P2C&#43;EWMA算法
    </h1>
    <div class="post-meta">January 24, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="p2c算法">P2C算法<a hidden class="anchor" aria-hidden="true" href="#p2c算法">#</a></h2>
<h3 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h3>
<p>常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Consistent hash等应该都耳熟能详，这些算法都在实践中有广泛的应用，例如Nginx、Haproxy等负载均衡模块都有相应算法的实现。本文将和大家分享一种全新的Load balance算法：Power of Two Random Choices，也算是Fast 2019 best paper解读《Distcache: Provable load balancing for large-scale storage systems with distributed caching》 的续篇，DistCache利用Power of two random choices实现Cache Query的Load balance：就是在查询Cache中item的时候，从命中的2个Cache节点中选择负载较低的Cache节点来服务；实现简单，效果却不简单。除此之外，新版本的Nginx和Haproxy最近都增加了对Power of Two Random Choices算法的支持，可见一斑。</p>
<p>本文将从Power of Two Random Choices算法的起源说起（也就是数学里面经典的Balls into Bins问题），向大家展示Power of Two Random Choices算法背后的数学原理。并介绍其在解决Hash冲突中的应用，想必能进一步加深大家对Cuckoo Hash、BloomFilter等使用多个hash function做法的理解。</p>
<h3 id="balls-into-bins">Balls into Bins<a hidden class="anchor" aria-hidden="true" href="#balls-into-bins">#</a></h3>
<p>首先看数学一个经典的Balls into Bins问题：</p>
<p>假如顺序地将n个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择任意一个bin</p>
<p>那么当抛球结束的时候，以非常高的概率（ 也就是以概率1-ｏ(1)），n个bin中最大负载为(1+ｏ(1))logn/loglogn个balls。注意o(1)指的是高阶无穷小，可以直接忽略掉。</p>
<p>这实际上就是一个无状态的Load balance问题，考虑一个负载均衡器（LB）将n个请求随机等概率的发送给n个Server，那么就可以知道Server上最大的可能负载会是多少。</p>
<h3 id="power-of-two-random-choices">Power of two random choices<a hidden class="anchor" aria-hidden="true" href="#power-of-two-random-choices">#</a></h3>
<p>如果选择上做一个小改动，也就是今天要说的Power of two random choices：</p>
<p>假如顺序地将n个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择d个bin，然后选择Ball最少的bin放入</p>
<p>那么当抛球结束的时候，将以非常高的概率（ 也就是以概率1-ｏ(1)），n个bin中最大负载为(1+ｏ(1))loglogn/logd+Ｏ(1)个balls。</p>
<p>现在情况Balls的数量往往远大于Bins的数量，所以扩展一下：</p>
<p>假如顺序地将m个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择d个bin，然后选择Ball最少的bin放入，其中m&gt;=n，d&gt;=2</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124114424.png" alt=""  />
</p>
<p>下面给出一个一组计算的算例，分别m=n={2^2,2^3,2^4&hellip;&hellip;,2^64}，其中红色为普通的Balls into Bins问题的最大负载，蓝色为Power of two random choices d=2情况下的最大负载：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124114507.png" alt=""  />
</p>
<p>通过上图可以发现，Power of two random choices负载均衡的效果是不错的。尽管上面的模型太过理想，假定了所有的key都是必须均匀分布，每个request的size都是相同，和实际生产环境相差巨大，但仍然不妨碍我们认定这种做法的有效性。</p>
<h3 id="app">App<a hidden class="anchor" aria-hidden="true" href="#app">#</a></h3>
<h4 id="load-balance">Load balance<a hidden class="anchor" aria-hidden="true" href="#load-balance">#</a></h4>
<p>得益于Power of Two Random Choices的实现简单和效果良好，开源的NGINX在版本1.15.1中开始支持，Haproxy也在2.0版本中开始支持，且将其替换成了默认的随机算法，文献中Haproxy有一些对比测试，大家可以参考。</p>
<h4 id="hash">Hash<a hidden class="anchor" aria-hidden="true" href="#hash">#</a></h4>
<p>如果使用这种方法来解决Hash冲突，以开链（separate chaining）法为例，如果每次选择哈希映射的桶时，通过两个hash function随机挑出两个桶，并从中选择链表长度相对更短的桶插入[10]（如下图），根据Power of Two Rand Choices理论，那么每个hash bucket的开链长度肯定会更加均衡。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124114552.png" alt=""  />
</p>
<p>实际上回过头来看Cuckoo Hash、BloomFilter设计多个hash function是有道理的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124114602.png" alt=""  />
</p>
<p>如上图，是一个Cuckoo Hash一种典型实现，通过两个hash函数来映射key，且每个bucket都可以存放多个items，实际上根据Power of Two Random Choices的原理，这样，可以使得每个bucket的冲突更加均衡，从而可以在设计Cuckoo hash的时候设置较小的Bucket容量，避免空间浪费，或者换一个角度，可以延迟resize hash的发生。</p>
<h3 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h3>
<p>Power of two random choices尽管是一种理想的理论模型，但是方法和思路仍然可以作为生产实践的指导，这也大概是理论研究的意义所在。</p>
<h2 id="负载均衡">负载均衡<a hidden class="anchor" aria-hidden="true" href="#负载均衡">#</a></h2>
<p>P2C算法通过随机选择两个节点后在这俩节点里选择优胜者来避免羊群效应，并通过指数加权移动平均算法统计服务端的实时状态，从而做出最优选择。</p>
<h3 id="工作流程">工作流程<a hidden class="anchor" aria-hidden="true" href="#工作流程">#</a></h3>
<p>$M=inflight<em>weight</em>latency$</p>
<p>P2C算法下的每个节点（下称Node）必须含有下方图中几个指标，它们的计算方法已经标出：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124141841.png" alt=""  />
</p>
<p>因此最终loadbalancer里保存的节点就会变成下图的结构，pick节点时需要做如下比较：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124142027.png" alt=""  />
</p>
<p>通过上面的流程可以看到，大体流程还是随机，相比普通的随机LB，它是随机选择两个node，然后比较它们的负载率，然后选出当前负载率最小的node。</p>
<h3 id="数据统计">数据统计<a hidden class="anchor" aria-hidden="true" href="#数据统计">#</a></h3>
<p>通过上面的简单介绍，可以知道P2C算法的大体流程，那么现在问题就变得简单多了，只需要知道负载率，就可以完成这个“简单”的负载均衡器，但是负载率是由上图五个指标共同参与计算完成的，那现在问题的关键就是如何完成这五个指标的统计，下面来介绍下这五个指标如何计算。</p>
<h4 id="weight">weight<a hidden class="anchor" aria-hidden="true" href="#weight">#</a></h4>
<p>这个很简单，主要是人为配置的定制，用于给不同的机器按照机器配置分配上不同的权重，权重越高，越容易被pick到。这个值可以做在服务注册与发现里，进行为每个节点分配一个权重值。</p>
<h4 id="server_cpu">server_cpu<a hidden class="anchor" aria-hidden="true" href="#server_cpu">#</a></h4>
<p>这个值可以通过服务端回写元数据来搞定，比如一次请求：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124142145.png" alt=""  />
</p>
<p>所以这个值可以通过服务端埋点的方式解决掉。</p>
<h4 id="inflight">inflight<a hidden class="anchor" aria-hidden="true" href="#inflight">#</a></h4>
<p>这个代表节点请求拥塞度，代表着当前节点有多少个请求未完成或者正开始请求，它的统计也很简单：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124143037.png" alt=""  />
</p>
<p>按照这种，每次pick到发送请求前先原子+1，response后说明一次请求完成，这时再原子-1，这样一增一减，在超多线程pick下（即高qps），当前线程获取到的inflight瞬间值，就是在这个时段的拥塞度，比如一个节点如果很闲，响应速度也快，那么它的拥塞度肯定极低（因为一增一减的操作很快就完成，不会淤积过多）。</p>
<h3 id="latency--client_success">latency &amp; client_success<a hidden class="anchor" aria-hidden="true" href="#latency--client_success">#</a></h3>
<p>前面的都很好了理解，这俩属性比较麻烦，它们分别代表请求延迟率和成功率。</p>
<p>这俩值该怎么计算？一般来说是通过平均数的方式来计算，但计算平均数的方式有很多，可以先用我们最熟悉的算术平均数来计算，它的计算公式如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124143938.png" alt=""  />
</p>
<p>利用此算法套入我们的场景后，请求总耗时比上请求总次数，就是latency：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124143947.png" alt=""  />
</p>
<p>请求总成功数比上请求总次数，就是client_success：</p>
<p>整个过程可以抽象成下面这样：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124144535.png" alt=""  />
</p>
<p>根据图5的流程，可以通过每次请求，累加总请求数、总耗时、总成功数，然后利用算术平均法更新latency和client_success的值，这一切可以运作的很好，可是算术平均有个很大的缺陷，不够敏感，出现的网络波动一下就被平均了.</p>
<h3 id="算术平均数模拟">算术平均数模拟<a hidden class="anchor" aria-hidden="true" href="#算术平均数模拟">#</a></h3>
<p>首先模拟1000次请求，让每次请求在0~25之间产生随机数用来作为本次请求的耗时（为了模拟真实情况，让一些请求耗时过高），每次请求计算当前的算术平均数，然后可以得到下面的统计图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124144652.png" alt=""  />
</p>
<p>可以看到，正常情况下，算术平均数表现出很好的稳定性，红线一致维持在黑线的中间，且浮动不大。</p>
<p>现在让我们搞点事情，假设在第100次请求到第200次请求间，模拟下网络抖动，让这期间的响应时间变成125ms（相比正常情况翻五倍），得到统计图如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124144724.png" alt=""  />
</p>
<p>可以看到平均数受到这次抖动的影响，需要非常长的时间才能感知到抖动的到来，然后恢复时又需要花很长时间才能恢复到抖动前的较正常的水平，也就是说，第100~200间的100次慢请求，不光要到140次请求后才能较明显的感知平均值的上涨，还导致网络恢复后，到第1000次请求时，平均值还没有恢复到正常水平（但其实从第200次请求后，响应时间就正常了），算术平均数导致的这类问题显然是很严重的，因为我需要的算法是可以立马感知到网络波动，网络恢复后又可以在较短的时间内恢复正常水平。</p>
<p>有没有更好的统计办法来避免这类问题并且达到我们的要求呢？</p>
<h2 id="ewma算法">EWMA算法<a hidden class="anchor" aria-hidden="true" href="#ewma算法">#</a></h2>
<h3 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h3>
<p>　　加权移动平均法，是对观察值分别给予不同的权数，按不同权数求得移动平均值，并以最后的移动平均值为基础，确定预测值的方法。采用加权移动平均法，是因为观察期的近期观察值对预测值有较大影响，它更能反映近期变化的趋势。</p>
<p>指数移动加权平均法，是指各数值的加权系数随时间呈指数式递减，越靠近当前时刻的数值加权系数就越大。</p>
<p>指数移动加权平均较传统的平均法来说，一是不需要保存过去所有的数值；二是计算量显著减小。</p>
<h3 id="算法理解">算法理解<a hidden class="anchor" aria-hidden="true" href="#算法理解">#</a></h3>
<p>引入一个例子，例子为美国一年内每天的温度分布情况，具体如下图所示</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124150108.png" alt=""  />
</p>
<p>EWMA 的表达式如下：</p>
<p>𝑣𝑡=𝛽𝑣𝑡−1+(1−𝛽)𝜃𝑡</p>
<p>上式中 𝜃𝑡 为时刻 𝑡 的实际温度；系数 𝛽 表示加权下降的速率，其值越小下降的越快；𝑣𝑡 为 𝑡 时刻 EWMA 的值。</p>
<p>在上图中有两条不同颜色的线，分别对应着不同的 𝛽 值。</p>
<p>当 𝛽=0.9 时，有 𝑣𝑡=0.9𝑣𝑡−1+0.1𝜃𝑡 ，对应着图中的红线，此时虽然曲线有些波动，但总体能拟合真实数据</p>
<p>当 𝛽=0.98 时，有 𝑣𝑡=0.98𝑣𝑡−1+0.02𝜃𝑡 ，对应着图中的绿线，此时曲线较平，但却有所偏离真实数据</p>
<p>在 𝑡=0 时刻，一般初始化 𝑣0=0 ，对 EWMA 的表达式进行归纳可以将 𝑡 时刻的表达式写成：</p>
<p>𝑣𝑡=(1−𝛽)(𝜃𝑡+𝛽𝜃𝑡−1+&hellip;+𝛽𝑡−1𝜃1)</p>
<p>从上面式子中可以看出，数值的加权系数随着时间呈指数下降。在数学中一般会以 1/𝑒 来作为一个临界值，小于该值的加权系数的值不作考虑，接着来分析上面 𝛽=0.9 和 𝛽=0.98 的情况。</p>
<p>当 𝛽=0.9 时，0.9^10 约等于 1/𝑒 ，因此认为此时是近10个数值的加权平均。</p>
<p>当 𝛽=0.98 时，0.9^50 约等于 1/𝑒，因此认为此时是近50个数值的加权平均。这种情况也正是移动加权平均的来源。</p>
<p>具体的分析如下图所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124150757.png" alt=""  />
</p>
<h3 id="偏差修正">偏差修正<a hidden class="anchor" aria-hidden="true" href="#偏差修正">#</a></h3>
<p>在初始化 𝑣0=0 时实际上会存在一个问题。具体的如下图所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124150813.png" alt=""  />
</p>
<p>从上图中可以看出有一条绿色和紫色的曲线，都是对应于 𝛽=0.98 时的曲线。理想状况下应该是绿色的曲线，但当初始化 𝑣0=0 时却会得到紫色的曲线，这是因为初始化的值太小，导致初期的数值都偏小，而随着时间的增长，初期的值的影响减小，紫色的曲线就慢慢和绿色的曲线重合。我们对公式做一些修改：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124150859.png" alt=""  />
</p>
<p>当 𝑡 很小时，分母可以很好的放大当前的数值；当 𝑡 很大时，分母的数值趋于1，对当前数值几乎没有影响。</p>
<p>EWMA 主要是被应用在动量优化算法中，比如Adam算法中的一阶矩和二阶矩都采用了上面修改后的EWMA算法。</p>
<h2 id="ewma模拟">EWMA模拟<a hidden class="anchor" aria-hidden="true" href="#ewma模拟">#</a></h2>
<p>公式如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124151343.png" alt=""  />
</p>
<p>解释：vt代表第t次请求的指数加权平均耗时，vt-1代表上次请求的指数加权平均耗时，θt代表第t次请求的实际耗时。</p>
<p>β值的定义如下：</p>
<p>vt ≈ 1/(1 - β) 次的平均耗时</p>
<p>例：假设β等于0.9，1/(1 - β) 就等于10，也就是vt约等于它前10次请求的平均耗时；假设把β值调大道接近1，例如，将β等于0.98，1/(1-β)=50，按照刚刚的说法也就是当前请求的前50次请求的平均耗时。</p>
<p>由此可以推导出：</p>
<p>β值越大，统计区间越大，当前平均值的计算受到之前平均值的影响也就越大（曲线越平滑，呈现一个平缓的变化趋势）</p>
<p>β值越小，统计区间越小，当前平均值的计算受到之前平均值的影响也就越小（曲线贴近统计原值）</p>
<p>β极小时，便可以认为当次的平均耗时约等于当次本身的实际耗时。</p>
<p>上面的结论接下来会通过实验来进行验证。</p>
<p>其实这些根据上面的公式很容易推到出来，比如现在有两次请求，第一次耗时25ms，第二次耗时50ms，代入公式，计算出第一次和第二次的指数加权平均值为：</p>
<p>v1 = β <em>0 + (1 - β)</em> 25</p>
<p>v2 = β <em>v1 + (1 - β)</em> 50</p>
<p>可以看到，β值越小，意味着本次请求的实际耗时占比越大，β值越大，之前计算得到的平均值占比越大。</p>
<p>根据上面的理解，相比普通平均值的计算，它更在乎的是一段时间内的平均趋势，而不是直接把当前实际耗时累加到总耗时里参与算术平均运算，这样有一个好处，那就是平均数变化会更加平滑（这个取决于β值的大小，后续会给出证明）。</p>
<p>我们再来利用此算法来模拟下1000次请求（同样为了模拟真实情况，让一些请求耗时过高），β我们取值0.9，代表最新请求时的平均值计算会受到最近10次耗时的影响进行平滑过渡，运行结果绘制如下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124151637.png" alt=""  />
</p>
<p>可以看到它得出的平均数曲线并没有算术平均那么稳定，但可以看出，每次网络波动会提升其加权均值，不像算术平均值那样完全不受网络波动影响。</p>
<p>接下来同样假设第100~200次请求，发生了网络延迟，延时5倍，再次利用ewma算法做下模拟：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124151653.png" alt=""  />
</p>
<p>请将这张图跟图7进行对比，你会发现，利用指数加权平均算法计算出的平均值在网络恢复时，以极快的速度恢复到了正常水平。</p>
<p>相比算术平均的绝对平均值，指数加权移动平均算法更重要的是它平滑的模拟了平均值的趋势，平均值曲线的峰值和负峰值受β影响，β越大，则当前平均数受到前面数据的影响越大，反之越小，比如我们把图9里的β值调整为0.98，此时在计算当前平均值时则受到前面(1/0.02) = 50个平均值的影响，便得到下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124152322.png" alt=""  />
</p>
<p>因为β值大，所以后续每个平均值都会受到更多前面值的影响，而自己的部分仅占很少影响（参考公式理解），所以它相比图9，在出现网络抖动后，更缓慢的恢复为正常均值，但由于它所统计的范围更大，因此平均数曲线会非常平缓，β值越大，统计周期越长，越能体现某个时段的平均趋势（比如图10里的平均数曲线已经趋近于算术平均数）。</p>
<p>再比如，我们将β设置为0.32，那么计算均值时仅受到前面(1/0.68) = 1.47个均值影响，说白了就是平均值轨迹几乎和正常响应时间重叠：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124152350.png" alt=""  />
</p>
<p>可以看到，当β很小时，受影响因子无限趋近于1，越趋近于1则越贴近原本值。</p>
<h3 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h3>
<table>
<thead>
<tr>
<th>实验组</th>
<th>对照组</th>
<th>目的</th>
<th>结论</th>
</tr>
</thead>
<tbody>
<tr>
<td>图6</td>
<td>图8（β=0.9）</td>
<td>模拟网络正常情况下，两种算法对均值的统计区别</td>
<td>算术平均值非常稳定，对单次网络抖动完全无感知，ewma均值则会随着响应时间动态变化，因此单次网络抖动后会稍微提升均值，之后便很快恢复</td>
</tr>
<tr>
<td>图7</td>
<td>图9（β=0.9）</td>
<td>模拟一段网络延迟，看两种算法的均值变化</td>
<td>算术平均值会缓慢提升，之后再次以极慢的速度下降，对网络延迟反映迟钝，网络延迟结束后仍然要花很长时间才能恢复到正常均值水平，ewma均值则迅速提升，恢复后迅速下降至正常水平</td>
</tr>
<tr>
<td>图9（β=0.9）</td>
<td>图10（β=0.98）</td>
<td>调大ewma的β值</td>
<td>β值越大，每次计算均值时受到之前均值影响越大，则平均曲线更加平滑，因此图10的曲线要比图9表现更加平滑，但付出的代价是对网络延迟反应也变的迟钝（但也碾压算术平均）</td>
</tr>
<tr>
<td>图9（β=0.9）</td>
<td>图11（β=0.32）</td>
<td>调小ewma的β值</td>
<td>β值越小，每次计算均值时受到之前均值影响越小，则平均曲线更加趋近于每次的实际耗时，因此图11的曲线要比图9表现的更加趋近于每次的实际耗时，顺理成章的，它对网络延迟的反映极迅速</td>
</tr>
</tbody>
</table>
<p>通过实验，可以看出ewma的优势极大，但β的取值需要仔细斟酌，若β太小，则无法很好的体现出平均值，若β太大，很好的体现了平均值，但对网络波动的反应相对迟钝，这里就考虑到一个折中的方案：</p>
<p>实时调整β值，比如ewma可以在网络波动时适当降低β的值，使其快速感知到波动的存在，当网络波动结束后，适当提升β的值，这样就可以在网络稳定的情况下较好的反映一个区段内的均值情况，这样等于结合了图10和图11各自的优点，实现后将达到一种效果：快速感知网络延迟并迅速提高其均值，当网络恢复后，慢慢降回正常水平（均值恢复需要慢慢进行，因为刚恢复的节点稳定性不可信，慢慢恢复到正常水平，以信任其稳定性）</p>
<h3 id="利用衰减函数动态调整β值">利用衰减函数动态调整β值<a hidden class="anchor" aria-hidden="true" href="#利用衰减函数动态调整β值">#</a></h3>
<p>通过上面的要求，我们需要完善这个变化的β，那么它该如何变化呢？如何能达到碰到网络波动时迅速感知，当波动过后慢慢恢复的效果呢？慢慢恢复需要多慢？可不可以通过调整某个阈值来控制恢复的速率？</p>
<p>带着上面的问题，需要了解一下：衰减函数（参考：牛顿冷却定律）</p>
<p>计算方法为：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195016.png" alt=""  />
</p>
<p>e是数学常量，△t表示第t次请求的耗时，k表示衰减系数，它的函数图如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195024.png" alt=""  />
</p>
<p>我们把k*△t看做x的取值，那么k和△t成正比，即：k和△t取值越大，β就越小</p>
<p>现在来看看这个结论支不支持我们要实现的功能：</p>
<ol>
<li>网络抖动时，假设△t非常大，即便不乘k值，β值也会变得很小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li>
<li>网络恢复时，△t迅速降低，假设此时△t非常小，则k值越大，图12里对应的x越大，β的值就越小，事实上通过实验可以得出，如果k值很大，得出的曲线近乎等于图11。
经过上面的梳理，发现k值似乎没有起到衰减作用，反而因为它的存在导致β值降低，它的取值在网络抖动恢复后依旧在削弱β的值，导致网络恢复后迅速降低到正常水平，这是我们不愿意看到的，那么上面的函数需要做下变体，即让△t和k值成反比即可：</li>
</ol>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195830.png" alt=""  />
</p>
<p>此时结论如下：</p>
<ol>
<li>网络抖动时，假设△t非常大，即便k值起到中和作用，β值较之前也会明显变小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li>
<li>网络恢复时，即使△t迅速降低，那么由于k值的中和（△t/k的值大小和k值成反比），k越大，β越大，则均值计算受之前波动期的均值影响越大，曲线恢复越缓慢。</li>
</ol>
<p>这点可以通过下方的验证得到证实，调整衰减系数k，的确可以控制在遇到波动时恢复到正常水平时的速度，衰减系数设置越大，波幅越大（恢复越慢），反之越小（恢复越快）。</p>
<h3 id="衰减系数验证">衰减系数验证<a hidden class="anchor" aria-hidden="true" href="#衰减系数验证">#</a></h3>
<p>第一组：随机次数的网络抖动，衰减系数分别为600和50</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195901.png" alt=""  />
</p>
<p>衰减系数为600时的走势图，可以看出，网络恢复后均值变化衰减速度很慢</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195913.png" alt=""  />
</p>
<p>衰减系数为50时的走势图，可以看出，网络恢复后均值变化衰减速度很快</p>
<p>第二组：第100~200次请求响应时间扩大5倍，衰减系数仍然是600和50</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195930.png" alt=""  />
</p>
<p>衰减系数为600时的走势图，可以看出在抖动发生时，仍然可以迅速感知，后续恢复时的衰减速度跟上面结果一样慢</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195938.png" alt=""  />
</p>
<p>衰减系数为50时的走势图，可以看出在抖动发生时，可以非常迅速的感知，后续恢复时的衰减速度跟上面结果一样快</p>
<h2 id="利用java实现p2c算法">利用JAVA实现P2C算法<a hidden class="anchor" aria-hidden="true" href="#利用java实现p2c算法">#</a></h2>
<p>首先定义Node类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="c1">//惩罚值
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">penalty</span> <span class="o">=</span> <span class="n">250_000_000_000L</span><span class="o">;</span> <span class="c1">//单位：纳秒（250s）
</span><span class="c1"></span>    <span class="c1">//衰减系数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">600_000_000L</span><span class="o">;</span> <span class="c1">//单位：纳秒（600ms）
</span><span class="c1"></span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">host</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">;</span> <span class="c1">//权重
</span><span class="c1"></span>
    <span class="c1">// client统计数据
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">AtomicLong</span> <span class="n">lag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">();</span> <span class="c1">//加权移动平均算法计算出的请求延迟度
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">AtomicLong</span> <span class="n">success</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span> <span class="c1">// 加权移动平均算法计算出的请求成功率（只记录grpc内部错误，比如context deadline）
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">AtomicLong</span> <span class="n">inflight</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// 当前客户端正在发送并等待response的请求数（pending request）
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">AtomicLong</span> <span class="n">svrCPU</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">(</span><span class="n">500</span><span class="o">);</span> <span class="c1">//对应服务端的CPU使用率
</span><span class="c1"></span>
    <span class="c1">// 最近一次resp时间戳
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">AtomicLong</span> <span class="n">stamp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">();</span>
    <span class="c1">// 最近被pick的时间戳，利用该值可以统计被选中后，一次请求的耗时
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">AtomicLong</span> <span class="n">pick</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicLong</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">String</span> <span class="n">host</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">host</span> <span class="o">=</span> <span class="n">host</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">valid</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">health</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">500</span> <span class="o">&amp;&amp;</span> <span class="n">svrCPU</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">900</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">health</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">success</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">//成功率
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">load</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">lag</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">lag</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">load</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">svrCPU</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">*</span> <span class="n">lag</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="na">inflight</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">//根据cpu使用率、延迟率、拥塞度计算出负载率
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">load</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// penalty是初始化没有数据时的惩罚值，默认为1e9 * 250
</span><span class="c1"></span>            <span class="n">load</span> <span class="o">=</span> <span class="n">penalty</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">load</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//被pick后，完成请求后触发逻辑
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">responseTrigger</span><span class="o">(</span><span class="kt">long</span> <span class="n">pickTime</span><span class="o">,</span> <span class="kt">long</span> <span class="n">cpu</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">error</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">inflight</span><span class="o">.</span><span class="na">decrementAndGet</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">stamp</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">td</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">stamp</span><span class="o">;</span> <span class="c1">//计算距离上次response的时间差，节点本身闲置越久，这个值越大
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">td</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">td</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//实时计算β值，利用衰减函数计算，公式为：β = e^(-t/k)，相比前文给出的衰减公式这里是按照k值的反比计算的，即k值和β值成正比
</span><span class="c1"></span>        <span class="kt">double</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">exp</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="o">-</span><span class="n">td</span> <span class="o">/</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="n">tau</span><span class="o">);</span>

        <span class="kt">long</span> <span class="n">lag</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">pickTime</span><span class="o">;</span> <span class="c1">//实际耗时
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">lag</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">long</span> <span class="n">oldLag</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lag</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldLag</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//计算指数加权移动平均响应时间
</span><span class="c1"></span>        <span class="n">lag</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">oldLag</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="n">lag</span> <span class="o">*</span> <span class="o">(</span><span class="n">1</span><span class="o">.</span><span class="na">0</span> <span class="o">-</span> <span class="n">w</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lag</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">lag</span><span class="o">);</span> <span class="c1">//更新
</span><span class="c1"></span>
        <span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">error</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">1000</span><span class="o">;</span>
        <span class="c1">//计算指数加权移动平均成功率
</span><span class="c1"></span>        <span class="n">success</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">success</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="n">success</span> <span class="o">*</span> <span class="o">(</span><span class="n">1</span><span class="o">.</span><span class="na">0</span> <span class="o">-</span> <span class="n">w</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">success</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">success</span><span class="o">);</span> <span class="c1">//更新
</span><span class="c1"></span>
        <span class="c1">//更新本次请求服务端返回的cpu使用率
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">cpu</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">svrCPU</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">cpu</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再来定义LoadBalancer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">public</span> <span class="nx">class</span> <span class="nx">P2CLoadBalancer</span> <span class="p">{</span>

    <span class="c1">//闲置时间的最大容忍值
</span><span class="c1"></span>    <span class="nx">private</span> <span class="nx">static</span> <span class="nx">final</span> <span class="nx">long</span> <span class="nx">forceGap</span> <span class="p">=</span> <span class="mi">3000_000_000</span><span class="nx">L</span><span class="p">;</span> <span class="c1">//单位：纳秒（3s）
</span><span class="c1"></span>
    <span class="nx">private</span> <span class="nx">static</span> <span class="nx">final</span> <span class="nx">Random</span> <span class="nx">r</span> <span class="p">=</span> <span class="nx">new</span> <span class="nf">Random</span><span class="p">();</span>

    <span class="nx">private</span> <span class="nx">final</span> <span class="nx">List</span><span class="p">&lt;</span><span class="nx">Node</span><span class="p">&gt;</span> <span class="nx">nodes</span><span class="p">;</span> <span class="c1">//保存了参与lb的节点集合
</span><span class="c1"></span>
    <span class="nx">public</span> <span class="nf">P2CLoadBalancer</span><span class="p">(</span><span class="nx">List</span><span class="p">&lt;</span><span class="nx">Node</span><span class="p">&gt;</span> <span class="nx">nodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">this</span><span class="p">.</span><span class="nx">nodes</span> <span class="p">=</span> <span class="nx">nodes</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">public</span> <span class="nx">Node</span> <span class="nf">pick</span><span class="p">(</span><span class="nx">long</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//外界给入start，值为当前时间，resp后应给recycle传同样的值
</span><span class="c1"></span>        <span class="nx">Node</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">upc</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">nodes</span> <span class="o">==</span> <span class="nx">null</span> <span class="o">||</span> <span class="nx">nodes</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">throw</span> <span class="nx">new</span> <span class="nf">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;no node!&#34;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">nodes</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">nodes</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nx">Node</span><span class="p">[]</span> <span class="nx">randomPair</span> <span class="p">=</span> <span class="nf">prePick</span><span class="p">();</span>

        <span class="cm">/**
</span><span class="cm">         * 这里根据各自当前指标，计算出谁更合适被pick
</span><span class="cm">         * 计算方式：
</span><span class="cm">         *        nodeA.load                           nodeB.load
</span><span class="cm">         * ----------------------------   :   ----------------------------
</span><span class="cm">         * nodeA.health * nodeA.weight        nodeB.health * nodeB.weight
</span><span class="cm">         *
</span><span class="cm">         * health和weight都是提权用的，而load是降权用的，所以用load除以heal和weight的乘积，计算出的值越大，越不容易被pick
</span><span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">load</span><span class="p">()</span> <span class="o">*</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">health</span><span class="p">()</span> <span class="o">*</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">weight</span> <span class="p">&gt;</span>
                <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">load</span><span class="p">()</span> <span class="o">*</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">health</span><span class="p">()</span> <span class="o">*</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">weight</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">pc</span> <span class="p">=</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="nx">upc</span> <span class="p">=</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">pc</span> <span class="p">=</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="nx">upc</span> <span class="p">=</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// 如果落选的节点，在forceGap期间内没有被选中一次，那么强制选中一次，利用强制的机会，来触发成功率、延迟的衰减
</span><span class="c1"></span>        <span class="nx">long</span> <span class="nx">pick</span> <span class="p">=</span> <span class="nx">upc</span><span class="p">.</span><span class="nx">pick</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">start</span> <span class="o">-</span> <span class="nx">pick</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">forceGap</span> <span class="o">&amp;&amp;</span> <span class="nx">upc</span><span class="p">.</span><span class="nx">pick</span><span class="p">.</span><span class="nf">compareAndSet</span><span class="p">(</span><span class="nx">pick</span><span class="p">,</span> <span class="nx">start</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">pc</span> <span class="p">=</span> <span class="nx">upc</span><span class="p">;</span> <span class="c1">//强制选中
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// 节点未发生切换才更新pick时间
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">!=</span> <span class="nx">upc</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">pc</span><span class="p">.</span><span class="nx">pick</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">pc</span><span class="p">.</span><span class="nx">inflight</span><span class="p">.</span><span class="nf">incrementAndGet</span><span class="p">();</span>

        <span class="k">return</span> <span class="nx">pc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//pick出去后，等来了response后，应触发该方法
</span><span class="c1"></span>    <span class="nx">public</span> <span class="nx">void</span> <span class="nf">recycle</span><span class="p">(</span><span class="nx">Node</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">long</span> <span class="nx">pickTime</span><span class="p">,</span> <span class="nx">long</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">boolean</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nf">responseTrigger</span><span class="p">(</span><span class="nx">pickTime</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="kt">error</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 随机选择俩节点
</span><span class="c1"></span>    <span class="nx">public</span> <span class="nx">Node</span><span class="p">[]</span> <span class="nf">prePick</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">Node</span><span class="p">[]</span> <span class="nx">randomPair</span> <span class="p">=</span> <span class="nx">new</span> <span class="nx">Node</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="nx">a</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">nextInt</span><span class="p">(</span><span class="nx">nodes</span><span class="p">.</span><span class="nf">size</span><span class="p">());</span>
            <span class="kt">int</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">nextInt</span><span class="p">(</span><span class="nx">nodes</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">b</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//防止随机出的节点相同
</span><span class="c1"></span>            <span class="p">}</span>
            <span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nodes</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
            <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nodes</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">randomPair</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">valid</span><span class="p">()</span> <span class="o">||</span> <span class="nx">randomPair</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">valid</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">randomPair</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/64538762">The Power of Two Random Choices</a>
<a href="https://blog.csdn.net/m0_38106113/article/details/81542863">深入解析TensorFlow中滑动平均模型与代码实现</a>
<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
