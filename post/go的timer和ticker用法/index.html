<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的timer和ticker用法 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="定时器:timer time包中有两个函数可以帮我们初始化 time.Timer （类型） 在高性能场景下，不应该使用time.After，而应该使用New.Time" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.87.0 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的timer和ticker用法" />
<meta property="og:description" content="定时器:timer time包中有两个函数可以帮我们初始化 time.Timer （类型） 在高性能场景下，不应该使用time.After，而应该使用New.Time" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84timer%E5%92%8Cticker%E7%94%A8%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-21T15:53:41+00:00" />
<meta property="article:modified_time" content="2019-10-21T15:53:41+00:00" />

<meta itemprop="name" content="Go的timer和ticker用法">
<meta itemprop="description" content="定时器:timer time包中有两个函数可以帮我们初始化 time.Timer （类型） 在高性能场景下，不应该使用time.After，而应该使用New.Time"><meta itemprop="datePublished" content="2019-10-21T15:53:41+00:00" />
<meta itemprop="dateModified" content="2019-10-21T15:53:41+00:00" />
<meta itemprop="wordCount" content="5544">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的timer和ticker用法"/>
<meta name="twitter:description" content="定时器:timer time包中有两个函数可以帮我们初始化 time.Timer （类型） 在高性能场景下，不应该使用time.After，而应该使用New.Time"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的timer和ticker用法</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-21 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 5544 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#newtimer">Newtimer</a>
      <ul>
        <li><a href="#timerreset">Timer.Reset</a></li>
        <li><a href="#timerstop">Timer.Stop</a></li>
      </ul>
    </li>
    <li><a href="#timeafer">time.Afer</a>
      <ul>
        <li><a href="#timeafer-1">time.Afer</a></li>
        <li><a href="#timeaferfunc">time.Aferfunc</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#newticker">NewTicker</a>
      <ul>
        <li><a href="#tickerstop">Ticker.Stop</a></li>
      </ul>
    </li>
    <li><a href="#timetick">time.Tick</a></li>
  </ul>

  <ul>
    <li><a href="#问题">问题</a></li>
    <li><a href="#解决">解决</a></li>
  </ul>

  <ul>
    <li><a href="#问题-1">问题</a></li>
    <li><a href="#竞争条件">竞争条件</a></li>
    <li><a href="#解决-1">解决</a></li>
  </ul>

  <ul>
    <li><a href="#问题-2">问题</a></li>
    <li><a href="#解决-2">解决</a>
      <ul>
        <li><a href="#context">context</a></li>
        <li><a href="#stop-channel">stop channel</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="定时器timer">定时器:timer</h1>
<p>time包中有两个函数可以帮我们初始化 time.Timer （类型）</p>
<p>在高性能场景下，不应该使用time.After，而应该使用New.Timer并在不再使用该Timer后（无论该Timer是否被触发）调用Timer的Stop方法来及时释放资源。不然内存资源可能被延时释放。</p>
<h2 id="newtimer">Newtimer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">time</span><span class="p">.</span><span class="nf">Newtimer</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>初始化一个到期时间据此时的间隔3小时30分的定时器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Newtimer</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span> <span class="o">+</span> <span class="mi">30</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>其中 t 是 *time.NewTimer 类型的，这个指针类型的方法集合包含两个方法：</p>
<ul>
<li>Reset() 用于重置定时器，该方法返回一个bool类型的值</li>
<li>Stop() 用来停止定时器，该方法返回一个bool类型的值，如果返回false，说明该定时器在之前已经到期或者已经被停止了，反之返回true。</li>
</ul>
<p>通过定时器的字段 C，我们可以及时得知定时器到期的这个事件来临，C 是一个 chan time.Time类型的缓冲通道，一旦触及到期时间，定时器就会向自己的 C 字段发送一个 time.Time类型的元素值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Time now = %v\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Expiration time = %v\n&#34;</span><span class="p">,</span> <span class="o">&lt;-</span> <span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">)</span>
<span class="p">}</span>
<span class="cm">/** output:
</span><span class="cm">Time now = 2018-11-27 09:22:09.92001771 +0800 CST m=+0.000332590
</span><span class="cm">Expiration time = 2018-11-27 09:22:12.921125657 +0800 CST m=+3.001270537
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="timerreset">Timer.Reset</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Reset使t重新开始计时，（本方法返回后再）等待时间段d过去后到期。</p>
<p>函数的返回值是bool类型,如果调用时t未到期会返回true；如果t已经到期或者被停止了会返回false。</p>
<p>我们所期望的定时器设置失败与否，通常只和通道有关：设置定时器前，定时器的通道Timer.C中是否已经有数据。</p>
<ul>
<li>如果有，我们设置的定时器失败了，我们可能读到不正确的超时事件。</li>
<li>如果没有，我们设置的定时器成功了，我们在设定的时间得到超时事件。</li>
</ul>
<p>因为定时器的缓存通道大小只为1，无法多存放超时事件，而且添加到通道的方法是非阻塞IO,如果通道已经有值,就会直接放弃.</p>
<p>定时器创建后是单独运行的，超时后会向通道写入数据，你从通道中把数据读走。当前一次的超时数据没有被读取，而设置了新的定时器，然后去通道读数据，结果读到的是上次超时的超时事件，看似成功，实则失败.</p>
<h3 id="timerstop">Timer.Stop</h3>
<p>调用Stop方法可阻止Timer被触发。如果Stop调用停止了timer，那么返回true，如果timer已经被触发过或者已经被停止了，那么返回false。</p>
<p>Stop方法在timer未被触发或已被触发或已被关闭的情况下都可以被调用。在高性能场景下，我们应该统一在select结束后，即timer不再使用后调用Stop方法。如果timer不做超时取消释放资源，则可能因为依赖方响应缓慢而导致本地资源堆积，例如 fd，连接数，内存占用等等。从而导致服务宕机。</p>
<h2 id="timeafer">time.Afer</h2>
<h3 id="timeafer-1">time.Afer</h3>
<p>time.After 一般用来控制某些耗时较长的行为，在超时后不再等待，以使程序行为可预期,等价于time.NewTimer(d).C</p>
<p>After函数底层所使用的Timer直到timer被触发才会被golang的垃圾回收器处理。但何时进一步释放给操作系统由垃圾回收器决定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// ch1 &lt;- 1
</span><span class="c1"></span>    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">e1</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
        <span class="c1">//如果ch1通道成功读取数据，则执行该case处理语句
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;1th case is selected. e1=%v&#34;</span><span class="p">,</span> <span class="nx">e1</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">e2</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
        <span class="c1">//如果ch2通道成功读取数据，则执行该case处理语句
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;2th case is selected. e2=%v&#34;</span><span class="p">,</span> <span class="nx">e2</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Timed out&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// output: Timed out
</span></code></pre></td></tr></table>
</div>
</div><p>time.Sleep() 函数，表示休眠多少时间，休眠时出于阻塞状态，后续程序无法执行。</p>
<h3 id="timeaferfunc">time.Aferfunc</h3>
<p>自定义定时器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>

    <span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(){</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Expiration time : %v.\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;C`s len: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="nx">t</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
    <span class="c1">//让当前Goroutine 睡眠2s，确保大于内容的完整
</span><span class="c1"></span>    <span class="c1">//这样做原因是，time.AfterFunc的调用不会被阻塞。它会以一部的方式在到期事件来临执行我们自定义函数f。
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
<span class="cm">/** output:
</span><span class="cm">Expiration time : 2018-11-27 10:09:22.084781987 +0800 CST m=+1.003211639.
</span><span class="cm">C`s len: 0
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><p>第二行打印内容说明：定时器字段 C 并没有缓冲任何元素值，这也说明了，在给定了自定义函数后，默认的处理方法（向C发送代表绝对到期时间的元质素）就不会被执行了。</p>
<h1 id="断续器ticker">断续器:ticker</h1>
<p>ticker就是周期性的传达到期时间的装置，这种装置的行为方式与仅有秒针的钟表有些类似</p>
<p>time包中有两个函数可以帮我们初始化 time.Ticker （类型）：</p>
<h2 id="newticker">NewTicker</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ticker</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Ticker</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="tickerstop">Ticker.Stop</h3>
<p>使用time.NewTicker时，在Ticker对象不再使用后（无论该Ticker是否被触发过），一定要调用Stop方法，否则会造成内存和cpu泄漏。</p>
<p>除非程序终止前定时器一直需要触发，否则，不需要时应该调用 Ticker.Stop 来释放相关资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span>    <span class="c1">// receive from the ticker&#39;s channel
</span><span class="c1"></span><span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="c1">// cause the ticker&#39;s goroutine to terminate
</span></code></pre></td></tr></table>
</div>
</div><h2 id="timetick">time.Tick</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Tick函数挺方便，但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适。否则的话,我们应该使用NewTicker.</p>
<h1 id="timeafter的正确用法">time.After的正确用法</h1>
<h2 id="问题">问题</h2>
<p>time.After是一次性触发的，触发后 timer 本身会从时间堆中删除。所以一般情况下直接用 &lt;-time.After 是没有问题的，不过在 for 循环的时候要注意:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
            <span class="nb">println</span><span class="p">(</span><span class="s">&#34;time out, and end&#34;</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码，&lt;-ch 这个 case 每次执行的时间都很短，但每次进入 select，time.After 都会分配一个新的 timer。因此会在短时间内创建大量的无用 timer，虽然没用的 timer 在触发后会消失，但这种写法会造成无意义的 cpu 资源浪费。</p>
<h2 id="解决">解决</h2>
<p>正确的写法应该对 timer 进行重用，如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">timer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
            <span class="nb">println</span><span class="p">(</span><span class="s">&#34;time out, and end&#34;</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果之前的 timer 没用了，可以手动 Stop 以使该 timer 从时间堆中移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="stop与reset的正确用法">Stop与Reset的正确用法</h1>
<h2 id="问题-1">问题</h2>
<p>按照 Timer.Stop 文档 的说法，每次调用 Stop 后需要判断返回值，如果返回 false（表示 Stop 失败，Timer 已经在 Stop 前到期）则需要排掉（drain）channel 中的事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是如果之前程序已经从 channel 中接收过事件，那么上述 &lt;-t.C 就会发生阻塞。可能的解决办法是借助 select 进行 非阻塞 排放（draining）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span> <span class="c1">// try to drain the channel
</span><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是因为 channel 的发送和接收发生在不同的 goroutine，所以 存在竞争条件（race condition），最终可能导致 channel 中的事件未被排掉。</p>
<p>以下就是一种有问题的场景，按时间先后顺序发生：</p>
<p>goroutine A：Go 运行时判断 Timer 已经到期，于是从最小堆中删除该 Timer
goroutine B：应用程序执行 Timer.Stop，发现 Timer 已经到期，进而返回 false
goroutine B：应用程序继续执行 select&hellip;case &lt;-t.C，因为 channel 中并没有事件，所以会立即返回
goroutine A：Go 运行时将到期事件发送到该 Timer 的 channel 中</p>
<p>按照 Timer.Reset 文档 的说法，要正确地 Reset Timer，首先需要正确地 Stop Timer。因此 Reset 的问题跟 Stop 基本相同。</p>
<h2 id="竞争条件">竞争条件</h2>
<p>如果你看过timerproc的代码，你会发现其中的这样一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// $GOROOT/src/runtime/time.go
</span><span class="c1"></span>            <span class="nx">f</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">f</span>
            <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">arg</span>
            <span class="nx">seq</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">seq</span>
            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">timers</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
                <span class="nf">raceacquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">seq</span><span class="p">)</span>
            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">timers</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们看到在timerproc执行f(arg, seq)这个函数前，timerproc unlock了timers.lock，也就是说f的执行并没有在锁内。</p>
<p>前面说过，f的执行是什么？</p>
<ul>
<li>对于AfterFunc来说，就是启动一个goroutine，并在这个新goroutine中执行用户传入的函数；</li>
<li>对于After和NewTimer这种创建姿势创建的timer而言，f的执行就是sendTime的执行，也就是向t.C中send 当前时间。</li>
</ul>
<p>注意：这时候timer expire过程中sendTime的执行与“drain channel”是分别在两个goroutine中执行的，谁先谁后，完全依靠runtime调度。</p>
<ul>
<li>如果sendTime的执行发生在drain channel执行前，那么就是example4.go中的执行结果：Stop返回false（因为timer已经expire了），显式drain channel会将数据读出，后续Reset后，timer正常执行；</li>
<li>如果sendTime的执行发生在drain channel执行后，那么问题就来了，虽然Stop返回false（因为timer已经expire），但drain channel并没有读出任何数据。之后，sendTime将数据发到channel中。timer Reset后的Timer中的Channel实际上已经有了数据，于是当进入下面的select执行体时，”case &lt;-timer.C:”瞬间返回，触发了timer事件，没有启动超时等待的作用。</li>
</ul>
<h2 id="解决-1">解决</h2>
<p>参考 Russ Cox 的回复，目前 Timer 唯一合理的使用方式是：</p>
<ul>
<li>程序始终在同一个 goroutine 中进行 Timer 的 Stop、Reset 和 receive/drain channel 操作</li>
<li>程序需要维护一个状态变量，用于记录它是否已经从 channel 中接收过事件，进而作为 Stop 中 draining 操作的判断依据</li>
</ul>
<p>如果每次使用 Timer 都要按照上述方式来处理，无疑是一件很费神的事。Go 库 <a href="https://github.com/RussellLuo/goodtimer">goodtimer</a> 解决标准 Timer 的问题。</p>
<p>源代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">goodtimer</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="c1">// GoodTimer wraps the standard time.Timer to provide more user-friendly interfaces.
</span><span class="c1">//
</span><span class="c1">// **NOTE**: All the the functions of GoodTimer *should* be used in the same goroutine.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GoodTimer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">t</span>    <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// The actual timer
</span><span class="c1"></span>	<span class="nx">read</span> <span class="kt">bool</span>        <span class="c1">// Whether t.C has already been read from
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// NewGoodTimer creates an instance of GoodTimer.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewGoodTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span><span class="p">)</span> <span class="o">*</span><span class="nx">GoodTimer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">GoodTimer</span><span class="p">{</span><span class="nx">t</span><span class="p">:</span> <span class="nx">t</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ReadC waits until it can read from the wrapped timer&#39;s channel C.
</span><span class="c1">// It returns the time value received from the channel C, a zero time value if the channel C has already been read from.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gt</span> <span class="o">*</span><span class="nx">GoodTimer</span><span class="p">)</span> <span class="nf">ReadC</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gt</span><span class="p">.</span><span class="nx">read</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">tv</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">gt</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span>
	<span class="nx">gt</span><span class="p">.</span><span class="nx">read</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span> <span class="nx">tv</span>
<span class="p">}</span>

<span class="c1">// TryReadC waits for at most the duration d, in order to read from the wrapped timer&#39;s channel C.
</span><span class="c1">// It returns the time value received from the channel C, a zero time value if the channel C has already been read from or if the timeout is reached.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gt</span> <span class="o">*</span><span class="nx">GoodTimer</span><span class="p">)</span> <span class="nf">TryReadC</span><span class="p">(</span><span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gt</span><span class="p">.</span><span class="nx">read</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">tv</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">gt</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
		<span class="nx">gt</span><span class="p">.</span><span class="nx">read</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">return</span> <span class="nx">tv</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">timeout</span><span class="p">):</span>
		<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Reset changes the timer to expire after duration d.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gt</span> <span class="o">*</span><span class="nx">GoodTimer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gt</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="nx">gt</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="nx">gt</span><span class="p">.</span><span class="nx">read</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// Stop prevents the Timer from firing.
</span><span class="c1">// It returns true if the call stops the timer, false if the timer has already expired or been stopped.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">gt</span> <span class="o">*</span><span class="nx">GoodTimer</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">stopped</span> <span class="o">:=</span> <span class="nx">gt</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">stopped</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">gt</span><span class="p">.</span><span class="nx">read</span> <span class="p">{</span>
		<span class="c1">// Drain the gt.t.C if it has not been read from already
</span><span class="c1"></span>		<span class="o">&lt;-</span><span class="nx">gt</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stopped</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">example</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/goodtimer&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Example_blockingRead</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">gt</span> <span class="o">:=</span> <span class="nx">goodtimer</span><span class="p">.</span><span class="nf">NewGoodTimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

	<span class="c1">// Read from the wrapped timer&#39;s channel C.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tv</span> <span class="o">:=</span> <span class="nx">gt</span><span class="p">.</span><span class="nf">ReadC</span><span class="p">();</span> <span class="p">!</span><span class="nx">tv</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The timer fires&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// The timer fires
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Example_nonBlockingRead</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">gt</span> <span class="o">:=</span> <span class="nx">goodtimer</span><span class="p">.</span><span class="nf">NewGoodTimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

	<span class="c1">// Read from the wrapped timer&#39;s channel C, in a non-blocking way.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tv</span> <span class="o">:=</span> <span class="nx">gt</span><span class="p">.</span><span class="nf">TryReadC</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">);</span> <span class="nx">tv</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Timed out before the timer firing&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// Timed out before the timer firing
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Example_stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">gt</span> <span class="o">:=</span> <span class="nx">goodtimer</span><span class="p">.</span><span class="nf">NewGoodTimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

	<span class="c1">// Any operations in the current goroutine.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">gt</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The timer is stopped before firing&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// The timer is stopped before firing
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Example_reset</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">gt</span> <span class="o">:=</span> <span class="nx">goodtimer</span><span class="p">.</span><span class="nf">NewGoodTimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

	<span class="c1">// Any operations in the current goroutine.
</span><span class="c1"></span>
	<span class="nx">gt</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

	<span class="c1">// Now you can use the timer gt again.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="stop的正确用法">Stop的正确用法</h1>
<h2 id="问题-2">问题</h2>
<p>比如，在时间轮里实例化了一个timer定时器对象，然后我在另一个协程里调用timer.Stop()来关闭该定时器，但 &lt;- timer.C不会被通知到，不会被通知就一直被阻塞。</p>
<p>为什么被阻塞，因为我的时间轮代码里只是对定时任务的删除，而没有去close channel，timer.C自然就阻塞。我这边肯定不能直接粗暴的去close channel，因为这样有概率触发panic send on closed channel的问题。</p>
<p>让我们先来看下golang标准库里timer、ticker关于stop方法的实现。src/time/sleep.go里的timer stop调用的是stopTimer方法，最终的stopTimer方法在runtime/time.go里，该方法是使用go:linkname来做的映射。最后调用的是deltimer，该方法的逻辑很简单，就是在heap里删除对应的定时任务，这就完事了….</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;time: Stop called on uninitialized Timer&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go:linkname stopTimer time.stopTimer
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stopTimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">deltimer</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Delete timer t from the heap.
</span><span class="c1">// Do not need to update the timerproc: if it wakes up early, no big deal.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deltimer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tb</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="nx">tb</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tb</span>

    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="nx">removed</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">tb</span><span class="p">.</span><span class="nf">deltimerLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nf">badTimer</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">removed</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>搜寻了半天，在src/time/sleep.go, src/runtime/time.go里没找到关闭channel的逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// xiaorui.cc
</span><span class="c1"></span>
<span class="c1">// The Timer type represents a single event.
</span><span class="c1">// When the Timer expires, the current time will be sent on C,
</span><span class="c1">// unless the Timer was created by AfterFunc.
</span><span class="c1">// A Timer must be created with NewTimer or AfterFunc.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">C</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Time</span>
    <span class="nx">r</span> <span class="nx">runtimeTimer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后不经意间，在Stop()里找到有关close channel的问题说明。</p>
<p>为什么不去close channel？</p>
<p>我们在创建timer的时候会构建runtimeTimer对象，里面有sendTime回调方法及初始化的channel。timerproc是golang runtime的定时扫描器，当发现有任务到期后，进行相应的方法回调。但如果我们在stop里把channel给关闭了，那么timerproc有可能就panic了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// timer定时器的定义
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Duration</span><span class="p">)</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// buf为1, 主要为了优化timerproc的回调性能
</span><span class="c1"></span>    <span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
        <span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
        <span class="nx">r</span><span class="p">:</span> <span class="nx">runtimeTimer</span><span class="p">{</span>
            <span class="nx">when</span><span class="p">:</span> <span class="nf">when</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span>  <span class="c1">// 时间
</span><span class="c1"></span>            <span class="nx">f</span><span class="p">:</span>    <span class="nx">sendTime</span><span class="p">,</span> <span class="c1">// 回调方法
</span><span class="c1"></span>            <span class="nx">arg</span><span class="p">:</span>  <span class="nx">c</span><span class="p">,</span>        <span class="c1">// 参数
</span><span class="c1"></span>        <span class="p">},</span>
    <span class="p">}</span>
    <span class="nf">startTimer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="c1">// 回调方法, default用来负责send.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendTime</span><span class="p">(</span><span class="nx">c</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">seq</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">chan</span> <span class="nx">Time</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="nf">Now</span><span class="p">():</span>
    <span class="k">default</span><span class="p">:</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// runtime/time.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">timerproc</span><span class="p">(</span><span class="nx">tb</span> <span class="o">*</span><span class="nx">timersBucket</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">f</span>
    <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">arg</span>
    <span class="nx">seq</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">seq</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nf">badTimer</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="nf">f</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">seq</span><span class="p">)</span>  <span class="c1">// 有可能会触发 panic send onclosed channel ...
</span><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tb</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="解决-2">解决</h2>
<p>既然他不去close channel，那么我们可以通过context或者创建一个stop channel来做事件的通知。</p>
<h3 id="context">context</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">ctimer</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;exit&#34;</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ctimer</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
        <span class="nf">cancel</span><span class="p">()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stop&#34;</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ticker.C call&#34;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="stop-channel">stop channel</h3>
<p>下面代码通过startTicker创建一个ticker, 当想要关闭这个ticker并同时退出对应goroutine中的for时，可以直接close()，发送done信号直接返回退出startTicker即可.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">Demo</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Demo</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nf">startTicker</span><span class="p">(</span><span class="nx">PrintInfo</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main finished&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">startTicker</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="c1">//	ticker := time.NewTicker(5 * time.Minute)
</span><span class="c1"></span>		<span class="k">defer</span> <span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="nf">f</span><span class="p">()</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">done</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PrintInfo</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参考:<br>
<a href="https://lg1024.com/post/go_timer_ticker.html">https://lg1024.com/post/go_timer_ticker.html</a><br>
<a href="https://segmentfault.com/a/1190000017013443">https://segmentfault.com/a/1190000017013443</a><br>
<a href="http://russellluo.com/2018/09/the-correct-way-to-use-timer-in-golang.html">http://russellluo.com/2018/09/the-correct-way-to-use-timer-in-golang.html</a><br>
<a href="https://tonybai.com/2016/12/21/how-to-use-timer-reset-in-golang-correctly/">https://tonybai.com/2016/12/21/how-to-use-timer-reset-in-golang-correctly/</a><br>
<a href="http://xiaorui.cc/2019/09/09/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90go-time-timer%E5%92%8Cticker%E7%9A%84stop%E9%97%AE%E9%A2%98/">http://xiaorui.cc/2019/09/09/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90go-time-timer%E5%92%8Cticker%E7%9A%84stop%E9%97%AE%E9%A2%98/</a><br>
<a href="http://researchlab.github.io/2016/10/16/close-ticker-correctly/">http://researchlab.github.io/2016/10/16/close-ticker-correctly/</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-10-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E4%B8%ADtrimleft%E5%92%8Ctrimprefix%E7%9A%84%E5%8C%BA%E5%88%AB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go中TrimLeft和TrimPrefix的区别</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84timer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">Go的timer源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
