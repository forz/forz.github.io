<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>P2C&#43;EWMA负载均衡算法实现 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="动态WRR算法(权重轮询) 数据中心内部的负载均衡 在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.3 with theme even" />


<link rel="canonical" href="/post/p2c&#43;ewma%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="P2C&#43;EWMA负载均衡算法实现" />
<meta property="og:description" content="动态WRR算法(权重轮询) 数据中心内部的负载均衡 在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/p2c&#43;ewma%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-24T11:29:23+00:00" />
<meta property="article:modified_time" content="2021-01-24T11:29:23+00:00" />

<meta itemprop="name" content="P2C&#43;EWMA负载均衡算法实现">
<meta itemprop="description" content="动态WRR算法(权重轮询) 数据中心内部的负载均衡 在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点"><meta itemprop="datePublished" content="2021-01-24T11:29:23+00:00" />
<meta itemprop="dateModified" content="2021-01-24T11:29:23+00:00" />
<meta itemprop="wordCount" content="8840">
<meta itemprop="keywords" content="算法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="P2C&#43;EWMA负载均衡算法实现"/>
<meta name="twitter:description" content="动态WRR算法(权重轮询) 数据中心内部的负载均衡 在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">P2C&#43;EWMA负载均衡算法实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-01-24 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
          <span class="more-meta"> 约 8840 字 </span>
          <span class="more-meta"> 预计阅读 18 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#动态wrr算法权重轮询">动态WRR算法(权重轮询)</a></li>
    <li><a href="#p2c算法">P2C算法</a>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#balls-into-bins">Balls into Bins</a></li>
        <li><a href="#power-of-two-random-choices">Power of two random choices</a></li>
        <li><a href="#伪代码">伪代码</a></li>
      </ul>
    </li>
    <li><a href="#ewma算法">EWMA算法</a>
      <ul>
        <li><a href="#加权移动平均算法">加权移动平均算法</a></li>
        <li><a href="#衰减函数调整β值">衰减函数调整β值</a></li>
      </ul>
    </li>
    <li><a href="#算法原理">算法原理</a></li>
    <li><a href="#代码分析">代码分析</a>
      <ul>
        <li><a href="#全局变量--init">全局变量 &amp; init</a></li>
        <li><a href="#p2csubconn">p2c.subConn</a></li>
        <li><a href="#p2cpickerbuilder">p2cPickerBuilder</a></li>
        <li><a href="#p2cpicker">p2cPicker</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="动态wrr算法权重轮询">动态WRR算法(权重轮询)</h2>
<p>数据中心内部的负载均衡</p>
<p>在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。</p>
<p>目标：</p>
<ul>
<li>均衡的流量分发。</li>
<li>可靠的识别异常节点。</li>
<li>scale-out，增加同质节点扩容。</li>
<li>减少错误，提高可用性。</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210117220020.png" alt=""></p>
<p>我们发现在 backend 之间的 load 差异比较大：</p>
<ul>
<li>
<p>每个请求的处理成本不同。</p>
</li>
<li>
<p>物理机环境的差异:</p>
<ul>
<li>服务器很难强同质性。</li>
<li>存在共享资源争用（内存缓存、带宽、IO等）。</li>
</ul>
</li>
<li>
<p>性能因素:</p>
<ul>
<li>FullGC。</li>
<li>JVM JIT。</li>
</ul>
</li>
</ul>
<p>参考JSQ（最闲轮训）负载均衡算法带来的问题，缺乏的是服务端全局视图，因此我们目标需要综合考虑：负载+可用性。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210117221339.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210117221353.png" alt=""></p>
<p>Kratos 在传统的 Nginx-WRR 算法 的基础上，为加权轮询算法增加了 动态调节权重值 ，用户可以在为每一个 Backend 先配置一个初始的权重分，之后算法会根据 Backend 节点 CPU、延迟、服务端错误率、客户端错误率动态打分，（每一次 RPC 调用后）在将打分乘用户自定义的初始权重分得到最后的权重值。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211116213103.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211116213336.png" alt=""></p>
<p>动态感知的 WRR 算法，利用每次 RPC 请求返回的 Response 夹带 CPU 使用率，尽可能感知到服务负载，并且每隔一段时间整体调整一次节点的权重分数，虽然解决了原生WRR的权重固定的问题，但是存在羊群效应问题：“发现其实是信息滞后和分布式带来的羊群效应”，即</p>
<p>就是WRR版本的负载均衡算法虽然会自动刷新权重值，但是在刷新时无法做到完全的实时，再快也不可能超过一个 RTT，都会存在一些信息延迟差。当后台资源比较稀缺时，遇到网络抖动时，就可能会把该节点炸掉，但是在监控上面是感觉不到的，因为 CPU 已经被平均掉了。</p>
<p>从上面的描述看，问题的本质在于gRPC的负载均衡是在客户端实现的，客户端每次请求完获取到服务端CPU数据，可能会存在延迟，在延迟的空档期，大量请求涌入，导致某个后端Node接收大量请求，从而不可用的问题。</p>
<h2 id="p2c算法">P2C算法</h2>
<h3 id="介绍">介绍</h3>
<p>常见的Load balance算法想必大家都不陌生，Random、Round-robin、Least connection、Consistent hash等应该都耳熟能详，这些算法都在实践中有广泛的应用，例如Nginx、Haproxy等负载均衡模块都有相应算法的实现。本文将和大家分享一种全新的Load balance算法：Power of Two Random Choices，也算是Fast 2019 best paper解读《Distcache: Provable load balancing for large-scale storage systems with distributed caching》 的续篇，DistCache利用Power of two random choices实现Cache Query的Load balance：就是在查询Cache中item的时候，从命中的2个Cache节点中选择负载较低的Cache节点来服务；实现简单，效果却不简单。除此之外，新版本的Nginx和Haproxy最近都增加了对Power of Two Random Choices算法的支持，可见一斑。</p>
<p>本文将从Power of Two Random Choices算法的起源说起（也就是数学里面经典的Balls into Bins问题），向大家展示Power of Two Random Choices算法背后的数学原理。并介绍其在解决Hash冲突中的应用，想必能进一步加深大家对Cuckoo Hash、BloomFilter等使用多个hash function做法的理解。</p>
<h3 id="balls-into-bins">Balls into Bins</h3>
<p>首先看数学一个经典的Balls into Bins问题：</p>
<p>假如顺序地将n个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择任意一个bin</p>
<p>那么当抛球结束的时候，以非常高的概率（ 也就是以概率1-ｏ(1)），n个bin中最大负载为(1+ｏ(1))logn/loglogn个balls。注意o(1)指的是高阶无穷小，可以直接忽略掉。</p>
<p>这实际上就是一个无状态的Load balance问题，考虑一个负载均衡器（LB）将n个请求随机等概率的发送给n个Server，那么就可以知道Server上最大的可能负载会是多少。</p>
<h3 id="power-of-two-random-choices">Power of two random choices</h3>
<p>如果选择上做一个小改动，也就是今天要说的Power of two random choices：</p>
<p>假如顺序地将n个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择d个bin，然后选择Ball最少的bin放入</p>
<p>那么当抛球结束的时候，将以非常高的概率（ 也就是以概率1-ｏ(1)），n个bin中最大负载为(1+ｏ(1))loglogn/logd+Ｏ(1)个balls。</p>
<p>现在情况Balls的数量往往远大于Bins的数量，所以扩展一下：</p>
<p>假如顺序地将m个Balls投入到ｎ个bins（垃圾桶），策略是从n个bin中随机独立均匀地选择d个bin，然后选择Ball最少的bin放入，其中m&gt;=n，d&gt;=2</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124114424.png" alt=""></p>
<p>下面给出一个一组计算的算例，分别m=n={2^2,2^3,2^4&hellip;&hellip;,2^64}，其中红色为普通的Balls into Bins问题的最大负载，蓝色为Power of two random choices d=2情况下的最大负载：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124114507.png" alt=""></p>
<p>通过上图可以发现，Power of two random choices负载均衡的效果是不错的。尽管上面的模型太过理想，假定了所有的key都是必须均匀分布，每个request的size都是相同，和实际生产环境相差巨大，但仍然不妨碍我们认定这种做法的有效性。</p>
<h3 id="伪代码">伪代码</h3>
<p>从可用后端节点列表中做 2 次选择操作（随机算法 or 依据一定策略来选择），得到节点 nodeA、nodeB
比较 nodeA、nodeB 两个节点，选出负载最低（一般是正在处理的连接数 / 请求数最少）的节点作为被选中的节点
伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">nodeA</span> <span class="o">=</span> <span class="nf">random_choice</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nodeB</span> <span class="o">=</span> <span class="nf">random_choice</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">best</span> <span class="o">=</span> <span class="nf">least_connection_choice</span><span class="p">(</span><span class="n">[nodeA</span><span class="p">,</span> <span class="n">nodeB]</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ewma算法">EWMA算法</h2>
<h3 id="加权移动平均算法">加权移动平均算法</h3>
<p>指数加权移动平均算法，是对观察值分别给予不同的权数，按不同权数求得移动平均值，并以最后的移动平均值为基础，确定预测值的方法。采用这种算法，是因为观察期的近期观察值对预测值有较大影响，它更能反映近期变化的趋势。</p>
<p>指数移动加权平均法，是指各数值的加权系数随时间呈指数式递减，越靠近当前时刻的数值加权系数就越大。</p>
<ol>
<li>相较于普通的计算平均值算法，EWMA 不需要保存过去所有的数值，计算量显著减少，同时也减小了存储资源。</li>
<li>传统的计算平均值算法对网络耗时不敏感, 而 EWMA 可以通过请求频繁来调节 β，进而迅速监控到网络毛刺或更多的体现整体平均值。
<ul>
<li>当请求较为频繁时, 说明节点网络负载升高了, 我们想监测到此时节点处理请求的耗时(侧面反映了节点的负载情况), 我们就相应的调小β。β越小，EWMA值 就越接近本次耗时，进而迅速监测到网络毛刺;</li>
<li>当请求较为不频繁时, 我们就相对的调大β值。这样计算出来的 EWMA值 越接近平均值</li>
</ul>
</li>
</ol>
<p>公式如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124151343.png" alt=""></p>
<p>解释：vt代表第t次请求的指数加权平均耗时，vt-1代表上次请求的指数加权平均耗时，θt代表第t次请求的实际耗时。</p>
<p>β值的定义如下：</p>
<p>vt ≈ 1/(1 - β) 次的平均耗时</p>
<p>例：假设β等于0.9，1/(1 - β) 就等于10，也就是vt约等于它前10次请求的平均耗时；假设把β值调大道接近1，例如，将β等于0.98，1/(1-β)=50，按照刚刚的说法也就是当前请求的前50次请求的平均耗时。</p>
<p>由此可以推导出：</p>
<p>β值越大，统计区间越大，当前平均值的计算受到之前平均值的影响也就越大（曲线越平滑，呈现一个平缓的变化趋势）</p>
<p>β值越小，统计区间越小，当前平均值的计算受到之前平均值的影响也就越小（曲线贴近统计原值）</p>
<p>β极小时，便可以认为当次的平均耗时约等于当次本身的实际耗时。</p>
<p>上面的结论接下来会通过实验来进行验证。</p>
<p>其实这些根据上面的公式很容易推到出来，比如现在有两次请求，第一次耗时25ms，第二次耗时50ms，代入公式，计算出第一次和第二次的指数加权平均值为：</p>
<p>v1 = β <em>0 + (1 - β)</em> 25</p>
<p>v2 = β <em>v1 + (1 - β)</em> 50</p>
<p>可以看到，β值越小，意味着本次请求的实际耗时占比越大，β值越大，之前计算得到的平均值占比越大。</p>
<p>根据上面的理解，相比普通平均值的计算，它更在乎的是一段时间内的平均趋势，而不是直接把当前实际耗时累加到总耗时里参与算术平均运算，这样有一个好处，那就是平均数变化会更加平滑（这个取决于β值的大小，后续会给出证明）。</p>
<p>我们再来利用此算法来模拟下1000次请求（同样为了模拟真实情况，让一些请求耗时过高），β我们取值0.9，代表最新请求时的平均值计算会受到最近10次耗时的影响进行平滑过渡，运行结果绘制如下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124151637.png" alt=""></p>
<p>可以看到它得出的平均数曲线并没有算术平均那么稳定，但可以看出，每次网络波动会提升其加权均值，不像算术平均值那样完全不受网络波动影响。</p>
<p>接下来同样假设第100~200次请求，发生了网络延迟，延时5倍，再次利用ewma算法做下模拟：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124151653.png" alt=""></p>
<p>请将这张图跟图7进行对比，你会发现，利用指数加权平均算法计算出的平均值在网络恢复时，以极快的速度恢复到了正常水平。</p>
<p>相比算术平均的绝对平均值，指数加权移动平均算法更重要的是它平滑的模拟了平均值的趋势，平均值曲线的峰值和负峰值受β影响，β越大，则当前平均数受到前面数据的影响越大，反之越小，比如我们把图9里的β值调整为0.98，此时在计算当前平均值时则受到前面(1/0.02) = 50个平均值的影响，便得到下图：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124152322.png" alt=""></p>
<p>因为β值大，所以后续每个平均值都会受到更多前面值的影响，而自己的部分仅占很少影响（参考公式理解），所以它相比图9，在出现网络抖动后，更缓慢的恢复为正常均值，但由于它所统计的范围更大，因此平均数曲线会非常平缓，β值越大，统计周期越长，越能体现某个时段的平均趋势（比如图10里的平均数曲线已经趋近于算术平均数）。</p>
<p>再比如，我们将β设置为0.32，那么计算均值时仅受到前面(1/0.68) = 1.47个均值影响，说白了就是平均值轨迹几乎和正常响应时间重叠：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124152350.png" alt=""></p>
<p>可以看到，当β很小时，受影响因子无限趋近于1，越趋近于1则越贴近原本值。</p>
<table>
<thead>
<tr>
<th>实验组</th>
<th>对照组</th>
<th>目的</th>
<th>结论</th>
</tr>
</thead>
<tbody>
<tr>
<td>图6</td>
<td>图8（β=0.9）</td>
<td>模拟网络正常情况下，两种算法对均值的统计区别</td>
<td>算术平均值非常稳定，对单次网络抖动完全无感知，ewma均值则会随着响应时间动态变化，因此单次网络抖动后会稍微提升均值，之后便很快恢复</td>
</tr>
<tr>
<td>图7</td>
<td>图9（β=0.9）</td>
<td>模拟一段网络延迟，看两种算法的均值变化</td>
<td>算术平均值会缓慢提升，之后再次以极慢的速度下降，对网络延迟反映迟钝，网络延迟结束后仍然要花很长时间才能恢复到正常均值水平，ewma均值则迅速提升，恢复后迅速下降至正常水平</td>
</tr>
<tr>
<td>图9（β=0.9）</td>
<td>图10（β=0.98）</td>
<td>调大ewma的β值</td>
<td>β值越大，每次计算均值时受到之前均值影响越大，则平均曲线更加平滑，因此图10的曲线要比图9表现更加平滑，但付出的代价是对网络延迟反应也变的迟钝（但也碾压算术平均）</td>
</tr>
<tr>
<td>图9（β=0.9）</td>
<td>图11（β=0.32）</td>
<td>调小ewma的β值</td>
<td>β值越小，每次计算均值时受到之前均值影响越小，则平均曲线更加趋近于每次的实际耗时，因此图11的曲线要比图9表现的更加趋近于每次的实际耗时，顺理成章的，它对网络延迟的反映极迅速</td>
</tr>
</tbody>
</table>
<p>通过实验，可以看出ewma的优势极大，但β的取值需要仔细斟酌，若β太小，则无法很好的体现出平均值，若β太大，很好的体现了平均值，但对网络波动的反应相对迟钝，这里就考虑到一个折中的方案：</p>
<p>实时调整β值，比如ewma可以在网络波动时适当降低β的值，使其快速感知到波动的存在，当网络波动结束后，适当提升β的值，这样就可以在网络稳定的情况下较好的反映一个区段内的均值情况，这样等于结合了图10和图11各自的优点，实现后将达到一种效果：快速感知网络延迟并迅速提高其均值，当网络恢复后，慢慢降回正常水平（均值恢复需要慢慢进行，因为刚恢复的节点稳定性不可信，慢慢恢复到正常水平，以信任其稳定性）</p>
<h3 id="衰减函数调整β值">衰减函数调整β值</h3>
<p>通过上面的要求，我们需要完善这个变化的β，那么它该如何变化呢？如何能达到碰到网络波动时迅速感知，当波动过后慢慢恢复的效果呢？慢慢恢复需要多慢？可不可以通过调整某个阈值来控制恢复的速率？</p>
<p>带着上面的问题，需要了解一下：衰减函数（参考：牛顿冷却定律）</p>
<p>计算方法为：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195016.png" alt=""></p>
<p>e是数学常量，△t表示第t次请求的耗时，k表示衰减系数，它的函数图如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195024.png" alt=""></p>
<p>我们把k*△t看做x的取值，那么k和△t成正比，即：k和△t取值越大，β就越小</p>
<p>现在来看看这个结论支不支持我们要实现的功能：</p>
<ol>
<li>网络抖动时，假设△t非常大，即便不乘k值，β值也会变得很小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li>
<li>网络恢复时，△t迅速降低，假设此时△t非常小，则k值越大，图12里对应的x越大，β的值就越小，事实上通过实验可以得出，如果k值很大，得出的曲线近乎等于图11。
经过上面的梳理，发现k值似乎没有起到衰减作用，反而因为它的存在导致β值降低，它的取值在网络抖动恢复后依旧在削弱β的值，导致网络恢复后迅速降低到正常水平，这是我们不愿意看到的，那么上面的函数需要做下变体，即让△t和k值成反比即可：</li>
</ol>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195830.png" alt=""></p>
<p>此时结论如下：</p>
<ol>
<li>网络抖动时，假设△t非常大，即便k值起到中和作用，β值较之前也会明显变小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li>
<li>网络恢复时，即使△t迅速降低，那么由于k值的中和（△t/k的值大小和k值成反比），k越大，β越大，则均值计算受之前波动期的均值影响越大，曲线恢复越缓慢。</li>
</ol>
<p>这点可以通过下方的验证得到证实，调整衰减系数k，的确可以控制在遇到波动时恢复到正常水平时的速度，衰减系数设置越大，波幅越大（恢复越慢），反之越小（恢复越快）。</p>
<p>衰减系数验证:</p>
<p>第一组：随机次数的网络抖动，衰减系数分别为600和50</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195901.png" alt=""></p>
<p>衰减系数为600时的走势图，可以看出，网络恢复后均值变化衰减速度很慢</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195913.png" alt=""></p>
<p>衰减系数为50时的走势图，可以看出，网络恢复后均值变化衰减速度很快</p>
<p>第二组：第100~200次请求响应时间扩大5倍，衰减系数仍然是600和50</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195930.png" alt=""></p>
<p>衰减系数为600时的走势图，可以看出在抖动发生时，仍然可以迅速感知，后续恢复时的衰减速度跟上面结果一样慢</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210124195938.png" alt=""></p>
<p>衰减系数为50时的走势图，可以看出在抖动发生时，可以非常迅速的感知，后续恢复时的衰减速度跟上面结果一样快</p>
<h2 id="算法原理">算法原理</h2>
<p>参考了《The power of two choices in randomized load balancing》的思路，我们使用 the choice-of-2 算法，随机选取的两个节点进行打分，选择更优的节点:</p>
<ul>
<li>选择 backend：CPU，client：health、inflight、latency 作为指标，使用一个简单的线性方程进行打分。</li>
<li>对新启动的节点使用常量惩罚值(penalty)，以及使用探针方式最小化放量，进行预热。</li>
<li>打分比较低的节点，避免进入“永久黑名单”而无法恢复，使用统计衰减的方式，让节点指标逐渐恢复到初始状态(即默认值)。
指标计算结合 moving average，使用时间衰减，计算vt = v(t-1) <em>β + at</em> (1-β) ，β为若干次幂的倒数即: Math.Exp((-span) / 600ms)</li>
</ul>
<p>本算法通过随机选择两个 node 选择优胜者来避免羊群效应，并通过 ewma（指数加权移动平均法） 尽量获取服务端的实时状态。</p>
<p>针对 服务端 的指标： 服务端获取最近 500ms 内的 CPU 使用率（针对容器场景：需要将 cgroup 设置的限制考虑进去，并除于 CPU 核心数），并将 CPU 使用率乘与 1000 后塞入每次 gRPC 请求中的的 Trailer 中夹带返回</p>
<p>针对 客户端 的指标：</p>
<ul>
<li>server_cpu：通过每次请求中服务端塞在 trailer 中的 cpu_usage 拿到服务端最近 500ms 内的 cpu 使用率</li>
<li>inflight：当前客户端正在发送并等待 response 的请求数（pending request）</li>
<li>latency: 加权移动平均算法计算出的接口延迟</li>
<li>client_success: 加权移动平均算法计算出的请求成功率（只记录 gRPC 内部错误，比如 context deadline）</li>
</ul>
<p>计算权重的公式如下： (\frac{success<em>metaWeight}{cpu</em>\sqrt{lag}*(inflight+1)})</p>
<p>这个公式的含义很直观，对权重有积极影响的因子，如成功率，初始权重等，位于分子；对权重有消极影响的因子，如cpu负载（过高）、lag延迟（过大）、以及积压的请求数inflight，放在分母的位置。（为了防止除法溢出，inflight做了加1处理）</p>
<p>EWMA 算法的修正（预测）公式是：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211116220208.png" alt=""></p>
<p>其中，在 P2C 算法中，w 系数按照下面的规则获取： w := math.Exp(float64(-td) / float64(tau))</p>
<p>预测的方法是，每隔一段时间进行一次采样，每次采样完成之后，就对预测值进行一次修正，这种方法的特点是近期的采样值对预测值的影响大，远期的影响较小。从算法应用场景可知，和 P2C 算法计算场景比较类似，这里针对 p2c.subConn 结构使用 EWMA 算法，只需要保存上一次计算拿到的结果即可。</p>
<h2 id="代码分析">代码分析</h2>
<h3 id="全局变量--init">全局变量 &amp; init</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// The mean lifetime of `cost`, it reaches its half-life after Tau*ln(2).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tau</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">600</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// if statistic not collected,we add a big penalty to endpoint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">penalty</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">250</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">forceGap</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">_</span> <span class="nx">base</span><span class="p">.</span><span class="nx">PickerBuilder</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">p2cPickerBuilder</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">_</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Picker</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">p2cPicker</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Name is the name of pick of two random choices balancer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;p2c&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// newBuilder creates a new weighted-roundrobin balancer builder.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newBuilder</span><span class="p">()</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Builder</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">base</span><span class="p">.</span><span class="nf">NewBalancerBuilder</span><span class="p">(</span><span class="nx">Name</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">p2cPickerBuilder</span><span class="p">{},</span> <span class="nx">base</span><span class="p">.</span><span class="nx">Config</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">balancer</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nf">newBuilder</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="p2csubconn">p2c.subConn</h3>
<p>p2c.subConn，封装了 balancer.SubConn，代表了 Client 到 Server 的一条长连接，封装了核心属性（计算权重需要）： 其中重要的字段说明如下（牢记一个 subConn 代表了客户端到某个服务端 Node 的唯一属性）：</p>
<ul>
<li>meta：在服务发现（Etcd）中设置的元数据值</li>
<li>lag：请求延迟（用于与下次实现加权计算）</li>
<li>success：使用加权算法拿到的客户端 RPC 调用成功率</li>
<li>inflight：当前正在处理的请求数</li>
<li>svrCPU：保存了服务端返回的最近一段时间的 CPU 使用率</li>
<li>stamp：保存上次计算权重的时间戳（Nano）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">subConn</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// metadata
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span>
</span></span><span class="line"><span class="cl">	<span class="nx">addr</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span>
</span></span><span class="line"><span class="cl">	<span class="nx">meta</span> <span class="nx">wmd</span><span class="p">.</span><span class="nx">MD</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//client statistic data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lag</span>      <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">success</span>  <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">inflight</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// server statistic data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">svrCPU</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//last collected timestamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stamp</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//last pick timestamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pick</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// request number in a period time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">reqs</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>p2c.subConn 实现的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="nf">valid</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sc</span><span class="p">.</span><span class="nf">health</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">500</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">svrCPU</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">900</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="nf">health</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">success</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="nf">load</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lag</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lag</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">load</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">svrCPU</span><span class="p">)</span> <span class="o">*</span> <span class="nx">lag</span> <span class="o">*</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">inflight</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">load</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// penalty是初始化没有数据时的惩罚值，默认为1e9 * 250
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">load</span> <span class="p">=</span> <span class="nx">penalty</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">load</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="nf">cost</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">load</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">svrCPU</span><span class="p">)</span> <span class="o">*</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lag</span><span class="p">)</span> <span class="o">*</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sc</span><span class="p">.</span><span class="nx">inflight</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">load</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// penalty是初始化没有数据时的惩罚值，默认为1e9 * 250
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">load</span> <span class="p">=</span> <span class="nx">penalty</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">load</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="p2cpickerbuilder">p2cPickerBuilder</h3>
<p>p2cPickerBuilder.Build 在每次后端节点有增减的情况下调用，初始化时会调用一次，readySCs 保存了后端服务器的基础信息，从代码实现上看，也是做了对节点的初始化工作： 当后端有删减时，也会强制把已存在的后端节点进行初始化：</p>
<p>这里后端的初始化数据为</p>
<ul>
<li>svrCPU: 500</li>
<li>lag： 0</li>
<li>success：1000</li>
<li>inflight： 1</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p2cPickerBuilder</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">p2cPickerBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">readySCs</span> <span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">)</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Picker</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p2cPicker</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">colors</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">p2cPicker</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 初始化 rand 种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">r</span><span class="p">:</span>      <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化后端的权重数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">readySCs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;[p2cPickerBuilder.Builder]init:&#34;</span><span class="p">,</span><span class="nx">addr</span><span class="p">,</span><span class="nx">sc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">meta</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.(</span><span class="nx">wmd</span><span class="p">.</span><span class="nx">MD</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">meta</span> <span class="p">=</span> <span class="nx">wmd</span><span class="p">.</span><span class="nx">MD</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">Weight</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">subc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">subConn</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">conn</span><span class="p">:</span> <span class="nx">sc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">addr</span><span class="p">:</span> <span class="nx">addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">meta</span><span class="p">:</span> <span class="nx">meta</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">svrCPU</span><span class="p">:</span>   <span class="mi">500</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">lag</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">success</span><span class="p">:</span>  <span class="mi">1000</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">inflight</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">meta</span><span class="p">.</span><span class="nx">Color</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">,</span> <span class="nx">subc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// if color not empty, use color picker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 如果服务端定义了 color 筛选，则启动 color 的选择逻辑（测试时没用）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">cp</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">colors</span><span class="p">[</span><span class="nx">meta</span><span class="p">.</span><span class="nx">Color</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">cp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">p2cPicker</span><span class="p">{</span><span class="nx">r</span><span class="p">:</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()))}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">p</span><span class="p">.</span><span class="nx">colors</span><span class="p">[</span><span class="nx">meta</span><span class="p">.</span><span class="nx">Color</span><span class="p">]</span> <span class="p">=</span> <span class="nx">cp</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cp</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">subConns</span><span class="p">,</span> <span class="nx">subc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="p2cpicker">p2cPicker</h3>
<p>p2c.Picker 实现了负载均衡的选择逻辑：</p>
<ol>
<li>Pick：主方法入口</li>
<li>先调用 prePick，选择两个随机的 node</li>
<li>最后从上一步的 node 列表中选取一个合适的 node，返回其对应的subConn，执行 RPC 请求</li>
<li>根据RPC请求结果及 node 回带的服务端 CPU 字段信息，更新本 subConn 的核心因子信息
<ul>
<li>stamp</li>
<li>success</li>
<li>lag</li>
</ul>
</li>
</ol>
<p>p2cPicker 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p2cPicker</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// subConns is the snapshot of the weighted-roundrobin balancer when this picker was
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// created. The slice is immutable. Each Get() will do a round robin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// selection from it and return the selected SubConn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">subConns</span> <span class="p">[]</span><span class="o">*</span><span class="nx">subConn</span>		<span class="c1">// 保存所有的后端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">colors</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">p2cPicker</span>
</span></span><span class="line"><span class="cl">	<span class="nx">logTs</span>    <span class="kt">int64</span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span>        <span class="o">*</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Rand</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lk</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来着重分析下 pick 和 prePick 方法：</p>
<p>prePick 方法，实现了随机选择的逻辑，总循环 3 次，随机从 <code>subConns []*subConn</code> 中选择两个节点 nodeB 和 nodeA，如果满足 <code>node.valid()</code> 的要求，直接返回，不满足的话，返回最后一次的选择的两个节点： 注意返回值中的 nodeA 和 nodeB 都是 subConn 结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// choose two distinct nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p2cPicker</span><span class="p">)</span> <span class="nf">prePick</span><span class="p">()</span> <span class="p">(</span><span class="nx">nodeA</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">,</span> <span class="nx">nodeB</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">lk</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">lk</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nodeA</span><span class="p">,</span> <span class="nx">nodeB</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">a</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">nodeA</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="o">||</span> <span class="nx">nodeB</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>picker 的实现如下，重要部分已加了注释，需要关注的有如下几点信息：</p>
<ol>
<li>DoneInfo() 是在 RPC 方法执行完成后的回调，主要用于在 gRPC 的 Trailer 返回的 pc 对应的服务端 CPU 信息，根据此 CPU 信息，更新 pc 这个 subConn 的相关信息</li>
<li>计算权重分数的方法，每次请求来时我们都会更新延迟，并且把之前获得的时间延迟进行权重的衰减，新获得的时间提高权重，这样就实现了滚动更新</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p2cPicker</span><span class="p">)</span> <span class="nf">Pick</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">PickResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// FIXME refactor to unify the color logic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">color</span> <span class="o">:=</span> <span class="nx">nmd</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">,</span> <span class="nx">nmd</span><span class="p">.</span><span class="nx">Color</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">color</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">env</span><span class="p">.</span><span class="nx">Color</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">color</span> <span class="p">=</span> <span class="nx">env</span><span class="p">.</span><span class="nx">Color</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">color</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">cp</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">colors</span><span class="p">[</span><span class="nx">color</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">cp</span><span class="p">.</span><span class="nf">pick</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pick</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p2cPicker</span><span class="p">)</span> <span class="nf">pick</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">PickResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">upc</span> <span class="o">*</span><span class="nx">subConn</span>
</span></span><span class="line"><span class="cl">	<span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickResult</span><span class="p">{},</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 只有 1 个节点，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">pc</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nodeA</span><span class="p">,</span> <span class="nx">nodeB</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">prePick</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// meta.Weight为服务发布者在disocvery中设置的权重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">nodeA</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span><span class="o">*</span><span class="nx">nodeB</span><span class="p">.</span><span class="nf">health</span><span class="p">()</span><span class="o">*</span><span class="nx">nodeB</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">Weight</span> <span class="p">&gt;</span> <span class="nx">nodeB</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span><span class="o">*</span><span class="nx">nodeA</span><span class="p">.</span><span class="nf">health</span><span class="p">()</span><span class="o">*</span><span class="nx">nodeA</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">Weight</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//pc 为本次算法选择的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">pc</span><span class="p">,</span> <span class="nx">upc</span> <span class="p">=</span> <span class="nx">nodeB</span><span class="p">,</span> <span class="nx">nodeA</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pc</span><span class="p">,</span> <span class="nx">upc</span> <span class="p">=</span> <span class="nx">nodeA</span><span class="p">,</span> <span class="nx">nodeB</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果选中的节点，在forceGap期间内没有被选中一次，那么强制一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 利用强制的机会，来触发成功率、延迟的衰减
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 原子锁conn.pick保证并发安全，放行一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">pick</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">upc</span><span class="p">.</span><span class="nx">pick</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">start</span><span class="o">-</span><span class="nx">pick</span> <span class="p">&gt;</span> <span class="nx">forceGap</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">upc</span><span class="p">.</span><span class="nx">pick</span><span class="p">,</span> <span class="nx">pick</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pc</span> <span class="p">=</span> <span class="nx">upc</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 节点未发生切换才更新pick时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">pc</span> <span class="o">!=</span> <span class="nx">upc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">pick</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">inflight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">reqs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// RPC 方法执行完成后，更新状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickResult</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">SubConn</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Done</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">di</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前正在处理的请求数减 1，好理解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">inflight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 取当前的时间戳（Nano）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// get moving average ratio w
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 获取 &amp;&amp; 设置上次测算的时间点，将 pc.stamp 的值更新为 now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">stamp</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">SwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">stamp</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取时间间隔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">td</span> <span class="o">:=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">stamp</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">td</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">td</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取时间衰减系数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">w</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Exp</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">td</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">tau</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获得本次延迟数据 1（注意 start 是在 pick 开始计时的）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">lag</span> <span class="o">:=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">start</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">lag</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">lag</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 获取上次保存的延迟数据 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">oldLag</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">lag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">oldLag</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">w</span> <span class="p">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 延迟数据 1 与延迟数据 2，计算出平均延迟（EWMA）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">lag</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">oldLag</span><span class="p">)</span><span class="o">*</span><span class="nx">w</span> <span class="o">+</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">lag</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="nx">w</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 保存本地计算出的延迟数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">lag</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lag</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">success</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">// error value ,if error set 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">di</span><span class="p">.</span><span class="nx">Err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">FromError</span><span class="p">(</span><span class="nx">di</span><span class="p">.</span><span class="nx">Err</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// only counter the local grpc error, ignore any business error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Code</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">codes</span><span class="p">.</span><span class="nx">Unknown</span> <span class="o">&amp;&amp;</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Code</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">codes</span><span class="p">.</span><span class="nx">OK</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">success</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">oldSuc</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">success</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">success</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">oldSuc</span><span class="p">)</span><span class="o">*</span><span class="nx">w</span> <span class="o">+</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">success</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="nx">w</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">success</span><span class="p">,</span> <span class="nx">success</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从服务端的 Trailer 中拿到 CPU 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">trailer</span> <span class="o">:=</span> <span class="nx">di</span><span class="p">.</span><span class="nx">Trailer</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">strs</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">trailer</span><span class="p">[</span><span class="nx">wmd</span><span class="p">.</span><span class="nx">CPUUsage</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">err2</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseUint</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span> <span class="nx">err2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cpu</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pc</span><span class="p">.</span><span class="nx">svrCPU</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">logTs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">logTs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">now</span><span class="o">-</span><span class="nx">logTs</span> <span class="p">&gt;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 超过一个 3s 的周期，尝试打印当前状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">logTs</span><span class="p">,</span> <span class="nx">logTs</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">p</span><span class="p">.</span><span class="nf">printStats</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>trailer需要另一个服务端在返回请求时传入,通常加在中间件里面:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stats</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">args</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryHandler</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nx">trailer</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">Pairs</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;serverinfo&#34;</span><span class="p">,</span> <span class="s">&#34;enjoy&#34;</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 每次 rpc 请求时，放在 tailer，上报至 discovery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">grpc</span><span class="p">.</span><span class="nf">SetTrailer</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">trailer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/64538762">The Power of Two Random Choices</a></p>
<p><a href="https://blog.csdn.net/m0_38106113/article/details/81542863">深入解析TensorFlow中滑动平均模型与代码实现</a></p>
<p><a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a></p>
<p><a href="https://pandaychen.github.io/2020/03/11/KRATOS-LB-ALGORITHM-ANALYSIS/">Kratos 源码分析：分析 Warden 框架 Dynamic-WRR 负载均衡算法的实现</a></p>
<p><a href="https://pandaychen.github.io/2020/07/25/KRATOS-WARDEN-BALANCER-P2C-ANALYSIS/">Kratos 源码分析：Warden 负载均衡算法之 P2C</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-01-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpu%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CPU缓存与伪共享</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/grpc%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">
            <span class="next-text nav-default">GRPC的服务发现与负载均衡</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
