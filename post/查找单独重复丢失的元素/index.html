<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>查找单独/重复/丢失的元素 | Forz Blog</title>
<meta name="keywords" content="Bit Manipulation" />
<meta name="description" content="LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="查找单独/重复/丢失的元素" />
<meta property="og:description" content="LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T23:58:53&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T23:58:53&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="查找单独/重复/丢失的元素"/>
<meta name="twitter:description" content="LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "查找单独/重复/丢失的元素",
      "item": "/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "查找单独/重复/丢失的元素",
  "name": "查找单独\/重复\/丢失的元素",
  "description": "LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所",
  "keywords": [
    "Bit Manipulation"
  ],
  "articleBody": "LeetCode 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所求解以外，其他的数都出现两次，可以直接用异或来抵消掉。\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public: int singleNumber(vectorint\u0026 nums) { int result = 0 ; for (int i=0; inums.size(); i++) { result ^= nums[i]; } return result; } };   LeetCode 137. Single Number II Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n解析：\n与上题不同的是除了所求解外其他数都出现三次。可以构建一个三进制的异或。\n异或的本质就是不进位加法，所以先创建一个长度为32的数组统计所有元素二进制形式下的每一位，统计过程中，要使该位保持三进制不进位加法形式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: int singleNumber(vectorint\u0026 nums) { int count[32]={0}; int result=0; for(int i=0;i32;i++){ //统计所有数的每一位  for(int j=0;jnums.size();j++){ count[i]+=((nums[j]i)\u00261); //首先把输入数字的第i位加起来。  count[i]=count[i]%3; //然后对3取余。  } result|=(count[i]i);//把二进制表示的结果转化为十进制表示的结果  } return result; } };   LeetCode 260. Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\nFor example:\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\nNote:\nThe order of the result is not important. So in the above example, [5, 3] is also correct.\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\n解析：\n首先，对数组中所有数字做异或运算，这样得到的结果为2个单独数字异或运算的结果。\n因为有两个元素不同，所以所有元素异或以后肯定不会为0，至少有一位为1。这一位和两个单独数异或肯定产生不同的结果，可以根据这个条件。将nums数组分成2组：每组是1个单独数+多个数对\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public: vectorint singleNumber(vectorint\u0026 nums) { int diff = accumulate(nums.begin(), nums.end(), 0, bit_xorint()); diff \u0026= -diff;//正数和负数取反的补码都是各位取反后加1  vectorint rets = {0, 0}; //保存结果  for (int num : nums) { if ((num \u0026 diff) == 0) // the bit is not set  { rets[0] ^= num; } else // the bit is set  { rets[1] ^= num; } } return rets; } };   结论：\n整数运算 x\u0026(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。\n  当x为0时，x\u0026(-x) 即 0 \u0026 0，结果为0；\n  当x不为0时，x和-x必有一个为正。不失一般性，设x为正。\n  当x为奇数时，最后一个比特为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。最后一位都为1，故结果为1。\n  当x为偶数，且为2的m次方（m0）时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，左边也都是0（个数由表示x的字节数决定），故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x\u0026 (-x) 得到的就是x。\n  当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位,因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与得到：第k+1位上为1，左边右边都为0。结果为2^k，即x中包含的2的最大次方的因子。\n    总结： x\u0026(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。\n比如x=32，其中2的最大次方因子为2^5，故x\u0026(-x)结果为32；当x=28，其中2的最大次方因 子为4，故x \u0026 (-x)结果为4。当x=24，其中2的最大次方因子为8,故 x\u0026(-x)结果为8。\nLeetCode 268. Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.\nFor example, Given nums = [0, 1, 3] return 2.\nNote: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?\n解析：此题给定数字范围是0~n，且n=nums.size(),要求数组中缺少的一个数字，可以先将result依次和0到n异或，然后再和数组内的元素异或，这就转化为上题的求解过程。实现过程中有一些小优化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public: int missingNumber(vector\u0026 nums) { int result = nums.size(); int i=0; for(int num:nums){ result ^= num; result ^= i; i++; } return result; } };   LeetCode 389. Find the Difference Given two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nFind the letter that was added in t.\nExample:\nInput: s = \"abcd\" t = \"abcde\" Output: e  Explanation:\n‘e’ is the letter that was added.\n解析：本题可以转化为在s+t字符串中找出一个单独字符。字符和数字相同，拼接成一个字符串后直接异或，留下来的那个就是多余元素。\n1 2 3 4 5 6 7 8 9  class Solution { public: char findTheDifference(string s, string t) { s += t; int ch =0; for(auto val: s) ch ^= val; return ch; } };   补充：hash方法\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public: char findTheDifference(string s, string t) { unordered_mapchar, int hash; char ans; for(auto ch: s) hash[ch]++; for(auto ch: t) if(--hash[ch]0) ans = ch; return ans; } };   LeetCode 448. Find All Numbers Disappeared in an Array Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\nExample:\nInput: [4,3,2,7,8,2,3,1] Output: [5,6]  解析：\n此题无法判断到底有多少个消失数字，所以不能用位运算（位运算只能判断至多2个消失或单独字）。\n核心思想就是遍历数组时，将每个元素，和以该元素为下标的元素进行置换，比如第一个元素是3，就将它置换到下标为3的地方，而原本下标为3的地方的元素就换到第一个来。如果换来的元素也是在正确的位置就检查下一个元素，否则继续交换，直到：\n待交换的两个数是一样的，数字位置正确。\n之后从0到nums.size()进行枚举，因为消失的数字肯定在这个范围内。将所有消失的数字放到结果中。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: vectorint findDisappearedNumbers(vectorint\u0026 nums) { vectorint res; for(int i = 0; i  nums.size(); ++i) while(nums[nums[i]-1] != nums[i]) swap(nums[nums[i]-1], nums[i]); for(int i = 0; i  nums.size(); ++i) if(nums[i] != i+1) res.push_back(i+1); return res; } };   LeetCode 41. First Missing Positive Given an unsorted integer array, find the first missing positive integer.\nFor example,\nGiven [1,2,0] return 3, and [3,4,-1,1] return 2.\nYour algorithm should run in O(n) time and uses constant space.\n解析：\n此题和上题基本相似，只有一点区别：数组中存在负数和超出数组大小的数字。这些数字是无用数字。负数不考虑，超出界限的数之前肯定有消失数字，否则不会大到超出界限。\n因为这些数字的影响，需要修改循环条件。如果换来的元素也是在正确的位置就检查下一个元素，否则继续交换，直到：\n  待交换的两个数是一样的，这些数字必须保证位置正确。要依靠这些数字判断结果\n  当前位置的元素没有对应的目的地（比如负数，或者超界元素），这些数字无法找到正确的位置\n  之后从0到nums.size()进行枚举，因为消失的数字肯定在这个范围内。找到 nums[i] != i+1 就可以返回结果了\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int firstMissingPositive(vectorint\u0026 nums) { for(int i = 0; i  nums.size(); ++i) while(nums[i]  0 \u0026\u0026 nums[i]  nums.size()\u0026\u0026nums[nums[i]-1] != nums[i]) swap(nums[nums[i]-1], nums[i]); for(int i = 0; i  nums.size(); ++i)//  if(nums[i] != i+1) return i+1; return nums.size()+1; } };   LeetCode 442. Find All Duplicates in an Array Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\nFind all the elements that appear twice in this array.\nCould you do it without extra space and in O(n) runtime?\nExample:\nInput: [4,3,2,7,8,2,3,1] Output: [2,3]  解析：和上上题完全没有区别。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: vectorint findDuplicates(vectorint\u0026 nums) { vectorint res; for(int i = 0; i  nums.size(); ++i) while(nums[nums[i] - 1] != nums[i]) swap(nums[nums[i] - 1], nums[i]); for(int i = 0; i  nums.size(); ++i) if(nums[i] != i + 1) res.push_back(nums[i]); return res; } };   ",
  "wordCount" : "2701",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T23:58:53Z",
  "dateModified": "2017-06-24T23:58:53Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9F%A5%E6%89%BE%E5%8D%95%E7%8B%AC%E9%87%8D%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      查找单独/重复/丢失的元素
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-136-single-number">LeetCode 136. Single Number<a hidden class="anchor" aria-hidden="true" href="#leetcode-136-single-number">#</a></h1>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note: <br>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>解析：利用异或运算规律，同一个数异或两次相当于没有异或。本题除了所求解以外，其他的数都出现两次，可以直接用异或来抵消掉。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
    <span class="kt">int</span> <span class="n">singleNumber</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">result</span> <span class="o">^=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
        <span class="p">}</span>  
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>  
    <span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-137-single-number-ii">LeetCode 137. Single Number II<a hidden class="anchor" aria-hidden="true" href="#leetcode-137-single-number-ii">#</a></h1>
<p>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note: <br>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>解析：</p>
<p>与上题不同的是除了所求解外其他数都出现三次。可以构建一个三进制的异或。</p>
<p>异或的本质就是不进位加法，所以先创建一个长度为32的数组统计所有元素二进制形式下的每一位，统计过程中，要使该位保持三进制不进位加法形式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">singleNumber</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>  
    <span class="kt">int</span> <span class="n">result</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">//统计所有数的每一位
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>  
            <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//首先把输入数字的第i位加起来。  
</span><span class="c1"></span>            <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="mi">3</span><span class="p">;</span> <span class="c1">//然后对3取余。  
</span><span class="c1"></span>        <span class="p">}</span>  
        <span class="n">result</span><span class="o">|=</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">);</span><span class="c1">//把二进制表示的结果转化为十进制表示的结果  
</span><span class="c1"></span>    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>  
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-260-single-number-iii">LeetCode 260. Single Number III<a hidden class="anchor" aria-hidden="true" href="#leetcode-260-single-number-iii">#</a></h1>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:</p>
<p>The order of the result is not important. So in the above example, [5, 3] is also correct.</p>
<p>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p>解析：</p>
<p>首先，对数组中所有数字做异或运算，这样得到的结果为2个单独数字异或运算的结果。</p>
<p>因为有两个元素不同，所以所有元素异或以后肯定不会为0，至少有一位为1。这一位和两个单独数异或肯定产生不同的结果，可以根据这个条件。将nums数组分成2组：每组是1个单独数+多个数对</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">singleNumber</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> 
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bit_xor</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">diff</span> <span class="o">&amp;=</span> <span class="o">-</span><span class="n">diff</span><span class="p">;</span><span class="c1">//正数和负数取反的补码都是各位取反后加1
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rets</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">//保存结果
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">num</span> <span class="o">&amp;</span> <span class="n">diff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// the bit is not set
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">rets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span> <span class="n">num</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="c1">// the bit is set
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">rets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^=</span> <span class="n">num</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>结论：</p>
<p>整数运算 x&amp;(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。</p>
<ol>
<li>
<p>当x为0时，x&amp;(-x) 即 0 &amp; 0，结果为0；</p>
</li>
<li>
<p>当x不为0时，x和-x必有一个为正。不失一般性，设x为正。</p>
<ol>
<li>
<p>当x为奇数时，最后一个比特为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。最后一位都为1，故结果为1。</p>
</li>
<li>
<p>当x为偶数，且为2的m次方（m&gt;0）时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，左边也都是0（个数由表示x的字节数决定），故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x&amp; (-x) 得到的就是x。</p>
</li>
<li>
<p>当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位,因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与得到：第k+1位上为1，左边右边都为0。结果为2^k，即x中包含的2的最大次方的因子。</p>
</li>
</ol>
</li>
</ol>
<h2 id="总结">总结：<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>x&amp;(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。</p>
<p>比如x=32，其中2的最大次方因子为2^5，故x&amp;(-x)结果为32；当x=28，其中2的最大次方因
子为4，故x &amp; (-x)结果为4。当x=24，其中2的最大次方因子为8,故 x&amp;(-x)结果为8。</p>
<h1 id="leetcode-268-missing-number">LeetCode 268. Missing Number<a hidden class="anchor" aria-hidden="true" href="#leetcode-268-missing-number">#</a></h1>
<p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example, <br>
Given nums = [0, 1, 3] return 2.</p>
<p>Note: <br>
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p>解析：此题给定数字范围是0~n，且n=nums.size(),要求数组中缺少的一个数字，可以先将result依次和0到n异或，然后再和数组内的元素异或，这就转化为上题的求解过程。实现过程中有一些小优化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">missingNumber</span><span class="p">(</span><span class="n">vector</span><span class="o">&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span><span class="p">:</span><span class="n">nums</span><span class="p">){</span>
        <span class="n">result</span> <span class="o">^=</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">^=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-389-find-the-difference">LeetCode 389. Find the Difference<a hidden class="anchor" aria-hidden="true" href="#leetcode-389-find-the-difference">#</a></h1>
<p>Given two strings s and t which consist of only lowercase letters.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Find the letter that was added in t.</p>
<p>Example:</p>
<pre><code>Input:
s = &quot;abcd&quot;
t = &quot;abcde&quot;

Output:
e
</code></pre>
<p>Explanation:</p>
<p>‘e’ is the letter that was added.</p>
<p>解析：本题可以转化为在s+t字符串中找出一个单独字符。字符和数字相同，拼接成一个字符串后直接异或，留下来的那个就是多余元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">char</span> <span class="n">findTheDifference</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ch</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="n">ch</span> <span class="o">^=</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：hash方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">char</span> <span class="n">findTheDifference</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>  
    <span class="kt">char</span> <span class="n">ans</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span><span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="n">hash</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span>   
        <span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">hash</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>   
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-448-find-all-numbers-disappeared-in-an-array">LeetCode 448. Find All Numbers Disappeared in an Array<a hidden class="anchor" aria-hidden="true" href="#leetcode-448-find-all-numbers-disappeared-in-an-array">#</a></h1>
<p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:</p>
<pre><code>Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
</code></pre>
<p>解析：</p>
<p>此题无法判断到底有多少个消失数字，所以不能用位运算（位运算只能判断至多2个消失或单独字）。</p>
<p>核心思想就是遍历数组时，将每个元素，和以该元素为下标的元素进行置换，比如第一个元素是3，就将它置换到下标为3的地方，而原本下标为3的地方的元素就换到第一个来。如果换来的元素也是在正确的位置就检查下一个元素，否则继续交换，直到：</p>
<p>待交换的两个数是一样的，数字位置正确。</p>
<p>之后从0到nums.size()进行枚举，因为消失的数字肯定在这个范围内。将所有消失的数字放到结果中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findDisappearedNumbers</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-41-first-missing-positive">LeetCode 41. First Missing Positive<a hidden class="anchor" aria-hidden="true" href="#leetcode-41-first-missing-positive">#</a></h1>
<p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,</p>
<p>Given [1,2,0] return 3,
and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<p>解析：</p>
<p>此题和上题基本相似，只有一点区别：数组中存在负数和超出数组大小的数字。这些数字是无用数字。负数不考虑，超出界限的数之前肯定有消失数字，否则不会大到超出界限。</p>
<p>因为这些数字的影响，需要修改循环条件。如果换来的元素也是在正确的位置就检查下一个元素，否则继续交换，直到：</p>
<ol>
<li>
<p>待交换的两个数是一样的，这些数字必须保证位置正确。要依靠这些数字判断结果</p>
</li>
<li>
<p>当前位置的元素没有对应的目的地（比如负数，或者超界元素），这些数字无法找到正确的位置</p>
</li>
</ol>
<p>之后从0到nums.size()进行枚举，因为消失的数字肯定在这个范围内。找到 nums[i] != i+1 就可以返回结果了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">firstMissingPositive</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&amp;&amp;</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-442-find-all-duplicates-in-an-array">LeetCode 442. Find All Duplicates in an Array<a hidden class="anchor" aria-hidden="true" href="#leetcode-442-find-all-duplicates-in-an-array">#</a></h1>
<p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements that appear twice in this array.</p>
<p>Could you do it without extra space and in O(n) runtime?</p>
<p>Example:</p>
<pre><code>Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
</code></pre>
<p>解析：和上上题完全没有区别。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findDuplicates</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/bit-manipulation/">Bit Manipulation</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
