<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Pprof实战:从零开始排查炸弹程序 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可">
<meta name="author" content="">
<link rel="canonical" href="/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Pprof实战:从零开始排查炸弹程序" />
<meta property="og:description" content="前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-02-09T17:45:44&#43;00:00" />
<meta property="article:modified_time" content="2020-02-09T17:45:44&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pprof实战:从零开始排查炸弹程序"/>
<meta name="twitter:description" content="前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Pprof实战:从零开始排查炸弹程序",
      "item": "/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Pprof实战:从零开始排查炸弹程序",
  "name": "Pprof实战:从零开始排查炸弹程序",
  "description": "前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可",
  "keywords": [
    "Go"
  ],
  "articleBody": "前言 如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可厚非，毕竟 pprof 是当程序占用资源异常时才需要启用的工具，而我相信大家的编码水平和排查问题的能力是足够高的，一般不会写出性能极度堪忧的程序，且即使发现有一些资源异常占用，也会通过排查代码快速定位，这也导致 pprof 需要上战场的机会少之又少。即使大家有心想学习使用 pprof，却也常常相忘于江湖。\n既然如此，那我就送大家一个性能极度堪忧的“炸弹”程序吧！\n这程序没啥正经用途缺极度占用资源，基本覆盖了常见的性能问题。本文就是希望读者能一步一步按照提示，使用 pprof 定位这个程序的的性能瓶颈所在，借此学习 pprof 工具的使用方法。\n因此，本文是一场“实验课”而非“理论课”，请读者腾出时间，脚踏实地，一步一步随实验步骤进行操作，这会是一个很有趣的冒险，不会很无聊，希望你能喜欢。\n实验准备 这里假设你有基本的 golang 开发功底，拥有 golang 开发环境并配置了 $GOPATH，能熟练阅读简单的代码或进行简单的修改，且知道如何编译运行 golang 程序。此外，需要你大致知道 pprof 是干什么的，有一个基本印象即可，你可以花几分钟时间读一下《Golang 大杀器之性能剖析 PProf》的开头部分，这不会耽误太久。\n此外由于你需要运行一个“炸弹”程序，请务必确保你用于做实验的机器有充足的资源，你的机器至少需要：\n 2 核 CPU； 2G 内存。  注意，以上只是最低需求，你的机器配置能高于上述要求自然最好。实际运行“炸弹”时，你可以关闭电脑上其他不必要的程序，甚至 IDE 都不用开，我们的实验操作基本上是在命令行里进行的。\n此外，务必确保你是在个人机器上运行“炸弹”的，能接受机器死机重启的后果（虽然这发生的概率很低）。请你务必不要在危险的边缘试探，比如在线上服务器运行这个程序。\n可能说得你都有点害怕了，为打消你顾虑，我可以剧透一下“炸弹”的情况，让你安心：\n 程序会占用约 2G 内存； 程序占用 CPU 最高约 100%（总量按“核数 * 100%”来算）； 程序不涉及网络或文件读写； 程序除了吃资源之外没有其他危险操作。  且程序所占用的各类资源，均不会随着运行时间的增长而增长，换句话说，只要你把“炸弹”启动并正常运行了一分钟，就基本确认安全了，之后即使运行几天也不会有更多的资源占用，除了有点费电之外。\n获取“炸弹” 炸弹程序的代码我已经放到了 GitHub 上，你只需要在终端里运行 go get 便可获取，注意加上 -d 参数，避免下载后自动安装：\n1 2  go get -d github.com/wolfogre/go-pprof-practice cd $GOPATH/src/github.com/wolfogre/go-pprof-practice   我们可以简单看一下 main.go 文件，里面有几个帮助排除性能调问题的关键的的点，我加上了些注释方便你理解，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main import ( // 略 \t_ \"net/http/pprof\" // 会自动注册 handler 到 http server，方便通过 http 接口获取程序运行采样报告 \t// 略 ) func main() { // 略  runtime.GOMAXPROCS(1) // 限制 CPU 使用数，避免过载 \truntime.SetMutexProfileFraction(1) // 开启对锁调用的跟踪 \truntime.SetBlockProfileRate(1) // 开启对阻塞操作的跟踪  go func() { // 启动一个 http server，注意 pprof 相关的 handler 已经自动注册过了 \tif err := http.ListenAndServe(\":6060\", nil); err != nil { log.Fatal(err) } os.Exit(0) }() // 略 }   除此之外的其他代码你一律不用看，那些都是我为了模拟一个“逻辑复杂”的程序而编造的，其中大多数的问题很容易通过肉眼发现，但我们需要做的是通过 pprof 来定位代码的问题，所以为了保证实验的趣味性请不要提前阅读代码，可以实验完成后再看。\n接着我们需要编译一下这个程序并运行，你不用担心依赖问题，这个程序没有任何外部依赖。\n1 2  go build ./go-pprof-practice   运行后注意查看一下资源是否吃紧，机器是否还能扛得住，坚持一分钟，如果确认没问题，咱们再进行下一步。\n控制台里应该会不停的打印日志，都是一些“猫狗虎鼠在不停地吃喝拉撒”的屁话，没有意义，不用细看。\n使用 pprof 保持程序运行，打开浏览器访问 http://localhost:6060/debug/pprof/，可以看到如下页面：\n页面上展示了可用的程序运行采样数据，分别有：\n   类型 描述 备注     allocs 内存分配情况的采样信息 可以用浏览器打开，但可读性不高   blocks 阻塞操作情况的采样信息 可以用浏览器打开，但可读性不高   cmdline 显示程序启动命令及参数 可以用浏览器打开，这里会显示 ./go-pprof-practice   goroutine 当前所有协程的堆栈信息 可以用浏览器打开，但可读性不高   heap 堆上内存使用情况的采样信息 可以用浏览器打开，但可读性不高   mutex 锁争用情况的采样信息 可以用浏览器打开，但可读性不高   profile CPU 占用情况的采样信息 浏览器打开会下载文件   threadcreate 系统线程创建情况的采样信息 可以用浏览器打开，但可读性不高   trace 程序运行跟踪信息 浏览器打开会下载文件，本文不涉及    因为 cmdline 没有什么实验价值，trace 与本文主题关系不大，threadcreate 涉及的情况偏复杂，所以这三个类型的采样信息这里暂且不提。除此之外，其他所有类型的采样信息本文都会涉及到，且炸弹程序已经为每一种类型的采样信息埋藏了一个对应的性能问题，等待你的发现。\n由于直接阅读采样信息缺乏直观性，我们需要借助 go tool pprof 命令来排查问题，这个命令是 go 原生自带的，所以不用额外安装。\n我们先不用完整地学习如何使用这个命令，毕竟那太枯燥了，我们一边实战一边学习。\n以下正式开始。\n排查 CPU 占用过高 我们首先通过活动监视器（或任务管理器、top 命令，取决于你的操作系统和你的喜好），查看一下炸弹程序的 CPU 占用：\n可以看到 CPU 占用相当高，这显然是有问题的，我们使用 go tool pprof 来排查一下：\n1  go tool pprof http://localhost:6060/debug/pprof/profile   等待一会儿后，进入一个交互式终端：\n输入 top 命令，查看 CPU 占用较高的调用：\n很明显，CPU 占用过高是 github.com/wolfogre/go-pprof-practice/animal/felidae/tiger.(*Tiger).Eat 造成的。\n注：为了保证实验节奏，关于图中 flat、flat%、sum%、cum、cum% 等参数的含义这里就不展开讲了，你可以先简单理解为数字越大占用情况越严重.\n输入 list Eat，查看问题具体在代码的哪一个位置：\n可以看到，是第 24 行那个一百亿次空循环占用了大量 CPU 时间，至此，问题定位成功！\n接下来有一个扩展操作：图形化显示调用栈信息，这很酷，但是需要你事先在机器上安装 graphviz，大多数系统上可以轻松安装它：\n1 2 3  brew install graphviz # for macos apt install graphviz # for ubuntu yum install graphviz # for centos   或者你也可以访问 graphviz 官网寻找适合自己操作系统的安装方法。\n安装完成后，我们继续在上文的交互式终端里输入 web，注意，虽然这个命令的名字叫“web”，但它的实际行为是产生一个 .svg 文件，并调用你的系统里设置的默认打开 .svg 的程序打开它。如果你的系统里打开 .svg 的默认程序并不是浏览器（比如可能是你的代码编辑器），这时候你需要设置一下默认使用浏览器打开 .svg 文件，相信这难不倒你。\n你应该可以看到：\n图中，tiger.(*Tiger).Eat 函数的框特别大，箭头特别粗，pprof 生怕你不知道这个函数的 CPU 占用很高，这张图还包含了很多有趣且有价值的信息，你可以多看一会儿再继续。\n至此，这一小节使用 pprof 定位 CPU 占用的实验就结束了，你需要输入 exit 退出 pprof 的交互式终端。\n为了方便进行后面的实验，我们修复一下这个问题，不用太麻烦，注释掉相关代码即可：\n1 2 3 4 5 6 7  func (t *Tiger) Eat() { log.Println(t.Name(), \"eat\") //loop := 10000000000 \t//for i := 0; i \t//\t// do nothing \t//} }   之后修复问题的的方法都是注释掉相关的代码，不再赘述。你可能觉得这很粗暴，但要知道，这个实验的重点是如何使用 pprof 定位问题，我们不需要花太多时间在改代码上。\n排查内存占用过高 重新编译炸弹程序，再次运行，可以看到 CPU 占用率已经下来了，但是内存的占用率仍然很高：\n我们再次运行使用 pprof 命令，注意这次使用的 URL 的结尾是 heap：\n1  go tool pprof http://localhost:6060/debug/pprof/heap   再一次使用 top、list 来定问问题代码：\n可以看到这次出问题的地方在 github.com/wolfogre/go-pprof-practice/animal/muridae/mouse.(*Mouse).Steal，函数内容如下：\n1 2 3 4 5 6 7  func (m *Mouse) Steal() { log.Println(m.Name(), \"steal\") max := constant.Gi for len(m.buffer) * constant.Mi  max { m.buffer = append(m.buffer, [constant.Mi]byte{}) } }   可以看到，这里有个循环会一直向 m.buffer 里追加长度为 1 MiB 的数组，直到总容量到达 1 GiB 为止，且一直不释放这些内存，这就难怪会有这么高的内存占用了。\n使用 web 来查看图形化展示，可以再次确认问题确实出在这里：\n现在我们同样是注释掉相关代码来解决这个问题。\n再次编译运行，查看内存占用：\n可以看到内存占用已经将到了 35 MB，似乎内存的使用已经恢复正常，一片祥和。\n但是，内存相关的性能问题真的已经全部解决了吗？\n排查频繁内存回收 你应该知道，频繁的 GC 对 golang 程序性能的影响也是非常严重的。虽然现在这个炸弹程序内存使用量并不高，但这会不会是频繁 GC 之后的假象呢？\n为了获取程序运行过程中 GC 日志，我们需要先退出炸弹程序，再在重新启动前赋予一个环境变量，同时为了避免其他日志的干扰，使用 grep 筛选出 GC 日志查看：\n1  GODEBUG=gctrace=1 ./go-pprof-practice | grep gc   日志输出如下：\n可以看到，GC 差不多每 3 秒就发生一次，且每次 GC 都会从 16MB 清理到几乎 0MB，说明程序在不断的申请内存再释放，这是高性能 golang 程序所不允许的。\n所以接下来使用 pprof 排查时，我们在乎的不是什么地方在占用大量内存，而是什么地方在不停地申请内存，这两者是有区别的。\n由于内存的申请与释放频度是需要一段时间来统计的，所有我们保证炸弹程序已经运行了几分钟之后，再运行命令：\n1  go tool pprof http://localhost:6060/debug/pprof/allocs   同样使用 top、list、web 大法：\n可以看到 github.com/wolfogre/go-pprof-practice/animal/canidae/dog.(*Dog).Run 会进行无意义的内存申请，而这个函数又会被频繁调用，这才导致程序不停地进行 GC:\n1 2 3 4  func (d *Dog) Run() { log.Println(d.Name(), \"run\") _ = make([]byte, 16 * constant.Mi) }   这里有个小插曲，你可尝试一下将 16 * constant.Mi 修改成一个较小的值，重新编译运行，会发现并不会引起频繁 GC，原因是在 golang 里，对象是使用堆内存还是栈内存，由编译器进行逃逸分析并决定，如果对象不会逃逸，便可在使用栈内存，但总有意外，就是对象的尺寸过大时，便不得不使用堆内存。所以这里设置申请 16 MiB 的内存就是为了避免编译器直接在栈上分配，如果那样得话就不会涉及到 GC 了。\n我们同样注释掉问题代码，重新编译执行，可以看到这一次，程序的 GC 频度要低很多，以至于短时间内都看不到 GC 日志了：\n排查协程泄露 由于 golang 自带内存回收，所以一般不会发生内存泄露。但凡事都有例外，在 golang 中，协程本身是可能泄露的，或者叫协程失控，进而导致内存泄露。\n我们在浏览器里可以看到，此时程序的协程数已经多达 106 条：\n虽然 106 条并不算多，但对于这样一个小程序来说，似乎还是不正常的。为求安心，我们再次是用 pprof 来排查一下：\n1  go tool pprof http://localhost:6060/debug/pprof/goroutine   同样是 top、list、web 大法：\n可能这次问题藏得比较隐晦，但仔细观察还是不难发现，问题在于 github.com/wolfogre/go-pprof-practice/animal/canidae/wolf.(*Wolf).Drink 在不停地创建没有实际作用的协程：\n1 2 3 4 5 6 7 8  func (w *Wolf) Drink() { log.Println(w.Name(), \"drink\") for i := 0; i  10; i++ { go func() { time.Sleep(30 * time.Second) }() } }   可以看到，Drink 函数每次会释放 10 个协程出去，每个协程会睡眠 30 秒再退出，而 Drink 函数又会被反复调用，这才导致大量协程泄露，试想一下，如果释放出的协程会永久阻塞，那么泄露的协程数便会持续增加，内存的占用也会持续增加，那迟早是会被操作系统杀死的。\n我们注释掉问题代码，重新编译运行可以看到，协程数已经降到 4 条了：\n排查锁的争用 到目前为止，我们已经解决这个炸弹程序的所有资源占用问题，但是事情还没有完，我们需要进一步排查那些会导致程序运行慢的性能问题，这些问题可能并不会导致资源占用，但会让程序效率低下，这同样是高性能程序所忌讳的。\n我们首先想到的就是程序中是否有不合理的锁的争用，我们倒一倒，回头看看上一张图，虽然协程数已经降到 4 条，但还显示有一个 mutex 存在争用问题。\n相信到这里，你已经触类旁通了，无需多言，开整。\n1  go tool pprof http://localhost:6060/debug/pprof/mutex   同样是 top、list、web 大法：\n可以看出来这问题出在 github.com/wolfogre/go-pprof-practice/animal/canidae/wolf.(*Wolf).Howl。但要知道，在代码中使用锁是无可非议的，并不是所有的锁都会被标记有问题，我们看看这个有问题的锁哪里触雷了。\n1 2 3 4 5 6 7 8 9 10 11  func (w *Wolf) Howl() { log.Println(w.Name(), \"howl\") m := \u0026sync.Mutex{} m.Lock() go func() { time.Sleep(time.Second) m.Unlock() }() m.Lock() }   可以看到，这个锁由主协程 Lock，并启动子协程去 Unlock，主协程会阻塞在第二次 Lock 这儿等待子协程完成任务，但由于子协程足足睡眠了一秒，导致主协程等待这个锁释放足足等了一秒钟。虽然这可能是实际的业务需要，逻辑上说得通，并不一定真的是性能瓶颈，但既然它出现在我写的“炸弹”里，就肯定不是什么“业务需要”啦。\n所以，我们注释掉这段问题代码，重新编译执行，继续。\n排查阻塞操作 好了，我们开始排查最后一个问题。\n在程序中，除了锁的争用会导致阻塞之外，很多逻辑都会导致阻塞。\n可以看到，这里仍有 2 个阻塞操作，虽然不一定是有问题的，但我们保证程序性能，我们还是要老老实实排查确认一下才对。\n1  go tool pprof http://localhost:6060/debug/pprof/block   top、list、web，你懂得。\n可以看到，阻塞操作位于 github.com/wolfogre/go-pprof-practice/animal/felidae/cat.(*Cat).Pee：\n1 2 3 4 5  func (c *Cat) Pee() { log.Println(c.Name(), \"pee\") time.After(time.Second) }   你应该可以看懂，不同于睡眠一秒，这里是从一个 channel 里读数据时，发生了阻塞，直到这个 channel 在一秒后才有数据读出，这就导致程序阻塞了一秒而非睡眠了一秒。\n这里有个疑点，就是上文中是可以看到有两个阻塞操作的，但这里只排查出了一个，我没有找到其准确原因，但怀疑另一个阻塞操作是程序监听端口提供 porof 查询时，涉及到 IO 操作发生了阻塞，即阻塞在对 HTTP 端口的监听上，但我没有进一步考证。\n不管怎样，恭喜你完整地完成了这个实验。\n问题 pprof统计的内存与PC上显示的内存不符合 炸弹程序占用内存大概2GB，通过htop查看，确实在2GB左右，但是通过pprof查看，只能查到1GB内存占用，这是为什么?\n是这样的，代码中一共有两处有意消耗内存，一处是这里：\n1 2 3 4 5 6 7  func (m *Mouse) Steal() { log.Println(m.Name(), \"steal\") max := constant.Gi for len(m.buffer) * constant.Mi  max { m.buffer = append(m.buffer, [constant.Mi]byte{}) } }   可以看到这里的逻辑是占上不超过 1G 内存，所以 pprof 查到 1G 内存是符合预期的。\n另一处是这里：\n1 2 3 4  func (d *Dog) Run() { log.Println(d.Name(), \"run\") _ = make([]byte, 16 * constant.Mi) }   这里故意申请 16M 内存并立即丢弃，这里本意是为了模拟一个频繁 GC 问题，因为上文已经占了 1G 内存不放，所以 golang 每次 GC 结束，会发现还占用了 1G，所以 GC 策略会在下次内存占用超过 1G * 2 时（具体为什么是两倍可以看下 GC 策略相关资料）再次触发 GC 降回 1G，所以站在操作系统来看，这个程序的内存占用是在 1GB - 2GB 之间的（注意 GC 掉的内存并不一定会立即返还给操作系统），而我说 “程序会占用约 2G 内存” 是说了最坏情况，意思是你至少得有 2G 内存。\n然后你应该意识到一个问题了，pprof 看到的内存占用，其实只是 golang 逻辑上正在使用的内存量，不包括已被 GC 回收但尚未返还给操作系统的内存，同样也不包括内核态的内存占用。而 htop 是站在操作系统层面看到的进程内存占用，理论上就是会比 pprof 看到的内存占用量更多的。\n如果你在实际工作中发现 htop 看到内存占用贼大，pprof 看到内存占用却不多，就要考虑下，是不是有大量内存被 GC 但还没来得及返还给操作系统，是不是某些内核态操作（比如 IO）消耗了大量内存。\n转载:https://blog.wolfogre.com/posts/go-ppof-practice/?utm_campaign=studygolang.com\u0026utm_medium=studygolang.com\u0026utm_source=studygolang.com\n",
  "wordCount" : "6048",
  "inLanguage": "zh-cn",
  "datePublished": "2020-02-09T17:45:44Z",
  "dateModified": "2020-02-09T17:45:44Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Pprof实战:从零开始排查炸弹程序
    </h1>
    <div class="post-meta">February 9, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h1>
<p>如果要说在 golang 开发过程进行性能调优，pprof 一定是一个大杀器般的工具。但在网上找到的教程都偏向简略，难寻真的能应用于实战的教程。这也无可厚非，毕竟 pprof 是当程序占用资源异常时才需要启用的工具，而我相信大家的编码水平和排查问题的能力是足够高的，一般不会写出性能极度堪忧的程序，且即使发现有一些资源异常占用，也会通过排查代码快速定位，这也导致 pprof 需要上战场的机会少之又少。即使大家有心想学习使用 pprof，却也常常相忘于江湖。</p>
<p>既然如此，那我就送大家一个性能极度堪忧的“炸弹”程序吧！</p>
<p>这程序没啥正经用途缺极度占用资源，基本覆盖了常见的性能问题。本文就是希望读者能一步一步按照提示，使用 pprof 定位这个程序的的性能瓶颈所在，借此学习 pprof 工具的使用方法。</p>
<p>因此，本文是一场“实验课”而非“理论课”，请读者腾出时间，脚踏实地，一步一步随实验步骤进行操作，这会是一个很有趣的冒险，不会很无聊，希望你能喜欢。</p>
<h1 id="实验准备">实验准备<a hidden class="anchor" aria-hidden="true" href="#实验准备">#</a></h1>
<p>这里假设你有基本的 golang 开发功底，拥有 golang 开发环境并配置了 $GOPATH，能熟练阅读简单的代码或进行简单的修改，且知道如何编译运行 golang 程序。此外，需要你大致知道 pprof 是干什么的，有一个基本印象即可，你可以花几分钟时间读一下<a href="https://blog.wolfogre.com/redirect/v3/A3jsjsv0r3pCsn4x_qmqFKwSAwM8Cv46xcU7LxImWv3F_wdFRERZQ0pZxVoWBjvFWhYGWsWtTRvFOwaJVMX_BDIwMTjM_wIwOcz_AjE1zP5HBolU_1AlMjAlRTUlQTQlQTclRTYlOUQlODAlRTUlOTklQTglRTQlQjklOEIlRTYlODAlQTclRTglODMlQkQlRTUlODklOTYlRTYlOUUlOTAlMjBQUHMsbi0YMRIDAzwK_jrFxVoWBjtuQQYW3Dsh_cU8Bk0KxTsGzDw8Bcw8ghxKiMU">《Golang 大杀器之性能剖析 PProf》</a>的开头部分，这不会耽误太久。</p>
<p>此外由于你需要运行一个“炸弹”程序，请务必确保你用于做实验的机器有充足的资源，你的机器至少需要：</p>
<ul>
<li>2 核 CPU；</li>
<li>2G 内存。</li>
</ul>
<p>注意，以上只是最低需求，你的机器配置能高于上述要求自然最好。实际运行“炸弹”时，你可以关闭电脑上其他不必要的程序，甚至 IDE 都不用开，我们的实验操作基本上是在命令行里进行的。</p>
<p>此外，务必确保你是在个人机器上运行“炸弹”的，能接受机器死机重启的后果（虽然这发生的概率很低）。请你务必不要在危险的边缘试探，比如在线上服务器运行这个程序。</p>
<p>可能说得你都有点害怕了，为打消你顾虑，我可以剧透一下“炸弹”的情况，让你安心：</p>
<ul>
<li>程序会占用约 2G 内存；</li>
<li>程序占用 CPU 最高约 100%（总量按“核数 * 100%”来算）；</li>
<li>程序不涉及网络或文件读写；</li>
<li>程序除了吃资源之外没有其他危险操作。</li>
</ul>
<p>且程序所占用的各类资源，均不会随着运行时间的增长而增长，换句话说，只要你把“炸弹”启动并正常运行了一分钟，就基本确认安全了，之后即使运行几天也不会有更多的资源占用，除了有点费电之外。</p>
<h1 id="获取炸弹">获取“炸弹”<a hidden class="anchor" aria-hidden="true" href="#获取炸弹">#</a></h1>
<p>炸弹程序的代码我已经放到了 <a href="https://github.com/wolfogre/go-pprof-practice">GitHub</a> 上，你只需要在终端里运行 go get 便可获取，注意加上 -d 参数，避免下载后自动安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go get -d github.com/wolfogre/go-pprof-practice
cd $GOPATH/src/github.com/wolfogre/go-pprof-practice
</code></pre></td></tr></table>
</div>
</div><p>我们可以简单看一下 main.go 文件，里面有几个帮助排除性能调问题的关键的的点，我加上了些注释方便你理解，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="c1">// 略
</span><span class="c1"></span>	<span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span> <span class="c1">// 会自动注册 handler 到 http server，方便通过 http 接口获取程序运行采样报告
</span><span class="c1"></span>	<span class="c1">// 略
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 略
</span><span class="c1"></span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 限制 CPU 使用数，避免过载
</span><span class="c1"></span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetMutexProfileFraction</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 开启对锁调用的跟踪
</span><span class="c1"></span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetBlockProfileRate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 开启对阻塞操作的跟踪
</span><span class="c1"></span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 启动一个 http server，注意 pprof 相关的 handler 已经自动注册过了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:6060&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="c1">// 略
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除此之外的其他代码你一律不用看，那些都是我为了模拟一个“逻辑复杂”的程序而编造的，其中大多数的问题很容易通过肉眼发现，但我们需要做的是通过 pprof 来定位代码的问题，所以为了保证实验的趣味性请不要提前阅读代码，可以实验完成后再看。</p>
<p>接着我们需要编译一下这个程序并运行，你不用担心依赖问题，这个程序没有任何外部依赖。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go build
./go-pprof-practice
</code></pre></td></tr></table>
</div>
</div><p>运行后注意查看一下资源是否吃紧，机器是否还能扛得住，坚持一分钟，如果确认没问题，咱们再进行下一步。</p>
<p>控制台里应该会不停的打印日志，都是一些“猫狗虎鼠在不停地吃喝拉撒”的屁话，没有意义，不用细看。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209175042.png" alt=""  />
</p>
<h1 id="使用-pprof">使用 pprof<a hidden class="anchor" aria-hidden="true" href="#使用-pprof">#</a></h1>
<p>保持程序运行，打开浏览器访问 <a href="http://localhost:6060/debug/pprof/">http://localhost:6060/debug/pprof/</a>，可以看到如下页面：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209175405.png" alt=""  />
</p>
<p>页面上展示了可用的程序运行采样数据，分别有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>allocs</td>
<td>内存分配情况的采样信息</td>
<td>可以用浏览器打开，但可读性不高</td>
</tr>
<tr>
<td>blocks</td>
<td>阻塞操作情况的采样信息</td>
<td>可以用浏览器打开，但可读性不高</td>
</tr>
<tr>
<td>cmdline</td>
<td>显示程序启动命令及参数</td>
<td>可以用浏览器打开，这里会显示 ./go-pprof-practice</td>
</tr>
<tr>
<td>goroutine</td>
<td>当前所有协程的堆栈信息</td>
<td>可以用浏览器打开，但可读性不高</td>
</tr>
<tr>
<td>heap</td>
<td>堆上内存使用情况的采样信息</td>
<td>可以用浏览器打开，但可读性不高</td>
</tr>
<tr>
<td>mutex</td>
<td>锁争用情况的采样信息</td>
<td>可以用浏览器打开，但可读性不高</td>
</tr>
<tr>
<td>profile</td>
<td>CPU 占用情况的采样信息</td>
<td>浏览器打开会下载文件</td>
</tr>
<tr>
<td>threadcreate</td>
<td>系统线程创建情况的采样信息</td>
<td>可以用浏览器打开，但可读性不高</td>
</tr>
<tr>
<td>trace</td>
<td>程序运行跟踪信息</td>
<td>浏览器打开会下载文件，本文不涉及</td>
</tr>
</tbody>
</table>
<p>因为 cmdline 没有什么实验价值，trace 与本文主题关系不大，threadcreate 涉及的情况偏复杂，所以这三个类型的采样信息这里暂且不提。除此之外，其他所有类型的采样信息本文都会涉及到，且炸弹程序已经为每一种类型的采样信息埋藏了一个对应的性能问题，等待你的发现。</p>
<p>由于直接阅读采样信息缺乏直观性，我们需要借助 go tool pprof 命令来排查问题，这个命令是 go 原生自带的，所以不用额外安装。</p>
<p>我们先不用完整地学习如何使用这个命令，毕竟那太枯燥了，我们一边实战一边学习。</p>
<p>以下正式开始。</p>
<h1 id="排查-cpu-占用过高">排查 CPU 占用过高<a hidden class="anchor" aria-hidden="true" href="#排查-cpu-占用过高">#</a></h1>
<p>我们首先通过活动监视器（或任务管理器、top 命令，取决于你的操作系统和你的喜好），查看一下炸弹程序的 CPU 占用：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209180242.png" alt=""  />
</p>
<p>可以看到 CPU 占用相当高，这显然是有问题的，我们使用 go tool pprof 来排查一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go tool pprof http://localhost:6060/debug/pprof/profile
</code></pre></td></tr></table>
</div>
</div><p>等待一会儿后，进入一个交互式终端：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209180332.png" alt=""  />
</p>
<p>输入 top 命令，查看 CPU 占用较高的调用：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209180343.png" alt=""  />
</p>
<p>很明显，CPU 占用过高是 <code>github.com/wolfogre/go-pprof-practice/animal/felidae/tiger.(*Tiger).Eat</code> 造成的。</p>
<p>注：为了保证实验节奏，关于图中 flat、flat%、sum%、cum、cum% 等参数的含义这里就不展开讲了，你可以先简单理解为数字越大占用情况越严重.</p>
<p>输入 list Eat，查看问题具体在代码的哪一个位置：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209180516.png" alt=""  />
</p>
<p>可以看到，是第 24 行那个一百亿次空循环占用了大量 CPU 时间，至此，问题定位成功！</p>
<p>接下来有一个扩展操作：图形化显示调用栈信息，这很酷，但是需要你事先在机器上安装 graphviz，大多数系统上可以轻松安装它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">brew install graphviz # for macos
apt install graphviz # for ubuntu
yum install graphviz # for centos
</code></pre></td></tr></table>
</div>
</div><p>或者你也可以访问 graphviz 官网寻找适合自己操作系统的安装方法。</p>
<p>安装完成后，我们继续在上文的交互式终端里输入 web，注意，虽然这个命令的名字叫“web”，但它的实际行为是产生一个 .svg 文件，并调用你的系统里设置的默认打开 .svg 的程序打开它。如果你的系统里打开 .svg 的默认程序并不是浏览器（比如可能是你的代码编辑器），这时候你需要设置一下默认使用浏览器打开 .svg 文件，相信这难不倒你。</p>
<p>你应该可以看到：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181035.png" alt=""  />
</p>
<p>图中，tiger.(*Tiger).Eat 函数的框特别大，箭头特别粗，pprof 生怕你不知道这个函数的 CPU 占用很高，这张图还包含了很多有趣且有价值的信息，你可以多看一会儿再继续。</p>
<p>至此，这一小节使用 pprof 定位 CPU 占用的实验就结束了，你需要输入 exit 退出 pprof 的交互式终端。</p>
<p>为了方便进行后面的实验，我们修复一下这个问题，不用太麻烦，注释掉相关代码即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tiger</span><span class="p">)</span> <span class="nf">Eat</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;eat&#34;</span><span class="p">)</span>
	<span class="c1">//loop := 10000000000
</span><span class="c1"></span>	<span class="c1">//for i := 0; i &lt; loop; i++ {
</span><span class="c1"></span>	<span class="c1">//	// do nothing
</span><span class="c1"></span>	<span class="c1">//}
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>之后修复问题的的方法都是注释掉相关的代码，不再赘述。你可能觉得这很粗暴，但要知道，这个实验的重点是如何使用 pprof 定位问题，我们不需要花太多时间在改代码上。</p>
<h1 id="排查内存占用过高">排查内存占用过高<a hidden class="anchor" aria-hidden="true" href="#排查内存占用过高">#</a></h1>
<p>重新编译炸弹程序，再次运行，可以看到 CPU 占用率已经下来了，但是内存的占用率仍然很高：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181131.png" alt=""  />
</p>
<p>我们再次运行使用 pprof 命令，注意这次使用的 URL 的结尾是 heap：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go tool pprof http://localhost:6060/debug/pprof/heap
</code></pre></td></tr></table>
</div>
</div><p>再一次使用 top、list 来定问问题代码：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181149.png" alt=""  />
</p>
<p>可以看到这次出问题的地方在 <code>github.com/wolfogre/go-pprof-practice/animal/muridae/mouse.(*Mouse).Steal</code>，函数内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mouse</span><span class="p">)</span> <span class="nf">Steal</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;steal&#34;</span><span class="p">)</span>
	<span class="nx">max</span> <span class="o">:=</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">Gi</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span> <span class="o">*</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">Mi</span> <span class="p">&lt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">buffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">buffer</span><span class="p">,</span> <span class="p">[</span><span class="nx">constant</span><span class="p">.</span><span class="nx">Mi</span><span class="p">]</span><span class="kt">byte</span><span class="p">{})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这里有个循环会一直向 m.buffer 里追加长度为 1 MiB 的数组，直到总容量到达 1 GiB 为止，且一直不释放这些内存，这就难怪会有这么高的内存占用了。</p>
<p>使用 web 来查看图形化展示，可以再次确认问题确实出在这里：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181230.png" alt=""  />
</p>
<p>现在我们同样是注释掉相关代码来解决这个问题。</p>
<p>再次编译运行，查看内存占用：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181239.png" alt=""  />
</p>
<p>可以看到内存占用已经将到了 35 MB，似乎内存的使用已经恢复正常，一片祥和。</p>
<p>但是，内存相关的性能问题真的已经全部解决了吗？</p>
<h1 id="排查频繁内存回收">排查频繁内存回收<a hidden class="anchor" aria-hidden="true" href="#排查频繁内存回收">#</a></h1>
<p>你应该知道，频繁的 GC 对 golang 程序性能的影响也是非常严重的。虽然现在这个炸弹程序内存使用量并不高，但这会不会是频繁 GC 之后的假象呢？</p>
<p>为了获取程序运行过程中 GC 日志，我们需要先退出炸弹程序，再在重新启动前赋予一个环境变量，同时为了避免其他日志的干扰，使用 grep 筛选出 GC 日志查看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">GODEBUG=gctrace=1 ./go-pprof-practice | grep gc
</code></pre></td></tr></table>
</div>
</div><p>日志输出如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181540.png" alt=""  />
</p>
<p>可以看到，GC 差不多每 3 秒就发生一次，且每次 GC 都会从 16MB 清理到几乎 0MB，说明程序在不断的申请内存再释放，这是高性能 golang 程序所不允许的。</p>
<p>所以接下来使用 pprof 排查时，我们在乎的不是什么地方在占用大量内存，而是什么地方在不停地申请内存，这两者是有区别的。</p>
<p>由于内存的申请与释放频度是需要一段时间来统计的，所有我们保证炸弹程序已经运行了几分钟之后，再运行命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go tool pprof http://localhost:6060/debug/pprof/allocs
</code></pre></td></tr></table>
</div>
</div><p>同样使用 top、list、web 大法：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181722.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181730.png" alt=""  />
</p>
<p>可以看到 <code>github.com/wolfogre/go-pprof-practice/animal/canidae/dog.(*Dog).Run</code> 会进行无意义的内存申请，而这个函数又会被频繁调用，这才导致程序不停地进行 GC:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;run&#34;</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">Mi</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里有个小插曲，你可尝试一下将 <code>16 * constant.Mi</code> 修改成一个较小的值，重新编译运行，会发现并不会引起频繁 GC，原因是在 golang 里，对象是使用堆内存还是栈内存，由编译器进行逃逸分析并决定，如果对象不会逃逸，便可在使用栈内存，但总有意外，就是对象的尺寸过大时，便不得不使用堆内存。所以这里设置申请 16 MiB 的内存就是为了避免编译器直接在栈上分配，如果那样得话就不会涉及到 GC 了。</p>
<p>我们同样注释掉问题代码，重新编译执行，可以看到这一次，程序的 GC 频度要低很多，以至于短时间内都看不到 GC 日志了：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209181901.png" alt=""  />
</p>
<h1 id="排查协程泄露">排查协程泄露<a hidden class="anchor" aria-hidden="true" href="#排查协程泄露">#</a></h1>
<p>由于 golang 自带内存回收，所以一般不会发生内存泄露。但凡事都有例外，在 golang 中，协程本身是可能泄露的，或者叫协程失控，进而导致内存泄露。</p>
<p>我们在浏览器里可以看到，此时程序的协程数已经多达 106 条：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209182623.png" alt=""  />
</p>
<p>虽然 106 条并不算多，但对于这样一个小程序来说，似乎还是不正常的。为求安心，我们再次是用 pprof 来排查一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go tool pprof http://localhost:6060/debug/pprof/goroutine
</code></pre></td></tr></table>
</div>
</div><p>同样是 top、list、web 大法：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209182634.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209182643.png" alt=""  />
</p>
<p>可能这次问题藏得比较隐晦，但仔细观察还是不难发现，问题在于 <code>github.com/wolfogre/go-pprof-practice/animal/canidae/wolf.(*Wolf).Drink</code> 在不停地创建没有实际作用的协程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">Wolf</span><span class="p">)</span> <span class="nf">Drink</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;drink&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，Drink 函数每次会释放 10 个协程出去，每个协程会睡眠 30 秒再退出，而 Drink 函数又会被反复调用，这才导致大量协程泄露，试想一下，如果释放出的协程会永久阻塞，那么泄露的协程数便会持续增加，内存的占用也会持续增加，那迟早是会被操作系统杀死的。</p>
<p>我们注释掉问题代码，重新编译运行可以看到，协程数已经降到 4 条了：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209182906.png" alt=""  />
</p>
<h1 id="排查锁的争用">排查锁的争用<a hidden class="anchor" aria-hidden="true" href="#排查锁的争用">#</a></h1>
<p>到目前为止，我们已经解决这个炸弹程序的所有资源占用问题，但是事情还没有完，我们需要进一步排查那些会导致程序运行慢的性能问题，这些问题可能并不会导致资源占用，但会让程序效率低下，这同样是高性能程序所忌讳的。</p>
<p>我们首先想到的就是程序中是否有不合理的锁的争用，我们倒一倒，回头看看上一张图，虽然协程数已经降到 4 条，但还显示有一个 mutex 存在争用问题。</p>
<p>相信到这里，你已经触类旁通了，无需多言，开整。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go tool pprof http://localhost:6060/debug/pprof/mutex
</code></pre></td></tr></table>
</div>
</div><p>同样是 top、list、web 大法：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209182939.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209182945.png" alt=""  />
</p>
<p>可以看出来这问题出在 <code>github.com/wolfogre/go-pprof-practice/animal/canidae/wolf.(*Wolf).Howl</code>。但要知道，在代码中使用锁是无可非议的，并不是所有的锁都会被标记有问题，我们看看这个有问题的锁哪里触雷了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">Wolf</span><span class="p">)</span> <span class="nf">Howl</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;howl&#34;</span><span class="p">)</span>

	<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这个锁由主协程 Lock，并启动子协程去 Unlock，主协程会阻塞在第二次 Lock 这儿等待子协程完成任务，但由于子协程足足睡眠了一秒，导致主协程等待这个锁释放足足等了一秒钟。虽然这可能是实际的业务需要，逻辑上说得通，并不一定真的是性能瓶颈，但既然它出现在我写的“炸弹”里，就肯定不是什么“业务需要”啦。</p>
<p>所以，我们注释掉这段问题代码，重新编译执行，继续。</p>
<h1 id="排查阻塞操作">排查阻塞操作<a hidden class="anchor" aria-hidden="true" href="#排查阻塞操作">#</a></h1>
<p>好了，我们开始排查最后一个问题。</p>
<p>在程序中，除了锁的争用会导致阻塞之外，很多逻辑都会导致阻塞。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209183058.png" alt=""  />
</p>
<p>可以看到，这里仍有 2 个阻塞操作，虽然不一定是有问题的，但我们保证程序性能，我们还是要老老实实排查确认一下才对。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">tool</span> <span class="nx">pprof</span> <span class="nx">http</span><span class="p">:</span><span class="c1">//localhost:6060/debug/pprof/block
</span></code></pre></td></tr></table>
</div>
</div><p>top、list、web，你懂得。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209183116.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200209183122.png" alt=""  />
</p>
<p>可以看到，阻塞操作位于 <code>github.com/wolfogre/go-pprof-practice/animal/felidae/cat.(*Cat).Pee</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nf">Pee</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;pee&#34;</span><span class="p">)</span>

	<span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你应该可以看懂，不同于睡眠一秒，这里是从一个 channel 里读数据时，发生了阻塞，直到这个 channel 在一秒后才有数据读出，这就导致程序阻塞了一秒而非睡眠了一秒。</p>
<p>这里有个疑点，就是上文中是可以看到有两个阻塞操作的，但这里只排查出了一个，我没有找到其准确原因，但怀疑另一个阻塞操作是程序监听端口提供 porof 查询时，涉及到 IO 操作发生了阻塞，即阻塞在对 HTTP 端口的监听上，但我没有进一步考证。</p>
<p>不管怎样，恭喜你完整地完成了这个实验。</p>
<h1 id="问题">问题<a hidden class="anchor" aria-hidden="true" href="#问题">#</a></h1>
<h2 id="pprof统计的内存与pc上显示的内存不符合">pprof统计的内存与PC上显示的内存不符合<a hidden class="anchor" aria-hidden="true" href="#pprof统计的内存与pc上显示的内存不符合">#</a></h2>
<p>炸弹程序占用内存大概2GB，通过htop查看，确实在2GB左右，但是通过pprof查看，只能查到1GB内存占用，这是为什么?</p>
<p>是这样的，代码中一共有两处有意消耗内存，一处是这里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mouse</span><span class="p">)</span> <span class="nf">Steal</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;steal&#34;</span><span class="p">)</span>
	<span class="nx">max</span> <span class="o">:=</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">Gi</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span> <span class="o">*</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">Mi</span> <span class="p">&lt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">buffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">buffer</span><span class="p">,</span> <span class="p">[</span><span class="nx">constant</span><span class="p">.</span><span class="nx">Mi</span><span class="p">]</span><span class="kt">byte</span><span class="p">{})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到这里的逻辑是占上不超过 1G 内存，所以 pprof 查到 1G 内存是符合预期的。</p>
<p>另一处是这里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="s">&#34;run&#34;</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="nx">constant</span><span class="p">.</span><span class="nx">Mi</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里故意申请 16M 内存并立即丢弃，这里本意是为了模拟一个频繁 GC 问题，因为上文已经占了 1G 内存不放，所以 golang 每次 GC 结束，会发现还占用了 1G，所以 GC 策略会在下次内存占用超过 1G * 2 时（具体为什么是两倍可以看下 GC 策略相关资料）再次触发 GC 降回 1G，所以站在操作系统来看，这个程序的内存占用是在 1GB - 2GB 之间的（注意 GC 掉的内存并不一定会立即返还给操作系统），而我说 “程序会占用约 2G 内存” 是说了最坏情况，意思是你至少得有 2G 内存。</p>
<p>然后你应该意识到一个问题了，pprof 看到的内存占用，其实只是 golang 逻辑上正在使用的内存量，不包括已被 GC 回收但尚未返还给操作系统的内存，同样也不包括内核态的内存占用。而 htop 是站在操作系统层面看到的进程内存占用，理论上就是会比 pprof 看到的内存占用量更多的。</p>
<p>如果你在实际工作中发现 htop 看到内存占用贼大，pprof 看到内存占用却不多，就要考虑下，是不是有大量内存被 GC 但还没来得及返还给操作系统，是不是某些内核态操作（比如 IO）消耗了大量内存。</p>
<p>转载:<a href="https://blog.wolfogre.com/posts/go-ppof-practice/?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com">https://blog.wolfogre.com/posts/go-ppof-practice/?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
