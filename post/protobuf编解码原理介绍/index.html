<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Protobuf编解码原理 | Forz Blog</title>
<meta name="keywords" content="protobuf" />
<meta name="description" content="序列化与反序列化 有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将">
<meta name="author" content="">
<link rel="canonical" href="/post/protobuf%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Protobuf编解码原理" />
<meta property="og:description" content="序列化与反序列化 有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/protobuf%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-04-20T15:41:20&#43;00:00" />
<meta property="article:modified_time" content="2021-04-20T15:41:20&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Protobuf编解码原理"/>
<meta name="twitter:description" content="序列化与反序列化 有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Protobuf编解码原理",
      "item": "/post/protobuf%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Protobuf编解码原理",
  "name": "Protobuf编解码原理",
  "description": "序列化与反序列化 有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将",
  "keywords": [
    "protobuf"
  ],
  "articleBody": "序列化与反序列化 有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将不同阶段的网络权重以模型文件的形式保存下来，如果训练意外终止，可以重新载入模型文件将模型复原，继续训练。\n将数据结构或对象以某种格式转化为字节流的过程，称之为序列化（Serialization），目的是把当前的状态保存下来，在需要时复原数据结构或对象（序列化时不包含与对象相关联的函数，所以后面只提数据结构）。反序列化（Deserialization），是序列化的逆过程，读取字节流，根据约定的格式协议，将数据结构复原。如下图所示，图片来自geeksforgeeks\n在介绍具体技术之前，我们先在脑海里分析下序列化和反序列化的过程：\n 代码运行过程中，数据结构和对象位于内存，其中的各项数据成员可能彼此紧邻，也可能分布在并不连续的各个内存区域，比如指针指向的内存块等； 文件中字节是顺序存储的，要想将数据结构保存成文件，就需要把所有的数据成员平铺开（flatten），然后串接在一起； 直接串接可能是不行的，因为字节流中没有天然的分界，所以在序列化时需要按照某种约定的格式（协议），以便在反序列化时知道“从哪里到哪里是哪个数据成员”，因此格式可能需要约定：指代数据成员的标识、起始位置、终止位置、长度、分隔符等 由上可见，格式协议是最重要的，它直接决定了序列化和反序列化的效率、字节流的大小和可读性等  Protocol Buffers概览 跨语言，跨平台，相比XML和JSON 更小、更快、更容易，因为XML、JSON为了可阅读、自解释被设计成字符文本形式，所以体积更大，在编码解码上也更麻烦，而Protobuf序列化为binary stream，体积更小，但是丧失了可读性——后面我们将看到可读性可以通过另一种方式得到保证。至于上面的\"You define how you want your data to be structured once\"该怎么理解？参看下图，图片素材来自 Protocol Buffers官网首页。\n首先是proto文件，在其中定义我们想要序列化的数据结构，如上图中的message Person，通过Protobuf提供的protoc.exe生成编解码代码文件（C++语言是.cc和.h），其中定义了类Person，类的各个成员变量与proto文件中的定义保持一致。序列化时，定义Person对象，对其成员变量赋值，调用序列化成员函数，将对象保存到文件。反序列化时，读入文件，将Person对象复原，读取相应的数据成员。\nproto文件仅定义了数据的结构（name、id、email），具体的数据内容（1234、“John Doe”、“jdoe@example.com”）保存在序列化生成的文件中，通过简单的思考可知，序列化后的文件里应该会存在一些辅助信息用来将数据内容与数据结构对应起来，以便在反序列化时将数据内容赋值给对应的成员。\n流程如下：\nvarint编码 Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。\nVarint 中的每个字节（最后一个字节除外）都设置了最高有效位（msb），这一位表示还会有更多字节出现。每个字节的低 7 位用于以 7 位组的形式存储数字的二进制补码表示，最低有效组首位。\nvarint是一种可变长编码，使用1个或多个字节对整数进行编码，可编码任意大的整数，小整数占用的字节少，大整数占用的字节多，如果小整数更频繁出现，则通过varint可实现压缩存储。\nvarint中每个字节的最高位bit称之为most significant bit (MSB)，如果该bit为0意味着这个字节为表示当前整数的最后一个字节，如果为1则表示后面还有至少1个字节，可见，varint的终止位置其实是自解释的。\n在Protobuf中，tag和length都是使用varint编码的。length和tag中的field_number都是正整数int32，这里提一下tag，它的低3位bit为wire type，如果只用1个字节表示的话，最高位bit为0，则留给field_number只有4个bit位，1到15，如果field_number大于等于16，就需要用2个字节，所以对于频繁使用的field其field_number应设置为1到15。\n如果用不到 1 个字节，那么最高有效位设为 0 ，如下面这个例子，1 用一个字节就可以表示，所以 msb 为 0.\n1  0000 0001   如果需要多个字节表示，msb 就应该设置为 1 。例如 300，如果用 Varint 表示的话：\n1  1010 1100 0000 0010   如果按照正常的二进制计算的话，这个表示的是 88068(65536 + 16384 + 4096 + 2048 + 4)。\n那 Varint 是怎么编码的呢？\n下面代码是 Varint int 32 的编码计算方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  char* EncodeVarint32(char* dst, uint32_t v) { // Operate on characters as unsigneds  unsigned char* ptr = reinterpret_castunsigned char*(dst); static const int B = 128; if (v  (17)) { *(ptr++) = v; } else if (v  (114)) { *(ptr++) = v | B; *(ptr++) = v7; } else if (v  (121)) { *(ptr++) = v | B; *(ptr++) = (v7) | B; *(ptr++) = v14; } else if (v  (128)) { *(ptr++) = v | B; *(ptr++) = (v7) | B; *(ptr++) = (v14) | B; *(ptr++) = v21; } else { *(ptr++) = v | B; *(ptr++) = (v7) | B; *(ptr++) = (v14) | B; *(ptr++) = (v21) | B; *(ptr++) = v28; } return reinterpret_castchar*(ptr); }   1  300 = 100101100   由于 300 超过了 7 位（Varint 一个字节只有 7 位能用来表示数字，最高位 msb 用来表示后面是否有更多字节），所以 300 需要用 2 个字节来表示。\nVarint 的编码，以 300 举例：\n1 2 3 4  if (v  (114)) { *(ptr++) = v | B; *(ptr++) = v7; }    100101100 | 10000000 = 1 1010 1100 110101100 取出末尾 7 位 = 010 1100 100101100 » 7 = 10 = 0000 0010 1010 1100 0000 0010 (最终 Varint 结果)  Varint 的解码算法应该是这样的：（实际就是编码的逆过程）\n 如果是多个字节，先去掉每个字节的 msb（通过逻辑或运算），每个字节只留下 7 位。 逆序整个结果，最多是 5 个字节，排序是 1-2-3-4-5，逆序之后就是 5-4-3-2-1，字节内部的二进制位的顺序不变，变的是字节的相对位置。  解码过程调用 GetVarint32Ptr 函数，如果是大于一个字节的情况，会调用 GetVarint32PtrFallback 来处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  inline const char* GetVarint32Ptr(const char* p, const char* limit, uint32_t* value) { if (p  limit) { uint32_t result = *(reinterpret_castconst unsigned char*(p)); if ((result \u0026 128) == 0) { *value = result; return p + 1; } } return GetVarint32PtrFallback(p, limit, value); } const char* GetVarint32PtrFallback(const char* p, const char* limit, uint32_t* value) { uint32_t result = 0; for (uint32_t shift = 0; shift  28 \u0026\u0026 p  limit; shift += 7) { uint32_t byte = *(reinterpret_castconst unsigned char*(p)); p++; if (byte \u0026 128) { // More bytes are present  result |= ((byte \u0026 127)  shift); } else { result |= (byte  shift); *value = result; return reinterpret_castconst char*(p); } } return NULL; }   至此，Varint 处理过程读者应该都熟悉了。上面列举出了 Varint 32 的算法，64 位的同理，只不过不再用 10 个分支来写代码了，太丑了。（32位 是 5 个 字节，64位 是 10 个字节）\n64 位 Varint 编码实现：\n1 2 3 4 5 6 7 8 9 10  char*EncodeVarint64(char* dst, uint64_t v) { static const int B = 128; unsigned char* ptr = reinterpret_castunsigned char*(dst); while (v = B) { *(ptr++) = (v \u0026 (B-1)) | B; v = 7; } *(ptr++) = static_castunsigned char(v); return reinterpret_castchar*(ptr); }   原理不变，只不过用循环来解决了。\n64 位 Varint 解码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const char*GetVarint64Ptr(const char* p, const char*limit, uint64_t* value) { uint64_t result = 0; for (uint32_t shift = 0; shift  63 \u0026\u0026 p  limit; shift += 7) { uint64_t byte = *(reinterpret_castconst unsigned char*(p)); p++; if (byte \u0026 128) { // More bytes are present  result |= ((byte \u0026 127)  shift); } else { result |= (byte  shift); *value = result; return reinterpret_castconst char*(p); } } return NULL; }   读到这里可能有读者会问了，Varint 不是为了紧凑 int 的么？那 300 本来可以用 2 个字节表示，现在还是 2 个字节了，哪里紧凑了，花费的空间没有变啊？！\nVarint 确实是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。\n300 如果用 int32 表示，需要 4 个字节，现在用 Varint 表示，只需要 2 个字节了。缩小了一半！\nMessage Structure 编码 protocol buffer 中 message 是一系列键值对。message 的二进制版本只是使用字段号(field’s number 和 wire_type)作为 key。每个字段的名称和声明类型只能在解码端通过引用消息类型的定义（即 .proto 文件）来确定。这一点也是人们常常说的 protocol buffer 比 JSON，XML 安全一点的原因，如果没有数据结构描述 .proto 文件，拿到数据以后是无法解释成正常的数据的。\n由于采用了 tag-value 的形式，所以 option 的 field 如果有，就存在在这个 message buffer 中，如果没有，就不会在这里，这一点也算是压缩了 message 的大小了。\n当消息编码时，键和值被连接成一个字节流。当消息被解码时，解析器需要能够跳过它无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不知道它们的旧程序。这就是所谓的 “向后”兼容性。\n为此，线性的格式消息中每对的“key”实际上是两个值，其中一个是来自.proto文件的字段编号，加上提供正好足够的信息来查找下一个值的长度。在大多数语言实现中，这个 key 被称为 tag。\n注意上图中，3 和 4 已经被废弃了，所以 wire_type 取值目前只有 0、1、2、5。\nkey 的计算方法是 (field_number ，换句话说，key 的最后 3 位表示的就是 wire_type。\n举例，一般 message 的字段号都是 1 开始的，所以对应的 tag 可能是这样的：\n1  000 1000   末尾 3 位表示的是 value 的类型，这里是 000，即 0 ，代表的是 varint 值。右移 3 位，即 0001，这代表的就是字段号(field number)。tag 的例子就举这么多，接下来举一个 value 的例子，还是用 varint 来举例：\n1 2 3 4  96 01 = 1001 0110 0000 0001 → 000 0001 ++ 001 0110 (drop the msb and reverse the groups of 7 bits) → 10010110 → 128 + 16 + 4 + 2 = 150   可以 96 01 代表的数据就是 150 。\n1 2 3  message Test1 { required int32 a = 1;}  如果存在上面这样的一个 message 的结构，如果存入 150，在 Protocol Buffer 中显示的二进制应该为 08 96 01 。\n额外说一句，type 需要注意的是 type = 2 的情况，tag 里面除了包含 field number 和 wire_type ，还需要再包含一个 length，决定 value 从那一段取出来。（具体原因见 Protocol Buffer 字符串 这一章节）\nSigned Integers 编码 从上面的表格里面可以看到 wire_type = 0 中包含了无符号的 varints，但是如果是一个无符号数呢？\n一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 10 个 byte 长度。\n为何 32 位和 64 位的负数都需要 10 个 byte 长度呢？\n1 2 3  inline void CodedOutputStream::WriteVarint32SignExtended(int32 value) { WriteVarint64(static_castuint64(value)); }   因为源码里面是这么规定的。32 位的有符号数都会转换成 64 位无符号来处理。至于源码为什么要这么规定呢，猜想可能是怕 32 位的负数转换会有溢出的可能。(只是猜想)\n在网络传输和数据存储场景中，需要对数据进行压缩。数据压缩的算法非常多，但大部分的数据压缩算法的原理是通过某种编码方式不存储数据中的0比特位，因此0比特位越多，数据压缩的效果越好。ZigZag编码就是一种增加0比例位的编码方式。\n可以看到varint对于有符号数，由于最高位是是符号位，如果是负数，那最高位就是1，这种情况下varint就会使用5个字节存储，会比原来更加浪费空间。zigzag编码就是为了解决负数问题的，同时其对正数也没有很大的影响。\n为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。将所有整数映射成无符号整数，然后再采用 varint 编码方式编码，这样，绝对值小的整数，编码后也会有一个较小的 varint 编码值。\nZigZag是将有符号数统一映射到无符号数的一种编码方案，对于无符号数0 1 2 3 4，映射前的有符号数分别为0 -1 1 -2 2，负数以及对应的正数来回映射到从0变大的数字序列里，这也是”zig-zag”的名字来源。\n为了便于后面的分析，我们先回顾下几个概念：\n 原码：最高位为符号位，剩余位表示绝对值； 反码：除符号位外，对原码剩余位依次取反； 补码：对于正数，补码为其自身；对于负数，除符号位外对原码剩余位依次取反然后+1。  补码解决了原码中00存在两种编码的问题：\n0=[00000000]原=[10000000]原0=[00000000]原=[10000000]原\n补码[10000001]补[10000001]补 表示−127−127；\n此外，原码中还存在加法错误的问题：\n1+(−1)=[00000001]原+[10000001]原=[10000010]原=−21+(−1)=[00000001]原+[10000001]原=[10000010]原=−2\n若用补码，则可得到正确结果：\n1+(−1)=[00000001]补+[11111111]补=[00000000]补=01+(−1)=[00000001]补+[11111111]补=[00000000]补=0\n因此，在计算机存储整数时，采用的是补码。此外，整数的补码有一些有趣的性质：\n 左移1位（n « 1），无论正数还是负数，相当于乘以2；对于正数，若大于Integer.MAX_VALUE/2（1076741823），则会发生溢出，导致左移1位后为负数 右移31位（n » 31），对于正数，则返回0x00000000；对于负数，则返回0xffffffff  这些性质正好在ZigZag编码中用到了。\nZigzag 映射函数为：\n1 2 3  Zigzag(n) = (n  1) ^ (n  31), n 为 sint32 时 Zigzag(n) = (n  1) ^ (n  63), n 为 sint64 时   正数\n假设数据类型为byte的正数11，其二进制表示为：00001011\n数据左移一位:00010110\n符号位（正数的符号为0）放到最后一位：00010110\n负数\n假设数据类型为byte的负数-11，其二进制在计算机中是用补码表示的，计算过程如下。\n正数原码：00001011。\n反码：11110100\n补码（反码加1）：11110101\n处理过程：\n左移一位：11101010\n符号位放到最后一位:11101011\n除最后一位外全部取反:00010101\n正数经过处理后，前导0和后置0的个数不变。但是负数经过处理后，增加了三个前导0，可以用于压缩。\n结合两种情况得出byte类型数据的编码公式：\n1  ZigZag(n) = n7 ^ n1   -11的处理过程如下：\n 11110101 » 7 = 11111111 11110101 « 1 = 11101010 11111111^11101010 = 00010101  ZigZag的逆函数：\n1  ZigZag−1(n)ZigZag−1(n)=(n1)^ -(n\u00261)   负数00010101的解码过程：\n n»1：00001010 n\u00261：00000001 -(n\u00261):11111111 1111111^0000101=11110101  需要注意的是，第二个转换 （n » 31） 部分，是一个算术转换。所以，换句话说，移位的结果要么是一个全为0（如果n是正数），要么是全部1（如果n是负数）。\n 编码时,先使用zigzag编码，后使用varint编码 解码时,先使用varint解码，后使用zigzag解码  当 sint32 或 sint64 被解析时，它的值被解码回原始的带符号的版本。\nNon-varint Numbers Non-varint 数字比较简单，double 、fixed64 的 wire_type 为 1，在解析时告诉解析器，该类型的数据需要一个 64 位大小的数据块即可。同理，float 和 fixed32 的 wire_type 为5，给其 32 位数据块即可。两种情况下，都是高位在后，低位在前。\n说 Protocol Buffer 压缩数据没有到极限，原因就在这里，因为并没有压缩 float、double 这些浮点类型。\n字符串 wire_type 类型为 2 的数据，是一种指定长度的编码方式：key + length + content，key 的编码方式是统一的，length 采用 varints 编码方式，content 就是由 length 指定长度的 Bytes。\n举例，假设定义如下的 message 格式：\n1 2 3  message Test2 { optional string b = 2;}  设置该值为\"testing\"，二进制格式查看：\n1  12 07 74 65 73 74 69 6e 67   74 65 73 74 69 6e 67 是“testing”的 UTF8 代码。\n此处，key 是16进制表示的，所以展开是：\n12 - 0001 0010，后三位 010 为 wire type = 2，0001 0010 右移三位为 0000 0010，即 tag = 2。\nlength 此处为 7，后边跟着 7 个bytes，即我们的字符串\"testing\"。\n所以 wire_type 类型为 2 的数据，编码的时候会默认转换为 T-L-V (Tag - Length - Value)的形式。\n嵌入式 message 假设，定义如下嵌套消息：\n1 2 3  message Test3 { optional Test1 c = 3;}  设置字段为整数150，编码后的字节为：\n1  1a 03 08 96 01   08 96 01 这三个代表的是 150，上面讲解过，这里就不再赘述了。\n1a - 0001 1010，后三位 010 为 wire type = 2，0001 1010 右移三位为 0000 0011，即 tag = 3。\nlength 为 3，代表后面有 3 个字节，即 08 96 01 。\n需要转变为 T - L - V 形式的还有 string, bytes, embedded messages, packed repeated fields （即 wire_type 为 2 的形式都会转变成 T - L - V 形式）\nOptional 和 Repeated 的编码 在 proto2 中定义成 repeated 的字段，（没有加上 [packed=true] option ），编码后的 message 有一个或者多个包含相同 tag 数字的 key-value 对。这些重复的 value 不需要连续的出现；他们可能与其他的字段间隔的出现。尽管他们是无序的，但是在解析时，他们是需要有序的。在 proto3 中 repeated 字段默认采用 packed 编码（具体原因见 Packed Repeated Fields 这一章节）\n对于 proto3 中的任何非重复字段或 proto2 中的可选字段，编码的 message 可能有也可能没有包含该字段号的键值对。\n通常，编码后的 message，其 required 字段和 optional 字段最多只有一个实例。但是解析器却需要处理多对一的情况。对于数字类型和 string 类型，如果同一值出现多次，解析器接受最后一个它收到的值。对于内嵌字段，解析器合并(merge)它接收到的同一字段的多个实例。就如 MergeFrom 方法一样，所有单数的字段，后来的会替换先前的，所有单数的内嵌 message 都会被合并(merge)，所有的 repeated 字段，都会串联起来。这样的规则的结果是，解析两个串联的编码后的 message，与分别解析两个 message 然后 merge，结果是一样的。例如：\n1 2  MyMessage message; message.ParseFromString(str1 + str2);   等价于\n1 2 3 4  MyMessage message, message2; message.ParseFromString(str1); message2.ParseFromString(str2); message.MergeFrom(message2);   这种方法有时是非常有用的。比如，即使不知道 message 的类型，也能够将其合并。\nPacked Repeated Fields 在 2.1.0 版本以后，protocol buffers 引入了该种类型，其与 repeated 字段一样，只是在末尾声明了 [packed=true]。类似 repeated 字段却又不同。在 proto3 中 Repeated 字段默认就是以这种方式处理。对于 packed repeated 字段，如果 message 中没有赋值，则不会出现在编码后的数据中。否则的话，该字段所有的元素会被打包到单一一个 key-value 对中，且它的 wire_type=2，长度确定。每个元素正常编码，只不过其前没有标签 tag。例如有如下 message 类型：\n1 2 3  message Test4 { repeated int32 d = 4 [packed=true];}  构造一个 Test4 字段，并且设置 repeated 字段 d 3个值：3，270和86942，编码后：\n1 2 3 4 5 6 7 8 9  22 // tag 0010 0010(field number 010 0 = 4, wire type 010 = 2) 06 // payload size (设置的length = 6 bytes) 03 // first element (varint 3) 8E 02 // second element (varint 270) 9E A7 05 // third element (varint 86942)   形成了 Tag - Length - Value - Value - Value …… 对。\n只有原始数字类型（使用varint，32位或64位）的重复字段才可以声明为“packed”。\n有一点需要注意，对于 packed 的 repeated 字段，尽管通常没有理由将其编码为多个 key-value 对，编码器必须有接收多个 key-pair 对的准备。这种情况下，payload 必须是串联的，每个 pair 必须包含完整的元素。\nProtocol Buffer 解析器必须能够解析被重新编译为 packed 的字段，就像它们未被 packed 一样，反之亦然。这允许以正向和反向兼容的方式将[packed = true]添加到现有字段。\nField Order 编码/解码与字段顺序无关，这一点由 key-value 机制保证。\n如果消息具有未知字段，则当前的 Java 和 C++ 实现在按顺序排序的已知字段之后以任意顺序写入它们。当前的 Python 实现不会跟踪未知字段。\nprotocol buffers 的优缺点 protocol buffers 在序列化方面，与 XML 相比，有诸多优点：\n 更加简单 数据体积小 3- 10 倍 更快的反序列化速度，提高 20 - 100 倍 可以自动化生成更易于编码方式使用的数据访问类  举个例子：\n如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：\n1 2 3 4   John Doe jdoe@example.com    相同需求，如果换成 protocol buffers 来实现，定义文件如下：\n1 2 3 4 5 6  # Textual representation of a protocol buffer # This is *not* the binary format used on the wire person { name: \"John Doe\" email: \"jdoe@example.com\" }   protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。\n上面说的是性能方面的优势。接下来说说编码方面的优势。\nprotocol buffers 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可（所有属性的 get 和 set 方法的代码都自动生成好了，只需要调用即可）\n1 2  cout  \"Name: \"  person.name()  endl; cout  \"E-mail: \"  person.email()  endl;   而 XML 读取数据会麻烦一些：\n1 2 3 4 5 6  cout  \"Name: \"  person.getElementsByTagName(\"name\")-item(0)-innerText()  endl; cout  \"E-mail: \"  person.getElementsByTagName(\"email\")-item(0)-innerText()  endl;   Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。\n使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。\nprotocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。\n当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。\n由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。\n总结 读完本篇 Protocol Buffer 编码原理以后，读者应该能明白以下几点：\n Protocol Buffer 利用 varint 原理压缩数据以后，二进制数据非常紧凑，option 也算是压缩体积的一个举措。所以 pb 体积更小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。但是并没有压缩到极限，float、double 浮点型都没有压缩。 Protocol Buffer 比 JSON 和 XML 少了 {、}、: 这些符号，体积也减少一些。再加上 varint 压缩，gzip 压缩以后体积更小！ Protocol Buffer 是 Tag - Value (Tag - Length - Value)的编码方式的实现，减少了分隔符的使用，数据存储更加紧凑。 Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。 Protocol Buffer 不是自我描述的，离开了数据描述 .proto 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。 Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。  参考 ZigZag编码 Protocol Buffers（1）：序列化、编译与使用 高效的数据压缩编码方式 Protobuf\n",
  "wordCount" : "8842",
  "inLanguage": "zh-cn",
  "datePublished": "2021-04-20T15:41:20Z",
  "dateModified": "2021-04-20T15:41:20Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/protobuf%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Protobuf编解码原理
    </h1>
    <div class="post-meta">April 20, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="序列化与反序列化">序列化与反序列化<a hidden class="anchor" aria-hidden="true" href="#序列化与反序列化">#</a></h2>
<p>有些时候，我们希望给数据结构或对象拍个“快照”，或者保存成文件，或者传输给其他应用程序。比如，在神经网络训练过程中，我们会将不同阶段的网络权重以模型文件的形式保存下来，如果训练意外终止，可以重新载入模型文件将模型复原，继续训练。</p>
<p>将数据结构或对象以某种格式转化为字节流的过程，称之为序列化（Serialization），目的是把当前的状态保存下来，在需要时复原数据结构或对象（序列化时不包含与对象相关联的函数，所以后面只提数据结构）。反序列化（Deserialization），是序列化的逆过程，读取字节流，根据约定的格式协议，将数据结构复原。如下图所示，图片来自geeksforgeeks</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210426163106.png" alt=""  />
</p>
<p>在介绍具体技术之前，我们先在脑海里分析下序列化和反序列化的过程：</p>
<ul>
<li>代码运行过程中，数据结构和对象位于内存，其中的各项数据成员可能彼此紧邻，也可能分布在并不连续的各个内存区域，比如指针指向的内存块等；</li>
<li>文件中字节是顺序存储的，要想将数据结构保存成文件，就需要把所有的数据成员平铺开（flatten），然后串接在一起；</li>
<li>直接串接可能是不行的，因为字节流中没有天然的分界，所以在序列化时需要按照某种约定的格式（协议），以便在反序列化时知道“从哪里到哪里是哪个数据成员”，因此格式可能需要约定：指代数据成员的标识、起始位置、终止位置、长度、分隔符等</li>
<li>由上可见，格式协议是最重要的，它直接决定了序列化和反序列化的效率、字节流的大小和可读性等</li>
</ul>
<h2 id="protocol-buffers概览">Protocol Buffers概览<a hidden class="anchor" aria-hidden="true" href="#protocol-buffers概览">#</a></h2>
<p>跨语言，跨平台，相比XML和JSON 更小、更快、更容易，因为XML、JSON为了可阅读、自解释被设计成字符文本形式，所以体积更大，在编码解码上也更麻烦，而Protobuf序列化为binary stream，体积更小，但是丧失了可读性——后面我们将看到可读性可以通过另一种方式得到保证。至于上面的&quot;You define how you want your data to be structured once&quot;该怎么理解？参看下图，图片素材来自 Protocol Buffers官网首页。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210426162437.png" alt=""  />
</p>
<p>首先是proto文件，在其中定义我们想要序列化的数据结构，如上图中的message Person，通过Protobuf提供的protoc.exe生成编解码代码文件（C++语言是.cc和.h），其中定义了类Person，类的各个成员变量与proto文件中的定义保持一致。序列化时，定义Person对象，对其成员变量赋值，调用序列化成员函数，将对象保存到文件。反序列化时，读入文件，将Person对象复原，读取相应的数据成员。</p>
<p>proto文件仅定义了数据的结构（name、id、email），具体的数据内容（1234、&ldquo;John Doe&rdquo;、&ldquo;<a href="mailto:jdoe@example.com">jdoe@example.com</a>&rdquo;）保存在序列化生成的文件中，通过简单的思考可知，序列化后的文件里应该会存在一些辅助信息用来将数据内容与数据结构对应起来，以便在反序列化时将数据内容赋值给对应的成员。</p>
<p>流程如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210426162610.png" alt=""  />
</p>
<h2 id="varint编码">varint编码<a hidden class="anchor" aria-hidden="true" href="#varint编码">#</a></h2>
<p>Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</p>
<p>Varint 中的每个字节（最后一个字节除外）都设置了最高有效位（msb），这一位表示还会有更多字节出现。每个字节的低 7 位用于以 7 位组的形式存储数字的二进制补码表示，最低有效组首位。</p>
<p>varint是一种可变长编码，使用1个或多个字节对整数进行编码，可编码任意大的整数，小整数占用的字节少，大整数占用的字节多，如果小整数更频繁出现，则通过varint可实现压缩存储。</p>
<p>varint中每个字节的最高位bit称之为most significant bit (MSB)，如果该bit为0意味着这个字节为表示当前整数的最后一个字节，如果为1则表示后面还有至少1个字节，可见，varint的终止位置其实是自解释的。</p>
<p>在Protobuf中，tag和length都是使用varint编码的。length和tag中的field_number都是正整数int32，这里提一下tag，它的低3位bit为wire type，如果只用1个字节表示的话，最高位bit为0，则留给field_number只有4个bit位，1到15，如果field_number大于等于16，就需要用2个字节，所以对于频繁使用的field其field_number应设置为1到15。</p>
<p>如果用不到 1 个字节，那么最高有效位设为 0 ，如下面这个例子，1 用一个字节就可以表示，所以 msb 为 0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">0000</span> <span class="m">0001</span>
</code></pre></td></tr></table>
</div>
</div><p>如果需要多个字节表示，msb 就应该设置为 1 。例如 300，如果用 Varint 表示的话：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">1010</span> <span class="m">1100</span> <span class="m">0000</span> <span class="m">0010</span>
</code></pre></td></tr></table>
</div>
</div><p>如果按照正常的二进制计算的话，这个表示的是 88068(65536 + 16384 + 4096 + 2048 + 4)。</p>
<p>那 Varint 是怎么编码的呢？</p>
<p>下面代码是 Varint int 32 的编码计算方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="nf">EncodeVarint32</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Operate on characters as unsigneds
</span><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">14</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">28</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">21</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">21</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">28</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">300</span> <span class="o">=</span> <span class="m">100101100</span>
</code></pre></td></tr></table>
</div>
</div><p>由于 300 超过了 7 位（Varint 一个字节只有 7 位能用来表示数字，最高位 msb 用来表示后面是否有更多字节），所以 300 需要用 2 个字节来表示。</p>
<p>Varint 的编码，以 300 举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="nf">if </span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="m">14</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="o">&gt;&gt;</span><span class="m">7</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>100101100 | 10000000 = 1 1010 1100</li>
<li>110101100 取出末尾 7 位 = 010 1100</li>
<li>100101100 &raquo; 7 = 10 = 0000 0010</li>
<li>1010 1100 0000 0010 (最终 Varint 结果)</li>
</ol>
<p>Varint 的解码算法应该是这样的：（实际就是编码的逆过程）</p>
<ol>
<li>如果是多个字节，先去掉每个字节的 msb（通过逻辑或运算），每个字节只留下 7 位。</li>
<li>逆序整个结果，最多是 5 个字节，排序是 1-2-3-4-5，逆序之后就是 5-4-3-2-1，字节内部的二进制位的顺序不变，变的是字节的相对位置。</li>
</ol>
<p>解码过程调用 GetVarint32Ptr 函数，如果是大于一个字节的情况，会调用 GetVarint32PtrFallback 来处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">GetVarint32Ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">limit</span><span class="p">,</span>
                                  <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mi">128</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">GetVarint32PtrFallback</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">GetVarint32PtrFallback</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">limit</span><span class="p">,</span>
                                   <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">shift</span> <span class="o">&lt;=</span> <span class="mi">28</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">shift</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
    <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// More bytes are present
</span><span class="c1"></span>      <span class="n">result</span> <span class="o">|=</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mi">127</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至此，Varint 处理过程读者应该都熟悉了。上面列举出了 Varint 32 的算法，64 位的同理，只不过不再用 10 个分支来写代码了，太丑了。（32位 是 5 个 字节，64位 是 10 个字节）</p>
<p>64 位 Varint 编码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">char</span><span class="o">*</span><span class="nf">EncodeVarint64</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">&gt;&gt;=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>原理不变，只不过用循环来解决了。</p>
<p>64 位 Varint 解码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="nf">GetVarint64Ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">limit</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">shift</span> <span class="o">&lt;=</span> <span class="mi">63</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">shift</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
    <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// More bytes are present
</span><span class="c1"></span>      <span class="n">result</span> <span class="o">|=</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mi">127</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>读到这里可能有读者会问了，Varint 不是为了紧凑 int 的么？那 300 本来可以用 2 个字节表示，现在还是 2 个字节了，哪里紧凑了，花费的空间没有变啊？！</p>
<p>Varint 确实是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。</p>
<p>300 如果用 int32 表示，需要 4 个字节，现在用 Varint 表示，只需要 2 个字节了。缩小了一半！</p>
<h2 id="message-structure-编码">Message Structure 编码<a hidden class="anchor" aria-hidden="true" href="#message-structure-编码">#</a></h2>
<p>protocol buffer 中 message 是一系列键值对。message 的二进制版本只是使用字段号(field&rsquo;s number 和 wire_type)作为 key。每个字段的名称和声明类型只能在解码端通过引用消息类型的定义（即 .proto 文件）来确定。这一点也是人们常常说的 protocol buffer 比 JSON，XML 安全一点的原因，如果没有数据结构描述 .proto 文件，拿到数据以后是无法解释成正常的数据的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210425194121.png" alt=""  />
</p>
<p>由于采用了 tag-value 的形式，所以 option 的 field 如果有，就存在在这个 message buffer 中，如果没有，就不会在这里，这一点也算是压缩了 message 的大小了。</p>
<p>当消息编码时，键和值被连接成一个字节流。当消息被解码时，解析器需要能够跳过它无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不知道它们的旧程序。这就是所谓的 “向后”兼容性。</p>
<p>为此，线性的格式消息中每对的“key”实际上是两个值，其中一个是来自.proto文件的字段编号，加上提供正好足够的信息来查找下一个值的长度。在大多数语言实现中，这个 key 被称为 tag。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210425195745.png" alt=""  />
</p>
<p>注意上图中，3 和 4 已经被废弃了，所以 wire_type 取值目前只有 0、1、2、5。</p>
<p>key 的计算方法是 <code>(field_number &lt;&lt; 3) | wire_type</code>，换句话说，key 的最后 3 位表示的就是 wire_type。</p>
<p>举例，一般 message 的字段号都是 1 开始的，所以对应的 tag 可能是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">000</span> <span class="m">1000</span>
</code></pre></td></tr></table>
</div>
</div><p>末尾 3 位表示的是 value 的类型，这里是 000，即 0 ，代表的是 varint 值。右移 3 位，即 0001，这代表的就是字段号(field number)。tag 的例子就举这么多，接下来举一个 value 的例子，还是用 varint 来举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">96</span> <span class="m">01</span> <span class="o">=</span> <span class="m">1001</span> <span class="m">0110</span>  <span class="m">0000</span> <span class="m">0001</span>
       → <span class="m">000</span> <span class="m">0001</span>  <span class="o">++</span>  <span class="m">001</span> <span class="m">0110</span> <span class="p">(</span><span class="n">drop</span> <span class="n">the</span> <span class="n">msb</span> <span class="n">and</span> <span class="n">reverse</span> <span class="n">the</span> <span class="n">groups</span> <span class="n">of</span> <span class="m">7</span> <span class="n">bits</span><span class="p">)</span>
       → <span class="m">10010110</span>
       → <span class="m">128</span> <span class="o">+</span> <span class="m">16</span> <span class="o">+</span> <span class="m">4</span> <span class="o">+</span> <span class="m">2</span> <span class="o">=</span> <span class="m">150</span>
</code></pre></td></tr></table>
</div>
</div><p>可以 96 01 代表的数据就是 150 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="kd">message</span> <span class="nc">Test1</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">required</span> <span class="kt">int32</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>如果存在上面这样的一个 message 的结构，如果存入 150，在 Protocol Buffer 中显示的二进制应该为 08 96 01 。</p>
<p>额外说一句，type 需要注意的是 type = 2 的情况，tag 里面除了包含 field number 和 wire_type ，还需要再包含一个 length，决定 value 从那一段取出来。（具体原因见 Protocol Buffer 字符串 这一章节）</p>
<h2 id="signed-integers-编码">Signed Integers 编码<a hidden class="anchor" aria-hidden="true" href="#signed-integers-编码">#</a></h2>
<p>从上面的表格里面可以看到 wire_type = 0 中包含了无符号的 varints，但是如果是一个无符号数呢？</p>
<p>一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 10 个 byte 长度。</p>
<p>为何 32 位和 64 位的负数都需要 10 个 byte 长度呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">CodedOutputStream</span><span class="o">::</span><span class="n">WriteVarint32SignExtended</span><span class="p">(</span><span class="n">int32</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">WriteVarint64</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">uint64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为源码里面是这么规定的。32 位的有符号数都会转换成 64 位无符号来处理。至于源码为什么要这么规定呢，猜想可能是怕 32 位的负数转换会有溢出的可能。(只是猜想)</p>
<p>在网络传输和数据存储场景中，需要对数据进行压缩。数据压缩的算法非常多，但大部分的数据压缩算法的原理是通过某种编码方式不存储数据中的0比特位，因此0比特位越多，数据压缩的效果越好。ZigZag编码就是一种增加0比例位的编码方式。</p>
<p>可以看到varint对于有符号数，由于最高位是是符号位，如果是负数，那最高位就是1，这种情况下varint就会使用5个字节存储，会比原来更加浪费空间。zigzag编码就是为了解决负数问题的，同时其对正数也没有很大的影响。</p>
<p>为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。将所有整数映射成无符号整数，然后再采用 varint 编码方式编码，这样，绝对值小的整数，编码后也会有一个较小的 varint 编码值。</p>
<p>ZigZag是将有符号数统一映射到无符号数的一种编码方案，对于无符号数0 1 2 3 4，映射前的有符号数分别为0 -1 1 -2 2，负数以及对应的正数来回映射到从0变大的数字序列里，这也是”zig-zag”的名字来源。</p>
<p>为了便于后面的分析，我们先回顾下几个概念：</p>
<ul>
<li>原码：最高位为符号位，剩余位表示绝对值；</li>
<li>反码：除符号位外，对原码剩余位依次取反；</li>
<li>补码：对于正数，补码为其自身；对于负数，除符号位外对原码剩余位依次取反然后+1。</li>
</ul>
<p>补码解决了原码中00存在两种编码的问题：</p>
<p><code>0=[00000000]原=[10000000]原0=[00000000]原=[10000000]原</code></p>
<p><code>补码[10000001]补[10000001]补 表示−127−127；</code></p>
<p>此外，原码中还存在加法错误的问题：</p>
<p><code>1+(−1)=[00000001]原+[10000001]原=[10000010]原=−21+(−1)=[00000001]原+[10000001]原=[10000010]原=−2</code></p>
<p>若用补码，则可得到正确结果：</p>
<p><code>1+(−1)=[00000001]补+[11111111]补=[00000000]补=01+(−1)=[00000001]补+[11111111]补=[00000000]补=0</code></p>
<p>因此，在计算机存储整数时，采用的是补码。此外，整数的补码有一些有趣的性质：</p>
<ul>
<li>左移1位（n &laquo; 1），无论正数还是负数，相当于乘以2；对于正数，若大于<code>Integer.MAX_VALUE/2（1076741823）</code>，则会发生溢出，导致左移1位后为负数</li>
<li>右移31位（n &raquo; 31），对于正数，则返回<code>0x00000000</code>；对于负数，则返回<code>0xffffffff</code></li>
</ul>
<p>这些性质正好在ZigZag编码中用到了。</p>
<p>Zigzag 映射函数为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Zigzag</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">),</span> <span class="n">n</span> <span class="err">为</span> <span class="n">sint32</span> <span class="err">时</span>

<span class="n">Zigzag</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">),</span> <span class="n">n</span> <span class="err">为</span> <span class="n">sint64</span> <span class="err">时</span>
</code></pre></td></tr></table>
</div>
</div><p>正数</p>
<p>假设数据类型为byte的正数11，其二进制表示为：00001011</p>
<p>数据左移一位:00010110</p>
<p>符号位（正数的符号为0）放到最后一位：00010110</p>
<p>负数</p>
<p>假设数据类型为byte的负数-11，其二进制在计算机中是用补码表示的，计算过程如下。</p>
<p>正数原码：00001011。</p>
<p>反码：11110100</p>
<p>补码（反码加1）：11110101</p>
<p>处理过程：</p>
<p>左移一位：11101010</p>
<p>符号位放到最后一位:11101011</p>
<p>除最后一位外全部取反:00010101</p>
<p>正数经过处理后，前导0和后置0的个数不变。但是负数经过处理后，增加了三个前导0，可以用于压缩。</p>
<p>结合两种情况得出byte类型数据的编码公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="nf">ZigZag</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">n</span><span class="o">&gt;&gt;</span><span class="m">7</span> <span class="n">^</span> <span class="n">n</span><span class="o">&lt;&lt;</span><span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>-11的处理过程如下：</p>
<ol>
<li>11110101 &raquo; 7 = 11111111</li>
<li>11110101 &laquo; 1 = 11101010</li>
<li>11111111^11101010 = 00010101</li>
</ol>
<p>ZigZag的逆函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ZigZag</span>−<span class="m">1</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="n">ZigZag</span>−<span class="m">1</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;&gt;</span><span class="m">1</span><span class="p">)</span><span class="n">^</span> <span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="m">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>负数00010101的解码过程：</p>
<ol>
<li>n&raquo;&gt;1：00001010</li>
<li>n&amp;1：00000001</li>
<li>-(n&amp;1):11111111</li>
<li>1111111^0000101=11110101</li>
</ol>
<p>需要注意的是，第二个转换 （n &raquo; 31） 部分，是一个算术转换。所以，换句话说，移位的结果要么是一个全为0（如果n是正数），要么是全部1（如果n是负数）。</p>
<ul>
<li>编码时,先使用zigzag编码，后使用varint编码</li>
<li>解码时,先使用varint解码，后使用zigzag解码</li>
</ul>
<p>当 sint32 或 sint64 被解析时，它的值被解码回原始的带符号的版本。</p>
<h2 id="non-varint-numbers">Non-varint Numbers<a hidden class="anchor" aria-hidden="true" href="#non-varint-numbers">#</a></h2>
<p>Non-varint 数字比较简单，double 、fixed64 的 wire_type 为 1，在解析时告诉解析器，该类型的数据需要一个 64 位大小的数据块即可。同理，float 和 fixed32 的 wire_type 为5，给其 32 位数据块即可。两种情况下，都是高位在后，低位在前。</p>
<p>说 Protocol Buffer 压缩数据没有到极限，原因就在这里，因为并没有压缩 float、double 这些浮点类型。</p>
<h2 id="字符串">字符串<a hidden class="anchor" aria-hidden="true" href="#字符串">#</a></h2>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210425205845.png" alt=""  />
</p>
<p>wire_type 类型为 2 的数据，是一种指定长度的编码方式：key + length + content，key 的编码方式是统一的，length 采用 varints 编码方式，content 就是由 length 指定长度的 Bytes。</p>
<p>举例，假设定义如下的 message 格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="kd">message</span> <span class="nc">Test2</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">string</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>设置该值为&quot;testing&quot;，二进制格式查看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">12</span> <span class="m">07</span> <span class="m">74</span> <span class="m">65</span> <span class="m">73</span> <span class="m">74</span> <span class="m">69</span> <span class="m">6</span><span class="n">e</span> <span class="m">67</span>
</code></pre></td></tr></table>
</div>
</div><p><code>74 65 73 74 69 6e 67</code> 是“testing”的 UTF8 代码。</p>
<p>此处，key 是16进制表示的，所以展开是：</p>
<p>12 -&gt; 0001 0010，后三位 010 为 wire type = 2，0001 0010 右移三位为 0000 0010，即 tag = 2。</p>
<p>length 此处为 7，后边跟着 7 个bytes，即我们的字符串&quot;testing&quot;。</p>
<p>所以 wire_type 类型为 2 的数据，编码的时候会默认转换为 T-L-V (Tag - Length - Value)的形式。</p>
<h2 id="嵌入式-message">嵌入式 message<a hidden class="anchor" aria-hidden="true" href="#嵌入式-message">#</a></h2>
<p>假设，定义如下嵌套消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="kd">message</span> <span class="nc">Test3</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="n">Test1</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>设置字段为整数150，编码后的字节为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">1</span><span class="n">a</span> <span class="m">03</span> <span class="m">08</span> <span class="m">96</span> <span class="m">01</span>
</code></pre></td></tr></table>
</div>
</div><p><code>08 96 01</code> 这三个代表的是 150，上面讲解过，这里就不再赘述了。</p>
<p><code>1a -&gt; 0001 1010</code>，后三位 010 为 wire type = 2，<code>0001 1010</code> 右移三位为 0000 0011，即 tag = 3。</p>
<p>length 为 3，代表后面有 3 个字节，即 08 96 01 。</p>
<p>需要转变为 T - L - V 形式的还有 string, bytes, embedded messages, packed repeated fields （即 wire_type 为 2 的形式都会转变成 T - L - V 形式）</p>
<h2 id="optional-和-repeated-的编码">Optional 和 Repeated 的编码<a hidden class="anchor" aria-hidden="true" href="#optional-和-repeated-的编码">#</a></h2>
<p>在 proto2 中定义成 repeated 的字段，（没有加上 <code>[packed=true] option</code> ），编码后的 message 有一个或者多个包含相同 tag 数字的 key-value 对。这些重复的 value 不需要连续的出现；他们可能与其他的字段间隔的出现。尽管他们是无序的，但是在解析时，他们是需要有序的。在 proto3 中 repeated 字段默认采用 packed 编码（具体原因见 Packed Repeated Fields 这一章节）</p>
<p>对于 proto3 中的任何非重复字段或 proto2 中的可选字段，编码的 message 可能有也可能没有包含该字段号的键值对。</p>
<p>通常，编码后的 message，其 required 字段和 optional 字段最多只有一个实例。但是解析器却需要处理多对一的情况。对于数字类型和 string 类型，如果同一值出现多次，解析器接受最后一个它收到的值。对于内嵌字段，解析器合并(merge)它接收到的同一字段的多个实例。就如 MergeFrom 方法一样，所有单数的字段，后来的会替换先前的，所有单数的内嵌 message 都会被合并(merge)，所有的 repeated 字段，都会串联起来。这样的规则的结果是，解析两个串联的编码后的 message，与分别解析两个 message 然后 merge，结果是一样的。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">MyMessage</span> <span class="n">message</span><span class="p">;</span>
<span class="n">message</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>等价于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">MyMessage</span> <span class="n">message</span><span class="p">,</span> <span class="n">message2</span><span class="p">;</span>
<span class="n">message</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
<span class="n">message2</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
<span class="n">message</span><span class="p">.</span><span class="n">MergeFrom</span><span class="p">(</span><span class="n">message2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>这种方法有时是非常有用的。比如，即使不知道 message 的类型，也能够将其合并。</p>
<h2 id="packed-repeated-fields">Packed Repeated Fields<a hidden class="anchor" aria-hidden="true" href="#packed-repeated-fields">#</a></h2>
<p>在 2.1.0 版本以后，protocol buffers 引入了该种类型，其与 repeated 字段一样，只是在末尾声明了 <code>[packed=true]</code>。类似 repeated 字段却又不同。在 proto3 中 Repeated 字段默认就是以这种方式处理。对于 packed repeated 字段，如果 message 中没有赋值，则不会出现在编码后的数据中。否则的话，该字段所有的元素会被打包到单一一个 key-value 对中，且它的 wire_type=2，长度确定。每个元素正常编码，只不过其前没有标签 tag。例如有如下 message 类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="kd">message</span> <span class="nc">Test4</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="kt">int32</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">[</span><span class="k">packed</span><span class="o">=</span><span class="kc">true</span><span class="p">];</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>构造一个 Test4 字段，并且设置 repeated 字段 d 3个值：3，270和86942，编码后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">22</span> <span class="o">//</span> <span class="n">tag</span> <span class="m">0010</span> <span class="m">0010</span><span class="p">(</span><span class="n">field</span> <span class="n">number</span> <span class="m">010</span> <span class="m">0</span> <span class="o">=</span> <span class="m">4</span><span class="p">,</span> <span class="n">wire</span> <span class="n">type</span> <span class="m">010</span> <span class="o">=</span> <span class="m">2</span><span class="p">)</span>

<span class="m">06</span> <span class="o">//</span> <span class="n">payload</span> <span class="nf">size </span><span class="p">(</span>设置的<span class="n">length</span> <span class="o">=</span> <span class="m">6</span> <span class="n">bytes</span><span class="p">)</span>

<span class="m">03</span> <span class="o">//</span> <span class="n">first</span> <span class="nf">element </span><span class="p">(</span><span class="n">varint</span> <span class="m">3</span><span class="p">)</span>

<span class="m">8</span><span class="n">E</span> <span class="m">02</span> <span class="o">//</span> <span class="n">second</span> <span class="nf">element </span><span class="p">(</span><span class="n">varint</span> <span class="m">270</span><span class="p">)</span>

<span class="m">9</span><span class="n">E</span> <span class="n">A7</span> <span class="m">05</span> <span class="o">//</span> <span class="n">third</span> <span class="nf">element </span><span class="p">(</span><span class="n">varint</span> <span class="m">86942</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>形成了 Tag - Length - Value - Value - Value …… 对。</p>
<p>只有原始数字类型（使用varint，32位或64位）的重复字段才可以声明为“packed”。</p>
<p>有一点需要注意，对于 packed 的 repeated 字段，尽管通常没有理由将其编码为多个 key-value 对，编码器必须有接收多个 key-pair 对的准备。这种情况下，payload 必须是串联的，每个 pair 必须包含完整的元素。</p>
<p>Protocol Buffer 解析器必须能够解析被重新编译为 packed 的字段，就像它们未被 packed 一样，反之亦然。这允许以正向和反向兼容的方式将<code>[packed = true]</code>添加到现有字段。</p>
<h2 id="field-order">Field Order<a hidden class="anchor" aria-hidden="true" href="#field-order">#</a></h2>
<p>编码/解码与字段顺序无关，这一点由 key-value 机制保证。</p>
<p>如果消息具有未知字段，则当前的 Java 和 C++ 实现在按顺序排序的已知字段之后以任意顺序写入它们。当前的 Python 实现不会跟踪未知字段。</p>
<h2 id="protocol-buffers-的优缺点">protocol buffers 的优缺点<a hidden class="anchor" aria-hidden="true" href="#protocol-buffers-的优缺点">#</a></h2>
<p>protocol buffers 在序列化方面，与 XML 相比，有诸多优点：</p>
<ul>
<li>更加简单</li>
<li>数据体积小 3- 10 倍</li>
<li>更快的反序列化速度，提高 20 - 100 倍</li>
<li>可以自动化生成更易于编码方式使用的数据访问类</li>
</ul>
<p>举个例子：</p>
<p>如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml">  <span class="nt">&lt;person&gt;</span>
    <span class="nt">&lt;name&gt;</span>John Doe<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;email&gt;</span>jdoe@example.com<span class="nt">&lt;/email&gt;</span>
  <span class="nt">&lt;/person&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>相同需求，如果换成 protocol buffers 来实现，定义文件如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># Textual representation of a protocol buffer
# This is *not* the binary format used on the wire
person {
  name: &#34;John Doe&#34;
  email: &#34;jdoe@example.com&#34;
}
</code></pre></td></tr></table>
</div>
</div><p>protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p>
<p>上面说的是性能方面的优势。接下来说说编码方面的优势。</p>
<p>protocol buffers 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可（所有属性的 get 和 set 方法的代码都自动生成好了，只需要调用即可）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;E-mail: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">person</span><span class="p">.</span><span class="n">email</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>而 XML 读取数据会麻烦一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Name: &#34;</span>
       <span class="o">&lt;&lt;</span> <span class="n">person</span><span class="p">.</span><span class="n">getElementsByTagName</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">innerText</span><span class="p">()</span>
       <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;E-mail: &#34;</span>
       <span class="o">&lt;&lt;</span> <span class="n">person</span><span class="p">.</span><span class="n">getElementsByTagName</span><span class="p">(</span><span class="s">&#34;email&#34;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">innerText</span><span class="p">()</span>
       <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p>
<p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p>
<p>protocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p>
<p>当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。</p>
<p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>读完本篇 Protocol Buffer 编码原理以后，读者应该能明白以下几点：</p>
<ol>
<li>Protocol Buffer 利用 varint 原理压缩数据以后，二进制数据非常紧凑，option 也算是压缩体积的一个举措。所以 pb 体积更小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。但是并没有压缩到极限，float、double 浮点型都没有压缩。</li>
<li>Protocol Buffer 比 JSON 和 XML 少了 {、}、: 这些符号，体积也减少一些。再加上 varint 压缩，gzip 压缩以后体积更小！</li>
<li>Protocol Buffer 是 Tag - Value (Tag - Length - Value)的编码方式的实现，减少了分隔符的使用，数据存储更加紧凑。</li>
<li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li>
<li>Protocol Buffer 不是自我描述的，离开了数据描述 .proto 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li>
<li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li>
</ol>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://blog.51cto.com/31329846/2463857">ZigZag编码</a>
<a href="https://www.cnblogs.com/shine-lee/p/10701810.html">Protocol Buffers（1）：序列化、编译与使用</a>
<a href="https://halfrost.com/protobuf_encode/">高效的数据压缩编码方式 Protobuf</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/protobuf/">protobuf</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
