<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的系统监控源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的系统监控源码剖析" />
<meta property="og:description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<meta property="article:published_time" content="2020-11-12T19:32:21+00:00" />
<meta property="article:modified_time" content="2020-11-12T19:32:21+00:00" />
<meta itemprop="name" content="Go的系统监控源码剖析">
<meta itemprop="description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触">
<meta itemprop="datePublished" content="2020-11-12T19:32:21&#43;00:00" />
<meta itemprop="dateModified" content="2020-11-12T19:32:21&#43;00:00" />
<meta itemprop="wordCount" content="15180">



<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的系统监控源码剖析"/>
<meta name="twitter:description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的系统监控源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-12 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 15180 字 </span>
          <span class="more-meta"> 预计阅读 31 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原理">设计原理</a></li>
    <li><a href="#sysmon启动">sysmon启动</a></li>
    <li><a href="#sysmon">sysmon</a></li>
    <li><a href="#checkdead">checkdead</a></li>
    <li><a href="#incidlelocked">incidlelocked</a></li>
    <li><a href="#injectglist">injectglist</a></li>
    <li><a href="#retake">retake</a>
      <ul>
        <li><a href="#抢占进行系统调用的-p">抢占进行系统调用的 P</a></li>
        <li><a href="#抢占长时间运行的-p">抢占长时间运行的 P</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计原理">设计原理</h2>
<p>Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收，通过这些行为，它能够让系统的运行状态变得更健康。</p>
<p>Go程序启动时，runtime会去启动一个名为sysmon的m(一般称为监控线程)，它自身通过 newm 在一个 M 上独立运行， 自身永远保持在一个循环内直到应用结束。</p>
<h2 id="sysmon启动">sysmon启动</h2>
<p>当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.newm 会创建一个存储待执行函数和处理器的新结构体 runtime.m。运行时执行系统监控不需要处理器，系统监控的 Goroutine 会直接在创建的线程上运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 创建 m 对象
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="c1">// 暂存 m
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">sigmask</span> <span class="p">=</span> <span class="nx">initSigmask</span>
	<span class="o">...</span>
	<span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.newm1 会调用特定平台的 runtime.newsproc 通过系统调用 clone 创建一个新的线程并在新的线程中执行 runtime.mstart：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">stk</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">oset</span> <span class="nx">sigset</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sigset_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nf">clone</span><span class="p">(</span><span class="nx">cloneFlags</span><span class="p">,</span> <span class="nx">stk</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">mstart</span><span class="p">)))</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后执行 mstart 函数，这是在 newosproc 函数传递进来的。mstart 函数再调用 mstart1，在 mstart1 里会执行这一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 执行启动函数。初始化过程中，fn == nil
</span><span class="c1"></span><span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nf">fn</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>之前我们在讲初始化的时候，这里的 fn 是空，会跳过的。但在这里，fn 就是最开始在 runtime.main 里设置的 sysmon 函数，因此这里会执行 sysmon，而它又是一个无限循环，永不返回。</p>
<p>所以，这里不会执行到 mstart1 函数后面的 schedule 函数，也就不会进入 schedule 循环。因此这是一个不用和 p 结合的 m，它直接在后台执行，默默地执行监控任务。</p>
<h2 id="sysmon">sysmon</h2>
<p>sysmon 执行一个无限循环，一开始每次循环休眠 20us，之后（1 ms 后）每次休眠时间倍增，最终每一轮都会休眠 10ms。</p>
<p>sysmon 中会进行 netpool（获取 fd 事件）、retake（抢占）、forcegc（按时间强制执行 gc），scavenge heap（释放自由列表中多余的项减少内存占用）等处理。</p>
<p>在新创建的线程中，我们会执行存储在 runtime.m 结构体中的 runtime.sysmon 函数启动系统监控：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Always runs without a P, so write barriers are not allowed.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">//首先注意，forcegcperiod是定义在sysmon函数外边的。它的含义是强制执行GC的时间间隔，默认是2分钟。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">forcegcperiod</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mf">1e9</span>  <span class="c1">//强制GC的时间间隔/2分钟/
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

    <span class="nx">lasttrace</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">//idle表示最近已连续有多少次系统监测任务执行但未能成功夺取P。一旦某次执行过程中成功夺取P，其值就会清零。
</span><span class="c1"></span>    <span class="nx">idle</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// how many cycles in succession we had not wokeup somebody
</span><span class="c1"></span>    <span class="c1">//delay表示系统监测任务具体的睡眠时间，单位为微秒。最大值为10000us，即10ms。
</span><span class="c1"></span>	<span class="nx">delay</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">idle</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// start with 20us sleep...
</span><span class="c1"></span>			<span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">idle</span> <span class="p">&gt;</span> <span class="mi">50</span> <span class="p">{</span> <span class="c1">// start doubling the sleep after 1ms...
</span><span class="c1"></span>			<span class="nx">delay</span> <span class="o">*=</span> <span class="mi">2</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">delay</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="mi">1000</span> <span class="p">{</span> <span class="c1">// up to 10ms
</span><span class="c1"></span>			<span class="nx">delay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>
		<span class="p">}</span>
		<span class="nf">usleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
		<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
        <span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
        <span class="c1">//STW时休眠sysmon
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
            <span class="c1">//如果发现有串行运行时任务等待执行，或所有P都已空闲，也就是没活干了，那么就继续睡。
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">next</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
                <span class="c1">//设置休眠标志,休眠(有个超时,苏醒保障)
</span><span class="c1"></span>                <span class="c1">//睡之前将调度器的sysmonwait字段设置为1，表示系统监测任务已停止。
</span><span class="c1"></span>					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="c1">// Make wake-up period small enough
</span><span class="c1"></span>                    <span class="c1">// for the sampling to be correct.
</span><span class="c1"></span>                    <span class="c1">//这次睡的时间是forcegcperiod和scavengelimit中较小值的一半。
</span><span class="c1"></span>                    <span class="c1">//也就是说，是强制GC时间间隔和清扫堆时间间隔中较短时间间隔的一半。
</span><span class="c1"></span>					<span class="nx">sleep</span> <span class="o">:=</span> <span class="nx">forcegcperiod</span> <span class="o">/</span> <span class="mi">2</span>
					<span class="k">if</span> <span class="nx">next</span><span class="o">-</span><span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">sleep</span> <span class="p">{</span>
						<span class="nx">sleep</span> <span class="p">=</span> <span class="nx">next</span> <span class="o">-</span> <span class="nx">now</span>
					<span class="p">}</span>
					<span class="nx">shouldRelax</span> <span class="o">:=</span> <span class="nx">sleep</span> <span class="o">&gt;=</span> <span class="nx">osRelaxMinNS</span>
					<span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
						<span class="nf">osRelax</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
                    <span class="p">}</span>
                    <span class="c1">//runtime.notesleep 会使用信号量同步系统监控即将进入休眠的状态。
</span><span class="c1"></span>					<span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">,</span> <span class="nx">sleep</span><span class="p">)</span>
					<span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
						<span class="nf">osRelax</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
                    <span class="p">}</span>

					<span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
					<span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
                    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                    <span class="c1">//睡完之后调度器的sysmonwait字段要清零
</span><span class="c1"></span>                    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="c1">//调用 runtime.noteclear 通知系统监控被唤醒并重置休眠的间隔。
</span><span class="c1"></span>					<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="c1">//把idle清零，并将delay设为初始值20。
</span><span class="c1"></span>				<span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
			<span class="p">}</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// If we spent a long time blocked on sysmonlock
</span><span class="c1"></span>			<span class="c1">// then we want to update now and next since it&#39;s
</span><span class="c1"></span>			<span class="c1">// likely stale.
</span><span class="c1"></span>			<span class="nx">now1</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">now1</span><span class="o">-</span><span class="nx">now</span> <span class="p">&gt;</span> <span class="mi">50</span><span class="o">*</span><span class="mi">1000</span> <span class="cm">/* 50µs */</span> <span class="p">{</span>
				<span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">now</span> <span class="p">=</span> <span class="nx">now1</span>
		<span class="p">}</span>

		<span class="c1">// trigger libc interceptors if needed
</span><span class="c1"></span>		<span class="c1">// 需要时触发 libc interceptor
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">//接下来就是抢夺P和G的过程。
</span><span class="c1"></span>        <span class="c1">//首先如果网络I/O轮询器已经初始化，并且距上次通过网络轮询器获取G的时间已超过10ms，那么就记录此次获取的时间并通过网络I/O轮询器获取一个可运行G，否则跳过此步。
</span><span class="c1"></span>        <span class="c1">// poll network if not polled for more than 10ms
</span><span class="c1"></span>        <span class="c1">//从网络I/O轮询器获取一个可运行G
</span><span class="c1"></span>        <span class="c1">//上次从网络轮询器获取G的时间
</span><span class="c1"></span>        <span class="nx">lastpoll</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">))</span>
        <span class="c1">//获取超过10ms的netpoll结果
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
            <span class="c1">//更新调度器的lastpoll值
</span><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lastpoll</span><span class="p">),</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
            <span class="c1">// 非阻塞 - 返回一个goroutine列表
</span><span class="c1"></span>			<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// non-blocking - returns list of goroutines
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// Need to decrement number of idle locked M&#39;s
</span><span class="c1"></span>				<span class="c1">// (pretending that one more is running) before injectglist.
</span><span class="c1"></span>				<span class="c1">// Otherwise it can lead to the following situation:
</span><span class="c1"></span>				<span class="c1">// injectglist grabs all P&#39;s but before it starts M&#39;s to run the P&#39;s,
</span><span class="c1"></span>				<span class="c1">// another M returns from syscall, finishes running its G,
</span><span class="c1"></span>				<span class="c1">// observes that there is no work to do and no other running M&#39;s
</span><span class="c1"></span>                <span class="c1">// and reports deadlock.
</span><span class="c1"></span>                <span class="c1">//incidlelocked是”inc idle locked “这三个单词组合而成，意思是增加因锁定而空闲的M的数量。这个数量其实是调度器的nmidlelocked字段
</span><span class="c1"></span>                <span class="c1">//在通过网络轮询器获得G之后，将这些G放入调度器的全局G队列前后两次调用incidlelocked函数到底有什么用呢？
</span><span class="c1"></span>                <span class="c1">//想象一下，如果在injectglist函数在完成它的工作之前，某个M从系统调用返回并执行完了它的G，此时它掐指一算，系统中没有工作可做了，也没有运行的M了，于是死锁就发生了。然而这时的injectglist函数就是有冤无处述，有苦说不出了。就因为送货（G）慢了点，人家就关门了，也不等等它。所以现在你应该知道了incidlelockd(-1)的作用就是为了避免这种死锁的情况。将nmidlelocked减一后，run的值怎么都是大于等于1，不会小于0。从而避免从网络轮询器获得的G在运行之前发生死锁。也就是说假装还有一个M在运行，但是真实的情况肯定不是这样，所以等到injectglist函数完成它的工作后，就要再次调用incidlelocked(1)来恢复系统真实的样子。
</span><span class="c1"></span>                <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">//它会把G都加入到调度器的可运行G队列，并启动一个空闲的P来运行G。
</span><span class="c1"></span>				<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
				<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//如果在这之后，我们发现下一个计时器需要触发的时间小于当前时间，这也就说明所有的线程可能正在忙于运行 Goroutine，系统监控会启动新的线程来触发计时器，避免计时器的到期时间有较大的偏差。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">next</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
			<span class="c1">// There are timers that should have already run,
</span><span class="c1"></span>			<span class="c1">// perhaps because there is an unpreemptible P.
</span><span class="c1"></span>			<span class="c1">// Try to start an M to run them.
</span><span class="c1"></span>			<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">scavenge</span><span class="p">.</span><span class="nx">sysmonWake</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Kick the scavenger awake if someone requested it.
</span><span class="c1"></span>			<span class="nf">wakeScavenger</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// retake P&#39;s blocked in syscalls
</span><span class="c1"></span>        <span class="c1">// and preempt long running G&#39;s
</span><span class="c1"></span>        <span class="c1">//其次是从调度器那里抢夺符合条件的P和G，这一步由retake函数完成，抢夺成功则idle会清零，失败则idle自加一.
</span><span class="c1"></span>        <span class="c1">//抢夺syscall长时间阻塞的P
</span><span class="c1"></span>        <span class="c1">//向长时间运行的G发出抢占调度
</span><span class="c1"></span>        <span class="c1">//从调度器那里抢夺符合条件的P和G
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">idle</span><span class="o">++</span>
		<span class="p">}</span>
        <span class="c1">// check if we need to force a GC
</span><span class="c1"></span>        <span class="c1">//在最后，系统监控还会决定是否需要触发强制垃圾回收，runtime.sysmon 会构建 runtime.gcTrigger 结构体并调用 runtime.gcTrigger.test 函数判断是否需要触发垃圾回收
</span><span class="c1"></span>        <span class="c1">//如果当前GC未执行，且距上一次执行已超过GC最大时间间隔，系统监测程序就会恢复专用于强制GC的G，并把它放入调度器的可运行G队列。GC最大时间间隔就是forcegcperiod的值，初始值为2分钟，
</span><span class="c1"></span>        <span class="c1">//用于强制GC的G是一个专用G，它在调度器初始化时就开始运行了，只不过一般处于暂停状态，只有系统监测程序可以恢复它。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">:</span> <span class="nx">now</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="kd">var</span> <span class="nx">list</span> <span class="nx">gList</span>
			<span class="nx">list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span><span class="p">)</span>
            <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
            <span class="c1">//forcegc就是强制GC的专用G。它在runtime2.go中定义，类型是forcegcstate。
</span><span class="c1"></span>            <span class="c1">//forcegcstate是一个结构体类型，其中封装了一个G。
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">//如果程序运行之前设置了GODEBUG环境变量，并且包含schedtrace=x，那么系统监测程序就会每过x毫秒打印一次调度器跟踪信息。这的x就是打印周期。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lasttrace</span><span class="o">+</span><span class="nb">int64</span><span class="p">(</span><span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span><span class="p">)</span><span class="o">*</span><span class="mi">1000000</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
			<span class="nx">lasttrace</span> <span class="p">=</span> <span class="nx">now</span>
			<span class="nf">schedtrace</span><span class="p">(</span><span class="nx">debug</span><span class="p">.</span><span class="nx">scheddetail</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>当运行时刚刚调用上述函数时，会先通过 runtime.checkdead 检查是否存在死锁，然后进入核心的监控循环；系统监控在每次循环开始时都会通过 usleep 挂起当前线程，该函数的参数是微秒，运行时会遵循以下的规则决定休眠时间：</p>
<ul>
<li>初始的休眠时间是 20μs；</li>
<li>最长的休眠时间是 10ms；</li>
<li>当系统监控在 50 个循环中都没有唤醒 Goroutine 时，休眠时间在每个循环都会倍增；</li>
</ul>
<p>当程序趋于稳定之后，系统监控的触发时间就会稳定在 10ms。它除了会检查死锁之外，还会在循环中完成以下的工作：</p>
<ul>
<li>运行计时器 — 获取下一个需要被触发的计时器；</li>
<li>轮询网络 — 获取需要处理的到期文件描述符；</li>
<li>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</li>
<li>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</li>
</ul>
<p>我们在这一节中会依次介绍系统监控是如何处理五种不同工作的。</p>
<h2 id="checkdead">checkdead</h2>
<p>系统监控通过 runtime.checkdead 检查运行时是否发生了死锁，我们可以将检查死锁的过程分成以下三个步骤：</p>
<ol>
<li>检查是否存在正在运行的线程；</li>
<li>检查是否存在正在运行的 Goroutine；</li>
<li>检查处理器上是否存在计时器；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Check for deadlock situation.
</span><span class="c1">// The check is based on number of running M&#39;s, if 0 -&gt; deadlock.
</span><span class="c1">// sched.lock must be held.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkdead</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// For -buildmode=c-shared or -buildmode=c-archive it&#39;s OK if
</span><span class="c1"></span>	<span class="c1">// there are no running goroutines. The calling program is
</span><span class="c1"></span>	<span class="c1">// assumed to be running.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">islibrary</span> <span class="o">||</span> <span class="nx">isarchive</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// If we are dying because of a signal caught on an already idle thread,
</span><span class="c1"></span>	<span class="c1">// freezetheworld will cause all running threads to block.
</span><span class="c1"></span>	<span class="c1">// And runtime will essentially enter into deadlock state,
</span><span class="c1"></span>	<span class="c1">// except that there is a thread that will call exit soon.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">panicking</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// If we are not running under cgo, but we have an extra M then account
</span><span class="c1"></span>	<span class="c1">// for it. (It is possible to have an extra M on Windows without cgo to
</span><span class="c1"></span>	<span class="c1">// accommodate callbacks created by syscall.NewCallback. See issue #6751
</span><span class="c1"></span>	<span class="c1">// for details.)
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">run0</span> <span class="kt">int32</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">iscgo</span> <span class="o">&amp;&amp;</span> <span class="nx">cgoHasExtraM</span> <span class="p">{</span>
		<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">lockextra</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="nx">haveExtraM</span> <span class="o">:=</span> <span class="nx">extraMCount</span> <span class="p">&gt;</span> <span class="mi">0</span>
		<span class="nf">unlockextra</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">haveExtraM</span> <span class="p">{</span>
			<span class="nx">run0</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">//首先会检查 Go 语言运行时中正在运行的线程数量，我们通过调度器中的多个字段计算该值的结果：
</span><span class="c1"></span>    <span class="c1">//1. runtime.mcount返回的是目前系统中存在的M的数量:根据下一个待创建的线程 id 和释放的线程数得到系统中存在的线程数；
</span><span class="c1"></span>    <span class="c1">//2. nmidle 是处于空闲状态的线程数量；
</span><span class="c1"></span>    <span class="c1">//3. nmidlelocked 是处于锁定状态的线程数量；
</span><span class="c1"></span>    <span class="c1">//4. nmsys 是处于系统调用的线程数量；
</span><span class="c1"></span>    <span class="c1">//run代表的就是还在运行的M的数量。如果线程数量大于 0，说明当前程序不存在死锁；如果线程数小于 0，说明当前程序的状态不一致；如果线程数等于 0，我们需要进一步检查程序的运行状态
</span><span class="c1"></span>    <span class="nx">run</span> <span class="o">:=</span> <span class="nf">mcount</span><span class="p">()</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span>
	<span class="k">if</span> <span class="nx">run</span> <span class="p">&gt;</span> <span class="nx">run0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">run</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: checkdead: nmidle=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="p">,</span> <span class="s">&#34; nmidlelocked=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span><span class="p">,</span> <span class="s">&#34; mcount=&#34;</span><span class="p">,</span> <span class="nf">mcount</span><span class="p">(),</span> <span class="s">&#34; nmsys=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: inconsistent counts&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//当存在 Goroutine 处于 _Grunnable、_Grunning 和 _Gsyscall 状态时，意味着程序发生了死锁；
</span><span class="c1"></span>    <span class="c1">//当所有的 Goroutine 都处于 _Gidle、_Gdead 和 _Gcopystack 状态时，意味着主程序调用了 runtime.goexit；
</span><span class="c1"></span>	<span class="nx">grunning</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allgs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">allgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">&amp;^</span> <span class="nx">_Gscan</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">_Gwaiting</span><span class="p">,</span>
			<span class="nx">_Gpreempted</span><span class="p">:</span>
			<span class="nx">grunning</span><span class="o">++</span>
		<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span>
			<span class="nx">_Grunning</span><span class="p">,</span>
			<span class="nx">_Gsyscall</span><span class="p">:</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: checkdead: find g &#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34; in status &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: runnable g&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">grunning</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// possible if main goroutine calls runtime·Goexit()
</span><span class="c1"></span>		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// unlock so that GODEBUG=scheddetail=1 doesn&#39;t hang
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;no goroutines (main called runtime.Goexit) - deadlock!&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Maybe jump time forward for playground.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">faketime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">when</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">faketime</span> <span class="p">=</span> <span class="nx">when</span>
			<span class="k">for</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">;</span> <span class="o">*</span><span class="nx">pp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">pp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pp</span><span class="p">).</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">link</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pp</span><span class="p">).</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">_p_</span> <span class="p">{</span>
					<span class="o">*</span><span class="nx">pp</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">mget</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// There should always be a free M since
</span><span class="c1"></span>				<span class="c1">// nothing is running.
</span><span class="c1"></span>				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: no m for timer&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">//当运行时存在等待的 Goroutine 并且不存在正在运行的 Goroutine 时，我们会检查处理器中存在的计时器：
</span><span class="c1"></span>    <span class="c1">//如果处理器中存在等待的计时器，那么所有的 Goroutine 陷入休眠状态是合理的，不过如果不存在等待的计时器，运行时就会直接报错并退出程序。
</span><span class="c1"></span>	<span class="c1">// There are no goroutines running, so we can look at the P&#39;s.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>    <span class="c1">// unlock so that GODEBUG=scheddetail=1 doesn&#39;t hang
</span><span class="c1"></span>	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;all goroutines are asleep - deadlock!&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="incidlelocked">incidlelocked</h2>
<p>incidlelocked函数十分简单，它就做了两件事：</p>
<ol>
<li>将参数加到调度器的nmidlelocked字段上</li>
<li>如果参数大于0，就调用checkdead函数检查是否发生死锁。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">incidlelocked</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span><span class="c1">//加锁
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span> <span class="o">+=</span> <span class="nx">v</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">checkdead</span><span class="p">()</span><span class="c1">//检查死锁
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span><span class="c1">//解锁
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那么为什么只在参数大于0的情况下才去检查死锁呢？因为参数大于0时，nmidlelocked值会增大，这时就有可能使run的值变成负数。也就是说这个M的锁定可能使系统中没有运行的M而发生死锁，当然有必要查看一下是否发生了死锁。如果incidlelocked函数的参数小于0，那么nmidlelocked的值会变小，而run的值只会更大，如果run本来就大于0，那么更不可能因此而发生死锁了，当然也就没必要检查了。</p>
<h2 id="injectglist">injectglist</h2>
<p>injectglist函数会非阻塞地调用 runtime.netpoll 检查待执行的文件描述符并通过 runtime.injectglist 将所有处于就绪状态的 Goroutine 加入全局运行队列中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">injectglist</span><span class="p">(</span><span class="nx">glist</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">();</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
		<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="nx">glist</span> <span class="p">=</span> <span class="nx">gList</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数会将所有 Goroutine 的状态从 _Gwaiting 切换至_Grunnable 并加入全局运行队列等待运行，如果当前程序中存在空闲的处理器，就会通过 runtime.startm 函数启动线程来执行这些任务。</p>
<h2 id="retake">retake</h2>
<p>系统监控通过在循环中抢占处理器来避免同一个 Goroutine 占用线程太长时间造成饥饿问题。</p>
<p>系统监控在循环中调用 runtime.retake 函数抢占处于运行或者系统调用中的处理器，该函数会遍历运行时的全局处理器，</p>
<p>runtime.retake 中的循环包含了两种不同的抢占逻辑：</p>
<ol>
<li>当处理器处于 _Prunning 状态时，如果上一次触发调度的时间已经过去了 10ms，我们就会通过 runtime.preemptone 抢占当前处理器；</li>
<li>当处理器处于 _Psyscall 状态时，在满足以下两种情况下会调用 runtime.handoffp 让出处理器的使用权：
<ol>
<li>当处理器的运行队列不为空或者不存在空闲处理器时；</li>
<li>当系统调用时间超过了 10ms 时；</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="c1">//在retake函数开始处，首先初始化了一个变量n := 0，它用来记录成功抢夺到P的次数
</span><span class="c1"></span>    <span class="c1">//而最后retake函数的返回值也是这个n，所以在sysmon函数中我们能够用retake函数的返回值是否大于0来判断抢夺P是否成功。
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// Prevent allp slice changes. This lock will be completely
</span><span class="c1"></span>	<span class="c1">// uncontended unless we&#39;re already stopping the world.
</span><span class="c1"></span>	<span class="c1">// 防止 allp 数组发生变化，除非我们已经 STW，此锁将完全没有人竞争
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="c1">// We can&#39;t use a range loop over allp because we may
</span><span class="c1"></span>	<span class="c1">// temporarily drop the allpLock. Hence, we need to re-fetch
</span><span class="c1"></span>	<span class="c1">// allp each time around the loop.
</span><span class="c1"></span>	<span class="c1">//接下来是对全局P列表中所有P进行迭代，并在可以抢夺的时候将P抢过来。不过在这之前，首先要初始化一些变量。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">//为什么从全局P列表取出的P还要进行为空判断呢？这是为了防止此时调用了procresize函数增加了P的最大数量，虽然数量已经涨上去了，但实际上P还没有被创建出来，导致获取的P为空。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// This can happen if procresize has grown
</span><span class="c1"></span>			<span class="c1">// allp but not yet created new Ps.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间
</span><span class="c1"></span>		<span class="nx">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">sysmontick</span>
		<span class="c1">// p 的状态
</span><span class="c1"></span>		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span>
		<span class="nx">sysretake</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="o">||</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
			<span class="c1">// 如果 G 运行时时间太长则进行抢占
</span><span class="c1"></span>			<span class="c1">// Preempt G if it&#39;s running for too long.
</span><span class="c1"></span>			<span class="c1">// 每发生一次调度，调度器 ++ 该值
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span>
			<span class="c1">//pd.schedtick == t 说明(pd.schedwhen ～ now)这段时间未发生过调度
</span><span class="c1"></span>			<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span> <span class="p">=</span> <span class="nx">now</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span><span class="o">+</span><span class="nx">forcePreemptNS</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="c1">//如果没超过10ms,则忽略
</span><span class="c1"></span>				<span class="c1">//forcepreemptNS，它是有” force preempt NS “组成，意思是强制抢占P的纳秒数，NS是单位，纳秒。它在retake函数外面定义，是一个常量。这一步是说距上次系统调用的时间间隔不足强制抢占P的时间间隔，就放弃抢占P。换句话说，当这个条件不满足时，说明这个P（准确的说是这个P当前运行的G）已经运行太长时间了，应该把它停止，并把运行机会让给其他G，以保证公平。
</span><span class="c1"></span>				<span class="c1">// 这段时间是同一个goroutine一直在运行，检查是否连续运行超过了 10 毫秒
</span><span class="c1"></span>				<span class="c1">// 连续运行超过 10 毫秒了，发起抢占请求
</span><span class="c1"></span>				<span class="c1">// 对于 syscall 的情况，因为 M 没有与 P 绑定，
</span><span class="c1"></span>				<span class="c1">// preemptone() 不工作
</span><span class="c1"></span>				<span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="c1">// In case of syscall, preemptone() doesn&#39;t
</span><span class="c1"></span>				<span class="c1">// work, because there is no M wired to P.
</span><span class="c1"></span>				<span class="nx">sysretake</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 对阻塞在系统调用上的 P 进行抢占
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
			<span class="c1">// Retake P from syscall if it&#39;s there for more than 1 sysmon tick (at least 20us).
</span><span class="c1"></span>			<span class="c1">//第一小步：判断当前P的系统调用计数和备份的系统调用计数是否相等。如果相等就继续后面的小步骤，如果不相等，要更新备份，并更新最近一次系统调用的时刻。
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span>
			<span class="c1">// _p_.syscalltick 用于记录系统调用的次数，在完成系统调用之后加 1
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">sysretake</span> <span class="o">&amp;&amp;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
				<span class="c1">// pd.syscalltick != _p_.syscalltick，说明已经不是上次观察到的系统调用了，
</span><span class="c1"></span>                <span class="c1">// 而是另外一次系统调用，所以需要重新记录 tick 和 when 值
</span><span class="c1"></span>				<span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span> <span class="p">=</span> <span class="nx">now</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">//这一步的目的很明显，就是要在某些条件下放弃对P的抢夺。要想放弃对P的抢夺，条件还是很严苛的，要同时满足三个条件：
</span><span class="c1"></span>            <span class="c1">//一是P的可运行G队列为空不抢，因为没活干的P抢过来也没用.
</span><span class="c1"></span>            <span class="c1">//二是有自旋的M或者有休息的P不抢，因为有自旋的M说明有M正在全力查找可运行的G，该P的可运行G队列一定会被全力查找可运行G的流程找到，就不用系统监测程序插手了
</span><span class="c1"></span>            <span class="c1">//三是距离上一次系统调用的时间不足10ms不抢
</span><span class="c1"></span>            <span class="c1">//这个条件中用到的上次系统调用时间正是备份中的syscallwhen字段，因为如果P的系统调用计数和备份中的不同步，说明在此次系统调用之前，已经有人捷足先登进行过系统调用了，那么最新的系统调用的时间也就必定不是备份中syscallwhen字段记录的时刻，这就会导致这里我们用备份中的syscallwhen字段来判断距离上次系统调用的时间间隔是否大于10ms是不准确的。
</span><span class="c1"></span>            <span class="c1">//所以在第一小步中一旦发现P的系统调用计数和备份中的不同步，就应该更新备份，并且忽略后面的步骤。
</span><span class="c1"></span>			<span class="c1">// On the one hand we don&#39;t want to retake Ps if there is no other work to do,
</span><span class="c1"></span>			<span class="c1">// but on the other hand we want to retake them eventually
</span><span class="c1"></span>			<span class="c1">// because they can prevent the sysmon thread from deep sleep.
</span><span class="c1"></span>			<span class="c1">//检查是否有其他任务需要P,是否超出时间限制,是否有必要抢夺P
</span><span class="c1"></span>			<span class="c1">// 一方面，在没有其他 work 的情况下，我们不希望抢夺 P
</span><span class="c1"></span>			<span class="c1">// 另一方面，因为它可能阻止 sysmon 线程从深度睡眠中唤醒，所以最终我们仍希望抢夺 P
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// Drop allpLock so we can take sched.lock.
</span><span class="c1"></span>			<span class="c1">// 解除 allpLock，从而可以获取 sched.lock
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
			<span class="c1">//抢夺P的过程就是将P转手。
</span><span class="c1"></span>			<span class="c1">//抢夺过程包裹在incidlelocked函数调用之间。然后要将P的状态转换为空闲状态（Pidle），并自增记录成功抢夺P次数的变量n以及P系统调用计数，最后通过handoffp函数转手这个P。
</span><span class="c1"></span>			<span class="c1">// 在 CAS 之前需要减少空闲 M 的数量（假装某个还在运行）
</span><span class="c1"></span>			<span class="c1">// 否则发生抢夺的 M 可能退出 syscall 然后再增加 nmidle ，进而发生死锁
</span><span class="c1"></span>			<span class="c1">// 这个过程发生在 stoplockedm 中
</span><span class="c1"></span>			<span class="c1">// Need to decrement number of idle locked M&#39;s
</span><span class="c1"></span>			<span class="c1">// (pretending that one more is running) before the CAS.
</span><span class="c1"></span>			<span class="c1">// Otherwise the M from which we retake can exit the syscall,
</span><span class="c1"></span>			<span class="c1">// increment nmidle and report deadlock.
</span><span class="c1"></span>			<span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">//抢夺P
</span><span class="c1"></span>			<span class="c1">// 将 P 设为 idle，从而交于其他 M 使用
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
					<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
					<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">n</span><span class="o">++</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
				<span class="c1">// 寻找一新的 m 接管 p
</span><span class="c1"></span>				<span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从代码来看，主要会对处于 _Psyscall 和_Prunning 状态的 p 进行抢占。</p>
<h3 id="抢占进行系统调用的-p">抢占进行系统调用的 P</h3>
<p>当 P 处于 _Psyscall 状态时，表明对应的 goroutine 正在进行系统调用。如果抢占 p，需要满足几个条件：</p>
<ol>
<li>p 的本地运行队列里面有等待运行的 goroutine。这时 p 绑定的 g 正在进行系统调用，无法去执行其他的 g，因此需要接管 p 来执行其他的 g。</li>
<li>没有“无所事事”的 p。sched.nmspinning 和 sched.npidle 都为 0，这就意味着没有“找工作”的 m，也没有空闲的 p，大家都在“忙”，可能有很多工作要做。因此要抢占当前的 p，让它来承担一部分工作。</li>
<li>从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒。这说明系统调用所花费的时间较长，需要对其进行抢占，以此来使得 retake 函数返回值不为 0，这样，会保持 sysmon 线程 20 us 的检查周期，提高 sysmon 监控的实时性。</li>
</ol>
<p>注意，原代码是用的三个与条件，三者都要满足才会执行下面的 continue，也就是不进行抢占。因此要想进行抢占的话，只需要三个条件有一个不满足就行了。于是就有了上述三种情况。</p>
<p>确定要抢占当前 p 后，先使用原子操作将 p 的状态修改为 _Pidle，最后调用 handoffp 进行抢占。</p>
<p>handoffp 再次进行场景判断，以调用 startm 启动一个工作线程来绑定 p，使得整体工作继续推进。</p>
<p>在抢占 P 的过程中，有两个非常小心的处理方式：</p>
<ol>
<li>如果此时队列为空，那么完全没有必要进行抢占，这时候似乎可以继续遍历其他的 P， 但必须在调度器中自旋的 M 和 空闲的 P 同时存在时、且系统调用阻塞时间非常长的情况下 才能这么做。否则，这个 retake 过程可能返回 0，进而系统监控可能看起来像是什么事情 也没做的情况下调整自己的步调进入深度睡眠。</li>
<li>在将 P 设置为空闲状态前，必须先将 M 的数量减少，否则当 M 退出系统调用时， 会在 exitsyscall0 中调用 stoplockedm 从而增加空闲 M 的数量，进而发生死锁。</li>
</ol>
<h3 id="抢占长时间运行的-p">抢占长时间运行的 P</h3>
<p>在检查 P 的状态时，P 如果是运行状态会调用 preemptone，来通过系统信号来完成抢占.之所以没有在之前提及的原因在于该调用 在 M 不与 P 绑定的情况下是不起任何作用直接返回的。这种异步抢占的本质是：抢占 M。</p>
<p>接下来我们就来分析当 P 处于 _Prunning 状态的情况。sysmon 扫描每个 p 时，都会记录下当前调度器调度的次数和当前时间，数据记录在结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">sysmontick</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">schedtick</span>   <span class="kt">uint32</span><span class="c1">//调度计数
</span><span class="c1"></span>	<span class="nx">schedwhen</span>   <span class="kt">int64</span><span class="c1">//调度时刻
</span><span class="c1"></span>	<span class="nx">syscalltick</span> <span class="kt">uint32</span><span class="c1">//系统调用计数
</span><span class="c1"></span>	<span class="nx">syscallwhen</span> <span class="kt">int64</span><span class="c1">//系统调用时刻
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>前面两个字段记录调度器调度的次数和时间，后面两个字段记录系统调用的次数和时间。</p>
<p>其实sysmontick结构中的syscalltick字段和syscallwhen字段在P结构体中也有，那么为什么这里还要重复存一份呢？目的就是为了备份，当发现sysmontick中的syscalltick值与P中的不一样是，就说明新的系统调用发生了，此时就可以更新syscallwhen字段为当前时间，记录下此次系统调用的时刻了。</p>
<p>在下一次扫描时，对比 sysmon 记录下的 p 的调度次数和时间，与当前 p 自己记录下的调度次数和时间对比，如果一致。说明 P 在这一段时间内一直在运行同一个 goroutine。那就来计算一下运行时间是否太长了。</p>
<p>如果发现运行时间超过了 10 ms，则要调用 preemptone(<em>p</em>) 发起抢占的请求</p>
<h4 id="协作抢占preemptone">协作抢占(preemptone)</h4>
<p>调用preemptone函数抢占该P，这也是go抢占式调度的体现。不过该函数只能告知在这个P上运行的G应该停止了。首先它不一定能正确的告知正确的G，其次即使告知被正确传递给了正确的G，这个G也可能忽略掉这个告知。也就是说preemptone函数只能告诉你我尽力而为，既不能保证告知正确到达，也不能保证那个G做出相应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tell the goroutine running on processor P to stop.
</span><span class="c1">// This function is purely best-effort. It can incorrectly fail to inform the
</span><span class="c1">// goroutine. It can send inform the wrong goroutine. Even if it informs the
</span><span class="c1">// correct goroutine, that goroutine might ignore the request if it is
</span><span class="c1">// simultaneously executing newstack.
</span><span class="c1">// No lock needs to be held.
</span><span class="c1">// Returns true if preemption request was issued.
</span><span class="c1">// The actual preemption will happen at some point in the future
</span><span class="c1">// and will be indicated by the gp-&gt;status no longer being
</span><span class="c1">// Grunning
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 检查 M 与 P 是否绑定
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">mp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 将 G 标记为抢占
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// Every call in a go routine checks for stack overflow by
</span><span class="c1"></span>	<span class="c1">// comparing the current stack pointer to gp-&gt;stackguard0.
</span><span class="c1"></span>	<span class="c1">// Setting gp-&gt;stackguard0 to StackPreempt folds
</span><span class="c1"></span>	<span class="c1">// preemption into the normal stack overflow check.
</span><span class="c1"></span>	<span class="c1">// 一个 Goroutine 中的每个调用都会通过比较当前栈指针和 gp.stackgard0
</span><span class="c1"></span>	<span class="c1">// 来检查栈是否溢出。
</span><span class="c1"></span>	<span class="c1">// 设置 gp.stackgard0 为 StackPreempt 来将抢占转换为正常的栈溢出检查。
</span><span class="c1"></span>	<span class="c1">// 在 goroutine 内部的每次调用都会比较栈顶指针和 g.stackguard0，
</span><span class="c1"></span>    <span class="c1">// 来判断是否发生了栈溢出。stackPreempt 非常大的一个数，比任何栈都大
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>

	<span class="c1">// Request an async preemption of this P.
</span><span class="c1"></span>	<span class="c1">// 请求该 P 的异步抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有两个标志,实际起作用的是G.stackguard0. G.preempt只是后备,以便在stackguard()做回溢出检查标志时,依然可用preempt恢复抢占状态.</p>
<p>当morestack调用newstack扩容时会检查抢占标志,并决定是否暂停当前任务,当然这发生在实际扩容之前.</p>
<p>go程序在执行G的每次调用时，都会通过比较当前堆栈指针和G的stackguard0字段来判断栈溢出。这里将当前G的stackguard0字段赋值为stackPreempt就会该G在下一次函数调用时栈空间检查失败，接下来就是一些列的函数调用，最终将这个G调度出去。</p>
<p>在讲述这一些列函数调用之前，我们先来认识一下stackPreempt。</p>
<p>它是在stack.go中定义的一个常量。在64位机器上，stackPreempt的值是0xfffffffffffffade，在32位机器上它的值是0xfffffade。表示的是栈指针sp的最大值，所以现在你知道为什么将stackguard0的值设置成它就能导致栈溢出了吧。它的计算出来需要用到uintptrMask，它是一个指针掩码，也就是一个所有位全为1的指针，32位机器上是0xffffffff，64位机器上是0xffffffffffffffff。在计算uintptrMask时用到的sys.PtrSize在sys包中的stubs.go文件中定义。^uintptr(0)得到的是一个各位都为1的值，32位机器上就是32个1,64位机器上就是64个1。左移63位后，如果是32位机器，结果就是0，接下来4右移0位还是4；64位机器结果是1，4右移1位后结果是8。所以PtrSize表示的就是一个指针长度的字节数。而一个字节的长度是8，所以在计算uintptrMask时用8乘以sys.PtrSize得到的就是一个指针的位数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="cm">/* stack.go */</span>
<span class="c1">// Goroutine 抢占请求
</span><span class="c1">// 存储到 g.stackguard0 来导致栈分段检查失败
</span><span class="c1">// 必须比任何实际的 SP 都要大
</span><span class="c1">// 十六进制为：0xfffffade
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
   <span class="nx">uintptrMask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">stackPreempt</span> <span class="p">=</span> <span class="nx">uintptrMask</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1314</span>
<span class="p">)</span>

<span class="cm">/* package sys */</span>
<span class="kd">const</span> <span class="nx">PtrSize</span> <span class="p">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>举一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>得到汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">size</span><span class="p">=</span><span class="mi">120</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x48</span>
    <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="err">$</span><span class="mi">72</span><span class="o">-</span><span class="mi">0</span>
    <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
    <span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JLS</span>    <span class="mi">113</span>
    <span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">SUBQ</span>    <span class="err">$</span><span class="mi">72</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">FUNCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">69</span><span class="nf">c1753bd5f81501d95132d08af04464</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">FUNCDATA</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="nf">e226d4ae4a7cad8835311c6a4683c14f</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0026</span> <span class="mo">0003</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x002f</span> <span class="mo">00047</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="kd">type</span><span class="p">.</span><span class="nb">string</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x0036</span> <span class="mo">00054</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x003b</span> <span class="mo">0005</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">statictmp_0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x0042</span> <span class="mo">00066</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">56</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0047</span> <span class="mo">00071</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">..</span><span class="nx">autotmp_0</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
    <span class="mh">0x004c</span> <span class="mo">00076</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0050</span> <span class="mo">000</span><span class="mi">80</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0059</span> <span class="mo">000</span><span class="mi">89</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
    <span class="mh">0x0062</span> <span class="mo">000</span><span class="mi">98</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span>
    <span class="mh">0x0062</span> <span class="mo">000</span><span class="mi">98</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x0067</span> <span class="mo">00103</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">MOVQ</span>    <span class="mi">64</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
    <span class="mh">0x006c</span> <span class="mo">0010</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">ADDQ</span>    <span class="err">$</span><span class="mi">72</span><span class="p">,</span> <span class="nx">SP</span>
    <span class="mh">0x0070</span> <span class="mo">00112</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">RET</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">NOP</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
    <span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="mh">0x0076</span> <span class="mo">0011</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JMP</span>    <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
</code></pre></td></tr></table>
</div>
</div><p>将本地存储 tls 保存到 CX 寄存器中，（TLS）表示它所关联的 g，这里就是前面所讲到的 main gouroutine。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>比较 SP 寄存器（代表当前 main goroutine 的栈顶寄存器）和 16(CX)，我们看下 g 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// goroutine 使用的栈
</span><span class="c1"></span>    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>    <span class="c1">// 用于栈的扩张和收缩检查
</span><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="c1">// ……………………
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对象 g 的第一个字段是 stack 结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lo</span> <span class="kt">uintptr</span>
    <span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>共 16 字节。而 16(CX) 表示 g 对象的第 16 个字节，跳过了 g 的第一个字段，也就是 g.stackguard0 字段。</p>
<p>如果 SP 小于 g.stackguard0，这是必然的，因为前面已经把 g.stackguard0 设置成了一个非常大的值，因此跳转到了 113 行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>    <span class="nx">NOP</span>
<span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">PCDATA</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
<span class="mh">0x0071</span> <span class="mo">00113</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="mh">0x0076</span> <span class="mo">0011</span><span class="mi">8</span> <span class="p">(</span><span class="nx">test26</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>    <span class="nx">JMP</span>    <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 runtime.morestack_noctxt 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/asm_amd64.s
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="nx">MOVL</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">DX</span>
	<span class="nx">JMP</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>直接跳转到 morestack 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
    <span class="c1">// Cannot grow scheduler stack (m-&gt;g0).
</span><span class="c1"></span>    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// BX = g，g 表示 main goroutine
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// BX = g.m
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// SI = g.m.g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">CMPQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">SI</span>
    <span class="nx">JNE</span>    <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackg0</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">INT</span>    <span class="err">$</span><span class="mi">3</span>

    <span class="c1">// ……………………
</span><span class="c1"></span>
    <span class="c1">// Set g-&gt;sched to context in f.
</span><span class="c1"></span>    <span class="c1">// 将函数的返回地址保存到 AX 寄存器
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span> <span class="c1">// f&#39;s PC
</span><span class="c1"></span>    <span class="c1">// 将函数的返回地址保存到 g.sched.pc
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// g.sched.g = g
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// 取地址操作符，调用 morestack_noctxt 之前的 rsp
</span><span class="c1"></span>    <span class="nx">LEAQ</span>    <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span> <span class="c1">// f&#39;s SP
</span><span class="c1"></span>    <span class="c1">// 将 main 函数的栈顶地址保存到 g.sched.sp
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// 将 BP 寄存器保存到 g.sched.bp
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">)</span>
    <span class="c1">// newstack will fill gobuf.ctxt.
</span><span class="c1"></span>
    <span class="c1">// Call newstack on m-&gt;g0&#39;s stack.
</span><span class="c1"></span>    <span class="c1">// BX = g.m.g0
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
    <span class="c1">// 将 g0 保存到本地存储 tls
</span><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
    <span class="c1">// 把 g0 栈的栈顶寄存器的值恢复到 CPU 的寄存器 SP，达到切换栈的目的，下面这一条指令执行之前，
</span><span class="c1"></span>    <span class="c1">// CPU 还是使用的调用此函数的 g 的栈，执行之后 CPU 就开始使用 g0 的栈了
</span><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>
    <span class="c1">// 准备参数
</span><span class="c1"></span>    <span class="nx">PUSHQ</span>    <span class="nx">DX</span>    <span class="c1">// ctxt argument
</span><span class="c1"></span>    <span class="c1">// 不返回
</span><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">runtime</span><span class="err">·</span><span class="nf">newstack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1003</span>    <span class="c1">// crash if newstack returns
</span><span class="c1"></span>    <span class="nx">POPQ</span>    <span class="nx">DX</span>    <span class="c1">// keep balance check happy
</span><span class="c1"></span>	<span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>主要做的工作就是将当前 goroutine，也就是 main goroutine 的和调度相关的信息保存到 g.sched 中，以便在调度到它执行时，可以恢复。</p>
<p>最后，将 g0 的地址保存到 tls 本地存储，并且切到 g0 栈执行之后的代码。继续调用 newstack 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// TODO: double check all gp. shouldn&#39;t be getg().
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackFork</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack growth after fork&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack called from g=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="o">+</span><span class="s">&#34;\tm=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34; m-&gt;curg=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">,</span> <span class="s">&#34; m-&gt;g0=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">,</span> <span class="s">&#34; m-&gt;gsignal=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
		<span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: wrong goroutine in newstack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>

	<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">{</span>
		<span class="c1">// Update syscallsp, syscallpc in case traceback uses them.
</span><span class="c1"></span>		<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span>
		<span class="nx">pcname</span><span class="p">,</span> <span class="nx">pcoff</span> <span class="o">:=</span> <span class="s">&#34;(unknown)&#34;</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">pcname</span> <span class="p">=</span> <span class="nf">funcname</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
			<span class="nx">pcoff</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="o">-</span> <span class="nx">f</span><span class="p">.</span><span class="nx">entry</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack at &#34;</span><span class="p">,</span> <span class="nx">pcname</span><span class="p">,</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">pcoff</span><span class="p">),</span>
			<span class="s">&#34; sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>

		<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// Include runtime frames
</span><span class="c1"></span>		<span class="nf">traceback</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">,</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: stack split at bad time&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">morebuf</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// NOTE: stackguard0 may change underfoot, if another thread
</span><span class="c1"></span>	<span class="c1">// is about to try to preempt gp. Read it just once and use that same
</span><span class="c1"></span>	<span class="c1">// value now and below.
</span><span class="c1"></span>	<span class="c1">// 如果是发起的抢占请求而非真正的栈分段
</span><span class="c1"></span>	<span class="nx">preempt</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span><span class="p">)</span> <span class="o">==</span> <span class="nx">stackPreempt</span>

	<span class="c1">// Be conservative about where we preempt.
</span><span class="c1"></span>	<span class="c1">// We are interested in preempting user Go code, not runtime code.
</span><span class="c1"></span>	<span class="c1">// If we&#39;re holding locks, mallocing, or preemption is disabled, don&#39;t
</span><span class="c1"></span>	<span class="c1">// preempt.
</span><span class="c1"></span>	<span class="c1">// This check is very early in newstack so that even the status change
</span><span class="c1"></span>	<span class="c1">// from Grunning to Gwaiting and back doesn&#39;t happen in this case.
</span><span class="c1"></span>	<span class="c1">// That status change by itself can be viewed as a small preemption,
</span><span class="c1"></span>	<span class="c1">// because the GC might change Gwaiting to Gscanwaiting, and then
</span><span class="c1"></span>	<span class="c1">// this goroutine has to wait for the GC to finish before continuing.
</span><span class="c1"></span>	<span class="c1">// If the GC is in some way dependent on this goroutine (for example,
</span><span class="c1"></span>	<span class="c1">// it needs a lock held by the goroutine), that small preemption turns
</span><span class="c1"></span>	<span class="c1">// into a real deadlock.
</span><span class="c1"></span>	<span class="c1">// 保守的对用户态代码进行抢占，而非抢占运行时代码
</span><span class="c1"></span>	<span class="c1">// 如果正持有锁、分配内存或抢占被禁用，则不发生抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Let the goroutine keep running for now.
</span><span class="c1"></span>			<span class="c1">// gp-&gt;preempt is set, so it will be preempted next time.
</span><span class="c1"></span>			<span class="c1">//stackguard0恢复溢出检查用途,下次用G.preempt恢复
</span><span class="c1"></span>			<span class="c1">// 还原 stackguard0 为正常值，表示我们已经处理过抢占请求了
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
			<span class="c1">// 不抢占，调用 gogo 继续运行当前这个 g，不需要调用 schedule 函数去挑选另一个 goroutine
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing stack in newstack&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">AMD64</span> <span class="o">||</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">I386</span> <span class="o">||</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">ArchFamily</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">WASM</span> <span class="p">{</span>
		<span class="c1">// The call to morestack cost a word.
</span><span class="c1"></span>		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: newstack sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tmorebuf={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">morebuf</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34;}\n&#34;</span><span class="p">,</span>
			<span class="s">&#34;\tsched={pc:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">),</span> <span class="s">&#34; sp:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; lr:&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span><span class="p">),</span> <span class="s">&#34; ctxt:&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">,</span> <span class="s">&#34;}\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sp</span> <span class="p">&lt;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;status=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n &#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow: &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; &lt; &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: split stack overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果需要对栈进行调整
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="c1">//垃圾回收本身也算一次抢占,忽略本次抢占调度
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: preempt g0&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: g is running but p is not&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">{</span>
			<span class="c1">// 我们正在一个同步安全点，因此等待栈收缩
</span><span class="c1"></span>			<span class="c1">// We&#39;re at a synchronous safe point now, so
</span><span class="c1"></span>			<span class="c1">// do the pending stack shrink.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
			<span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never returns
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 调用 gopreempt_m 把 gp 切换出去
</span><span class="c1"></span>		<span class="c1">// Act like goroutine called runtime.Gosched.
</span><span class="c1"></span>		<span class="c1">// 表现得像是调用了 runtime.Gosched，主动让权
</span><span class="c1"></span>		<span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Allocate a bigger segment and move the stack.
</span><span class="c1"></span>	<span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
	<span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">*</span> <span class="mi">2</span>

	<span class="c1">// Make sure we grow at least as much as needed to fit the new frame.
</span><span class="c1"></span>	<span class="c1">// (This is just an optimization - the caller of morestack will
</span><span class="c1"></span>	<span class="c1">// recheck the bounds on return.)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">f</span><span class="p">.</span><span class="nf">valid</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">max</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">funcMaxSPDelta</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
		<span class="k">for</span> <span class="nx">newsize</span><span class="o">-</span><span class="nx">oldsize</span> <span class="p">&lt;</span> <span class="nx">max</span><span class="o">+</span><span class="nx">_StackGuard</span> <span class="p">{</span>
			<span class="nx">newsize</span> <span class="o">*=</span> <span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">newsize</span> <span class="p">&gt;</span> <span class="nx">maxstacksize</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: goroutine stack exceeds &#34;</span><span class="p">,</span> <span class="nx">maxstacksize</span><span class="p">,</span> <span class="s">&#34;-byte limit\n&#34;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: sp=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">sp</span><span class="p">),</span> <span class="s">&#34; stack=[&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">),</span> <span class="s">&#34;]\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stack overflow&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// The goroutine must be executing in order to call newstack,
</span><span class="c1"></span>	<span class="c1">// so it must be Grunning (or Gscanrunning).
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">)</span>

	<span class="c1">// The concurrent GC will not scan the stack while we are doing the copy since
</span><span class="c1"></span>	<span class="c1">// the gp is in a Gcopystack status.
</span><span class="c1"></span>	<span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;stack grow done\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的 canPreemptM 验证了可以被抢占的条件：</p>
<ol>
<li>运行时没有禁止抢占（m.locks == 0）</li>
<li>运行时没有在执行内存分配（m.mallocing == 0）</li>
<li>运行时没有关闭抢占机制（m.preemptoff == &ldquo;&quot;）</li>
<li>M 与 P 绑定且没有进入系统调用（p.status == _Prunning）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// canPreemptM 报告 mp 是否处于可抢占的安全状态。
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">//如果M持有锁,或者正在进行内存分配,垃圾回收等操作,不抢占,留待下次
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Prunning</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第一次判断 preempt 标志是 true 时，检查了 g 的状态，发现不能抢占，例如它所绑定的 P 的状态不是 _Prunning，那就恢复它的 stackguard0 字段，下次就不会走这一套流程了。然后，调用 gogo(&amp;gp.sched) 继续执行当前的 goroutine。</p>
<p>中间又处理了很多判断流程，再次判断 preempt 标志是 true 时，调用 gopreempt_m(gp) 将 gp 切换出去。</p>
<p>gopreempt_m函数在proc.go中定义，它的参数是需要停止的G。它就干了一件事，调用goschedImpl函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoPreempt</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>goschedImpl函数也在proc.go文件中，参数是要停止的G。该函数首先把这个G从Grunning状态转到Grunnable状态。然后调用dropg函数解除这个G与当前M的关联。再把这个G放入调度器的可运行G队列，最后调用schedule函数进行一轮调度，为当前P找一个新的可运行G来运行。至此抢占结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="p">{</span>
		<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g status&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 更改 gp 的状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="c1">// 解除 m 和 g 的关系
</span><span class="c1"></span>	<span class="nf">dropg</span><span class="p">()</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 将 gp 放入全局可运行队列
</span><span class="c1"></span>	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 进入新一轮的调度循环
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将 gp 的状态改为 _Grunnable，放入全局可运行队列，等待下次有 m 来全局队列找工作时才能继续运行，毕竟你已经运行这么长时间了，给别人一点机会嘛。</p>
<p>最后，调用 schedule() 函数进入新一轮的调度循环，会找出一个 goroutine 来运行，永不返回。</p>
<p>从可被抢占的条件来看，能够对一个 G 进行抢占其实是呈保守状态的。 这一保守体现在抢占对很多运行时所需的条件进行了判断，这也理所当然是因为 运行时优先级更高，不应该轻易发生抢占， 但与此同时由于又需要对用户态代码进行抢占，于是先作出一次不需要抢占的判断（快速路径）， 确定不能抢占时返回并继续调度，如果真的需要进行抢占，则转入调用 gopreempt_m， 放弃当前 G 的执行权，将其加入全局队列，重新进入调度循环。</p>
<p>什么时候会会给 stackguard0 设置抢占标记 stackPreempt 呢？ 一共有以下几种情况：</p>
<ol>
<li>进入系统调用时（runtime.reentersyscall，注意这种情况是为了保证不会发生栈分裂， 真正的抢占是异步的通过系统监控进行的）</li>
<li>任何运行时不再持有锁的时候（m.locks == 0）</li>
<li>当垃圾回收器需要停止所有用户 Goroutine 时</li>
</ol>
<h4 id="异步抢占preemptm">异步抢占(preemptM)</h4>
<h5 id="抢占信号的选取">抢占信号的选取</h5>
<p>preemptM 完成了信号的发送，其实现也非常直接，直接向需要进行抢占的 M 发送 SIGURG 信号 即可。但是真正的重要的问题是，为什么是 SIGURG 信号而不是其他的信号？如何才能保证该信号 不与用户态产生的信号产生冲突？这里面有几个原因：</p>
<ol>
<li>默认情况下，SIGURG 已经用于调试器传递信号。</li>
<li>SIGRUURG 可以不加选择地虚假发生的信号。例如，我们不能选择 SIGALRM，因为 信号处理程序无法分辨它是否是由实际过程引起的（可以说这意味着信号已损坏）。 而常见的用户自定义信号 SIGUSR1 和 SIGUSR2 也不够好，因为用户态代码可能会将其进行使用</li>
<li>需要处理没有实时信号的平台（例如 macOS）</li>
</ol>
<p>考虑以上的观点，SIGURG 其实是一个很好的、满足所有这些条件、且极不可能因被用户态代码 进行使用的一种信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">sigPreempt</span> <span class="p">=</span> <span class="nx">_SIGURG</span>

<span class="c1">// preemptM 向 mp 发送抢占请求。该请求可以异步处理，也可以与对 M 的其他请求合并。
</span><span class="c1">// 接收到该请求后，如果正在运行的 G 或 P 被标记为抢占，并且 Goroutine 处于异步安全点，
</span><span class="c1">// 它将抢占 Goroutine。在处理抢占请求后，它始终以原子方式递增 mp.preemptGen。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">sigPreempt</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">,</span> <span class="nx">sig</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">tgkill</span><span class="p">(</span><span class="nf">getpid</span><span class="p">(),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">procid</span><span class="p">),</span> <span class="nx">sig</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="抢占调用的注入">抢占调用的注入</h5>
<p>Go 运行时进行信号处理的基本做法，其核心是注册 sighandler 函数，并在信号到达后， 由操作系统中断转入内核空间，而后将所中断线程的执行上下文参数（例如寄存器 rip, rep 等） 传递给处理函数。如果在 sighandler 中修改了这个上下文参数，操作系统则会根据修改后的 上下文信息恢复执行，这也就为抢占提供了机会。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sighandler</span><span class="p">(</span><span class="nx">sig</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">siginfo</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sigctxt</span><span class="p">{</span><span class="nx">info</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">sig</span> <span class="o">==</span> <span class="nx">sigPreempt</span> <span class="p">{</span>
		<span class="c1">// 可能是一个抢占信号
</span><span class="c1"></span>		<span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
		<span class="c1">// 即便这是一个抢占信号，它也可能与其他信号进行混合，因此我们
</span><span class="c1"></span>		<span class="c1">// 继续进行处理。
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// doSigPreempt handles a preemption signal on gp.
</span><span class="c1">// doSigPreempt 处理了 gp 上的抢占信号
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">doSigPreempt</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Check if this G wants to be preempted and is safe to
</span><span class="c1"></span>	<span class="c1">// preempt.
</span><span class="c1"></span>	<span class="c1">// 检查 G 是否需要被抢占、抢占是否安全
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">wantAsyncPreempt</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">newpc</span> <span class="o">:=</span> <span class="nf">isAsyncSafePoint</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigpc</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">sigsp</span><span class="p">(),</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">siglr</span><span class="p">());</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Adjust the PC and inject a call to asyncPreempt.
</span><span class="c1"></span>			<span class="c1">// 插入抢占调用
</span><span class="c1"></span>			<span class="nx">ctxt</span><span class="p">.</span><span class="nf">pushCall</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">asyncPreempt</span><span class="p">),</span> <span class="nx">newpc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Acknowledge the preemption.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">signalPending</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 记录抢占
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ctxt.pushCall 之前， ctxt.rip() 和 ctxt.rep() 都保存了被中断的 Goroutine 所在的位置， 但是 pushCall 直接修改了这些寄存器，进而当从 sighandler 返回用户态 Goroutine 时， 能够从注入的 asyncPreempt 开始执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sigctxt</span><span class="p">)</span> <span class="nf">pushCall</span><span class="p">(</span><span class="nx">targetPC</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rip</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">rsp</span><span class="p">())</span>
	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">pc</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rsp</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">set_rip</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">targetPC</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>完成 sighandler 之后，我们成功恢复到 asyncPreempt 调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// asyncPreempt 保存了所有用户寄存器，并调用 asyncPreempt2
</span><span class="c1">//
</span><span class="c1">// 当栈扫描遭遇 asyncPreempt 栈帧时，将会保守的扫描调用方栈帧
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数的主要目的是保存用户态寄存器，并且在调用完毕前恢复所有的寄存器上下文， 就好像什么事情都没有发生过一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> ·<span class="nf">asyncPreempt</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span><span class="n">NOSPLIT</span><span class="o">|</span><span class="n">NOFRAME</span><span class="p">,</span><span class="o">$</span><span class="m">0-0</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="kc">...</span>
	<span class="n">MOVUPS</span> <span class="n">X15</span><span class="p">,</span> <span class="m">352</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="n">CALL</span> ·<span class="nf">asyncPreempt2</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">MOVUPS</span> <span class="m">352</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">X15</span>
	<span class="kc">...</span>
	<span class="n">MOVQ</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
	<span class="kc">...</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>当调用 asyncPreempt2 时，会根据 preemptPark 或者 gopreempt_m 重新切换回 调度循环，从而打断密集循环的继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">preemptPark</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">gopreempt_m</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 异步抢占过程结束
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至此，异步抢占过程结束。我们总结一下抢占调用的整体逻辑：</p>
<ol>
<li>M1 发送中断信号（signalM(mp, sigPreempt)）</li>
<li>M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数（sighandler(signum, info, ctxt, gp)）</li>
<li>M2 修改执行的上下文，并恢复到修改后的位置（asyncPreempt）</li>
<li>重新进入调度循环进而调度其他 Goroutine（preemptPark 和 gopreempt_m）</li>
</ol>
<p>参考:</p>
<p><a href="https://blog.csdn.net/puss0/article/details/80627753#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">地鼠宝宝的秩事异闻之调度器</a><br>
<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">6.7 系统监控</a><br>
<a href="https://qcrao91.gitbook.io/go/goroutine-tiao-du-qi/sysmon-hou-tai-jian-kong-xian-cheng-zuo-le-shi-mo">sysmon 后台监控线程做了什么</a><br>
<a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/#heading">6.8 协作与抢占</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-12
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的网络轮询器源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/grpc%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">
            <span class="next-text nav-default">GRPC的负载均衡</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
