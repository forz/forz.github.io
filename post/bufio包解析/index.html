<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>bufio包解析 | Forz Blog</title>
<meta name="keywords" content="Go标准库" />
<meta name="description" content="Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) Variables 1 2 3 4 5 6 var ( ErrInvalidUnreadByte">
<meta name="author" content="">
<link rel="canonical" href="/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="bufio包解析" />
<meta property="og:description" content="Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) Variables 1 2 3 4 5 6 var ( ErrInvalidUnreadByte" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:12:08&#43;00:00" />
<meta property="article:modified_time" content="2018-11-15T18:12:08&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="bufio包解析"/>
<meta name="twitter:description" content="Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) Variables 1 2 3 4 5 6 var ( ErrInvalidUnreadByte"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "bufio包解析",
      "item": "/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "bufio包解析",
  "name": "bufio包解析",
  "description": "Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) Variables 1 2 3 4 5 6 var ( ErrInvalidUnreadByte",
  "keywords": [
    "Go标准库"
  ],
  "articleBody": "Constants 1 2 3 4  const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容  MaxScanTokenSize = 64 * 1024 )   Variables 1 2 3 4 5 6  var ( ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\") ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\") ErrBufferFull = errors.New(\"bufio: buffer full\") ErrNegativeCount = errors.New(\"bufio: negative count\") )   1 2 3 4 5  var ( ErrTooLong = errors.New(\"bufio.Scanner: token too long\") ErrNegativeAdvance = errors.New(\"bufio.Scanner: SplitFunc returns negative advance count\") ErrAdvanceTooFar = errors.New(\"bufio.Scanner: SplitFunc returns advance count beyond input\") )   会被Scanner类型返回的错误。\ntype Reader 1 2 3  type Reader struct { // 内含隐藏或非导出字段 }   Reader实现了给一个io.Reader接口对象附加缓冲。\nfunc NewReader 1  func NewReader(rd io.Reader) *Reader   NewReader创建一个具有默认大小缓冲、从r读取的*Reader。\nfunc NewReaderSize 1  func NewReaderSize(rd io.Reader, size int) *Reader   NewReaderSize创建一个具有最少有size尺寸的缓冲、从r读取的*Reader。如果参数r已经是一个具有足够大缓冲的* Reader类型值，会返回r。\nfunc (*Reader) Reset 1  func (b *Reader) Reset(r io.Reader)   Reset丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据。\nfunc (*Reader) Buffered 1  func (b *Reader) Buffered() int   Buffered返回缓冲中现有的可读取的字节数。\nfunc (*Reader) Peek 1  func (b *Reader) Peek(n int) ([]byte, error)   Peek返回输入流的下n个字节，而不会移动读取位置。返回的[]byte只在下一次调用读取操作前合法。如果Peek返回的切片长度比n小，它也会返会一个错误说明原因。如果n比缓冲尺寸还大，返回的错误将是ErrBufferFull。\nfunc (*Reader) Read 1  func (b *Reader) Read(p []byte) (n int, err error)   Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。\nfunc (*Reader) ReadByte 1  func (b *Reader) ReadByte() (c byte, err error)   ReadByte读取并返回一个字节。如果没有可用的数据，会返回错误。\nfunc (*Reader) UnreadByte 1  func (b *Reader) UnreadByte() error   UnreadByte吐出最近一次读取操作读取的最后一个字节。（只能吐出最后一个，多次调用会出问题）\nfunc (*Reader) ReadRune 1  func (b *Reader) ReadRune() (r rune, size int, err error)   ReadRune读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误。如果utf-8编码非法，读取位置只移动1字节，返回U+FFFD，返回值size为1而err为nil。如果没有可用的数据，会返回错误。\nfunc (*Reader) UnreadRune 1  func (b *Reader) UnreadRune() error   UnreadRune吐出最近一次ReadRune调用读取的unicode码值。如果最近一次读取不是调用的ReadRune，会返回错误。（从这点看，UnreadRune比UnreadByte严格很多）\nfunc (*Reader) ReadLine 1  func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)   ReadLine是一个低水平的行数据读取原语。大多数调用者应使用ReadBytes('\\n')或ReadString('\\n')代替，或者使用Scanner。\nReadLine尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值isPrefix会被设为true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值isPrefix会在返回该行最后一个片段时才设为false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine要么返回一个非nil的line，要么返回一个非nil的err，两个返回值至少一个非nil。\n返回的文本不包含行尾的标志字节（\"\\r\\n\"或\"\\n\"）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用ReadLine之后调用UnreadByte会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是ReadLine返回值的一部分。\nfunc (*Reader) ReadSlice 1  func (b *Reader) ReadSlice(delim byte) (line []byte, err error)   ReadSlice读取直到第一次遇到delim字节，返回缓冲里的包含已读取的数据和delim字节的切片。该返回值只在下一次读取操作之前合法。如果ReadSlice放在在读取到delim之前遇到了错误，它会返回在错误之前读取的数据在缓冲中的切片以及该错误（一般是io.EOF）。如果在读取到delim之前缓冲就被写满了，ReadSlice失败并返回ErrBufferFull。因为ReadSlice的返回值会被下一次I/O操作重写，调用者应尽量使用ReadBytes或ReadString替代本法功法。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。\nfunc (*Reader) ReadBytes 1  func (b *Reader) ReadBytes(delim byte) (line []byte, err error)   ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。\nfunc (*Reader) ReadString 1  func (b *Reader) ReadString(delim byte) (line string, err error)   ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。\nfunc (*Reader) WriteTo 1  func (b *Reader) WriteTo(w io.Writer) (n int64, err error)   WriteTo方法实现了io.WriterTo接口。\ntype Writer 1 2 3  type Writer struct { // 内含隐藏或非导出字段 }   Writer实现了为io.Writer接口对象提供缓冲。如果在向一个Writer类型值写入时遇到了错误，该对象将不再接受任何数据，且所有写操作都会返回该错误。在所有数据都写入后，调用者有义务调用Flush方法以保证所有的数据都交给了下层的io.Writer。\n1 2 3 4 5 6 7 8  w := bufio.NewWriter(os.Stdout) fmt.Fprint(w, \"Hello, \") fmt.Fprint(w, \"world!\") w.Flush() // Don't forget to flush!  Output: Hello, world!   func NewWriter 1  func NewWriter(w io.Writer) *Writer   NewWriter创建一个具有默认大小缓冲、写入w的*Writer。\nfunc NewWriterSize 1  func NewWriterSize(w io.Writer, size int) *Writer   NewWriterSize创建一个具有最少有size尺寸的缓冲、写入w的*Writer。如果参数w已经是一个具有足够大缓冲的*Writer类型值，会返回w。\nfunc (*Writer) Reset 1  func (b *Writer) Reset(w io.Writer)   Reset丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。\nfunc (*Writer) Buffered 1  func (b *Writer) Buffered() int   Buffered返回缓冲中已使用的字节数。\nfunc (*Writer) Available 1  func (b *Writer) Available() int   Available返回缓冲中还有多少字节未使用。\nfunc (*Writer) Write 1  func (b *Writer) Write(p []byte) (nn int, err error)   Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn func (*Writer) WriteString 1  func (b *Writer) WriteString(s string) (int, error)   WriteString写入一个字符串。返回写入的字节数。如果返回值nn func (*Writer) WriteByte 1  func (b *Writer) WriteByte(c byte) error   WriteByte写入单个字节。\nfunc (*Writer) WriteRune 1  func (b *Writer) WriteRune(r rune) (size int, err error)   WriteRune写入一个unicode码值（的utf-8编码），返回写入的字节数和可能的错误。\nfunc (*Writer) Flush 1  func (b *Writer) Flush() error   Flush方法将缓冲中的数据写入下层的io.Writer接口。\nfunc (*Writer) ReadFrom 1  func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)   ReadFrom实现了io.ReaderFrom接口。\ntype ReadWriter 1 2 3 4  type ReadWriter struct { *Reader *Writer }   ReadWriter类型保管了指向Reader和Writer类型的指针，（因此）实现了io.ReadWriter接口。\nfunc NewReadWriter 1  func NewReadWriter(r *Reader, w *Writer) *ReadWriter   NewReadWriter申请创建一个新的、将读写操作分派给r和w 的ReadWriter。\ntype SplitFunc 1  type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)   SplitFunc类型代表用于对输出作词法分析的分割函数。\n参数data是尚未处理的数据的一个开始部分的切片，参数atEOF表示是否Reader接口不能提供更多的数据。返回值是解析位置前进的字节数，将要返回给调用者的token切片，以及可能遇到的错误。如果数据不足以（保证）生成一个完整的token，例如需要一整行数据但data里没有换行符，SplitFunc可以返回(0, nil, nil)来告诉Scanner读取更多的数据写入切片然后用从同一位置起始、长度更长的切片再试一次（调用SplitFunc类型函数）。\n如果返回值err非nil，扫描将终止并将该错误返回给Scanner的调用者。\n除非atEOF为真，永远不会使用空切片data调用SplitFunc类型函数。然而，如果atEOF为真，data却可能是非空的、且包含着未处理的文本。\nfunc ScanBytes 1  func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)   ScanBytes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每个字节作为一个token返回。\nfunc ScanRunes 1  func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)   ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每个utf-8编码的unicode码值作为一个token返回。本函数返回的rune序列和range一个字符串的输出rune序列相同。错误的utf-8编码会翻译为U+FFFD = “\\xef\\xbf\\xbd”，但只会消耗一个字节。调用者无法区分正确编码的rune和错误编码的rune。\nfunc ScanWords 1  func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)   ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将空白（参见unicode.IsSpace）分隔的片段（去掉前后空白后）作为一个token返回。本函数永远不会返回空字符串。\nfunc ScanLines 1  func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)   ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每一行文本去掉末尾的换行标记作为一个token返回。返回的行可以是空字符串。换行标记为一个可选的回车后跟一个必选的换行符。最后一行即使没有换行符也会作为一个token返回。\ntype Scanner 1 2 3  type Scanner struct { // 内含隐藏或非导出字段 }   Scanner类型提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行。\n成功调用的Scan方法会逐步提供文件的token，跳过token之间的字节。token由SplitFunc类型的分割函数指定；默认的分割函数会将输入分割为多个行，并去掉行尾的换行标志。本包预定义的分割函数可以将文件分割为行、字节、unicode码值、空白分隔的word。调用者可以定制自己的分割函数。\n扫描会在抵达输入流结尾、遇到的第一个I/O错误、token过大不能保存进缓冲时，不可恢复的停止。当扫描停止后，当前读取位置可能会远在最后一个获得的token后面。需要更多对错误管理的控制或token很大，或必须从reader连续扫描的程序，应使用bufio.Reader代替。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  Example (Custom) // An artificial input source. const input = \"1234 5678 1234567901234567890\" scanner := bufio.NewScanner(strings.NewReader(input)) // Create a custom split function by wrapping the existing ScanWords function. split := func(data []byte, atEOF bool) (advance int, token []byte, err error) { advance, token, err = bufio.ScanWords(data, atEOF) if err == nil \u0026\u0026 token != nil { _, err = strconv.ParseInt(string(token), 10, 32) } return } // Set the split function for the scanning operation. scanner.Split(split) // Validate the input for scanner.Scan() { fmt.Printf(\"%s\\n\", scanner.Text()) } if err := scanner.Err(); err != nil { fmt.Printf(\"Invalid input: %s\", err) } Output: 1234 5678 Invalid input: strconv.ParseInt: parsing \"1234567901234567890\": value out of range   1 2 3 4 5 6 7 8 9  Example (Lines) scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) // Println will add back the final '\\n' } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading standard input:\", err) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Example (Words) // An artificial input source. const input = \"Now is the winter of our discontent,\\nMade glorious summer by this sun of York.\\n\" scanner := bufio.NewScanner(strings.NewReader(input)) // Set the split function for the scanning operation. scanner.Split(bufio.ScanWords) // Count the words. count := 0 for scanner.Scan() { count++ } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading input:\", err) } fmt.Printf(\"%d\\n\", count) Output: 15   func NewScanner 1  func NewScanner(r io.Reader) *Scanner   NewScanner创建并返回一个从r读取数据的Scanner，默认的分割函数是ScanLines。\nfunc (*Scanner) Split 1  func (s *Scanner) Split(split SplitFunc)   Split设置该Scanner的分割函数。本方法必须在Scan之前调用。\nfunc (*Scanner) Scan 1  func (s *Scanner) Scan() bool   Scan方法获取当前位置的token（该token可以通过Bytes或Text方法获得），并让Scanner的扫描位置移动到下一个token。当扫描因为抵达输入流结尾或者遇到错误而停止时，本方法会返回false。在Scan方法返回false后，Err方法将返回扫描时遇到的任何错误；除非是io.EOF，此时Err会返回nil。\nfunc (*Scanner) Bytes 1  func (s *Scanner) Bytes() []byte   Bytes方法返回最近一次Scan调用生成的token。底层数组指向的数据可能会被下一次Scan的调用重写。\nfunc (*Scanner) Text 1  func (s *Scanner) Text() string   Bytes方法返回最近一次Scan调用生成的token，会申请创建一个字符串保存token并返回该字符串。\nfunc (*Scanner) Err 1  func (s *Scanner) Err() error   Err返回Scanner遇到的第一个非EOF的错误。\n",
  "wordCount" : "4929",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-15T18:12:08Z",
  "dateModified": "2018-11-15T18:12:08Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/bufio%E5%8C%85%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      bufio包解析
    </h1>
    <div class="post-meta">November 15, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="constants">Constants<a hidden class="anchor" aria-hidden="true" href="#constants">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容
</span><span class="c1"></span>    <span class="nx">MaxScanTokenSize</span> <span class="p">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="variables">Variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrInvalidUnreadByte</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio: invalid use of UnreadByte&#34;</span><span class="p">)</span>
    <span class="nx">ErrInvalidUnreadRune</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio: invalid use of UnreadRune&#34;</span><span class="p">)</span>
    <span class="nx">ErrBufferFull</span>        <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio: buffer full&#34;</span><span class="p">)</span>
    <span class="nx">ErrNegativeCount</span>     <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio: negative count&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrTooLong</span>         <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio.Scanner: token too long&#34;</span><span class="p">)</span>
    <span class="nx">ErrNegativeAdvance</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio.Scanner: SplitFunc returns negative advance count&#34;</span><span class="p">)</span>
    <span class="nx">ErrAdvanceTooFar</span>   <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bufio.Scanner: SplitFunc returns advance count beyond input&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>会被Scanner类型返回的错误。</p>
<h1 id="type-reader">type Reader<a hidden class="anchor" aria-hidden="true" href="#type-reader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Reader实现了给一个io.Reader接口对象附加缓冲。</p>
<h2 id="func-newreader">func NewReader<a hidden class="anchor" aria-hidden="true" href="#func-newreader">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewReader</span><span class="p">(</span><span class="nx">rd</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">*</span><span class="nx">Reader</span>
</code></pre></td></tr></table>
</div>
</div><p>NewReader创建一个具有默认大小缓冲、从r读取的*Reader。</p>
<h2 id="func-newreadersize">func NewReaderSize<a hidden class="anchor" aria-hidden="true" href="#func-newreadersize">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewReaderSize</span><span class="p">(</span><span class="nx">rd</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Reader</span>
</code></pre></td></tr></table>
</div>
</div><p>NewReaderSize创建一个具有最少有size尺寸的缓冲、从r读取的*Reader。如果参数r已经是一个具有足够大缓冲的* Reader类型值，会返回r。</p>
<h2 id="func-reader-reset">func (*Reader) Reset<a hidden class="anchor" aria-hidden="true" href="#func-reader-reset">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据。</p>
<h2 id="func-reader-buffered">func (*Reader) Buffered<a hidden class="anchor" aria-hidden="true" href="#func-reader-buffered">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">Buffered</span><span class="p">()</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>Buffered返回缓冲中现有的可读取的字节数。</p>
<h2 id="func-reader-peek">func (*Reader) Peek<a hidden class="anchor" aria-hidden="true" href="#func-reader-peek">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">Peek</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Peek返回输入流的下n个字节，而不会移动读取位置。返回的[]byte只在下一次调用读取操作前合法。如果Peek返回的切片长度比n小，它也会返会一个错误说明原因。如果n比缓冲尺寸还大，返回的错误将是ErrBufferFull。</p>
<h2 id="func-reader-read">func (*Reader) Read<a hidden class="anchor" aria-hidden="true" href="#func-reader-read">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<h2 id="func-reader-readbyte">func (*Reader) ReadByte<a hidden class="anchor" aria-hidden="true" href="#func-reader-readbyte">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">ReadByte</span><span class="p">()</span> <span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadByte读取并返回一个字节。如果没有可用的数据，会返回错误。</p>
<h2 id="func-reader-unreadbyte">func (*Reader) UnreadByte<a hidden class="anchor" aria-hidden="true" href="#func-reader-unreadbyte">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">UnreadByte</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>UnreadByte吐出最近一次读取操作读取的最后一个字节。（只能吐出最后一个，多次调用会出问题）</p>
<h2 id="func-reader-readrune">func (*Reader) ReadRune<a hidden class="anchor" aria-hidden="true" href="#func-reader-readrune">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">ReadRune</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadRune读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误。如果utf-8编码非法，读取位置只移动1字节，返回U+FFFD，返回值size为1而err为nil。如果没有可用的数据，会返回错误。</p>
<h2 id="func-reader-unreadrune">func (*Reader) UnreadRune<a hidden class="anchor" aria-hidden="true" href="#func-reader-unreadrune">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">UnreadRune</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>UnreadRune吐出最近一次ReadRune调用读取的unicode码值。如果最近一次读取不是调用的ReadRune，会返回错误。（从这点看，UnreadRune比UnreadByte严格很多）</p>
<h2 id="func-reader-readline">func (*Reader) ReadLine<a hidden class="anchor" aria-hidden="true" href="#func-reader-readline">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">ReadLine</span><span class="p">()</span> <span class="p">(</span><span class="nx">line</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">isPrefix</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadLine是一个低水平的行数据读取原语。大多数调用者应使用ReadBytes('\n')或ReadString('\n')代替，或者使用Scanner。</p>
<p>ReadLine尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值isPrefix会被设为true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值isPrefix会在返回该行最后一个片段时才设为false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine要么返回一个非nil的line，要么返回一个非nil的err，两个返回值至少一个非nil。</p>
<p>返回的文本不包含行尾的标志字节（&quot;\r\n&quot;或&quot;\n&quot;）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用ReadLine之后调用UnreadByte会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是ReadLine返回值的一部分。</p>
<h2 id="func-reader-readslice">func (*Reader) ReadSlice<a hidden class="anchor" aria-hidden="true" href="#func-reader-readslice">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">ReadSlice</span><span class="p">(</span><span class="nx">delim</span> <span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">line</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadSlice读取直到第一次遇到delim字节，返回缓冲里的包含已读取的数据和delim字节的切片。该返回值只在下一次读取操作之前合法。如果ReadSlice放在在读取到delim之前遇到了错误，它会返回在错误之前读取的数据在缓冲中的切片以及该错误（一般是io.EOF）。如果在读取到delim之前缓冲就被写满了，ReadSlice失败并返回ErrBufferFull。因为ReadSlice的返回值会被下一次I/O操作重写，调用者应尽量使用ReadBytes或ReadString替代本法功法。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p>
<h2 id="func-reader-readbytes">func (*Reader) ReadBytes<a hidden class="anchor" aria-hidden="true" href="#func-reader-readbytes">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">ReadBytes</span><span class="p">(</span><span class="nx">delim</span> <span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">line</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p>
<h2 id="func-reader-readstring">func (*Reader) ReadString<a hidden class="anchor" aria-hidden="true" href="#func-reader-readstring">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">ReadString</span><span class="p">(</span><span class="nx">delim</span> <span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">line</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p>
<h2 id="func-reader-writeto">func (*Reader) WriteTo<a hidden class="anchor" aria-hidden="true" href="#func-reader-writeto">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">WriteTo</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteTo方法实现了io.WriterTo接口。</p>
<h1 id="type-writer">type Writer<a hidden class="anchor" aria-hidden="true" href="#type-writer">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Writer实现了为io.Writer接口对象提供缓冲。如果在向一个Writer类型值写入时遇到了错误，该对象将不再接受任何数据，且所有写操作都会返回该错误。在所有数据都写入后，调用者有义务调用Flush方法以保证所有的数据都交给了下层的io.Writer。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">w</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello, &#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;world!&#34;</span><span class="p">)</span>
<span class="nx">w</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span> <span class="c1">// Don&#39;t forget to flush!
</span><span class="c1"></span>

<span class="nx">Output</span><span class="p">:</span>
<span class="nx">Hello</span><span class="p">,</span> <span class="nx">world</span><span class="p">!</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newwriter">func NewWriter<a hidden class="anchor" aria-hidden="true" href="#func-newwriter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Writer</span>
</code></pre></td></tr></table>
</div>
</div><p>NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</p>
<h2 id="func-newwritersize">func NewWriterSize<a hidden class="anchor" aria-hidden="true" href="#func-newwritersize">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewWriterSize</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Writer</span>
</code></pre></td></tr></table>
</div>
</div><p>NewWriterSize创建一个具有最少有size尺寸的缓冲、写入w的*Writer。如果参数w已经是一个具有足够大缓冲的*Writer类型值，会返回w。</p>
<h2 id="func-writer-reset">func (*Writer) Reset<a hidden class="anchor" aria-hidden="true" href="#func-writer-reset">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。</p>
<h2 id="func-writer-buffered">func (*Writer) Buffered<a hidden class="anchor" aria-hidden="true" href="#func-writer-buffered">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">Buffered</span><span class="p">()</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>Buffered返回缓冲中已使用的字节数。</p>
<h2 id="func-writer-available">func (*Writer) Available<a hidden class="anchor" aria-hidden="true" href="#func-writer-available">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">Available</span><span class="p">()</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>Available返回缓冲中还有多少字节未使用。</p>
<h2 id="func-writer-write">func (*Writer) Write<a hidden class="anchor" aria-hidden="true" href="#func-writer-write">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">nn</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn &lt; len(p)，还会返回一个错误说明原因。</p>
<h2 id="func-writer-writestring">func (*Writer) WriteString<a hidden class="anchor" aria-hidden="true" href="#func-writer-writestring">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteString写入一个字符串。返回写入的字节数。如果返回值nn &lt; len(s)，还会返回一个错误说明原因。</p>
<h2 id="func-writer-writebyte">func (*Writer) WriteByte<a hidden class="anchor" aria-hidden="true" href="#func-writer-writebyte">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">WriteByte</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteByte写入单个字节。</p>
<h2 id="func-writer-writerune">func (*Writer) WriteRune<a hidden class="anchor" aria-hidden="true" href="#func-writer-writerune">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">WriteRune</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteRune写入一个unicode码值（的utf-8编码），返回写入的字节数和可能的错误。</p>
<h2 id="func-writer-flush">func (*Writer) Flush<a hidden class="anchor" aria-hidden="true" href="#func-writer-flush">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">Flush</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Flush方法将缓冲中的数据写入下层的io.Writer接口。</p>
<h2 id="func-writer-readfrom">func (*Writer) ReadFrom<a hidden class="anchor" aria-hidden="true" href="#func-writer-readfrom">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadFrom实现了io.ReaderFrom接口。</p>
<h1 id="type-readwriter">type ReadWriter<a hidden class="anchor" aria-hidden="true" href="#type-readwriter">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">Reader</span>
    <span class="o">*</span><span class="nx">Writer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadWriter类型保管了指向Reader和Writer类型的指针，（因此）实现了io.ReadWriter接口。</p>
<h2 id="func-newreadwriter">func NewReadWriter<a hidden class="anchor" aria-hidden="true" href="#func-newreadwriter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewReadWriter</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">w</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="o">*</span><span class="nx">ReadWriter</span>
</code></pre></td></tr></table>
</div>
</div><p>NewReadWriter申请创建一个新的、将读写操作分派给r和w 的ReadWriter。</p>
<h2 id="type-splitfunc">type SplitFunc<a hidden class="anchor" aria-hidden="true" href="#type-splitfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SplitFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">atEOF</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">advance</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">token</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>SplitFunc类型代表用于对输出作词法分析的分割函数。</p>
<p>参数data是尚未处理的数据的一个开始部分的切片，参数atEOF表示是否Reader接口不能提供更多的数据。返回值是解析位置前进的字节数，将要返回给调用者的token切片，以及可能遇到的错误。如果数据不足以（保证）生成一个完整的token，例如需要一整行数据但data里没有换行符，SplitFunc可以返回(0, nil, nil)来告诉Scanner读取更多的数据写入切片然后用从同一位置起始、长度更长的切片再试一次（调用SplitFunc类型函数）。</p>
<p>如果返回值err非nil，扫描将终止并将该错误返回给Scanner的调用者。</p>
<p>除非atEOF为真，永远不会使用空切片data调用SplitFunc类型函数。然而，如果atEOF为真，data却可能是非空的、且包含着未处理的文本。</p>
<h2 id="func-scanbytes">func ScanBytes<a hidden class="anchor" aria-hidden="true" href="#func-scanbytes">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ScanBytes</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">atEOF</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">advance</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">token</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ScanBytes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每个字节作为一个token返回。</p>
<h2 id="func-scanrunes">func ScanRunes<a hidden class="anchor" aria-hidden="true" href="#func-scanrunes">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ScanRunes</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">atEOF</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">advance</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">token</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每个utf-8编码的unicode码值作为一个token返回。本函数返回的rune序列和range一个字符串的输出rune序列相同。错误的utf-8编码会翻译为U+FFFD = &ldquo;\xef\xbf\xbd&rdquo;，但只会消耗一个字节。调用者无法区分正确编码的rune和错误编码的rune。</p>
<h2 id="func-scanwords">func ScanWords<a hidden class="anchor" aria-hidden="true" href="#func-scanwords">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ScanWords</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">atEOF</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">advance</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">token</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将空白（参见unicode.IsSpace）分隔的片段（去掉前后空白后）作为一个token返回。本函数永远不会返回空字符串。</p>
<h2 id="func-scanlines">func ScanLines<a hidden class="anchor" aria-hidden="true" href="#func-scanlines">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ScanLines</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">atEOF</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">advance</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">token</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>ScanRunes是用于Scanner类型的分割函数（符合SplitFunc），本函数会将每一行文本去掉末尾的换行标记作为一个token返回。返回的行可以是空字符串。换行标记为一个可选的回车后跟一个必选的换行符。最后一行即使没有换行符也会作为一个token返回。</p>
<h1 id="type-scanner">type Scanner<a hidden class="anchor" aria-hidden="true" href="#type-scanner">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Scanner</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Scanner类型提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行。</p>
<p>成功调用的Scan方法会逐步提供文件的token，跳过token之间的字节。token由SplitFunc类型的分割函数指定；默认的分割函数会将输入分割为多个行，并去掉行尾的换行标志。本包预定义的分割函数可以将文件分割为行、字节、unicode码值、空白分隔的word。调用者可以定制自己的分割函数。</p>
<p>扫描会在抵达输入流结尾、遇到的第一个I/O错误、token过大不能保存进缓冲时，不可恢复的停止。当扫描停止后，当前读取位置可能会远在最后一个获得的token后面。需要更多对错误管理的控制或token很大，或必须从reader连续扫描的程序，应使用bufio.Reader代替。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Example</span> <span class="p">(</span><span class="nx">Custom</span><span class="p">)</span>
<span class="c1">// An artificial input source.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">input</span> <span class="p">=</span> <span class="s">&#34;1234 5678 1234567901234567890&#34;</span>
<span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">input</span><span class="p">))</span>
<span class="c1">// Create a custom split function by wrapping the existing ScanWords function.
</span><span class="c1"></span><span class="nx">split</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">atEOF</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">advance</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">token</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">advance</span><span class="p">,</span> <span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">ScanWords</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">atEOF</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">token</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">token</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="c1">// Set the split function for the scanning operation.
</span><span class="c1"></span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">split</span><span class="p">)</span>
<span class="c1">// Validate the input
</span><span class="c1"></span><span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Invalid input: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>


<span class="nx">Output</span><span class="p">:</span>
<span class="mi">1234</span>
<span class="mi">5678</span>
<span class="nx">Invalid</span> <span class="nx">input</span><span class="p">:</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">:</span> <span class="nx">parsing</span> <span class="s">&#34;1234567901234567890&#34;</span><span class="p">:</span> <span class="nx">value</span> <span class="nx">out</span> <span class="nx">of</span> <span class="k">range</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Example</span> <span class="p">(</span><span class="nx">Lines</span><span class="p">)</span>

<span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span> <span class="c1">// Println will add back the final &#39;\n&#39;
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;reading standard input:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Example</span> <span class="p">(</span><span class="nx">Words</span><span class="p">)</span>

<span class="c1">// An artificial input source.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">input</span> <span class="p">=</span> <span class="s">&#34;Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n&#34;</span>
<span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">input</span><span class="p">))</span>
<span class="c1">// Set the split function for the scanning operation.
</span><span class="c1"></span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">ScanWords</span><span class="p">)</span>
<span class="c1">// Count the words.
</span><span class="c1"></span><span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">count</span><span class="o">++</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;reading input:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
<span class="nx">Output</span><span class="p">:</span>

<span class="mi">15</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-newscanner">func NewScanner<a hidden class="anchor" aria-hidden="true" href="#func-newscanner">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewScanner</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">*</span><span class="nx">Scanner</span>
</code></pre></td></tr></table>
</div>
</div><p>NewScanner创建并返回一个从r读取数据的Scanner，默认的分割函数是ScanLines。</p>
<h2 id="func-scanner-split">func (*Scanner) Split<a hidden class="anchor" aria-hidden="true" href="#func-scanner-split">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Scanner</span><span class="p">)</span> <span class="nf">Split</span><span class="p">(</span><span class="nx">split</span> <span class="nx">SplitFunc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Split设置该Scanner的分割函数。本方法必须在Scan之前调用。</p>
<h2 id="func-scanner-scan">func (*Scanner) Scan<a hidden class="anchor" aria-hidden="true" href="#func-scanner-scan">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Scanner</span><span class="p">)</span> <span class="nf">Scan</span><span class="p">()</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Scan方法获取当前位置的token（该token可以通过Bytes或Text方法获得），并让Scanner的扫描位置移动到下一个token。当扫描因为抵达输入流结尾或者遇到错误而停止时，本方法会返回false。在Scan方法返回false后，Err方法将返回扫描时遇到的任何错误；除非是io.EOF，此时Err会返回nil。</p>
<h2 id="func-scanner-bytes">func (*Scanner) Bytes<a hidden class="anchor" aria-hidden="true" href="#func-scanner-bytes">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Scanner</span><span class="p">)</span> <span class="nf">Bytes</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span>
</code></pre></td></tr></table>
</div>
</div><p>Bytes方法返回最近一次Scan调用生成的token。底层数组指向的数据可能会被下一次Scan的调用重写。</p>
<h2 id="func-scanner-text">func (*Scanner) Text<a hidden class="anchor" aria-hidden="true" href="#func-scanner-text">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Scanner</span><span class="p">)</span> <span class="nf">Text</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>Bytes方法返回最近一次Scan调用生成的token，会申请创建一个字符串保存token并返回该字符串。</p>
<h2 id="func-scanner-err">func (*Scanner) Err<a hidden class="anchor" aria-hidden="true" href="#func-scanner-err">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Scanner</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Err返回Scanner遇到的第一个非EOF的错误。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
