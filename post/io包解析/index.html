<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>io包解析 | Forz Blog</title>
<meta name="keywords" content="Go标准库" />
<meta name="description" content="Variables var EOF = errors.New(&quot;EOF&quot;) EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EO">
<meta name="author" content="">
<link rel="canonical" href="/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="io包解析" />
<meta property="og:description" content="Variables var EOF = errors.New(&quot;EOF&quot;) EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EO" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:32:33&#43;00:00" />
<meta property="article:modified_time" content="2018-11-15T18:32:33&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="io包解析"/>
<meta name="twitter:description" content="Variables var EOF = errors.New(&quot;EOF&quot;) EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EO"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "io包解析",
      "item": "/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "io包解析",
  "name": "io包解析",
  "description": "Variables var EOF = errors.New(\u0026quot;EOF\u0026quot;) EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EO",
  "keywords": [
    "Go标准库"
  ],
  "articleBody": "Variables var EOF = errors.New(\"EOF\")  EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EOF在不期望的位置出现了，则应返回错误ErrUnexpectedEOF或者其它给出更多细节的错误。\nvar ErrClosedPipe = errors.New(\"io: read/write on closed pipe\")  当从一个已关闭的Pipe读取或者写入时，会返回ErrClosedPipe。\nvar ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")  某些使用io.Reader接口的客户端如果多次调用Read都不返回数据也不返回错误时，就会返回本错误，一般来说是io.Reader的实现有问题的标志。\nvar ErrShortBuffer = errors.New(\"short buffer\")  ErrShortBuffer表示读取操作需要大缓冲，但提供的缓冲不够大。\nvar ErrShortWrite = errors.New(\"short write\")  ErrShortWrite表示写入操作写入的数据比提供的少，却没有显式的返回错误。\nvar ErrUnexpectedEOF = errors.New(\"unexpected EOF\")  ErrUnexpectedEOF表示在读取一个固定尺寸的块或者数据结构时，在读取未完全时遇到了EOF。\ntype Reader 1 2 3  type Reader interface { Read(p []byte) (n int, err error) }   Reader接口用于包装基本的读取方法。\nRead方法读取len(p)字节数据写入p。它返回写入的字节数和遇到的任何错误。即使Read方法返回值n 当Read在读取n  0个字节后遭遇错误或者到达文件结尾时，会返回读取的字节数。它可能会在该次调用返回一个非nil的错误，或者在下一次调用时返回0和该错误。一个常见的例子，Reader接口会在输入流的结尾返回非0的字节数，返回值err == EOF或err == nil。但不管怎样，下一次Read调用必然返回(0, EOF)。调用者应该总是先处理读取的n  0字节再处理错误值。这么做可以正确的处理发生在读取部分数据后的I/O错误，也能正确处理EOF事件。\n如果Read的某个实现返回0字节数和nil错误值，表示被阻碍；调用者应该将这种情况视为未进行操作。\ntype Writer 1 2 3  type Writer interface { Write(p []byte) (n int, err error) }   Writer接口用于包装基本的写入方法。\nWrite方法len(p) 字节数据从p写入底层的数据流。它会返回写入的字节数(0 type Closer 1 2 3  type Closer interface { Close() error }   Closer接口用于包装基本的关闭方法。\n在第一次调用之后再次被调用时，Close方法的的行为是未定义的。某些实现可能会说明他们自己的行为。\ntype Seeker 1 2 3  type Seeker interface { Seek(offset int64, whence int) (int64, error) }   Seeker接口用于包装基本的移位方法。\nSeek方法设定下一次读写的位置：偏移量为offset，校准点由whence确定：0表示相对于文件起始；1表示相对于当前位置；2表示相对于文件结尾。Seek方法返回新的位置以及可能遇到的错误。\n移动到一个绝对偏移量为负数的位置会导致错误。移动到任何偏移量为正数的位置都是合法的，但其下一次I/O操作的具体行为则要看底层的实现。\ntype ReadCloser 1 2 3 4  type ReadCloser interface { Reader Closer }   ReadCloser接口聚合了基本的读取和关闭操作。\ntype ReadSeeker 1 2 3 4  type ReadSeeker interface { Reader Seeker }   ReadSeeker接口聚合了基本的读取和移位操作。\ntype WriteCloser 1 2 3 4  type WriteCloser interface { Writer Closer }   WriteCloser接口聚合了基本的写入和关闭操作。\ntype WriteSeeker 1 2 3 4  type WriteSeeker interface { Writer Seeker }   WriteSeeker接口聚合了基本的写入和移位操作。\ntype ReadWriter 1 2 3 4  type ReadWriter interface { Reader Writer }   ReadWriter接口聚合了基本的读写操作。\ntype ReadWriteCloser 1 2 3 4 5  type ReadWriteCloser interface { Reader Writer Closer }   ReadWriteCloser接口聚合了基本的读写和关闭操作。\ntype ReadWriteSeeker 1 2 3 4 5  type ReadWriteSeeker interface { Reader Writer Seeker }   ReadWriteSeeker接口聚合了基本的读写和移位操作。\ntype ReaderAt 1 2 3  type ReaderAt interface { ReadAt(p []byte, off int64) (n int, err error) }   ReaderAt接口包装了基本的ReadAt方法。\nReadAt从底层输入流的偏移量off位置读取len(p)字节数据写入p， 它返回读取的字节数(0 如果ReadAt是从某个有偏移量的底层输入流（的Reader包装）读取，ReadAt方法既不应影响底层的偏移量，也不应被底层的偏移量影响。\nReadAt方法的调用者可以对同一输入流执行并行的ReadAt调用。\ntype WriterAt 1 2 3  type WriterAt interface { WriteAt(p []byte, off int64) (n int, err error) }   WriterAt接口包装了基本的WriteAt方法。\nWriteAt将p全部len(p)字节数据写入底层数据流的偏移量off位置。它返回写入的字节数(0 如果WriteAt写入的对象是某个有偏移量的底层输出流（的Writer包装），WriteAt方法既不应影响底层的偏移量，也不应被底层的偏移量影响。\nReadAt方法的调用者可以对同一输入流执行并行的WriteAt调用。（前提是写入范围不重叠）\ntype ByteReader 1 2 3  type ByteReader interface { ReadByte() (c byte, err error) }   ByteReader是基本的ReadByte方法的包装。\nReadByte读取输入中的单个字节并返回。如果没有字节可读取，会返回错误。\ntype ByteScanner 1 2 3 4  type ByteScanner interface { ByteReader UnreadByte() error }   ByteScanner接口在基本的ReadByte方法之外还添加了UnreadByte方法。\nUnreadByte方法让下一次调用ReadByte时返回之前调用ReadByte时返回的同一个字节。连续调用两次UnreadByte方法而中间没有调用ReadByte时，可能会导致错误。\ntype RuneReader 1 2 3  type RuneReader interface { ReadRune() (r rune, size int, err error) }   RuneReader是基本的ReadRune方法的包装。\nReadRune读取单个utf-8编码的字符，返回该字符和它的字节长度。如果没有有效的字符，会返回错误。\ntype RuneScanner 1 2 3 4  type RuneScanner interface { RuneReader UnreadRune() error }   RuneScanner接口在基本的ReadRune方法之外还添加了UnreadRune方法。\nUnreadRune方法让下一次调用ReadRune时返回之前调用ReadRune时返回的同一个utf-8字符。连续调用两次UnreadRune方法而中间没有调用ReadRune时，可能会导致错误。\ntype ByteWriter 1 2 3  type ByteWriter interface { WriteByte(c byte) error }   ByteWriter是基本的WriteByte方法的包装。\ntype ReaderFrom 1 2 3  type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) }   ReaderFrom接口包装了基本的ReadFrom方法。\nReadFrom方法从r读取数据直到EOF或者遇到错误。返回值n是读取的字节数，执行时遇到的错误（EOF除外）也会被返回。\ntype WriterTo 1 2 3  type WriterTo interface { WriteTo(w Writer) (n int64, err error) }   WriterTo接口包装了基本的WriteTo方法。\nWriteTo方法将数据写入w直到没有数据可以写入或者遇到错误。返回值n是写入的字节数，执行时遇到的任何错误也会被返回。\ntype LimitedReader 1 2 3 4  type LimitedReader struct { R Reader // 底层Reader接口  N int64 // 剩余可读取字节数 }   LimitedReader从R中读取数据，但限制可以读取的数据的量为最多N字节，每次调用Read方法都会更新N以标记剩余可以读取的字节数。\nfunc LimitReader func LimitReader(r Reader, n int64) Reader  返回一个Reader，它从r中读取n个字节后以EOF停止。返回值接口的底层为*LimitedReader类型。\nfunc (*LimitedReader) Read func (l *LimitedReader) Read(p []byte) (n int, err error)  type SectionReader 1 2 3  type SectionReader struct { // 内含隐藏或非导出字段 }   SectionReader实现了对底层满足ReadAt接口的输入流某个片段的Read、ReadAt、Seek方法。\nfunc NewSectionReader func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader  返回一个从r中的偏移量off处为起始，读取n个字节后以EOF停止的SectionReader。\nfunc (*SectionReader) Size func (s *SectionReader) Size() int64  Size返回该片段的字节数。\nfunc (*SectionReader) Read func (s *SectionReader) Read(p []byte) (n int, err error)  func (*SectionReader) ReadAt func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)  ##func (*SectionReader) Seek\nfunc (s *SectionReader) Seek(offset int64, whence int) (int64, error)  type PipeReader 1 2 3  type PipeReader struct { // 内含隐藏或非导出字段 }   PipeReader是一个管道的读取端。\nfunc Pipe func Pipe() (*PipeReader, *PipeWriter)  Pipe创建一个同步的内存中的管道。它可以用于连接期望io.Reader的代码和期望io.Writer的代码。一端的读取对应另一端的写入，直接在两端拷贝数据，没有内部缓冲。可以安全的并行调用Read和Write或者Read/Write与Close方法。Close方法会在最后一次阻塞中的I/O操作结束后完成。并行调用Read或并行调用Write也是安全的：每一个独立的调用会依次进行。\nfunc (*PipeReader) Read func (r *PipeReader) Read(data []byte) (n int, err error)  Read实现了标准Reader接口：它从管道中读取数据，会阻塞直到写入端开始写入或写入端被关闭。\nfunc (*PipeReader) Close func (r *PipeReader) Close() error  Close关闭读取器；关闭后如果对管道的写入端进行写入操作，就会返回(0, ErrClosedPip)。\nfunc (*PipeReader) CloseWithError func (r *PipeReader) CloseWithError(err error) error  CloseWithError类似Close方法，但将调用Write时返回的错误改为err。\ntype PipeWriter 1 2 3  type PipeWriter struct { // 内含隐藏或非导出字段 }   PipeWriter是一个管道的写入端。\nfunc (*PipeWriter) Write func (w *PipeWriter) Write(data []byte) (n int, err error)  Write实现了标准Writer接口：它将数据写入到管道中，会阻塞直到读取器读完所有的数据或读取端被关闭。\nfunc (*PipeWriter) Close func (w *PipeWriter) Close() error  Close关闭写入器；关闭后如果对管道的读取端进行读取操作，就会返回(0, EOF)。\nfunc (*PipeWriter) CloseWithError func (w *PipeWriter) CloseWithError(err error) error  CloseWithError类似Close方法，但将调用Read时返回的错误改为err。\nfunc TeeReader func TeeReader(r Reader, w Writer) Reader  TeeReader返回一个将其从r读取的数据写入w的Reader接口。所有通过该接口对r的读取都会执行对应的对w的写入。没有内部的缓冲：写入必须在读取完成前完成。写入时遇到的任何错误都会作为读取错误返回。\nfunc MultiReader func MultiReader(readers ...Reader) Reader  MultiReader返回一个将提供的Reader在逻辑上串联起来的Reader接口。他们依次被读取。当所有的输入流都读取完毕，Read才会返回EOF。如果readers中任一个返回了非nil非EOF的错误，Read方法会返回该错误。\nfunc MultiWriter func MultiWriter(writers ...Writer) Writer  MultiWriter创建一个Writer接口，会将提供给其的数据写入所有创建时提供的Writer接口。\nfunc Copy func Copy(dst Writer, src Reader) (written int64, err error)  将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。\n对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。\nfunc CopyN func CopyN(dst Writer, src Reader, n int64) (written int64, err error)  从src拷贝n个字节数据到dst，直到在src上到达EOF或发生错误。返回复制的字节数和遇到的第一个错误。\n只有err为nil时，written才会等于n。如果dst实现了ReaderFrom接口，本函数很调用它实现拷贝。\nfunc ReadAtLeast func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)  ReadAtLeast从r至少读取min字节数据填充进buf。函数返回写入的字节数和错误（如果没有读取足够的字节）。只有没有读取到字节时才可能返回EOF；如果读取了有但不够的字节时遇到了EOF，函数会返回ErrUnexpectedEOF。 如果min比buf的长度还大，函数会返回ErrShortBuffer。只有返回值err为nil时，返回值n才会不小于min。\nfunc ReadFull func ReadFull(r Reader, buf []byte) (n int, err error)  ReadFull从r精确地读取len(buf)字节数据填充进buf。函数返回写入的字节数和错误（如果没有读取足够的字节）。只有没有读取到字节时才可能返回EOF；如果读取了有但不够的字节时遇到了EOF，函数会返回ErrUnexpectedEOF。 只有返回值err为nil时，返回值n才会等于len(buf)。\nfunc WriteString func WriteString(w Writer, s string) (n int, err error)  WriteString函数将字符串s的内容写入w中。如果w已经实现了WriteString方法，函数会直接调用该方法。\n",
  "wordCount" : "5099",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-15T18:32:33Z",
  "dateModified": "2018-11-15T18:32:33Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/io%E5%8C%85%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      io包解析
    </h1>
    <div class="post-meta">November 15, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="variables">Variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h1>
<pre><code>var EOF = errors.New(&quot;EOF&quot;)
</code></pre>
<p>EOF当无法得到更多输入时，Read方法返回EOF。当函数一切正常的到达输入的结束时，就应返回EOF。如果在一个结构化数据流中EOF在不期望的位置出现了，则应返回错误ErrUnexpectedEOF或者其它给出更多细节的错误。</p>
<pre><code>var ErrClosedPipe = errors.New(&quot;io: read/write on closed pipe&quot;)
</code></pre>
<p>当从一个已关闭的Pipe读取或者写入时，会返回ErrClosedPipe。</p>
<pre><code>var ErrNoProgress = errors.New(&quot;multiple Read calls return no data or error&quot;)
</code></pre>
<p>某些使用io.Reader接口的客户端如果多次调用Read都不返回数据也不返回错误时，就会返回本错误，一般来说是io.Reader的实现有问题的标志。</p>
<pre><code>var ErrShortBuffer = errors.New(&quot;short buffer&quot;)
</code></pre>
<p>ErrShortBuffer表示读取操作需要大缓冲，但提供的缓冲不够大。</p>
<pre><code>var ErrShortWrite = errors.New(&quot;short write&quot;)
</code></pre>
<p>ErrShortWrite表示写入操作写入的数据比提供的少，却没有显式的返回错误。</p>
<pre><code>var ErrUnexpectedEOF = errors.New(&quot;unexpected EOF&quot;)
</code></pre>
<p>ErrUnexpectedEOF表示在读取一个固定尺寸的块或者数据结构时，在读取未完全时遇到了EOF。</p>
<h1 id="type-reader">type Reader<a hidden class="anchor" aria-hidden="true" href="#type-reader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Reader接口用于包装基本的读取方法。</p>
<p>Read方法读取len(p)字节数据写入p。它返回写入的字节数和遇到的任何错误。即使Read方法返回值n &lt; len(p)，本方法在被调用时仍可能使用p的全部长度作为暂存空间。如果有部分可用数据，但不够len(p)字节，Read按惯例会返回可以读取到的数据，而不是等待更多数据。</p>
<p>当Read在读取n &gt; 0个字节后遭遇错误或者到达文件结尾时，会返回读取的字节数。它可能会在该次调用返回一个非nil的错误，或者在下一次调用时返回0和该错误。一个常见的例子，Reader接口会在输入流的结尾返回非0的字节数，返回值err == EOF或err == nil。但不管怎样，下一次Read调用必然返回(0, EOF)。调用者应该总是先处理读取的n &gt; 0字节再处理错误值。这么做可以正确的处理发生在读取部分数据后的I/O错误，也能正确处理EOF事件。</p>
<p>如果Read的某个实现返回0字节数和nil错误值，表示被阻碍；调用者应该将这种情况视为未进行操作。</p>
<h1 id="type-writer">type Writer<a hidden class="anchor" aria-hidden="true" href="#type-writer">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Writer接口用于包装基本的写入方法。</p>
<p>Write方法len(p) 字节数据从p写入底层的数据流。它会返回写入的字节数(0 &lt;= n &lt;= len(p))和遇到的任何导致写入提取结束的错误。Write必须返回非nil的错误，如果它返回的 n &lt; len(p)。Write不能修改切片p中的数据，即使临时修改也不行。</p>
<h1 id="type-closer">type Closer<a hidden class="anchor" aria-hidden="true" href="#type-closer">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Closer接口用于包装基本的关闭方法。</p>
<p>在第一次调用之后再次被调用时，Close方法的的行为是未定义的。某些实现可能会说明他们自己的行为。</p>
<h1 id="type-seeker">type Seeker<a hidden class="anchor" aria-hidden="true" href="#type-seeker">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Seeker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Seek</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">whence</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Seeker接口用于包装基本的移位方法。</p>
<p>Seek方法设定下一次读写的位置：偏移量为offset，校准点由whence确定：0表示相对于文件起始；1表示相对于当前位置；2表示相对于文件结尾。Seek方法返回新的位置以及可能遇到的错误。</p>
<p>移动到一个绝对偏移量为负数的位置会导致错误。移动到任何偏移量为正数的位置都是合法的，但其下一次I/O操作的具体行为则要看底层的实现。</p>
<h1 id="type-readcloser">type ReadCloser<a hidden class="anchor" aria-hidden="true" href="#type-readcloser">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadCloser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Closer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadCloser接口聚合了基本的读取和关闭操作。</p>
<h1 id="type-readseeker">type ReadSeeker<a hidden class="anchor" aria-hidden="true" href="#type-readseeker">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadSeeker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Seeker</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadSeeker接口聚合了基本的读取和移位操作。</p>
<h1 id="type-writecloser">type WriteCloser<a hidden class="anchor" aria-hidden="true" href="#type-writecloser">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Writer</span>
    <span class="nx">Closer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteCloser接口聚合了基本的写入和关闭操作。</p>
<h1 id="type-writeseeker">type WriteSeeker<a hidden class="anchor" aria-hidden="true" href="#type-writeseeker">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WriteSeeker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Writer</span>
    <span class="nx">Seeker</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>WriteSeeker接口聚合了基本的写入和移位操作。</p>
<h1 id="type-readwriter">type ReadWriter<a hidden class="anchor" aria-hidden="true" href="#type-readwriter">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadWriter接口聚合了基本的读写操作。</p>
<h1 id="type-readwritecloser">type ReadWriteCloser<a hidden class="anchor" aria-hidden="true" href="#type-readwritecloser">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadWriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
    <span class="nx">Closer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadWriteCloser接口聚合了基本的读写和关闭操作。</p>
<h1 id="type-readwriteseeker">type ReadWriteSeeker<a hidden class="anchor" aria-hidden="true" href="#type-readwriteseeker">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadWriteSeeker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
    <span class="nx">Seeker</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReadWriteSeeker接口聚合了基本的读写和移位操作。</p>
<h1 id="type-readerat">type ReaderAt<a hidden class="anchor" aria-hidden="true" href="#type-readerat">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReaderAt</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">ReadAt</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReaderAt接口包装了基本的ReadAt方法。</p>
<p>ReadAt从底层输入流的偏移量off位置读取len(p)字节数据写入p， 它返回读取的字节数(0 &lt;= n &lt;= len(p))和遇到的任何错误。当ReadAt方法返回值n &lt; len(p)时，它会返回一个非nil的错误来说明为啥没有读取更多的字节。在这方面，ReadAt是比Read要严格的。即使ReadAt方法返回值 n &lt; len(p)，它在被调用时仍可能使用p的全部长度作为暂存空间。如果有部分可用数据，但不够len(p)字节，ReadAt会阻塞直到获取len(p)个字节数据或者遇到错误。在这方面，ReadAt和Read是不同的。如果ReadAt返回时到达输入流的结尾，而返回值n == len(p)，其返回值err既可以是EOF也可以是nil。</p>
<p>如果ReadAt是从某个有偏移量的底层输入流（的Reader包装）读取，ReadAt方法既不应影响底层的偏移量，也不应被底层的偏移量影响。</p>
<p>ReadAt方法的调用者可以对同一输入流执行并行的ReadAt调用。</p>
<h1 id="type-writerat">type WriterAt<a hidden class="anchor" aria-hidden="true" href="#type-writerat">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WriterAt</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">WriteAt</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>WriterAt接口包装了基本的WriteAt方法。</p>
<p>WriteAt将p全部len(p)字节数据写入底层数据流的偏移量off位置。它返回写入的字节数(0 &lt;= n &lt;= len(p))和遇到的任何导致写入提前中止的错误。当其返回值n &lt; len(p)时，WriteAt必须放哪会一个非nil的错误。</p>
<p>如果WriteAt写入的对象是某个有偏移量的底层输出流（的Writer包装），WriteAt方法既不应影响底层的偏移量，也不应被底层的偏移量影响。</p>
<p>ReadAt方法的调用者可以对同一输入流执行并行的WriteAt调用。（前提是写入范围不重叠）</p>
<h1 id="type-bytereader">type ByteReader<a hidden class="anchor" aria-hidden="true" href="#type-bytereader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ByteReader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">ReadByte</span><span class="p">()</span> <span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ByteReader是基本的ReadByte方法的包装。</p>
<p>ReadByte读取输入中的单个字节并返回。如果没有字节可读取，会返回错误。</p>
<h1 id="type-bytescanner">type ByteScanner<a hidden class="anchor" aria-hidden="true" href="#type-bytescanner">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ByteScanner</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ByteReader</span>
    <span class="nf">UnreadByte</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ByteScanner接口在基本的ReadByte方法之外还添加了UnreadByte方法。</p>
<p>UnreadByte方法让下一次调用ReadByte时返回之前调用ReadByte时返回的同一个字节。连续调用两次UnreadByte方法而中间没有调用ReadByte时，可能会导致错误。</p>
<h1 id="type-runereader">type RuneReader<a hidden class="anchor" aria-hidden="true" href="#type-runereader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RuneReader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">ReadRune</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>RuneReader是基本的ReadRune方法的包装。</p>
<p>ReadRune读取单个utf-8编码的字符，返回该字符和它的字节长度。如果没有有效的字符，会返回错误。</p>
<h1 id="type-runescanner">type RuneScanner<a hidden class="anchor" aria-hidden="true" href="#type-runescanner">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RuneScanner</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">RuneReader</span>
    <span class="nf">UnreadRune</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>RuneScanner接口在基本的ReadRune方法之外还添加了UnreadRune方法。</p>
<p>UnreadRune方法让下一次调用ReadRune时返回之前调用ReadRune时返回的同一个utf-8字符。连续调用两次UnreadRune方法而中间没有调用ReadRune时，可能会导致错误。</p>
<h1 id="type-bytewriter">type ByteWriter<a hidden class="anchor" aria-hidden="true" href="#type-bytewriter">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ByteWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">WriteByte</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ByteWriter是基本的WriteByte方法的包装。</p>
<h1 id="type-readerfrom">type ReaderFrom<a hidden class="anchor" aria-hidden="true" href="#type-readerfrom">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReaderFrom</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReaderFrom接口包装了基本的ReadFrom方法。</p>
<p>ReadFrom方法从r读取数据直到EOF或者遇到错误。返回值n是读取的字节数，执行时遇到的错误（EOF除外）也会被返回。</p>
<h1 id="type-writerto">type WriterTo<a hidden class="anchor" aria-hidden="true" href="#type-writerto">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WriterTo</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">WriteTo</span><span class="p">(</span><span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>WriterTo接口包装了基本的WriteTo方法。</p>
<p>WriteTo方法将数据写入w直到没有数据可以写入或者遇到错误。返回值n是写入的字节数，执行时遇到的任何错误也会被返回。</p>
<h1 id="type-limitedreader">type LimitedReader<a hidden class="anchor" aria-hidden="true" href="#type-limitedreader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LimitedReader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">R</span>   <span class="nx">Reader</span> <span class="c1">// 底层Reader接口
</span><span class="c1"></span>    <span class="nx">N</span>   <span class="kt">int64</span>  <span class="c1">// 剩余可读取字节数
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LimitedReader从R中读取数据，但限制可以读取的数据的量为最多N字节，每次调用Read方法都会更新N以标记剩余可以读取的字节数。</p>
<h1 id="func-limitreader">func LimitReader<a hidden class="anchor" aria-hidden="true" href="#func-limitreader">#</a></h1>
<pre><code>func LimitReader(r Reader, n int64) Reader
</code></pre>
<p>返回一个Reader，它从r中读取n个字节后以EOF停止。返回值接口的底层为*LimitedReader类型。</p>
<h1 id="func-limitedreader-read">func (*LimitedReader) Read<a hidden class="anchor" aria-hidden="true" href="#func-limitedreader-read">#</a></h1>
<pre><code>func (l *LimitedReader) Read(p []byte) (n int, err error)
</code></pre>
<h1 id="type-sectionreader">type SectionReader<a hidden class="anchor" aria-hidden="true" href="#type-sectionreader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectionReader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SectionReader实现了对底层满足ReadAt接口的输入流某个片段的Read、ReadAt、Seek方法。</p>
<h2 id="func-newsectionreader">func NewSectionReader<a hidden class="anchor" aria-hidden="true" href="#func-newsectionreader">#</a></h2>
<pre><code>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader
</code></pre>
<p>返回一个从r中的偏移量off处为起始，读取n个字节后以EOF停止的SectionReader。</p>
<h2 id="func-sectionreader-size">func (*SectionReader) Size<a hidden class="anchor" aria-hidden="true" href="#func-sectionreader-size">#</a></h2>
<pre><code>func (s *SectionReader) Size() int64
</code></pre>
<p>Size返回该片段的字节数。</p>
<h2 id="func-sectionreader-read">func (*SectionReader) Read<a hidden class="anchor" aria-hidden="true" href="#func-sectionreader-read">#</a></h2>
<pre><code>func (s *SectionReader) Read(p []byte) (n int, err error)
</code></pre>
<h2 id="func-sectionreader-readat">func (*SectionReader) ReadAt<a hidden class="anchor" aria-hidden="true" href="#func-sectionreader-readat">#</a></h2>
<pre><code>func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)
</code></pre>
<p>##func (*SectionReader) Seek</p>
<pre><code>func (s *SectionReader) Seek(offset int64, whence int) (int64, error)
</code></pre>
<h1 id="type-pipereader">type PipeReader<a hidden class="anchor" aria-hidden="true" href="#type-pipereader">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PipeReader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>PipeReader是一个管道的读取端。</p>
<h1 id="func-pipe">func Pipe<a hidden class="anchor" aria-hidden="true" href="#func-pipe">#</a></h1>
<pre><code>func Pipe() (*PipeReader, *PipeWriter)
</code></pre>
<p>Pipe创建一个同步的内存中的管道。它可以用于连接期望io.Reader的代码和期望io.Writer的代码。一端的读取对应另一端的写入，直接在两端拷贝数据，没有内部缓冲。可以安全的并行调用Read和Write或者Read/Write与Close方法。Close方法会在最后一次阻塞中的I/O操作结束后完成。并行调用Read或并行调用Write也是安全的：每一个独立的调用会依次进行。</p>
<h2 id="func-pipereader-read">func (*PipeReader) Read<a hidden class="anchor" aria-hidden="true" href="#func-pipereader-read">#</a></h2>
<pre><code>func (r *PipeReader) Read(data []byte) (n int, err error)
</code></pre>
<p>Read实现了标准Reader接口：它从管道中读取数据，会阻塞直到写入端开始写入或写入端被关闭。</p>
<h2 id="func-pipereader-close">func (*PipeReader) Close<a hidden class="anchor" aria-hidden="true" href="#func-pipereader-close">#</a></h2>
<pre><code>func (r *PipeReader) Close() error
</code></pre>
<p>Close关闭读取器；关闭后如果对管道的写入端进行写入操作，就会返回(0, ErrClosedPip)。</p>
<h2 id="func-pipereader-closewitherror">func (*PipeReader) CloseWithError<a hidden class="anchor" aria-hidden="true" href="#func-pipereader-closewitherror">#</a></h2>
<pre><code>func (r *PipeReader) CloseWithError(err error) error
</code></pre>
<p>CloseWithError类似Close方法，但将调用Write时返回的错误改为err。</p>
<h1 id="type-pipewriter">type PipeWriter<a hidden class="anchor" aria-hidden="true" href="#type-pipewriter">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PipeWriter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>PipeWriter是一个管道的写入端。</p>
<h2 id="func-pipewriter-write">func (*PipeWriter) Write<a hidden class="anchor" aria-hidden="true" href="#func-pipewriter-write">#</a></h2>
<pre><code>func (w *PipeWriter) Write(data []byte) (n int, err error)
</code></pre>
<p>Write实现了标准Writer接口：它将数据写入到管道中，会阻塞直到读取器读完所有的数据或读取端被关闭。</p>
<h2 id="func-pipewriter-close">func (*PipeWriter) Close<a hidden class="anchor" aria-hidden="true" href="#func-pipewriter-close">#</a></h2>
<pre><code>func (w *PipeWriter) Close() error
</code></pre>
<p>Close关闭写入器；关闭后如果对管道的读取端进行读取操作，就会返回(0, EOF)。</p>
<h2 id="func-pipewriter-closewitherror">func (*PipeWriter) CloseWithError<a hidden class="anchor" aria-hidden="true" href="#func-pipewriter-closewitherror">#</a></h2>
<pre><code>func (w *PipeWriter) CloseWithError(err error) error
</code></pre>
<p>CloseWithError类似Close方法，但将调用Read时返回的错误改为err。</p>
<h1 id="func-teereader">func TeeReader<a hidden class="anchor" aria-hidden="true" href="#func-teereader">#</a></h1>
<pre><code>func TeeReader(r Reader, w Writer) Reader
</code></pre>
<p>TeeReader返回一个将其从r读取的数据写入w的Reader接口。所有通过该接口对r的读取都会执行对应的对w的写入。没有内部的缓冲：写入必须在读取完成前完成。写入时遇到的任何错误都会作为读取错误返回。</p>
<h1 id="func-multireader">func MultiReader<a hidden class="anchor" aria-hidden="true" href="#func-multireader">#</a></h1>
<pre><code>func MultiReader(readers ...Reader) Reader
</code></pre>
<p>MultiReader返回一个将提供的Reader在逻辑上串联起来的Reader接口。他们依次被读取。当所有的输入流都读取完毕，Read才会返回EOF。如果readers中任一个返回了非nil非EOF的错误，Read方法会返回该错误。</p>
<h1 id="func-multiwriter">func MultiWriter<a hidden class="anchor" aria-hidden="true" href="#func-multiwriter">#</a></h1>
<pre><code>func MultiWriter(writers ...Writer) Writer
</code></pre>
<p>MultiWriter创建一个Writer接口，会将提供给其的数据写入所有创建时提供的Writer接口。</p>
<h1 id="func-copy">func Copy<a hidden class="anchor" aria-hidden="true" href="#func-copy">#</a></h1>
<pre><code>func Copy(dst Writer, src Reader) (written int64, err error)
</code></pre>
<p>将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</p>
<p>对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。</p>
<h1 id="func-copyn">func CopyN<a hidden class="anchor" aria-hidden="true" href="#func-copyn">#</a></h1>
<pre><code>func CopyN(dst Writer, src Reader, n int64) (written int64, err error)
</code></pre>
<p>从src拷贝n个字节数据到dst，直到在src上到达EOF或发生错误。返回复制的字节数和遇到的第一个错误。</p>
<p>只有err为nil时，written才会等于n。如果dst实现了ReaderFrom接口，本函数很调用它实现拷贝。</p>
<h1 id="func-readatleast">func ReadAtLeast<a hidden class="anchor" aria-hidden="true" href="#func-readatleast">#</a></h1>
<pre><code>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
</code></pre>
<p>ReadAtLeast从r至少读取min字节数据填充进buf。函数返回写入的字节数和错误（如果没有读取足够的字节）。只有没有读取到字节时才可能返回EOF；如果读取了有但不够的字节时遇到了EOF，函数会返回ErrUnexpectedEOF。 如果min比buf的长度还大，函数会返回ErrShortBuffer。只有返回值err为nil时，返回值n才会不小于min。</p>
<h1 id="func-readfull">func ReadFull<a hidden class="anchor" aria-hidden="true" href="#func-readfull">#</a></h1>
<pre><code>func ReadFull(r Reader, buf []byte) (n int, err error)
</code></pre>
<p>ReadFull从r精确地读取len(buf)字节数据填充进buf。函数返回写入的字节数和错误（如果没有读取足够的字节）。只有没有读取到字节时才可能返回EOF；如果读取了有但不够的字节时遇到了EOF，函数会返回ErrUnexpectedEOF。 只有返回值err为nil时，返回值n才会等于len(buf)。</p>
<h1 id="func-writestring">func WriteString<a hidden class="anchor" aria-hidden="true" href="#func-writestring">#</a></h1>
<pre><code>func WriteString(w Writer, s string) (n int, err error)
</code></pre>
<p>WriteString函数将字符串s的内容写入w中。如果w已经实现了WriteString方法，函数会直接调用该方法。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
