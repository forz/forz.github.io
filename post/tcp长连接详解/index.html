<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>TCP长连接详解 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Kee">
<meta name="author" content="">
<link rel="canonical" href="/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="TCP长连接详解" />
<meta property="og:description" content="TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Kee" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T14:21:22&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T14:21:22&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TCP长连接详解"/>
<meta name="twitter:description" content="TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Kee"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "TCP长连接详解",
      "item": "/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP长连接详解",
  "name": "TCP长连接详解",
  "description": "TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Kee",
  "keywords": [
    
  ],
  "articleBody": "TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Keepalive（存活定时器）功能。\n长连接保活方法 对于面向连接的TCP socket,在实际应用中通常都要检测对端是否处于连接中,连接端口分两种情况:\n  连接正常关闭,调用close() shutdown()连接优雅关闭,send与recv立马返回错误,select返回SOCK_ERR;\n  连接的对端异常关闭,比如网络断掉,突然断电.\n  对于第二种情况,判断连接是否断开的方法有以下几种:\n  自己编写心跳包程序,简单的说就是自己的程序加入一条线程,定时向对端发送数据包,查看是否有ACK,根据ACK的返回情况来管理连接。此方法比较通用,一般使用业务层心跳处理,灵活可控,但改变了现有的协议;\n  使用TCP的keepalive机制,UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测\n  TCP的KeepAlive保活机制 在《UNIX网络编程第1卷》中也有详细的阐述：\nSO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：\n  对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。\n  对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接口本身则被关闭。\n  客户端崩溃且未完成重新启动。在这两种情况下，它的TCP都不会响应。服务器没有收到对其发出探测的响应，并且在75秒之后超时。服务器将总共发送10个这样的探测，每个探测75秒。如果没有收到一个响应，它就认为客户端主机已经关闭并终止连接。\n  客户端主机活跃运行，但从服务器不可到达。ICMP错误是“host unreachable(主机不可达)”。\n  服务器不必担心客户端主机被关闭然后重启的情况（这里指的是操作员执行的正常关闭，而不是主机的崩溃）。当系统被操作员关闭时，所有的应用程序进程（也就是客户端进程）都将被终止，客户端TCP会在连接上发送一个FIN。服务器可检测到FIN报文并正常结束。\n根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。\n方法如下：\nkeepAlive = 1； Setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)\u0026keepAlive, sizeof(keepAlive));  如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。\n1 2 3 4 5 6  The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours). /*开始首次KeepAlive探测前的TCP空闭时间 */ The tcp_keepintvl parameter specifies the interval between the nine retries that are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keepintvl defaults to 150 (75 seconds). /* 两次KeepAlive探测间的时间间隔 */ The TCP_KEEPCNT option specifies the maximum number of keepalive probes to be sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n is the value of the systemwide tcp_keepcnt parameter. /* 判定断开前的KeepAlive探测次数 */   因此我们可以得到\n1 2 3 4 5 6  int keepIdle = 6; int keepInterval = 5; int keepCount = 3; setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)\u0026keepIdle, sizeof(keepIdle)); setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)\u0026keepInterval, sizeof(keepInterval)); setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)\u0026keepCount, sizeof(keepCount));   这些属性是sockt继承的，非整个代码内的所有sockets都继承这个属性，因为如果要应用到多个套接口上必须分别使用setsockopt。\n全局设置方法:可更改/etc/sysctl.conf,加上:\n1 2 3  net.ipv4.tcp_keepalive_intvl = 20 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_time = 60   keepalive机制的必要性 如果没有设置keep alive，可能你在你的socket（阻塞性）的上面，接收: recv会一直阻塞不能返回，除非对端主动关闭连接，因为recv不知道socket断了。发送：取决于数据量的大小，只要底层协议栈的buffer能放下你的发送数据，应用程序级别的send就会一直成功返回。 直到buffer满，甚至buffer满了还要阻塞一段时间试图等待buffer空闲。所以你对send的返回值的检查根本检测不到失败。开启了keep alive功能，你直接通过发送接收的函数返回值就可以知道网络是否异常。\n另外，谁想定期检查连接状况，谁就启用keep alive。另一端可以不启用，只是被动地对探测包进行响应，这种响应是tcp协议的基本要求，跟keep alive无关。并不需要客户端和服务器端都开启keep alive。\nkeepalive机制的弊端   SO_KEEPALIVE无法控制，它会每时每刻都发；\n  SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。\n  在发送数据的时候keepalive根本无法正确运行\n正常情况下，连接的另一端主动调用colse关闭连接，tcp会通知，我们知道了该连接已经关闭。但是如果tcp连接的另一端突然掉线，或者重启断电，这个时候我们并不知道网络已经关闭。而此时，如果有发送数据失败，tcp会自动进行重传。重传包的优先级高于keepalive，那就意味着，我们的keepalive总是不能发送出去。 而此时，我们也并不知道该连接已经出错而中断。在较长时间的重传失败之后，我们才会知道。\n  应用层实现的心跳包 由应用程序自己发送心跳包来检测连接是否正常，大致的方法是：服务器在一个 Timer事件中定时 向客户端发送一个短小精悍的数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应， 如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；同样，如果客户端在一定时间内没 有收到服务器的心跳包，则认为连接不可用。\n转载：http://blog.csdn.net/liujiakunit/article/details/9786303\n",
  "wordCount" : "2429",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T14:21:22Z",
  "dateModified": "2017-06-25T14:21:22Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      TCP长连接详解
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><p>TCP协议中有长连接和短连接之分。短连接在数据包发送完成后就会自己断开，长连接在发包完毕后，会在一定的时间内保持连接，即我们通常所说的Keepalive（存活定时器）功能。</p>
<h1 id="长连接保活方法">长连接保活方法<a hidden class="anchor" aria-hidden="true" href="#长连接保活方法">#</a></h1>
<p>对于面向连接的TCP socket,在实际应用中通常都要检测对端是否处于连接中,连接端口分两种情况:</p>
<ol>
<li>
<p>连接正常关闭,调用close() shutdown()连接优雅关闭,send与recv立马返回错误,select返回SOCK_ERR;</p>
</li>
<li>
<p>连接的对端异常关闭,比如网络断掉,突然断电.</p>
</li>
</ol>
<p>对于第二种情况,判断连接是否断开的方法有以下几种:</p>
<ol>
<li>
<p>自己编写心跳包程序,简单的说就是自己的程序加入一条线程,定时向对端发送数据包,查看是否有ACK,根据ACK的返回情况来管理连接。此方法比较通用,一般使用业务层心跳处理,灵活可控,但改变了现有的协议;</p>
</li>
<li>
<p>使用TCP的keepalive机制,UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测</p>
</li>
</ol>
<h1 id="tcp的keepalive保活机制">TCP的KeepAlive保活机制<a hidden class="anchor" aria-hidden="true" href="#tcp的keepalive保活机制">#</a></h1>
<p>在《UNIX网络编程第1卷》中也有详细的阐述：</p>
<p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：</p>
<ol>
<li>
<p>对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。</p>
</li>
<li>
<p>对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接口本身则被关闭。</p>
</li>
<li>
<p>客户端崩溃且未完成重新启动。在这两种情况下，它的TCP都不会响应。服务器没有收到对其发出探测的响应，并且在75秒之后超时。服务器将总共发送10个这样的探测，每个探测75秒。如果没有收到一个响应，它就认为客户端主机已经关闭并终止连接。</p>
</li>
<li>
<p>客户端主机活跃运行，但从服务器不可到达。ICMP错误是“host unreachable(主机不可达)”。</p>
</li>
</ol>
<p>服务器不必担心客户端主机被关闭然后重启的情况（这里指的是操作员执行的正常关闭，而不是主机的崩溃）。当系统被操作员关闭时，所有的应用程序进程（也就是客户端进程）都将被终止，客户端TCP会在连接上发送一个FIN。服务器可检测到FIN报文并正常结束。</p>
<p>根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。</p>
<p>方法如下：</p>
<pre><code>keepAlive = 1；
Setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));
</code></pre>
<p>如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">The</span> <span class="n">tcp_keepidle</span> <span class="n">parameter</span> <span class="n">specifies</span> <span class="n">the</span> <span class="n">interval</span> <span class="n">of</span> <span class="n">inactivity</span> <span class="n">that</span> <span class="n">causes</span> <span class="n">TCP</span> <span class="n">to</span> <span class="n">generate</span> <span class="n">a</span> <span class="n">KEEPALIVE</span> <span class="n">transmission</span> <span class="k">for</span> <span class="n">an</span> <span class="n">application</span> <span class="n">that</span> <span class="n">requests</span> <span class="n">them</span><span class="p">.</span> <span class="n">tcp_keepidle</span> <span class="n">defaults</span> <span class="n">to</span> <span class="mi">14400</span> <span class="p">(</span><span class="n">two</span> <span class="n">hours</span><span class="p">).</span>
<span class="cm">/*开始首次KeepAlive探测前的TCP空闭时间 */</span>
<span class="n">The</span> <span class="n">tcp_keepintvl</span> <span class="n">parameter</span> <span class="n">specifies</span> <span class="n">the</span> <span class="n">interval</span> <span class="n">between</span> <span class="n">the</span> <span class="n">nine</span> <span class="n">retries</span> <span class="n">that</span> <span class="n">are</span> <span class="n">attempted</span> <span class="k">if</span> <span class="n">a</span> <span class="n">KEEPALIVE</span> <span class="n">transmission</span> <span class="n">is</span> <span class="n">not</span> <span class="n">acknowledged</span><span class="p">.</span> <span class="n">tcp_keepintvl</span> <span class="n">defaults</span> <span class="n">to</span> <span class="mi">150</span> <span class="p">(</span><span class="mi">75</span> <span class="n">seconds</span><span class="p">).</span>
<span class="cm">/* 两次KeepAlive探测间的时间间隔 */</span>
<span class="n">The</span> <span class="n">TCP_KEEPCNT</span> <span class="n">option</span> <span class="n">specifies</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">keepalive</span> <span class="n">probes</span> <span class="n">to</span> <span class="n">be</span> <span class="n">sent</span><span class="p">.</span> <span class="n">The</span> <span class="n">value</span> <span class="n">of</span> <span class="n">TCP_KEEPCNT</span> <span class="n">is</span> <span class="n">an</span> <span class="n">integer</span> <span class="n">value</span> <span class="n">between</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">n</span><span class="p">,</span> <span class="n">where</span> <span class="n">n</span> <span class="n">is</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">systemwide</span> <span class="n">tcp_keepcnt</span> <span class="n">parameter</span><span class="p">.</span>
<span class="cm">/* 判定断开前的KeepAlive探测次数 */</span>
</code></pre></td></tr></table>
</div>
</div><p>因此我们可以得到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">keepIdle</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">keepInterval</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">keepCount</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_KEEPIDLE</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keepIdle</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">keepIdle</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">SOL_TCP</span><span class="p">,</span><span class="n">TCP_KEEPINTVL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keepInterval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">keepInterval</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="n">SOL_TCP</span><span class="p">,</span> <span class="n">TCP_KEEPCNT</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keepCount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">keepCount</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>这些属性是sockt继承的，非整个代码内的所有sockets都继承这个属性，因为如果要应用到多个套接口上必须分别使用setsockopt。</p>
<p>全局设置方法:可更改/etc/sysctl.conf,加上:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">net</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">tcp_keepalive_intvl</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">net</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">tcp_keepalive_probes</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">net</span><span class="p">.</span><span class="n">ipv4</span><span class="p">.</span><span class="n">tcp_keepalive_time</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="keepalive机制的必要性">keepalive机制的必要性<a hidden class="anchor" aria-hidden="true" href="#keepalive机制的必要性">#</a></h1>
<p>如果没有设置keep alive，可能你在你的socket（阻塞性）的上面，接收: recv会一直阻塞不能返回，除非对端主动关闭连接，因为recv不知道socket断了。发送：取决于数据量的大小，只要底层协议栈的buffer能放下你的发送数据，应用程序级别的send就会一直成功返回。 直到buffer满，甚至buffer满了还要阻塞一段时间试图等待buffer空闲。所以你对send的返回值的检查根本检测不到失败。开启了keep alive功能，你直接通过发送接收的函数返回值就可以知道网络是否异常。</p>
<p>另外，谁想定期检查连接状况，谁就启用keep alive。另一端可以不启用，只是被动地对探测包进行响应，这种响应是tcp协议的基本要求，跟keep alive无关。并不需要客户端和服务器端都开启keep alive。</p>
<h1 id="keepalive机制的弊端">keepalive机制的弊端<a hidden class="anchor" aria-hidden="true" href="#keepalive机制的弊端">#</a></h1>
<ol>
<li>
<p>SO_KEEPALIVE无法控制，它会每时每刻都发；</p>
</li>
<li>
<p>SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。</p>
</li>
<li>
<p>在发送数据的时候keepalive根本无法正确运行</p>
<p>正常情况下，连接的另一端主动调用colse关闭连接，tcp会通知，我们知道了该连接已经关闭。但是如果tcp连接的另一端突然掉线，或者重启断电，这个时候我们并不知道网络已经关闭。而此时，如果有发送数据失败，tcp会自动进行重传。重传包的优先级高于keepalive，那就意味着，我们的keepalive总是不能发送出去。 而此时，我们也并不知道该连接已经出错而中断。在较长时间的重传失败之后，我们才会知道。</p>
</li>
</ol>
<h1 id="应用层实现的心跳包">应用层实现的心跳包<a hidden class="anchor" aria-hidden="true" href="#应用层实现的心跳包">#</a></h1>
<p>由应用程序自己发送心跳包来检测连接是否正常，大致的方法是：服务器在一个 Timer事件中定时 向客户端发送一个短小精悍的数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应， 如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；同样，如果客户端在一定时间内没 有收到服务器的心跳包，则认为连接不可用。</p>
<p>转载：<a href="">http://blog.csdn.net/liujiakunit/article/details/9786303</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
