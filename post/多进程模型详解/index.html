<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>多进程模型详解 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="多进程模型详解" />
<meta property="og:description" content="简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-09-10T22:25:16&#43;00:00" />
<meta property="article:modified_time" content="2017-09-10T22:25:16&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="多进程模型详解"/>
<meta name="twitter:description" content="简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "多进程模型详解",
      "item": "/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "多进程模型详解",
  "name": "多进程模型详解",
  "description": "简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在",
  "keywords": [
    
  ],
  "articleBody": "简介 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。\n父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。\n进程创建与结束 进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 - 1号内核进程 - 1号用户进程(init进程) - getty进程 - shell进程 - 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。\n相关接口：\n创建进程： pid_t fork(void);  返回值：出错返回-1；父进程中返回pid  0；子进程中pid == 0\n结束进程： void exit(int status);  status是退出状态，保存在全局变量中S?，通常0表示正常退出。\n获得PID： pid_t getpid(void);  返回调用者pid。\n获得父进程PID： pid_t getppid(void);  返回父进程pid。\n其他补充： 正常退出方式：\nexit()、_exit()、return（在main中）。  exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。\nreturn和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。\n异常退出方式：\nabort()、终止信号。  僵尸进程、孤儿进程 父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。\n相关接口：\n回收进程（1）： pid_t wait(int *status);  一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。\nstatus：指向子进程结束状态值。  回收进程（2）： pid_t waitpid(pid_t pid, int *status, int options);  返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。\npid：子进程识别码，控制等待哪些子进程。 pid 0，等待任何子进程识别码为pid的子进程。 status：指向返回码的指针。 options：选项决定父进程调用waitpid后的状态。 options = WNOHANG，即使没有子进程退出也会立即返回。 options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。  进程间通信 Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。\n管道 无名管道 无名管道特点：\n无名管道是一种特殊的文件，这种文件只存在于内存中。\n无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。\n无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。\n相关接口：\nint pipe(int fd[2]);  fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。\n通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。\n有名管道： 有名管道特点：\n有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。\n无名管道可以在不具有亲缘关系的进程间进行通信。\n相关接口：\nint mkfifo(const char *pathname, mode_t mode);  pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。\nmode：和open()中的参数相同。\n消息队列 共享内存 进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。\n相关接口\n创建共享内存： int shmget(key_t key, int size, int flag);  成功时返回一个和key相关的共享内存标识符，失败返回-1。\nkey：为共享内存段命名，多个共享同一片内存的进程使用同一个key。\nsize：共享内存容量。\nflag：权限标志位，和open的mode参数一样。\n连接到共享内存地址空间： void *shmat(int shmid, void *addr, int flag);  返回值即共享内存实际地址。\nshmid：shmget()返回的标识。\naddr：决定以什么方式连接地址。\nflag：访问模式。\n从共享内存分离： int shmdt(const void *shmaddr);  调用成功返回0，失败返回-1。\nshmaddr：是shmat()返回的地址指针。  其他补充 共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。\n但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。\n信号量 在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。\n相关接口\n创建信号量： int semget(key_t key, int nsems, int semflag);  创建成功返回信号量标识符，失败返回-1。\nkey：进程pid。\nnsems：创建信号量的个数。\nsemflag：指定信号量读写权限。\n改变信号量值： int semop(int semid, struct sembuf *sops, unsigned nsops);\n我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。\nstruct sembuf结构体定义如下：\nstruct sembuf{ short sem_num; short sem_op; short sem_flg; };  成功返回信号量标识符，失败返回-1。\nsemid：信号量集标识符，由semget()函数返回。\nsops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。\nnsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。\n直接控制信号量信息： int semctl(int semid, int semnum, int cmd, union semun arg);  semid：信号量集标识符。\nsemnum：信号量集数组上的下标，表示某一个信号量。\narg：union semun类型。\n辅助命令 ipcs命令用于报告共享内存、信号量和消息队列信息。\nipcs -a：列出共享内存、信号量和消息队列信息。\nipcs -l：列出系统限额。\nipcs -u：列出当前使用情况。\n套接字\n",
  "wordCount" : "3265",
  "inLanguage": "zh-cn",
  "datePublished": "2017-09-10T22:25:16Z",
  "dateModified": "2017-09-10T22:25:16Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      多进程模型详解
    </h1>
    <div class="post-meta">September 10, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h1>
<p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。</p>
<p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p>
<h1 id="进程创建与结束">进程创建与结束<a hidden class="anchor" aria-hidden="true" href="#进程创建与结束">#</a></h1>
<p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p>
<p>相关接口：</p>
<h3 id="创建进程">创建进程：<a hidden class="anchor" aria-hidden="true" href="#创建进程">#</a></h3>
<pre><code>pid_t fork(void);
</code></pre>
<p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0</p>
<h3 id="结束进程">结束进程：<a hidden class="anchor" aria-hidden="true" href="#结束进程">#</a></h3>
<pre><code>void exit(int status);
</code></pre>
<p>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</p>
<h3 id="获得pid">获得PID：<a hidden class="anchor" aria-hidden="true" href="#获得pid">#</a></h3>
<pre><code>pid_t getpid(void);
</code></pre>
<p>返回调用者pid。</p>
<h3 id="获得父进程pid">获得父进程PID：<a hidden class="anchor" aria-hidden="true" href="#获得父进程pid">#</a></h3>
<pre><code>pid_t getppid(void);
</code></pre>
<p>返回父进程pid。</p>
<h3 id="其他补充">其他补充：<a hidden class="anchor" aria-hidden="true" href="#其他补充">#</a></h3>
<p>正常退出方式：</p>
<pre><code>exit()、_exit()、return（在main中）。
</code></pre>
<p>exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p>
<p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p>
<p>异常退出方式：</p>
<pre><code>abort()、终止信号。
</code></pre>
<h1 id="僵尸进程孤儿进程">僵尸进程、孤儿进程<a hidden class="anchor" aria-hidden="true" href="#僵尸进程孤儿进程">#</a></h1>
<p>父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。</p>
<p>相关接口：</p>
<h3 id="回收进程1">回收进程（1）：<a hidden class="anchor" aria-hidden="true" href="#回收进程1">#</a></h3>
<pre><code>pid_t wait(int *status);
</code></pre>
<p>一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。</p>
<pre><code>status：指向子进程结束状态值。
</code></pre>
<h3 id="回收进程2">回收进程（2）：<a hidden class="anchor" aria-hidden="true" href="#回收进程2">#</a></h3>
<pre><code>pid_t waitpid(pid_t pid, int *status, int options);
</code></pre>
<p>返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。</p>
<pre><code>pid：子进程识别码，控制等待哪些子进程。

pid &lt; -1，等待进程组识别码为pid绝对值的任何进程。

pid = -1，等待任何子进程。

pid = 0，等待进程组识别码与目前进程相同的任何子进程。

pid &gt; 0，等待任何子进程识别码为pid的子进程。

status：指向返回码的指针。

options：选项决定父进程调用waitpid后的状态。

options = WNOHANG，即使没有子进程退出也会立即返回。

options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。
</code></pre>
<h1 id="进程间通信">进程间通信<a hidden class="anchor" aria-hidden="true" href="#进程间通信">#</a></h1>
<p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p>
<h2 id="管道">管道<a hidden class="anchor" aria-hidden="true" href="#管道">#</a></h2>
<h3 id="无名管道">无名管道<a hidden class="anchor" aria-hidden="true" href="#无名管道">#</a></h3>
<p>无名管道特点：</p>
<p>无名管道是一种特殊的文件，这种文件只存在于内存中。</p>
<p>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</p>
<p>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</p>
<p>相关接口：</p>
<pre><code>int pipe(int fd[2]);
</code></pre>
<p>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。</p>
<p>通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</p>
<h3 id="有名管道">有名管道：<a hidden class="anchor" aria-hidden="true" href="#有名管道">#</a></h3>
<p>有名管道特点：</p>
<p>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</p>
<p>无名管道可以在不具有亲缘关系的进程间进行通信。</p>
<p>相关接口：</p>
<pre><code>int mkfifo(const char *pathname, mode_t mode);
</code></pre>
<p>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</p>
<p>mode：和open()中的参数相同。</p>
<h3 id="消息队列">消息队列<a hidden class="anchor" aria-hidden="true" href="#消息队列">#</a></h3>
<h3 id="共享内存">共享内存<a hidden class="anchor" aria-hidden="true" href="#共享内存">#</a></h3>
<p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p>
<p>相关接口</p>
<h4 id="创建共享内存">创建共享内存：<a hidden class="anchor" aria-hidden="true" href="#创建共享内存">#</a></h4>
<pre><code>int shmget(key_t key, int size, int flag);
</code></pre>
<p>成功时返回一个和key相关的共享内存标识符，失败返回-1。</p>
<p>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</p>
<p>size：共享内存容量。</p>
<p>flag：权限标志位，和open的mode参数一样。</p>
<h4 id="连接到共享内存地址空间">连接到共享内存地址空间：<a hidden class="anchor" aria-hidden="true" href="#连接到共享内存地址空间">#</a></h4>
<pre><code>void *shmat(int shmid, void *addr, int flag);
</code></pre>
<p>返回值即共享内存实际地址。</p>
<p>shmid：shmget()返回的标识。</p>
<p>addr：决定以什么方式连接地址。</p>
<p>flag：访问模式。</p>
<h4 id="从共享内存分离">从共享内存分离：<a hidden class="anchor" aria-hidden="true" href="#从共享内存分离">#</a></h4>
<pre><code>int shmdt(const void *shmaddr);
</code></pre>
<p>调用成功返回0，失败返回-1。</p>
<pre><code>shmaddr：是shmat()返回的地址指针。
</code></pre>
<h4 id="其他补充-1">其他补充<a hidden class="anchor" aria-hidden="true" href="#其他补充-1">#</a></h4>
<p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p>
<p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p>
<h2 id="信号量">信号量<a hidden class="anchor" aria-hidden="true" href="#信号量">#</a></h2>
<p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。</p>
<p>相关接口</p>
<h3 id="创建信号量">创建信号量：<a hidden class="anchor" aria-hidden="true" href="#创建信号量">#</a></h3>
<pre><code>int semget(key_t key, int nsems, int semflag);
</code></pre>
<p>创建成功返回信号量标识符，失败返回-1。</p>
<p>key：进程pid。</p>
<p>nsems：创建信号量的个数。</p>
<p>semflag：指定信号量读写权限。</p>
<h3 id="改变信号量值">改变信号量值：<a hidden class="anchor" aria-hidden="true" href="#改变信号量值">#</a></h3>
<p>int semop(int semid, struct sembuf *sops, unsigned nsops);</p>
<p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p>
<p>struct sembuf结构体定义如下：</p>
<pre><code>struct sembuf{
    short sem_num;
    short sem_op;
    short sem_flg;
};
</code></pre>
<p>成功返回信号量标识符，失败返回-1。</p>
<p>semid：信号量集标识符，由semget()函数返回。</p>
<p>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</p>
<p>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p>
<h3 id="直接控制信号量信息">直接控制信号量信息：<a hidden class="anchor" aria-hidden="true" href="#直接控制信号量信息">#</a></h3>
<pre><code>int semctl(int semid, int semnum, int cmd, union semun arg);
</code></pre>
<p>semid：信号量集标识符。</p>
<p>semnum：信号量集数组上的下标，表示某一个信号量。</p>
<p>arg：union semun类型。</p>
<h3 id="辅助命令">辅助命令<a hidden class="anchor" aria-hidden="true" href="#辅助命令">#</a></h3>
<p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p>
<p>ipcs -a：列出共享内存、信号量和消息队列信息。</p>
<p>ipcs -l：列出系统限额。</p>
<p>ipcs -u：列出当前使用情况。</p>
<p>套接字</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
