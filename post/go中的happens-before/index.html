<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go中的happens-before | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="前言 Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84happens-before/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go中的happens-before" />
<meta property="og:description" content="前言 Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84happens-before/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-23T23:21:53&#43;00:00" />
<meta property="article:modified_time" content="2021-05-23T23:21:53&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的happens-before"/>
<meta name="twitter:description" content="前言 Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go中的happens-before",
      "item": "/post/go%E4%B8%AD%E7%9A%84happens-before/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go中的happens-before",
  "name": "Go中的happens-before",
  "description": "前言 Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发",
  "keywords": [
    "Go"
  ],
  "articleBody": "前言 Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发环境中多 goroutine 读相同变量的时候,变量的可见性条件。具体点说,就是指,在什么条件下, goroutine 在读取一个变量的值的时候,能够看到其它 goroutine 对这个变量进行的写的结果。\n由于 CPU 指令重排和多级 Cache 的存在,保证多核访问同一个变量这件事儿变得非常复杂。毕竟,不同 CPU 架构(x86/amd64、ARM、Power 等)的处理方式也不一样,再加上编译器的优化也可能对指令进行重排,所以编程语言需要一个规范,来明确多线程同时访问同一个变量的可见性和顺序( Russ Cox 在麻省理工学院 6.824 分布式系统 Distributed Systems 课程 的一课,专门介绍了相关的知识)。在编程语言中,这个规范被叫做内存模型。\n除了 Go,Java、C++、C、C#、Rust 等编程语言也有内存模型。为什么这些编程语言都要定义内存模型呢?在我看来,主要是两个目的。\n向广大的程序员提供一种保证,以便他们在做设计和开发程序时,面对同一个数据同时被多个 goroutine 访问的情况,可以做一些串行化访问的控制,比如使用 Channel 或者 sync 包和 sync/atomic 包中的并发原语。\n允许编译器和硬件对程序做一些优化。这一点其实主要是为编译器开发者提供的保证, 这样可以方便他们对 Go 的编译器做优化。\n首先,我们要先弄明白重排和可见性的问题,因为它们影响着程序实际执行的顺序关系。\n重排和可见性的问题 由于指令重排,代码并不一定会按照你写的顺序执行。\n举个例子,当两个 goroutine 同时对一个数据进行读写时,假设 goroutine g1 对这个变量进行写操作 w,goroutine g2 同时对这个变量进行读操作 r,那么,如果 g2 在执行读操作 r 的时候,已经看到了 g1 写操作 w 的结果,那么,也不意味着 g2 能看到在 w 之前的其它的写操作。这是一个反直观的结果,不过的确可能会存在。\n接下来,我再举几个具体的例子,带你来感受一下,重排以及多核 CPU 并发执行导致程序的运行和代码的书写顺序不一样的情况。\n先看第一个例子,代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var a, b int func f() { a = 1 // w之前的写操作  b = 2 // 写操作w } func g() { print(b) // 读操作r  print(a) // ??? } func main() { go f() //g1  g() //g2 }   可以看到,第 9 行是要打印 b 的值。需要注意的是,即使这里打印出的值是 2,但是依然可能在打印 a 的值时,打印出初始值 0,而不是 1。这是因为,程序运行的时候,不能保证 g2 看到的 a 和 b 的赋值有先后关系。\n再来看一个类似的例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var a string var done bool func setup() { a = \"hello, world\" done = true } func main() { go setup() for !done { } print(a) }   在这段代码中,主 goroutine main 即使观察到 done 变成 true 了,最后读取到的 a 的值仍然可能为空。\n更糟糕的情况是,main 根本就观察不到另一个 goroutine 对 done 的写操作,这就会导致 main 程序一直被 hang 住。甚至可能还会出现半初始化的情况,比如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type T struct { msg string } var g *T func setup() { t := new(T) t.msg = \"hello, world\" g = t } func main() { go setup() for g == nil { } print(g.msg) }   即使 main goroutine 观察到 g 不为 nil,也可能打印出空的 msg(第 17 行)。\n看到这里,你可能要说了,我都运行这个程序几百万次了,怎么也没有观察到这种现象? 我可以这么告诉你,能不能观察到和提供保证(guarantee)是两码事儿。由于 CPU 架构和 Go 编译器的不同,即使你运行程序时没有遇到这些现象,也不代表 Go 可以 100% 保证不会出现这些问题。\n刚刚说了,程序在运行的时候,两个操作的顺序可能不会得到保证,那该怎么办呢?接下来,我要带你了解一下 Go 内存模型中很重要的一个概念:happens-before,这是用来描述两个时间的顺序关系的。如果某些操作能提供 happens-before 关系,那么,我们就可以 100% 保证它们之间的顺序。\n在并发编程中的 memory barrier 和 GC 中的 barrier 不是一回 事。\nMemory barrier 是为了防止各种类型的读写重排:\n而 GC 中的 read/write barrier 则是指堆上指针修改之前插入 的一小段代码。\nhappens-before 在一个 goroutine 内部,程序的执行顺序和它们的代码指定的顺序是一样的,即使编译器或者 CPU 重排了读写顺序,从行为上来看,也和代码指定的顺序一样。\n这是一个非常重要的保证,我们一定要记住。\n我们来看一个例子。在下面的代码中,即使编译器或者 CPU 对 a、b、c 的初始化进行了重排,但是打印结果依然能保证是 1、2、3,而不会出现 1、0、0 或 1、0、1 等情况。\n1 2 3 4 5 6 7 8 9 10  func foo() { var a = 1 var b = 2 var c = 3 println(a) println(b) println(c) }   但是,对于另一个 goroutine 来说,重排却会产生非常大的影响。因为 Go 只保证 goroutine 内部重排对读写的顺序没有影响,比如刚刚我们在讲“可见性”问题时提到的三个例子,那该怎么办呢?这就要用到 happens-before 关系了。\n如果两个 action(read 或者 write)有明确的 happens-before 关系,你就可以确定它们之间的执行顺序(或者是行为表现上的顺序)。\nGo 内存模型通过 happens-before 定义两个事件(读、写 action)的顺序:如果事件 e1 happens before 事件 e2,那么,我们就可以说事件 e2 在事件 e1 之后发生(happens after)。如果 e1 不是 happens before e2, 同时也不 happens after e2,那么,我们就可以说事件 e1 和 e2 是同时发生的。\n如果要保证对“变量 v 的读操作 r”能够观察到一个对“变量 v 的写操作 w”,并且 r 只能观察到 w 对变量 v 的写,没有其它对 v 的写操作,也就是说,我们要保证 r 绝对能观察到 w 操作的结果,那么就需要同时满足两个条件:\n w happens before r; 其它对 v 的写操作(w2、w3、w4, …) 要么 happens before w,要么 happens after r,绝对不会和 w、r 同时发生,或者是在它们之间发生。  你可能会说,这是很显然的事情啊,但我要和你说的是,这是一个非常严格、严谨的数学定义。\n对于单个的 goroutine 来说,它有一个特殊的 happens-before 关系,Go 内存模型中是这么讲的:\nWithin a single goroutine, the happens-before order is the order expressed by the program.\n我来解释下这句话。它的意思是,在单个的 goroutine 内部, happens-before 的关系和代码编写的顺序是一致的。\n我再具体解释下。\n在 goroutine 内部对一个局部变量 v 的读,一定能观察到最近一次对这个局部变量 v 的写。如果要保证多个 goroutine 之间对一个共享变量的读写顺序,在 Go 语言中,可以使用并发原语为读写操作建立 happens-before 关系,这样就可以保证顺序了。\n说到这儿,我想先给你补充三个 Go 语言中和内存模型有关的小知识,掌握了这些,你就能更好地理解下面的内容。\n 在 Go 语言中,对变量进行零值的初始化就是一个写操作。 如果对超过机器 word(64bit、32bit 或者其它)大小的值进行读写,那么,就可以看作是对拆成 word 大小的几个读写无序进行。 Go 并不提供直接的 CPU 屏障(CPU fence)来提示编译器或者 CPU 保证顺序性,而是使用不同架构的内存屏障指令来实现统一的并发原语。  接下来,我就带你学习下 Go 语言中提供的 happens-before 关系保证。\nHappen-before 到底是什么?\n本质是在用户不知道 memory barrier 概念和具体实现的前提 下，能够按照官方提供的 happen-before 正确进行并发编 程。\nGo 语言中保证的 happens-before 关系 除了单个 goroutine 内部提供的 happens-before 保证,Go 语言中还提供了一些其它的 happens-before 关系的保证,下面我来一个一个介绍下。\ninit 函数 应用程序的初始化是在单一的 goroutine 执行的。如果包 p 导入了包 q,那么,q 的 init 函数的执行一定 happens before p 的任何初始化代码。\n这里有一个特殊情况需要你记住:main 函数一定在导入的包的 init 函数之后执行。\n包级别的变量在同一个文件中是按照声明顺序逐个初始化的,除非初始化它的时候依赖其它的变量。同一个包下的多个文件,会按照文件名的排列顺序进行初始化。这个顺序被定义在Go 语言规范中,而不是 Go 的内存模型规范中。你可以看看下面的例子中各个变量的值:\n1 2 3 4 5 6 7 8 9 10 11  var ( a = c + b // == 9  b = f() // == 4  c = f() // == 5  d = 3 // == 5 全部初始化完成后 ) func f() int { d++ return d }   具体怎么对这些变量进行初始化呢?Go 采用的是依赖分析技术。不过,依赖分析技术保证的顺序只是针对同一包下的变量,而且,只有引用关系是本包变量、函数和非接口的方法,才能保证它们的顺序性。\n同一个包下可以有多个 init 函数,但是每个文件最多只能有一个 init 函数,多个 init 函数按照它们的文件名顺序逐个初始化。\n刚刚讲的这些都是不同包的 init 函数执行顺序,下面我举一个具体的例子,把这些内容串起来,你一看就明白了。\n这个例子是一个 main 程序,它依赖包 p1,包 p1 依赖包 p2,包 p2 依赖 p3。\n为了追踪初始化过程,并输出有意义的日志,我定义了一个辅助方法,打印出日志并返回一个用来初始化的整数值:\n1 2 3 4 5  func Trace(t string, v int) int { fmt.Println(t, \":\", v) return v }   包 p3 包含两个文件,分别定义了一个 init 函数。第一个文件中定义了两个变量,这两个变量的值还会在 init 函数中进行修改。\n我们来分别看下包 p3 的这两个文件:\n1 2 3 4 5 6 7 8 9 10 11 12  // lib1.go in p3  var V1_p3 = trace.Trace(\"init v1_p3\", 3) var V2_p3 = trace.Trace(\"init v2_p3\", 3) func init() { fmt.Println(\"init func in p3\") V1_p3 = 300 V2_p3 = 300 }   1 2 3 4 5 6  // lib2.go in p3  func init() { fmt.Println(\"another init func in p3\") }   下面再来看看包 p2。包 p2 定义了变量和 init 函数。第一个变量初始化为 2,并在 init 函数中更改为 200。第二个变量是复制的 p3.V2_p3。\n1 2 3 4 5 6 7  var V1_p2 = trace.Trace(\"init v1_p2\", 2) var V2_p2 = trace.Trace(\"init v2_p2\", p3.V2_p3) func init() { fmt.Println(\"init func in p2\") V1_p2 = 200 }   包 p1 定义了变量和 init 函数。它的两个变量的值是复制的 p2 对应的两个变量值。\n1 2 3 4 5 6  var V1_p1 = trace.Trace(\"init v1_p1\", p2.V1_p2) var V2_p1 = trace.Trace(\"init v2_p1\", p2.V2_p2) func init() { fmt.Println(\"init func in p1\") }   main 定义了 init 函数和 main 函数。\n1 2 3 4 5 6 7 8 9  func init() { fmt.Println(\"init func in main\") } func main() { fmt.Println(\"V1_p1:\", p1.V1_p1) fmt.Println(\"V2_p1:\", p1.V2_p1) }   运行 main 函数会依次输出 p3、p2、p1、main 的初始化变量时的日志(变量初始化时的日志和 init 函数调用时的日志):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 包p3的变量初始化 init v1_p3 : 3 init v2_p3 : 3 // p3的init函数 init func in p3 // p3的另一个init函数 another init func in p3 // 包p2的变量初始化 init v1_p2 : 2 init v2_p2 : 300 // 包p2的init函数 init func in p2 // 包p1的变量初始化 init v1_p1 : 200 init v2_p1 : 300 // 包p1的init函数 init func in p1 // 包main的init函数 init func in main // main函数 V1_p1: 200 V2_p1: 300   下面,我们再来看看 goroutine 对 happens-before 关系的保证情况。\ngoroutine 首先,我们需要明确一个规则:启动 goroutine 的 go 语句的执行,一定 happens before 此 goroutine 内的代码执行。\n根据这个规则,我们就可以知道,如果 go 语句传入的参数是一个函数执行的结果,那么,这个函数一定先于 goroutine 内部的代码被执行。\n同一个 goroutine 内的逻辑有依赖的语句执行，满足顺序关系。\n编译器/CPU 可能对同一个 goroutine 中的语句执行进行打 乱，以提高性能，但不能破坏其应用原有的逻辑。\n不同的 goroutine 观察到的共享变量的修改顺序可能不一样。\nGoroutine 的创建(creation)一定先于 goroutine 的执行 (execution)\n我们来看一个例子。在下面的代码中,第 8 行 a 的赋值和第 9 行的 go 语句是在同一个 goroutine 中执行的,所以,在主 goroutine 看来,第 8 行肯定 happens before 第 9 行,又由于刚才的保证,第 9 行子 goroutine 的启动 happens before 第 4 行的变量输出,那么,我们就可以推断出,第 8 行 happens before 第 4 行。也就是说,在第 4 行打印 a 的值的时候,肯定会打印出“hello world”。\n1 2 3 4 5 6 7 8 9 10 11  var a string func f() { print(a) } func hello() { a = \"hello, world\" go f() }   刚刚说的是启动 goroutine 的情况,goroutine 退出的时候,是没有任何 happensbefore 保证的。所以,如果你想观察某个 goroutine 的执行效果,你需要使用同步机制建立 happens-before 关系,比如 Mutex 或者 Channel。接下来,我会讲 Channel 的 happens-before 的关系保证。\n在没有显式同步的情况下，goroutine 的结束没有任何保证， 可能被执行，也可能不被执行\nChannel Channel 是 goroutine 同步交流的主要方法。往一个 Channel 中发送一条数据,通常对应着另一个 goroutine 从这个 Channel 中接收一条数据。\n通用的 Channel happens-before 关系保证有 4 条规则,我分别来介绍下。\n第 1 条规则是,往 Channel 中的发送操作,happens before 从该 Channel 接收相应数据的动作完成之前,即第 n 个 send 一定 happens before 第 n 个 receive 的完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13  var ch = make(chan struct{}, 10) // buffered或者unbuffered var s string func f() { s = \"hello, world\" ch  struct{}{} } func main() { go f() ch print(s) }   在这个例子中,s 的初始化(第 5 行)happens before 往 ch 中发送数据, 往 ch 发送数据 happens before 从 ch 中读取出一条数据(第 11 行),第 12 行打印 s 的值 happens after 第 11 行,所以,打印的结果肯定是初始化后的 s 的值“hello world”。\n第 2 条规则是,close 一个 Channel 的调用,肯定 happens before 从关闭的 Channel 中读取出一个零值。\n还是拿刚刚的这个例子来说,如果你把第 6 行替换成 close(ch),也能保证同样的执行顺序。因为第 11 行从关闭的 ch 中读取出零值后,第 6 行肯定被调用了。\n第 3 条规则是,对于 unbuffered 的 Channel,也就是容量是 0 的 Channel,从此 Channel 中读取数据的调用一定 happens before 往此 Channel 发送数据的调用完成。\n所以,在上面的这个例子中呢,如果想保持同样的执行顺序,也可以写成这样:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var ch = make(chan int) var s string func f() { s = \"hello, world\" ch } func main() { go f() ch  struct{}{} print(s) }   如果第 11 行发送语句执行成功(完毕),那么根据这个规则,第 6 行(接收)的调用肯定发生了(执行完成不完成不重要,重要的是这一句“肯定执行了”),那么 s 也肯定初始化了,所以一定会打印出“hello world”。\n这一条比较晦涩,但是,因为 Channel 是 unbuffered 的 Channel,所以这个规则也成立。\n第 4 条规则是,如果 Channel 的容量是 m(m0),那么,第 n 个 receive 一定 happens before 第 n+m 个 send 的完成。\n前一条规则是针对 unbuffered channel 的,这里给出了更广泛的针对 buffered channel 的保证。利用这个规则,我们可以实现信号量(Semaphore)的并发原语。Channel 的容量相当于可用的资源,发送一条数据相当于请求信号量,接收一条数据相当于释放信号。\nMutex/RWMutex 对于互斥锁 Mutex m 或者读写锁 RWMutex m,有 3 条 happens-before 关系的保证。\n 第 n 次的 l.Unlock,那么,和这个 RLock 相对应的 l.RUnlock 一定 happens 第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法的返回; 1. 对于读写锁 RWMutex m,如果它的第 n 个 m.Lock 方法的调用已返回,那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回, 只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证,只有释放了持有的写锁,那些等待的读请求才能请求到读锁。 对于读写锁 RWMutex m,如果它的第 n 个 m.RLock 方法的调用已返回,那么它的第 k (k 读写锁的保证有点绕,我再带你看看官方的描述:\n对于读写锁 l 的 l.RLock 方法调用,如果存在一个 n,这次的 l.RLock 调用 happens after第 n 次的 l.Unlock,那么,和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是,读写锁的 Lock 必须等待既有的读锁释放后才能获取到。\n我再举个例子。在下面的代码中,第 6 行第一次的 Unlock 一定 happens before 第二次的 Lock(第 12 行),所以这也能保证正确地打印出“hello world”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var mu sync.Mutex var s string func foo() { s = \"hello, world\" mu.Unlock() } func main() { mu.Lock() go foo() mu.Lock() print(s)   WaitGroup 接下来是 WaitGroup 的保证。\n对于一个 WaitGroup 实例 wg,在某个时刻 t0 时,它的计数值已经不是零了,假如 t0 时刻之后调用了一系列的 wg.Add(n) 或者 wg.Done(),并且只有最后一次调用 wg 的计数值变为了 0,那么,可以保证这些 wg.Add 或者 wg.Done() 一定 happens before t0 时刻之后调用的 wg.Wait 方法的返回。\n这个保证的通俗说法,就是 Wait 方法等到计数值归零之后才返回。\nOnce 它提供的保证是:对于 once.Do(f) 调用,f 函数的那个单次调用一定 happens before 任何 once.Do(f) 调用的返回。换句话说,就是函数 f 一定会在 Do 方法返回之前执行。\n还是以 hello world 的例子为例,这次我们使用 Once 并发原语实现,可以看下下面的代码:\n1 2 3 4 5 6 7 8 9 10 11  var s string var once sync.Once func foo() { s = \"hello, world\" } func twoprint() { once.Do(foo) print(s) }   第 5 行的执行一定 happens before 第 9 行的返回,所以执行到第 10 行的时候,sd 已经初始化了,所以会正确地打印“hello world”。\n最后,我再来说说 atomic 的保证。\natomic 其实,Go 内存模型的官方文档并没有明确给出 atomic 的保证,有一个相关的 issue go# 5045记录了相关的讨论。光看 issue 号,就知道这个讨论由来已久了。Russ Cox 想让 atomic 有一个弱保证,这样可以为以后留下充足的可扩展空间,所以,Go 内存模型规范上并没有严格的定义。\n对于 Go 1.15 的官方实现来说,可以保证使用 atomic 的 Load/Store 的变量之间的顺序性。\n在下面的例子中,打印出的 a 的结果总是 1,但是官方并没有做任何文档上的说明和保证。\n依照 Ian Lance Taylor 的说法,Go 核心开发组的成员几乎没有关注这个方向上的研究, 因为这个问题太复杂,有很多问题需要去研究,所以,现阶段还是不要使用 atomic 来保证顺序性。\n1 2 3 4 5 6 7 8 9 10 11 12 13  func main() { var a, b int32 = 0, 0 go func() { atomic.StoreInt32(\u0026a, 1) atomic.StoreInt32(\u0026b, 1) }() for atomic.LoadInt32(\u0026b) == 0{ runtime.Gosched() } fmt.Println(atomic.LoadInt32(\u0026a)) }   Ian Lance Taylor曾经在论坛中说:\nIn C++ memory model terms I believe that the sync/atomic Load operations are memory_order_acquire, and I believe that the sync/atomic Store operations are memory_order_release. It’s possible that if we ever document it we will go for stronger memory ordering, but I believe that these operations must at least carry those guarantees.\nI’m somewhat less certain of the memory order guarantees of the Swap, CompareAndSwap, and Add functions. I guess that Swap and CompareAndSwap are probably at least memory_order_acq_rel, but Add may be memory_order_relaxed.\nRuss Cox曾经回答过问题,他把go的atomic 操作定位sequential consistency的，这是一个更严格的memory ordering。它们之前的读写操作,不会重排在Load/Store之后， 它们之后的读写操作也不会重排在Load/Store之前，所以建立了一个内存屏障(Memory barrier)。\nrsc 2019年7月16日上午9:12:01\nAlthough there’s been no official resolution to the issue, I think the actual path forward is what I posted a while back: “Go’s atomics guarantee sequential consistency among the atomic variables (behave like C/C++’s seqconst atomics), and that you shouldn’t mix atomic and non-atomic accesses for a given memory word.”\n至少目前，我们可以按照他们的解答进行理解。\n总结 Go 的内存模型规范中,一开始有这么一段话:\nIf you must read the rest of this document to understand the behavior of your program, you are being too clever.\nDon’t be clever.\n理解你的程序的行为是聪明的,但是, 不要自作聪明。\n谨慎地使用这些保证,能够让你的程序按照设想的 happens-before 关系执行,但是不要以为完全理解这些概念和保证,就可以随意地制造所谓的各种技巧,否则就很容易掉进“坑”里,而且会给代码埋下了很多的“定时炸弹”。\n比如,Go 里面已经有值得信赖的互斥锁了,如果没有额外的需求,就不要使用 Channel 创造出自己的互斥锁。\n当然,我也不希望你畏手畏脚地把思想局限住,我还是建议你去做一些有意义的尝试,比如使用 Channel 实现信号量等扩展并发原语。\n",
  "wordCount" : "6942",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-23T23:21:53Z",
  "dateModified": "2021-05-23T23:21:53Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E4%B8%AD%E7%9A%84happens-before/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go中的happens-before
    </h1>
    <div class="post-meta">May 23, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>Go 官方文档里专门介绍了 Go 的 内存模型,你不要误解这里的内存模型的含义,它并不是指 Go 对象的内存分配、内存回收和内存整理的规范,它描述的是并发环境中多 goroutine 读相同变量的时候,变量的可见性条件。具体点说,就是指,在什么条件下, goroutine 在读取一个变量的值的时候,能够看到其它 goroutine 对这个变量进行的写的结果。</p>
<p>由于 CPU 指令重排和多级 Cache 的存在,保证多核访问同一个变量这件事儿变得非常复杂。毕竟,不同 CPU 架构(x86/amd64、ARM、Power 等)的处理方式也不一样,再加上编译器的优化也可能对指令进行重排,所以编程语言需要一个规范,来明确多线程同时访问同一个变量的可见性和顺序( Russ Cox 在麻省理工学院 6.824 分布式系统 Distributed Systems 课程 的一课,专门介绍了相关的知识)。在编程语言中,这个规范被叫做内存模型。</p>
<p>除了 Go,Java、C++、C、C#、Rust 等编程语言也有内存模型。为什么这些编程语言都要定义内存模型呢?在我看来,主要是两个目的。</p>
<p>向广大的程序员提供一种保证,以便他们在做设计和开发程序时,面对同一个数据同时被多个 goroutine 访问的情况,可以做一些串行化访问的控制,比如使用 Channel 或者 sync 包和 sync/atomic 包中的并发原语。</p>
<p>允许编译器和硬件对程序做一些优化。这一点其实主要是为编译器开发者提供的保证, 这样可以方便他们对 Go 的编译器做优化。</p>
<p>首先,我们要先弄明白重排和可见性的问题,因为它们影响着程序实际执行的顺序关系。</p>
<h2 id="重排和可见性的问题">重排和可见性的问题<a hidden class="anchor" aria-hidden="true" href="#重排和可见性的问题">#</a></h2>
<p>由于指令重排,代码并不一定会按照你写的顺序执行。</p>
<p>举个例子,当两个 goroutine 同时对一个数据进行读写时,假设 goroutine g1 对这个变量进行写操作 w,goroutine g2 同时对这个变量进行读操作 r,那么,如果 g2 在执行读操作 r 的时候,已经看到了 g1 写操作 w 的结果,那么,也不意味着 g2 能看到在 w 之前的其它的写操作。这是一个反直观的结果,不过的确可能会存在。</p>
<p>接下来,我再举几个具体的例子,带你来感受一下,重排以及多核 CPU 并发执行导致程序的运行和代码的书写顺序不一样的情况。</p>
<p>先看第一个例子,代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// w之前的写操作
</span><span class="c1"></span>  <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// 写操作w
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 读操作r
</span><span class="c1"></span>  <span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// ???
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nf">f</span><span class="p">()</span> <span class="c1">//g1
</span><span class="c1"></span>  <span class="nf">g</span><span class="p">()</span> <span class="c1">//g2
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到,第 9 行是要打印 b 的值。需要注意的是,即使这里打印出的值是 2,但是依然可能在打印 a 的值时,打印出初始值 0,而不是 1。这是因为,程序运行的时候,不能保证 g2 看到的 a 和 b 的赋值有先后关系。</p>
<p>再来看一个类似的例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">var</span> <span class="nx">a</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">done</span> <span class="kt">bool</span>

<span class="kd">func</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
  <span class="nx">done</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nf">setup</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">!</span><span class="nx">done</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这段代码中,主 goroutine main 即使观察到 done 变成 true 了,最后读取到的 a 的值仍然可能为空。</p>
<p>更糟糕的情况是,main 根本就观察不到另一个 goroutine 对 done 的写操作,这就会导致 main 程序一直被 hang 住。甚至可能还会出现半初始化的情况,比如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">*</span><span class="nx">T</span>

<span class="kd">func</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">t</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">msg</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
  <span class="nx">g</span> <span class="p">=</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nf">setup</span><span class="p">()</span>
  <span class="k">for</span> <span class="nx">g</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>即使 main goroutine 观察到 g 不为 nil,也可能打印出空的 msg(第 17 行)。</p>
<p>看到这里,你可能要说了,我都运行这个程序几百万次了,怎么也没有观察到这种现象? 我可以这么告诉你,能不能观察到和提供保证(guarantee)是两码事儿。由于 CPU 架构和 Go 编译器的不同,即使你运行程序时没有遇到这些现象,也不代表 Go 可以 100% 保证不会出现这些问题。</p>
<p>刚刚说了,程序在运行的时候,两个操作的顺序可能不会得到保证,那该怎么办呢?接下来,我要带你了解一下 Go 内存模型中很重要的一个概念:happens-before,这是用来描述两个时间的顺序关系的。如果某些操作能提供 happens-before 关系,那么,我们就可以 100% 保证它们之间的顺序。</p>
<p>在并发编程中的 memory barrier 和 GC 中的 barrier 不是一回
事。</p>
<p>Memory barrier 是为了防止各种类型的读写重排:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210819215541.png" alt=""  />
</p>
<p>而 GC 中的 read/write barrier 则是指堆上指针修改之前插入 的一小段代码。</p>
<h2 id="happens-before">happens-before<a hidden class="anchor" aria-hidden="true" href="#happens-before">#</a></h2>
<p>在一个 goroutine 内部,程序的执行顺序和它们的代码指定的顺序是一样的,即使编译器或者 CPU 重排了读写顺序,从行为上来看,也和代码指定的顺序一样。</p>
<p>这是一个非常重要的保证,我们一定要记住。</p>
<p>我们来看一个例子。在下面的代码中,即使编译器或者 CPU 对 a、b、c 的初始化进行了重排,但是打印结果依然能保证是 1、2、3,而不会出现 1、0、0 或 1、0、1 等情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="mi">3</span>

    <span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是,对于另一个 goroutine 来说,重排却会产生非常大的影响。因为 Go 只保证 goroutine 内部重排对读写的顺序没有影响,比如刚刚我们在讲“可见性”问题时提到的三个例子,那该怎么办呢?这就要用到 happens-before 关系了。</p>
<p>如果两个 action(read 或者 write)有明确的 happens-before 关系,你就可以确定它们之间的执行顺序(或者是行为表现上的顺序)。</p>
<p>Go 内存模型通过 happens-before 定义两个事件(读、写 action)的顺序:如果事件 e1  happens before 事件 e2,那么,我们就可以说事件 e2 在事件 e1 之后发生(happens after)。如果 e1 不是 happens before e2, 同时也不 happens after e2,那么,我们就可以说事件 e1 和 e2 是同时发生的。</p>
<p>如果要保证对“变量 v 的读操作 r”能够观察到一个对“变量 v 的写操作 w”,并且 r 只能观察到 w 对变量 v 的写,没有其它对 v 的写操作,也就是说,我们要保证 r 绝对能观察到 w 操作的结果,那么就需要同时满足两个条件:</p>
<ol>
<li>w happens before r;</li>
<li>其它对 v 的写操作(w2、w3、w4, …) 要么 happens before w,要么 happens after r,绝对不会和 w、r 同时发生,或者是在它们之间发生。</li>
</ol>
<p>你可能会说,这是很显然的事情啊,但我要和你说的是,这是一个非常严格、严谨的数学定义。</p>
<p>对于单个的 goroutine 来说,它有一个特殊的 happens-before 关系,Go 内存模型中是这么讲的:</p>
<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>
<p>我来解释下这句话。它的意思是,在单个的 goroutine 内部, happens-before 的关系和代码编写的顺序是一致的。</p>
<p>我再具体解释下。</p>
<p>在 goroutine 内部对一个局部变量 v 的读,一定能观察到最近一次对这个局部变量 v 的写。如果要保证多个 goroutine 之间对一个共享变量的读写顺序,在 Go 语言中,可以使用并发原语为读写操作建立 happens-before 关系,这样就可以保证顺序了。</p>
<p>说到这儿,我想先给你补充三个 Go 语言中和内存模型有关的小知识,掌握了这些,你就能更好地理解下面的内容。</p>
<ol>
<li>在 Go 语言中,对变量进行零值的初始化就是一个写操作。</li>
<li>如果对超过机器 word(64bit、32bit 或者其它)大小的值进行读写,那么,就可以看作是对拆成 word 大小的几个读写无序进行。</li>
<li>Go 并不提供直接的 CPU 屏障(CPU fence)来提示编译器或者 CPU 保证顺序性,而是使用不同架构的内存屏障指令来实现统一的并发原语。</li>
</ol>
<p>接下来,我就带你学习下 Go 语言中提供的 happens-before 关系保证。</p>
<p>Happen-before 到底是什么?</p>
<p>本质是在用户不知道 memory barrier 概念和具体实现的前提 下，能够按照官方提供的 happen-before 正确进行并发编 程。</p>
<h2 id="go-语言中保证的-happens-before-关系">Go 语言中保证的 happens-before 关系<a hidden class="anchor" aria-hidden="true" href="#go-语言中保证的-happens-before-关系">#</a></h2>
<p>除了单个 goroutine 内部提供的 happens-before 保证,Go 语言中还提供了一些其它的 happens-before 关系的保证,下面我来一个一个介绍下。</p>
<h3 id="init-函数">init 函数<a hidden class="anchor" aria-hidden="true" href="#init-函数">#</a></h3>
<p>应用程序的初始化是在单一的 goroutine 执行的。如果包 p 导入了包 q,那么,q 的 init 函数的执行一定 happens before  p 的任何初始化代码。</p>
<p>这里有一个特殊情况需要你记住:main 函数一定在导入的包的 init 函数之后执行。</p>
<p>包级别的变量在同一个文件中是按照声明顺序逐个初始化的,除非初始化它的时候依赖其它的变量。同一个包下的多个文件,会按照文件名的排列顺序进行初始化。这个顺序被定义在Go 语言规范中,而不是 Go 的内存模型规范中。你可以看看下面的例子中各个变量的值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">b</span>  <span class="c1">// == 9
</span><span class="c1"></span>  <span class="nx">b</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>    <span class="c1">// == 4
</span><span class="c1"></span>  <span class="nx">c</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>    <span class="c1">// == 5
</span><span class="c1"></span>  <span class="nx">d</span> <span class="p">=</span> <span class="mi">3</span>      <span class="c1">// == 5 全部初始化完成后
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">d</span><span class="o">++</span>
  <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体怎么对这些变量进行初始化呢?Go 采用的是依赖分析技术。不过,依赖分析技术保证的顺序只是针对同一包下的变量,而且,只有引用关系是本包变量、函数和非接口的方法,才能保证它们的顺序性。</p>
<p>同一个包下可以有多个 init 函数,但是每个文件最多只能有一个 init 函数,多个 init 函数按照它们的文件名顺序逐个初始化。</p>
<p>刚刚讲的这些都是不同包的 init 函数执行顺序,下面我举一个具体的例子,把这些内容串起来,你一看就明白了。</p>
<p>这个例子是一个 main 程序,它依赖包 p1,包 p1 依赖包 p2,包 p2 依赖 p3。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210523235204.png" alt=""  />
</p>
<p>为了追踪初始化过程,并输出有意义的日志,我定义了一个辅助方法,打印出日志并返回一个用来初始化的整数值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Trace</span><span class="p">(</span><span class="nx">t</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>包 p3 包含两个文件,分别定义了一个 init 函数。第一个文件中定义了两个变量,这两个变量的值还会在 init 函数中进行修改。</p>
<p>我们来分别看下包 p3 的这两个文件:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// lib1.go in p3
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">V1_p3</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Trace</span><span class="p">(</span><span class="s">&#34;init v1_p3&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">V2_p3</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Trace</span><span class="p">(</span><span class="s">&#34;init v2_p3&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init func in p3&#34;</span><span class="p">)</span>
    <span class="nx">V1_p3</span> <span class="p">=</span> <span class="mi">300</span>
    <span class="nx">V2_p3</span> <span class="p">=</span> <span class="mi">300</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// lib2.go in p3
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;another init func in p3&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面再来看看包 p2。包 p2 定义了变量和 init 函数。第一个变量初始化为 2,并在 init 函数中更改为 200。第二个变量是复制的 p3.V2_p3。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">V1_p2</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Trace</span><span class="p">(</span><span class="s">&#34;init v1_p2&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">V2_p2</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Trace</span><span class="p">(</span><span class="s">&#34;init v2_p2&#34;</span><span class="p">,</span> <span class="nx">p3</span><span class="p">.</span><span class="nx">V2_p3</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init func in p2&#34;</span><span class="p">)</span>
    <span class="nx">V1_p2</span> <span class="p">=</span> <span class="mi">200</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>包 p1 定义了变量和 init 函数。它的两个变量的值是复制的 p2 对应的两个变量值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">V1_p1</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Trace</span><span class="p">(</span><span class="s">&#34;init v1_p1&#34;</span><span class="p">,</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">V1_p2</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">V2_p1</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Trace</span><span class="p">(</span><span class="s">&#34;init v2_p1&#34;</span><span class="p">,</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">V2_p2</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init func in p1&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>main 定义了 init 函数和 main 函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init func in main&#34;</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;V1_p1:&#34;</span><span class="p">,</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">V1_p1</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;V2_p1:&#34;</span><span class="p">,</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">V2_p1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行 main 函数会依次输出 p3、p2、p1、main 的初始化变量时的日志(变量初始化时的日志和 init 函数调用时的日志):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">
<span class="o">//</span> 包<span class="n">p3的变量初始化</span>
<span class="n">init</span> <span class="n">v1_p3</span> <span class="o">:</span> <span class="m">3</span>
<span class="n">init</span> <span class="n">v2_p3</span> <span class="o">:</span> <span class="m">3</span>
<span class="o">//</span> <span class="n">p3的init函数</span>
<span class="n">init</span> <span class="n">func</span> <span class="n">in</span> <span class="n">p3</span>
<span class="o">//</span> <span class="n">p3的另一个init函数</span>
<span class="n">another</span> <span class="n">init</span> <span class="n">func</span> <span class="n">in</span> <span class="n">p3</span>

<span class="o">//</span> 包<span class="n">p2的变量初始化</span>
<span class="n">init</span> <span class="n">v1_p2</span> <span class="o">:</span> <span class="m">2</span>
<span class="n">init</span> <span class="n">v2_p2</span> <span class="o">:</span> <span class="m">300</span>
<span class="o">//</span> 包<span class="n">p2的init函数</span>
<span class="n">init</span> <span class="n">func</span> <span class="n">in</span> <span class="n">p2</span>

<span class="o">//</span> 包<span class="n">p1的变量初始化</span>
<span class="n">init</span> <span class="n">v1_p1</span> <span class="o">:</span> <span class="m">200</span>
<span class="n">init</span> <span class="n">v2_p1</span> <span class="o">:</span> <span class="m">300</span>
<span class="o">//</span> 包<span class="n">p1的init函数</span>
<span class="n">init</span> <span class="n">func</span> <span class="n">in</span> <span class="n">p1</span>

<span class="o">//</span> 包<span class="n">main的init函数</span>
<span class="n">init</span> <span class="n">func</span> <span class="n">in</span> <span class="n">main</span>
<span class="o">//</span> <span class="n">main函数</span>
<span class="n">V1_p1</span><span class="o">:</span> <span class="m">200</span>
<span class="n">V2_p1</span><span class="o">:</span> <span class="m">300</span>
</code></pre></td></tr></table>
</div>
</div><p>下面,我们再来看看 goroutine 对 happens-before 关系的保证情况。</p>
<h3 id="goroutine">goroutine<a hidden class="anchor" aria-hidden="true" href="#goroutine">#</a></h3>
<p>首先,我们需要明确一个规则:启动 goroutine 的 go 语句的执行,一定 happens before 此 goroutine 内的代码执行。</p>
<p>根据这个规则,我们就可以知道,如果 go 语句传入的参数是一个函数执行的结果,那么,这个函数一定先于 goroutine 内部的代码被执行。</p>
<p>同一个 goroutine 内的逻辑有依赖的语句执行，满足顺序关系。</p>
<p>编译器/CPU 可能对同一个 goroutine 中的语句执行进行打 乱，以提高性能，但不能破坏其应用原有的逻辑。</p>
<p>不同的 goroutine 观察到的共享变量的修改顺序可能不一样。</p>
<p>Goroutine 的创建(creation)一定先于 goroutine 的执行 (execution)</p>
<p>我们来看一个例子。在下面的代码中,第 8 行 a 的赋值和第 9 行的 go 语句是在同一个 goroutine 中执行的,所以,在主 goroutine 看来,第 8 行肯定 happens before 第 9 行,又由于刚才的保证,第 9 行子 goroutine 的启动 happens before 第 4 行的变量输出,那么,我们就可以推断出,第 8 行 happens before 第 4 行。也就是说,在第 4 行打印 a 的值的时候,肯定会打印出“hello world”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">var</span> <span class="nx">a</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
  <span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>刚刚说的是启动 goroutine 的情况,goroutine 退出的时候,是没有任何 happensbefore 保证的。所以,如果你想观察某个 goroutine 的执行效果,你需要使用同步机制建立 happens-before 关系,比如 Mutex 或者 Channel。接下来,我会讲 Channel 的 happens-before 的关系保证。</p>
<p>在没有显式同步的情况下，goroutine 的结束没有任何保证， 可能被执行，也可能不被执行</p>
<h3 id="channel">Channel<a hidden class="anchor" aria-hidden="true" href="#channel">#</a></h3>
<p>Channel 是 goroutine 同步交流的主要方法。往一个 Channel 中发送一条数据,通常对应着另一个 goroutine 从这个 Channel 中接收一条数据。</p>
<p>通用的 Channel happens-before 关系保证有 4 条规则,我分别来介绍下。</p>
<p>第 1 条规则是,往 Channel 中的发送操作,happens before 从该 Channel 接收相应数据的动作完成之前,即第 n 个 send 一定 happens before 第 n 个 receive 的完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">// buffered或者unbuffered
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
  <span class="o">&lt;-</span><span class="nx">ch</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个例子中,s 的初始化(第 5 行)happens before 往 ch 中发送数据, 往 ch 发送数据 happens before 从 ch 中读取出一条数据(第 11 行),第 12 行打印 s 的值 happens after 第 11 行,所以,打印的结果肯定是初始化后的 s 的值“hello world”。</p>
<p>第 2 条规则是,close 一个 Channel 的调用,肯定 happens before 从关闭的 Channel 中读取出一个零值。</p>
<p>还是拿刚刚的这个例子来说,如果你把第 6 行替换成 close(ch),也能保证同样的执行顺序。因为第 11 行从关闭的 ch 中读取出零值后,第 6 行肯定被调用了。</p>
<p>第 3 条规则是,对于 unbuffered 的 Channel,也就是容量是 0 的 Channel,从此 Channel 中读取数据的调用一定 happens before 往此 Channel 发送数据的调用完成。</p>
<p>所以,在上面的这个例子中呢,如果想保持同样的执行顺序,也可以写成这样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">var</span> <span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
  <span class="o">&lt;-</span><span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果第 11 行发送语句执行成功(完毕),那么根据这个规则,第 6 行(接收)的调用肯定发生了(执行完成不完成不重要,重要的是这一句“肯定执行了”),那么 s 也肯定初始化了,所以一定会打印出“hello world”。</p>
<p>这一条比较晦涩,但是,因为 Channel 是 unbuffered 的 Channel,所以这个规则也成立。</p>
<p>第 4 条规则是,如果 Channel 的容量是 m(m&gt;0),那么,第 n 个 receive 一定 happens before 第 n+m 个 send 的完成。</p>
<p>前一条规则是针对 unbuffered channel 的,这里给出了更广泛的针对 buffered channel 的保证。利用这个规则,我们可以实现信号量(Semaphore)的并发原语。Channel 的容量相当于可用的资源,发送一条数据相当于请求信号量,接收一条数据相当于释放信号。</p>
<h3 id="mutexrwmutex">Mutex/RWMutex<a hidden class="anchor" aria-hidden="true" href="#mutexrwmutex">#</a></h3>
<p>对于互斥锁 Mutex m 或者读写锁 RWMutex m,有 3 条 happens-before 关系的保证。</p>
<ol>
<li>第 n 次的 l.Unlock,那么,和这个 RLock 相对应的 l.RUnlock 一定 happens 第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock 方法的返回; 1.</li>
<li>对于读写锁 RWMutex m,如果它的第 n 个 m.Lock 方法的调用已返回,那么它的第 n 个 m.Unlock 的方法调用一定 happens before 任何一个 m.RLock 方法调用的返回, 只要这些 m.RLock 方法调用 happens after 第 n 次 m.Lock 的调用的返回。这就可以保证,只有释放了持有的写锁,那些等待的读请求才能请求到读锁。</li>
<li>对于读写锁 RWMutex m,如果它的第 n 个 m.RLock 方法的调用已返回,那么它的第 k (k&lt;=n)个成功的 m.RUnlock 方法的返回一定 happens before 任意的 m.RUnlockLock 方法调用,只要这些 m.Lock 方法调用 happens after 第 n 次 m.RLock。</li>
</ol>
<p>读写锁的保证有点绕,我再带你看看官方的描述:</p>
<p>对于读写锁 l 的 l.RLock 方法调用,如果存在一个 n,这次的 l.RLock 调用 happens after第 n 次的 l.Unlock,那么,和这个 RLock 相对应的 l.RUnlock 一定 happens before 第 n+1 次 l.Lock。意思是,读写锁的 Lock 必须等待既有的读锁释放后才能获取到。</p>
<p>我再举个例子。在下面的代码中,第 6 行第一次的 Unlock 一定 happens before 第二次的 Lock(第 12 行),所以这也能保证正确地打印出“hello world”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">go</span> <span class="nf">foo</span><span class="p">()</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="waitgroup">WaitGroup<a hidden class="anchor" aria-hidden="true" href="#waitgroup">#</a></h3>
<p>接下来是 WaitGroup 的保证。</p>
<p>对于一个 WaitGroup 实例 wg,在某个时刻 t0 时,它的计数值已经不是零了,假如 t0 时刻之后调用了一系列的 wg.Add(n) 或者 wg.Done(),并且只有最后一次调用 wg 的计数值变为了 0,那么,可以保证这些 wg.Add 或者 wg.Done() 一定 happens before t0 时刻之后调用的 wg.Wait 方法的返回。</p>
<p>这个保证的通俗说法,就是 Wait 方法等到计数值归零之后才返回。</p>
<h3 id="once">Once<a hidden class="anchor" aria-hidden="true" href="#once">#</a></h3>
<p>它提供的保证是:对于 once.Do(f) 调用,f 函数的那个单次调用一定 happens before 任何 once.Do(f) 调用的返回。换句话说,就是函数 f 一定会在 Do 方法返回之前执行。</p>
<p>还是以 hello world 的例子为例,这次我们使用 Once 并发原语实现,可以看下下面的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;hello, world&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">twoprint</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">foo</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第 5 行的执行一定 happens before 第 9 行的返回,所以执行到第 10 行的时候,sd 已经初始化了,所以会正确地打印“hello world”。</p>
<p>最后,我再来说说 atomic 的保证。</p>
<h3 id="atomic">atomic<a hidden class="anchor" aria-hidden="true" href="#atomic">#</a></h3>
<p>其实,Go 内存模型的官方文档并没有明确给出 atomic 的保证,有一个相关的 issue go# 5045记录了相关的讨论。光看 issue 号,就知道这个讨论由来已久了。Russ Cox 想让 atomic 有一个弱保证,这样可以为以后留下充足的可扩展空间,所以,Go 内存模型规范上并没有严格的定义。</p>
<p>对于 Go 1.15 的官方实现来说,可以保证使用 atomic 的 Load/Store 的变量之间的顺序性。</p>
<p>在下面的例子中,打印出的 a 的结果总是 1,但是官方并没有做任何文档上的说明和保证。</p>
<p>依照 Ian Lance Taylor 的说法,Go 核心开发组的成员几乎没有关注这个方向上的研究, 因为这个问题太复杂,有很多问题需要去研究,所以,现阶段还是不要使用 atomic 来保证顺序性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">Gosched</span><span class="p">()</span>
  <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Ian Lance Taylor曾经在论坛中说:</p>
<p>In C++ memory model terms I believe that the sync/atomic Load
operations are memory_order_acquire, and I believe that the
sync/atomic Store operations are memory_order_release. It&rsquo;s possible
that if we ever document it we will go for stronger memory ordering,
but I believe that these operations must at least carry those guarantees.</p>
<p>I&rsquo;m somewhat less certain of the memory order guarantees of the Swap,
CompareAndSwap, and Add functions. I guess that Swap and
CompareAndSwap are probably at least memory_order_acq_rel, but Add may
be memory_order_relaxed.</p>
<p>Russ Cox曾经回答过问题,他把go的atomic 操作定位sequential consistency的，这是一个更严格的memory ordering。它们之前的读写操作,不会重排在Load/Store之后， 它们之后的读写操作也不会重排在Load/Store之前，所以建立了一个内存屏障(Memory barrier)。</p>
<p>rsc
2019年7月16日上午9:12:01</p>
<p>Although there&rsquo;s been no official resolution to the issue, I think the actual path forward is what I posted a while back: &ldquo;Go&rsquo;s atomics guarantee sequential consistency among the atomic variables (behave like C/C++&rsquo;s seqconst atomics), and that you shouldn&rsquo;t mix atomic and non-atomic accesses for a given memory word.&rdquo;</p>
<p>至少目前，我们可以按照他们的解答进行理解。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>Go 的内存模型规范中,一开始有这么一段话:</p>
<p>If you must read the rest of this document to understand the behavior of your program, you are being too clever.</p>
<p>Don’t be clever.</p>
<p>理解你的程序的行为是聪明的,但是, 不要自作聪明。</p>
<p>谨慎地使用这些保证,能够让你的程序按照设想的 happens-before 关系执行,但是不要以为完全理解这些概念和保证,就可以随意地制造所谓的各种技巧,否则就很容易掉进“坑”里,而且会给代码埋下了很多的“定时炸弹”。</p>
<p>比如,Go 里面已经有值得信赖的互斥锁了,如果没有额外的需求,就不要使用 Channel 创造出自己的互斥锁。</p>
<p>当然,我也不希望你畏手畏脚地把思想局限住,我还是建议你去做一些有意义的尝试,比如使用 Channel 实现信号量等扩展并发原语。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
