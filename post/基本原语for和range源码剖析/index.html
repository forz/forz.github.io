<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>基本原语for和range源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="汇编 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADfor%E5%92%8Crange%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="基本原语for和range源码剖析" />
<meta property="og:description" content="汇编 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADfor%E5%92%8Crange%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-14T22:03:44&#43;00:00" />
<meta property="article:modified_time" content="2021-06-14T22:03:44&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="基本原语for和range源码剖析"/>
<meta name="twitter:description" content="汇编 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "基本原语for和range源码剖析",
      "item": "/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADfor%E5%92%8Crange%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基本原语for和range源码剖析",
  "name": "基本原语for和range源码剖析",
  "description": "汇编 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "汇编 循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，\nfor 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用相同的处理逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main func main() { for i := 0; i  10; i++ { println(i) } } \"\".main STEXT size=98 args=0x0 locals=0x18 00000 (main.go:3)\tTEXT\t\"\".main(SB), $24-0 ... 00029 (main.go:3)\tXORL\tAX, AX ;; i := 0 00031 (main.go:4)\tJMP\t75 00033 (main.go:4)\tMOVQ\tAX, \"\".i+8(SP) 00038 (main.go:5)\tCALL\truntime.printlock(SB) 00043 (main.go:5)\tMOVQ\t\"\".i+8(SP), AX 00048 (main.go:5)\tMOVQ\tAX, (SP) 00052 (main.go:5)\tCALL\truntime.printint(SB) 00057 (main.go:5)\tCALL\truntime.printnl(SB) 00062 (main.go:5)\tCALL\truntime.printunlock(SB) 00067 (main.go:4)\tMOVQ\t\"\".i+8(SP), AX 00072 (main.go:4)\tINCQ\tAX ;; i++ 00075 (main.go:4)\tCMPQ\tAX, $10 ;; 比较变量 i 和 10 00079 (main.go:4)\tJLT\t33 ;; 跳转到 33 行如果 i  10 ...   这里将上述汇编指令的执行过程分成三个部分进行分析：\n 0029 ~ 0031 行负责循环的初始化；  对寄存器 AX 中的变量 i 进行初始化并执行 JMP 75 指令跳转到 0075 行；   0075 ~ 0079 行负责检查循环的终止条件，将寄存器中存储的数据 i 与 10 比较；  JLT 33 命令会在变量的值小于 10 时跳转到 0033 行执行循环主体； JLT 33 命令会在变量的值大于 10 时跳出循环体执行下面的代码；   0033 ~ 0072 行是循环内部的语句；  通过多个汇编指令打印变量中的内容； INCQ AX 指令会将变量加一，然后再与 10 进行比较，回到第二步；    经过优化的 for-range 循环的汇编代码有着相同的结构。无论是变量的初始化、循环体的执行还是最后的条件判断都是完全一样的，所以这里也就不展开分析对应的汇编指令了。\n1 2 3 4 5 6 7 8  package main func main() { arr := []int{1, 2, 3} for i, _ := range arr { println(i) } }   在汇编语言中，无论是经典的 for 循环还是 for-range 循环都会使用 JMP 等命令跳回循环体的开始位置复用代码。从不同循环具有相同的汇编代码可以猜到，使用 for-range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环，后面的分析也会印证这一点。\n现象 在深入语言源代码了解两种不同循环的实现之前，我们可以先来看一下使用 for 和 range 会遇到的一些问题，我们可以带着问题去源代码中寻找答案，这样能更高效地理解它们的实现原理。\n循环永动机 如果我们在遍历数组的同时修改数组的元素，能否得到一个永远都不会停止的循环呢？你可以尝试运行下面的代码：\n1 2 3 4 5 6 7  func main() { arr := []int{1, 2, 3} for _, v := range arr { arr = append(arr, v) } fmt.Println(arr) }   1 2  $ go run main.go 1 2 3 1 2 3   上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。\n神奇的指针 第二个例子是使用 Go 语言经常会犯的错误1。当我们在遍历一个数组时，如果获取 range 返回变量的地址并保存到另一个数组或者哈希时，会遇到令人困惑的现象，下面的代码会输出 “3 3 3”：\n1 2 3 4 5 6 7 8 9 10  func main() { arr := []int{1, 2, 3} newArr := []*int{} for _, v := range arr { newArr = append(newArr, \u0026v) } for _, v := range newArr { fmt.Println(*v) } }   1 2  $ go run main.go 3 3 3   一些有经验的开发者不经意也会犯这种错误，正确的做法应该是使用 \u0026arr[i] 替代 \u0026v，我们会在下面分析这一现象背后的原因。\n遍历清空数组 当我们想要在 Go 语言中清空一个切片或者哈希时，一般都会使用以下的方法将切片中的元素置零：\n1 2 3 4 5 6  func main() { arr := []int{1, 2, 3} for i, _ := range arr { arr[i] = 0 } }   依次遍历切片和哈希看起来是非常耗费性能的，因为数组、切片和哈希占用的内存空间都是连续的，所以最快的方法是直接清空这片内存中的内容，当我们编译上述代码时会得到以下的汇编指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \"\".main STEXT size=93 args=0x0 locals=0x30 0x0000 00000 (main.go:3)\tTEXT\t\"\".main(SB), $48-0 ... 0x001d 00029 (main.go:4)\tMOVQ\t\"\".statictmp_0(SB), AX 0x0024 00036 (main.go:4)\tMOVQ\tAX, \"\"..autotmp_3+16(SP) 0x0029 00041 (main.go:4)\tMOVUPS\t\"\".statictmp_0+8(SB), X0 0x0030 00048 (main.go:4)\tMOVUPS\tX0, \"\"..autotmp_3+24(SP) 0x0035 00053 (main.go:5)\tPCDATA\t$2, $1 0x0035 00053 (main.go:5)\tLEAQ\t\"\"..autotmp_3+16(SP), AX 0x003a 00058 (main.go:5)\tPCDATA\t$2, $0 0x003a 00058 (main.go:5)\tMOVQ\tAX, (SP) 0x003e 00062 (main.go:5)\tMOVQ\t$24, 8(SP) 0x0047 00071 (main.go:5)\tCALL\truntime.memclrNoHeapPointers(SB) ...   从生成的汇编代码我们可以看出，编译器会直接使用 runtime.memclrNoHeapPointers 清空切片中的数据，这也是我们在下面的小节会介绍的内容。\n随机遍历 当我们在 Go 语言中使用 range 遍历哈希表时，往往都会使用如下的代码结构，但是这段代码在每次运行时都会打印出不同的结果：\n1 2 3 4 5 6 7 8 9 10  func main() { hash := map[string]int{ \"1\": 1, \"2\": 2, \"3\": 3, } for k, v := range hash { println(k, v) } }   两次运行上述代码可能会得到不同的结果，第一次会打印 2 3 1，第二次会打印 1 2 3，如果我们运行的次数足够多，最后会得到几种不同的遍历顺序。\n1 2 3 4 5 6 7 8 9  $ go run main.go 2 2 3 3 1 1 $ go run main.go 1 1 2 2 3 3   Go 语言在运行时为哈希表的遍历引入了不确定性，也是告诉所有 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历，我们在下面的小节会介绍在遍历的过程是如何引入不确定性的。\n经典循环 Go 语言中的经典循环在编译器看来是一个 OFOR 类型的节点，这个节点由以下四个部分组成：\n 初始化循环的 Ninit； 循环的继续条件 Left； 循环体结束时执行的 Right； 循环体 NBody：  1 2 3  for Ninit; Left; Right { NBody }   在生成 SSA 中间代码的阶段，cmd/compile/internal/gc.state.stmt 方法在发现传入的节点类型是 OFOR 时会执行以下的代码块，这段代码会将循环中的代码分成不同的块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func (s *state) stmt(n*Node) { switch n.Op { case OFOR, OFORUNTIL: bCond, bBody, bIncr, bEnd := ... b := s.endBlock() b.AddEdgeTo(bCond) s.startBlock(bCond) s.condBranch(n.Left, bBody, bEnd, 1) s.startBlock(bBody) s.stmtList(n.Nbody) b.AddEdgeTo(bIncr) s.startBlock(bIncr) s.stmt(n.Right) b.AddEdgeTo(bCond) s.startBlock(bEnd) } }   一个常见的 for 循环代码会被 cmd/compile/internal/gc.state.stmt 转换成下面的控制结构，该结构中包含了 4 个不同的块，这些代码块之间的连接表示汇编语言中的跳转关系，与我们理解的 for 循环控制结构没有太多的差别。\n机器码生成阶段会将这些代码块转换成机器码，以及指定 CPU 架构上运行的机器语言，就是我们在前面编译得到的汇编指令。\n范围循环 与简单的经典循环相比，范围循环在 Go 语言中更常见、实现也更复杂。这种循环同时使用 for 和 range 两个关键字，编译器会在编译期间将所有 for-range 循环变成经典循环。从编译器的视角来看，就是将 ORANGE 类型的节点转换成 OFOR 节点:\n节点类型的转换过程都发生在中间代码生成阶段，所有的 for-range 循环都会被 cmd/compile/internal/gc.walkrange 转换成不包含复杂结构、只包含基本表达式的语句。接下来，我们按照循环遍历的元素类型依次介绍遍历数组和切片、哈希表、字符串以及管道时的过程。\nfor-range其实是语法糖，内部调用还是for循环，初始化会拷贝带遍历的列表（如array，slice，map），然后每次遍历的v都是对同一个元素的遍历赋值。\n数组和切片 对于数组和切片来说，Go 语言有三种不同的遍历方式，这三种不同的遍历方式分别对应着代码中的不同条件，它们会在 cmd/compile/internal/gc.walkrange 函数中转换成不同的控制逻辑，我们会分成几种情况分析该函数的逻辑：\n 分析遍历数组和切片清空元素的情况； 分析使用 for range a {} 遍历数组和切片，不关心索引和数据的情况； 分析使用 for i := range a {} 遍历数组和切片，只关心索引的情况； 分析使用 for i, elem := range a {} 遍历数组和切片，关心索引和数据的情况；  1 2 3 4 5 6  func walkrange(n *Node)*Node { switch t.Etype { case TARRAY, TSLICE: if arrayClear(n, v1, v2, a) { return n }   cmd/compile/internal/gc.arrayClear 是一个非常有趣的优化，它会优化 Go 语言遍历数组或者切片并删除全部元素的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12  // 原代码 for i := range a { a[i] = zero } // 优化后 if len(a) != 0 { hp = \u0026a[0] hn = len(a)*sizeof(elem(a)) memclrNoHeapPointers(hp, hn) i = len(a) - 1 }   相比于依次清除数组或者切片中的数据，Go 语言会直接使用 runtime.memclrNoHeapPointers 或者 runtime.memclrHasPointers 清除目标数组内存空间中的全部数据，并在执行完成后更新遍历数组的索引，这也印证了我们在遍历清空数组一节中观察到的现象。\n处理了这种特殊的情况之后，我们可以回到 ORANGE 节点的处理过程了。这里会设置 for 循环的 Left 和 Right 字段，也就是终止条件和循环体每次执行结束后运行的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ha := a hv1 := temp(types.Types[TINT]) hn := temp(types.Types[TINT]) init = append(init, nod(OAS, hv1, nil)) init = append(init, nod(OAS, hn, nod(OLEN, ha, nil))) n.Left = nod(OLT, hv1, hn) n.Right = nod(OAS, hv1, nod(OADD, hv1, nodintconst(1))) if v1 == nil { break }   如果循环是 for range a {}，那么就满足了上述代码中的条件 v1 == nil，即循环不关心数组的索引和数据，这种循环会被编译器转换成如下形式：\n1 2 3 4 5 6 7  ha := a hv1 := 0 hn := len(ha) v1 := hv1 for ; hv1  hn; hv1++ { ... }   这是 ORANGE 结构在编译期间被转换的最简单形式，由于原代码不需要获取数组的索引和元素，只需要使用数组或者切片的数量执行对应次数的循环，所以会生成一个最简单的 for 循环。\n如果我们在遍历数组时需要使用索引 for i := range a {}，那么编译器会继续会执行下面的代码：\n1 2 3 4  if v2 == nil { body = []*Node{nod(OAS, v1, hv1)} break }   v2 == nil 意味着调用方不关心数组的元素，只关心遍历数组使用的索引。它会将 for i := range a {} 转换成下面的逻辑，与第一种循环相比，这种循环在循环体中添加了 v1 := hv1 语句，传递遍历数组时的索引：\n1 2 3 4 5 6 7 8  ha := a hv1 := 0 hn := len(ha) v1 := hv1 for ; hv1  hn; hv1++ { v1 = hv1 ... }   上面两种情况虽然也是使用 range 会经常遇到的情况，但是同时去遍历索引和元素也很常见。处理这种情况会使用下面这段的代码：\n1 2 3 4 5 6 7 8 9 10 11 12  tmp := nod(OINDEX, ha, hv1) tmp.SetBounded(true) a := nod(OAS2, nil, nil) a.List.Set2(v1, v2) a.Rlist.Set2(hv1, tmp) body = []*Node{a} } n.Ninit.Append(init...) n.Nbody.Prepend(body...) return n }   这段代码处理的使用者同时关心索引和切片的情况。它不仅会在循环体中插入更新索引的语句，还会插入赋值操作让循环体内部的代码能够访问数组中的元素：\n1 2 3 4 5 6 7 8 9 10  ha := a hv1 := 0 hn := len(ha) v1 := hv1 v2 := nil for ; hv1  hn; hv1++ { tmp := ha[hv1] v1, v2 = hv1, tmp ... }   对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新变量 ha，在赋值的过程中就发生了拷贝，而我们又通过 len 关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环执行的次数，这也就解释了循环永动机一节提到的现象。\n而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝。\n1 2 3 4 5 6 7 8 9 10  func main() { arr := []int{1, 2, 3} newArr := []*int{} for i, _ := range arr { newArr = append(newArr, \u0026arr[i]) } for _, v := range newArr { fmt.Println(*v) } }   因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。因此当我们想要访问数组中元素所在的地址时，不应该直接获取 range 返回的变量地址 \u0026v2，而应该使用 \u0026a[index] 这种形式。\n哈希表 在遍历哈希表时，编译器会使用 runtime.mapiterinit 和 runtime.mapiternext 两个运行时函数重写原始的 for-range 循环：\n1 2 3 4 5 6 7 8  ha := a hit := hiter(n.Type) th := hit.Type mapiterinit(typename(t), ha, \u0026hit) for ; hit.key != nil; mapiternext(\u0026hit) { key := *hit.key val :=*hit.val }   上述代码是展开 for key, val := range hash {} 后的结果，在 cmd/compile/internal/gc.walkrange 处理 TMAP 节点时，编译器会根据 range 返回值的数量在循环体中插入需要的赋值语句：\n这三种不同的情况分别向循环体插入了不同的赋值语句。遍历哈希表时会使用 runtime.mapiterinit 函数初始化遍历开始的元素：\n1 2 3 4 5 6 7 8 9 10 11 12  func mapiterinit(t *maptype, h*hmap, it *hiter) { it.t = t it.h = h it.B = h.B it.buckets = h.buckets r := uintptr(fastrand()) it.startBucket = r \u0026 bucketMask(h.B) it.offset = uint8(r  h.B \u0026 (bucketCnt - 1)) it.bucket = it.startBucket mapiternext(it) }   该函数会初始化 runtime.hiter 结构体中的字段，并通过 runtime.fastrand 生成一个随机数帮助我们随机选择一个遍历桶的起始位置。Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。\n遍历哈希会使用 runtime.mapiternext，我们在这里简化了很多逻辑，省去了一些边界条件以及哈希表扩容时的兼容操作，这里只需要关注处理遍历逻辑的核心代码，我们会将该函数分成桶的选择和桶内元素的遍历两部分，首先是桶的选择过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func mapiternext(it *hiter) { h := it.h t := it.t bucket := it.bucket b := it.bptr i := it.i alg := t.key.alg next: if b == nil { if bucket == it.startBucket \u0026\u0026 it.wrapped { it.key = nil it.value = nil return } b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) bucket++ if bucket == bucketShift(it.B) { bucket = 0 it.wrapped = true } i = 0 }   这段代码主要有两个作用：\n 在待遍历的桶为空时，选择需要遍历的新桶； 在不存在待遍历的桶时。返回 (nil, nil) 键值对并中止遍历；  runtime.mapiternext 剩余代码的作用是从桶中找到下一个遍历的元素，在大多数情况下都会直接操作内存获取目标键值的内存地址，不过如果哈希表处于扩容期间就会调用 runtime.mapaccessK 获取键值对：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  for ; i  bucketCnt; i++ { offi := (i + it.offset) \u0026 (bucketCnt - 1) k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize)) if (b.tophash[offi] != evacuatedX \u0026\u0026 b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || alg.equal(k, k)) { it.key = k it.value = v } else { rk, rv := mapaccessK(t, h, k) it.key = rk it.value = rv } it.bucket = bucket it.i = i + 1 return } b = b.overflow(t) i = 0 goto next }   当上述函数已经遍历了正常桶后，会通过 runtime.bmap.overflow 遍历哈希中的溢出桶。\n简单总结一下哈希表遍历的顺序，首先会选出一个绿色的正常桶开始遍历，随后遍历所有黄色的溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。\n字符串 遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 rune。我们在遍历字符串时拿到的值都是 rune 类型的变量，for i, r := range s {} 的结构都会被转换成如下所示的形式：\n1 2 3 4 5 6 7 8 9 10 11  ha := s for hv1 := 0; hv1  len(ha); { hv1t := hv1 hv2 := rune(ha[hv1]) if hv2  utf8.RuneSelf { hv1++ } else { hv2, hv1 = decoderune(ha, hv1) } v1, v2 = hv1t, hv2 }   在前面的字符串一节中我们曾经介绍过字符串是一个只读的字节数组切片，所以范围循环在编译期间生成的框架与切片非常类似，只是细节有一些不同。\n首先仍然和遍历数组和切片一样，会对原对象进行一次拷贝，接下来开始使用传统三段式遍历方式进行遍历，接下来其把当前遍历到的字节（字符串底层类似为byte数组）转换为rune类型，然后判断该rune类型是否为utf8码点，如果判断为true，则代表当前的rune是一个ASCII字符，此时索引仅+1即可，如果为false，需要将其转换为对应长度的rune字符并且对应索引也会随之增加，随后，赋值给v1,v1即for k, v := range str 的k和v。至此，字符串的遍历也讲完了，主要就是针对utf8码点进行了索引递增，每个中文字符占用3个byte长度。\ndecoderune函数的功能就是返回 s[k:]开头的非 ASCII 符文和 s 中符文后的索引。其中，s为传入的字符串，k为索引\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // decoderune returns the non-ASCII rune at the start of // s[k:] and the index after the rune in s. // // decoderune assumes that caller has checked that // the to be decoded rune is a non-ASCII rune. // // If the string appears to be incomplete or decoding problems // are encountered (runeerror, k + 1) is returned to ensure // progress when decoderune is used to iterate over a string. func decoderune(s string, k int) (r rune, pos int) { pos = k if k = len(s) { return runeError, k + 1 } s = s[k:] switch { case t2  s[0] \u0026\u0026 s[0]  t3: // 0080-07FF two byte sequence \tif len(s)  1 \u0026\u0026 (locb  s[1] \u0026\u0026 s[1]  hicb) { r = rune(s[0]\u0026mask2)6 | rune(s[1]\u0026maskx) pos += 2 if rune1Max  r { return } } case t3  s[0] \u0026\u0026 s[0]  t4: // 0800-FFFF three byte sequence \tif len(s)  2 \u0026\u0026 (locb  s[1] \u0026\u0026 s[1]  hicb) \u0026\u0026 (locb  s[2] \u0026\u0026 s[2]  hicb) { r = rune(s[0]\u0026mask3)12 | rune(s[1]\u0026maskx)6 | rune(s[2]\u0026maskx) pos += 3 if rune2Max  r \u0026\u0026 !(surrogateMin  r \u0026\u0026 r  surrogateMax) { return } } case t4  s[0] \u0026\u0026 s[0]  t5: // 10000-1FFFFF four byte sequence \tif len(s)  3 \u0026\u0026 (locb  s[1] \u0026\u0026 s[1]  hicb) \u0026\u0026 (locb  s[2] \u0026\u0026 s[2]  hicb) \u0026\u0026 (locb  s[3] \u0026\u0026 s[3]  hicb) { r = rune(s[0]\u0026mask4)18 | rune(s[1]\u0026maskx)12 | rune(s[2]\u0026maskx)6 | rune(s[3]\u0026maskx) pos += 4 if rune3Max  r \u0026\u0026 r  maxRune { return } } } return runeError, k + 1 }   通道 使用 range 遍历 Channel 也是比较常见的做法，一个形如 for v := range ch {} 的语句最终会被转换成如下的格式：\n1 2 3 4 5 6 7  ha := a hv1, hb := ha for ; hb != false; hv1, hb = ha { v1 := hv1 hv1 = nil ... }   这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用  从管道中取出等待处理的值，这个操作会调用 runtime.chanrecv2 并阻塞当前的协程，当 runtime.chanrecv2 返回时会根据布尔值 hb 判断当前的值是否存在：\n 如果不存在当前值，意味着当前的管道已经被关闭； 如果存在当前值，会为 v1 赋值并清除 hv1 变量中的数据，然后重新陷入阻塞等待新数据；  小结 这一节介绍的两个关键字 for 和 range 都是我们在学习和使用 Go 语言中无法绕开的，通过分析和研究它们的底层原理，让我们对实现细节有了更清楚的认识，包括 Go 语言遍历数组和切片时会复用变量、哈希表的随机遍历原理以及底层的一些优化，这都能帮助我们更好地理解和使用 Go 语言。\n转载 5.1 for 和 range\n",
  "wordCount" : "5942",
  "inLanguage": "zh-cn",
  "datePublished": "2021-06-14T22:03:44Z",
  "dateModified": "2021-06-14T22:03:44Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADfor%E5%92%8Crange%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      基本原语for和range源码剖析
    </h1>
    <div class="post-meta">June 14, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="汇编">汇编<a hidden class="anchor" aria-hidden="true" href="#汇编">#</a></h2>
<p>循环是所有编程语言都有的控制结构，除了使用经典的三段式循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历数组、切片、哈希表以及 Channel 等集合类型。本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，</p>
<p>for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用相同的处理逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">size</span><span class="p">=</span><span class="mi">98</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x18</span>
	<span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">TEXT</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="err">$</span><span class="mi">24</span><span class="o">-</span><span class="mi">0</span>
	<span class="o">...</span>
	<span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>	<span class="nx">XORL</span>	<span class="nx">AX</span><span class="p">,</span> <span class="nx">AX</span>                   <span class="p">;;</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="mo">00031</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">JMP</span>	<span class="mi">75</span>
	<span class="mo">00033</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">i</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="mo">0003</span><span class="mi">8</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">printlock</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mo">00043</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">i</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="mo">0004</span><span class="mi">8</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="mo">00052</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">printint</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mo">00057</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">printnl</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mo">00062</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">printunlock</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="mo">00067</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">i</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="mo">00072</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">INCQ</span>	<span class="nx">AX</span>                       <span class="p">;;</span> <span class="nx">i</span><span class="o">++</span>
	<span class="mo">00075</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">CMPQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mi">10</span>                  <span class="p">;;</span> <span class="nx">比较变量</span> <span class="nx">i</span> <span class="nx">和</span> <span class="mi">10</span>
	<span class="mo">0007</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>	<span class="nx">JLT</span>	<span class="mi">33</span>                           <span class="p">;;</span> <span class="nx">跳转到</span> <span class="mi">33</span> <span class="nx">行如果</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span>
	<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>这里将上述汇编指令的执行过程分成三个部分进行分析：</p>
<ol>
<li>0029 ~ 0031 行负责循环的初始化；
<ol>
<li>对寄存器 AX 中的变量 i 进行初始化并执行 JMP 75 指令跳转到 0075 行；</li>
</ol>
</li>
<li>0075 ~ 0079 行负责检查循环的终止条件，将寄存器中存储的数据 i 与 10 比较；
<ol>
<li>JLT 33 命令会在变量的值小于 10 时跳转到 0033 行执行循环主体；</li>
<li>JLT 33 命令会在变量的值大于 10 时跳出循环体执行下面的代码；</li>
</ol>
</li>
<li>0033 ~ 0072 行是循环内部的语句；
<ol>
<li>通过多个汇编指令打印变量中的内容；</li>
<li>INCQ AX 指令会将变量加一，然后再与 10 进行比较，回到第二步；</li>
</ol>
</li>
</ol>
<p>经过优化的 for-range 循环的汇编代码有着相同的结构。无论是变量的初始化、循环体的执行还是最后的条件判断都是完全一样的，所以这里也就不展开分析对应的汇编指令了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在汇编语言中，无论是经典的 for 循环还是 for-range 循环都会使用 JMP 等命令跳回循环体的开始位置复用代码。从不同循环具有相同的汇编代码可以猜到，使用 for-range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环，后面的分析也会印证这一点。</p>
<h2 id="现象">现象<a hidden class="anchor" aria-hidden="true" href="#现象">#</a></h2>
<p>在深入语言源代码了解两种不同循环的实现之前，我们可以先来看一下使用 for 和 range 会遇到的一些问题，我们可以带着问题去源代码中寻找答案，这样能更高效地理解它们的实现原理。</p>
<h3 id="循环永动机">循环永动机<a hidden class="anchor" aria-hidden="true" href="#循环永动机">#</a></h3>
<p>如果我们在遍历数组的同时修改数组的元素，能否得到一个永远都不会停止的循环呢？你可以尝试运行下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。</p>
<h3 id="神奇的指针">神奇的指针<a hidden class="anchor" aria-hidden="true" href="#神奇的指针">#</a></h3>
<p>第二个例子是使用 Go 语言经常会犯的错误1。当我们在遍历一个数组时，如果获取 range 返回变量的地址并保存到另一个数组或者哈希时，会遇到令人困惑的现象，下面的代码会输出 “3 3 3”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">newArr</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
		<span class="nx">newArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newArr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newArr</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">3</span> <span class="m">3</span> <span class="m">3</span>
</code></pre></td></tr></table>
</div>
</div><p>一些有经验的开发者不经意也会犯这种错误，正确的做法应该是使用 <code>&amp;arr[i]</code> 替代 <code>&amp;v</code>，我们会在下面分析这一现象背后的原因。</p>
<h3 id="遍历清空数组">遍历清空数组<a hidden class="anchor" aria-hidden="true" href="#遍历清空数组">#</a></h3>
<p>当我们想要在 Go 语言中清空一个切片或者哈希时，一般都会使用以下的方法将切片中的元素置零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>依次遍历切片和哈希看起来是非常耗费性能的，因为数组、切片和哈希占用的内存空间都是连续的，所以最快的方法是直接清空这片内存中的内容，当我们编译上述代码时会得到以下的汇编指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="s">&#34;&#34;</span><span class="n">.main</span> <span class="n">STEXT</span> <span class="n">size</span><span class="o">=</span><span class="m">93</span> <span class="n">args</span><span class="o">=</span><span class="mh">0x0</span> <span class="n">locals</span><span class="o">=</span><span class="mh">0x30</span>
	<span class="mh">0x0000</span> <span class="m">00000</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">3</span><span class="p">)</span>	<span class="n">TEXT</span>	<span class="s">&#34;&#34;</span><span class="nf">.main</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="o">$</span><span class="m">48-0</span>
	<span class="kc">...</span>
	<span class="mh">0x001d</span> <span class="m">00029</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">4</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="nf">.statictmp_0</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
	<span class="mh">0x0024</span> <span class="m">00036</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">4</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_3</span><span class="m">+16</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="mh">0x0029</span> <span class="m">00041</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">4</span><span class="p">)</span>	<span class="n">MOVUPS</span>	<span class="s">&#34;&#34;</span><span class="n">.statictmp_0</span><span class="m">+8</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">X0</span>
	<span class="mh">0x0030</span> <span class="m">00048</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">4</span><span class="p">)</span>	<span class="n">MOVUPS</span>	<span class="n">X0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">..autotmp_3</span><span class="m">+24</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="mh">0x0035</span> <span class="m">00053</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>	<span class="n">PCDATA</span>	<span class="o">$</span><span class="m">2</span><span class="p">,</span> <span class="o">$</span><span class="m">1</span>
	<span class="mh">0x0035</span> <span class="m">00053</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>	<span class="n">LEAQ</span>	<span class="s">&#34;&#34;</span><span class="n">..autotmp_3</span><span class="m">+16</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
	<span class="mh">0x003a</span> <span class="m">00058</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>	<span class="n">PCDATA</span>	<span class="o">$</span><span class="m">2</span><span class="p">,</span> <span class="o">$</span><span class="m">0</span>
	<span class="mh">0x003a</span> <span class="m">00058</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="mh">0x003e</span> <span class="m">00062</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="o">$</span><span class="m">24</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
	<span class="mh">0x0047</span> <span class="m">00071</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">5</span><span class="p">)</span>	<span class="n">CALL</span>	<span class="nf">runtime.memclrNoHeapPointers</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>从生成的汇编代码我们可以看出，编译器会直接使用 runtime.memclrNoHeapPointers 清空切片中的数据，这也是我们在下面的小节会介绍的内容。</p>
<h3 id="随机遍历">随机遍历<a hidden class="anchor" aria-hidden="true" href="#随机遍历">#</a></h3>
<p>当我们在 Go 语言中使用 range 遍历哈希表时，往往都会使用如下的代码结构，但是这段代码在每次运行时都会打印出不同的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="s">&#34;1&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="s">&#34;2&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="s">&#34;3&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">hash</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>两次运行上述代码可能会得到不同的结果，第一次会打印 2 3 1，第二次会打印 1 2 3，如果我们运行的次数足够多，最后会得到几种不同的遍历顺序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">2</span> <span class="m">2</span>
<span class="m">3</span> <span class="m">3</span>
<span class="m">1</span> <span class="m">1</span>

<span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">1</span> <span class="m">1</span>
<span class="m">2</span> <span class="m">2</span>
<span class="m">3</span> <span class="m">3</span>
</code></pre></td></tr></table>
</div>
</div><p>Go 语言在运行时为哈希表的遍历引入了不确定性，也是告诉所有 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历，我们在下面的小节会介绍在遍历的过程是如何引入不确定性的。</p>
<h2 id="经典循环">经典循环<a hidden class="anchor" aria-hidden="true" href="#经典循环">#</a></h2>
<p>Go 语言中的经典循环在编译器看来是一个 OFOR 类型的节点，这个节点由以下四个部分组成：</p>
<ol>
<li>初始化循环的 Ninit；</li>
<li>循环的继续条件 Left；</li>
<li>循环体结束时执行的 Right；</li>
<li>循环体 NBody：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">Ninit</span><span class="p">;</span> <span class="nx">Left</span><span class="p">;</span> <span class="nx">Right</span> <span class="p">{</span>
    <span class="nx">NBody</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在生成 SSA 中间代码的阶段，<code>cmd/compile/internal/gc.state.stmt</code> 方法在发现传入的节点类型是 OFOR 时会执行以下的代码块，这段代码会将循环中的代码分成不同的块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">stmt</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">OFOR</span><span class="p">,</span> <span class="nx">OFORUNTIL</span><span class="p">:</span>
		<span class="nx">bCond</span><span class="p">,</span> <span class="nx">bBody</span><span class="p">,</span> <span class="nx">bIncr</span><span class="p">,</span> <span class="nx">bEnd</span> <span class="o">:=</span> <span class="o">...</span>

		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">endBlock</span><span class="p">()</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">bCond</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">bCond</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">condBranch</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">bBody</span><span class="p">,</span> <span class="nx">bEnd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

		<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">bBody</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">stmtList</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Nbody</span><span class="p">)</span>

		<span class="nx">b</span><span class="p">.</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">bIncr</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">bIncr</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">stmt</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">bCond</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">bEnd</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>一个常见的 for 循环代码会被 cmd/compile/internal/gc.state.stmt 转换成下面的控制结构，该结构中包含了 4 个不同的块，这些代码块之间的连接表示汇编语言中的跳转关系，与我们理解的 for 循环控制结构没有太多的差别。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210614222854.png" alt=""  />
</p>
<p>机器码生成阶段会将这些代码块转换成机器码，以及指定 CPU 架构上运行的机器语言，就是我们在前面编译得到的汇编指令。</p>
<h2 id="范围循环">范围循环<a hidden class="anchor" aria-hidden="true" href="#范围循环">#</a></h2>
<p>与简单的经典循环相比，范围循环在 Go 语言中更常见、实现也更复杂。这种循环同时使用 for 和 range 两个关键字，编译器会在编译期间将所有 for-range 循环变成经典循环。从编译器的视角来看，就是将 ORANGE 类型的节点转换成 OFOR 节点:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210614222932.png" alt=""  />
</p>
<p>节点类型的转换过程都发生在中间代码生成阶段，所有的 for-range 循环都会被 <code>cmd/compile/internal/gc.walkrange</code> 转换成不包含复杂结构、只包含基本表达式的语句。接下来，我们按照循环遍历的元素类型依次介绍遍历数组和切片、哈希表、字符串以及管道时的过程。</p>
<p>for-range其实是语法糖，内部调用还是for循环，初始化会拷贝带遍历的列表（如array，slice，map），然后每次遍历的v都是对同一个元素的遍历赋值。</p>
<h3 id="数组和切片">数组和切片<a hidden class="anchor" aria-hidden="true" href="#数组和切片">#</a></h3>
<p>对于数组和切片来说，Go 语言有三种不同的遍历方式，这三种不同的遍历方式分别对应着代码中的不同条件，它们会在 <code>cmd/compile/internal/gc.walkrange</code> 函数中转换成不同的控制逻辑，我们会分成几种情况分析该函数的逻辑：</p>
<ol>
<li>分析遍历数组和切片清空元素的情况；</li>
<li>分析使用 <code>for range a {}</code> 遍历数组和切片，不关心索引和数据的情况；</li>
<li>分析使用 <code>for i := range a {}</code> 遍历数组和切片，只关心索引的情况；</li>
<li>分析使用 <code>for i, elem := range a {}</code> 遍历数组和切片，关心索引和数据的情况；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">walkrange</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span><span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Etype</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">TARRAY</span><span class="p">,</span> <span class="nx">TSLICE</span><span class="p">:</span>
		<span class="k">if</span> <span class="nf">arrayClear</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>cmd/compile/internal/gc.arrayClear</code> 是一个非常有趣的优化，它会优化 Go 语言遍历数组或者切片并删除全部元素的逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 原代码
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">zero</span>
<span class="p">}</span>

<span class="c1">// 优化后
</span><span class="c1"></span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">hp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">hn</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="nf">elem</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">hp</span><span class="p">,</span> <span class="nx">hn</span><span class="p">)</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>相比于依次清除数组或者切片中的数据，Go 语言会直接使用 <code>runtime.memclrNoHeapPointers</code> 或者 <code>runtime.memclrHasPointers</code> 清除目标数组内存空间中的全部数据，并在执行完成后更新遍历数组的索引，这也印证了我们在遍历清空数组一节中观察到的现象。</p>
<p>处理了这种特殊的情况之后，我们可以回到 ORANGE 节点的处理过程了。这里会设置 for 循环的 Left 和 Right 字段，也就是终止条件和循环体每次执行结束后运行的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">		<span class="n">ha</span> <span class="o">:=</span> <span class="n">a</span>

		<span class="n">hv1</span> <span class="o">:=</span> <span class="nf">temp</span><span class="p">(</span><span class="n">types.Types[TINT]</span><span class="p">)</span>
		<span class="n">hn</span> <span class="o">:=</span> <span class="nf">temp</span><span class="p">(</span><span class="n">types.Types[TINT]</span><span class="p">)</span>

		<span class="n">init</span> <span class="o">=</span> <span class="nf">append</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="nf">nod</span><span class="p">(</span><span class="n">OAS</span><span class="p">,</span> <span class="n">hv1</span><span class="p">,</span> <span class="n">nil</span><span class="p">))</span>
		<span class="n">init</span> <span class="o">=</span> <span class="nf">append</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="nf">nod</span><span class="p">(</span><span class="n">OAS</span><span class="p">,</span> <span class="n">hn</span><span class="p">,</span> <span class="nf">nod</span><span class="p">(</span><span class="n">OLEN</span><span class="p">,</span> <span class="n">ha</span><span class="p">,</span> <span class="n">nil</span><span class="p">)))</span>

		<span class="n">n.Left</span> <span class="o">=</span> <span class="nf">nod</span><span class="p">(</span><span class="n">OLT</span><span class="p">,</span> <span class="n">hv1</span><span class="p">,</span> <span class="n">hn</span><span class="p">)</span>
		<span class="n">n.Right</span> <span class="o">=</span> <span class="nf">nod</span><span class="p">(</span><span class="n">OAS</span><span class="p">,</span> <span class="n">hv1</span><span class="p">,</span> <span class="nf">nod</span><span class="p">(</span><span class="n">OADD</span><span class="p">,</span> <span class="n">hv1</span><span class="p">,</span> <span class="nf">nodintconst</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span>

		<span class="n">if</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
			<span class="n">break</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果循环是 <code>for range a {}</code>，那么就满足了上述代码中的条件 <code>v1 == nil</code>，即循环不关心数组的索引和数据，这种循环会被编译器转换成如下形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">hn</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">)</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nx">hn</span><span class="p">;</span> <span class="nx">hv1</span><span class="o">++</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是 ORANGE 结构在编译期间被转换的最简单形式，由于原代码不需要获取数组的索引和元素，只需要使用数组或者切片的数量执行对应次数的循环，所以会生成一个最简单的 for 循环。</p>
<p>如果我们在遍历数组时需要使用索引 <code>for i := range a {}</code>，那么编译器会继续会执行下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">		<span class="k">if</span> <span class="nx">v2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">body</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{</span><span class="nf">nod</span><span class="p">(</span><span class="nx">OAS</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">hv1</span><span class="p">)}</span>
			<span class="k">break</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>v2 == nil 意味着调用方不关心数组的元素，只关心遍历数组使用的索引。它会将 <code>for i := range a {}</code> 转换成下面的逻辑，与第一种循环相比，这种循环在循环体中添加了 v1 := hv1 语句，传递遍历数组时的索引：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">hn</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">)</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nx">hn</span><span class="p">;</span> <span class="nx">hv1</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="p">=</span> <span class="nx">hv1</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面两种情况虽然也是使用 range 会经常遇到的情况，但是同时去遍历索引和元素也很常见。处理这种情况会使用下面这段的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OINDEX</span><span class="p">,</span> <span class="nx">ha</span><span class="p">,</span> <span class="nx">hv1</span><span class="p">)</span>
		<span class="nx">tmp</span><span class="p">.</span><span class="nf">SetBounded</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OAS2</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nx">a</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set2</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span>
		<span class="nx">a</span><span class="p">.</span><span class="nx">Rlist</span><span class="p">.</span><span class="nf">Set2</span><span class="p">(</span><span class="nx">hv1</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
		<span class="nx">body</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{</span><span class="nx">a</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">.</span><span class="nx">Ninit</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">init</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">n</span><span class="p">.</span><span class="nx">Nbody</span><span class="p">.</span><span class="nf">Prepend</span><span class="p">(</span><span class="nx">body</span><span class="o">...</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码处理的使用者同时关心索引和切片的情况。它不仅会在循环体中插入更新索引的语句，还会插入赋值操作让循环体内部的代码能够访问数组中的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">hn</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">)</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
<span class="nx">v2</span> <span class="o">:=</span> <span class="kc">nil</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nx">hn</span><span class="p">;</span> <span class="nx">hv1</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">ha</span><span class="p">[</span><span class="nx">hv1</span><span class="p">]</span>
    <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span> <span class="p">=</span> <span class="nx">hv1</span><span class="p">,</span> <span class="nx">tmp</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新变量 ha，在赋值的过程中就发生了拷贝，而我们又通过 len 关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环执行的次数，这也就解释了循环永动机一节提到的现象。</p>
<p>而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">newArr</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
		<span class="nx">newArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newArr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newArr</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。因此当我们想要访问数组中元素所在的地址时，不应该直接获取 range 返回的变量地址 <code>&amp;v2</code>，而应该使用 <code>&amp;a[index]</code> 这种形式。</p>
<h3 id="哈希表">哈希表<a hidden class="anchor" aria-hidden="true" href="#哈希表">#</a></h3>
<p>在遍历哈希表时，编译器会使用 <code>runtime.mapiterinit</code> 和 <code>runtime.mapiternext</code> 两个运行时函数重写原始的 for-range 循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hit</span> <span class="o">:=</span> <span class="nf">hiter</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>
<span class="nx">th</span> <span class="o">:=</span> <span class="nx">hit</span><span class="p">.</span><span class="nx">Type</span>
<span class="nf">mapiterinit</span><span class="p">(</span><span class="nf">typename</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="nx">ha</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">hit</span><span class="p">)</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hit</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">hit</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">key</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">hit</span><span class="p">.</span><span class="nx">key</span>
<span class="nx">val</span> <span class="o">:=*</span><span class="nx">hit</span><span class="p">.</span><span class="nx">val</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码是展开 <code>for key, val := range hash {}</code> 后的结果，在 <code>cmd/compile/internal/gc.walkrange</code> 处理 TMAP 节点时，编译器会根据 range 返回值的数量在循环体中插入需要的赋值语句：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210614224801.png" alt=""  />
</p>
<p>这三种不同的情况分别向循环体插入了不同的赋值语句。遍历哈希表时会使用 runtime.mapiterinit 函数初始化遍历开始的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span><span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="p">=</span> <span class="nx">h</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>
	<span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数会初始化 <code>runtime.hiter</code> 结构体中的字段，并通过 <code>runtime.fastrand</code> 生成一个随机数帮助我们随机选择一个遍历桶的起始位置。Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。</p>
<p>遍历哈希会使用 <code>runtime.mapiternext</code>，我们在这里简化了很多逻辑，省去了一些边界条件以及哈希表扩容时的兼容操作，这里只需要关注处理遍历逻辑的核心代码，我们会将该函数分成桶的选择和桶内元素的遍历两部分，首先是桶的选择过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">t</span>
	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">i</span>
	<span class="nx">alg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">alg</span>

<span class="nx">next</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">{</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">bucket</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">bucket</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码主要有两个作用：</p>
<ol>
<li>在待遍历的桶为空时，选择需要遍历的新桶；</li>
<li>在不存在待遍历的桶时。返回 (nil, nil) 键值对并中止遍历；</li>
</ol>
<p>runtime.mapiternext 剩余代码的作用是从桶中找到下一个遍历的元素，在大多数情况下都会直接操作内存获取目标键值的内存地址，不过如果哈希表处于扩容期间就会调用 runtime.mapaccessK 获取键值对：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">offi</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedX</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">!(</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">rk</span><span class="p">,</span> <span class="nx">rv</span> <span class="o">:=</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">rk</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">rv</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">bucket</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">goto</span> <span class="nx">next</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当上述函数已经遍历了正常桶后，会通过 <code>runtime.bmap.overflow</code> 遍历哈希中的溢出桶。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210614225710.png" alt=""  />
</p>
<p>简单总结一下哈希表遍历的顺序，首先会选出一个绿色的正常桶开始遍历，随后遍历所有黄色的溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。</p>
<h3 id="字符串">字符串<a hidden class="anchor" aria-hidden="true" href="#字符串">#</a></h3>
<p>遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 rune。我们在遍历字符串时拿到的值都是 rune 类型的变量，<code>for i, r := range s {}</code> 的结构都会被转换成如下所示的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">s</span>
<span class="k">for</span> <span class="nx">hv1</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">hv1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ha</span><span class="p">);</span> <span class="p">{</span>
    <span class="nx">hv1t</span> <span class="o">:=</span> <span class="nx">hv1</span>
    <span class="nx">hv2</span> <span class="o">:=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">ha</span><span class="p">[</span><span class="nx">hv1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nx">hv2</span> <span class="p">&lt;</span> <span class="nx">utf8</span><span class="p">.</span><span class="nx">RuneSelf</span> <span class="p">{</span>
        <span class="nx">hv1</span><span class="o">++</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">hv2</span><span class="p">,</span> <span class="nx">hv1</span> <span class="p">=</span> <span class="nf">decoderune</span><span class="p">(</span><span class="nx">ha</span><span class="p">,</span> <span class="nx">hv1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span> <span class="p">=</span> <span class="nx">hv1t</span><span class="p">,</span> <span class="nx">hv2</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在前面的字符串一节中我们曾经介绍过字符串是一个只读的字节数组切片，所以范围循环在编译期间生成的框架与切片非常类似，只是细节有一些不同。</p>
<p>首先仍然和遍历数组和切片一样，会对原对象进行一次拷贝，接下来开始使用传统三段式遍历方式进行遍历，接下来其把当前遍历到的字节（字符串底层类似为byte数组）转换为rune类型，然后判断该rune类型是否为utf8码点，如果判断为true，则代表当前的rune是一个ASCII字符，此时索引仅+1即可，如果为false，需要将其转换为对应长度的rune字符并且对应索引也会随之增加，随后，赋值给v1,v1即for k, v := range str 的k和v。至此，字符串的遍历也讲完了，主要就是针对utf8码点进行了索引递增，每个中文字符占用3个byte长度。</p>
<p>decoderune函数的功能就是返回 <code>s[k:]</code>开头的非 ASCII 符文和 s 中符文后的索引。其中，s为传入的字符串，k为索引</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// decoderune returns the non-ASCII rune at the start of
</span><span class="c1">// s[k:] and the index after the rune in s.
</span><span class="c1">//
</span><span class="c1">// decoderune assumes that caller has checked that
</span><span class="c1">// the to be decoded rune is a non-ASCII rune.
</span><span class="c1">//
</span><span class="c1">// If the string appears to be incomplete or decoding problems
</span><span class="c1">// are encountered (runeerror, k + 1) is returned to ensure
</span><span class="c1">// progress when decoderune is used to iterate over a string.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">decoderune</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">,</span> <span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pos</span> <span class="p">=</span> <span class="nx">k</span>

	<span class="k">if</span> <span class="nx">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">runeError</span><span class="p">,</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">k</span><span class="p">:]</span>

	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">t2</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">t3</span><span class="p">:</span>
		<span class="c1">// 0080-07FF two byte sequence
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">mask2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span>
			<span class="nx">pos</span> <span class="o">+=</span> <span class="mi">2</span>
			<span class="k">if</span> <span class="nx">rune1Max</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">t3</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">t4</span><span class="p">:</span>
		<span class="c1">// 0800-FFFF three byte sequence
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">mask3</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">12</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span>
			<span class="nx">pos</span> <span class="o">+=</span> <span class="mi">3</span>
			<span class="k">if</span> <span class="nx">rune2Max</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="p">!(</span><span class="nx">surrogateMin</span> <span class="o">&lt;=</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">surrogateMax</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">t4</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">t5</span><span class="p">:</span>
		<span class="c1">// 10000-1FFFFF four byte sequence
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">locb</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">hicb</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">mask4</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">18</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">12</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span> <span class="p">|</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">maskx</span><span class="p">)</span>
			<span class="nx">pos</span> <span class="o">+=</span> <span class="mi">4</span>
			<span class="k">if</span> <span class="nx">rune3Max</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">maxRune</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">runeError</span><span class="p">,</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="通道">通道<a hidden class="anchor" aria-hidden="true" href="#通道">#</a></h3>
<p>使用 range 遍历 Channel 也是比较常见的做法，一个形如 for v := range ch {} 的语句最终会被转换成如下的格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span><span class="p">,</span> <span class="nx">hb</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ha</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hb</span> <span class="o">!=</span> <span class="kc">false</span><span class="p">;</span> <span class="nx">hv1</span><span class="p">,</span> <span class="nx">hb</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ha</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
    <span class="nx">hv1</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用 <code>&lt;-ch</code> 从管道中取出等待处理的值，这个操作会调用 <code>runtime.chanrecv2</code> 并阻塞当前的协程，当 <code>runtime.chanrecv2</code> 返回时会根据布尔值 hb 判断当前的值是否存在：</p>
<ul>
<li>如果不存在当前值，意味着当前的管道已经被关闭；</li>
<li>如果存在当前值，会为 v1 赋值并清除 hv1 变量中的数据，然后重新陷入阻塞等待新数据；</li>
</ul>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>这一节介绍的两个关键字 for 和 range 都是我们在学习和使用 Go 语言中无法绕开的，通过分析和研究它们的底层原理，让我们对实现细节有了更清楚的认识，包括 Go 语言遍历数组和切片时会复用变量、哈希表的随机遍历原理以及底层的一些优化，这都能帮助我们更好地理解和使用 Go 语言。</p>
<h2 id="转载">转载<a hidden class="anchor" aria-hidden="true" href="#转载">#</a></h2>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/">5.1 for 和 range</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
