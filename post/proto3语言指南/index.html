<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Proto3语言指南 | Forz Blog</title>
<meta name="keywords" content="protobuf" />
<meta name="description" content="语言指南 定义消息类型 先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的">
<meta name="author" content="">
<link rel="canonical" href="/post/proto3%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Proto3语言指南" />
<meta property="og:description" content="语言指南 定义消息类型 先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/proto3%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-04-12T19:42:32&#43;00:00" />
<meta property="article:modified_time" content="2021-04-12T19:42:32&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Proto3语言指南"/>
<meta name="twitter:description" content="语言指南 定义消息类型 先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Proto3语言指南",
      "item": "/post/proto3%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Proto3语言指南",
  "name": "Proto3语言指南",
  "description": "语言指南 定义消息类型 先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的",
  "keywords": [
    "protobuf"
  ],
  "articleBody": "语言指南 定义消息类型 先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：\n1 2 3 4 5 6 7  syntax = \"proto3\";message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3;}   文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。 SearchRequest消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。  指定字段类型 在上面的例子中，所有字段都是标量类型：两个整型（page_number和result_per_page），一个string类型（query）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。\n分配标识号 正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。\n最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。\n指定字段规则 所指定的消息字段修饰符必须是如下之一：\n singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。 repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。  在proto3中，repeated的标量域默认情况虾使用packed。\n你可以了解更多的pakced属性在Protocol Buffer 编码\n添加更多消息类型 在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：\n1 2 3 4 5 6 7 8 9  message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3;}message SearchResponse { ...}  添加注释 向.proto文件添加注释，可以使用C/C++/Java风格的双斜杠（//） 语法格式，如：\n1 2 3 4 5 6 7 8 9  /* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */message SearchRequest { string query = 1; int32 page_number = 2; // Which page number do we want?  int32 result_per_page = 3; // Number of results to return per page. }  保留标识符（Reserved） 如果你通过删除或者注释所有域，以后的用户在更新这个类型的时候可能重用这些标识号。如果你使用旧版本加载相同的.proto文件会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段tag（reserved name可能会JSON序列化的问题）指定reserved标识符，protocol buffer的编译器会警告未来尝试使用这些域标识符的用户。\n1 2 3 4  message Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\";}  注：不要在同一行reserved声明中同时声明域名字和tag number。\n从.proto文件生成了什么？ 当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。\n 对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。 对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。 对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。 对go来说，编译器会位每个消息类型生成了一个.pd.go文件。 对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。 javaNano来说，编译器输出类似域java但是没有Builder类 对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。 对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。  你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。API Reference\n标量值类型 一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：\n   .proto Type Notes C++ Type Java Type Python Type[2] Go Type Ruby Type C# Type PHP Type     double  double double float float64 Float double float   float  float float float float32 Float float float   int32 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 int32 int int int32 Fixnum 或者 Bignum（根据需要） int integer   uint32 使用变长编码 uint32 int int/long uint32 Fixnum 或者 Bignum（根据需要） uint integer   uint64 使用变长编码 uint64 long int/long uint64 Bignum ulong integer/string   sint32 使用变长编码，这些编码在负值时比int32高效的多 int32 int int int32 Fixnum 或者 Bignum（根据需要） int integer   sint64 使用变长编码，有符号的整型值。编码时比通常的int64高效。 int64 long int/long int64 Bignum long integer/string   fixed32 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。 uint32 int int uint32 Fixnum 或者 Bignum（根据需要） uint integer   fixed64 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。 uint64 long int/long uint64 Bignum ulong integer/string   sfixed32 总是4个字节 int32 int int int32 Fixnum 或者 Bignum（根据需要） int integer   sfixed64 总是8个字节 int64 long int/long int64 Bignum long integer/string   bool  bool boolean bool bool TrueClass/FalseClass bool boolean   string 一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。 string String str/unicode string String (UTF-8) string string   bytes 可能包含任意顺序的字节数据。 string ByteString str []byte String (ASCII-8BIT) ByteString string    你可以在文章Protocol Buffer 编码中，找到更多“序列化消息时各种类型如何编码”的信息。\n 在java中，无符号32位和64位整型被表示成他们的整型对应形式，最高位被储存在标志位中。 对于所有的情况，设定值会执行类型检查以确保此值是有效。 64位或者无符号32位整型在解码时被表示成为ilong，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。 python中string被表示成在解码时表示成unicode。但是一个ASCIIstring可以被表示成str类型。 Integer在64位的机器上使用，string在32位机器上使用  默认值 当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：\n 对于string，默认是一个空string 对于bytes，默认是一个空的bytes 对于bool，默认是false 对于数值类型，默认是0 对于枚举，默认是第一个定义的枚举值，必须为0; 对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide  对于可重复域的默认值是空（通常情况下是对应语言中空列表）。\n注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。\n查看generated code guide选择你的语言的默认值的工作细节。\n枚举 当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。\n在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 4;}  如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：\n 必须有有一个0值，我们可以用这个0值作为默认值。 这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。  你可以通过将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true，否则编译器会在别名的地方产生一个错误信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  message MyMessage1 { enum EnumAllowingAlias { option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1; }}message MyMessage2 { enum EnumNotAllowingAlias { UNKNOWN = 0; STARTED = 1; // RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside.  }}  枚举器常量必须在32位整数范围内。由于enum值在序列化上使用varint编码，因此负值效率不高，因此不建议使用。您可以在消息定义中定义enum，如上面的示例所示，enum也可以在外部定义-这些s可以在.proto文件中的任何消息定义中重复使用。您还可以使用enum语法将一条消息中声明的类型用作另一条消息中字段的类型_MessageType_._EnumType_。\n当运行在所述协议缓冲编译器.proto，它使用一个enum，生成的代码将具有对应enum于Java或C++，一个特殊EnumDescriptor的是被用于创建一组与在所述运行时生成的类的整数值的符号常数的Python类。\n注意:所生成的代码可能会受到语言特定的枚举数限制（一种语言的成千上万个）。请查看您计划使用的语言的限制。\n在反序列化期间，无法识别的枚举值将保留在消息中，尽管在反序列化消息时如何表示该值取决于语言。在支持具有超出指定符号范围的值的开放式枚举类型的语言（例如C ++和Go）中，未知的枚举值只是作为其基础整数表示形式存储。在具有封闭枚举类型的语言（例如Java）中，枚举中的大小写用于表示无法识别的值，并且可以使用特殊的访问器访问基础整数。在任何一种情况下，如果消息已序列化，则无法识别的值仍将与消息一起序列化。\n有关如何enum在应用程序中使用message的更多信息，请参见针对所选语言生成的代码指南。\n保留值 如果通过完全删除枚举条目或将其注释掉来更新枚举类型，则将来的用户在自己对类型进行更新时可以重用数值。如果他们以后加载相同版本的旧版本，可能会导致严重问题.proto，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是，将删除的条目的数字值（和/或名称，也可能导致JSON序列化的问题）指定为reserved。如果将来有任何用户尝试使用这些标识符，则协议缓冲区编译器会抱怨。您可以使用max关键字指定保留的数值范围达到最大可能值。\n1 2 3 4  enum Foo { reserved 2, 15, 9 to 11, 40 to max; reserved \"FOO\", \"BAR\";}  请注意，您不能在同reserved一条语句中混合使用字段名和数字值。\n使用其他消息类型 你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：\n1 2 3 4 5 6 7 8 9  message SearchResponse { repeated Result results = 1;}message Result { string url = 1; string title = 2; repeated string snippets = 3;}  导入定义 请注意，此功能在Java中不可用。\n在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？\n你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：\n1  import \"myproject/other_protos.proto\";  默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如：\n1 2 3 4 5 6 7 8 9 10 11  // new.proto // All definitions are moved here // old.proto // This is the proto that all clients are importing. import public \"new.proto\";import \"other.proto\";// client.proto import \"old.proto\";// You use definitions from old.proto and new.proto, but not other.proto   通过在编译器命令行参数中使用-I/–proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。\n使用proto2消息类型 在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。\n嵌套类型 你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：\n1 2 3 4 5 6 7 8  message SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1;}  如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：\n1 2 3  message SomeOtherMessage { SearchResponse.Result result = 1;}  当然，你也可以将消息嵌套任意多层，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  message Outer { // Level 0  message MiddleAA { // Level 1  message Inner { // Level 2  int64 ival = 1; bool booly = 2; } } message MiddleBB { // Level 1  message Inner { // Level 2  int32 ival = 1; bool booly = 2; } }}  更新消息类型 如果现有消息类型不再满足您的所有需求（例如，您希望消息格式具有一个额外的字段），但是您仍然希望使用以旧格式创建的代码，请不要担心！在不破坏任何现有代码的情况下更新消息类型非常简单。只要记住以下规则：\n如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。\n 不要更改任何已有的字段的数值标识。 如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化） 非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。 int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。 sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。 string和bytes是兼容的——只要bytes是有效的UTF-8编码。 嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。 fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。 枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的 将单个值更改为新 值的成员oneof是安全且二进制兼容的。oneof如果您确定没有代码一次设置多个字段，那么将多个字段移动到新字段中可能是安全的。将任何字段移到现有字段中oneof都是不安全的。  未知字段 未知字段是格式正确的protocol buffers序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件使用新字段解析新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。\n最初，proto3消息始终在解析过程中丢弃未知字段，但是在版本3.5中，我们重新引入了保留未知字段以匹配proto2行为的功能。在版本3.5和更高版本中，未知字段将在解析期间保留并包含在序列化输出中。\nAny Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google/protobuf/any.proto。\n1 2 3 4 5 6  import \"google/protobuf/any.proto\";message ErrorStatus { string message = 1; repeated google.protobuf.Any details = 2;}  对于给定的消息类型的默认类型URL是type.googleapis.com/packagename.messagename。\n不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的pack()和unpack()访问器，在C++中会有PackFrom()和UnpackTo()方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Storing an arbitrary message type in Any. NetworkErrorDetails details = ...; ErrorStatus status; status.add_details()-PackFrom(details); // Reading an arbitrary message from Any. ErrorStatus status = ...; for (const Any\u0026 detail : status.details()) { if (detail.IsNetworkErrorDetails()) { NetworkErrorDetails network_error; detail.UnpackTo(\u0026network_error); ... processing network_error ... } }   目前，用于Any类型的动态库仍在开发之中\n如果你已经很熟悉proto2语法，使用Any替换扩展。\nOneof 如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存.\nOneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。 你可以使用case()或者WhichOneof() 方法检查哪个oneof字段被设置， 看你使用什么语言了.\n使用Oneof 为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:\n1 2 3 4 5 6  message SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; }}  然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字.\n在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API指南中找到oneof API介绍.\noneof特性 设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.\n1 2 3 4 5  SampleMessage message; message.set_name(\"name\"); CHECK(message.has_name()); message.mutable_sub_message(); // Will clear name field. CHECK(!message.has_name());   如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。\noneof不支持repeated.\n反射API对oneof 字段有效.\n如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了\n1 2 3 4  SampleMessage message; SubMessage* sub_message = message.mutable_sub_message(); message.set_name(\"name\"); // Will delete sub_message sub_message-set_... // Crashes here   在C++中，如果你使用Swap()两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，msg1会拥有sub_message并且msg2会有name。\n1 2 3 4 5 6 7  SampleMessage msg1; msg1.set_name(\"name\"); SampleMessage msg2; msg2.mutable_sub_message(); msg1.swap(\u0026msg2); CHECK(msg1.has_sub_message()); CHECK(msg2.has_name());   向后兼容问题 当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None/NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。\nTag 重用问题：\n 将字段移入或移除oneof：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除） 删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段 分离或者融合oneof：行为与移动常规字段相似。  Map 如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：\n1  mapkey_type, value_type map_field = N;  其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。\n例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：\n1  mapstring, Project projects = 3;    Map字段不能为repeated。 Map值的线格式排序和Map迭代排序是不确定的，因此您不能依赖于Map项的特定顺序。 为.proto生成文本格式时，Map会按键排序。数字键按数字排序。 从序列化解析或合并时，如果存在重复的映射键，则使用最后看到的键。从文本格式解析Map时，如果键重复，则解析可能会失败。 如果为映射字段提供键但没有值，则序列化字段时的行为取决于语言。在C ++，Java和Python中，类型的默认值是序列化的，而在其他语言中，则没有序列化的值。  生成的MapAPI当前可用于所有proto3支持的语言。您可以在相关API参考中找到有关所选语言的map API的更多信息。\nWell-Known类型 除了我们前面介绍的基本类型、Any、还有省略未介绍的Service相关的类型外，还有一些大家常见的类型，Protobuf也提供了定义，比如Timestamp和Duration。这里我们看看如何使用它。\nProtobuf提供了github.com/golang/protobuf/ptypes/timestamp.Timestamp和github.com/golang/protobuf/ptypes/duration.Duration两种扩展类型，用来表示时间，并提供了和标准库time.Time和 time.Duration的转换函数。\n你可以在你的proto中需要时间戳和duration的地方使用这两个类型，而不是使用标准库的time.Time和time.Duration,因为标注库的类型没有提供protobuf序列化反序列化的功能，你需要额外处理，所以不如直接使用Protobuf提供的对应类型(下一节gogo库提供了对标准库的支持，稍候再讲)。\n同时，它还是以指针的方式定义字段，这也意味着我们我们可以分别反序列化的时候，可以区分对应字段是否在数据中存在。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import ( fmt \"fmt\" \"time\" proto \"github.com/golang/protobuf/proto\" ptypes \"github.com/golang/protobuf/ptypes\" ) func main() { msg := \u0026WellKnownTypes{ Now: ptypes.TimestampNow(), Took: ptypes.DurationProto(10 * time.Minute), } data, err := proto.Marshal(msg) if err != nil { panic(err) } err = proto.Unmarshal(data, msg) if err != nil { panic(err) } fmt.Println(msg) }   向后兼容 map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：\n1 2 3 4 5 6  message MapFieldEntry { key_type key = 1; value_type value = 2;}repeated MapFieldEntry map_field = N;  任何支持映射的protocol buffers实现都必须产生并接受可以被上述定义接受的数据。\nPackages 当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：\n1 2  package foo.bar;message Open { ... }  在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：\n1 2 3 4 5  message Foo { ... foo.bar.Open open = 1; ...}  包的声明符会根据使用语言的不同影响生成的代码。\n 对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中； - 对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package； 对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。 对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。 对于Ruby，生成的类可以被包装在内置的Ruby名称空间中，转换成Ruby所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在Foo::Bar名称空间中。 对于javaNano包会使用Java包，除非你在你的文件中显式的提供一个option java_package。 对于C#包可以转换为PascalCase后作为名称空间，除非你在你的文件中显式的提供一个option csharp_namespace，例如，Open会在Foo.Bar名称空间中  包及名称的解析 Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。\nProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。\n定义服务 如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：\n1 2 3  service SearchService { rpc Search(SearchRequest) returns (SearchResponse);}  最直观的使用protocol buffer的RPC系统是gRPC,一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。\n如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息\n还有一些第三方开发的PRC实现使用Protocol Buffer。参考第三方插件wiki查看这些实现的列表。\nJSON对应 Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。\n如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。\n   proto3 JSON JSON示例 注意     message object {“fBar”: v, “g”: null, …} 产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值   enum string “FOO_BAR” 枚举值的名字在proto文件中被指定   map object {“k”: v, …} 所有的键都被转换成string   repeated V array [v, …] null被视为空列表   bool true, false true, false    string string “Hello World!”    bytes base64 string\t“YWJjMTIzIT8kKiYoKSctPUB+”    int32, fixed32, uint32 number 1, -10, 0 JSON值会是一个十进制数，数值型或者string类型都会接受   int64, fixed64, uint64 string “1”, “-10” JSON值会是一个十进制数，数值型或者string类型都会接受   float, double number 1.1, -10.0, 0, “NaN”, “Infinity” JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受   Any object {“@type”: “url”, “f”: v, … } 如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：{\"@type\": xxx, “value”: yyy}否则，该值会被转换成一个JSON对象，@type字段会被插入所指定的确定的值   Timestamp string “1972-01-01T10:00:20.021Z” 使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数   Duration string “1.000340012s”, “1s” 生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度   Struct object { … } 任意的JSON对象，见struct.proto   Wrapper types various types 2, “2”, “foo”, true, “true”, null, 0, … 包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null   FieldMask string “f.fooBar,h” 见fieldmask.proto   ListValue array [foo, bar, …]    Value value  任意JSON值   NullValue null  JSON null    JSON选项 一个proto3 JSON实现可以提供以下选项：\n 发出具有默认值的字段：默认情况下，proto3 JSON输出中会省略具有默认值的字段。一个实现可以提供一个选项，以使用其默认值覆盖此行为和输出字段。 忽略未知字段：默认情况下，Proto3 JSON解析器应拒绝未知字段，但可以提供在解析时忽略未知字段的选项。 使用proto字段名称而不是lowerCamelCase名称：默认情况下，proto3 JSON打印应将字段名称转换为lowerCamelCase并将其用作JSON名称。一个实现可以提供一个选项，改为使用原型字段名称作为JSON名称。Proto3 JSON解析器必须接受转换后的lowerCamelCase名称和原型字段名称。 将枚举值发送为整数而不是字符串：默认情况下，JSON输出中使用枚举值的名称。可以提供一个选项来代替使用枚举值的数字值。  Option 定义.proto文件时能够标注一系列的option。Option并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在google/protobuf/descriptor.proto找到。\n一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。\n如下就是一些常用的选项：\njava_package (文件选项) :这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：\n1  option java_package = \"com.example.foo\";  java_outer_classname (文件选项): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：\n1  option java_outer_classname = \"Ponycopter\";  java_multiple_files（文件选项）：如果为false，.java则将为此.proto文件仅生成一个文件，以及所有Java类/枚举/等。为顶级消息，服务和枚举生成的消息将嵌套在外部类的内部（请参阅参考资料java_outer_classname）。如果为true，.java则将为每个Java类/枚举/等生成单独的文件。是为顶级消息，服务和枚举生成的，而为此.proto文件生成的包装Java类将不包含任何嵌套的类/枚举/等。这是一个布尔选项，默认为false。如果未生成Java代码，则此选项无效。\n1  option java_multiple_files = true;  optimize_for(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成：\n SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。 CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。 LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。  1  option optimize_for = CODE_SIZE;  cc_enable_arenas(文件选项):对于C++产生的代码启用arena allocation\nobjc_class_prefix(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。\ndeprecated(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成@Deprecated注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。\n1  int32 old_field = 6 [deprecated = true];   options options其实是protobuf内置的一些message类型，其分为以下几个级别：\n 文件级别(file-level options) 消息级别(message-level options) 字段级别(field-level options) service级别(service options) method级别(method options)  protobuf提供一些内置的options可供选择，也提供了通过extend关键字来扩展这些options，达到增加自定义options的目的。\n在proto2语法中，extend可以作用于任何message，但在proto3语法中，extend仅能作用于这些定义option的message——仅用于自定义option。\noptions不会改变声明的整体含义（例如声明的是int32就是int32，不会因为一个option改变了其声明类型），但可能会影响在特定情况下处理它的方式。例如我们可以使用内置的deprecated option将某字段标记为deprecated：\n1 2 3 4  message Msg { string foo = 1; string bar = 2 [deprecated = true]; //标记为deprecated。 }  当我们需要编写自定义protoc插件时，可以通过自定义options为编译插件提供额外信息。举个例子，假设我要开发一个proto的校验插件，其生成xxx.Validate()方法来校验消息的合法性，我可以通过自定义options来提供生成代码的必要信息：\n1 2 3 4  message Msg { // required是自定义options，表示foo字段必须非空  string foo = 1; [required = true];}  内置options的定义可以在github.com/protocolbuf…找到，每种级别的options都对应一个message，分别是：\n FileOptions —— 文件级别 MessageOptions —— 消息级别 FieldOptions —— 字段级别 ServiceOptions —— service级别 MethodOptions —— method级别  以下将通过示例来逐一介绍这些级别的options，以及如何扩展这些options。\n文件级别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  ... option go_package = \"examplepb\"; // 编译后的golang包名 ... message extObj { string foo_string= 1; int64 bar_int=2; } // file options extend google.protobuf.FileOptions { string file_opt_string = 1001; extObj file_opt_obj = 1002; } option (example.everything.file_opt_string) = \"file_options\"; option (example.everything.file_opt_obj) = { foo_string: \"foo\" bar_int:1 };   go_package 毫无疑问是protobuf内置提供的，用于指定编译后的golang包名。除了使用内置的外，可以通过extend字段来扩展内置的FileOptions，例如在上述例子中，我们新增了两个新的option——string类型的file_opt_string和extObj类型的file_opt_obj。并通过option关键字设置了两个文件级别的options。在Go语言中，我们可以这样读取这些options:\n1 2 3 4 5 6 7 8 9 10  func getFileOptions() { fmt.Println(\"file options:\") msg := \u0026examplepb.MessageOption{} md, _ := descriptor.MessageDescriptorProto(msg) stringOpt, _ := proto.GetExtension(md.Options, examplepb.E_FileOptString) objOpt, _ := proto.GetExtension(md.Options, examplepb.E_FileOptObj) fmt.Println(\"\tobj.foo_string:\", objOpt.(*examplepb.ExtObj).FooString) fmt.Println(\"\tobj.bar_int\", objOpt.(*examplepb.ExtObj).BarInt) fmt.Println(\"\tstring:\", *stringOpt.(*string)) }   打印结果：\n1 2 3 4  file options: obj.foo_string: foo obj.bar_int 1 string: file_options   消息级别 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // message options extend google.protobuf.MessageOptions { string msg_opt_string = 1001; extObj msg_opt_obj = 1002; } message MessageOption { option (example.everything.msg_opt_string) = \"Hello world!\"; option (example.everything.msg_opt_obj) = { foo_string: \"foo\" bar_int:1 }; string foo = 1; }   与文件级别大同小异，不再赘述。Go语言读取示例：\n1 2 3 4 5 6 7 8 9 10  func getMessageOptions() { fmt.Println(\"message options:\") msg := \u0026examplepb.MessageOption{} _, md := descriptor.MessageDescriptorProto(msg) objOpt,_ := proto.GetExtension(md.Options, examplepb.E_MsgOptObj) stringOpt,_ := proto.GetExtension(md.Options, examplepb.E_MsgOptString) fmt.Println(\"\tobj.foo_string:\", objOpt.(*examplepb.ExtObj).FooString) fmt.Println(\"\tobj.bar_int\", objOpt.(*examplepb.ExtObj).BarInt) fmt.Println(\"\tstring:\", *stringOpt.(*string)) }   字段级别 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // field options extend google.protobuf.FieldOptions { string field_opt_string = 1001; extObj field_opt_obj = 1002;}message FieldOption { // 自定义的option  string foo= 1 [(example.everything.field_opt_string) = \"abc\",(example.everything.field_opt_obj) = { foo_string: \"foo\" bar_int:1 }]; // protobuf内置的option  string bar = 2 [deprecated = true];}  字段级别的option定义方式不使用option关键字，格式为：用[]包裹的用逗号分隔的k=v形式的数组。在Go语言中，我们可以这样读取这些option：\n1 2 3 4 5 6 7 8 9 10  func getFieldOptions() { fmt.Println(\"field options:\") msg := \u0026examplepb.FieldOption{} _, md := descriptor.MessageDescriptorProto(msg) stringOpt,_ := proto.GetExtension(md.Field[0].Options, examplepb.E_FieldOptString) objOpt,_ := proto.GetExtension(md.Field[0].Options, examplepb.E_FieldOptObj) fmt.Println(\"\tobj.foo_string:\", objOpt.(*examplepb.ExtObj).FooString) fmt.Println(\"\tobj.bar_int\", objOpt.(*examplepb.ExtObj).BarInt) fmt.Println(\"\tstring:\", *stringOpt.(*string)) }   service和method级别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // service \u0026 method options extend google.protobuf.ServiceOptions { string srv_opt_string = 1001; extObj srv_opt_obj = 1002;}extend google.protobuf.MethodOptions { string method_opt_string = 1001; extObj method_opt_obj = 1002;}service ServiceOption { option (example.everything.srv_opt_string) = \"foo\"; rpc Search (SearchRequest) returns (SearchResponse) { option (example.everything.method_opt_string) = \"foo\"; option (example.everything.method_opt_obj) = { foo_string: \"foo\" bar_int: 1 }; };}  service和method级别的option也是通过option关键字来定义，与文件级别和消息级别option类似，不再赘述。Go语言读取示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func getServiceOptions() { fmt.Println(\"service options:\") msg := \u0026examplepb.MessageOption{} md, _ := descriptor.MessageDescriptorProto(msg) srv := md.Service[1] // ServiceOption \tstringOpt, _ := proto.GetExtension(srv.Options, examplepb.E_SrvOptString) fmt.Println(\"\tstring:\", *stringOpt.(*string)) } func getMethodOptions() { fmt.Println(\"method options:\") msg := \u0026examplepb.MessageOption{} md, _ := descriptor.MessageDescriptorProto(msg) srv := md.Service[1] // ServiceOption \tobjOpt, _ := proto.GetExtension(srv.Method[0].Options, examplepb.E_MethodOptObj) stringOpt, _ := proto.GetExtension(srv.Method[0].Options, examplepb.E_MethodOptString) fmt.Println(\"\tobj.foo_string:\", objOpt.(*examplepb.ExtObj).FooString) fmt.Println(\"\tobj.bar_int\", objOpt.(*examplepb.ExtObj).BarInt) fmt.Println(\"\tstring:\", *stringOpt.(*string)) }   自定义选项 ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看 Proto2 Language Guide。注意创建自定义选项使用了拓展，拓展只在proto3中可用。\n由于options是定在 google/protobuf/descriptor.proto中的，因此你可以在该文件中进行扩展，定义自己的选项。如：\n1 2 3 4 5 6 7  import \"google/protobuf/descriptor.proto\";extend google.protobuf.MessageOptions { optional string my_option = 51234;}message MyMessage { option (my_option) = \"Hello world!\";}  在上述代码中，通过对MessageOptions进行扩展定义了一个新的消息级别的选项。当使用该选项时，选项的名称需要使用（）包裹起来，以表明它是一个扩展。在C++代码中可以看出my_option是以如下方式被读取的。\n1  string value = MyMessage::descriptor()-options().GetExtension(my_option);   在Java代码中的读取方式如下：\n1 2  String value = MyProtoFile.MyMessage.getDescriptor().getOptions() .getExtension(MyProtoFile.myOption);   在Python中:\n1 2  value = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions() .Extensions[my_proto_file_pb2.my_option]   正如上面的读取方式，定制选项对于Python并不支持。定制选项在protocol buffer语言中可用于任何结构。下面就是一些具体的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  import \"google/protobuf/descriptor.proto\";extend google.protobuf.FileOptions { optional string my_file_option = 50000;}extend google.protobuf.MessageOptions { optional int32 my_message_option = 50001;}extend google.protobuf.FieldOptions { optional float my_field_option = 50002;}extend google.protobuf.EnumOptions { optional bool my_enum_option = 50003;}extend google.protobuf.EnumValueOptions { optional uint32 my_enum_value_option = 50004;}extend google.protobuf.ServiceOptions { optional MyEnum my_service_option = 50005;}extend google.protobuf.MethodOptions { optional MyMessage my_method_option = 50006;}option (my_file_option) = \"Hello world!\";message MyMessage { option (my_message_option) = 1234; optional int32 foo = 1 [(my_field_option) = 4.5]; optional string bar = 2;}enum MyEnum { option (my_enum_option) = true; FOO = 1 [(my_enum_value_option) = 321]; BAR = 2;}message RequestType {}message ResponseType {}service MyService { option (my_service_option) = FOO; rpc MyMethod(RequestType) returns(ResponseType) { // Note: my_method_option has type MyMessage. We can set each field  // within it using a separate \"option\" line.  option (my_method_option).foo = 567; option (my_method_option).bar = \"Some string\"; }}  注：如果要在该选项定义之外使用一个自定义的选项，必须要由包名 + 选项名来定义该选项。如：\n1 2 3 4 5 6  // foo.proto import \"google/protobuf/descriptor.proto\";package foo;extend google.protobuf.MessageOptions { optional string my_option = 51234;}  1 2 3 4 5 6  // bar.proto import \"foo.proto\";package bar;message MyMessage { option (foo.my_option) = \"Hello world!\";}  最后一件事情需要注意：因为自定义选项是可扩展的，它必须象其它的域或扩展一样来定义标识号。正如上述示例，[50000－99999]已经被占 用，该范围内的值已经被内部所使用，当然了你可以在内部应用中随意使用。如果你想在一些公共应用中进行自定义选项，你必须确保它是全局唯一的。可以通过protobuf-global-extension-registry@google.com来获取全局唯一标识号。 只需提供你的项目名和项目网站. 通常你只需要一个扩展号。 你可以使用一个扩展号声明多个选项:\n1 2 3 4 5 6 7 8 9 10 11 12 13  message FooOptions { optional int32 opt1 = 1; optional string opt2 = 2;}extend google.protobuf.FieldOptions { optional FooOptions foo_options = 1234;}// usage: message Bar { optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = \"baz\"]; // alternative aggregate syntax (uses TextFormat):  optional int32 b = 2 [(foo_options) = { opt1: 123 opt2: \"baz\" }];}  生成类 可以通过定义好的.proto文件来生成Java,Python,C++, Ruby, JavaNano, Objective-C,或者C# 代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器插件。你可以通过GitHub上的protobuf库找到安装过程\n通过如下方式调用protocol编译器：\n1  protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto   IMPORT_PATH声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用–proto_path，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是–proto_path的简化形式。\n当然也可以提供一个或多个输出路径：\n –cpp_out 在目标目录DST_DIR中产生C++代码，可以在C++代码生成参考中查看更多。 –java_out 在目标目录DST_DIR中产生Java代码，可以在 Java代码生成参考中查看更多。 –python_out 在目标目录 DST_DIR 中产生Python代码，可以在Python代码生成参考中查看更多。 –go_out 在目标目录 DST_DIR 中产生Go代码，可以在GO代码生成参考中查看更多。 –ruby_out在目标目录 DST_DIR 中产生Ruby代码，参考正在制作中。 –javanano_out在目标目录DST_DIR中生成JavaNano，JavaNano代码生成器有一系列的选项用于定制自定义生成器的输出：你可以通过生成器的README查找更多信息，JavaNano参考正在制作中。 –objc_out在目标目录DST_DIR中产生Object代码，可以在Objective-C代码生成参考中查看更多。 –csharp_out在目标目录DST_DIR中产生Object代码，可以在C#代码生成参考中查看更多。 –php_out在目标目录DST_DIR中产生Object代码，可以在PHP代码生成参考中查看更多。  作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。\n你必须提议一个或多个.proto文件作为输入，多个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。\n语言规范 这是协议缓冲区语言（proto3）版本3的语言规范参考。使用扩展Backus-Naur形式（EBNF）指定语法：\n1 2 3 4  | alternation () grouping [] option (zero or one time) {} repetition (any number of times)   有关使用proto3的更多信息，请参见语言指南。\n词汇要素 字母和数字 1 2 3 4  letter = \"A\" … \"Z\" | \"a\" … \"z\" decimalDigit = \"0\" … \"9\" octalDigit = \"0\" … \"7\" hexDigit = \"0\" … \"9\" | \"A\" … \"F\" | \"a\" … \"f\"   身份标识 1 2 3 4 5 6 7 8 9 10 11  ident = letter { letter | decimalDigit | \"_\" } fullIdent = ident { \".\" ident } messageName = ident enumName = ident fieldName = ident oneofName = ident mapName = ident serviceName = ident rpcName = ident messageType = [ \".\" ] { ident \".\" } messageName enumType = [ \".\" ] { ident \".\" } enumName   整数文字 1 2 3 4  intLit = decimalLit | octalLit | hexLit decimalLit = ( \"1\" … \"9\" ) { decimalDigit } octalLit = \"0\" { octalDigit } hexLit = \"0\" ( \"x\" | \"X\" ) hexDigit { hexDigit }   浮点文字 1 2 3  floatLit = ( decimals \".\" [ decimals ] [ exponent ] | decimals exponent | \".\"decimals [ exponent ] ) | \"inf\" | \"nan\" decimals = decimalDigit { decimalDigit } exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals   布尔型 1  boolLit = \"true\" | \"false\"   字符串文字 1 2 3 4 5 6  strLit = ( \"'\" { charValue } \"'\" ) | ( '\"' { charValue } '\"' ) charValue = hexEscape | octEscape | charEscape | /[^\\0\\n\\\\]/ hexEscape = '\\' ( \"x\" | \"X\" ) hexDigit hexDigit octEscape = '\\' octalDigit octalDigit octalDigit charEscape = '\\' ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | '\\' | \"'\" | '\"' ) quote = \"'\" | '\"'   空声明 1  emptyStatement = \";\"   不变 1  constant = fullIdent | ( [ \"-\" | \"+\" ] intLit ) | ( [ \"-\" | \"+\" ] floatLit ) | strLit | boolLit   句法 语法语句用于定义protobuf版本。\n1  syntax = \"syntax\" \"=\" quote \"proto3\" quote \";\"   例子：\n1  syntax = \"proto3\";  import import语句用于导入另一个.proto的定义。\n1  import = \"import\" [ \"weak\" | \"public\" ] strLit \";\"   例子：\n1  import public \"other.proto\";  package 包说明符可用于防止协议消息类型之间的名称冲突。\n1  package = \"package\" fullIdent \";\"   例子：\n1  package foo.bar;  选项 选项可用于原始文件，消息，枚举和服务。选项可以是protobuf定义的选项，也可以是自定义选项。有关更多信息，请参见语言指南中的选项。\n1 2  option = \"option\" optionName \"=\" constant \";\" optionName = ( ident | \"(\" fullIdent \")\" ) { \".\" ident }   例子：\n1  option java_package = \"com.example.foo\";  字段 字段是协议缓冲区消息的基本元素。字段可以是普通字段，字段之一或地图字段。字段具有类型和字段编号。\n1 2 3 4  type = \"double\" | \"float\" | \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\" | \"bytes\" | messageType | enumType fieldNumber = intLit;   普通字段 每个字段都有类型，名称和字段编号。它可能具有字段选项。\n1 2 3  field = [ \"repeated\" ] type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" fieldOptions = fieldOption { \",\" fieldOption } fieldOption = optionName \"=\" constant   例子：\n1 2  foo.Bar nested_message = 2;repeated int32 samples = 4 [packed=true];  oneof oneof由一个字段和一个名称组成。\n1 2  oneof = \"oneof\" oneofName \"{\" { option | oneofField | emptyStatement } \"}\" oneofField = type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\"   例子：\n1 2 3 4  oneof foo { string name = 4; SubMessage sub_message = 9;}  map 映射字段具有键类型，值类型，名称和字段编号。键类型可以是任何整数或字符串类型。\n1 2 3  mapField = \"map\" \" keyType \",\" type \"\" mapName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" keyType = \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\"   例子：\n1  mapstring, Project projects = 3;  reserve reserve语句声明了此消息中不能使用的一系列字段号或字段名。\n1 2 3 4  reserved = \"reserved\" ( ranges | fieldNames ) \";\" ranges = range { \",\" range } range = intLit [ \"to\" ( intLit | \"max\" ) ] fieldNames = fieldName { \",\" fieldName }   例子：\n1 2  reserved 2, 15, 9 to 11;reserved \"foo\", \"bar\";  顶级定义 枚举定义 枚举定义由名称和枚举主体组成。枚举主体可以具有选项和枚举字段。枚举定义必须以枚举值零开始。\n1 2 3 4  enum = \"enum\" enumName enumBody enumBody = \"{\" { option | enumField | emptyStatement } \"}\" enumField = ident \"=\" [ \"-\" ] intLit [ \"[\" enumValueOption { \",\" enumValueOption } \"]\" ]\";\" enumValueOption = optionName \"=\" constant   例子：\n1 2 3 4 5 6  enum EnumAllowingAlias { option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 2 [(custom_option) = \"hello world\"];}  消息定义 消息由消息名称和消息正文组成。消息主体可以具有字段，嵌套枚举定义，嵌套消息定义，选项，oneof，映射字段和保留语句。\n1 2 3  message = \"message\" messageName messageBody messageBody = \"{\" { field | enum | message | option | oneof | mapField | reserved | emptyStatement } \"}\"   例子：\n1 2 3 4 5 6 7  message Outer { option (my_option).a = true; message Inner { // Level 2  int64 ival = 1; } mapint32, string my_map = 2;}  服务定义 1 2 3  service = \"service\" serviceName \"{\" { option | rpc | emptyStatement } \"}\" rpc = \"rpc\" rpcName \"(\" [ \"stream\" ] messageType \")\" \"returns\" \"(\" [ \"stream\" ] messageType \")\" (( \"{\" {option | emptyStatement } \"}\" ) | \";\")   例子：\n1 2 3  service SearchService { rpc Search (SearchRequest) returns (SearchResponse);}  原始文件 1 2  proto = syntax { import | package | option | topLevelDef | emptyStatement } topLevelDef = message | enum | service   .proto示例文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  syntax = \"proto3\";import public \"other.proto\";option java_package = \"com.example.foo\";enum EnumAllowingAlias { option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 2 [(custom_option) = \"hello world\"];}message Outer { option (my_option).a = true; message Inner { // Level 2  int64 ival = 1; } repeated Inner inner_message = 2; EnumAllowingAlias enum_field =3; mapint32, string my_map = 4;}  参考 Protobuf语法全解析\n[译]Protobuf 语法指南\n",
  "wordCount" : "19084",
  "inLanguage": "zh-cn",
  "datePublished": "2021-04-12T19:42:32Z",
  "dateModified": "2021-04-12T19:42:32Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/proto3%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Proto3语言指南
    </h1>
    <div class="post-meta">April 12, 2021
</div>
  </header> 
  <div class="post-content"><h1 id="语言指南">语言指南<a hidden class="anchor" aria-hidden="true" href="#语言指南">#</a></h1>
<h2 id="定义消息类型">定义消息类型<a hidden class="anchor" aria-hidden="true" href="#定义消息类型">#</a></h2>
<p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li>SearchRequest消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h3 id="指定字段类型">指定字段类型<a hidden class="anchor" aria-hidden="true" href="#指定字段类型">#</a></h3>
<p>在上面的例子中，所有字段都是标量类型：两个整型（page_number和result_per_page），一个string类型（query）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。</p>
<h3 id="分配标识号">分配标识号<a hidden class="anchor" aria-hidden="true" href="#分配标识号">#</a></h3>
<p>正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p>
<h3 id="指定字段规则">指定字段规则<a hidden class="anchor" aria-hidden="true" href="#指定字段规则">#</a></h3>
<p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li>singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。</li>
<li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。</li>
</ul>
<p>在proto3中，repeated的标量域默认情况虾使用packed。</p>
<p>你可以了解更多的pakced属性在Protocol Buffer 编码</p>
<h3 id="添加更多消息类型">添加更多消息类型<a hidden class="anchor" aria-hidden="true" href="#添加更多消息类型">#</a></h3>
<p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span><span class="err">
</span><span class="err"></span> <span class="o">...</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="添加注释">添加注释<a hidden class="anchor" aria-hidden="true" href="#添加注释">#</a></h3>
<p>向.proto文件添加注释，可以使用C/C++/Java风格的双斜杠（//） 语法格式，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="cm">/* SearchRequest represents a search query, with pagination options to
</span><span class="cm">
</span><span class="cm">* indicate which results to include in the response. */</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// Which page number do we want?
</span><span class="c1"></span>  <span class="kt">int32</span> <span class="n">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// Number of results to return per page.
</span><span class="c1"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="保留标识符reserved">保留标识符（Reserved）<a hidden class="anchor" aria-hidden="true" href="#保留标识符reserved">#</a></h3>
<p>如果你通过删除或者注释所有域，以后的用户在更新这个类型的时候可能重用这些标识号。如果你使用旧版本加载相同的.proto文件会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段tag（reserved name可能会JSON序列化的问题）指定reserved标识符，protocol buffer的编译器会警告未来尝试使用这些域标识符的用户。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">reserved</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span> <span class="k">to</span> <span class="mi">11</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">reserved</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="s">&#34;bar&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>注：不要在同一行reserved声明中同时声明域名字和tag number。</p>
<h3 id="从proto文件生成了什么">从.proto文件生成了什么？<a hidden class="anchor" aria-hidden="true" href="#从proto文件生成了什么">#</a></h3>
<p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li>
<li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</li>
<li>对go来说，编译器会位每个消息类型生成了一个.pd.go文件。</li>
<li>对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。</li>
<li>javaNano来说，编译器输出类似域java但是没有Builder类</li>
<li>对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。</li>
</ul>
<p>你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。API Reference</p>
<h2 id="标量值类型">标量值类型<a hidden class="anchor" aria-hidden="true" href="#标量值类型">#</a></h2>
<p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Python Type[2]</th>
<th>Go Type</th>
<th>Ruby Type</th>
<th>C# Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
<td>int</td>
<td>int/long</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比int32高效的多</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td>
<td>uint32</td>
<td>int</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是4个字节</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是8个字节</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>TrueClass/FalseClass</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td>string</td>
<td>String</td>
<td>str/unicode</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>string</td>
</tr>
</tbody>
</table>
<p>你可以在文章Protocol Buffer 编码中，找到更多“序列化消息时各种类型如何编码”的信息。</p>
<ol>
<li>在java中，无符号32位和64位整型被表示成他们的整型对应形式，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64位或者无符号32位整型在解码时被表示成为ilong，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python中string被表示成在解码时表示成unicode。但是一个ASCIIstring可以被表示成str类型。</li>
<li>Integer在64位的机器上使用，string在32位机器上使用</li>
</ol>
<h2 id="默认值">默认值<a hidden class="anchor" aria-hidden="true" href="#默认值">#</a></h2>
<p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于string，默认是一个空string</li>
<li>对于bytes，默认是一个空的bytes</li>
<li>对于bool，默认是false</li>
<li>对于数值类型，默认是0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为0;</li>
<li>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide</li>
</ul>
<p>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。</p>
<p>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。</p>
<p>查看generated code guide选择你的语言的默认值的工作细节。</p>
<h2 id="枚举">枚举<a hidden class="anchor" aria-hidden="true" href="#枚举">#</a></h2>
<p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">int32</span> <span class="n">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kd">enum</span> <span class="n">Corpus</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="n">UNIVERSAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">WEB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">IMAGES</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">LOCAL</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">NEWS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">PRODUCTS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">VIDEO</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="n">Corpus</span> <span class="n">corpus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有有一个0值，我们可以用这个0值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>你可以通过将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true，否则编译器会在别名的地方产生一个错误信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">MyMessage1</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kd">enum</span> <span class="n">EnumAllowingAlias</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="k">option</span> <span class="n">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">STARTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">RUNNING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">MyMessage2</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kd">enum</span> <span class="n">EnumNotAllowingAlias</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">STARTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="c1">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.
</span><span class="c1"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>枚举器常量必须在32位整数范围内。由于enum值在序列化上使用varint编码，因此负值效率不高，因此不建议使用。您可以在消息定义中定义enum，如上面的示例所示，enum也可以在外部定义-这些s可以在.proto文件中的任何消息定义中重复使用。您还可以使用enum语法将一条消息中声明的类型用作另一条消息中字段的类型<code>_MessageType_._EnumType_</code>。</p>
<p>当运行在所述协议缓冲编译器.proto，它使用一个enum，生成的代码将具有对应enum于Java或C++，一个特殊EnumDescriptor的是被用于创建一组与在所述运行时生成的类的整数值的符号常数的Python类。</p>
<p>注意:所生成的代码可能会受到语言特定的枚举数限制（一种语言的成千上万个）。请查看您计划使用的语言的限制。</p>
<p>在反序列化期间，无法识别的枚举值将保留在消息中，尽管在反序列化消息时如何表示该值取决于语言。在支持具有超出指定符号范围的值的开放式枚举类型的语言（例如C ++和Go）中，未知的枚举值只是作为其基础整数表示形式存储。在具有封闭枚举类型的语言（例如Java）中，枚举中的大小写用于表示无法识别的值，并且可以使用特殊的访问器访问基础整数。在任何一种情况下，如果消息已序列化，则无法识别的值仍将与消息一起序列化。</p>
<p>有关如何enum在应用程序中使用message的更多信息，请参见针对所选语言生成的代码指南。</p>
<h3 id="保留值">保留值<a hidden class="anchor" aria-hidden="true" href="#保留值">#</a></h3>
<p>如果通过完全删除枚举条目或将其注释掉来更新枚举类型，则将来的用户在自己对类型进行更新时可以重用数值。如果他们以后加载相同版本的旧版本，可能会导致严重问题.proto，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是，将删除的条目的数字值（和/或名称，也可能导致JSON序列化的问题）指定为reserved。如果将来有任何用户尝试使用这些标识符，则协议缓冲区编译器会抱怨。您可以使用max关键字指定保留的数值范围达到最大可能值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">enum</span> <span class="n">Foo</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">reserved</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span> <span class="k">to</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">40</span> <span class="k">to</span> <span class="k">max</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">reserved</span> <span class="s">&#34;FOO&#34;</span><span class="p">,</span> <span class="s">&#34;BAR&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>请注意，您不能在同reserved一条语句中混合使用字段名和数字值。</p>
<h2 id="使用其他消息类型">使用其他消息类型<a hidden class="anchor" aria-hidden="true" href="#使用其他消息类型">#</a></h2>
<p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="n">Result</span> <span class="n">results</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">Result</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="n">url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="n">title</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="kt">string</span> <span class="n">snippets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="导入定义">导入定义<a hidden class="anchor" aria-hidden="true" href="#导入定义">#</a></h3>
<p>请注意，此功能在Java中不可用。</p>
<p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？</p>
<p>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">&#34;myproject/other_protos.proto&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="c1">// new.proto
</span><span class="c1">// All definitions are moved here
</span><span class="c1"></span><span class="err">
</span><span class="err"></span><span class="c1">// old.proto
</span><span class="c1">// This is the proto that all clients are importing.
</span><span class="c1"></span><span class="k">import</span> <span class="n">public</span> <span class="s">&#34;new.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="k">import</span> <span class="s">&#34;other.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c1">// client.proto
</span><span class="c1"></span><span class="k">import</span> <span class="s">&#34;old.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="c1">// You use definitions from old.proto and new.proto, but not other.proto
</span></code></pre></td></tr></table>
</div>
</div><p>通过在编译器命令行参数中使用-I/&ndash;proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h3 id="使用proto2消息类型">使用proto2消息类型<a hidden class="anchor" aria-hidden="true" href="#使用proto2消息类型">#</a></h3>
<p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。</p>
<h2 id="嵌套类型">嵌套类型<a hidden class="anchor" aria-hidden="true" href="#嵌套类型">#</a></h2>
<p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kd">message</span> <span class="nc">Result</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">title</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="k">repeated</span> <span class="kt">string</span> <span class="n">snippets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="n">Result</span> <span class="n">results</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SomeOtherMessage</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">SearchResponse.Result</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>当然，你也可以将消息嵌套任意多层，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Outer</span> <span class="p">{</span>                  <span class="c1">// Level 0
</span><span class="c1"></span>  <span class="kd">message</span> <span class="nc">MiddleAA</span> <span class="p">{</span>  <span class="c1">// Level 1
</span><span class="c1"></span>    <span class="kd">message</span> <span class="nc">Inner</span> <span class="p">{</span>   <span class="c1">// Level 2
</span><span class="c1"></span>      <span class="kt">int64</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>      <span class="kt">bool</span>  <span class="n">booly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="kd">message</span> <span class="nc">MiddleBB</span> <span class="p">{</span>  <span class="c1">// Level 1
</span><span class="c1"></span>    <span class="kd">message</span> <span class="nc">Inner</span> <span class="p">{</span>   <span class="c1">// Level 2
</span><span class="c1"></span>      <span class="kt">int32</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>      <span class="kt">bool</span>  <span class="n">booly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="更新消息类型">更新消息类型<a hidden class="anchor" aria-hidden="true" href="#更新消息类型">#</a></h2>
<p>如果现有消息类型不再满足您的所有需求（例如，您希望消息格式具有一个额外的字段），但是您仍然希望使用以旧格式创建的代码，请不要担心！在不破坏任何现有代码的情况下更新消息类型非常简单。只要记住以下规则：</p>
<p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<ul>
<li>不要更改任何已有的字段的数值标识。</li>
<li>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）</li>
<li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li>
<li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li>
<li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li>
<li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li>
<li>枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的</li>
<li>将单个值更改为新 值的成员oneof是安全且二进制兼容的。oneof如果您确定没有代码一次设置多个字段，那么将多个字段移动到新字段中可能是安全的。将任何字段移到现有字段中oneof都是不安全的。</li>
</ul>
<h2 id="未知字段">未知字段<a hidden class="anchor" aria-hidden="true" href="#未知字段">#</a></h2>
<p>未知字段是格式正确的protocol buffers序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件使用新字段解析新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。</p>
<p>最初，proto3消息始终在解析过程中丢弃未知字段，但是在版本3.5中，我们重新引入了保留未知字段以匹配proto2行为的功能。在版本3.5和更高版本中，未知字段将在解析期间保留并包含在序列化输出中。</p>
<h2 id="any">Any<a hidden class="anchor" aria-hidden="true" href="#any">#</a></h2>
<p>Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google/protobuf/any.proto。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">&#34;google/protobuf/any.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">ErrorStatus</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="kt">string</span> <span class="kd">message</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="n">google.protobuf.Any</span> <span class="n">details</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>对于给定的消息类型的默认类型URL是<code>type.googleapis.com/packagename.messagename</code>。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的pack()和unpack()访问器，在C++中会有PackFrom()和UnpackTo()方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Storing an arbitrary message type in Any.
</span><span class="c1"></span><span class="n">NetworkErrorDetails</span> <span class="n">details</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">ErrorStatus</span> <span class="n">status</span><span class="o">;</span>
<span class="n">status</span><span class="o">.</span><span class="na">add_details</span><span class="o">()-&gt;</span><span class="n">PackFrom</span><span class="o">(</span><span class="n">details</span><span class="o">);</span>

<span class="c1">// Reading an arbitrary message from Any.
</span><span class="c1"></span><span class="n">ErrorStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="o">...;</span>
<span class="k">for</span> <span class="o">(</span><span class="kd">const</span> <span class="n">Any</span><span class="o">&amp;</span> <span class="n">detail</span> <span class="o">:</span> <span class="n">status</span><span class="o">.</span><span class="na">details</span><span class="o">())</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">detail</span><span class="o">.</span><span class="na">Is</span><span class="o">&lt;</span><span class="n">NetworkErrorDetails</span><span class="o">&gt;())</span> <span class="o">{</span>
    <span class="n">NetworkErrorDetails</span> <span class="n">network_error</span><span class="o">;</span>
    <span class="n">detail</span><span class="o">.</span><span class="na">UnpackTo</span><span class="o">(&amp;</span><span class="n">network_error</span><span class="o">);</span>
    <span class="o">...</span> <span class="n">processing</span> <span class="n">network_error</span> <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>目前，用于Any类型的动态库仍在开发之中</p>
<p>如果你已经很熟悉proto2语法，使用Any替换扩展。</p>
<h2 id="oneof">Oneof<a hidden class="anchor" aria-hidden="true" href="#oneof">#</a></h2>
<p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存.</p>
<p>Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。 你可以使用case()或者WhichOneof() 方法检查哪个oneof字段被设置， 看你使用什么语言了.</p>
<h3 id="使用oneof">使用Oneof<a hidden class="anchor" aria-hidden="true" href="#使用oneof">#</a></h3>
<p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">SampleMessage</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">oneof</span> <span class="n">test_oneof</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">SubMessage</span> <span class="n">sub_message</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字.</p>
<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API指南中找到oneof API介绍.</p>
<h3 id="oneof特性">oneof特性<a hidden class="anchor" aria-hidden="true" href="#oneof特性">#</a></h3>
<p>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">SampleMessage</span> <span class="n">message</span><span class="o">;</span>
<span class="n">message</span><span class="o">.</span><span class="na">set_name</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">);</span>
<span class="n">CHECK</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">has_name</span><span class="o">());</span>
<span class="n">message</span><span class="o">.</span><span class="na">mutable_sub_message</span><span class="o">();</span>   <span class="c1">// Will clear name field.
</span><span class="c1"></span><span class="n">CHECK</span><span class="o">(!</span><span class="n">message</span><span class="o">.</span><span class="na">has_name</span><span class="o">());</span>
</code></pre></td></tr></table>
</div>
</div><p>如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。</p>
<p>oneof不支持repeated.</p>
<p>反射API对oneof 字段有效.</p>
<p>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">SampleMessage</span> <span class="n">message</span><span class="p">;</span>
<span class="n">SubMessage</span><span class="o">*</span> <span class="n">sub_message</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">mutable_sub_message</span><span class="p">();</span>
<span class="n">message</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">);</span>      <span class="c1">// Will delete sub_message
</span><span class="c1"></span><span class="n">sub_message</span><span class="o">-&gt;</span><span class="n">set_</span><span class="p">...</span>            <span class="c1">// Crashes here
</span></code></pre></td></tr></table>
</div>
</div><p>在C++中，如果你使用Swap()两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，msg1会拥有sub_message并且msg2会有name。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">SampleMessage</span> <span class="n">msg1</span><span class="p">;</span>
<span class="n">msg1</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">);</span>
<span class="n">SampleMessage</span> <span class="n">msg2</span><span class="p">;</span>
<span class="n">msg2</span><span class="p">.</span><span class="n">mutable_sub_message</span><span class="p">();</span>
<span class="n">msg1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg2</span><span class="p">);</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">msg1</span><span class="p">.</span><span class="n">has_sub_message</span><span class="p">());</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">msg2</span><span class="p">.</span><span class="n">has_name</span><span class="p">());</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="向后兼容问题">向后兼容问题<a hidden class="anchor" aria-hidden="true" href="#向后兼容问题">#</a></h3>
<p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None/NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。</p>
<p>Tag 重用问题：</p>
<ul>
<li>将字段移入或移除oneof：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</li>
<li>删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段</li>
<li>分离或者融合oneof：行为与移动常规字段相似。</li>
</ul>
<h2 id="map">Map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h2>
<p>如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">map</span><span class="p">&lt;</span><span class="n">key_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">&gt;</span> <span class="n">map_field</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。</p>
<p>例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="nx">Project</span><span class="p">&gt;</span> <span class="nx">projects</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Map字段不能为repeated。</li>
<li>Map值的线格式排序和Map迭代排序是不确定的，因此您不能依赖于Map项的特定顺序。</li>
<li>为.proto生成文本格式时，Map会按键排序。数字键按数字排序。</li>
<li>从序列化解析或合并时，如果存在重复的映射键，则使用最后看到的键。从文本格式解析Map时，如果键重复，则解析可能会失败。</li>
<li>如果为映射字段提供键但没有值，则序列化字段时的行为取决于语言。在C ++，Java和Python中，类型的默认值是序列化的，而在其他语言中，则没有序列化的值。</li>
</ul>
<p>生成的MapAPI当前可用于所有proto3支持的语言。您可以在相关API参考中找到有关所选语言的map API的更多信息。</p>
<h2 id="well-known类型">Well-Known类型<a hidden class="anchor" aria-hidden="true" href="#well-known类型">#</a></h2>
<p>除了我们前面介绍的基本类型、Any、还有省略未介绍的Service相关的类型外，还有一些大家常见的类型，Protobuf也提供了定义，比如Timestamp和Duration。这里我们看看如何使用它。</p>
<p>Protobuf提供了<code>github.com/golang/protobuf/ptypes/timestamp.Timestamp</code>和<code>github.com/golang/protobuf/ptypes/duration.Duration</code>两种扩展类型，用来表示时间，并提供了和标准库time.Time和 time.Duration的转换函数。</p>
<p>你可以在你的proto中需要时间戳和duration的地方使用这两个类型，而不是使用标准库的time.Time和time.Duration,因为标注库的类型没有提供protobuf序列化反序列化的功能，你需要额外处理，所以不如直接使用Protobuf提供的对应类型(下一节gogo库提供了对标准库的支持，稍候再讲)。</p>
<p>同时，它还是以指针的方式定义字段，这也意味着我们我们可以分别反序列化的时候，可以区分对应字段是否在数据中存在。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">fmt</span> <span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
	<span class="nx">proto</span> <span class="s">&#34;github.com/golang/protobuf/proto&#34;</span>
	<span class="nx">ptypes</span> <span class="s">&#34;github.com/golang/protobuf/ptypes&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">msg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">WellKnownTypes</span><span class="p">{</span>
		<span class="nx">Now</span><span class="p">:</span>  <span class="nx">ptypes</span><span class="p">.</span><span class="nf">TimestampNow</span><span class="p">(),</span>
		<span class="nx">Took</span><span class="p">:</span> <span class="nx">ptypes</span><span class="p">.</span><span class="nf">DurationProto</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="向后兼容">向后兼容<a hidden class="anchor" aria-hidden="true" href="#向后兼容">#</a></h3>
<p>map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">MapFieldEntry</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="n">key_type</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">value_type</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">repeated</span> <span class="n">MapFieldEntry</span> <span class="n">map_field</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>任何支持映射的protocol buffers实现都必须产生并接受可以被上述定义接受的数据。</p>
<h2 id="packages">Packages<a hidden class="anchor" aria-hidden="true" href="#packages">#</a></h2>
<p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">Open</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="o">...</span><span class="err">
</span><span class="err"></span>  <span class="n">foo.bar.Open</span> <span class="n">open</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="o">...</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中； - 对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li>
<li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。</li>
<li>对于Ruby，生成的类可以被包装在内置的Ruby名称空间中，转换成Ruby所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在Foo::Bar名称空间中。</li>
<li>对于javaNano包会使用Java包，除非你在你的文件中显式的提供一个option java_package。</li>
<li>对于C#包可以转换为PascalCase后作为名称空间，除非你在你的文件中显式的提供一个option csharp_namespace，例如，Open会在Foo.Bar名称空间中</li>
</ul>
<h3 id="包及名称的解析">包及名称的解析<a hidden class="anchor" aria-hidden="true" href="#包及名称的解析">#</a></h3>
<p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h3 id="定义服务">定义服务<a hidden class="anchor" aria-hidden="true" href="#定义服务">#</a></h3>
<p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">service</span> <span class="n">SearchService</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">rpc</span> <span class="n">Search</span><span class="p">(</span><span class="n">SearchRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SearchResponse</span><span class="p">);</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>最直观的使用protocol buffer的RPC系统是gRPC,一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p>
<p>如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息</p>
<p>还有一些第三方开发的PRC实现使用Protocol Buffer。参考第三方插件wiki查看这些实现的列表。</p>
<h2 id="json对应">JSON对应<a hidden class="anchor" aria-hidden="true" href="#json对应">#</a></h2>
<p>Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。</p>
<table>
<thead>
<tr>
<th>proto3</th>
<th>JSON</th>
<th>JSON示例</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>object</td>
<td>{“fBar”: v, “g”: null, …}</td>
<td>产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值</td>
</tr>
<tr>
<td>enum</td>
<td>string</td>
<td>“FOO_BAR”</td>
<td>枚举值的名字在proto文件中被指定</td>
</tr>
<tr>
<td>map</td>
<td>object</td>
<td>{“k”: v, …}</td>
<td>所有的键都被转换成string</td>
</tr>
<tr>
<td>repeated V</td>
<td>array</td>
<td>[v, …]</td>
<td>null被视为空列表</td>
</tr>
<tr>
<td>bool</td>
<td>true, false</td>
<td>true, false</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>“Hello World!”</td>
<td></td>
</tr>
<tr>
<td>bytes</td>
<td>base64</td>
<td>string	“YWJjMTIzIT8kKiYoKSctPUB+”</td>
<td></td>
</tr>
<tr>
<td>int32, fixed32, uint32</td>
<td>number</td>
<td>1, -10, 0</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>int64, fixed64, uint64</td>
<td>string</td>
<td>“1”, “-10”</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>float, double</td>
<td>number</td>
<td>1.1, -10.0, 0, “NaN”, “Infinity”</td>
<td>JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td>
</tr>
<tr>
<td>Any</td>
<td>object</td>
<td>{“@type”: “url”, “f”: v, … }</td>
<td>如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：{&quot;@type&quot;: xxx, &ldquo;value&rdquo;: yyy}否则，该值会被转换成一个JSON对象，@type字段会被插入所指定的确定的值</td>
</tr>
<tr>
<td>Timestamp</td>
<td>string</td>
<td>“1972-01-01T10:00:20.021Z”</td>
<td>使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td>
</tr>
<tr>
<td>Duration</td>
<td>string</td>
<td>“1.000340012s”, “1s”</td>
<td>生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td>
</tr>
<tr>
<td>Struct</td>
<td>object</td>
<td>{ … }</td>
<td>任意的JSON对象，见struct.proto</td>
</tr>
<tr>
<td>Wrapper types</td>
<td>various types</td>
<td>2, “2”, “foo”, true, “true”, null, 0, …</td>
<td>包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td>
</tr>
<tr>
<td>FieldMask</td>
<td>string</td>
<td>“f.fooBar,h”</td>
<td>见fieldmask.proto</td>
</tr>
<tr>
<td>ListValue</td>
<td>array</td>
<td>[foo, bar, …]</td>
<td></td>
</tr>
<tr>
<td>Value</td>
<td>value</td>
<td></td>
<td>任意JSON值</td>
</tr>
<tr>
<td>NullValue</td>
<td>null</td>
<td></td>
<td>JSON null</td>
</tr>
</tbody>
</table>
<h3 id="json选项">JSON选项<a hidden class="anchor" aria-hidden="true" href="#json选项">#</a></h3>
<p>一个proto3 JSON实现可以提供以下选项：</p>
<ul>
<li>发出具有默认值的字段：默认情况下，proto3 JSON输出中会省略具有默认值的字段。一个实现可以提供一个选项，以使用其默认值覆盖此行为和输出字段。</li>
<li>忽略未知字段：默认情况下，Proto3 JSON解析器应拒绝未知字段，但可以提供在解析时忽略未知字段的选项。</li>
<li>使用proto字段名称而不是lowerCamelCase名称：默认情况下，proto3 JSON打印应将字段名称转换为lowerCamelCase并将其用作JSON名称。一个实现可以提供一个选项，改为使用原型字段名称作为JSON名称。Proto3 JSON解析器必须接受转换后的lowerCamelCase名称和原型字段名称。</li>
<li>将枚举值发送为整数而不是字符串：默认情况下，JSON输出中使用枚举值的名称。可以提供一个选项来代替使用枚举值的数字值。</li>
</ul>
<h2 id="option">Option<a hidden class="anchor" aria-hidden="true" href="#option">#</a></h2>
<p>定义.proto文件时能够标注一系列的option。Option并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在google/protobuf/descriptor.proto找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选项：</p>
<p>java_package (文件选项) :这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">option</span> <span class="n">java_package</span> <span class="o">=</span> <span class="s">&#34;com.example.foo&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>java_outer_classname (文件选项): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">option</span> <span class="n">java_outer_classname</span> <span class="o">=</span> <span class="s">&#34;Ponycopter&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>java_multiple_files（文件选项）：如果为false，.java则将为此.proto文件仅生成一个文件，以及所有Java类/枚举/等。为顶级消息，服务和枚举生成的消息将嵌套在外部类的内部（请参阅参考资料java_outer_classname）。如果为true，.java则将为每个Java类/枚举/等生成单独的文件。是为顶级消息，服务和枚举生成的，而为此.proto文件生成的包装Java类将不包含任何嵌套的类/枚举/等。这是一个布尔选项，默认为false。如果未生成Java代码，则此选项无效。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">option</span> <span class="n">java_multiple_files</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>optimize_for(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成：</p>
<ul>
<li>SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li>CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li>LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">option</span> <span class="n">optimize_for</span> <span class="o">=</span> <span class="n">CODE_SIZE</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>cc_enable_arenas(文件选项):对于C++产生的代码启用arena allocation</p>
<p>objc_class_prefix(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。</p>
<p>deprecated(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成@Deprecated注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">int32 old_field = 6 [deprecated = true];
</code></pre></td></tr></table>
</div>
</div><h3 id="options">options<a hidden class="anchor" aria-hidden="true" href="#options">#</a></h3>
<p>options其实是protobuf内置的一些message类型，其分为以下几个级别：</p>
<ul>
<li>文件级别(file-level options)</li>
<li>消息级别(message-level options)</li>
<li>字段级别(field-level options)</li>
<li>service级别(service options)</li>
<li>method级别(method options)</li>
</ul>
<p>protobuf提供一些内置的options可供选择，也提供了通过extend关键字来扩展这些options，达到增加自定义options的目的。</p>
<p>在proto2语法中，extend可以作用于任何message，但在proto3语法中，extend仅能作用于这些定义option的message——仅用于自定义option。</p>
<p>options不会改变声明的整体含义（例如声明的是int32就是int32，不会因为一个option改变了其声明类型），但可能会影响在特定情况下处理它的方式。例如我们可以使用内置的deprecated option将某字段标记为deprecated：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Msg</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[</span><span class="n">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span> <span class="c1">//标记为deprecated。
</span><span class="c1"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>当我们需要编写自定义protoc插件时，可以通过自定义options为编译插件提供额外信息。举个例子，假设我要开发一个proto的校验插件，其生成xxx.Validate()方法来校验消息的合法性，我可以通过自定义options来提供生成代码的必要信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Msg</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="c1">// required是自定义options，表示foo字段必须非空
</span><span class="c1"></span>    <span class="kt">string</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">[</span><span class="k">required</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>内置options的定义可以在<code>github.com/protocolbuf…</code>找到，每种级别的options都对应一个message，分别是：</p>
<ul>
<li>FileOptions —— 文件级别</li>
<li>MessageOptions —— 消息级别</li>
<li>FieldOptions —— 字段级别</li>
<li>ServiceOptions —— service级别</li>
<li>MethodOptions —— method级别</li>
</ul>
<p>以下将通过示例来逐一介绍这些级别的options，以及如何扩展这些options。</p>
<h4 id="文件级别">文件级别<a hidden class="anchor" aria-hidden="true" href="#文件级别">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="nx">option</span> <span class="nx">go_package</span> <span class="p">=</span> <span class="s">&#34;examplepb&#34;</span><span class="p">;</span>  <span class="c1">// 编译后的golang包名
</span><span class="c1"></span><span class="o">...</span>
<span class="nx">message</span> <span class="nx">extObj</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">foo_string</span><span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int64</span> <span class="nx">bar_int</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// file options
</span><span class="c1"></span><span class="nx">extend</span> <span class="nx">google</span><span class="p">.</span><span class="nx">protobuf</span><span class="p">.</span><span class="nx">FileOptions</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">file_opt_string</span> <span class="p">=</span> <span class="mi">1001</span><span class="p">;</span>
    <span class="nx">extObj</span> <span class="nx">file_opt_obj</span> <span class="p">=</span> <span class="mi">1002</span><span class="p">;</span>
<span class="p">}</span>
<span class="nf">option</span> <span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">everything</span><span class="p">.</span><span class="nx">file_opt_string</span><span class="p">)</span> <span class="p">=</span> <span class="s">&#34;file_options&#34;</span><span class="p">;</span>
<span class="nf">option</span> <span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">everything</span><span class="p">.</span><span class="nx">file_opt_obj</span><span class="p">)</span> <span class="p">=</span> <span class="p">{</span>
    <span class="nx">foo_string</span><span class="p">:</span> <span class="s">&#34;foo&#34;</span>
    <span class="nx">bar_int</span><span class="p">:</span><span class="mi">1</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>go_package 毫无疑问是protobuf内置提供的，用于指定编译后的golang包名。除了使用内置的外，可以通过extend字段来扩展内置的FileOptions，例如在上述例子中，我们新增了两个新的option——string类型的file_opt_string和extObj类型的file_opt_obj。并通过option关键字设置了两个文件级别的options。在Go语言中，我们可以这样读取这些options:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getFileOptions</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;file options:&#34;</span><span class="p">)</span>
	<span class="nx">msg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">MessageOption</span><span class="p">{}</span>
	<span class="nx">md</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nf">MessageDescriptorProto</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
	<span class="nx">stringOpt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">md</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_FileOptString</span><span class="p">)</span>
	<span class="nx">objOpt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">md</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_FileOptObj</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.foo_string:&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">FooString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.bar_int&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">BarInt</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	string:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">stringOpt</span><span class="p">.(</span><span class="o">*</span><span class="kt">string</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>打印结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">file</span> <span class="n">options</span><span class="o">:</span>
	<span class="n">obj.foo_string</span><span class="o">:</span> <span class="n">foo</span>
	<span class="n">obj.bar_int</span> <span class="m">1</span>
	<span class="n">string</span><span class="o">:</span> <span class="n">file_options</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="消息级别">消息级别<a hidden class="anchor" aria-hidden="true" href="#消息级别">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// message options
</span><span class="c1"></span><span class="nx">extend</span> <span class="nx">google</span><span class="p">.</span><span class="nx">protobuf</span><span class="p">.</span><span class="nx">MessageOptions</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">msg_opt_string</span> <span class="p">=</span> <span class="mi">1001</span><span class="p">;</span>
    <span class="nx">extObj</span> <span class="nx">msg_opt_obj</span> <span class="p">=</span> <span class="mi">1002</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">message</span> <span class="nx">MessageOption</span> <span class="p">{</span>
    <span class="nf">option</span> <span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">everything</span><span class="p">.</span><span class="nx">msg_opt_string</span><span class="p">)</span> <span class="p">=</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">;</span>
    <span class="nf">option</span> <span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">everything</span><span class="p">.</span><span class="nx">msg_opt_obj</span><span class="p">)</span> <span class="p">=</span> <span class="p">{</span>
        <span class="nx">foo_string</span><span class="p">:</span> <span class="s">&#34;foo&#34;</span>
        <span class="nx">bar_int</span><span class="p">:</span><span class="mi">1</span>
    <span class="p">};</span>
    <span class="kt">string</span> <span class="nx">foo</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>与文件级别大同小异，不再赘述。Go语言读取示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getMessageOptions</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;message options:&#34;</span><span class="p">)</span>
	<span class="nx">msg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">MessageOption</span><span class="p">{}</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">md</span> <span class="o">:=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nf">MessageDescriptorProto</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
<span class="nx">objOpt</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">md</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_MsgOptObj</span><span class="p">)</span>
<span class="nx">stringOpt</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">md</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_MsgOptString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.foo_string:&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">FooString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.bar_int&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">BarInt</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	string:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">stringOpt</span><span class="p">.(</span><span class="o">*</span><span class="kt">string</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="字段级别">字段级别<a hidden class="anchor" aria-hidden="true" href="#字段级别">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="c1">// field options
</span><span class="c1"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.FieldOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">field_opt_string</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">extObj</span> <span class="n">field_opt_obj</span> <span class="o">=</span> <span class="mi">1002</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">FieldOption</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="c1">// 自定义的option
</span><span class="c1"></span>    <span class="kt">string</span> <span class="n">foo</span><span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">example.everything.field_opt_string</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="p">,(</span><span class="n">example.everything.field_opt_obj</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>        <span class="n">foo_string</span><span class="o">:</span> <span class="s">&#34;foo&#34;</span><span class="err">
</span><span class="err"></span>        <span class="n">bar_int</span><span class="o">:</span><span class="mi">1</span><span class="err">
</span><span class="err"></span>    <span class="p">}];</span><span class="err">
</span><span class="err"></span>    <span class="c1">// protobuf内置的option
</span><span class="c1"></span>    <span class="kt">string</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[</span><span class="n">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>字段级别的option定义方式不使用option关键字，格式为：用[]包裹的用逗号分隔的k=v形式的数组。在Go语言中，我们可以这样读取这些option：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getFieldOptions</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;field options:&#34;</span><span class="p">)</span>
	<span class="nx">msg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">FieldOption</span><span class="p">{}</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">md</span> <span class="o">:=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nf">MessageDescriptorProto</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
<span class="nx">stringOpt</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">md</span><span class="p">.</span><span class="nx">Field</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_FieldOptString</span><span class="p">)</span>
<span class="nx">objOpt</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">md</span><span class="p">.</span><span class="nx">Field</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_FieldOptObj</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.foo_string:&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">FooString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.bar_int&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">BarInt</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	string:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">stringOpt</span><span class="p">.(</span><span class="o">*</span><span class="kt">string</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="service和method级别">service和method级别<a hidden class="anchor" aria-hidden="true" href="#service和method级别">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="c1">// service &amp; method options
</span><span class="c1"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.ServiceOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">srv_opt_string</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">extObj</span> <span class="n">srv_opt_obj</span> <span class="o">=</span> <span class="mi">1002</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.MethodOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">method_opt_string</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">extObj</span> <span class="n">method_opt_obj</span> <span class="o">=</span> <span class="mi">1002</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">service</span> <span class="n">ServiceOption</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="k">option</span> <span class="p">(</span><span class="n">example.everything.srv_opt_string</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;foo&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="k">rpc</span> <span class="n">Search</span> <span class="p">(</span><span class="n">SearchRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SearchResponse</span><span class="p">)</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>        <span class="k">option</span> <span class="p">(</span><span class="n">example.everything.method_opt_string</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;foo&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span>        <span class="k">option</span> <span class="p">(</span><span class="n">example.everything.method_opt_obj</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>            <span class="n">foo_string</span><span class="o">:</span> <span class="s">&#34;foo&#34;</span><span class="err">
</span><span class="err"></span>            <span class="n">bar_int</span><span class="o">:</span> <span class="mi">1</span><span class="err">
</span><span class="err"></span>        <span class="p">};</span><span class="err">
</span><span class="err"></span>    <span class="p">};</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>service和method级别的option也是通过option关键字来定义，与文件级别和消息级别option类似，不再赘述。Go语言读取示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getServiceOptions</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;service options:&#34;</span><span class="p">)</span>
	<span class="nx">msg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">MessageOption</span><span class="p">{}</span>
	<span class="nx">md</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nf">MessageDescriptorProto</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
	<span class="nx">srv</span> <span class="o">:=</span> <span class="nx">md</span><span class="p">.</span><span class="nx">Service</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// ServiceOption
</span><span class="c1"></span>	<span class="nx">stringOpt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_SrvOptString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	string:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">stringOpt</span><span class="p">.(</span><span class="o">*</span><span class="kt">string</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">getMethodOptions</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;method options:&#34;</span><span class="p">)</span>
	<span class="nx">msg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">MessageOption</span><span class="p">{}</span>
	<span class="nx">md</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nf">MessageDescriptorProto</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
	<span class="nx">srv</span> <span class="o">:=</span> <span class="nx">md</span><span class="p">.</span><span class="nx">Service</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// ServiceOption
</span><span class="c1"></span>	<span class="nx">objOpt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Method</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_MethodOptObj</span><span class="p">)</span>
	<span class="nx">stringOpt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">GetExtension</span><span class="p">(</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Method</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Options</span><span class="p">,</span> <span class="nx">examplepb</span><span class="p">.</span><span class="nx">E_MethodOptString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.foo_string:&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">FooString</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	obj.bar_int&#34;</span><span class="p">,</span> <span class="nx">objOpt</span><span class="p">.(</span><span class="o">*</span><span class="nx">examplepb</span><span class="p">.</span><span class="nx">ExtObj</span><span class="p">).</span><span class="nx">BarInt</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;	string:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">stringOpt</span><span class="p">.(</span><span class="o">*</span><span class="kt">string</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="自定义选项">自定义选项<a hidden class="anchor" aria-hidden="true" href="#自定义选项">#</a></h3>
<p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看 Proto2 Language Guide。注意创建自定义选项使用了拓展，拓展只在proto3中可用。</p>
<p>由于options是定在 google/protobuf/descriptor.proto中的，因此你可以在该文件中进行扩展，定义自己的选项。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">&#34;google/protobuf/descriptor.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.MessageOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">string</span> <span class="n">my_option</span> <span class="o">=</span> <span class="mi">51234</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">MyMessage</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">my_option</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>在上述代码中，通过对MessageOptions进行扩展定义了一个新的消息级别的选项。当使用该选项时，选项的名称需要使用（）包裹起来，以表明它是一个扩展。在C++代码中可以看出my_option是以如下方式被读取的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="n">MyMessage</span><span class="o">::</span><span class="n">descriptor</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">().</span><span class="n">GetExtension</span><span class="p">(</span><span class="n">my_option</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在Java代码中的读取方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">MyProtoFile</span><span class="o">.</span><span class="na">MyMessage</span><span class="o">.</span><span class="na">getDescriptor</span><span class="o">().</span><span class="na">getOptions</span><span class="o">()</span>
  <span class="o">.</span><span class="na">getExtension</span><span class="o">(</span><span class="n">MyProtoFile</span><span class="o">.</span><span class="na">myOption</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在Python中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">value</span> <span class="o">=</span> <span class="n">my_proto_file_pb2</span><span class="o">.</span><span class="n">MyMessage</span><span class="o">.</span><span class="n">DESCRIPTOR</span><span class="o">.</span><span class="n">GetOptions</span><span class="p">()</span>
  <span class="o">.</span><span class="n">Extensions</span><span class="p">[</span><span class="n">my_proto_file_pb2</span><span class="o">.</span><span class="n">my_option</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>正如上面的读取方式，定制选项对于Python并不支持。定制选项在protocol buffer语言中可用于任何结构。下面就是一些具体的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="s">&#34;google/protobuf/descriptor.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.FileOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">string</span> <span class="n">my_file_option</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.MessageOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">int32</span> <span class="n">my_message_option</span> <span class="o">=</span> <span class="mi">50001</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.FieldOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">float</span> <span class="n">my_field_option</span> <span class="o">=</span> <span class="mi">50002</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.EnumOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">bool</span> <span class="n">my_enum_option</span> <span class="o">=</span> <span class="mi">50003</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.EnumValueOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">uint32</span> <span class="n">my_enum_value_option</span> <span class="o">=</span> <span class="mi">50004</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.ServiceOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="n">MyEnum</span> <span class="n">my_service_option</span> <span class="o">=</span> <span class="mi">50005</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.MethodOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="n">MyMessage</span> <span class="n">my_method_option</span> <span class="o">=</span> <span class="mi">50006</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="k">option</span> <span class="p">(</span><span class="n">my_file_option</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">MyMessage</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">my_message_option</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">int32</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">my_field_option</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">];</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">string</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">enum</span> <span class="n">MyEnum</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">my_enum_option</span><span class="p">)</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">FOO</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">my_enum_value_option</span><span class="p">)</span> <span class="o">=</span> <span class="mi">321</span><span class="p">];</span><span class="err">
</span><span class="err"></span>  <span class="n">BAR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">RequestType</span> <span class="p">{}</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">ResponseType</span> <span class="p">{}</span><span class="err">
</span><span class="err"></span><span class="kd">service</span> <span class="n">MyService</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">my_service_option</span><span class="p">)</span> <span class="o">=</span> <span class="n">FOO</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="k">rpc</span> <span class="n">MyMethod</span><span class="p">(</span><span class="n">RequestType</span><span class="p">)</span> <span class="k">returns</span><span class="p">(</span><span class="n">ResponseType</span><span class="p">)</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="c1">// Note:  my_method_option has type MyMessage.  We can set each field
</span><span class="c1"></span>    <span class="c1">//   within it using a separate &#34;option&#34; line.
</span><span class="c1"></span>    <span class="k">option</span> <span class="p">(</span><span class="n">my_method_option</span><span class="p">)</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="mi">567</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="k">option</span> <span class="p">(</span><span class="n">my_method_option</span><span class="p">)</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s">&#34;Some string&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>注：如果要在该选项定义之外使用一个自定义的选项，必须要由包名 + 选项名来定义该选项。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="c1">// foo.proto
</span><span class="c1"></span><span class="k">import</span> <span class="s">&#34;google/protobuf/descriptor.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kn">package</span> <span class="nn">foo</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.MessageOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">string</span> <span class="n">my_option</span> <span class="o">=</span> <span class="mi">51234</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="c1">// bar.proto
</span><span class="c1"></span><span class="k">import</span> <span class="s">&#34;foo.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kn">package</span> <span class="nn">bar</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">MyMessage</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">foo.my_option</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>最后一件事情需要注意：因为自定义选项是可扩展的，它必须象其它的域或扩展一样来定义标识号。正如上述示例，[50000－99999]已经被占 用，该范围内的值已经被内部所使用，当然了你可以在内部应用中随意使用。如果你想在一些公共应用中进行自定义选项，你必须确保它是全局唯一的。可以通过protobuf-global-extension-registry@google.com来获取全局唯一标识号。 只需提供你的项目名和项目网站. 通常你只需要一个扩展号。 你可以使用一个扩展号声明多个选项:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">FooOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">int32</span> <span class="n">opt1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">string</span> <span class="n">opt2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">extend</span> <span class="nc">google</span><span class="o">.</span><span class="n">protobuf.FieldOptions</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="n">FooOptions</span> <span class="n">foo_options</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="c1">// usage:
</span><span class="c1"></span><span class="kd">message</span> <span class="nc">Bar</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">optional</span> <span class="kt">int32</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">foo_options</span><span class="p">)</span><span class="o">.</span><span class="n">opt1</span> <span class="o">=</span> <span class="mi">123</span><span class="p">,</span> <span class="p">(</span><span class="n">foo_options</span><span class="p">)</span><span class="o">.</span><span class="n">opt2</span> <span class="o">=</span> <span class="s">&#34;baz&#34;</span><span class="p">];</span><span class="err">
</span><span class="err"></span>  <span class="c1">// alternative aggregate syntax (uses TextFormat):
</span><span class="c1"></span>  <span class="k">optional</span> <span class="kt">int32</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">foo_options</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="n">opt1</span><span class="o">:</span> <span class="mi">123</span> <span class="n">opt2</span><span class="o">:</span> <span class="s">&#34;baz&#34;</span> <span class="p">}];</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="生成类">生成类<a hidden class="anchor" aria-hidden="true" href="#生成类">#</a></h2>
<p>可以通过定义好的.proto文件来生成Java,Python,C++, Ruby, JavaNano, Objective-C,或者C# 代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器插件。你可以通过GitHub上的protobuf库找到安装过程</p>
<p>通过如下方式调用protocol编译器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">protoc --proto_path<span class="o">=</span>IMPORT_PATH --cpp_out<span class="o">=</span>DST_DIR --java_out<span class="o">=</span>DST_DIR --python_out<span class="o">=</span>DST_DIR --go_out<span class="o">=</span>DST_DIR --ruby_out<span class="o">=</span>DST_DIR --objc_out<span class="o">=</span>DST_DIR --csharp_out<span class="o">=</span>DST_DIR path/to/file.proto
</code></pre></td></tr></table>
</div>
</div><p>IMPORT_PATH声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用&ndash;proto_path，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是&ndash;proto_path的简化形式。</p>
<p>当然也可以提供一个或多个输出路径：</p>
<ul>
<li>&ndash;cpp_out 在目标目录DST_DIR中产生C++代码，可以在C++代码生成参考中查看更多。</li>
<li>&ndash;java_out 在目标目录DST_DIR中产生Java代码，可以在 Java代码生成参考中查看更多。</li>
<li>&ndash;python_out 在目标目录 DST_DIR 中产生Python代码，可以在Python代码生成参考中查看更多。</li>
<li>&ndash;go_out 在目标目录 DST_DIR 中产生Go代码，可以在GO代码生成参考中查看更多。</li>
<li>&ndash;ruby_out在目标目录 DST_DIR 中产生Ruby代码，参考正在制作中。</li>
<li>&ndash;javanano_out在目标目录DST_DIR中生成JavaNano，JavaNano代码生成器有一系列的选项用于定制自定义生成器的输出：你可以通过生成器的README查找更多信息，JavaNano参考正在制作中。</li>
<li>&ndash;objc_out在目标目录DST_DIR中产生Object代码，可以在Objective-C代码生成参考中查看更多。</li>
<li>&ndash;csharp_out在目标目录DST_DIR中产生Object代码，可以在C#代码生成参考中查看更多。</li>
<li>&ndash;php_out在目标目录DST_DIR中产生Object代码，可以在PHP代码生成参考中查看更多。</li>
</ul>
<p>作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。</p>
<p>你必须提议一个或多个.proto文件作为输入，多个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。</p>
<h1 id="语言规范">语言规范<a hidden class="anchor" aria-hidden="true" href="#语言规范">#</a></h1>
<p>这是协议缓冲区语言（proto3）版本3的语言规范参考。使用扩展Backus-Naur形式（EBNF）指定语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">|</span>   <span class="nf">alternation
</span><span class="nf"></span><span class="p">()</span>  <span class="n">grouping</span>
<span class="n">[]</span>  <span class="nf">option </span><span class="p">(</span><span class="n">zero</span> <span class="n">or</span> <span class="n">one</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{}</span>  <span class="nf">repetition </span><span class="p">(</span><span class="n">any</span> <span class="n">number</span> <span class="n">of</span> <span class="n">times</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>有关使用proto3的更多信息，请参见语言指南。</p>
<h2 id="词汇要素">词汇要素<a hidden class="anchor" aria-hidden="true" href="#词汇要素">#</a></h2>
<h3 id="字母和数字">字母和数字<a hidden class="anchor" aria-hidden="true" href="#字母和数字">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">letter</span> <span class="o">=</span> <span class="s">&#34;A&#34;</span> … <span class="s">&#34;Z&#34;</span> <span class="o">|</span> <span class="s">&#34;a&#34;</span> … <span class="s">&#34;z&#34;</span>
<span class="n">decimalDigit</span> <span class="o">=</span> <span class="s">&#34;0&#34;</span> … <span class="s">&#34;9&#34;</span>
<span class="n">octalDigit</span>   <span class="o">=</span> <span class="s">&#34;0&#34;</span> … <span class="s">&#34;7&#34;</span>
<span class="n">hexDigit</span>     <span class="o">=</span> <span class="s">&#34;0&#34;</span> … <span class="s">&#34;9&#34;</span> <span class="o">|</span> <span class="s">&#34;A&#34;</span> … <span class="s">&#34;F&#34;</span> <span class="o">|</span> <span class="s">&#34;a&#34;</span> … <span class="s">&#34;f&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="身份标识">身份标识<a hidden class="anchor" aria-hidden="true" href="#身份标识">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ident</span> <span class="o">=</span> <span class="n">letter</span> <span class="p">{</span> <span class="n">letter</span> <span class="o">|</span> <span class="n">decimalDigit</span> <span class="o">|</span> <span class="s">&#34;_&#34;</span> <span class="p">}</span>
<span class="n">fullIdent</span> <span class="o">=</span> <span class="n">ident</span> <span class="p">{</span> <span class="s">&#34;.&#34;</span> <span class="n">ident</span> <span class="p">}</span>
<span class="n">messageName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">enumName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">fieldName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">oneofName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">mapName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">serviceName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">rpcName</span> <span class="o">=</span> <span class="n">ident</span>
<span class="n">messageType</span> <span class="o">=</span> <span class="n">[</span> <span class="s">&#34;.&#34;</span> <span class="n">]</span> <span class="p">{</span> <span class="n">ident</span> <span class="s">&#34;.&#34;</span> <span class="p">}</span> <span class="n">messageName</span>
<span class="n">enumType</span> <span class="o">=</span> <span class="n">[</span> <span class="s">&#34;.&#34;</span> <span class="n">]</span> <span class="p">{</span> <span class="n">ident</span> <span class="s">&#34;.&#34;</span> <span class="p">}</span> <span class="n">enumName</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="整数文字">整数文字<a hidden class="anchor" aria-hidden="true" href="#整数文字">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">intLit</span>     <span class="o">=</span> <span class="n">decimalLit</span> <span class="o">|</span> <span class="n">octalLit</span> <span class="o">|</span> <span class="n">hexLit</span>
<span class="n">decimalLit</span> <span class="o">=</span> <span class="p">(</span> <span class="s">&#34;1&#34;</span> … <span class="s">&#34;9&#34;</span> <span class="p">)</span> <span class="p">{</span> <span class="n">decimalDigit</span> <span class="p">}</span>
<span class="n">octalLit</span>   <span class="o">=</span> <span class="s">&#34;0&#34;</span> <span class="p">{</span> <span class="n">octalDigit</span> <span class="p">}</span>
<span class="n">hexLit</span>     <span class="o">=</span> <span class="s">&#34;0&#34;</span> <span class="p">(</span> <span class="s">&#34;x&#34;</span> <span class="o">|</span> <span class="s">&#34;X&#34;</span> <span class="p">)</span> <span class="n">hexDigit</span> <span class="p">{</span> <span class="n">hexDigit</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="浮点文字">浮点文字<a hidden class="anchor" aria-hidden="true" href="#浮点文字">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">floatLit</span> <span class="o">=</span> <span class="p">(</span> <span class="n">decimals</span> <span class="s">&#34;.&#34;</span> <span class="n">[</span> <span class="n">decimals</span> <span class="n">]</span> <span class="n">[</span> <span class="n">exponent</span> <span class="n">]</span> <span class="o">|</span> <span class="n">decimals</span> <span class="n">exponent</span> <span class="o">|</span> <span class="s">&#34;.&#34;</span><span class="n">decimals</span> <span class="n">[</span> <span class="n">exponent</span> <span class="n">]</span> <span class="p">)</span> <span class="o">|</span> <span class="s">&#34;inf&#34;</span> <span class="o">|</span> <span class="s">&#34;nan&#34;</span>
<span class="n">decimals</span>  <span class="o">=</span> <span class="n">decimalDigit</span> <span class="p">{</span> <span class="n">decimalDigit</span> <span class="p">}</span>
<span class="n">exponent</span>  <span class="o">=</span> <span class="p">(</span> <span class="s">&#34;e&#34;</span> <span class="o">|</span> <span class="s">&#34;E&#34;</span> <span class="p">)</span> <span class="n">[</span> <span class="s">&#34;+&#34;</span> <span class="o">|</span> <span class="s">&#34;-&#34;</span> <span class="n">]</span> <span class="n">decimals</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="布尔型">布尔型<a hidden class="anchor" aria-hidden="true" href="#布尔型">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">boolLit</span> <span class="o">=</span> <span class="s">&#34;true&#34;</span> <span class="o">|</span> <span class="s">&#34;false&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="字符串文字">字符串文字<a hidden class="anchor" aria-hidden="true" href="#字符串文字">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">strLit</span> <span class="o">=</span> <span class="p">(</span> <span class="s">&#34;&#39;&#34;</span> <span class="p">{</span> <span class="n">charValue</span> <span class="p">}</span> <span class="s">&#34;&#39;&#34;</span> <span class="p">)</span> <span class="o">|</span>  <span class="p">(</span> <span class="s">&#39;&#34;&#39;</span> <span class="p">{</span> <span class="n">charValue</span> <span class="p">}</span> <span class="s">&#39;&#34;&#39;</span> <span class="p">)</span>
<span class="n">charValue</span> <span class="o">=</span> <span class="n">hexEscape</span> <span class="o">|</span> <span class="n">octEscape</span> <span class="o">|</span> <span class="n">charEscape</span> <span class="o">|</span> <span class="o">/</span><span class="n">[^\0\n\\]</span><span class="o">/</span>
<span class="n">hexEscape</span> <span class="o">=</span> <span class="s">&#39;\&#39; ( &#34;x&#34; | &#34;X&#34; ) hexDigit hexDigit
</span><span class="s">octEscape = &#39;</span><span class="n">\</span><span class="s">&#39; octalDigit octalDigit octalDigit
</span><span class="s">charEscape = &#39;</span><span class="n">\</span><span class="s">&#39; ( &#34;a&#34; | &#34;b&#34; | &#34;f&#34; | &#34;n&#34; | &#34;r&#34; | &#34;t&#34; | &#34;v&#34; | &#39;</span><span class="n">\</span><span class="s">&#39; | &#34;&#39;&#34; | &#39;&#34;&#39; )
</span><span class="s">quote = &#34;&#39;&#34; | &#39;&#34;&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="空声明">空声明<a hidden class="anchor" aria-hidden="true" href="#空声明">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">emptyStatement</span> <span class="o">=</span> <span class="s">&#34;;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="不变">不变<a hidden class="anchor" aria-hidden="true" href="#不变">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">constant</span> <span class="o">=</span> <span class="n">fullIdent</span> <span class="o">|</span> <span class="p">(</span> <span class="n">[</span> <span class="s">&#34;-&#34;</span> <span class="o">|</span> <span class="s">&#34;+&#34;</span> <span class="n">]</span> <span class="n">intLit</span> <span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="n">[</span> <span class="s">&#34;-&#34;</span> <span class="o">|</span> <span class="s">&#34;+&#34;</span> <span class="n">]</span> <span class="n">floatLit</span> <span class="p">)</span> <span class="o">|</span> <span class="n">strLit</span> <span class="o">|</span> <span class="n">boolLit</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="句法">句法<a hidden class="anchor" aria-hidden="true" href="#句法">#</a></h2>
<p>语法语句用于定义protobuf版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;syntax&#34;</span> <span class="s">&#34;=&#34;</span> <span class="n">quote</span> <span class="s">&#34;proto3&#34;</span> <span class="n">quote</span> <span class="s">&#34;;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="import">import<a hidden class="anchor" aria-hidden="true" href="#import">#</a></h2>
<p>import语句用于导入另一个.proto的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">import</span> <span class="o">=</span> <span class="s">&#34;import&#34;</span> <span class="n">[</span> <span class="s">&#34;weak&#34;</span> <span class="o">|</span> <span class="s">&#34;public&#34;</span> <span class="n">]</span> <span class="n">strLit</span> <span class="s">&#34;;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">import</span> <span class="n">public</span> <span class="s">&#34;other.proto&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="package">package<a hidden class="anchor" aria-hidden="true" href="#package">#</a></h2>
<p>包说明符可用于防止协议消息类型之间的名称冲突。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">package</span> <span class="o">=</span> <span class="s">&#34;package&#34;</span> <span class="n">fullIdent</span> <span class="s">&#34;;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kn">package</span> <span class="nn">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="选项">选项<a hidden class="anchor" aria-hidden="true" href="#选项">#</a></h2>
<p>选项可用于原始文件，消息，枚举和服务。选项可以是protobuf定义的选项，也可以是自定义选项。有关更多信息，请参见语言指南中的选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">option</span> <span class="o">=</span> <span class="s">&#34;option&#34;</span> <span class="n">optionName</span>  <span class="s">&#34;=&#34;</span> <span class="n">constant</span> <span class="s">&#34;;&#34;</span>
<span class="n">optionName</span> <span class="o">=</span> <span class="p">(</span> <span class="n">ident</span> <span class="o">|</span> <span class="s">&#34;(&#34;</span> <span class="n">fullIdent</span> <span class="s">&#34;)&#34;</span> <span class="p">)</span> <span class="p">{</span> <span class="s">&#34;.&#34;</span> <span class="n">ident</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">option</span> <span class="n">java_package</span> <span class="o">=</span> <span class="s">&#34;com.example.foo&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="字段">字段<a hidden class="anchor" aria-hidden="true" href="#字段">#</a></h2>
<p>字段是协议缓冲区消息的基本元素。字段可以是普通字段，字段之一或地图字段。字段具有类型和字段编号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">type</span> <span class="o">=</span> <span class="s">&#34;double&#34;</span> <span class="o">|</span> <span class="s">&#34;float&#34;</span> <span class="o">|</span> <span class="s">&#34;int32&#34;</span> <span class="o">|</span> <span class="s">&#34;int64&#34;</span> <span class="o">|</span> <span class="s">&#34;uint32&#34;</span> <span class="o">|</span> <span class="s">&#34;uint64&#34;</span>
      <span class="o">|</span> <span class="s">&#34;sint32&#34;</span> <span class="o">|</span> <span class="s">&#34;sint64&#34;</span> <span class="o">|</span> <span class="s">&#34;fixed32&#34;</span> <span class="o">|</span> <span class="s">&#34;fixed64&#34;</span> <span class="o">|</span> <span class="s">&#34;sfixed32&#34;</span> <span class="o">|</span> <span class="s">&#34;sfixed64&#34;</span>
      <span class="o">|</span> <span class="s">&#34;bool&#34;</span> <span class="o">|</span> <span class="s">&#34;string&#34;</span> <span class="o">|</span> <span class="s">&#34;bytes&#34;</span> <span class="o">|</span> <span class="n">messageType</span> <span class="o">|</span> <span class="n">enumType</span>
<span class="n">fieldNumber</span> <span class="o">=</span> <span class="n">intLit</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="普通字段">普通字段<a hidden class="anchor" aria-hidden="true" href="#普通字段">#</a></h3>
<p>每个字段都有类型，名称和字段编号。它可能具有字段选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">field</span> <span class="o">=</span> <span class="n">[</span> <span class="s">&#34;repeated&#34;</span> <span class="n">]</span> <span class="n">type</span> <span class="n">fieldName</span> <span class="s">&#34;=&#34;</span> <span class="n">fieldNumber</span> <span class="n">[</span> <span class="s">&#34;[&#34;</span> <span class="n">fieldOptions</span> <span class="s">&#34;]&#34;</span> <span class="n">]</span> <span class="s">&#34;;&#34;</span>
<span class="n">fieldOptions</span> <span class="o">=</span> <span class="n">fieldOption</span> <span class="p">{</span> <span class="s">&#34;,&#34;</span>  <span class="n">fieldOption</span> <span class="p">}</span>
<span class="n">fieldOption</span> <span class="o">=</span> <span class="n">optionName</span> <span class="s">&#34;=&#34;</span> <span class="n">constant</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">foo.Bar</span> <span class="n">nested_message</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="k">repeated</span> <span class="kt">int32</span> <span class="n">samples</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">[</span><span class="k">packed</span><span class="o">=</span><span class="kc">true</span><span class="p">];</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="oneof-1">oneof<a hidden class="anchor" aria-hidden="true" href="#oneof-1">#</a></h3>
<p>oneof由一个字段和一个名称组成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">oneof</span> <span class="o">=</span> <span class="s">&#34;oneof&#34;</span> <span class="n">oneofName</span> <span class="s">&#34;{&#34;</span> <span class="p">{</span> <span class="n">option</span> <span class="o">|</span> <span class="n">oneofField</span> <span class="o">|</span> <span class="n">emptyStatement</span> <span class="p">}</span> <span class="s">&#34;}&#34;</span>
<span class="n">oneofField</span> <span class="o">=</span> <span class="n">type</span> <span class="n">fieldName</span> <span class="s">&#34;=&#34;</span> <span class="n">fieldNumber</span> <span class="n">[</span> <span class="s">&#34;[&#34;</span> <span class="n">fieldOptions</span> <span class="s">&#34;]&#34;</span> <span class="n">]</span> <span class="s">&#34;;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="k">oneof</span> <span class="n">foo</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>    <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span><span class="err"></span>    <span class="n">SubMessage</span> <span class="n">sub_message</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="map-1">map<a hidden class="anchor" aria-hidden="true" href="#map-1">#</a></h3>
<p>映射字段具有键类型，值类型，名称和字段编号。键类型可以是任何整数或字符串类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">mapField</span> <span class="o">=</span> <span class="s">&#34;map&#34;</span> <span class="s">&#34;&lt;&#34;</span> <span class="n">keyType</span> <span class="s">&#34;,&#34;</span> <span class="n">type</span> <span class="s">&#34;&gt;&#34;</span> <span class="n">mapName</span> <span class="s">&#34;=&#34;</span> <span class="n">fieldNumber</span> <span class="n">[</span> <span class="s">&#34;[&#34;</span> <span class="n">fieldOptions</span> <span class="s">&#34;]&#34;</span> <span class="n">]</span> <span class="s">&#34;;&#34;</span>
<span class="n">keyType</span> <span class="o">=</span> <span class="s">&#34;int32&#34;</span> <span class="o">|</span> <span class="s">&#34;int64&#34;</span> <span class="o">|</span> <span class="s">&#34;uint32&#34;</span> <span class="o">|</span> <span class="s">&#34;uint64&#34;</span> <span class="o">|</span> <span class="s">&#34;sint32&#34;</span> <span class="o">|</span> <span class="s">&#34;sint64&#34;</span> <span class="o">|</span>
          <span class="s">&#34;fixed32&#34;</span> <span class="o">|</span> <span class="s">&#34;fixed64&#34;</span> <span class="o">|</span> <span class="s">&#34;sfixed32&#34;</span> <span class="o">|</span> <span class="s">&#34;sfixed64&#34;</span> <span class="o">|</span> <span class="s">&#34;bool&#34;</span> <span class="o">|</span> <span class="s">&#34;string&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">map</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Project</span><span class="p">&gt;</span> <span class="n">projects</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="reserve">reserve<a hidden class="anchor" aria-hidden="true" href="#reserve">#</a></h2>
<p>reserve语句声明了此消息中不能使用的一系列字段号或字段名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">reserved</span> <span class="o">=</span> <span class="s">&#34;reserved&#34;</span> <span class="p">(</span> <span class="n">ranges</span> <span class="o">|</span> <span class="n">fieldNames</span> <span class="p">)</span> <span class="s">&#34;;&#34;</span>
<span class="n">ranges</span> <span class="o">=</span> <span class="n">range</span> <span class="p">{</span> <span class="s">&#34;,&#34;</span> <span class="n">range</span> <span class="p">}</span>
<span class="n">range</span> <span class="o">=</span>  <span class="n">intLit</span> <span class="n">[</span> <span class="s">&#34;to&#34;</span> <span class="p">(</span> <span class="n">intLit</span> <span class="o">|</span> <span class="s">&#34;max&#34;</span> <span class="p">)</span> <span class="n">]</span>
<span class="n">fieldNames</span> <span class="o">=</span> <span class="n">fieldName</span> <span class="p">{</span> <span class="s">&#34;,&#34;</span> <span class="n">fieldName</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">reserved</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span> <span class="k">to</span> <span class="mi">11</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="n">reserved</span> <span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="s">&#34;bar&#34;</span><span class="p">;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="顶级定义">顶级定义<a hidden class="anchor" aria-hidden="true" href="#顶级定义">#</a></h2>
<h3 id="枚举定义">枚举定义<a hidden class="anchor" aria-hidden="true" href="#枚举定义">#</a></h3>
<p>枚举定义由名称和枚举主体组成。枚举主体可以具有选项和枚举字段。枚举定义必须以枚举值零开始。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">enum</span> <span class="o">=</span> <span class="s">&#34;enum&#34;</span> <span class="n">enumName</span> <span class="n">enumBody</span>
<span class="n">enumBody</span> <span class="o">=</span> <span class="s">&#34;{&#34;</span> <span class="p">{</span> <span class="n">option</span> <span class="o">|</span> <span class="n">enumField</span> <span class="o">|</span> <span class="n">emptyStatement</span> <span class="p">}</span> <span class="s">&#34;}&#34;</span>
<span class="n">enumField</span> <span class="o">=</span> <span class="n">ident</span> <span class="s">&#34;=&#34;</span> <span class="n">[</span> <span class="s">&#34;-&#34;</span> <span class="n">]</span> <span class="n">intLit</span> <span class="n">[</span> <span class="s">&#34;[&#34;</span> <span class="n">enumValueOption</span> <span class="p">{</span> <span class="s">&#34;,&#34;</span>  <span class="n">enumValueOption</span> <span class="p">}</span> <span class="s">&#34;]&#34;</span> <span class="n">]</span><span class="s">&#34;;&#34;</span>
<span class="n">enumValueOption</span> <span class="o">=</span> <span class="n">optionName</span> <span class="s">&#34;=&#34;</span> <span class="n">constant</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">enum</span> <span class="n">EnumAllowingAlias</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="n">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">STARTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">RUNNING</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">custom_option</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;hello world&#34;</span><span class="p">];</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="消息定义">消息定义<a hidden class="anchor" aria-hidden="true" href="#消息定义">#</a></h3>
<p>消息由消息名称和消息正文组成。消息主体可以具有字段，嵌套枚举定义，嵌套消息定义，选项，oneof，映射字段和保留语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">message</span> <span class="o">=</span> <span class="s">&#34;message&#34;</span> <span class="n">messageName</span> <span class="n">messageBody</span>
<span class="n">messageBody</span> <span class="o">=</span> <span class="s">&#34;{&#34;</span> <span class="p">{</span> <span class="n">field</span> <span class="o">|</span> <span class="n">enum</span> <span class="o">|</span> <span class="n">message</span> <span class="o">|</span> <span class="n">option</span> <span class="o">|</span> <span class="n">oneof</span> <span class="o">|</span> <span class="n">mapField</span> <span class="o">|</span>
<span class="n">reserved</span> <span class="o">|</span> <span class="n">emptyStatement</span> <span class="p">}</span> <span class="s">&#34;}&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">message</span> <span class="nc">Outer</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">my_option</span><span class="p">)</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kd">message</span> <span class="nc">Inner</span> <span class="p">{</span>   <span class="c1">// Level 2
</span><span class="c1"></span>    <span class="kt">int64</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="n">map</span><span class="p">&lt;</span><span class="kt">int32</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">my_map</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="服务定义">服务定义<a hidden class="anchor" aria-hidden="true" href="#服务定义">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">service</span> <span class="o">=</span> <span class="s">&#34;service&#34;</span> <span class="n">serviceName</span> <span class="s">&#34;{&#34;</span> <span class="p">{</span> <span class="n">option</span> <span class="o">|</span> <span class="n">rpc</span> <span class="o">|</span> <span class="n">emptyStatement</span> <span class="p">}</span> <span class="s">&#34;}&#34;</span>
<span class="n">rpc</span> <span class="o">=</span> <span class="s">&#34;rpc&#34;</span> <span class="n">rpcName</span> <span class="s">&#34;(&#34;</span> <span class="n">[</span> <span class="s">&#34;stream&#34;</span> <span class="n">]</span> <span class="n">messageType</span> <span class="s">&#34;)&#34;</span> <span class="s">&#34;returns&#34;</span> <span class="s">&#34;(&#34;</span> <span class="n">[</span> <span class="s">&#34;stream&#34;</span> <span class="n">]</span>
<span class="n">messageType</span> <span class="s">&#34;)&#34;</span> <span class="p">((</span> <span class="s">&#34;{&#34;</span> <span class="p">{</span><span class="n">option</span> <span class="o">|</span> <span class="n">emptyStatement</span> <span class="p">}</span> <span class="s">&#34;}&#34;</span> <span class="p">)</span> <span class="o">|</span> <span class="s">&#34;;&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="kd">service</span> <span class="n">SearchService</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">rpc</span> <span class="n">Search</span> <span class="p">(</span><span class="n">SearchRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SearchResponse</span><span class="p">);</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="原始文件">原始文件<a hidden class="anchor" aria-hidden="true" href="#原始文件">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">proto</span> <span class="o">=</span> <span class="n">syntax</span> <span class="p">{</span> <span class="n">import</span> <span class="o">|</span> <span class="n">package</span> <span class="o">|</span> <span class="n">option</span> <span class="o">|</span> <span class="n">topLevelDef</span> <span class="o">|</span> <span class="n">emptyStatement</span> <span class="p">}</span>
<span class="n">topLevelDef</span> <span class="o">=</span> <span class="n">message</span> <span class="o">|</span> <span class="n">enum</span> <span class="o">|</span> <span class="n">service</span>
</code></pre></td></tr></table>
</div>
</div><p>.proto示例文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="k">import</span> <span class="n">public</span> <span class="s">&#34;other.proto&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="k">option</span> <span class="n">java_package</span> <span class="o">=</span> <span class="s">&#34;com.example.foo&#34;</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="kd">enum</span> <span class="n">EnumAllowingAlias</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="n">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">STARTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">RUNNING</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">custom_option</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;hello world&#34;</span><span class="p">];</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span><span class="err"></span><span class="kd">message</span> <span class="nc">Outer</span> <span class="p">{</span><span class="err">
</span><span class="err"></span>  <span class="k">option</span> <span class="p">(</span><span class="n">my_option</span><span class="p">)</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="kd">message</span> <span class="nc">Inner</span> <span class="p">{</span>   <span class="c1">// Level 2
</span><span class="c1"></span>    <span class="kt">int64</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="p">}</span><span class="err">
</span><span class="err"></span>  <span class="k">repeated</span> <span class="n">Inner</span> <span class="n">inner_message</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">EnumAllowingAlias</span> <span class="n">enum_field</span> <span class="o">=</span><span class="mi">3</span><span class="p">;</span><span class="err">
</span><span class="err"></span>  <span class="n">map</span><span class="p">&lt;</span><span class="kt">int32</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">my_map</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span><span class="err"></span><span class="p">}</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h1 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h1>
<p><a href="https://juejin.cn/post/6844904147339198472#heading-0">Protobuf语法全解析</a></p>
<p><a href="https://colobu.com/2015/01/07/Protobuf-language-guide/">[译]Protobuf 语法指南</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/protobuf/">protobuf</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
