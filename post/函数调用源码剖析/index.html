<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>函数调用源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.1 with theme even" />


<link rel="canonical" href="/post/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="函数调用源码剖析" />
<meta property="og:description" content="前言 函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-30T12:40:39+00:00" />
<meta property="article:modified_time" content="2021-06-30T12:40:39+00:00" />

<meta itemprop="name" content="函数调用源码剖析">
<meta itemprop="description" content="前言 函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执"><meta itemprop="datePublished" content="2021-06-30T12:40:39+00:00" />
<meta itemprop="dateModified" content="2021-06-30T12:40:39+00:00" />
<meta itemprop="wordCount" content="6232">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="函数调用源码剖析"/>
<meta name="twitter:description" content="前言 函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">函数调用源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-30 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 6232 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#调用惯例">调用惯例</a></li>
    <li><a href="#c-语言">C 语言</a></li>
    <li><a href="#go-语言">Go 语言</a></li>
    <li><a href="#go的函数调用规约">Go的函数调用规约</a></li>
    <li><a href="#参数传递">参数传递</a>
      <ul>
        <li><a href="#整型和数组">整型和数组</a></li>
        <li><a href="#结构体和指针">结构体和指针</a></li>
        <li><a href="#传值">传值</a></li>
      </ul>
    </li>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执行过程。</p>
<h2 id="调用惯例">调用惯例</h2>
<p>无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">somefunction</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，本节将为各位读者介绍 C 和 Go 语言的调用惯例。</p>
<h2 id="c-语言">C 语言</h2>
<p>我们先来研究 C 语言的调用惯例，使用 gcc1 或者 clang2 将 C 语言编译成汇编代码是分析其调用惯例的最好方法，从汇编语言中可以了解函数调用的具体过程。</p>
<p>gcc 和 clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 gcc 编译器来编译 C 语言：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">gcc</span> <span class="o">--</span><span class="n">version</span>
<span class="nf">gcc </span><span class="p">(</span><span class="n">Ubuntu</span> <span class="m">4.8.2-19</span><span class="n">ubuntu1</span><span class="p">)</span> <span class="m">4.8.2</span>
<span class="nf">Copyright </span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="m">2013</span> <span class="n">Free</span> <span class="n">Software</span> <span class="n">Foundation</span><span class="p">,</span> <span class="n">Inc.</span>
<span class="n">This</span> <span class="n">is</span> <span class="n">free</span> <span class="n">software</span><span class="p">;</span> <span class="n">see</span> <span class="n">the</span> <span class="n">source</span> <span class="n">for</span> <span class="n">copying</span> <span class="n">conditions.</span>  <span class="n">There</span> <span class="n">is</span> <span class="n">NO</span>
<span class="n">warranty</span><span class="p">;</span> <span class="n">not</span> <span class="n">even</span> <span class="n">for</span> <span class="n">MERCHANTABILITY</span> <span class="n">or</span> <span class="n">FITNESS</span> <span class="n">FOR</span> <span class="n">A</span> <span class="n">PARTICULAR</span> <span class="n">PURPOSE.</span>
</code></pre></td></tr></table>
</div>
</div><p>假设我们有以下的 C 语言代码，代码中只包含两个函数，其中一个是主函数 main，另一个是我们定义的函数 my_function：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// ch04/my_function.c
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">my_function</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以使用 <code>cc -S my_function.c</code> 命令将上述文件编译成如下所示的汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">main</span><span class="o">:</span>
	<span class="n">pushq</span>	<span class="o">%rbp
</span><span class="o">	movq	%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%rbp
</span><span class="o">	subq	$16, %</span><span class="n">rsp</span>
	<span class="n">movl</span>	<span class="o">$</span><span class="m">2</span><span class="p">,</span> <span class="o">%esi  // 设置第二个参数
</span><span class="o">	movl	$1, %</span><span class="n">edi</span>  <span class="o">//</span> 设置第一个参数
	<span class="n">call</span>	<span class="n">my_function</span>
	<span class="n">movl</span>	<span class="o">%eax, -4(%</span><span class="n">rbp</span><span class="p">)</span>
<span class="n">my_function</span><span class="o">:</span>
	<span class="n">pushq</span>	<span class="o">%rbp
</span><span class="o">	movq	%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%rbp
</span><span class="o">	movl	%</span><span class="n">edi</span><span class="p">,</span> <span class="m">-4</span><span class="p">(</span><span class="o">%rbp)    // 取出第一个参数，放到栈上
</span><span class="o">	movl	%</span><span class="n">esi</span><span class="p">,</span> <span class="m">-8</span><span class="p">(</span><span class="o">%rbp)    // 取出第二个参数，放到栈上
</span><span class="o">	movl	-8(%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%eax    // eax = esi = 1
</span><span class="o">	movl	-4(%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%edx    // edx = edi = 2
</span><span class="o">	addl	%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%eax        // eax = eax + edx = 1 + 2 = 3
</span><span class="o">	popq	%</span><span class="n">rbp</span>
</code></pre></td></tr></table>
</div>
</div><p>我们按照调用前、调用时以及调用后的顺序分析上述调用过程：</p>
<ul>
<li>在 my_function 调用前，调用方 main 函数将 my_function 的两个参数分别存到 edi 和 esi 寄存器中；</li>
<li>在 my_function 调用时，它会将寄存器 edi 和 esi 中的数据存储到 eax 和 edx 两个寄存器中，随后通过汇编指令 addl 计算两个入参之和；</li>
<li>在 my_function 调用后，使用寄存器 eax 传递返回值，main 函数将 my_function 的返回值存储到栈上的 i 变量中；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">int</span> <span class="p">...</span> <span class="n">arg8</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="n">arg8</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如上述代码所示，当 my_function 函数的入参增加至八个时，重新编译当前程序可以会得到不同的汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">main</span><span class="o">:</span>
	<span class="n">pushq</span>	<span class="o">%rbp
</span><span class="o">	movq	%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%rbp
</span><span class="o">	subq	$16, %</span><span class="n">rsp</span>     <span class="o">//</span> 为参数传递申请 <span class="m">16</span> 字节的栈空间
	<span class="n">movl</span>	<span class="o">$</span><span class="m">8</span><span class="p">,</span> <span class="m">8</span><span class="p">(</span><span class="o">%rsp)   // 传递第 8 个参数
</span><span class="o">	movl	$7, (%</span><span class="n">rsp</span><span class="p">)</span>    <span class="o">//</span> 传递第 <span class="m">7</span> 个参数
	<span class="n">movl</span>	<span class="o">$</span><span class="m">6</span><span class="p">,</span> <span class="o">%r9d
</span><span class="o">	movl	$5, %</span><span class="n">r8d</span>
	<span class="n">movl</span>	<span class="o">$</span><span class="m">4</span><span class="p">,</span> <span class="o">%ecx
</span><span class="o">	movl	$3, %</span><span class="n">edx</span>
	<span class="n">movl</span>	<span class="o">$</span><span class="m">2</span><span class="p">,</span> <span class="o">%esi
</span><span class="o">	movl	$1, %</span><span class="n">edi</span>
	<span class="n">call</span>	<span class="n">my_function</span>
</code></pre></td></tr></table>
</div>
</div><p>main 函数调用 <code>my_function</code> 时，前六个参数会使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递。寄存器的使用顺序也是调用惯例的一部分，函数的第一个参数一定会使用 edi 寄存器，第二个参数使用 esi 寄存器，以此类推。</p>
<p>最后的两个参数与前面的完全不同，调用方 main 函数通过栈传递这两个参数，下图展示了 main 函数在调用 my_function 前的栈信息：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210630135454.png" alt=""></p>
<p>上图中 rbp 寄存器会存储函数调用栈的基址指针，即属于 main 函数的栈空间的起始位置，而另一个寄存器 rsp 存储的是 main 函数调用栈结束的位置，这两个寄存器共同表示了函数的栈空间。</p>
<p>在调用 my_function 之前，main 函数通过 subq $16, %rsp 指令分配了 16 个字节的栈地址，随后将第六个以上的参数按照从右到左的顺序存入栈中，即第八个和第七个，余下的六个参数会通过寄存器传递，接下来运行的 call my_function 指令会调用 my_function 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">my_function</span><span class="o">:</span>
	<span class="n">pushq</span>	<span class="o">%rbp
</span><span class="o">	movq	%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%rbp
</span><span class="o">	movl	%</span><span class="n">edi</span><span class="p">,</span> <span class="m">-4</span><span class="p">(</span><span class="o">%rbp)    // rbp-4 = edi = 1
</span><span class="o">	movl	%</span><span class="n">esi</span><span class="p">,</span> <span class="m">-8</span><span class="p">(</span><span class="o">%rbp)    // rbp-8 = esi = 2
</span><span class="o">	...
</span><span class="o">	movl	-8(%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%eax    // eax = 2
</span><span class="o">	movl	-4(%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%edx    // edx = 1
</span><span class="o">	addl	%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%edx        // edx = eax + edx = 3
</span><span class="o">	...
</span><span class="o">	movl	16(%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%eax    // eax = 7
</span><span class="o">	addl	%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%edx        // edx = eax + edx = 28
</span><span class="o">	movl	24(%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%eax    // eax = 8
</span><span class="o">	addl	%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%eax        // edx = eax + edx = 36
</span><span class="o">	popq	%</span><span class="n">rbp</span>
</code></pre></td></tr></table>
</div>
</div><p>my_function 会先将寄存器中的全部数据转移到栈上，然后利用 eax 寄存器计算所有入参的和并返回结果。</p>
<p>我们可以将本节的发现和分析简单总结成 — 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p>
<ul>
<li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li>
<li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li>
</ul>
<p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p>
<h2 id="go-语言">Go 语言</h2>
<p>Go 1.17版本之前，Go采用基于栈的调用约定，即函数的参数与返回值都通过栈来传递，这种方式的优点是实现简单，不用担心底层cpu架构寄存器的差异，适合跨平台；但缺点就是牺牲了一些性能，我们都知道寄存器的访问速度要远高于内存。</p>
<p>大多数平台上的大多数语言实现都使用基于寄存器的调用约定，通过寄存器而不是内存传递函数参数和返回结果，并指定一些寄存器为调用保存寄存器，允许函数在不同的调用中保持状态。</p>
<p>于是Go在1.17版本决定向这些语言看齐，在amd64架构下率先实现了从基于堆栈的调用惯例到基于寄存器的调用惯例的切换。</p>
<p>在Go 1.17的版本发布说明文档中有提到：切换到基于寄存器的调用惯例后，一组有代表性的Go包和程序的基准测试显示，Go程序的运行性能提高了约5%，二进制文件大小典型减少约2%。我们可以通过反汇编对其进行简单的观察。这里依然为了简化问题，我们只用 int 参数(float 使用的不是通用寄存器)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="c1">//go:noinline
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">z</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">f</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">l</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>稍微多传一些参数方便我们观察，输入 12 个参数，返回 11 个值。</p>
<p>直接看反汇编的结果，首先是对 main.add 的调用部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main.main</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">xargin</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">abi.go</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">15</span>             <span class="mh">0x1054e60</span>               <span class="m">4</span><span class="n">c8da42478ffffff</span>        <span class="n">LEAQ</span> <span class="mh">0xffffff78</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">R12</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">15</span>             <span class="mh">0x1054e68</span>               <span class="m">4</span><span class="n">d3b6610</span>                <span class="n">CMPQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="n">R14</span><span class="p">),</span> <span class="n">R12</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">15</span>             <span class="mh">0x1054e6c</span>               <span class="m">0</span><span class="n">f865a020000</span>            <span class="n">JBE</span> <span class="mh">0x10550cc</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">15</span>             <span class="mh">0x1054e72</span>               <span class="m">4881</span><span class="n">ec08010000</span>          <span class="n">SUBQ</span> <span class="o">$</span><span class="mh">0x108</span><span class="p">,</span> <span class="n">SP</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">15</span>             <span class="mh">0x1054e79</span>               <span class="m">4889</span><span class="n">ac2400010000</span>        <span class="n">MOVQ</span> <span class="n">BP</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">15</span>             <span class="mh">0x1054e81</span>               <span class="m">488</span><span class="n">dac2400010000</span>        <span class="n">LEAQ</span> <span class="mh">0x100</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BP</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054e89</span>               <span class="m">48</span><span class="n">c704240a000000</span>        <span class="n">MOVQ</span> <span class="o">$</span><span class="mh">0xa</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 第 <span class="m">10</span> 个参数
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054e91</span>               <span class="m">48</span><span class="n">c74424080b000000</span>      <span class="n">MOVQ</span> <span class="o">$</span><span class="mh">0xb</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 第 <span class="m">11</span> 个参数
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054e9a</span>               <span class="m">48</span><span class="n">c74424100c000000</span>      <span class="n">MOVQ</span> <span class="o">$</span><span class="mh">0xc</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 第 <span class="m">12</span> 个参数
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ea3</span>               <span class="n">b801000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">AX</span> <span class="o">//</span> 第 <span class="m">1</span> 个参数，后面以此类推
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ea8</span>               <span class="n">bb02000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">BX</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ead</span>               <span class="n">b903000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">CX</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054eb2</span>               <span class="n">bf04000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x4</span><span class="p">,</span> <span class="n">DI</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054eb7</span>               <span class="n">be05000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x5</span><span class="p">,</span> <span class="n">SI</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ebc</span>               <span class="m">41</span><span class="n">b806000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x6</span><span class="p">,</span> <span class="n">R8</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ec2</span>               <span class="m">41</span><span class="n">b907000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x7</span><span class="p">,</span> <span class="n">R9</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ec8</span>               <span class="m">41</span><span class="n">ba08000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="n">R10</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ece</span>               <span class="m">41</span><span class="n">bb09000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x9</span><span class="p">,</span> <span class="n">R11</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ed4</span>               <span class="n">e807fdffff</span>              <span class="n">CALL</span> <span class="nf">main.add</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">16</span>             <span class="mh">0x1054ed9</span>               <span class="m">48898424</span><span class="n">f8000000</span>        <span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，官方只使用了 9 个通用寄存器，依次是 AX，BX，CX，DI，SI，R8，R9，R10，R11，超出部分，按顺序放在栈上。</p>
<p>然后是 main.add 的返回值部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main.add</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">xargin</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">abi.go</span>
<span class="n">....</span>  省略 <span class="n">print</span> 的部分
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c2f</span>               <span class="m">48</span><span class="n">c74424400a000000</span>      <span class="n">MOVQ</span> <span class="o">$</span><span class="mh">0xa</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 第 <span class="m">10</span> 个返回值
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c38</span>               <span class="m">48</span><span class="n">c74424480b000000</span>      <span class="n">MOVQ</span> <span class="o">$</span><span class="mh">0xb</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 第 <span class="m">11</span> 个返回值
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c41</span>               <span class="n">b801000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">AX</span> <span class="o">//</span> 第 <span class="m">1</span> 个返回值，后面以此类推
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c46</span>               <span class="n">bb02000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">BX</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c4b</span>               <span class="n">b903000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">CX</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c50</span>               <span class="n">bf04000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x4</span><span class="p">,</span> <span class="n">DI</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c55</span>               <span class="n">be05000000</span>              <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x5</span><span class="p">,</span> <span class="n">SI</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c5a</span>               <span class="m">41</span><span class="n">b806000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x6</span><span class="p">,</span> <span class="n">R8</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c60</span>               <span class="m">41</span><span class="n">b907000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x7</span><span class="p">,</span> <span class="n">R9</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c66</span>               <span class="m">41</span><span class="n">ba08000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="n">R10</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c6c</span>               <span class="m">41</span><span class="n">bb09000000</span>            <span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x9</span><span class="p">,</span> <span class="n">R11</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c72</span>               <span class="m">488</span><span class="n">b6c2418</span>              <span class="n">MOVQ</span> <span class="mh">0x18</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BP</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c77</span>               <span class="m">4883</span><span class="n">c420</span>                <span class="n">ADDQ</span> <span class="o">$</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">SP</span>
  <span class="n">abi.go</span><span class="o">:</span><span class="m">6</span>              <span class="mh">0x1054c7b</span>               <span class="n">c3</span>                      <span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>返回值和输入使用了完全相同的寄存器序列，同样在超出 9 个返回值时，多出的内容在栈上返回。</p>
<p>在传统的调用规约中，一般会区分 caller saved registers 和 callee saved registers，但在 Go 中，所有寄存器都是 caller saved，也就是由 caller 负责保存，在 callee 中不保证不对其现场进行破坏。</p>
<p>这里可以看到，返回值直接就把入参使用的寄存器直接覆盖掉了，也可以证明这一点。</p>
<p>因为函数调用不需要通过栈来传参了，所以在一些函数调用嵌套层次比较深的场景下，goroutine 栈本身使用的内存也有一定概率会降低。</p>
<h2 id="go的函数调用规约">Go的函数调用规约</h2>
<p>调用规约是程序员需要遵守的关于函数调用顺序的约定。</p>
<p>如果所有人都遵守同样的规则的话，那么就可以流畅地完成合作。一旦有人破坏规则，例如，修改或者在一个函数中不恢复 rbp 的值，那么可能会发生：啥事都没有，稍后程序崩溃，或者程序马上就崩。由于其它函数在编写的时候都假定自身以外的函数是遵守这些调用规则的，且保证 rbp 寄存器不被修改。</p>
<p>调用规约定义的其中之一就是参数的传递算法。我们这里使用传统的 *nix 的 x86 64 下的习惯(在[24]中详细定义)，下面的描述对于函数如何被调用是一个相对精确的近似。</p>
<p>1.首先，需要对值进行保护的寄存器需要保存好原来的值。除了七个 callee-saved 寄存器(rbx，rbp，rsp，r12 - r15)都可能被被调用函数所修改，所以如果这些寄存器的值重要的话，就需要把这些寄存器的值保存起来(一般都在栈上保存)。
2.寄存器和栈都会被参数填充。 每个参数都会被 round 到 8 字节。 参数会被分为三个列表： (a) 整数和指针参数 (b) Float 和 double 参数 (c) 通过内存中的栈传入的参数 第一个列表中的前六个参数通过六个通用寄存器传入(rdi，rsi，rdx，rcx，r8 和 r9)。第二个列表中的前八个参数通过 xmm0 ~ xmm7 这八个寄存器传入。如果前两个列表还有更多的参数传入，那么这些多余的参数会被以反序存储在栈上传入。也就是说，在函数被执行前，传入的最后一个参数应该是在栈顶上。 整数和浮点数参数传递比较简单，结构体传入则稍微复杂一些。 如果一个结构体大于 32 字节，或者有未对齐的字段，那么就会通过内存传入。 小结构体会按照其字段被分解为多个字段，每一个字段都被分别处理，如果结构体内又有结构体，那么也会被递归做相同处理。所以一个包含两个元素的结构体可以用两个参数的同样的方式进行传入。如果结构体的某个字段被认为是 &ldquo;内存&rdquo;，那么就会冒泡到结构体本身。 rbp 寄存器像我们即将看到的，会用来定位通过内存传入的参数以及局部变量。 返回值往哪里填呢？整数和指针会存储在 rax 和 rdx 中返回。浮点数会在 xmm0 和 xmm1 返回。大结构体会以一个指针形式返回，该指针以隐藏的附加参数返回，像下面这个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">s</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">vals</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">s</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">s</span> <span class="n">mys</span><span class="p">;</span>
    <span class="n">mys</span><span class="p">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">mys</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">s</span><span class="o">*</span> <span class="n">ret</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span><span class="o">-&gt;</span><span class="n">vals</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>3.然后就可以调用 call 指令了。call 的参数是需要调用的函数的第一条指令的地址。call 指令会将该地址 push 到栈上。</p>
<p>每一个程序都可以有同一个函数的多个实例同时执行，这些同时执行的函数并不一定是在不同的线程中，且有可能是由于递归导致的多实例。这个函数的每一个实例都会被存储在栈上，因为栈的主要规则是后进先出，因此该特性会反映在函数的运行和销毁上。一个函数 f 在运行后调用了函数 g，那么 g 会先被销毁(而 g 从时间上来讲是后被调用的)，f 之后才被销毁 (然而 f 在时间上是先被调用的)。</p>
<p>栈帧是为某一函数所专用的栈的一部分。栈帧保存了局部变量，临时变量和保存的寄存器。</p>
<p>函数代码一般会被一对 prologue 代码和 epilogue 代码包裹，对所有函数来说都一样。prologue 用来初始化栈帧，epilogue 用来逆向初始化(销毁)。</p>
<p>函数执行过程中，rbp 保持不变并一直指向该函数栈帧的起始位置。这样就可以用 rbp 寄存器外加偏移量来对局部变量进行寻址了。列表 14-1 中的代码对此有所反映。</p>
<p>Listing 14-1.prologue.asm</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">func</span><span class="o">:</span>
<span class="n">push</span> <span class="n">rbp</span>
<span class="n">mov</span> <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>

<span class="n">sub</span> <span class="n">rsp</span><span class="p">,</span> <span class="m">24</span>      <span class="p">;</span> <span class="n">given</span> <span class="m">24</span> <span class="n">is</span> <span class="n">total</span> <span class="n">size</span> <span class="n">of</span> <span class="n">local</span> <span class="n">variables</span>
</code></pre></td></tr></table>
</div>
</div><p>老的 rbp 值被存储起来以便之后在 epilogue 中恢复。然后 rbp 被设置为当前的栈的栈顶值(顺便说一下，栈顶现在存储的是 rbp 的老值)。接下来为局部变量分配空间的话，就只需要让 rsp 的值减去该变量的大小就可以了。这也是我们在栈上分配 buffer 空间的方式。</p>
<p>局部变量现在若要分配内存则可以直接用 rsp 减去其大小</p>
<p>函数结束的 epilogue 片段如列表 14-2 所示。</p>
<p>Listing 14-2.epilogue.asm</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">mov</span> <span class="n">rsp</span><span class="p">,</span> <span class="n">rbp</span>
<span class="n">pop</span> <span class="n">rbp</span>
<span class="n">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>通过将栈帧的起始地址移动到 rsp，我们可以确保所有在栈上分配的空间都被释放掉了。然后老的 rbp 值也就被恢复了，现在 rbp 会指向前一个栈帧的起始地址。最后 ret 指令会将返回地址从栈弹出到 rip 中。</p>
<p>编译器一般使用的是一组完全等价的替代指令，参见列表 14-3。</p>
<p>Listing 14-3.epilogue_alt.asm</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Leave</span>
<span class="n">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>leave 指令是特别为栈帧销毁所发明的指令。其反义指令 enter 则不太被很多编译器所接受，因为这条指令提供了比列表 14-1 更多的功能。指令本身是针对那些内嵌函数支持的编程语言设计的。</p>
<p>4.在离开函数之后，并不是说我们的工作就结束了。由于一些参数是通过内存(栈)传入的，我们也需要把这些也清理掉。</p>
<h2 id="参数传递">参数传递</h2>
<p>除了函数的调用惯例之外，Go 语言在传递参数时是传值还是传引用也是一个有趣的问题，不同的选择会影响我们在函数中修改入参时是否会影响调用方看到的数据。我们先来介绍一下传值和传引用两者的区别：</p>
<ul>
<li>传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li>
<li>传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。</li>
</ul>
<p>不同语言会选择不同的方式传递参数，Go 语言选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝。本节剩下的内容将会验证这个结论的正确性。</p>
<h3 id="整型和数组">整型和数组</h3>
<p>我们先来分析 Go 语言是如何传递基本类型和数组的。如下所示的函数 myFunction 接收了两个参数，整型变量 i 和数组 arr，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 myFunction 函数调用前后分别打印两个参数的地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">myFunction</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">30</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before calling - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
	<span class="nf">myFunction</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;after  calling - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">before</span> <span class="n">calling</span> <span class="o">-</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="mh">0xc00009a000</span><span class="p">)</span> <span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">[66</span> <span class="m">77</span><span class="n">]</span><span class="p">,</span> <span class="mh">0xc00009a010</span><span class="p">)</span>
<span class="n">in</span> <span class="n">my_funciton</span> <span class="o">-</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="mh">0xc00009a008</span><span class="p">)</span> <span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">[66</span> <span class="m">77</span><span class="n">]</span><span class="p">,</span> <span class="mh">0xc00009a020</span><span class="p">)</span>
<span class="n">after</span>  <span class="n">calling</span> <span class="o">-</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="mh">0xc00009a000</span><span class="p">)</span> <span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">[66</span> <span class="m">77</span><span class="n">]</span><span class="p">,</span> <span class="mh">0xc00009a010</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们通过命令运行这段代码时会发现，main 函数和被调用者 myFunction 中参数的地址是完全不同的。</p>
<p>不过从 main 函数的角度来看，在调用 myFunction 前后，整数 i 和数组 arr 两个参数的地址都没有变化。那么如果我们在 myFunction 函数内部对参数进行修改是否会影响 main 函数中的变量呢？这里更新 myFunction 函数并重新执行这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">myFunction</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="mi">29</span>
	<span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">88</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="nx">arr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">before</span> <span class="n">calling</span> <span class="o">-</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="mh">0xc000072008</span><span class="p">)</span> <span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">[66</span> <span class="m">77</span><span class="n">]</span><span class="p">,</span> <span class="mh">0xc000072010</span><span class="p">)</span>
<span class="n">in</span> <span class="n">my_funciton</span> <span class="o">-</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="m">29</span><span class="p">,</span> <span class="mh">0xc000072028</span><span class="p">)</span> <span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">[66</span> <span class="m">88</span><span class="n">]</span><span class="p">,</span> <span class="mh">0xc000072040</span><span class="p">)</span>
<span class="n">after</span>  <span class="n">calling</span> <span class="o">-</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="m">30</span><span class="p">,</span> <span class="mh">0xc000072008</span><span class="p">)</span> <span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">[66</span> <span class="m">77</span><span class="n">]</span><span class="p">,</span> <span class="mh">0xc000072010</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以看到在 myFunction 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 main 函数，所以能得出如下结论：Go 语言的整型和数组类型都是值传递的，也就是在调用函数时会对内容进行拷贝。需要注意的是如果当前数组的大小非常的大，这种传值的方式会对性能造成比较大的影响。</p>
<h3 id="结构体和指针">结构体和指针</h3>
<p>接下来我们继续分析 Go 语言另外两种常见类型 — 结构体和指针。下面这段代码中定义了一个结构体 MyStruct 以及接受两个参数的 myFunction 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyStruct</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">myFunction</span><span class="p">(</span><span class="nx">a</span> <span class="nx">MyStruct</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">MyStruct</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">31</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">41</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;in my_function - a=(%d, %p) b=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nx">MyStruct</span><span class="p">{</span><span class="nx">i</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MyStruct</span><span class="p">{</span><span class="nx">i</span><span class="p">:</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before calling - a=(%d, %p) b=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>
	<span class="nf">myFunction</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;after calling  - a=(%d, %p) b=(%v, %p)\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">before</span> <span class="n">calling</span> <span class="o">-</span> <span class="n">a</span><span class="o">=</span><span class="p">({</span><span class="m">30</span><span class="p">},</span> <span class="mh">0xc000018178</span><span class="p">)</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="o">&amp;</span><span class="p">{</span><span class="m">40</span><span class="p">},</span> <span class="mh">0xc00000c028</span><span class="p">)</span>
<span class="n">in</span> <span class="n">my_function</span> <span class="o">-</span> <span class="n">a</span><span class="o">=</span><span class="p">({</span><span class="m">31</span><span class="p">},</span> <span class="mh">0xc000018198</span><span class="p">)</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="o">&amp;</span><span class="p">{</span><span class="m">41</span><span class="p">},</span> <span class="mh">0xc00000c038</span><span class="p">)</span>
<span class="n">after</span> <span class="n">calling</span>  <span class="o">-</span> <span class="n">a</span><span class="o">=</span><span class="p">({</span><span class="m">30</span><span class="p">},</span> <span class="mh">0xc000018178</span><span class="p">)</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="o">&amp;</span><span class="p">{</span><span class="m">41</span><span class="p">},</span> <span class="mh">0xc00000c028</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>从上述运行的结果我们可以得出如下结论：</p>
<ul>
<li>传递结构体时：会拷贝结构体中的全部内容；</li>
<li>传递结构体指针时：会拷贝结构体指针；</li>
</ul>
<p>修改结构体指针是改变了指针指向的结构体，b.i 可以被理解成 (*b).i，也就是我们先获取指针 b 背后的结构体，再修改结构体的成员变量。我们简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyStruct</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="kt">int</span>
	<span class="nx">j</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">myFunction</span><span class="p">(</span><span class="nx">ms</span> <span class="o">*</span><span class="nx">MyStruct</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">((</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">i</span><span class="p">))))</span>
		<span class="o">*</span><span class="nx">c</span> <span class="o">+=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%p] %d\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="o">*</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MyStruct</span><span class="p">{</span><span class="nx">i</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="nx">j</span><span class="p">:</span> <span class="mi">50</span><span class="p">}</span>
	<span class="nf">myFunction</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%p] %v\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">[0xc000018180]</span> <span class="m">41</span>
<span class="n">[0xc000018188]</span> <span class="m">52</span>
<span class="n">[0xc000018180]</span> <span class="o">&amp;</span><span class="p">{</span><span class="m">41</span> <span class="m">52</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这段代码中，我们通过指针修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 MyStruct 指针修改成 int 类型的，那么访问新指针就会返回整型变量 i，将指针移动 8 个字节之后就能获取下一个成员变量 j。</p>
<p>如果我们将上述代码简化成如下所示的代码片段并使用 go tool compile 进行编译会得到如下的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyStruct</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="kt">int</span>
	<span class="nx">j</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">myFunction</span><span class="p">(</span><span class="nx">ms</span> <span class="o">*</span><span class="nx">MyStruct</span><span class="p">)</span><span class="o">*</span><span class="nx">MyStruct</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">ms</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">tool</span> <span class="n">compile</span> <span class="o">-</span><span class="n">S</span> <span class="o">-</span><span class="n">N</span> <span class="o">-</span><span class="n">l</span> <span class="n">main.go</span>
<span class="s">&#34;&#34;</span><span class="n">.myFunction</span> <span class="n">STEXT</span> <span class="n">nosplit</span> <span class="n">size</span><span class="o">=</span><span class="m">20</span> <span class="n">args</span><span class="o">=</span><span class="mh">0x10</span> <span class="n">locals</span><span class="o">=</span><span class="mh">0x0</span>
	<span class="mh">0x0000</span> <span class="m">00000</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">8</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="o">$</span><span class="m">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">.~r1</span><span class="m">+16</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 初始化返回值
	<span class="mh">0x0009</span> <span class="m">00009</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="s">&#34;&#34;</span><span class="n">.ms</span><span class="m">+8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>   <span class="o">//</span> 复制引用
	<span class="mh">0x000e</span> <span class="m">00014</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>	<span class="n">MOVQ</span>	<span class="n">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="n">.~r1</span><span class="m">+16</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span> <span class="o">//</span> 返回引用
	<span class="mh">0x0013</span> <span class="m">00019</span> <span class="p">(</span><span class="n">main.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>在这段汇编语言中，我们发现当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令复制引用，然后将复制后的指针作为返回值传递回调用方。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210630151146.png" alt=""></p>
<p>所以将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。</p>
<h3 id="传值">传值</h3>
<p>当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。</p>
<h2 id="转载">转载</h2>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/">4.1 函数调用</a>
<a href="https://xargin.com/go1-17-new-calling-convention/">简单看看 Go 1.17 的新调用规约</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-06-30
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84arrayslicestring%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">基本数据结构array,slice,string源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/interface%E5%92%8Creflect%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <span class="next-text nav-default">interface和reflect源码剖析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
