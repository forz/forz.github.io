<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go的IO库介绍 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go的IO库介绍" />
<meta property="og:description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-06T17:45:39&#43;00:00" />
<meta property="article:modified_time" content="2021-08-06T17:45:39&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的IO库介绍"/>
<meta name="twitter:description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go的IO库介绍",
      "item": "/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go的IO库介绍",
  "name": "Go的IO库介绍",
  "description": "Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可",
  "keywords": [
    "Go"
  ],
  "articleBody": "Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可比的。\n前置小知识点：并行和并发的区别？\n并行看的是时刻，并发看的是时间段。\n2021/1/1 12:00:00 这个时刻有两个请求在同时被执行，这说的是并行； 2021/1/1 12:00:00 - 2021/1/1 12:00:01 这 1 秒的时间，完成了 1000 个请求，qps 为 1000，这种说的是并发； 好，先回归主题，Go 除了 Goroutine 足够轻量之外，支持如此高并发的这其中的秘诀在哪里？\n执行体调度得当。CPU 不停的在不同的执行体（ Goroutine ）之间反复横跳！CPU 一直在装填和运行不同执行体的指令，G1（Goroutine 1 的缩写） 不行就搞 G2 ，一刻不能停，这样才能使得大量的执行体（ Goroutine ）齐头并进，系统才能完成如此高并发的吞吐（注意关键字：并发哦）。\n思考一个问题，程序可分为 CPU 密集型的程序和 IO 密集型的程序两种，Go 适合哪种？\nIO 密集型。\n这里的理由其实很有意思，先说为什么不合适 CPU 密集型呢？\n理由其实很简单，CPU 密集型就意味着每个执行体都是急需 CPU 的，G1 吃 CPU 都不够，还切到 G2 去干嘛？所以 CPU 密集型的程序最好的情况就是不调度！ 绑核都来不及呢。想要提高这种程序的性能，就是加钱，买核，买 CPU，买 GPU，把 CPU 核并行起来。\n为什么 IO 密集型就好了？\n划重点：IO 设备和 CPU 可是不同的独立设备呀。 这两者之间的处理可是并行运行的。\nGo 程序的协程调度则可以很好的利用这个关系，让 CPU 执行程序指令，只负责发送 IO ，一旦 IO 被 IO 设备接收，不等待完成，就可以处理其他人的指令，IO 的完成以异步事件的形式触发。这样 IO 设备的处理过程就和 CPU 的执行并行了起来。\n任何 IO 都适配 Go 吗？\n不是的。IO 也分为网络 IO 和文件 IO 。其实适合 Go 的程序类型准确的来讲是：网络 IO 密集型的程序。\n其中差异就在于：\n 网络 fd 可以用 epoll 池来管理事件，实现异步 IO； 文件 fd 不能用 epoll 池来管理事件，只能同步 IO；  题外话：文件要实现异步 IO 当前在 Linux 下有两种方式：\n Linux 系统提供的 AIO ：但 Go 没封装实现，因为这个有不少坑； Linux 系统提供的 io_uring ：但内核版本要求高，线上没普及；  一句话，Go 语言级别把网络 IO 做了异步化，但是文件 IO 还是同步的调用。\n异步 IO 咱们就不展开了，以后单独讲。笔者铺开了这么多，只想说明一个事情：Go 和 IO 天然就存在不解之缘，IO 操作是 Go 的最核心之一。\n今天就是为了简单讲讲 Go 的 IO 使用有哪些姿势。\nGo 的 IO 长什么样子？ IO 接口描述（语义） IO 无非就是读写。Go 的语义接口用 interface 来表述，定义在 io 这个 package 中，代码位置：io/io.go 。\nio库比较常用的接口有三个，分别是Reader，Writer和Close。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Read方法会接收一个字节数组p，并将读取到的数据存进该数组，最后返回读取的字节数n。 // 注意n不一定等于读取的数据长度，比如字节数组p的容量太小，n会等于数组的长度 type Reader interface { Read(p []byte) (n int, err error) } // Write 方法同样接收一个字节数组p，并将接收的数据保存至文件或者标准输出等，返回的n表示写入的数据长度。 // 当n不等于len(p)时，返回一个错误。 type Writer interface { Write(p []byte) (n int, err error) } // 关闭操作 type Closer interface { Close() error }   io 是 Go 里面最最核心的 IO 相关的库。为什么怎么说呢？\n因为 IO 的 interface 定义在这个地方。该库不涉及具体的 IO 实现，定义的是最本源的 IO 接口语义。\n什么是 Reader、Writer、ReaderAt、WriterAt ，在这个库里说的明明白白。\n划重点：这个库不涉及具体的 io 实现，描述的是最核心的 IO 接口语义。\nio 库的内容，如果按照接口的定义维度大致可以分为 3 大类：\n基础类型：\n比如：Reader、Writer、Closer、ReaderAt、WriterAt、Seeker、ByteReader、ByteWrieter、RuneReader、StringWriter 等；\n这些接口是最基本的接口，描述了最原始的 Go 的 IO 的样子，这个非常非常非常重要。重要的说三遍。\n如果你写 Go 代码的时候，要实现这些接口，千万要注意在标准库里的注释。\n组合类型：\n第二大类就是组合类型，往往是把最基本的接口组合起来，使用的语法糖则是 Go 的匿名字段的用法，比如：ReaderCloser、WriteCloser、WriteSeeker 等；\n1 2 3 4  type ReadWriter interface { Reader Writer }   进阶类型：\n这个类型比较有意思，一般是基于基础接口之上，加了一些有趣的实现，比如：\nTeeReader、LimitReader、SectionReader、MultiReader、MultiWriter、PipeReader、PipeWriter 等；\n比如：\n TeeReader 这是一个分流器的实现，如果把数据比作一个水流，那么通过 TeeReader 之后，将会分叉出一个新的数据流。 LimitReader 则是给 Reader 加了一个边界期限。 MultiReader 则是把多个数据流合成一股。  这个和 Linux 的 tee 命令异曲同工，细品。\nIO 通用的函数 io 库还有一些基于这些接口的函数，比如：\n Copy ：把一个 Reader 读出来，写到 Writer 里去，直到其中一方出错为止（ 比如最常见的，读端出现 EOF ）； CopyN ：这个和 Copy 一样，读 Reader，写 Writer，直到出错为止。但是 CopyN 比 Copy 多了一个结束条件：数据的拷贝绝对不会超过 N 个； CopyBuffer：这个也是个拷贝实现，和 Copy，CopyN 本质无差异。这个能让用户指定使用多大的 Buffer 内存，这个可以让用户能根据实际情况优化性能，比如大文件拷贝的话，可以考虑使用大一点的 buffer，提高效率（ 1G 的文件拷贝，它也是分了无数次的读写完成的，比如用 1M 的内存 buffer，不停的搬运，搬运 1024 次，才算完）。  io/ioutil 工具库 这个库位于 src/io 目录之下，目录路径为 src/io/ioutil。顾名思义，这是一个工具类型的库，util 嘛，你们都懂的，啥都有，是一些方便的函数实现。他的核心是：怎么方便怎么来。\n ReadFile：给一个路径，把文件一把读到内存（不需要 open，close，read，write 啥的，统统封装起来）方便不？ WriterFile：给一个路径，把内存一把写入文件，方便不？ ReadDir：给一个目录路径，把这个路径下的文件列表一把读上来，方便不？ ReadAll：给一个 Reader 流，一把读完，全部读到内存，方便不？  这就是个工具库，就是应付一些简单的场景的 IO 方便而已。注意了，场景一定要简单，举个栗子：\n使用 ReadAll 这个函数，是把 Reader 流全部读到内存，所以这里内存要装得下才行，如果你这个 Reader 是从一个 2 T 的文件来的，那就 (⊙o⊙)… 尴尬了。\nio 的姿势多种多样？ io 库定义了 io 的该有的样子。现在可以想象具体的问题了，Reader，Writer 可能是哪些？\n 字节数组可以是 Reader / Writer ？ 内存结构体可以是 Reader 吗？ 文件可以是 Reader / Writer 吗？ 字符串可以是 Reader ？ IO 能聚合来提高效率吗？  都可以！Go 帮你做好了这一切。\nIO 行为都是以 io 库为中心发散的。\n围绕着 IO 库，io 的姿势丰富多彩，io 的主体随意定制。\n io库属于底层接口定义库，其作用是是定义一些基本接口和一些基本常量，并对这些接口的作用给出说明，常见的接口有Reader、Writer等。一般用这个库只是为了调用它的一些常量，比如io.EOF。 ioutil库包含在io目录下，它的主要作用是作为一个工具包，里面有一些比较实用的函数，比如 ReadAll(从某个源读取数据)、ReadFile（读取文件内容）、WriteFile（将数据写入文件）、ReadDir（获取目录） os库主要是跟操作系统打交道，所以文件操作基本都会跟os库挂钩，比如创建文件、打开一个文件等。这个库往往会和ioutil库、bufio库等配合使用 bufio库可以理解为在io库上再封装一层，加上了缓存功能。它可能会和ioutil库和bytes.Buffer搞混。  bufio VS ioutil库：两者都提供了对文件的读写功能，唯一的不同就是bufio多了一层缓存的功能，这个优势主要体现读取大文件的时候（ioutil.ReadFile是一次性将内容加载到内存，如果内容过大，很容易爆内存） bufio VS bytes.Buffer：两者都提供一层缓存功能，它们的不同主要在于 bufio 针对的是文件到内存的缓存，而 bytes.Buffer 的针对的是内存到内存的缓存（个人感觉有点像channel，你也可以发现 bytes.Buffer 并没有提供接口将数据写到文件）。   bytes和strings库：这两个库有点迷，首先它们都实现了Reader接口，所以它们的不同主要在于针对的对象不同，bytes针对的是字节，strings针对的是字符串（它们的方法实现原理很相似）。另一个区别就是 bytes还带有Buffer的功能，但是 strings没提供。  关于Reader和Writer接口，可以简单理解为读取源和写入源，即只要实现Reader里面的Read方法，这个东西就可以作为一个读取源，里面可以包含数据并被我们读取；Writer亦是如此。\nio 和字节的故事：bytes 库 Reader/Writer 可以是内存字节数组。\n处理字节数组的库，bytes.Reader 可以把 []byte 转换成 Reader，bytes.Buffer 可以把 []byte 转化成 Reader、Writer ，换句话讲，内存块可以作为读写的数据流了。\n举个栗子：\n1 2 3 4 5  buffer := make([]byte, 1024) readerFromBytes := bytes.NewReader(buffer) n, err := io.Copy(ioutil.Discard, readerFromBytes) // n == 1024, err == nil  fmt.Printf(\"n=%v,err=%v\\n\",n, err)   bytes库有Buffer的功能，而strings库则没有。\n1 2 3  var buf bytes.Buffer fmt.Fprintf(\u0026buf, \"Size: %d MB.\", 85) s := buf.String()) // s == \"Size: 85 MB.\"   io 和字符串的故事：strings 库 字符串可以是 Reader。\nstrings.Reader 能够把字符串转换成 Reader ，这个也挺有意思的，直接能把字符串作为读源。\n1 2 3 4  data := \"hello world\" readerFromBytes := strings.NewReader(data) n, err := io.Copy(ioutil.Discard, readerFromBytes) fmt.Printf(\"n=%v,err=%v\\n\",n, err)   io 和网络的故事：net 库 网络可以作为读写源，抽象成了 Reader、Writer 的形式。这个是以 net.Conn 封装出来的。\n举个栗子：演示一个 C/S 通信。\n服务端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func handleConn(conn net.Conn) { defer conn.Close() buf := make([]byte, 4096) conn.Read(buf) conn.Write([]byte(\"pong: \")) conn.Write(buf) } func main() { server, err := net.Listen(\"tcp\", \":9999\") if err != nil { log.Fatalf(\"err:%v\", err) } for { c, err := server.Accept() if err != nil { log.Fatalf(\"err:%v\", err) } go handleConn(c) } }   关键点：\n net.Listen 创建一个监听套接字，在 Go 里封装成了 net.Listener 类型； Accept 函数返回一个 net.Conn ，代表一条网络连接，net.Conn 既是 Reader，又是 Writer ，拿到之后各自处理即可；  客户端：\n通过 net.Dail 一个 net.Conn 出来。\n1 2 3 4 5 6 7 8  func main() { conn, err := net.Dial(\"tcp\", \":9999\") if err != nil { panic(err) } conn.Write([]byte(\"hello world\\n\")) io.Copy(os.Stdout, conn) }   关键点：\n net.Dail 传入服务端地址和网络协议类型，即可返回一条和服务端通信的网络连接，返回的结构为 net.Conn； net.Conn 即可作为读端（ Reader ），也是写端（ Writer ）；  以上无论是 net.Listener ，还是 net.Conn 都是基于系统调用 socket 之上的一层封装。底下使用的是类似的系统调用：\n1 2 3 4  syscall.Socket syscall.Connect syscall.Listen syscall.GetsockoptInt   Go 针对网络 fd 会做哪些封装呢？\n 创建还是用 socket 的调用创建的 fd，创建出来就会立马设置 nonblock 模式（因为 Go 的网络 fd 天然要使用 IO 多路复用的方式来走 IO ），还有其他配置； 把 socket fd 丢到 epoll 池里 （ 通过 poll.runtime_pollOpen 把 socket 套接字加到 epoll 池里，底层调用的还是 epollctl ），监听事件； 封装好读写事件到来的函数回调；  和文件的故事：os 库 文件 IO，这个就是我们最常见的文件 IO 啦，文件可以作为读端，也可以作为写端。\nFile\nio 的读写端可以是文件。这个太容易理解了，也是我们最常见的读写端，毕竟文件就是存储数据的一种形态。在 Go 里面，我们用 os.OpenFile 这个调用，就可以获取到 Go 帮你封装的文件操作句柄 File ，File 这个结构体对外实现了 Read，Write，ReadAt，WriteAt 等接口，所以自然就可以作为 Reader 和 Writer 来使用。。\n举个栗子：\n1 2 3 4 5 6  // 如下，把 test.data 的数据读出来丢到垃圾桶  fd, err := os.OpenFile(\"test.data\", os.O_RDWR, 0) if err != nil { panic(err) } io.Copy(ioutil.Discard, fd)   这里返回了一个 File 类型，不难想象这个是基于文件 fd 的一层封装。这个里面大概做了什么？\n 调用系统调用 syscall.Open 拿到文件 fd ，顺便设置了下垃圾回收时候的析构函数，其他的好像没了。远比网络 fd 要简单；  Stdin、Stdout、Stderr\nGo 这个把标准输入、标准输出、标准错误输出 抽象成了读写源，对应了 os.Stdin，os.Stdout，os.Stderr 这三个变量。这三个变量其实就是 File 类型的变量，定义在 Go 的源码库 src/os/file.go 里：\n1 2 3 4 5  var ( Stdin = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\") Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\") Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\") )   划重点：这个就是我们常用的 0，1，2 句柄哦。\n标准输入就可以和方便的作为读端（ Reader ），标准输出可以作为写端（ Writer ）啦。\n举个栗子：用一行代码实现一个最简单的 echo 回显的程序。\n1 2 3 4  func main() { // 一行代码实现回显  io.Copy(os.Stdout, os.Stdin) }   把标准输入作为读端，标准输出作为写端。编译出来运行吧，在终端随便输入一个字符串，敲下回车看下效果吧。\n缓存 io 的故事：bufio 库 Reader/Writer 可以是缓冲 IO 的数据流。\n在 c 语言，有人肯定用过 fopen 打开的文件（所谓的标准IO）：\n1  FILE *fopen ( const char* filename, const char * mode );   这个函数 open 出的是一个 FILE 结构体，而非之前常说的整数 fd 句柄。通过这个文件句柄的 IO 就是标准库帮你实现的缓冲 IO。c 语言的缓冲 IO 有三种模式：\n 全缓冲：数据填满 buffer，才会真正的调用底层 IO； 行缓冲：不用等填满 buffer，遇到换行符，就会把 IO 下发下去； 不缓冲：bypass 的模式，每次都是直通底层 IO；  Go 的缓冲 IO 则是由 bufio 这个库提供。先讨论下缓冲 IO 究竟是什么吧。\n缓冲 IO 是在底层 IO 之上实现的一层 buffer ，什么意思？\n假设有个用户，每次写数据都只写 1 个字节，顺序的，写 512 次。之前我们在磁盘 IO 为啥要对齐中提过，非对齐的 IO 性能损失很大。以普通的机械硬盘来说，写 1 个字节，其实要先读一个扇区出来，然后再写下去。所以这里 IO 实际的 IO 次数为 1024 次，实际的 IO 数据量为：读 512512 Byte，写了 512512 Byte。\n能怎么优化呢？\n搞一个内存 512 字节的 buffer ，用户写 1 个字节我就先暂存在 buffer 里面，直到写满 512 字节，buffer 满了，然后一次性把 512 字节的 buffer 数据写到底层。你会发现，这里实际的 IO 只有一次，实际的数据量只有 512 字节。这就是 buffer io ，能极大的减少底层真实的 IO 次数。\n所以，缓冲 IO 的优势是什么？\n一目了然，写的时候能聚合 IO，极大减少 IO 次数。读的时候还能实现预读的效果，同样也减少 IO 次数。\n缺点是啥？\n这个也很容易理解，buffer io 相当于缓存数据了，一份数据多份存储了，这里给数据的一致性管理带来了复杂性，预读还有可能读到脏数据等等混乱情况。\nbufio 这个库我们先理解名字，buffer io 的缩写。那顾名思义，核心是实现了缓存 IO 的库。对一个 Reader/Writer 携带一个内存 buffer 做了一层封装，达到聚合 io 的目的。\nbufio 的使用接口：\n1 2 3 4 5  // 创建一个带 buffer 的 writer，使用默认 buffer size 4096 bufio.NewWriter // 创建一个带 buffer 的 writer 可以手动指定 buffer size bufio.NewWriterSize   bufio，可以理解为在io库的基础上额外封装加了一个缓存层，它提供了很多按行进行读写的函数，从io库的按字节读写变为按行读写对写代码来说还是方便了不少。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func readBigFile(filePath string) error { f, err := os.Open(filePath) defer f.Close() if err != nil { log.Fatal(err) return err } buf := bufio.NewReader(f) count := 0 // 循环中打印前100行内容  for { count += 1 line, err := buf.ReadString('\\n') line = strings.TrimSpace(line) if err != nil { return err } fmt.Println(\"line\", line) if count  100 { break } } return nil }    ReadLine和ReadString方法：buf.ReadLine()，buf.ReadString(\"\\n\")都是按行读，只不过ReadLine读出来的是[]byte，后者直接读出了string，最终他们底层调用的都是ReadSlice方法。 bufio VS ioutil 库： bufio 和 ioutil 库都提供了读写文件的能力。它们之间唯一的区别是 bufio 有一个额外的缓存层。这个优势主要体现在读取大文件的时候。  总结   CPU 和 IO 设备是不同的设备，能并行运行。合理调度程序，充分利用硬件，就能跑出很好的性能；\n  Go 的 IO 最最核心的是 io 库，如果要实现其中的 interface ，千万要仔细阅读语义；\n  io 库除了定义 interface ，还实现了通用的函数，比如 Copy 之类的；\n  io/ioutil 里面实现的挺杂的，但真香；\n  内存字节数组可以作为 Reader ，Writer ，实现在 bytes 库中，bytes.NewReader，bytes.NewBuffer （换句话说，内存结构体和可以作为 Reader，因为结构体可以强转成字节数组）；\n  字符串可以作为 Reader，实现在 strings 库中，strings.NewReader ；\n  网络句柄可以作为 Reader，Writer，实现在 net 库中，net.Conn；\n  文件句柄可以作为 Reader，Writer，实现在 os 库中，os.File ；\n  参考 浅析 Go IO 的知识框架\nGo指南10-谈谈对Golang IO读写的困惑\nGolang的IO库那么多，我该怎么选?\n",
  "wordCount" : "6410",
  "inLanguage": "zh-cn",
  "datePublished": "2021-08-06T17:45:39Z",
  "dateModified": "2021-08-06T17:45:39Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go的IO库介绍
    </h1>
    <div class="post-meta">August 6, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="go和io">Go和IO<a hidden class="anchor" aria-hidden="true" href="#go和io">#</a></h2>
<p>Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可比的。</p>
<p>前置小知识点：并行和并发的区别？</p>
<p>并行看的是时刻，并发看的是时间段。</p>
<p>2021/1/1 12:00:00 这个时刻有两个请求在同时被执行，这说的是并行；
2021/1/1 12:00:00 - 2021/1/1 12:00:01 这 1 秒的时间，完成了 1000 个请求，qps 为 1000，这种说的是并发；
好，先回归主题，Go 除了 Goroutine 足够轻量之外，支持如此高并发的这其中的秘诀在哪里？</p>
<p>执行体调度得当。CPU 不停的在不同的执行体（ Goroutine ）之间反复横跳！CPU 一直在装填和运行不同执行体的指令，G1（Goroutine 1 的缩写） 不行就搞 G2 ，一刻不能停，这样才能使得大量的执行体（ Goroutine ）齐头并进，系统才能完成如此高并发的吞吐（注意关键字：并发哦）。</p>
<p>思考一个问题，程序可分为 CPU 密集型的程序和 IO 密集型的程序两种，Go 适合哪种？</p>
<p>IO 密集型。</p>
<p>这里的理由其实很有意思，先说为什么不合适 CPU 密集型呢？</p>
<p>理由其实很简单，CPU 密集型就意味着每个执行体都是急需 CPU 的，G1 吃 CPU 都不够，还切到 G2 去干嘛？所以 CPU 密集型的程序最好的情况就是不调度！ 绑核都来不及呢。想要提高这种程序的性能，就是加钱，买核，买 CPU，买 GPU，把 CPU 核并行起来。</p>
<p>为什么 IO 密集型就好了？</p>
<p>划重点：IO 设备和 CPU 可是不同的独立设备呀。 这两者之间的处理可是并行运行的。</p>
<p>Go 程序的协程调度则可以很好的利用这个关系，让 CPU 执行程序指令，只负责发送 IO ，一旦 IO 被 IO 设备接收，不等待完成，就可以处理其他人的指令，IO 的完成以异步事件的形式触发。这样 IO 设备的处理过程就和 CPU 的执行并行了起来。</p>
<p>任何 IO 都适配 Go 吗？</p>
<p>不是的。IO 也分为网络 IO 和文件 IO 。其实适合 Go 的程序类型准确的来讲是：网络 IO 密集型的程序。</p>
<p>其中差异就在于：</p>
<ol>
<li>网络 fd 可以用 epoll 池来管理事件，实现异步 IO；</li>
<li>文件 fd 不能用 epoll 池来管理事件，只能同步 IO；</li>
</ol>
<p>题外话：文件要实现异步 IO 当前在 Linux 下有两种方式：</p>
<ol>
<li>Linux 系统提供的 AIO ：但 Go 没封装实现，因为这个有不少坑；</li>
<li>Linux 系统提供的 io_uring ：但内核版本要求高，线上没普及；</li>
</ol>
<p>一句话，Go 语言级别把网络 IO 做了异步化，但是文件 IO 还是同步的调用。</p>
<p>异步 IO 咱们就不展开了，以后单独讲。笔者铺开了这么多，只想说明一个事情：Go 和 IO 天然就存在不解之缘，IO 操作是 Go 的最核心之一。</p>
<p>今天就是为了简单讲讲 Go 的 IO 使用有哪些姿势。</p>
<h2 id="go-的-io-长什么样子">Go 的 IO 长什么样子？<a hidden class="anchor" aria-hidden="true" href="#go-的-io-长什么样子">#</a></h2>
<h3 id="io-接口描述语义">IO 接口描述（语义）<a hidden class="anchor" aria-hidden="true" href="#io-接口描述语义">#</a></h3>
<p>IO 无非就是读写。Go 的语义接口用 interface 来表述，定义在 io 这个 package 中，代码位置：io/io.go 。</p>
<p>io库比较常用的接口有三个，分别是Reader，Writer和Close。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Read方法会接收一个字节数组p，并将读取到的数据存进该数组，最后返回读取的字节数n。
</span><span class="c1">// 注意n不一定等于读取的数据长度，比如字节数组p的容量太小，n会等于数组的长度
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Write 方法同样接收一个字节数组p，并将接收的数据保存至文件或者标准输出等，返回的n表示写入的数据长度。
</span><span class="c1">// 当n不等于len(p)时，返回一个错误。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 关闭操作
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>io 是 Go 里面最最核心的 IO 相关的库。为什么怎么说呢？</p>
<p>因为 IO 的 interface 定义在这个地方。该库不涉及具体的 IO 实现，定义的是最本源的 IO 接口语义。</p>
<p>什么是 Reader、Writer、ReaderAt、WriterAt ，在这个库里说的明明白白。</p>
<p>划重点：这个库不涉及具体的 io 实现，描述的是最核心的 IO 接口语义。</p>
<p>io 库的内容，如果按照接口的定义维度大致可以分为 3 大类：</p>
<p>基础类型：</p>
<p>比如：Reader、Writer、Closer、ReaderAt、WriterAt、Seeker、ByteReader、ByteWrieter、RuneReader、StringWriter  等；</p>
<p>这些接口是最基本的接口，描述了最原始的 Go 的 IO 的样子，这个非常非常非常重要。重要的说三遍。</p>
<p>如果你写 Go 代码的时候，要实现这些接口，千万要注意在标准库里的注释。</p>
<p>组合类型：</p>
<p>第二大类就是组合类型，往往是把最基本的接口组合起来，使用的语法糖则是 Go 的匿名字段的用法，比如：ReaderCloser、WriteCloser、WriteSeeker 等；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
 <span class="nx">Reader</span>
 <span class="nx">Writer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>进阶类型：</p>
<p>这个类型比较有意思，一般是基于基础接口之上，加了一些有趣的实现，比如：</p>
<p>TeeReader、LimitReader、SectionReader、MultiReader、MultiWriter、PipeReader、PipeWriter 等；</p>
<p>比如：</p>
<ul>
<li>TeeReader 这是一个分流器的实现，如果把数据比作一个水流，那么通过 TeeReader 之后，将会分叉出一个新的数据流。</li>
<li>LimitReader 则是给 Reader 加了一个边界期限。</li>
<li>MultiReader 则是把多个数据流合成一股。</li>
</ul>
<p>这个和 Linux 的 tee 命令异曲同工，细品。</p>
<h3 id="io-通用的函数">IO 通用的函数<a hidden class="anchor" aria-hidden="true" href="#io-通用的函数">#</a></h3>
<p>io 库还有一些基于这些接口的函数，比如：</p>
<ul>
<li>Copy ：把一个 Reader 读出来，写到 Writer  里去，直到其中一方出错为止（ 比如最常见的，读端出现 EOF ）；</li>
<li>CopyN ：这个和 Copy 一样，读 Reader，写 Writer，直到出错为止。但是 CopyN 比 Copy 多了一个结束条件：数据的拷贝绝对不会超过 N 个；</li>
<li>CopyBuffer：这个也是个拷贝实现，和 Copy，CopyN 本质无差异。这个能让用户指定使用多大的 Buffer 内存，这个可以让用户能根据实际情况优化性能，比如大文件拷贝的话，可以考虑使用大一点的 buffer，提高效率（ 1G 的文件拷贝，它也是分了无数次的读写完成的，比如用 1M 的内存 buffer，不停的搬运，搬运 1024 次，才算完）。</li>
</ul>
<h3 id="ioioutil-工具库">io/ioutil 工具库<a hidden class="anchor" aria-hidden="true" href="#ioioutil-工具库">#</a></h3>
<p>这个库位于 src/io 目录之下，目录路径为 src/io/ioutil。顾名思义，这是一个工具类型的库，util 嘛，你们都懂的，啥都有，是一些方便的函数实现。他的核心是：怎么方便怎么来。</p>
<ul>
<li>ReadFile：给一个路径，把文件一把读到内存（不需要 open，close，read，write 啥的，统统封装起来）方便不？</li>
<li>WriterFile：给一个路径，把内存一把写入文件，方便不？</li>
<li>ReadDir：给一个目录路径，把这个路径下的文件列表一把读上来，方便不？</li>
<li>ReadAll：给一个 Reader 流，一把读完，全部读到内存，方便不？</li>
</ul>
<p>这就是个工具库，就是应付一些简单的场景的 IO 方便而已。注意了，场景一定要简单，举个栗子：</p>
<p>使用 ReadAll 这个函数，是把 Reader 流全部读到内存，所以这里内存要装得下才行，如果你这个 Reader 是从一个 2 T 的文件来的，那就 (⊙o⊙)… 尴尬了。</p>
<h2 id="io-的姿势多种多样">io 的姿势多种多样？<a hidden class="anchor" aria-hidden="true" href="#io-的姿势多种多样">#</a></h2>
<p>io 库定义了 io 的该有的样子。现在可以想象具体的问题了，Reader，Writer 可能是哪些？</p>
<ul>
<li>字节数组可以是 Reader / Writer ？</li>
<li>内存结构体可以是 Reader 吗？</li>
<li>文件可以是 Reader / Writer 吗？</li>
<li>字符串可以是 Reader ？</li>
<li>IO 能聚合来提高效率吗？</li>
</ul>
<p>都可以！Go 帮你做好了这一切。</p>
<p>IO 行为都是以 io 库为中心发散的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210806182100.png" alt=""  />
</p>
<p>围绕着 IO 库，io 的姿势丰富多彩，io 的主体随意定制。</p>
<ol>
<li>io库属于底层接口定义库，其作用是是定义一些基本接口和一些基本常量，并对这些接口的作用给出说明，常见的接口有Reader、Writer等。一般用这个库只是为了调用它的一些常量，比如io.EOF。</li>
<li>ioutil库包含在io目录下，它的主要作用是作为一个工具包，里面有一些比较实用的函数，比如 ReadAll(从某个源读取数据)、ReadFile（读取文件内容）、WriteFile（将数据写入文件）、ReadDir（获取目录）</li>
<li>os库主要是跟操作系统打交道，所以文件操作基本都会跟os库挂钩，比如创建文件、打开一个文件等。这个库往往会和ioutil库、bufio库等配合使用</li>
<li>bufio库可以理解为在io库上再封装一层，加上了缓存功能。它可能会和ioutil库和bytes.Buffer搞混。
<ol>
<li>bufio VS ioutil库：两者都提供了对文件的读写功能，唯一的不同就是bufio多了一层缓存的功能，这个优势主要体现读取大文件的时候（ioutil.ReadFile是一次性将内容加载到内存，如果内容过大，很容易爆内存）</li>
<li>bufio VS bytes.Buffer：两者都提供一层缓存功能，它们的不同主要在于 bufio 针对的是文件到内存的缓存，而 bytes.Buffer 的针对的是内存到内存的缓存（个人感觉有点像channel，你也可以发现 bytes.Buffer 并没有提供接口将数据写到文件）。</li>
</ol>
</li>
<li>bytes和strings库：这两个库有点迷，首先它们都实现了Reader接口，所以它们的不同主要在于针对的对象不同，bytes针对的是字节，strings针对的是字符串（它们的方法实现原理很相似）。另一个区别就是 bytes还带有Buffer的功能，但是 strings没提供。</li>
</ol>
<p>关于Reader和Writer接口，可以简单理解为读取源和写入源，即只要实现Reader里面的Read方法，这个东西就可以作为一个读取源，里面可以包含数据并被我们读取；Writer亦是如此。</p>
<h3 id="io-和字节的故事bytes-库">io 和字节的故事：bytes 库<a hidden class="anchor" aria-hidden="true" href="#io-和字节的故事bytes-库">#</a></h3>
<p>Reader/Writer 可以是内存字节数组。</p>
<p>处理字节数组的库，bytes.Reader 可以把 <code>[]byte</code> 转换成 Reader，bytes.Buffer 可以把 <code>[]byte</code> 转化成 Reader、Writer ，换句话讲，内存块可以作为读写的数据流了。</p>
<p>举个栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
    <span class="nx">readerFromBytes</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">readerFromBytes</span><span class="p">)</span>
    <span class="c1">// n == 1024, err == nil
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;n=%v,err=%v\n&#34;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>bytes库有Buffer的功能，而strings库则没有。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;Size: %d MB.&#34;</span><span class="p">,</span> <span class="mi">85</span><span class="p">)</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// s == &#34;Size: 85 MB.&#34;
</span></code></pre></td></tr></table>
</div>
</div><h3 id="io-和字符串的故事strings-库">io 和字符串的故事：strings 库<a hidden class="anchor" aria-hidden="true" href="#io-和字符串的故事strings-库">#</a></h3>
<p>字符串可以是 Reader。</p>
<p>strings.Reader 能够把字符串转换成 Reader ，这个也挺有意思的，直接能把字符串作为读源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="nx">data</span> <span class="o">:=</span> <span class="s">&#34;hello world&#34;</span>
    <span class="nx">readerFromBytes</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">readerFromBytes</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;n=%v,err=%v\n&#34;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="io-和网络的故事net-库">io 和网络的故事：net 库<a hidden class="anchor" aria-hidden="true" href="#io-和网络的故事net-库">#</a></h3>
<p>网络可以作为读写源，抽象成了 Reader、Writer 的形式。这个是以 net.Conn  封装出来的。</p>
<p>举个栗子：演示一个 C/S 通信。</p>
<p>服务端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>
 <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
 <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;pong: &#34;</span><span class="p">))</span>
 <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">server</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:9999&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">for</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>关键点：</p>
<ol>
<li>net.Listen 创建一个监听套接字，在 Go 里封装成了 net.Listener 类型；</li>
<li>Accept 函数返回一个 net.Conn ，代表一条网络连接，net.Conn  既是 Reader，又是 Writer ，拿到之后各自处理即可；</li>
</ol>
<p>客户端：</p>
<p>通过 net.Dail  一个 net.Conn 出来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:9999&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world\n&#34;</span><span class="p">))</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>关键点：</p>
<ol>
<li>net.Dail 传入服务端地址和网络协议类型，即可返回一条和服务端通信的网络连接，返回的结构为 net.Conn；</li>
<li>net.Conn 即可作为读端（ Reader ），也是写端（ Writer ）；</li>
</ol>
<p>以上无论是 net.Listener ，还是 net.Conn  都是基于系统调用 socket 之上的一层封装。底下使用的是类似的系统调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">syscall.Socket</span>
<span class="n">syscall.Connect</span>
<span class="n">syscall.Listen</span>
<span class="n">syscall.GetsockoptInt</span>
</code></pre></td></tr></table>
</div>
</div><p>Go 针对网络 fd 会做哪些封装呢？</p>
<ol>
<li>创建还是用 socket 的调用创建的 fd，创建出来就会立马设置 nonblock 模式（因为 Go 的网络 fd 天然要使用 IO 多路复用的方式来走 IO ），还有其他配置；</li>
<li>把 socket fd 丢到 epoll 池里 （ 通过 poll.runtime_pollOpen  把 socket 套接字加到 epoll 池里，底层调用的还是 epollctl  ），监听事件；</li>
<li>封装好读写事件到来的函数回调；</li>
</ol>
<h3 id="和文件的故事os-库">和文件的故事：os 库<a hidden class="anchor" aria-hidden="true" href="#和文件的故事os-库">#</a></h3>
<p>文件 IO，这个就是我们最常见的文件 IO 啦，文件可以作为读端，也可以作为写端。</p>
<p>File</p>
<p>io 的读写端可以是文件。这个太容易理解了，也是我们最常见的读写端，毕竟文件就是存储数据的一种形态。在 Go 里面，我们用 os.OpenFile  这个调用，就可以获取到 Go 帮你封装的文件操作句柄 File ，File 这个结构体对外实现了 Read，Write，ReadAt，WriteAt  等接口，所以自然就可以作为 Reader 和 Writer 来使用。。</p>
<p>举个栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">    <span class="c1">// 如下，把 test.data 的数据读出来丢到垃圾桶
</span><span class="c1"></span>    <span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;test.data&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_RDWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">fd</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里返回了一个 File 类型，不难想象这个是基于文件 fd 的一层封装。这个里面大概做了什么？</p>
<ol>
<li>调用系统调用 syscall.Open 拿到文件 fd ，顺便设置了下垃圾回收时候的析构函数，其他的好像没了。远比网络 fd 要简单；</li>
</ol>
<p>Stdin、Stdout、Stderr</p>
<p>Go 这个把标准输入、标准输出、标准错误输出 抽象成了读写源，对应了 os.Stdin，os.Stdout，os.Stderr  这三个变量。这三个变量其实就是 File 类型的变量，定义在 Go 的源码库 src/os/file.go 里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
 <span class="nx">Stdin</span>  <span class="p">=</span> <span class="nf">NewFile</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">),</span> <span class="s">&#34;/dev/stdin&#34;</span><span class="p">)</span>
 <span class="nx">Stdout</span> <span class="p">=</span> <span class="nf">NewFile</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">),</span> <span class="s">&#34;/dev/stdout&#34;</span><span class="p">)</span>
 <span class="nx">Stderr</span> <span class="p">=</span> <span class="nf">NewFile</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">),</span> <span class="s">&#34;/dev/stderr&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>划重点：这个就是我们常用的 0，1，2 句柄哦。</p>
<p>标准输入就可以和方便的作为读端（ Reader ），标准输出可以作为写端（ Writer ）啦。</p>
<p>举个栗子：用一行代码实现一个最简单的 echo 回显的程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 一行代码实现回显
</span><span class="c1"></span>    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>把标准输入作为读端，标准输出作为写端。编译出来运行吧，在终端随便输入一个字符串，敲下回车看下效果吧。</p>
<h3 id="缓存-io-的故事bufio-库">缓存 io 的故事：bufio 库<a hidden class="anchor" aria-hidden="true" href="#缓存-io-的故事bufio-库">#</a></h3>
<p>Reader/Writer 可以是缓冲 IO 的数据流。</p>
<p>在 c 语言，有人肯定用过 fopen  打开的文件（所谓的标准IO）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">FILE</span> <span class="o">*</span><span class="nf">fopen</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">mode</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数 open 出的是一个 FILE 结构体，而非之前常说的整数 fd 句柄。通过这个文件句柄的 IO 就是标准库帮你实现的缓冲 IO。c 语言的缓冲 IO 有三种模式：</p>
<ul>
<li>全缓冲：数据填满 buffer，才会真正的调用底层 IO；</li>
<li>行缓冲：不用等填满 buffer，遇到换行符，就会把 IO 下发下去；</li>
<li>不缓冲：bypass 的模式，每次都是直通底层 IO；</li>
</ul>
<p>Go 的缓冲 IO 则是由 bufio 这个库提供。先讨论下缓冲 IO 究竟是什么吧。</p>
<p>缓冲 IO 是在底层 IO 之上实现的一层 buffer ，什么意思？</p>
<p>假设有个用户，每次写数据都只写 1 个字节，顺序的，写 512 次。之前我们在磁盘 IO 为啥要对齐中提过，非对齐的 IO 性能损失很大。以普通的机械硬盘来说，写 1 个字节，其实要先读一个扇区出来，然后再写下去。所以这里 IO 实际的 IO 次数为 1024 次，实际的 IO 数据量为：读 512<em>512 Byte，写了 512</em>512  Byte。</p>
<p>能怎么优化呢？</p>
<p>搞一个内存 512 字节的 buffer ，用户写 1 个字节我就先暂存在 buffer 里面，直到写满 512 字节，buffer 满了，然后一次性把 512 字节的 buffer 数据写到底层。你会发现，这里实际的 IO 只有一次，实际的数据量只有 512 字节。这就是 buffer io ，能极大的减少底层真实的 IO 次数。</p>
<p>所以，缓冲 IO 的优势是什么？</p>
<p>一目了然，写的时候能聚合 IO，极大减少 IO 次数。读的时候还能实现预读的效果，同样也减少 IO 次数。</p>
<p>缺点是啥？</p>
<p>这个也很容易理解，buffer io 相当于缓存数据了，一份数据多份存储了，这里给数据的一致性管理带来了复杂性，预读还有可能读到脏数据等等混乱情况。</p>
<p>bufio 这个库我们先理解名字，buffer io 的缩写。那顾名思义，核心是实现了缓存 IO 的库。对一个 Reader/Writer 携带一个内存 buffer 做了一层封装，达到聚合 io 的目的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210809133803.png" alt=""  />
</p>
<p>bufio 的使用接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个带 buffer 的 writer，使用默认 buffer size 4096
</span><span class="c1"></span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewWriter</span>

<span class="c1">// 创建一个带 buffer 的 writer 可以手动指定 buffer size
</span><span class="c1"></span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewWriterSize</span>
</code></pre></td></tr></table>
</div>
</div><p>bufio，可以理解为在io库的基础上额外封装加了一个缓存层，它提供了很多按行进行读写的函数，从io库的按字节读写变为按行读写对写代码来说还是方便了不少。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">readBigFile</span><span class="p">(</span><span class="nx">filePath</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
  <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="c1">// 循环中打印前100行内容
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nx">line</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="nx">line</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;line&#34;</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><ul>
<li>ReadLine和ReadString方法：buf.ReadLine()，buf.ReadString(&quot;\n&quot;)都是按行读，只不过ReadLine读出来的是[]byte，后者直接读出了string，最终他们底层调用的都是ReadSlice方法。</li>
<li>bufio VS ioutil 库： bufio 和 ioutil 库都提供了读写文件的能力。它们之间唯一的区别是 bufio 有一个额外的缓存层。这个优势主要体现在读取大文件的时候。</li>
</ul>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ul>
<li>
<p>CPU 和 IO 设备是不同的设备，能并行运行。合理调度程序，充分利用硬件，就能跑出很好的性能；</p>
</li>
<li>
<p>Go 的 IO 最最核心的是 io 库，如果要实现其中的 interface  ，千万要仔细阅读语义；</p>
</li>
<li>
<p>io 库除了定义 interface ，还实现了通用的函数，比如 Copy 之类的；</p>
</li>
<li>
<p>io/ioutil 里面实现的挺杂的，但真香；</p>
</li>
<li>
<p>内存字节数组可以作为 Reader ，Writer ，实现在 bytes 库中，bytes.NewReader，bytes.NewBuffer （换句话说，内存结构体和可以作为 Reader，因为结构体可以强转成字节数组）；</p>
</li>
<li>
<p>字符串可以作为 Reader，实现在 strings 库中，strings.NewReader  ；</p>
</li>
<li>
<p>网络句柄可以作为 Reader，Writer，实现在 net 库中，net.Conn；</p>
</li>
<li>
<p>文件句柄可以作为 Reader，Writer，实现在 os 库中，os.File ；</p>
</li>
</ul>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://mp.weixin.qq.com/s/JniBMBw__WLbYtigj3eiXQ">浅析 Go IO 的知识框架</a></p>
<p><a href="https://juejin.cn/post/6864886461746855949">Go指南10-谈谈对Golang IO读写的困惑</a></p>
<p><a href="https://juejin.cn/post/6976841033795502093">Golang的IO库那么多，我该怎么选?</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
