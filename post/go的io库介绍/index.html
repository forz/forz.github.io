<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的IO库介绍 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.97.3 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的IO库介绍" />
<meta property="og:description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84io%E5%BA%93%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-06T17:45:39+00:00" />
<meta property="article:modified_time" content="2021-08-06T17:45:39+00:00" />

<meta itemprop="name" content="Go的IO库介绍">
<meta itemprop="description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可"><meta itemprop="datePublished" content="2021-08-06T17:45:39+00:00" />
<meta itemprop="dateModified" content="2021-08-06T17:45:39+00:00" />
<meta itemprop="wordCount" content="6409">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的IO库介绍"/>
<meta name="twitter:description" content="Go和IO Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的IO库介绍</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-06 </span>
        <div class="post-category">
            <a href="/categories/go%E5%AE%9E%E8%B7%B5/"> Go实践 </a>
            </div>
          <span class="more-meta"> 约 6409 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#go和io">Go和IO</a></li>
    <li><a href="#go-的-io-长什么样子">Go 的 IO 长什么样子？</a>
      <ul>
        <li><a href="#io-接口描述语义">IO 接口描述（语义）</a></li>
        <li><a href="#io-通用的函数">IO 通用的函数</a></li>
        <li><a href="#ioioutil-工具库">io/ioutil 工具库</a></li>
      </ul>
    </li>
    <li><a href="#io-的姿势多种多样">io 的姿势多种多样？</a>
      <ul>
        <li><a href="#io-和字节的故事bytes-库">io 和字节的故事：bytes 库</a></li>
        <li><a href="#io-和字符串的故事strings-库">io 和字符串的故事：strings 库</a></li>
        <li><a href="#io-和网络的故事net-库">io 和网络的故事：net 库</a></li>
        <li><a href="#和文件的故事os-库">和文件的故事：os 库</a></li>
        <li><a href="#缓存-io-的故事bufio-库">缓存 io 的故事：bufio 库</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="go和io">Go和IO</h2>
<p>Go 是一种高性能的编译性语言，天然支持高并发，语言级别封装协程，号称可以支持成千上万，十万，甚至百万的协程并发。这个量级远不是线程可比的。</p>
<p>前置小知识点：并行和并发的区别？</p>
<p>并行看的是时刻，并发看的是时间段。</p>
<p>2021/1/1 12:00:00 这个时刻有两个请求在同时被执行，这说的是并行；
2021/1/1 12:00:00 - 2021/1/1 12:00:01 这 1 秒的时间，完成了 1000 个请求，qps 为 1000，这种说的是并发；
好，先回归主题，Go 除了 Goroutine 足够轻量之外，支持如此高并发的这其中的秘诀在哪里？</p>
<p>执行体调度得当。CPU 不停的在不同的执行体（ Goroutine ）之间反复横跳！CPU 一直在装填和运行不同执行体的指令，G1（Goroutine 1 的缩写） 不行就搞 G2 ，一刻不能停，这样才能使得大量的执行体（ Goroutine ）齐头并进，系统才能完成如此高并发的吞吐（注意关键字：并发哦）。</p>
<p>思考一个问题，程序可分为 CPU 密集型的程序和 IO 密集型的程序两种，Go 适合哪种？</p>
<p>IO 密集型。</p>
<p>这里的理由其实很有意思，先说为什么不合适 CPU 密集型呢？</p>
<p>理由其实很简单，CPU 密集型就意味着每个执行体都是急需 CPU 的，G1 吃 CPU 都不够，还切到 G2 去干嘛？所以 CPU 密集型的程序最好的情况就是不调度！ 绑核都来不及呢。想要提高这种程序的性能，就是加钱，买核，买 CPU，买 GPU，把 CPU 核并行起来。</p>
<p>为什么 IO 密集型就好了？</p>
<p>划重点：IO 设备和 CPU 可是不同的独立设备呀。 这两者之间的处理可是并行运行的。</p>
<p>Go 程序的协程调度则可以很好的利用这个关系，让 CPU 执行程序指令，只负责发送 IO ，一旦 IO 被 IO 设备接收，不等待完成，就可以处理其他人的指令，IO 的完成以异步事件的形式触发。这样 IO 设备的处理过程就和 CPU 的执行并行了起来。</p>
<p>任何 IO 都适配 Go 吗？</p>
<p>不是的。IO 也分为网络 IO 和文件 IO 。其实适合 Go 的程序类型准确的来讲是：网络 IO 密集型的程序。</p>
<p>其中差异就在于：</p>
<ol>
<li>网络 fd 可以用 epoll 池来管理事件，实现异步 IO；</li>
<li>文件 fd 不能用 epoll 池来管理事件，只能同步 IO；</li>
</ol>
<p>题外话：文件要实现异步 IO 当前在 Linux 下有两种方式：</p>
<ol>
<li>Linux 系统提供的 AIO ：但 Go 没封装实现，因为这个有不少坑；</li>
<li>Linux 系统提供的 io_uring ：但内核版本要求高，线上没普及；</li>
</ol>
<p>一句话，Go 语言级别把网络 IO 做了异步化，但是文件 IO 还是同步的调用。</p>
<p>异步 IO 咱们就不展开了，以后单独讲。笔者铺开了这么多，只想说明一个事情：Go 和 IO 天然就存在不解之缘，IO 操作是 Go 的最核心之一。</p>
<p>今天就是为了简单讲讲 Go 的 IO 使用有哪些姿势。</p>
<h2 id="go-的-io-长什么样子">Go 的 IO 长什么样子？</h2>
<h3 id="io-接口描述语义">IO 接口描述（语义）</h3>
<p>IO 无非就是读写。Go 的语义接口用 interface 来表述，定义在 io 这个 package 中，代码位置：io/io.go 。</p>
<p>io库比较常用的接口有三个，分别是Reader，Writer和Close。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Read方法会接收一个字节数组p，并将读取到的数据存进该数组，最后返回读取的字节数n。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意n不一定等于读取的数据长度，比如字节数组p的容量太小，n会等于数组的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Write 方法同样接收一个字节数组p，并将接收的数据保存至文件或者标准输出等，返回的n表示写入的数据长度。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 当n不等于len(p)时，返回一个错误。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 关闭操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>io 是 Go 里面最最核心的 IO 相关的库。为什么怎么说呢？</p>
<p>因为 IO 的 interface 定义在这个地方。该库不涉及具体的 IO 实现，定义的是最本源的 IO 接口语义。</p>
<p>什么是 Reader、Writer、ReaderAt、WriterAt ，在这个库里说的明明白白。</p>
<p>划重点：这个库不涉及具体的 io 实现，描述的是最核心的 IO 接口语义。</p>
<p>io 库的内容，如果按照接口的定义维度大致可以分为 3 大类：</p>
<p>基础类型：</p>
<p>比如：Reader、Writer、Closer、ReaderAt、WriterAt、Seeker、ByteReader、ByteWrieter、RuneReader、StringWriter  等；</p>
<p>这些接口是最基本的接口，描述了最原始的 Go 的 IO 的样子，这个非常非常非常重要。重要的说三遍。</p>
<p>如果你写 Go 代码的时候，要实现这些接口，千万要注意在标准库里的注释。</p>
<p>组合类型：</p>
<p>第二大类就是组合类型，往往是把最基本的接口组合起来，使用的语法糖则是 Go 的匿名字段的用法，比如：ReaderCloser、WriteCloser、WriteSeeker 等；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">Reader</span>
</span></span><span class="line"><span class="cl"> <span class="nx">Writer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>进阶类型：</p>
<p>这个类型比较有意思，一般是基于基础接口之上，加了一些有趣的实现，比如：</p>
<p>TeeReader、LimitReader、SectionReader、MultiReader、MultiWriter、PipeReader、PipeWriter 等；</p>
<p>比如：</p>
<ul>
<li>TeeReader 这是一个分流器的实现，如果把数据比作一个水流，那么通过 TeeReader 之后，将会分叉出一个新的数据流。</li>
<li>LimitReader 则是给 Reader 加了一个边界期限。</li>
<li>MultiReader 则是把多个数据流合成一股。</li>
</ul>
<p>这个和 Linux 的 tee 命令异曲同工，细品。</p>
<h3 id="io-通用的函数">IO 通用的函数</h3>
<p>io 库还有一些基于这些接口的函数，比如：</p>
<ul>
<li>Copy ：把一个 Reader 读出来，写到 Writer  里去，直到其中一方出错为止（ 比如最常见的，读端出现 EOF ）；</li>
<li>CopyN ：这个和 Copy 一样，读 Reader，写 Writer，直到出错为止。但是 CopyN 比 Copy 多了一个结束条件：数据的拷贝绝对不会超过 N 个；</li>
<li>CopyBuffer：这个也是个拷贝实现，和 Copy，CopyN 本质无差异。这个能让用户指定使用多大的 Buffer 内存，这个可以让用户能根据实际情况优化性能，比如大文件拷贝的话，可以考虑使用大一点的 buffer，提高效率（ 1G 的文件拷贝，它也是分了无数次的读写完成的，比如用 1M 的内存 buffer，不停的搬运，搬运 1024 次，才算完）。</li>
</ul>
<h3 id="ioioutil-工具库">io/ioutil 工具库</h3>
<p>这个库位于 src/io 目录之下，目录路径为 src/io/ioutil。顾名思义，这是一个工具类型的库，util 嘛，你们都懂的，啥都有，是一些方便的函数实现。他的核心是：怎么方便怎么来。</p>
<ul>
<li>ReadFile：给一个路径，把文件一把读到内存（不需要 open，close，read，write 啥的，统统封装起来）方便不？</li>
<li>WriterFile：给一个路径，把内存一把写入文件，方便不？</li>
<li>ReadDir：给一个目录路径，把这个路径下的文件列表一把读上来，方便不？</li>
<li>ReadAll：给一个 Reader 流，一把读完，全部读到内存，方便不？</li>
</ul>
<p>这就是个工具库，就是应付一些简单的场景的 IO 方便而已。注意了，场景一定要简单，举个栗子：</p>
<p>使用 ReadAll 这个函数，是把 Reader 流全部读到内存，所以这里内存要装得下才行，如果你这个 Reader 是从一个 2 T 的文件来的，那就 (⊙o⊙)… 尴尬了。</p>
<h2 id="io-的姿势多种多样">io 的姿势多种多样？</h2>
<p>io 库定义了 io 的该有的样子。现在可以想象具体的问题了，Reader，Writer 可能是哪些？</p>
<ul>
<li>字节数组可以是 Reader / Writer ？</li>
<li>内存结构体可以是 Reader 吗？</li>
<li>文件可以是 Reader / Writer 吗？</li>
<li>字符串可以是 Reader ？</li>
<li>IO 能聚合来提高效率吗？</li>
</ul>
<p>都可以！Go 帮你做好了这一切。</p>
<p>IO 行为都是以 io 库为中心发散的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210806182100.png" alt=""></p>
<p>围绕着 IO 库，io 的姿势丰富多彩，io 的主体随意定制。</p>
<ol>
<li>io库属于底层接口定义库，其作用是是定义一些基本接口和一些基本常量，并对这些接口的作用给出说明，常见的接口有Reader、Writer等。一般用这个库只是为了调用它的一些常量，比如io.EOF。</li>
<li>ioutil库包含在io目录下，它的主要作用是作为一个工具包，里面有一些比较实用的函数，比如 ReadAll(从某个源读取数据)、ReadFile（读取文件内容）、WriteFile（将数据写入文件）、ReadDir（获取目录）</li>
<li>os库主要是跟操作系统打交道，所以文件操作基本都会跟os库挂钩，比如创建文件、打开一个文件等。这个库往往会和ioutil库、bufio库等配合使用</li>
<li>bufio库可以理解为在io库上再封装一层，加上了缓存功能。它可能会和ioutil库和bytes.Buffer搞混。
<ol>
<li>bufio VS ioutil库：两者都提供了对文件的读写功能，唯一的不同就是bufio多了一层缓存的功能，这个优势主要体现读取大文件的时候（ioutil.ReadFile是一次性将内容加载到内存，如果内容过大，很容易爆内存）</li>
<li>bufio VS bytes.Buffer：两者都提供一层缓存功能，它们的不同主要在于 bufio 针对的是文件到内存的缓存，而 bytes.Buffer 的针对的是内存到内存的缓存（个人感觉有点像channel，你也可以发现 bytes.Buffer 并没有提供接口将数据写到文件）。</li>
</ol>
</li>
<li>bytes和strings库：这两个库有点迷，首先它们都实现了Reader接口，所以它们的不同主要在于针对的对象不同，bytes针对的是字节，strings针对的是字符串（它们的方法实现原理很相似）。另一个区别就是 bytes还带有Buffer的功能，但是 strings没提供。</li>
</ol>
<p>关于Reader和Writer接口，可以简单理解为读取源和写入源，即只要实现Reader里面的Read方法，这个东西就可以作为一个读取源，里面可以包含数据并被我们读取；Writer亦是如此。</p>
<h3 id="io-和字节的故事bytes-库">io 和字节的故事：bytes 库</h3>
<p>Reader/Writer 可以是内存字节数组。</p>
<p>处理字节数组的库，bytes.Reader 可以把 <code>[]byte</code> 转换成 Reader，bytes.Buffer 可以把 <code>[]byte</code> 转化成 Reader、Writer ，换句话讲，内存块可以作为读写的数据流了。</p>
<p>举个栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">readerFromBytes</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">readerFromBytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// n == 1024, err == nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;n=%v,err=%v\n&#34;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>bytes库有Buffer的功能，而strings库则没有。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;Size: %d MB.&#34;</span><span class="p">,</span> <span class="mi">85</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// s == &#34;Size: 85 MB.&#34;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="io-和字符串的故事strings-库">io 和字符串的故事：strings 库</h3>
<p>字符串可以是 Reader。</p>
<p>strings.Reader 能够把字符串转换成 Reader ，这个也挺有意思的，直接能把字符串作为读源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="nx">data</span> <span class="o">:=</span> <span class="s">&#34;hello world&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">readerFromBytes</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">readerFromBytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;n=%v,err=%v\n&#34;</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="io-和网络的故事net-库">io 和网络的故事：net 库</h3>
<p>网络可以作为读写源，抽象成了 Reader、Writer 的形式。这个是以 net.Conn  封装出来的。</p>
<p>举个栗子：演示一个 C/S 通信。</p>
<p>服务端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"> <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;pong: &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">server</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:9999&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err:%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">go</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关键点：</p>
<ol>
<li>net.Listen 创建一个监听套接字，在 Go 里封装成了 net.Listener 类型；</li>
<li>Accept 函数返回一个 net.Conn ，代表一条网络连接，net.Conn  既是 Reader，又是 Writer ，拿到之后各自处理即可；</li>
</ol>
<p>客户端：</p>
<p>通过 net.Dail  一个 net.Conn 出来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:9999&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello world\n&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关键点：</p>
<ol>
<li>net.Dail 传入服务端地址和网络协议类型，即可返回一条和服务端通信的网络连接，返回的结构为 net.Conn；</li>
<li>net.Conn 即可作为读端（ Reader ），也是写端（ Writer ）；</li>
</ol>
<p>以上无论是 net.Listener ，还是 net.Conn  都是基于系统调用 socket 之上的一层封装。底下使用的是类似的系统调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">syscall.Socket</span>
</span></span><span class="line"><span class="cl"><span class="n">syscall.Connect</span>
</span></span><span class="line"><span class="cl"><span class="n">syscall.Listen</span>
</span></span><span class="line"><span class="cl"><span class="n">syscall.GetsockoptInt</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Go 针对网络 fd 会做哪些封装呢？</p>
<ol>
<li>创建还是用 socket 的调用创建的 fd，创建出来就会立马设置 nonblock 模式（因为 Go 的网络 fd 天然要使用 IO 多路复用的方式来走 IO ），还有其他配置；</li>
<li>把 socket fd 丢到 epoll 池里 （ 通过 poll.runtime_pollOpen  把 socket 套接字加到 epoll 池里，底层调用的还是 epollctl  ），监听事件；</li>
<li>封装好读写事件到来的函数回调；</li>
</ol>
<h3 id="和文件的故事os-库">和文件的故事：os 库</h3>
<p>文件 IO，这个就是我们最常见的文件 IO 啦，文件可以作为读端，也可以作为写端。</p>
<p>File</p>
<p>io 的读写端可以是文件。这个太容易理解了，也是我们最常见的读写端，毕竟文件就是存储数据的一种形态。在 Go 里面，我们用 os.OpenFile  这个调用，就可以获取到 Go 帮你封装的文件操作句柄 File ，File 这个结构体对外实现了 Read，Write，ReadAt，WriteAt  等接口，所以自然就可以作为 Reader 和 Writer 来使用。。</p>
<p>举个栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">    <span class="c1">// 如下，把 test.data 的数据读出来丢到垃圾桶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;test.data&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_RDWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">fd</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里返回了一个 File 类型，不难想象这个是基于文件 fd 的一层封装。这个里面大概做了什么？</p>
<ol>
<li>调用系统调用 syscall.Open 拿到文件 fd ，顺便设置了下垃圾回收时候的析构函数，其他的好像没了。远比网络 fd 要简单；</li>
</ol>
<p>Stdin、Stdout、Stderr</p>
<p>Go 这个把标准输入、标准输出、标准错误输出 抽象成了读写源，对应了 os.Stdin，os.Stdout，os.Stderr  这三个变量。这三个变量其实就是 File 类型的变量，定义在 Go 的源码库 src/os/file.go 里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="nx">Stdin</span>  <span class="p">=</span> <span class="nf">NewFile</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">),</span> <span class="s">&#34;/dev/stdin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nx">Stdout</span> <span class="p">=</span> <span class="nf">NewFile</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">),</span> <span class="s">&#34;/dev/stdout&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nx">Stderr</span> <span class="p">=</span> <span class="nf">NewFile</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">),</span> <span class="s">&#34;/dev/stderr&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>划重点：这个就是我们常用的 0，1，2 句柄哦。</p>
<p>标准输入就可以和方便的作为读端（ Reader ），标准输出可以作为写端（ Writer ）啦。</p>
<p>举个栗子：用一行代码实现一个最简单的 echo 回显的程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 一行代码实现回显
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>把标准输入作为读端，标准输出作为写端。编译出来运行吧，在终端随便输入一个字符串，敲下回车看下效果吧。</p>
<h3 id="缓存-io-的故事bufio-库">缓存 io 的故事：bufio 库</h3>
<p>Reader/Writer 可以是缓冲 IO 的数据流。</p>
<p>在 c 语言，有人肯定用过 fopen  打开的文件（所谓的标准IO）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">FILE</span> <span class="o">*</span><span class="nf">fopen</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">mode</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数 open 出的是一个 FILE 结构体，而非之前常说的整数 fd 句柄。通过这个文件句柄的 IO 就是标准库帮你实现的缓冲 IO。c 语言的缓冲 IO 有三种模式：</p>
<ul>
<li>全缓冲：数据填满 buffer，才会真正的调用底层 IO；</li>
<li>行缓冲：不用等填满 buffer，遇到换行符，就会把 IO 下发下去；</li>
<li>不缓冲：bypass 的模式，每次都是直通底层 IO；</li>
</ul>
<p>Go 的缓冲 IO 则是由 bufio 这个库提供。先讨论下缓冲 IO 究竟是什么吧。</p>
<p>缓冲 IO 是在底层 IO 之上实现的一层 buffer ，什么意思？</p>
<p>假设有个用户，每次写数据都只写 1 个字节，顺序的，写 512 次。之前我们在磁盘 IO 为啥要对齐中提过，非对齐的 IO 性能损失很大。以普通的机械硬盘来说，写 1 个字节，其实要先读一个扇区出来，然后再写下去。所以这里 IO 实际的 IO 次数为 1024 次，实际的 IO 数据量为：读 512<em>512 Byte，写了 512</em>512  Byte。</p>
<p>能怎么优化呢？</p>
<p>搞一个内存 512 字节的 buffer ，用户写 1 个字节我就先暂存在 buffer 里面，直到写满 512 字节，buffer 满了，然后一次性把 512 字节的 buffer 数据写到底层。你会发现，这里实际的 IO 只有一次，实际的数据量只有 512 字节。这就是 buffer io ，能极大的减少底层真实的 IO 次数。</p>
<p>所以，缓冲 IO 的优势是什么？</p>
<p>一目了然，写的时候能聚合 IO，极大减少 IO 次数。读的时候还能实现预读的效果，同样也减少 IO 次数。</p>
<p>缺点是啥？</p>
<p>这个也很容易理解，buffer io 相当于缓存数据了，一份数据多份存储了，这里给数据的一致性管理带来了复杂性，预读还有可能读到脏数据等等混乱情况。</p>
<p>bufio 这个库我们先理解名字，buffer io 的缩写。那顾名思义，核心是实现了缓存 IO 的库。对一个 Reader/Writer 携带一个内存 buffer 做了一层封装，达到聚合 io 的目的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210809133803.png" alt=""></p>
<p>bufio 的使用接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 创建一个带 buffer 的 writer，使用默认 buffer size 4096
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewWriter</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 创建一个带 buffer 的 writer 可以手动指定 buffer size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bufio</span><span class="p">.</span><span class="nx">NewWriterSize</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>bufio，可以理解为在io库的基础上额外封装加了一个缓存层，它提供了很多按行进行读写的函数，从io库的按字节读写变为按行读写对写代码来说还是方便了不少。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">readBigFile</span><span class="p">(</span><span class="nx">filePath</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 循环中打印前100行内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">line</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">line</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;line&#34;</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>ReadLine和ReadString方法：buf.ReadLine()，buf.ReadString(&quot;\n&quot;)都是按行读，只不过ReadLine读出来的是[]byte，后者直接读出了string，最终他们底层调用的都是ReadSlice方法。</li>
<li>bufio VS ioutil 库： bufio 和 ioutil 库都提供了读写文件的能力。它们之间唯一的区别是 bufio 有一个额外的缓存层。这个优势主要体现在读取大文件的时候。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>CPU 和 IO 设备是不同的设备，能并行运行。合理调度程序，充分利用硬件，就能跑出很好的性能；</p>
</li>
<li>
<p>Go 的 IO 最最核心的是 io 库，如果要实现其中的 interface  ，千万要仔细阅读语义；</p>
</li>
<li>
<p>io 库除了定义 interface ，还实现了通用的函数，比如 Copy 之类的；</p>
</li>
<li>
<p>io/ioutil 里面实现的挺杂的，但真香；</p>
</li>
<li>
<p>内存字节数组可以作为 Reader ，Writer ，实现在 bytes 库中，bytes.NewReader，bytes.NewBuffer （换句话说，内存结构体和可以作为 Reader，因为结构体可以强转成字节数组）；</p>
</li>
<li>
<p>字符串可以作为 Reader，实现在 strings 库中，strings.NewReader  ；</p>
</li>
<li>
<p>网络句柄可以作为 Reader，Writer，实现在 net 库中，net.Conn；</p>
</li>
<li>
<p>文件句柄可以作为 Reader，Writer，实现在 os 库中，os.File ；</p>
</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/JniBMBw__WLbYtigj3eiXQ">浅析 Go IO 的知识框架</a></p>
<p><a href="https://juejin.cn/post/6864886461746855949">Go指南10-谈谈对Golang IO读写的困惑</a></p>
<p><a href="https://juejin.cn/post/6976841033795502093">Golang的IO库那么多，我该怎么选?</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-08-06
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go代码的编译与反编译</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/">
            <span class="next-text nav-default">全链路灰度方案设计</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
