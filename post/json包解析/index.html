<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>json包解析 | Forz Blog</title>
<meta name="keywords" content="Go标准库" />
<meta name="description" content="func Compact func Compact(dst *bytes.Buffer, src []byte) error 将src删除空格符号,并附加到dst中 func HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte) HTMLEscape 函数将json编码的src中的&lt;、&gt;、&amp;、U&#43;20">
<meta name="author" content="">
<link rel="canonical" href="/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="json包解析" />
<meta property="og:description" content="func Compact func Compact(dst *bytes.Buffer, src []byte) error 将src删除空格符号,并附加到dst中 func HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte) HTMLEscape 函数将json编码的src中的&lt;、&gt;、&amp;、U&#43;20" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-23T16:22:15&#43;00:00" />
<meta property="article:modified_time" content="2018-11-23T16:22:15&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="json包解析"/>
<meta name="twitter:description" content="func Compact func Compact(dst *bytes.Buffer, src []byte) error 将src删除空格符号,并附加到dst中 func HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte) HTMLEscape 函数将json编码的src中的&lt;、&gt;、&amp;、U&#43;20"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "json包解析",
      "item": "/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "json包解析",
  "name": "json包解析",
  "description": "func Compact func Compact(dst *bytes.Buffer, src []byte) error 将src删除空格符号,并附加到dst中 func HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte) HTMLEscape 函数将json编码的src中的\u0026lt;、\u0026gt;、\u0026amp;、U+20",
  "keywords": [
    "Go标准库"
  ],
  "articleBody": "func Compact func Compact(dst *bytes.Buffer, src []byte) error  将src删除空格符号,并附加到dst中\nfunc HTMLEscape func HTMLEscape(dst *bytes.Buffer, src []byte)  HTMLEscape 函数将json编码的src中的、\u0026、U+2028 和U+2029字符替换为\\u003c、\\u003e、\\u0026、\\u2028、\\u2029 转义字符串，以便json编码可以安全的嵌入HTML的标签里。因为历史原因，网络浏览器不支持在标签中使用标准HTML转义， 因此必须使用另一种json编码方案。\nfunc Indent func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error  Indent函数将json编码的调整缩进之后写入dst。JSON对象或数组中的每个元素都以一个新的缩进行开始，该行以前缀开头，后跟根据缩进嵌套的一个或多个缩进副本。附加到dst的数据不以前缀或任何缩进开头，以便更容易嵌入其他格式化的JSON数据中。虽然删除了src开头的前导空格字符（空格，制表符，回车符，换行符），但保留了src末尾的尾随空格字符并将其复制到dst。例如，如果src没有尾随空格，则dst也不会; 如果src以尾随换行结束，那么dst也是如此。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import ( \"bytes\" \"encoding/json\" \"log\" \"os\" ) func main() { type Road struct { Name string Number int } roads := []Road{ {\"Diamond Fork\", 29}, {\"Sheep Creek\", 51}, } b, err := json.Marshal(roads) if err != nil { log.Fatal(err) } var out bytes.Buffer json.Indent(\u0026out, b, \"=\", \"\\t\") out.WriteTo(os.Stdout) } [ = { = \"Name\": \"Diamond Fork\", = \"Number\": 29 = }, = { = \"Name\": \"Sheep Creek\", = \"Number\": 51 = } =]%   func Marshal func Marshal(v interface{}) ([]byte, error)  Marshal返回v的JSON编码。\nMarshal递归地遍历值v。如果遇到的值实现了Marshaler接口并且不是nil指针，Marshal会调用其MarshalJSON方法来生成JSON。如果不存在MarshalJSON方法，但该值实现encoding.TextMarshaler，则Marshal调用其MarshalText方法并将结果编码为JSON字符串。nil指针异常不是绝对必要的，但会模拟与UnmarshalJSON的行为类似的必需的异常。\n否则，Marshal使用以下类型相关的默认编码：\n布尔类型编码为json布尔类型。\n浮点数、整数和Number类型的值编码为json数字类型。\n字符串值编码为强制转换为有效UTF-8的JSON字符串，用Unicode替换符号替换无效字节。尖括号“”被转义为“\\ u003c”和“\\ u003e”，以防止某些浏览器将JSON输出误解为HTML。出于同样的原因,“＆”也被转义到“\\ u0026”。可以使用调用了SetEscapeHTML（false）的编码器禁用此转义。\n数组和切片类型的值编码为json数组，但[]byte编码为base64编码字符串，nil切片编码为null.\n结构体编码为JSON对象。每个导出的struct字段都成为对象的成员，使用字段名称作为对象键，除非出于下面给出的原因之一省略该字段。\n每个struct字段的编码可以通过存储在struct字段标记中“json”键下的格式字符串来定制。格式字符串给出了字段的名称，可能后跟逗号分隔的选项列表。名称可以为空以指定选项而不覆盖默认字段名称。\n“omitempty”选项指定如果字段具有空值（定义为false，0，nil指针，nil接口值以及任何空数组，切片，映射或字符串），则应从编码中省略该字段。\n作为特殊情况，如果字段标记为“ - ”，则始终省略该字段。请注意，仍然可以使用标记“ - ，”生成名称为“ - ”的字段。\nstruct字段标记及其含义的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //字段在JSON中显示为键“myName”。 Field int `json:\"myName\"` //字段在JSON中显示为关键字“myName”和 //如果对象的值为空，则该对象将被省略， //如上所定义。 Field int `json:\"myName,omitempty\"` //字段在JSON中显示为键\"Field\"（默认值），但是 //如果为空则跳过该字段。 //注意引导逗号。 Field int `json:\",omitempty\"` //此包忽略了字段。 Field int `json:\"-\"` //字段在JSON中显示为键 \"-\"。 Field int `json:\"-,\"`   “string”选项表示字段在JSON编码的字符串中存储为JSON。它仅适用于字符串，浮点，整数或布尔类型的字段。在与JavaScript程序通信时，有时会使用这种额外的编码级别：\n1  Int64String int64 `json:\",string\"`   如果键名是非空字符串，仅包含Unicode字母，数字和ASCII标点符号（引号，反斜杠和逗号除外），则将使用键名。\n匿名结构字段通常被封送，就好像它们的内部导出字段是外部结构中的字段一样，受下一段中描述的通常的Go可见性规则修改。在其JSON标记中给出名称的匿名结构字段被视为具有该名称，而不是匿名。接口类型的匿名结构字段的处理方式与将该类型作为其名称相同，而不是匿名。\n在决定要编组或解组的字段时，会针对JSON修改结构字段的Go可见性规则。如果同一级别有多个字段，并且该级别是嵌套最少的（因此通常是Go规则选择的嵌套级别），则适用以下额外规则：\n1）在这些字段中，如果有任何JSON标记，则仅考虑标记字段，即使存在多个未标记的字段否则会发生冲突。\n2）如果只有一个字段（根据第一个规则标记或不标记），则选择该字段。\n3）否则有多个字段，都被忽略; 没有错误发生。\n处理匿名结构字段是Go 1.1中的新增功能。在Go 1.1之前，匿名结构字段被忽略。要强制忽略当前版本和早期版本中的匿名结构字段，请为该字段指定“ - ”的JSON标记。\n映射值编码为JSON对象。映射的键类型必须是字符串，整数类型或实现encoding.TextMarshaler。通过应用以下规则对映射键进行排序并将其用作JSON对象键，具体取决于上面对字符串值所描述的UTF-8强制：\n 直接使用字符串键 encoding.TextMarshalers被封送 整数键转换为字符串 指针值编码为指向的值。nil指针编码为空JSON值。  接口值编码为接口中包含的值。nil接口值编码为null JSON值。\n通道，复杂和函数值无法以JSON编码。尝试对此类值进行编码会导致Marshal返回UnsupportedTypeError。\nJSON不能表示循环数据结构，Marshal不能处理它们。将循环结构传递给Marshal将导致无限递归。\n▹ Example\nfunc MarshalIndent func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.\n▹ Example\nfunc Unmarshal func Unmarshal(data []byte, v interface{}) error Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.\nUnmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.\nTo unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value’s UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value’s UnmarshalText method with the unquoted form of the string.\nTo unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don’t have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).\nTo unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:\nbool, for JSON booleans float64, for JSON numbers string, for JSON strings []interface{}, for JSON arrays map[string]interface{}, for JSON objects nil for JSON null To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.\nTo unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map’s key type must either be a string, an integer, or implement encoding.TextUnmarshaler.\nIf a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it’s not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.\nThe JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean “not present,” unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.\nWhen unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.\n▹ Example\nfunc Valid 1.9 func Valid(data []byte) bool Valid reports whether data is a valid JSON encoding.\ntype Decoder A Decoder reads and decodes JSON values from an input stream.\ntype Decoder struct { // contains filtered or unexported fields } ▹ Example\nfunc NewDecoder func NewDecoder(r io.Reader) *Decoder NewDecoder returns a new decoder that reads from r.\nThe decoder introduces its own buffering and may read data from r beyond the JSON values requested.\nfunc (*Decoder) Buffered 1.1 func (dec *Decoder) Buffered() io.Reader Buffered returns a reader of the data remaining in the Decoder’s buffer. The reader is valid until the next call to Decode.\nfunc (*Decoder) Decode func (dec *Decoder) Decode(v interface{}) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.\nSee the documentation for Unmarshal for details about the conversion of JSON into a Go value.\n▹ Example (Stream)\nfunc (*Decoder) DisallowUnknownFields 1.10 func (dec *Decoder) DisallowUnknownFields() DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination.\nfunc (*Decoder) More 1.5 func (dec *Decoder) More() bool More reports whether there is another element in the current array or object being parsed.\nfunc (*Decoder) Token 1.5 func (dec *Decoder) Token() (Token, error) Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.\nToken guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.\nThe input stream consists of basic JSON values—bool, string, number, and null—along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.\n▹ Example\nfunc (*Decoder) UseNumber 1.1 func (dec *Decoder) UseNumber() UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.\ntype Delim 1.5 A Delim is a JSON array or object delimiter, one of [ ] { or }.\ntype Delim rune func (Delim) String 1.5 func (d Delim) String() string type Encoder An Encoder writes JSON values to an output stream.\ntype Encoder struct { // contains filtered or unexported fields } func NewEncoder func NewEncoder(w io.Writer) *Encoder NewEncoder returns a new encoder that writes to w.\nfunc (*Encoder) Encode func (enc *Encoder) Encode(v interface{}) error Encode writes the JSON encoding of v to the stream, followed by a newline character.\nSee the documentation for Marshal for details about the conversion of Go values to JSON.\nfunc (*Encoder) SetEscapeHTML 1.7 func (enc *Encoder) SetEscapeHTML(on bool) SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape \u0026, to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that can arise when embedding JSON in HTML.\nIn non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.\nfunc (*Encoder) SetIndent 1.7 func (enc *Encoder) SetIndent(prefix, indent string) SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(\"\", “\") disables indentation.\ntype InvalidUTF8Error Before Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD.\nDeprecated: No longer used; kept for compatibility.\ntype InvalidUTF8Error struct { S string // the whole string value that caused the error } func (*InvalidUTF8Error) Error func (e *InvalidUTF8Error) Error() string type InvalidUnmarshalError An InvalidUnmarshalError describes an invalid argument passed to Unmarshal. (The argument to Unmarshal must be a non-nil pointer.)\ntype InvalidUnmarshalError struct { Type reflect.Type } func (*InvalidUnmarshalError) Error func (e *InvalidUnmarshalError) Error() string type Marshaler Marshaler is the interface implemented by types that can marshal themselves into valid JSON.\ntype Marshaler interface { MarshalJSON() ([]byte, error) } type MarshalerError type MarshalerError struct { Type reflect.Type Err error } func (*MarshalerError) Error func (e *MarshalerError) Error() string type Number 1.1 A Number represents a JSON number literal.\ntype Number string func (Number) Float64 1.1 func (n Number) Float64() (float64, error) Float64 returns the number as a float64.\nfunc (Number) Int64 1.1 func (n Number) Int64() (int64, error) Int64 returns the number as an int64.\nfunc (Number) String 1.1 func (n Number) String() string String returns the literal text of the number.\ntype RawMessage RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.\ntype RawMessage []byte ▹ Example (Marshal)\n▹ Example (Unmarshal)\nfunc (RawMessage) MarshalJSON 1.8 func (m RawMessage) MarshalJSON() ([]byte, error) MarshalJSON returns m as the JSON encoding of m.\nfunc (*RawMessage) UnmarshalJSON func (m *RawMessage) UnmarshalJSON(data []byte) error UnmarshalJSON sets *m to a copy of data.\ntype SyntaxError A SyntaxError is a description of a JSON syntax error.\ntype SyntaxError struct { Offset int64 // error occurred after reading Offset bytes // contains filtered or unexported fields } func (*SyntaxError) Error func (e *SyntaxError) Error() string type Token 1.5 A Token holds a value of one of these types:\nDelim, for the four JSON delimiters [ ] { } bool, for JSON booleans float64, for JSON numbers Number, for JSON numbers string, for JSON string literals nil, for JSON null type Token interface{} type UnmarshalFieldError An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field.\nDeprecated: No longer used; kept for compatibility.\ntype UnmarshalFieldError struct { Key string Type reflect.Type Field reflect.StructField } func (*UnmarshalFieldError) Error func (e *UnmarshalFieldError) Error() string type UnmarshalTypeError An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type.\ntype UnmarshalTypeError struct { Value string // description of JSON value - “bool”, “array”, “number -5” Type reflect.Type // type of Go value it could not be assigned to Offset int64 // error occurred after reading Offset bytes; added in Go 1.5 Struct string // name of the struct type containing the field; added in Go 1.8 Field string // name of the field holding the Go value; added in Go 1.8 } func (*UnmarshalTypeError) Error func (e *UnmarshalTypeError) Error() string type Unmarshaler Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.\nBy convention, to approximate the behavior of Unmarshal itself, Unmarshalers implement UnmarshalJSON([]byte(“null”)) as a no-op.\ntype Unmarshaler interface { UnmarshalJSON([]byte) error } type UnsupportedTypeError An UnsupportedTypeError is returned by Marshal when attempting to encode an unsupported value type.\ntype UnsupportedTypeError struct { Type reflect.Type } func (*UnsupportedTypeError) Error ¶ func (e *UnsupportedTypeError) Error() string type UnsupportedValueError type UnsupportedValueError struct { Value reflect.Value Str string } func (*UnsupportedValueError) Error func (e *UnsupportedValueError) Error() string\n",
  "wordCount" : "4348",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-23T16:22:15Z",
  "dateModified": "2018-11-23T16:22:15Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/json%E5%8C%85%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      json包解析
    </h1>
    <div class="post-meta">November 23, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="func-compact">func Compact<a hidden class="anchor" aria-hidden="true" href="#func-compact">#</a></h1>
<pre><code>func Compact(dst *bytes.Buffer, src []byte) error
</code></pre>
<p>将src删除空格符号,并附加到dst中</p>
<h1 id="func-htmlescape">func HTMLEscape<a hidden class="anchor" aria-hidden="true" href="#func-htmlescape">#</a></h1>
<pre><code>func HTMLEscape(dst *bytes.Buffer, src []byte)
</code></pre>
<p>HTMLEscape 函数将json编码的src中的&lt;、&gt;、&amp;、U+2028 和U+2029字符替换为\u003c、\u003e、\u0026、\u2028、\u2029 转义字符串，以便json编码可以安全的嵌入HTML的&lt;script&gt;标签里。因为历史原因，网络浏览器不支持在&lt;script&gt;标签中使用标准HTML转义， 因此必须使用另一种json编码方案。</p>
<h1 id="func-indent">func Indent<a hidden class="anchor" aria-hidden="true" href="#func-indent">#</a></h1>
<pre><code>func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
</code></pre>
<p>Indent函数将json编码的调整缩进之后写入dst。JSON对象或数组中的每个元素都以一个新的缩进行开始，该行以前缀开头，后跟根据缩进嵌套的一个或多个缩进副本。附加到dst的数据不以前缀或任何缩进开头，以便更容易嵌入其他格式化的JSON数据中。虽然删除了src开头的前导空格字符（空格，制表符，回车符，换行符），但保留了src末尾的尾随空格字符并将其复制到dst。例如，如果src没有尾随空格，则dst也不会; 如果src以尾随换行结束，那么dst也是如此。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">Road</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Name</span>   <span class="kt">string</span>
		<span class="nx">Number</span> <span class="kt">int</span>
	<span class="p">}</span>
	<span class="nx">roads</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">Road</span><span class="p">{</span>
		<span class="p">{</span><span class="s">&#34;Diamond Fork&#34;</span><span class="p">,</span> <span class="mi">29</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;Sheep Creek&#34;</span><span class="p">,</span> <span class="mi">51</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">roads</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">out</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Indent</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">out</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="s">&#34;\t&#34;</span><span class="p">)</span>
	<span class="nx">out</span><span class="p">.</span><span class="nf">WriteTo</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
<span class="p">}</span>



<span class="p">[</span>
<span class="p">=</span>       <span class="p">{</span>
<span class="p">=</span>               <span class="s">&#34;Name&#34;</span><span class="p">:</span> <span class="s">&#34;Diamond Fork&#34;</span><span class="p">,</span>
<span class="p">=</span>               <span class="s">&#34;Number&#34;</span><span class="p">:</span> <span class="mi">29</span>
<span class="p">=</span>       <span class="p">},</span>
<span class="p">=</span>       <span class="p">{</span>
<span class="p">=</span>               <span class="s">&#34;Name&#34;</span><span class="p">:</span> <span class="s">&#34;Sheep Creek&#34;</span><span class="p">,</span>
<span class="p">=</span>               <span class="s">&#34;Number&#34;</span><span class="p">:</span> <span class="mi">51</span>
<span class="p">=</span>       <span class="p">}</span>
<span class="p">=]</span><span class="o">%</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-marshal">func Marshal<a hidden class="anchor" aria-hidden="true" href="#func-marshal">#</a></h1>
<pre><code>func Marshal(v interface{}) ([]byte, error)
</code></pre>
<p>Marshal返回v的JSON编码。</p>
<p>Marshal递归地遍历值v。如果遇到的值实现了Marshaler接口并且不是nil指针，Marshal会调用其MarshalJSON方法来生成JSON。如果不存在MarshalJSON方法，但该值实现encoding.TextMarshaler，则Marshal调用其MarshalText方法并将结果编码为JSON字符串。nil指针异常不是绝对必要的，但会模拟与UnmarshalJSON的行为类似的必需的异常。</p>
<p>否则，Marshal使用以下类型相关的默认编码：</p>
<p>布尔类型编码为json布尔类型。</p>
<p>浮点数、整数和Number类型的值编码为json数字类型。</p>
<p>字符串值编码为强制转换为有效UTF-8的JSON字符串，用Unicode替换符号替换无效字节。尖括号“&lt;”和“&gt;”被转义为“\ u003c”和“\ u003e”，以防止某些浏览器将JSON输出误解为HTML。出于同样的原因,“＆”也被转义到“\ u0026”。可以使用调用了SetEscapeHTML（false）的编码器禁用此转义。</p>
<p>数组和切片类型的值编码为json数组，但[]byte编码为base64编码字符串，nil切片编码为null.</p>
<p>结构体编码为JSON对象。每个导出的struct字段都成为对象的成员，使用字段名称作为对象键，除非出于下面给出的原因之一省略该字段。</p>
<p>每个struct字段的编码可以通过存储在struct字段标记中“json”键下的格式字符串来定制。格式字符串给出了字段的名称，可能后跟逗号分隔的选项列表。名称可以为空以指定选项而不覆盖默认字段名称。</p>
<p>“omitempty”选项指定如果字段具有空值（定义为false，0，nil指针，nil接口值以及任何空数组，切片，映射或字符串），则应从编码中省略该字段。</p>
<p>作为特殊情况，如果字段标记为“ - ”，则始终省略该字段。请注意，仍然可以使用标记“ - ，”生成名称为“ - ”的字段。</p>
<p>struct字段标记及其含义的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//字段在JSON中显示为键“myName”。
</span><span class="c1"></span><span class="nx">Field</span> <span class="kt">int</span> <span class="s">`json:&#34;myName&#34;`</span>

<span class="c1">//字段在JSON中显示为关键字“myName”和
</span><span class="c1">//如果对象的值为空，则该对象将被省略，
</span><span class="c1">//如上所定义。
</span><span class="c1"></span><span class="nx">Field</span> <span class="kt">int</span> <span class="s">`json:&#34;myName,omitempty&#34;`</span>

<span class="c1">//字段在JSON中显示为键&#34;Field&#34;（默认值），但是
</span><span class="c1">//如果为空则跳过该字段。
</span><span class="c1">//注意引导逗号。
</span><span class="c1"></span><span class="nx">Field</span> <span class="kt">int</span> <span class="s">`json:&#34;,omitempty&#34;`</span>

<span class="c1">//此包忽略了字段。
</span><span class="c1"></span><span class="nx">Field</span> <span class="kt">int</span> <span class="s">`json:&#34;-&#34;`</span>

<span class="c1">//字段在JSON中显示为键 &#34;-&#34;。
</span><span class="c1"></span><span class="nx">Field</span> <span class="kt">int</span> <span class="s">`json:&#34;-,&#34;`</span>
</code></pre></td></tr></table>
</div>
</div><p>“string”选项表示字段在JSON编码的字符串中存储为JSON。它仅适用于字符串，浮点，整数或布尔类型的字段。在与JavaScript程序通信时，有时会使用这种额外的编码级别：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Int64String</span> <span class="kt">int64</span> <span class="s">`json:&#34;,string&#34;`</span>
</code></pre></td></tr></table>
</div>
</div><p>如果键名是非空字符串，仅包含Unicode字母，数字和ASCII标点符号（引号，反斜杠和逗号除外），则将使用键名。</p>
<p>匿名结构字段通常被封送，就好像它们的内部导出字段是外部结构中的字段一样，受下一段中描述的通常的Go可见性规则修改。在其JSON标记中给出名称的匿名结构字段被视为具有该名称，而不是匿名。接口类型的匿名结构字段的处理方式与将该类型作为其名称相同，而不是匿名。</p>
<p>在决定要编组或解组的字段时，会针对JSON修改结构字段的Go可见性规则。如果同一级别有多个字段，并且该级别是嵌套最少的（因此通常是Go规则选择的嵌套级别），则适用以下额外规则：</p>
<p>1）在这些字段中，如果有任何JSON标记，则仅考虑标记字段，即使存在多个未标记的字段否则会发生冲突。</p>
<p>2）如果只有一个字段（根据第一个规则标记或不标记），则选择该字段。</p>
<p>3）否则有多个字段，都被忽略; 没有错误发生。</p>
<p>处理匿名结构字段是Go 1.1中的新增功能。在Go 1.1之前，匿名结构字段被忽略。要强制忽略当前版本和早期版本中的匿名结构字段，请为该字段指定“ - ”的JSON标记。</p>
<p>映射值编码为JSON对象。映射的键类型必须是字符串，整数类型或实现encoding.TextMarshaler。通过应用以下规则对映射键进行排序并将其用作JSON对象键，具体取决于上面对字符串值所描述的UTF-8强制：</p>
<ul>
<li>直接使用字符串键</li>
<li>encoding.TextMarshalers被封送</li>
<li>整数键转换为字符串
指针值编码为指向的值。nil指针编码为空JSON值。</li>
</ul>
<p>接口值编码为接口中包含的值。nil接口值编码为null JSON值。</p>
<p>通道，复杂和函数值无法以JSON编码。尝试对此类值进行编码会导致Marshal返回UnsupportedTypeError。</p>
<p>JSON不能表示循环数据结构，Marshal不能处理它们。将循环结构传递给Marshal将导致无限递归。</p>
<p>▹ Example</p>
<p>func MarshalIndent
func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)
MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.</p>
<p>▹ Example</p>
<p>func Unmarshal
func Unmarshal(data []byte, v interface{}) error
Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</p>
<p>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</p>
<p>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</p>
<p>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value&rsquo;s UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value&rsquo;s UnmarshalText method with the unquoted form of the string.</p>
<p>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don&rsquo;t have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</p>
<p>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</p>
<p>bool, for JSON booleans
float64, for JSON numbers
string, for JSON strings
[]interface{}, for JSON arrays
map[string]interface{}, for JSON objects
nil for JSON null
To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</p>
<p>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</p>
<p>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map&rsquo;s key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</p>
<p>If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it&rsquo;s not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.</p>
<p>The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean “not present,” unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.</p>
<p>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</p>
<p>▹ Example</p>
<p>func Valid 1.9
func Valid(data []byte) bool
Valid reports whether data is a valid JSON encoding.</p>
<p>type Decoder
A Decoder reads and decodes JSON values from an input stream.</p>
<p>type Decoder struct {
// contains filtered or unexported fields
}
▹ Example</p>
<p>func NewDecoder
func NewDecoder(r io.Reader) *Decoder
NewDecoder returns a new decoder that reads from r.</p>
<p>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</p>
<p>func (*Decoder) Buffered 1.1
func (dec *Decoder) Buffered() io.Reader
Buffered returns a reader of the data remaining in the Decoder&rsquo;s buffer. The reader is valid until the next call to Decode.</p>
<p>func (*Decoder) Decode
func (dec *Decoder) Decode(v interface{}) error
Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.</p>
<p>See the documentation for Unmarshal for details about the conversion of JSON into a Go value.</p>
<p>▹ Example (Stream)</p>
<p>func (*Decoder) DisallowUnknownFields 1.10
func (dec *Decoder) DisallowUnknownFields()
DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination.</p>
<p>func (*Decoder) More 1.5
func (dec *Decoder) More() bool
More reports whether there is another element in the current array or object being parsed.</p>
<p>func (*Decoder) Token 1.5
func (dec *Decoder) Token() (Token, error)
Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</p>
<p>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</p>
<p>The input stream consists of basic JSON values—bool, string, number, and null—along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</p>
<p>▹ Example</p>
<p>func (*Decoder) UseNumber 1.1
func (dec *Decoder) UseNumber()
UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</p>
<p>type Delim 1.5
A Delim is a JSON array or object delimiter, one of [ ] { or }.</p>
<p>type Delim rune
func (Delim) String 1.5
func (d Delim) String() string
type Encoder
An Encoder writes JSON values to an output stream.</p>
<p>type Encoder struct {
// contains filtered or unexported fields
}
func NewEncoder
func NewEncoder(w io.Writer) *Encoder
NewEncoder returns a new encoder that writes to w.</p>
<p>func (*Encoder) Encode
func (enc *Encoder) Encode(v interface{}) error
Encode writes the JSON encoding of v to the stream, followed by a newline character.</p>
<p>See the documentation for Marshal for details about the conversion of Go values to JSON.</p>
<p>func (*Encoder) SetEscapeHTML 1.7
func (enc *Encoder) SetEscapeHTML(on bool)
SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;, &lt;, and &gt; to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.</p>
<p>In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.</p>
<p>func (*Encoder) SetIndent 1.7
func (enc *Encoder) SetIndent(prefix, indent string)
SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(&quot;&quot;, &ldquo;&quot;) disables indentation.</p>
<p>type InvalidUTF8Error
Before Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD.</p>
<p>Deprecated: No longer used; kept for compatibility.</p>
<p>type InvalidUTF8Error struct {
S string // the whole string value that caused the error
}
func (*InvalidUTF8Error) Error
func (e *InvalidUTF8Error) Error() string
type InvalidUnmarshalError
An InvalidUnmarshalError describes an invalid argument passed to Unmarshal. (The argument to Unmarshal must be a non-nil pointer.)</p>
<p>type InvalidUnmarshalError struct {
Type reflect.Type
}
func (*InvalidUnmarshalError) Error
func (e *InvalidUnmarshalError) Error() string
type Marshaler
Marshaler is the interface implemented by types that can marshal themselves into valid JSON.</p>
<p>type Marshaler interface {
MarshalJSON() ([]byte, error)
}
type MarshalerError
type MarshalerError struct {
Type reflect.Type
Err  error
}
func (*MarshalerError) Error
func (e *MarshalerError) Error() string
type Number 1.1
A Number represents a JSON number literal.</p>
<p>type Number string
func (Number) Float64 1.1
func (n Number) Float64() (float64, error)
Float64 returns the number as a float64.</p>
<p>func (Number) Int64 1.1
func (n Number) Int64() (int64, error)
Int64 returns the number as an int64.</p>
<p>func (Number) String 1.1
func (n Number) String() string
String returns the literal text of the number.</p>
<p>type RawMessage
RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</p>
<p>type RawMessage []byte
▹ Example (Marshal)</p>
<p>▹ Example (Unmarshal)</p>
<p>func (RawMessage) MarshalJSON 1.8
func (m RawMessage) MarshalJSON() ([]byte, error)
MarshalJSON returns m as the JSON encoding of m.</p>
<p>func (*RawMessage) UnmarshalJSON
func (m *RawMessage) UnmarshalJSON(data []byte) error
UnmarshalJSON sets *m to a copy of data.</p>
<p>type SyntaxError
A SyntaxError is a description of a JSON syntax error.</p>
<p>type SyntaxError struct {
Offset int64 // error occurred after reading Offset bytes
// contains filtered or unexported fields
}
func (*SyntaxError) Error
func (e *SyntaxError) Error() string
type Token 1.5
A Token holds a value of one of these types:</p>
<p>Delim, for the four JSON delimiters [ ] { }
bool, for JSON booleans
float64, for JSON numbers
Number, for JSON numbers
string, for JSON string literals
nil, for JSON null
type Token interface{}
type UnmarshalFieldError
An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field.</p>
<p>Deprecated: No longer used; kept for compatibility.</p>
<p>type UnmarshalFieldError struct {
Key   string
Type  reflect.Type
Field reflect.StructField
}
func (*UnmarshalFieldError) Error
func (e *UnmarshalFieldError) Error() string
type UnmarshalTypeError
An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type.</p>
<p>type UnmarshalTypeError struct {
Value  string       // description of JSON value - &ldquo;bool&rdquo;, &ldquo;array&rdquo;, &ldquo;number -5&rdquo;
Type   reflect.Type // type of Go value it could not be assigned to
Offset int64        // error occurred after reading Offset bytes; added in Go 1.5
Struct string       // name of the struct type containing the field; added in Go 1.8
Field  string       // name of the field holding the Go value; added in Go 1.8
}
func (*UnmarshalTypeError) Error
func (e *UnmarshalTypeError) Error() string
type Unmarshaler
Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</p>
<p>By convention, to approximate the behavior of Unmarshal itself, Unmarshalers implement UnmarshalJSON([]byte(&ldquo;null&rdquo;)) as a no-op.</p>
<p>type Unmarshaler interface {
UnmarshalJSON([]byte) error
}
type UnsupportedTypeError
An UnsupportedTypeError is returned by Marshal when attempting to encode an unsupported value type.</p>
<p>type UnsupportedTypeError struct {
Type reflect.Type
}
func (*UnsupportedTypeError) Error ¶
func (e *UnsupportedTypeError) Error() string
type UnsupportedValueError
type UnsupportedValueError struct {
Value reflect.Value
Str   string
}
func (*UnsupportedValueError) Error
func (e *UnsupportedValueError) Error() string</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
