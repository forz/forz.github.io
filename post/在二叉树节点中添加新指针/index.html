<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>在二叉树节点中添加新指针 | Forz Blog</title>
<meta name="keywords" content="DFS, Tree" />
<meta name="description" content="LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="在二叉树节点中添加新指针" />
<meta property="og:description" content="LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:26:57&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:26:57&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="在二叉树节点中添加新指针"/>
<meta name="twitter:description" content="LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "在二叉树节点中添加新指针",
      "item": "/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "在二叉树节点中添加新指针",
  "name": "在二叉树节点中添加新指针",
  "description": "LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it",
  "keywords": [
    "DFS", "Tree"
  ],
  "articleBody": "LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree\nstruct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nNote:\nYou may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\nFor example, Given the following perfect binary tree,\n 1 / \\ 2 3 / \\ / \\ 4 5 6 7  After calling your function, the tree should look like:\n 1 - NULL / \\ 2 - 3 - NULL / \\ / \\ 4-5-6-7 - NULL  解析：本题已经规定是完全二叉树，下一层的连接关系可以直接从上一层的连接关系来求得，可以直接利用递推来处理。在维护当前层链表的时候，需要记录上一层左端节点pre，方便此层扫描结束后，跳转到下一层。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /** * Definition for binary tree with next pointer. * struct TreeLinkNode { * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */ class Solution { public: void connect(TreeLinkNode *root) { if (root == NULL) return; TreeLinkNode *pre = root; TreeLinkNode *cur = NULL; while(pre-left) {//按层维护，每一层从最左端开始  cur = pre; while(cur) { cur-left-next = cur-right;//同一棵树  if(cur-next) cur-right-next = cur-next-left;//父节点还存在邻居，右孩子也有相邻节点  cur = cur-next;//父节点右移  } pre = pre-left;//跳转到下一层 } } };   LeetCode 117. Populating Next Right Pointers in Each Node II Follow up for problem “Populating Next Right Pointers in Each Node”.\nWhat if the given tree could be any binary tree? Would your previous solution still work?\nNote:\nYou may only use constant extra space. For example, Given the following binary tree,\n 1 / \\ 2 3 / \\ \\ 4 5 7  After calling your function, the tree should look like:\n 1 - NULL / \\ 2 - 3 - NULL / \\ \\ 4- 5 - 7 - NULL  解析：本题不限制一定是完全二叉树，需要判断子节点情况，而且当前层的节点情况不能根据上一层的链表直接推出来，所以tempchild和currentchild都保存的是当前层的链表信息来辅助维护。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /** * Definition for binary tree with next pointer. * struct TreeLinkNode { * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */ class Solution { public: void connect(TreeLinkNode *root) { while(root != NULL){ TreeLinkNode *tempChild = new TreeLinkNode(0); //当前层的横向链表头，因为无法简单判断出当前层是否为空和头节点到底在哪里，所以需要先创建伪头节点  TreeLinkNode *currentChild = tempChild; while(root!=NULL){//根节点按层遍历  //左孩子  if(root-left != NULL) { currentChild-next = root-left; currentChild = currentChild-next; } //右孩子  if(root-right != NULL) { currentChild-next = root-right; currentChild = currentChild-next; } root = root-next; } root = tempChild-next;//下一层的起点  } } };   LeetCode 199. Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nFor example: Given the following binary tree,\n 1  You should return [1, 3, 4].\n解析：只返回最右侧的节点，可以将先序遍历改一下，右孩子优先，DFS扫描得到结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: void recursion(TreeNode *root, int level, vectorint \u0026res) {//先序遍历（右孩子优先）  if(root==NULL) return ;//当前结点不存在，递归终止条件  if(res.size()level) res.push_back(root-val);//如果当前层的节点还没放入答案  recursion(root-right, level+1, res); recursion(root-left, level+1, res); } vectorint rightSideView(TreeNode *root) { vectorint res; recursion(root, 1, res); return res; } };   ",
  "wordCount" : "1148",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:26:57Z",
  "dateModified": "2017-06-24T20:26:57Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      在二叉树节点中添加新指针
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-116-populating-next-right-pointers-in-each-node">LeetCode 116. Populating Next Right Pointers in Each Node<a hidden class="anchor" aria-hidden="true" href="#leetcode-116-populating-next-right-pointers-in-each-node">#</a></h1>
<p>Given a binary tree</p>
<pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</code></pre>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space. <br>
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</p>
<p>For example,    <br>
Given the following perfect binary tree,</p>
<pre><code>    1
   /  \
  2    3
 / \  / \
4  5  6  7
</code></pre>
<p>After calling your function, the tree should look like:</p>
<pre><code>    1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL
</code></pre>
<p>解析：本题已经规定是完全二叉树，下一层的连接关系可以直接从上一层的连接关系来求得，可以直接利用递推来处理。在维护当前层链表的时候，需要记录上一层左端节点pre，方便此层扫描结束后，跳转到下一层。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for binary tree with next pointer.
</span><span class="cm"> * struct TreeLinkNode {
</span><span class="cm"> *  int val;
</span><span class="cm"> *  TreeLinkNode *left, *right, *next;
</span><span class="cm"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">connect</span><span class="p">(</span><span class="n">TreeLinkNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
<span class="n">TreeLinkNode</span> <span class="o">*</span><span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
<span class="n">TreeLinkNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span><span class="c1">//按层维护，每一层从最左端开始
</span><span class="c1"></span>    <span class="n">cur</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span><span class="c1">//同一棵树
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span><span class="c1">//父节点还存在邻居，右孩子也有相邻节点
</span><span class="c1"></span>        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//父节点右移
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span><span class="c1">//跳转到下一层
</span><span class="c1"></span><span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-117-populating-next-right-pointers-in-each-node-ii">LeetCode 117. Populating Next Right Pointers in Each Node II<a hidden class="anchor" aria-hidden="true" href="#leetcode-117-populating-next-right-pointers-in-each-node-ii">#</a></h1>
<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<p>You may only use constant extra space. <br>
For example,  <br>
Given the following binary tree,</p>
<pre><code>    1
   /  \
  2    3
 / \    \
4   5    7
</code></pre>
<p>After calling your function, the tree should look like:</p>
<pre><code>    1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL
</code></pre>
<p>解析：本题不限制一定是完全二叉树，需要判断子节点情况，而且当前层的节点情况不能根据上一层的链表直接推出来，所以tempchild和currentchild都保存的是当前层的链表信息来辅助维护。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for binary tree with next pointer.
</span><span class="cm"> * struct TreeLinkNode {
</span><span class="cm"> *  int val;
</span><span class="cm"> *  TreeLinkNode *left, *right, *next;
</span><span class="cm"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">connect</span><span class="p">(</span><span class="n">TreeLinkNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">TreeLinkNode</span> <span class="o">*</span><span class="n">tempChild</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TreeLinkNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">//当前层的横向链表头，因为无法简单判断出当前层是否为空和头节点到底在哪里，所以需要先创建伪头节点
</span><span class="c1"></span>        <span class="n">TreeLinkNode</span> <span class="o">*</span><span class="n">currentChild</span> <span class="o">=</span> <span class="n">tempChild</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">root</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span><span class="c1">//根节点按层遍历
</span><span class="c1"></span>            <span class="c1">//左孩子
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> 
            <span class="p">{</span> 
                <span class="n">currentChild</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> 
                <span class="n">currentChild</span> <span class="o">=</span> <span class="n">currentChild</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//右孩子
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> 
            <span class="p">{</span> 
            <span class="n">currentChild</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span> 
            <span class="n">currentChild</span> <span class="o">=</span> <span class="n">currentChild</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">tempChild</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//下一层的起点
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-199-binary-tree-right-side-view">LeetCode 199. Binary Tree Right Side View<a hidden class="anchor" aria-hidden="true" href="#leetcode-199-binary-tree-right-side-view">#</a></h1>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example: <br>
Given the following binary tree,</p>
<pre><code>   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</code></pre>
<p>You should return [1, 3, 4].</p>
<p>解析：只返回最右侧的节点，可以将先序遍历改一下，右孩子优先，DFS扫描得到结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm">     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">recursion</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span><span class="c1">//先序遍历（右孩子优先）
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span><span class="c1">//当前结点不存在，递归终止条件
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">level</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span><span class="c1">//如果当前层的节点还没放入答案
</span><span class="c1"></span>    <span class="n">recursion</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="n">recursion</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span> 
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">recursion</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/dfs/">DFS</a></li>
      <li><a href="/tags/tree/">Tree</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
