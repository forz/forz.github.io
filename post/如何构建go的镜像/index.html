<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>如何构建Go的镜像 | Forz Blog</title>
<meta name="keywords" content="docker, go" />
<meta name="description" content="示例应用 首先贴出代码例子，我们假设要构建一个 http 服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/gin-gonic/gin&#34; ) func main() { fmt.Println(&#34;Server Ready&#34;) router :=">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="如何构建Go的镜像" />
<meta property="og:description" content="示例应用 首先贴出代码例子，我们假设要构建一个 http 服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/gin-gonic/gin&#34; ) func main() { fmt.Println(&#34;Server Ready&#34;) router :=" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-12T23:33:43&#43;00:00" />
<meta property="article:modified_time" content="2021-03-12T23:33:43&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何构建Go的镜像"/>
<meta name="twitter:description" content="示例应用 首先贴出代码例子，我们假设要构建一个 http 服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/gin-gonic/gin&#34; ) func main() { fmt.Println(&#34;Server Ready&#34;) router :="/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "如何构建Go的镜像",
      "item": "/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何构建Go的镜像",
  "name": "如何构建Go的镜像",
  "description": "示例应用 首先贴出代码例子，我们假设要构建一个 http 服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { fmt.Println(\u0026#34;Server Ready\u0026#34;) router :=",
  "keywords": [
    "docker", "go"
  ],
  "articleBody": "示例应用 首先贴出代码例子，我们假设要构建一个 http 服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \"fmt\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" ) func main() { fmt.Println(\"Server Ready\") router := gin.Default() router.GET(\"/\", func(c *gin.Context) { c.String(200, \"hello world, this time is: \"+time.Now().Format(time.RFC1123Z)) }) router.GET(\"/github\", func(c*gin.Context) { _, err := http.Get(\"https://api.github.com/\") if err != nil { c.String(500, err.Error()) return } c.String(200, \"access github api ok\") }) if err := router.Run(\":9900\"); err != nil { panic(err) } }   说明：\n 这里选择 Gin 作为例子，是为了演示我们有第三方包条件下要优化构建速度 main函数第一行打印了一行字，为了演示后面启动时遇到的一个坑 跟路由打印了时间，为了演示后面遇到的关于时区的坑 路由 github 尝试访问 https://api.github.com，为了演示后面遇到的证书坑  这里我们可以先试一试构建后包的体积\n1 2 3  $ go build -o server $ ls -alh | grep server -rwxrwxrwx 1 eyas eyas 14.6M May 29 10:26 server   14.6MB，这是一个http服务的 hello world，当然这是因为使用了 gin ，所以有些大，如果用标准包 net/http 写的 hello world，体积大概是接近 7 MB\n多阶段构建 要想大幅度减少镜像的体积，多阶段构建是必不可少的。多阶段构建的想法很简单：“我不想在最终的镜像中包含一堆 C 或 Go 编译器和整个编译工具链，我只要一个编译好的可执行文件！”\n多阶段构建可以由多个 FROM 指令识别，每一个 FROM 语句表示一个新的构建阶段，阶段名称可以用 AS 参数指定，例如：\n1 2 3 4 5 6  FROM gcc AS mybuildstage COPY hello.c . RUN gcc -o hello hello.c FROM ubuntu COPY --from=mybuildstage hello . CMD [\"./hello\"]   本例使用基础镜像 gcc 来编译程序 hello.c，然后启动一个新的构建阶段，它以 ubuntu 作为基础镜像，将可执行文件 hello 从上一阶段拷贝到最终的镜像中。最终的镜像大小是 64 MB，比之前的 1.1 GB 减少了 95%：\n1 2 3 4  → docker images minimage REPOSITORY TAG ... SIZE minimage hello-c.gcc ... 1.14GB minimage hello-c.gcc.ubuntu ... 64.2MB   还能不能继续优化？当然能。在继续优化之前，先提醒一下：\n在声明构建阶段时，可以不必使用关键词 AS，最终阶段拷贝文件时可以直接使用序号表示之前的构建阶段（从零开始）。也就是说，下面两行是等效的：\n1 2  COPY --from=mybuildstage hello . COPY --from=0 hello .   如果 Dockerfile 内容不是很复杂，构建阶段也不是很多，可以直接使用序号表示构建阶段。一旦 Dockerfile 变复杂了，构建阶段增多了，最好还是通过关键词 AS 为每个阶段命名，这样也便于后期维护。\n使用经典的基础镜像 我强烈建议在构建的第一阶段使用经典的基础镜像，这里经典的镜像指的是 CentOS，Debian，Fedora 和 Ubuntu 之类的镜像。你可能还听说过 Alpine 镜像，不要用它！至少暂时不要用，后面我会告诉你有哪些坑。\nCOPY –from 使用绝对路径 从上一个构建阶段拷贝文件时，使用的路径是相对于上一阶段的根目录的。如果你使用 golang 镜像作为构建阶段的基础镜像，就会遇到类似的问题。假设使用下面的 Dockerfile 来构建镜像：\n1 2 3 4 5 6  FROM golang COPY hello.go . RUN go build hello.go FROM ubuntu COPY --from=0 hello . CMD [\"./hello\"]   你会看到这样的报错：\n1  COPY failed: stat /var/lib/docker/overlay2/1be...868/merged/hello: no such file or directory   这是因为 COPY 命令想要拷贝的是 /hello，而 golang 镜像的 WORKDIR 是 /go，所以可执行文件的真正路径是 /go/hello。\n当然你可以使用绝对路径来解决这个问题，但如果后面基础镜像改变了 WORKDIR 怎么办？你还得不断地修改绝对路径，所以这个方案还是不太优雅。最好的方法是在第一阶段指定 WORKDIR，在第二阶段使用绝对路径拷贝文件，这样即使基础镜像修改了 WORKDIR，也不会影响到镜像的构建。例如：\n1 2 3 4 5 6 7  FROM golang WORKDIR /src COPY hello.go . RUN go build hello.go FROM ubuntu COPY --from=0 /src/hello . CMD [\"./hello\"]   最后的效果还是很惊人的，将镜像的体积直接从 800 MB 降低到了 66 MB：\n→ docker images minimage REPOSITORY TAG … SIZE minimage hello-go.golang … 805MB minimage hello-go.golang.ubuntu-workdir … 66.2MB\n初步优化 先看看第一个版本\n1 2 3 4 5 6 7 8 9 10 11 12  FROM golang:1.14-alpine as builder WORKDIR /usr/src/app ENV GOPROXY=https://goproxy.cn COPY ./go.mod ./ COPY ./go.sum ./ RUN go mod download COPY . . RUN go build -ldflags \"-s -w\" -o server FROM scratch as runner COPY --from=builder /usr/src/app/server /opt/app/ CMD [\"/opt/app/server\"]   说明：\n 选择 golang:1.14-alpine 作为编译环境，是因为这是体积最小的golang编译环境 设置 GOPROXY 是为了提升构建速度 先复制 go.mod 和 go.sum ，然后 go mod download，是为了防止每次构建都会重新下载依赖包，利用docker构建缓存提升构建速度 go build 时加上 -ldflags “-s -w” 去除构建包的调试信息，减小go构建后程序体积，大概能减小 1/4 吧  -s: 省略符号表和调试信息 -w: 省略DWARF符号表   使用了多阶段构建，也就是 FROM XXX as xxx ，在构建程序包的时候，使用带编译环境的镜像去构建，运行的时候其实完全不需要go的编译环境，所以在运行阶段使用docker的空镜像 scratch 去运行。这部是减小镜像体积最有效的方法了。  好了，下面开始构建镜像\n1 2 3 4  $ docker build -t server . ... Successfully built 8d3b91210721 Successfully tagged server:latest   到了这一步，构建成功，看看镜像大小\n1 2  $ docker images server latest 8d3b91210721 1 minutes ago 11MB   11MB，还行，现在运行一下\n1 2  $ docker run -p 9900:9900 server standard_init_linux.go:211: exec user process caused \"no such file or directory\"   发现启动报错了，而且main函数的第一行打印语句都没有出现，所以整个程序完全没有运行。错误原因是缺少库依赖文件。这其实是构建的 go 程序还依赖底层的 so 库文件，不信可以在物理机编译后看看它的依赖\n1 2 3 4 5 6  $ go build -o server $ ldd server linux-vdso.so.1 (0x00007ffcfb775000) libpthread.so.0 = /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f9a8dc47000) libc.so.6 = /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a8d856000) /lib64/ld-linux-x86-64.so.2 (0x00007f9a8de66000)   这是不是跟我们的认知有点出入呢，说好无依赖的呢，结果还是有几个依赖库文件呢，虽然这几个依赖都是最底层的，一般操作系统都会有，可谁叫我们选了 scratch，这个镜像里面除了linux内核以外真的什么都没了。\n这是因为go build 是默认启用 CGO 的，不信你可以试试这个命令 go env CGO_ENABLED，在 CGO 开启情况下，无论代码有没有用CGO，都会有库依赖文件，解决方法也很简单，手动指定关闭CGO就行，而且包体积并不会增加哦，还会减少呢\n1 2 3  $ CGO_ENABLED=0 go build -o server $ ldd server not a dynamic executable   Go 语言程序编译时会将所有必须的依赖编译到二进制文件中，但也不能完全肯定它使用的是静态链接，因为 Go 的某些包是依赖系统标准库的，例如使用到 DNS 解析的包。只要代码中导入了这些包，编译的二进制文件就需要调用到某些系统库，为了这个需求，Go 实现了一种机制叫 cgo，以允许 Go 调用 C 代码，这样编译好的二进制文件就可以调用系统库。\n也就是说，如果 Go 程序使用了 net 包，就会生成一个动态的二进制文件，如果想让镜像能够正常工作，必须将需要的库文件复制到镜像中，或者直接使用 busybox:glibc 镜像。\n当然，你也可以禁止 cgo，这样 Go 就不会使用系统库，使用内置的实现来替代系统库（例如使用内置的 DNS 解析器），这种情况下生成的二进制文件就是静态的。可以通过设置环境变量 CGO_ENABLED=0 来禁用 cgo，例如：\n1 2 3 4 5 6 7 8  FROM golang COPY whatsmyip.go . ENV CGO_ENABLED=0 RUN go build whatsmyip.go FROM scratch COPY --from=0 /go/whatsmyip . CMD [\"./whatsmyip\"]   由于编译生成的是静态二进制文件，因此可以直接跑在 scratch 镜像中\n当然，也可以不用完全禁用 cgo，可以通过 -tags 参数指定需要使用的内建库，例如 -tags netgo 就表示使用内建的 net 包，不依赖系统库：\n1  go build -tags netgo whatsmyip.go   这样指定之后，如果导入的其他包都没有用到系统库，那么编译得到的就是静态二进制文件。也就是说，只要还有一个包用到了系统库，都会开启 cgo，最后得到的就是动态二进制文件。要想一劳永逸，还是设置环境变量 CGO_ENABLED=0 吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13  FROM golang:1.14-alpine as builder WORKDIR /usr/src/app ENV GOPROXY=https://goproxy.cn COPY ./go.mod ./ COPY ./go.sum ./ RUN go mod download COPY . . -RUN go build -ldflags \"-s -w\" -o server +RUN CGO_ENABLED=0 go build -ldflags \"-s -w\" -o server FROM scratch as runner COPY --from=builder /usr/src/app/server /opt/app/ CMD [\"/opt/app/server\"]   改动点: go build 前加了 CGO_ENABLED=0\n1 2 3 4 5 6 7 8  $ docker build -t server . ... Successfully built a81385160e25 Successfully tagged server:latest $ docker run -p 9900:9900 server [GIN-debug] GET / -- main.main.func1 (3 handlers) [GIN-debug] GET /github -- main.main.func2 (3 handlers) [GIN-debug] Listening and serving HTTP on :9900   scratch解决运行环境时区与证书问题 正常启动了，我们访问一下试试，访问之前看看当前时间\n1 2 3 4 5 6 7 8  $ date Fri May 29 13:11:28 CST 2020 $ curl http://localhost:9900 hello world, this time is: Fri, 29 May 2020 05:18:28 +0000 $ curl http://localhost:9900/github Get \"https://api.github.com/\": x509: certificate signed by unknown authority   发现有问题\n 当前系统时间是 13:11:28 ，但是根据由显示的时间是 05:11:53，其实是docker 容器内的时区不对，默认是 0 时区，可是我们国家是 东8区 尝试访问 https://api.github.com/ 这是 https 站点，报证书错误  解决问题\n 在容器放置根证书 设置容器时区  原因在于 scratch 镜像并不包含任何 时区信息 ，我们需要从本地系统中复制一份。\n由于 scratch 镜像几乎不包含任何东西，甚至没有 mkdir 命令。 因此，我们需要对时区信息进行打包，然后再通过 ADD 指令进行添加，以此绕过目录创建：\n1 2  $ tar -chzf zoneinfo.tar.gz /usr/share/zoneinfo tar: Removing leading '/' from member names   这时，时区信息问题已经解决了，但是发起 HTTPS 请求还存在问题， 原因是 scratch 镜像不包含任何 SSL CA 证书。\n接下来，从 https://curl.haxx.se/docs/caextract.html 下载 CA 证书：\n1  curl -o cacert.pem https://curl.haxx.se/ca/cacert.pem   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  FROM golang:1.14-alpine as builder WORKDIR /usr/src/app ENV GOPROXY=https://goproxy.cn +RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories \u0026\u0026 \\ * apk add --no-cache ca-certificates tzdata COPY ./go.mod ./ COPY ./go.sum ./ RUN go mod download COPY . . RUN CGO_ENABLED=0 go build -ldflags \"-s -w\" -o server FROM scratch as runner +COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime +COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ COPY --from=builder /usr/src/app/server /opt/app/ CMD [\"/opt/app/server\"]   在 builder 阶段，安装了 ca-certificates tzdata 两个库，在runner阶段，将时区配置和根证书复制了一份\n1 2 3 4 5 6 7 8  $ docker build -t server . ... Successfully built e0825838043d Successfully tagged server:latest $ docker run -p 9900:9900 server [GIN-debug] GET / -- main.main.func1 (3 handlers) [GIN-debug] GET /github -- main.main.func2 (3 handlers) [GIN-debug] Listening and serving HTTP on :9900   访问一下试试\n1 2 3 4 5 6 7 8  $ date Fri May 29 13:27:16 CST 2020 $ curl http://localhost:9900 hello world, this time is: Fri, 29 May 2020 13:27:16 +0800 $ curl http://localhost:9900/github access github api ok   一切正常了，看看当前镜像大小\n1 2  $ docker images server latest e0825838043d 9 minutes ago 11.3MB   才 11.3MB，已经很小了，但是，还可以更小，就是把构建后的包再压缩一次\nupx进一步减小体积 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  FROM golang:1.14-alpine as builder WORKDIR /usr/src/app ENV GOPROXY=https://goproxy.cn RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories \u0026\u0026 \\ * apk add --no-cache ca-certificates tzdata * apk add --no-cache upx ca-certificates tzdata COPY ./go.mod ./ COPY ./go.sum ./ RUN go mod download COPY . . -RUN CGO_ENABLED=0 go build -ldflags \"-s -w\" -o server +RUN CGO_ENABLED=0 go build -ldflags \"-s -w\" -o server \u0026\u0026\\ * upx --best server -o _upx_server \u0026\u0026 \\ * mv -f _upx_server server FROM scratch as runner COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ COPY --from=builder /usr/src/app/server /opt/app/ CMD [\"/opt/app/server\"]   在 builder 阶段，安装了 upx ，并且go build 完成后，使用 upx 压缩了一下，执行一下构建，你会发现这个构建时间变长了，这是因为我给 upx 设置的参数是 –best ，也就是最大压缩级别，这样压缩出来的后会尽可能的小，如果嫌慢，可以降低压缩级别从 -1 到 -9 ，数字越大压缩级别越高，也越慢。我使用 –best 构建完成后看看镜像体积。\n1 2 3 4 5 6  $ docker build -t server . ... Successfully built 80c3f3cde1f7 Successfully tagged server:latest $ docker images server latest 80c3f3cde1f7 1 minutes ago 4.26MB   这下子可小了，才 4.26MB，再去试试那两个接口，一切正常。优化到此结束。\n最终的Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  FROM golang:1.14-alpine as builder WORKDIR /usr/src/app ENV GOPROXY=https://goproxy.cn RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories \u0026\u0026 \\ apk add --no-cache upx ca-certificates tzdata COPY ./go.mod ./ COPY ./go.sum ./ RUN go mod download COPY . . RUN CGO_ENABLED=0 go build -ldflags \"-s -w\" -o server \u0026\u0026\\ upx --best server -o_upx_server \u0026\u0026 \\ mv -f_upx_server server FROM scratch as runner COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ COPY --from=builder /usr/src/app/server /opt/app/ CMD [\"/opt/app/server\"]   scratch 回到我们的 hello world，C 语言版本的程序大小为 16 kB，Go 语言版本的程序大小为 2 MB，那么我们到底能不能将镜像缩减到这么小？能否构建一个只包含我需要的程序，没有任何多余文件的镜像？\n答案是肯定的，你只需要将多阶段构建的第二阶段的基础镜像改为 scratch 就好了。scratch 是一个虚拟镜像，不能被 pull，也不能运行，因为它表示空、nothing！这就意味着新镜像的构建是从零开始，不存在其他的镜像层。例如：\n1 2 3 4 5 6  FROM golang COPY hello.go . RUN go build hello.go FROM scratch COPY --from=0 /go/hello . CMD [\"./hello\"]   这一次构建的镜像大小正好就是 2 MB，堪称完美！\n然而，但是，使用 scratch 作为基础镜像时会带来很多的不便，且听我一一道来。\n缺少 shell scratch 镜像的第一个不便是没有 shell，这就意味着 CMD/RUN 语句中不能使用字符串，例如：\n1 2 3 4  ... FROM scratch COPY --from=0 /go/hello . CMD ./hello   如果你使用构建好的镜像创建并运行容器，就会遇到下面的报错：\n1  docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused \"exec: \\\"/bin/sh\\\": stat /bin/sh: no such file or directory\": unknown.   从报错信息可以看出，镜像中并不包含 /bin/sh，所以无法运行程序。这是因为当你在 CMD/RUN 语句中使用字符串作为参数时，这些参数会被放到 /bin/sh 中执行，也就是说，下面这两条语句是等效的：\n1 2  CMD ./hello CMD /bin/sh -c \"./hello\"   解决办法其实也很简单：使用 JSON 语法取代字符串语法。例如，将 CMD ./hello 替换为 CMD [\"./hello\"]，这样 Docker 就会直接运行程序，不会把它放到 shell 中运行。\n缺少调试工具 scratch 镜像不包含任何调试工具，ls、ps、ping 这些统统没有，当然了，shell 也没有（上文提过了），你无法使用 docker exec 进入容器，也无法查看网络堆栈信息等等。\n如果想查看容器中的文件，可以使用 docker cp；如果想查看或调试网络堆栈，可以使用 docker run –net container:，或者使用 nsenter；为了更好地调试容器，Kubernetes 也引入了一个新概念叫 Ephemeral Containers，但现在还是 Alpha 特性。\n虽然有这么多杂七杂八的方法可以帮助我们调试容器，但它们会将事情变得更加复杂，我们追求的是简单，越简单越好。\n折中一下可以选择 busybox 或 alpine 镜像来替代 scratch，虽然它们多了那么几 MB，但从整体来看，这只是牺牲了少量的空间来换取调试的便利性，还是很值得的。\n缺少 libc 这是最难解决的问题。使用 scratch 作为基础镜像时，Go 语言版本的 hello world 跑得很欢快，C 语言版本就不行了，或者换个更复杂的 Go 程序也是跑不起来的（例如用到了网络相关的工具包），你会遇到类似于下面的错误：\n1  standard_init_linux.go:211: exec user process caused \"no such file or directory\"   从报错信息可以看出缺少文件，但没有告诉我们到底缺少哪些文件，其实这些文件就是程序运行所必需的动态库（dynamic library）。\n那么，什么是动态库？为什么需要动态库？\n所谓动态库、静态库，指的是程序编译的链接阶段，链接成可执行文件的方式。静态库指的是在链接阶段将汇编生成的目标文件.o 与引用到的库一起链接打包到可执行文件中，因此对应的链接方式称为静态链接（static linking）。而动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此对应的链接方式称为动态链接（dynamic linking）。\n90 年代的程序大多使用的是静态链接，因为当时的程序大多数都运行在软盘或者盒式磁带上，而且当时根本不存在标准库。这样程序在运行时与函数库再无瓜葛，移植方便。但对于 Linux 这样的分时系统，会在在同一块硬盘上并发运行多个程序，这些程序基本上都会用到标准的 C 库，这时使用动态链接的优点就体现出来了。使用动态链接时，可执行文件不包含标准库文件，只包含到这些库文件的索引。例如，某程序依赖于库文件 libtrigonometry.so 中的 cos 和 sin 函数，该程序运行时就会根据索引找到并加载 libtrigonometry.so，然后程序就可以调用这个库文件中的函数。\n使用动态链接的好处显而易见：\n 节省磁盘空间，不同的程序可以共享常见的库。 节省内存，共享的库只需从磁盘中加载到内存一次，然后在不同的程序之间共享。 更便于维护，库文件更新后，不需要重新编译使用该库的所有程序。  严格来说，动态库与共享库（shared libraries）相结合才能达到节省内存的功效。Linux 中动态库的扩展名是 .so（ shared object），而 Windows 中动态库的扩展名是 .DLL（Dynamic-link library）。\n回到最初的问题，默认情况下，C 程序使用的是动态链接，Go 程序也是。上面的 hello world 程序使用了标准库文件 libc.so.6，所以只有镜像中包含该文件，程序才能正常运行。使用 scratch 作为基础镜像肯定是不行的，使用 busybox 和 alpine 也不行，因为 busybox 不包含标准库，而 alpine 使用的标准库是 musl libc，与大家常用的标准库 glibc 不兼容，后续的文章会详细解读，这里就不赘述了。\n那么该如何解决标准库的问题呢？有三种方案。\n1、使用静态库 我们可以让编译器使用静态库编译程序，办法有很多，如果使用 gcc 作为编译器，只需加上一个参数 -static：\n1  gcc -o hello hello.c -static   编译完的可执行文件大小为 760 kB，相比于之前的 16kB 是大了好多，这是因为可执行文件中包含了其运行所需要的库文件。编译完的程序就可以跑在 scratch 镜像中了。\n如果使用 alpine 镜像作为基础镜像来编译，得到的可执行文件会更小（2、拷贝库文件到镜像中 为了找出程序运行需要哪些库文件，可以使用 ldd 工具：\n1 2 3 4  $ ldd hello linux-vdso.so.1 (0x00007ffdf8acb000) libc.so.6 = /usr/lib/libc.so.6 (0x00007ff897ef6000) /lib64/ld-linux-x86-64.so.2 = /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff8980f7000)   从输出结果可知，该程序只需要 libc.so.6 这一个库文件。linux-vdso.so.1 与一种叫做 VDSO 的机制有关，用来加速某些系统调用，可有可无。ld-linux-x86-64.so.2 表示动态链接器本身，包含了所有依赖的库文件的信息。\n你可以选择将 ldd 列出的所有库文件拷贝到镜像中，但这会很难维护，特别是当程序有大量依赖库时。对于 hello world 程序来说，拷贝库文件完全没有问题，但对于更复杂的程序（例如使用到 DNS 的程序），就会遇到令人费解的问题：glibc（GNU C library）通过一种相当复杂的机制来实现 DNS，这种机制叫 NSS（Name Service Switch, 名称服务开关）。它需要一个配置文件 /etc/nsswitch.conf 和额外的函数库，但使用 ldd 时不会显示这些函数库，因为这些库在程序运行后才会加载。如果想让 DNS 解析正确工作，必须要拷贝这些额外的库文件（/lib64/libnss_*）。\n我个人不建议直接拷贝库文件，因为它非常难以维护，后期需要不断地更改，而且还有很多未知的隐患。\n3、使用 busybox:glibc 作为基础镜像 有一个镜像可以完美解决所有的这些问题，那就是 busybox:glibc。它只有 5 MB 大小，并且包含了 glibc 和各种调试工具。如果你想选择一个合适的镜像来运行使用动态链接的程序，busybox:glibc 是最好的选择。\n注意：如果你的程序使用到了除标准库之外的库，仍然需要将这些库文件拷贝到镜像中。\nAlpine Alpine 是众多 Linux 发行版中的一员，和 CentOS、Ubuntu、Archlinux 之类一样，只是一个发行版的名字，号称小巧安全，有自己的包管理工具 apk。\n与 CentOS 和 Ubuntu 不同，Alpine 并没有像 Red Hat 或 Canonical 之类的大公司为其提供维护支持，软件包的数量也比这些发行版少很多（如果只看开箱即用的默认软件仓库，Alpine 只有 10000 个软件包，而 Ubuntu、Debian 和 Fedora 的软件包数量均大于 50000。）\n容器崛起之前，Alpine 还是个无名之辈，可能是因为大家并不是很关心操作系统本身的大小，毕竟大家只关心业务数据和文档，程序、库文件和系统本身的大小通常可以忽略不计。\n容器技术席卷整个软件产业之后，大家都注意到了一个问题，那就是容器的镜像太大了，浪费磁盘空间，拉取镜像的时间也很长。于是，人们开始寻求适用于容器的更小的镜像。对于那些耳熟能详的发行版（例如 Ubuntu、Debian、Fedora）来说，只能通过删除某些工具（例如 ifconfig 和 netstat）将镜像体积控制在 100M 以下。而对于 Alpine 而言，什么都不用删除，镜像大小也就只有 5M 而已。\nAlpine 镜像的另一个优势是包管理工具的执行速度非常快，安装软件体验非常顺滑。诚然，在传统的虚拟机上不需要太关心软件包的安装速度，同一个包只需要装一次即可，无需不停重复安装。容器就不一样了，你可能会定期构建新镜像，也可能会在运行的容器中临时安装某些调试工具，如果软件包的安装速度很慢，会很快消磨掉我们的耐心。\n为了更直观，我们来做个简单的对比测试，看看不同的发行版安装 tcpdump 需要多长时间，测试命令如下：\n1  🐳 → time docker run image packagemanager install tcpdump   测试结果如下：\n1 2 3 4 5 6 7 8 9  Base image Size Time to install tcpdump --------------------------------------------------------- alpine:3.11 5.6 MB 1-2s archlinux:20200106 409 MB 7-9s centos:8 237 MB 5-6s debian:10 114 MB 5-7s fedora:31 194 MB 35-60s ubuntu:18.04 64 MB 6-8s   如果你想了解更多关于 Alpine 的内幕，可以看看 Natanel Copa 的演讲。\n好吧，既然 Alpine 这么棒，为什么不用它作为所有镜像的基础镜像呢？别急，先一步一步来，为了趟平所有的坑，需要分两种情况来考虑：\n 使用 Alpine 作为第二构建阶段（run 阶段）的基础镜像 使用 ALpine 作为所有构建阶段（run 阶段和 build 阶段）的基础镜像  run 阶段使用 Alpine 带着激动的心情，将 Alpine 镜像加入了 Dockerfile：\n1 2 3 4 5 6 7  FROM gcc AS mybuildstage COPY hello.c . RUN gcc -o hello hello.c FROM alpine COPY --from=mybuildstage hello . CMD [\"./hello\"]   第一个坑来了，启动容器出现了错误：\n1  standard_init_linux.go:211: exec user process caused \"no such file or directory\"   这个报错在上篇文章已经见识过了，上篇文章的场景是使用 scratch 镜像作为 C 语言程序的基础镜像，错误的原因是 scratch 镜像中缺少动态库文件。可是为什么使用 Alpine 镜像也有报错，难道它也缺少动态库文件？\n也不完全是，Alpine 使用的也是动态库，毕竟它的设计目标之一就是占用更少的空间。但 Alpine 使用的标准库与大多数发行版不同，它使用的是 musl libc，这个库相比于 glibc 更小、更简单、更安全，但是与大家常用的标准库 glibc 并不兼容。\n你可能又要问了：『既然 musl libc 更小、更简单，还特么更安全，为啥其他发行版还在用 glibc？』\n因为 glibc 有很多额外的扩展，并且很多程序都用到了这些扩展，而 musl libc 是不包含这些扩展的。详情可以参考 musl 的文档。\n也就是说，如果想让程序跑在 Alpine 镜像中，必须在编译时使用 musl libc 作为动态库。\n所有阶段使用 Alpine 为了生成一个与 musl libc 链接的二进制文件，有两条路：\n 某些官方镜像提供了 Alpine 版本，可以直接拿来用。 还有些官方镜像没有提供 Alpine 版本，我们需要自己构建。  golang 镜像就属于第一种情况，golang:alpine 提供了基于 Alpine 构建的 Go 工具链。\n构建 Go 程序可以使用下面的 Dockerfile：\n1 2 3 4 5 6 7  FROM golang:alpine COPY hello.go . RUN go build hello.go FROM alpine COPY --from=0 /go/hello . CMD [\"./hello\"]   生成的镜像大小为 7.5M，对于一个只打印 『hello world』的程序来说确实有点大了，但我们可以换个角度：\n 即使程序很复杂，生成的镜像也不会很大。 包含了很多有用的调试工具。 即使运行时缺少某些特殊的调试工具，也可以迅速安装。  Go 语言搞定了，C 语言呢？并没有 gcc:alpine 这样的镜像啊。只能以 Alpine 镜像作为基础镜像，自己安装 C 编译器了，Dockerfile 如下：\n1 2 3 4 5 6 7 8  FROM alpine RUN apk add build-base COPY hello.c . RUN gcc -o hello hello.c FROM alpine COPY --from=0 hello . CMD [\"./hello\"]   必须安装 build-base，如果安装 gcc，就只有编译器，没有标准库。build-base 相当于 Ubuntu 的 build-essentials，引入了编译器、标准库和 make 之类的工具。\n最后来对比一下不同构建方法得到的 『hello world』镜像大小：\n  使用基础镜像 golang 构建：805MB\n  多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 ubuntu：66.2MB\n  多阶段构建，build 阶段使用基础镜像 golang:alpine，run 阶段使用基础镜像 alpine：7.6MB\n  多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 scratch：2MB\n  最终镜像体积减少了 99.75%，相当惊人了。再来看一个更实际的例子，上一节提到的使用 net 的程序，最终的镜像大小对比：\n 使用基础镜像 golang 构建：810MB 多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 ubuntu：71.2MB 多阶段构建，build 阶段使用基础镜像 golang:alpine，run 阶段使用基础镜像 alpine：12.6MB 多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 busybox:glibc：12.2MB 多阶段构建，build 阶段使用基础镜像 golang 并使用参数 CGO_ENABLED=0，run 阶段使用基础镜像 ubuntu：7MB 镜像体积仍然减少了 99%。  建议选择alpile 要减小镜像体积，首先多阶段构建这很重要，这样就可以把编译环境和运行环境分开。\n另外，选择 scratch 这个镜像其实很不明智，它虽然很小，但是它太原始了，里面什么工具都没有，程序启动后，连容器都进不去，就算进去了什么都做不了。所以就算一昧的追求尽可能小的镜像体积，也不建议选择 scratch 作为运行环境，我暂时只踩到小部分的坑，后面还有更多坑没踩，我也没有兴趣继续踩 scratch 的坑。\n建议选择 alpine ，alpine 的镜像大小是 5.61MB 这个大小其实还是镜像解压后的大小，实际上下载镜像的时候，只需要下载 2.68 MB 。还有，上文所有我说的镜像体积，全都是指解压后的镜像体积，和实际上传下载时的体积是不一样的，docker自己会压缩一次再传输镜像 还有个很小的镜像是 busybox，它的体积是 1.22MB，下载 705.6 KB ，有大部分的linux命令可用，但是运行环境还是很原始，有兴趣可以去尝试\n无论是 alpine 还是 busybox ，他们都会上述时区和证书问题，同样按照上面方法就能解决，切换到 alpine 或者 busybox 也很简单，只需要修改 runner 基础镜像就行\n1 2  -FROM scratch as runner +FROM alpine as runner   或者\n1 2  -FROM scratch as runner +FROM busybox as runne   最终版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  FROM golang:1.13.5-alpine3.10 AS builder WORKDIR /build RUN adduser -u 10001 -D app-runner ENV GOPROXY https://goproxy.cn COPY go.mod . COPY go.sum . RUN go mod download COPY . . RUN CGO_ENABLED=0 GOARCH=amd64 GOOS=linux go build -a -o your-application .  FROM alpine:3.10 AS final RUN apk update --no-cache \u0026\u0026 apk add --no-cache ca-certificates tzdata ENV TZ Asia/Shanghai WORKDIR /app COPY --from=builder /build/your-application /app/ COPY --from=builder /etc/passwd /etc/passwd USER app-runner ENTRYPOINT [\"/app/your-application\"]   首先，这个dockerfile分为builder和final两部分。\nbuilder选择了golang:1.13.5-alpine3.10作为编译的基础镜像，相比于golang:1.13, 一方面是因为它体积更小，另一方面是我发现golang:1.13的编译结果，在alpine:3.10中会报not found的错误，虽说有人提供了其它的解决方案，但是能直接避免，为啥不避免呢。\n1  RUN adduser -u 10001 -D app-runner   接着是创建了一个app-runner的用户, -D表示无密码。 此用户的信息是是需要拷到final中，作为应用程序的启动用户。这是为了避免使用container中的默认用户root，那可是有安全漏洞的，详细解释，可以参考这篇medium上的文章Processes In Containers Should Not Run As Root 再下面的四行，\n1 2 3 4  ENV GOPROXY https://goproxy.cn COPY go.mod . COPY go.sum . RUN go mod download   是配置了国内的代理，安装依赖包了。这里用go mod download的好处是下次构建镜像文件时，当go.mod和go.sum没有改变时，它是有缓存的，可以避免重复下载依赖包，加快构建。\nbuilder的最后，就是把当前目录的文件拷过去，编译代码了。\n1 2  COPY . . RUN CGO_ENABLED=0 GOARCH=amd64 GOOS=linux go build -a -o your-application .   final选择了alpine:3.10,一方面是体积小，只有5m；另一方面也是和构建镜像的alpine版本保持一致。\n接下来几行没啥说的，就是把构建结果、配置文件（有的话）和用户的相关文件拷过去。\n下面的这步一定不要忘记了，\n1  USER app-runner   没有它，container启动时就是用root用户启动了!!! 如果被攻击了，那黑客可是就有root权限了（不要问我为啥会被攻击）。\n最后，设置一个ENTRYPOINT，完事!\n如果你程序的启动过程比较复杂，或者是要在启动时根据环境变量的值做不同的操作，那还是写个shell文件吧。\n参考 构建 Golang 应用最小 Docker 镜像 两个奇技淫巧，将 Docker 镜像体积减小 99% Docker 镜像制作教程：针对不同语言的精简策略 手把手教你写一个完美的Golang Dockerfile\n",
  "wordCount" : "10022",
  "inLanguage": "zh-cn",
  "datePublished": "2021-03-12T23:33:43Z",
  "dateModified": "2021-03-12T23:33:43Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAgo%E7%9A%84%E9%95%9C%E5%83%8F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      如何构建Go的镜像
    </h1>
    <div class="post-meta">March 12, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="示例应用">示例应用<a hidden class="anchor" aria-hidden="true" href="#示例应用">#</a></h2>
<p>首先贴出代码例子，我们假设要构建一个 http 服务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Server Ready&#34;</span><span class="p">)</span>
	<span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">&#34;hello world, this time is: &#34;</span><span class="o">+</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC1123Z</span><span class="p">))</span>
	<span class="p">})</span>
<span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/github&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;https://api.github.com/&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">&#34;access github api ok&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">router</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:9900&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>说明：</p>
<ul>
<li>这里选择 Gin 作为例子，是为了演示我们有第三方包条件下要优化构建速度</li>
<li>main函数第一行打印了一行字，为了演示后面启动时遇到的一个坑</li>
<li>跟路由打印了时间，为了演示后面遇到的关于时区的坑</li>
<li>路由 github 尝试访问 <a href="https://api.github.com">https://api.github.com</a>，为了演示后面遇到的证书坑</li>
</ul>
<p>这里我们可以先试一试构建后包的体积</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>
<span class="o">$</span> <span class="n">ls</span> <span class="o">-</span><span class="n">alh</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">server</span>
<span class="o">-</span><span class="n">rwxrwxrwx</span> <span class="m">1</span> <span class="n">eyas</span> <span class="n">eyas</span>  <span class="m">14.6</span><span class="n">M</span> <span class="n">May</span> <span class="m">29</span> <span class="m">10</span><span class="o">:</span><span class="m">26</span> <span class="n">server</span>
</code></pre></td></tr></table>
</div>
</div><p>14.6MB，这是一个http服务的 hello world，当然这是因为使用了 gin ，所以有些大，如果用标准包 net/http 写的 hello world，体积大概是接近 7 MB</p>
<h2 id="多阶段构建">多阶段构建<a hidden class="anchor" aria-hidden="true" href="#多阶段构建">#</a></h2>
<p>要想大幅度减少镜像的体积，多阶段构建是必不可少的。多阶段构建的想法很简单：“我不想在最终的镜像中包含一堆 C 或 Go 编译器和整个编译工具链，我只要一个编译好的可执行文件！”</p>
<p>多阶段构建可以由多个 FROM 指令识别，每一个 FROM 语句表示一个新的构建阶段，阶段名称可以用 AS 参数指定，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">gcc</span> <span class="n">AS</span> <span class="n">mybuildstage</span>
<span class="n">COPY</span> <span class="n">hello.c</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">hello.c</span>
<span class="n">FROM</span> <span class="n">ubuntu</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">mybuildstage</span> <span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>本例使用基础镜像 gcc 来编译程序 hello.c，然后启动一个新的构建阶段，它以 ubuntu 作为基础镜像，将可执行文件 hello 从上一阶段拷贝到最终的镜像中。最终的镜像大小是 64 MB，比之前的 1.1 GB 减少了 95%：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">  → <span class="n">docker</span> <span class="n">images</span> <span class="n">minimage</span>
<span class="n">REPOSITORY</span>          <span class="n">TAG</span>                    <span class="kc">...</span>         <span class="n">SIZE</span>
<span class="n">minimage</span>            <span class="n">hello</span><span class="o">-</span><span class="n">c.gcc</span>            <span class="kc">...</span>         <span class="m">1.14</span><span class="n">GB</span>
<span class="n">minimage</span>            <span class="n">hello</span><span class="o">-</span><span class="n">c.gcc.ubuntu</span>     <span class="kc">...</span>         <span class="m">64.2</span><span class="n">MB</span>
</code></pre></td></tr></table>
</div>
</div><p>还能不能继续优化？当然能。在继续优化之前，先提醒一下：</p>
<p>在声明构建阶段时，可以不必使用关键词 AS，最终阶段拷贝文件时可以直接使用序号表示之前的构建阶段（从零开始）。也就是说，下面两行是等效的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">mybuildstage</span> <span class="n">hello</span> <span class="n">.
</span><span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="n">hello</span> <span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><p>如果 Dockerfile 内容不是很复杂，构建阶段也不是很多，可以直接使用序号表示构建阶段。一旦 Dockerfile 变复杂了，构建阶段增多了，最好还是通过关键词 AS 为每个阶段命名，这样也便于后期维护。</p>
<h2 id="使用经典的基础镜像">使用经典的基础镜像<a hidden class="anchor" aria-hidden="true" href="#使用经典的基础镜像">#</a></h2>
<p>我强烈建议在构建的第一阶段使用经典的基础镜像，这里经典的镜像指的是 CentOS，Debian，Fedora 和 Ubuntu 之类的镜像。你可能还听说过 Alpine 镜像，不要用它！至少暂时不要用，后面我会告诉你有哪些坑。</p>
<h2 id="copy---from-使用绝对路径">COPY &ndash;from 使用绝对路径<a hidden class="anchor" aria-hidden="true" href="#copy---from-使用绝对路径">#</a></h2>
<p>从上一个构建阶段拷贝文件时，使用的路径是相对于上一阶段的根目录的。如果你使用 golang 镜像作为构建阶段的基础镜像，就会遇到类似的问题。假设使用下面的 Dockerfile 来构建镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span>
<span class="n">COPY</span> <span class="n">hello.go</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="n">hello.go</span>
<span class="n">FROM</span> <span class="n">ubuntu</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>你会看到这样的报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">COPY</span> <span class="n">failed</span><span class="o">:</span> <span class="n">stat</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">overlay2</span><span class="o">/</span><span class="m">1</span><span class="n">be...868</span><span class="o">/</span><span class="n">merged</span><span class="o">/</span><span class="n">hello</span><span class="o">:</span> <span class="n">no</span> <span class="n">such</span> <span class="n">file</span> <span class="n">or</span> <span class="n">directory</span>
</code></pre></td></tr></table>
</div>
</div><p>这是因为 COPY 命令想要拷贝的是 /hello，而 golang 镜像的 WORKDIR 是 /go，所以可执行文件的真正路径是 /go/hello。</p>
<p>当然你可以使用绝对路径来解决这个问题，但如果后面基础镜像改变了 WORKDIR 怎么办？你还得不断地修改绝对路径，所以这个方案还是不太优雅。最好的方法是在第一阶段指定 WORKDIR，在第二阶段使用绝对路径拷贝文件，这样即使基础镜像修改了 WORKDIR，也不会影响到镜像的构建。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">src</span>
<span class="n">COPY</span> <span class="n">hello.go</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="n">hello.go</span>
<span class="n">FROM</span> <span class="n">ubuntu</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>最后的效果还是很惊人的，将镜像的体积直接从 800 MB 降低到了 66 MB：</p>
<p>→ docker images minimage
REPOSITORY     TAG                              &hellip;    SIZE
minimage       hello-go.golang                  &hellip;    805MB
minimage       hello-go.golang.ubuntu-workdir   &hellip;    66.2MB</p>
<h2 id="初步优化">初步优化<a hidden class="anchor" aria-hidden="true" href="#初步优化">#</a></h2>
<p>先看看第一个版本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.14</span><span class="o">-</span><span class="n">alpine</span> <span class="n">as</span> <span class="n">builder</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">ENV</span> <span class="n">GOPROXY</span><span class="o">=&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span><span class="o">&gt;</span>
<span class="n">COPY</span> <span class="n">./go.mod</span> <span class="n">./</span>
<span class="n">COPY</span> <span class="n">./go.sum</span> <span class="n">./</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>
<span class="n">COPY</span> <span class="n">. .</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>

<span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">server</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;/opt/app/server&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>说明：</p>
<ul>
<li>选择 golang:1.14-alpine 作为编译环境，是因为这是体积最小的golang编译环境</li>
<li>设置 GOPROXY 是为了提升构建速度</li>
<li>先复制 go.mod 和 go.sum ，然后 go mod download，是为了防止每次构建都会重新下载依赖包，利用docker构建缓存提升构建速度</li>
<li>go build 时加上 -ldflags &ldquo;-s -w&rdquo; 去除构建包的调试信息，减小go构建后程序体积，大概能减小 1/4 吧
<ul>
<li>-s: 省略符号表和调试信息</li>
<li>-w: 省略DWARF符号表</li>
</ul>
</li>
<li>使用了多阶段构建，也就是 FROM XXX as xxx ，在构建程序包的时候，使用带编译环境的镜像去构建，运行的时候其实完全不需要go的编译环境，所以在运行阶段使用docker的空镜像 scratch 去运行。这部是减小镜像体积最有效的方法了。</li>
</ul>
<p>好了，下面开始构建镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">server</span> <span class="n">.
</span><span class="n">...</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="m">8</span><span class="n">d3b91210721</span>
<span class="n">Successfully</span> <span class="n">tagged</span> <span class="n">server</span><span class="o">:</span><span class="n">latest</span>
</code></pre></td></tr></table>
</div>
</div><p>到了这一步，构建成功，看看镜像大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">images</span>
<span class="n">server</span>          <span class="n">latest</span>         <span class="m">8</span><span class="n">d3b91210721</span>      <span class="m">1</span> <span class="n">minutes</span> <span class="n">ago</span>        <span class="m">11</span><span class="n">MB</span>
</code></pre></td></tr></table>
</div>
</div><p>11MB，还行，现在运行一下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="m">9900</span><span class="o">:</span><span class="m">9900</span> <span class="n">server</span>
<span class="n">standard_init_linux.go</span><span class="o">:</span><span class="m">211</span><span class="o">:</span> <span class="n">exec</span> <span class="n">user</span> <span class="n">process</span> <span class="n">caused</span> <span class="s">&#34;no such file or directory&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>发现启动报错了，而且main函数的第一行打印语句都没有出现，所以整个程序完全没有运行。错误原因是缺少库依赖文件。这其实是构建的 go 程序还依赖底层的 so 库文件，不信可以在物理机编译后看看它的依赖</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>
<span class="o">$</span> <span class="n">ldd</span> <span class="n">server</span>
        <span class="n">linux</span><span class="o">-</span><span class="nf">vdso.so.1 </span><span class="p">(</span><span class="mh">0x00007ffcfb775000</span><span class="p">)</span>
        <span class="n">libpthread.so.0</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="nf">libpthread.so.0 </span><span class="p">(</span><span class="mh">0x00007f9a8dc47000</span><span class="p">)</span>
        <span class="n">libc.so.6</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="nf">libc.so.6 </span><span class="p">(</span><span class="mh">0x00007f9a8d856000</span><span class="p">)</span>
        <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="m">-64</span><span class="nf">.so.2 </span><span class="p">(</span><span class="mh">0x00007f9a8de66000</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这是不是跟我们的认知有点出入呢，说好无依赖的呢，结果还是有几个依赖库文件呢，虽然这几个依赖都是最底层的，一般操作系统都会有，可谁叫我们选了 scratch，这个镜像里面除了linux内核以外真的什么都没了。</p>
<p>这是因为go build 是默认启用 CGO 的，不信你可以试试这个命令 go env CGO_ENABLED，在 CGO 开启情况下，无论代码有没有用CGO，都会有库依赖文件，解决方法也很简单，手动指定关闭CGO就行，而且包体积并不会增加哦，还会减少呢</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>
<span class="o">$</span> <span class="n">ldd</span> <span class="n">server</span>
        <span class="n">not</span> <span class="n">a</span> <span class="n">dynamic</span> <span class="n">executable</span>
</code></pre></td></tr></table>
</div>
</div><p>Go 语言程序编译时会将所有必须的依赖编译到二进制文件中，但也不能完全肯定它使用的是静态链接，因为 Go 的某些包是依赖系统标准库的，例如使用到 DNS 解析的包。只要代码中导入了这些包，编译的二进制文件就需要调用到某些系统库，为了这个需求，Go 实现了一种机制叫 cgo，以允许 Go 调用 C 代码，这样编译好的二进制文件就可以调用系统库。</p>
<p>也就是说，如果 Go 程序使用了 net 包，就会生成一个动态的二进制文件，如果想让镜像能够正常工作，必须将需要的库文件复制到镜像中，或者直接使用 busybox:glibc 镜像。</p>
<p>当然，你也可以禁止 cgo，这样 Go 就不会使用系统库，使用内置的实现来替代系统库（例如使用内置的 DNS 解析器），这种情况下生成的二进制文件就是静态的。可以通过设置环境变量 CGO_ENABLED=0 来禁用 cgo，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span>
<span class="n">COPY</span> <span class="n">whatsmyip.go</span> <span class="n">.
</span><span class="n">ENV</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="n">whatsmyip.go</span>

<span class="n">FROM</span> <span class="n">scratch</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">whatsmyip</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./whatsmyip&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>由于编译生成的是静态二进制文件，因此可以直接跑在 scratch 镜像中</p>
<p>当然，也可以不用完全禁用 cgo，可以通过 -tags 参数指定需要使用的内建库，例如 -tags netgo 就表示使用内建的 net 包，不依赖系统库：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">tags</span> <span class="n">netgo</span> <span class="n">whatsmyip.go</span>
</code></pre></td></tr></table>
</div>
</div><p>这样指定之后，如果导入的其他包都没有用到系统库，那么编译得到的就是静态二进制文件。也就是说，只要还有一个包用到了系统库，都会开启 cgo，最后得到的就是动态二进制文件。要想一劳永逸，还是设置环境变量 CGO_ENABLED=0 吧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.14</span><span class="o">-</span><span class="n">alpine</span> <span class="n">as</span> <span class="n">builder</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">ENV</span> <span class="n">GOPROXY</span><span class="o">=&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span><span class="o">&gt;</span>
<span class="n">COPY</span> <span class="n">./go.mod</span> <span class="n">./</span>
<span class="n">COPY</span> <span class="n">./go.sum</span> <span class="n">./</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>
<span class="n">COPY</span> <span class="n">. .</span>
<span class="o">-</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>
<span class="o">+</span><span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>

<span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">server</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;/opt/app/server&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>改动点: go build 前加了 CGO_ENABLED=0</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">server</span> <span class="n">.
</span><span class="n">...</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="n">a81385160e25</span>
<span class="n">Successfully</span> <span class="n">tagged</span> <span class="n">server</span><span class="o">:</span><span class="n">latest</span>
<span class="o">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="m">9900</span><span class="o">:</span><span class="m">9900</span> <span class="n">server</span>
<span class="n">[GIN</span><span class="o">-</span><span class="n">debug]</span> <span class="n">GET</span>    <span class="o">/</span>                         <span class="o">--&gt;</span> <span class="nf">main.main.func1 </span><span class="p">(</span><span class="m">3</span> <span class="n">handlers</span><span class="p">)</span>
<span class="n">[GIN</span><span class="o">-</span><span class="n">debug]</span> <span class="n">GET</span>    <span class="o">/</span><span class="n">github</span>                   <span class="o">--&gt;</span> <span class="nf">main.main.func2 </span><span class="p">(</span><span class="m">3</span> <span class="n">handlers</span><span class="p">)</span>
<span class="n">[GIN</span><span class="o">-</span><span class="n">debug]</span> <span class="n">Listening</span> <span class="n">and</span> <span class="n">serving</span> <span class="n">HTTP</span> <span class="n">on</span> <span class="o">:</span><span class="m">9900</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="scratch解决运行环境时区与证书问题">scratch解决运行环境时区与证书问题<a hidden class="anchor" aria-hidden="true" href="#scratch解决运行环境时区与证书问题">#</a></h2>
<p>正常启动了，我们访问一下试试，访问之前看看当前时间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">date</span>
<span class="n">Fri</span> <span class="n">May</span> <span class="m">29</span> <span class="m">13</span><span class="o">:</span><span class="m">11</span><span class="o">:</span><span class="m">28</span> <span class="n">CST</span> <span class="m">2020</span>

<span class="o">$</span> <span class="n">curl</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">://</span><span class="n">localhost</span><span class="o">:</span><span class="m">9900</span><span class="o">&gt;</span>
<span class="n">hello</span> <span class="n">world</span><span class="p">,</span> <span class="n">this</span> <span class="n">time</span> <span class="n">is</span><span class="o">:</span> <span class="n">Fri</span><span class="p">,</span> <span class="m">29</span> <span class="n">May</span> <span class="m">2020</span> <span class="m">05</span><span class="o">:</span><span class="m">18</span><span class="o">:</span><span class="m">28</span> <span class="m">+0000</span>

<span class="o">$</span> <span class="n">curl</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">://</span><span class="n">localhost</span><span class="o">:</span><span class="m">9900</span><span class="o">/</span><span class="n">github</span><span class="o">&gt;</span>
<span class="n">Get</span> <span class="s">&#34;https://api.github.com/&#34;</span><span class="o">:</span> <span class="n">x509</span><span class="o">:</span> <span class="n">certificate</span> <span class="n">signed</span> <span class="n">by</span> <span class="n">unknown</span> <span class="n">authority</span>
</code></pre></td></tr></table>
</div>
</div><p>发现有问题</p>
<ul>
<li>当前系统时间是 13:11:28 ，但是根据由显示的时间是 05:11:53，其实是docker 容器内的时区不对，默认是 0 时区，可是我们国家是 东8区</li>
<li>尝试访问 <a href="https://api.github.com/">https://api.github.com/</a> 这是 https 站点，报证书错误</li>
</ul>
<p>解决问题</p>
<ul>
<li>在容器放置根证书</li>
<li>设置容器时区</li>
</ul>
<p>原因在于 scratch 镜像并不包含任何 时区信息 ，我们需要从本地系统中复制一份。</p>
<p>由于 scratch 镜像几乎不包含任何东西，甚至没有 mkdir 命令。 因此，我们需要对时区信息进行打包，然后再通过 ADD 指令进行添加，以此绕过目录创建：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">tar</span> <span class="o">-</span><span class="n">chzf</span> <span class="n">zoneinfo.tar.gz</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">zoneinfo</span>
<span class="n">tar</span><span class="o">:</span> <span class="n">Removing</span> <span class="n">leading</span> <span class="s">&#39;/&#39;</span> <span class="n">from</span> <span class="n">member</span> <span class="n">names</span>
</code></pre></td></tr></table>
</div>
</div><p>这时，时区信息问题已经解决了，但是发起 HTTPS 请求还存在问题， 原因是 scratch 镜像不包含任何 SSL CA 证书。</p>
<p>接下来，从 <a href="https://curl.haxx.se/docs/caextract.html">https://curl.haxx.se/docs/caextract.html</a> 下载 CA 证书：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">curl</span> <span class="o">-</span><span class="n">o</span> <span class="n">cacert.pem</span> <span class="n">https</span><span class="o">://</span><span class="n">curl.haxx.se</span><span class="o">/</span><span class="n">ca</span><span class="o">/</span><span class="n">cacert.pem</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.14</span><span class="o">-</span><span class="n">alpine</span> <span class="n">as</span> <span class="n">builder</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">ENV</span> <span class="n">GOPROXY</span><span class="o">=&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span><span class="o">&gt;</span>
<span class="o">+</span><span class="n">RUN</span> <span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="s">&#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apk</span><span class="o">/</span><span class="n">repositories</span> <span class="o">&amp;&amp;</span> <span class="n">\</span>

<span class="o">*</span> <span class="n">apk</span> <span class="n">add</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span> <span class="n">ca</span><span class="o">-</span><span class="n">certificates</span> <span class="n">tzdata</span>
<span class="n">COPY</span> <span class="n">./go.mod</span> <span class="n">./</span>
<span class="n">COPY</span> <span class="n">./go.sum</span> <span class="n">./</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>
<span class="n">COPY</span> <span class="n">. .</span>
<span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>

<span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="o">+</span><span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">zoneinfo</span><span class="o">/</span><span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">localtime</span>
<span class="o">+</span><span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">ssl</span><span class="o">/</span><span class="n">certs</span><span class="o">/</span><span class="n">ca</span><span class="o">-</span><span class="n">certificates.crt</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">ssl</span><span class="o">/</span><span class="n">certs</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">server</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;/opt/app/server&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>在 builder 阶段，安装了 ca-certificates tzdata 两个库，在runner阶段，将时区配置和根证书复制了一份</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">server</span> <span class="n">.
</span><span class="n">...</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="n">e0825838043d</span>
<span class="n">Successfully</span> <span class="n">tagged</span> <span class="n">server</span><span class="o">:</span><span class="n">latest</span>
<span class="o">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="m">9900</span><span class="o">:</span><span class="m">9900</span> <span class="n">server</span>
<span class="n">[GIN</span><span class="o">-</span><span class="n">debug]</span> <span class="n">GET</span>    <span class="o">/</span>                         <span class="o">--&gt;</span> <span class="nf">main.main.func1 </span><span class="p">(</span><span class="m">3</span> <span class="n">handlers</span><span class="p">)</span>
<span class="n">[GIN</span><span class="o">-</span><span class="n">debug]</span> <span class="n">GET</span>    <span class="o">/</span><span class="n">github</span>                   <span class="o">--&gt;</span> <span class="nf">main.main.func2 </span><span class="p">(</span><span class="m">3</span> <span class="n">handlers</span><span class="p">)</span>
<span class="n">[GIN</span><span class="o">-</span><span class="n">debug]</span> <span class="n">Listening</span> <span class="n">and</span> <span class="n">serving</span> <span class="n">HTTP</span> <span class="n">on</span> <span class="o">:</span><span class="m">9900</span>
</code></pre></td></tr></table>
</div>
</div><p>访问一下试试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">date</span>
<span class="n">Fri</span> <span class="n">May</span> <span class="m">29</span> <span class="m">13</span><span class="o">:</span><span class="m">27</span><span class="o">:</span><span class="m">16</span> <span class="n">CST</span> <span class="m">2020</span>

<span class="o">$</span> <span class="n">curl</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">://</span><span class="n">localhost</span><span class="o">:</span><span class="m">9900</span><span class="o">&gt;</span>
<span class="n">hello</span> <span class="n">world</span><span class="p">,</span> <span class="n">this</span> <span class="n">time</span> <span class="n">is</span><span class="o">:</span> <span class="n">Fri</span><span class="p">,</span> <span class="m">29</span> <span class="n">May</span> <span class="m">2020</span> <span class="m">13</span><span class="o">:</span><span class="m">27</span><span class="o">:</span><span class="m">16</span> <span class="m">+0800</span>

<span class="o">$</span> <span class="n">curl</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">://</span><span class="n">localhost</span><span class="o">:</span><span class="m">9900</span><span class="o">/</span><span class="n">github</span><span class="o">&gt;</span>
<span class="n">access</span> <span class="n">github</span> <span class="n">api</span> <span class="n">ok</span>
</code></pre></td></tr></table>
</div>
</div><p>一切正常了，看看当前镜像大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">images</span>
<span class="n">server</span>          <span class="n">latest</span>         <span class="n">e0825838043d</span>      <span class="m">9</span> <span class="n">minutes</span> <span class="n">ago</span>        <span class="m">11.3</span><span class="n">MB</span>
</code></pre></td></tr></table>
</div>
</div><p>才 11.3MB，已经很小了，但是，还可以更小，就是把构建后的包再压缩一次</p>
<h2 id="upx进一步减小体积">upx进一步减小体积<a hidden class="anchor" aria-hidden="true" href="#upx进一步减小体积">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.14</span><span class="o">-</span><span class="n">alpine</span> <span class="n">as</span> <span class="n">builder</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">ENV</span> <span class="n">GOPROXY</span><span class="o">=&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span><span class="o">&gt;</span>
<span class="n">RUN</span> <span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="s">&#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apk</span><span class="o">/</span><span class="n">repositories</span> <span class="o">&amp;&amp;</span> <span class="n">\</span>

<span class="o">*</span> <span class="n">apk</span> <span class="n">add</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span> <span class="n">ca</span><span class="o">-</span><span class="n">certificates</span> <span class="n">tzdata</span>

<span class="o">*</span> <span class="n">apk</span> <span class="n">add</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span> <span class="n">upx</span> <span class="n">ca</span><span class="o">-</span><span class="n">certificates</span> <span class="n">tzdata</span>
<span class="n">COPY</span> <span class="n">./go.mod</span> <span class="n">./</span>
<span class="n">COPY</span> <span class="n">./go.sum</span> <span class="n">./</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>
<span class="n">COPY</span> <span class="n">. .</span>
<span class="o">-</span><span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span>
<span class="o">+</span><span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span> <span class="o">&amp;&amp;</span><span class="n">\</span>
<span class="o">*</span> <span class="n">upx</span> <span class="o">--</span><span class="n">best</span> <span class="n">server</span> <span class="o">-</span><span class="n">o</span> <span class="n">_upx_server</span> <span class="o">&amp;&amp;</span> <span class="n">\</span>
<span class="o">*</span> <span class="n">mv</span> <span class="o">-</span><span class="n">f</span> <span class="n">_upx_server</span> <span class="n">server</span>

<span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">zoneinfo</span><span class="o">/</span><span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">localtime</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">ssl</span><span class="o">/</span><span class="n">certs</span><span class="o">/</span><span class="n">ca</span><span class="o">-</span><span class="n">certificates.crt</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">ssl</span><span class="o">/</span><span class="n">certs</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">server</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;/opt/app/server&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>在 builder 阶段，安装了 upx ，并且go build 完成后，使用 upx 压缩了一下，执行一下构建，你会发现这个构建时间变长了，这是因为我给 upx 设置的参数是 &ndash;best ，也就是最大压缩级别，这样压缩出来的后会尽可能的小，如果嫌慢，可以降低压缩级别从 -1 到 -9 ，数字越大压缩级别越高，也越慢。我使用 &ndash;best 构建完成后看看镜像体积。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">server</span> <span class="n">.
</span><span class="n">...</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="m">80</span><span class="n">c3f3cde1f7</span>
<span class="n">Successfully</span> <span class="n">tagged</span> <span class="n">server</span><span class="o">:</span><span class="n">latest</span>
<span class="o">$</span> <span class="n">docker</span> <span class="n">images</span>
<span class="n">server</span>          <span class="n">latest</span>         <span class="m">80</span><span class="n">c3f3cde1f7</span>      <span class="m">1</span> <span class="n">minutes</span> <span class="n">ago</span>        <span class="m">4.26</span><span class="n">MB</span>
</code></pre></td></tr></table>
</div>
</div><p>这下子可小了，才 4.26MB，再去试试那两个接口，一切正常。优化到此结束。</p>
<h2 id="最终的dockerfile">最终的Dockerfile<a hidden class="anchor" aria-hidden="true" href="#最终的dockerfile">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.14</span><span class="o">-</span><span class="n">alpine</span> <span class="n">as</span> <span class="n">builder</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">ENV</span> <span class="n">GOPROXY</span><span class="o">=&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span><span class="o">&gt;</span>
<span class="n">RUN</span> <span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="s">&#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apk</span><span class="o">/</span><span class="n">repositories</span> <span class="o">&amp;&amp;</span> <span class="n">\</span>
  <span class="n">apk</span> <span class="n">add</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span> <span class="n">upx</span> <span class="n">ca</span><span class="o">-</span><span class="n">certificates</span> <span class="n">tzdata</span>
<span class="n">COPY</span> <span class="n">./go.mod</span> <span class="n">./</span>
<span class="n">COPY</span> <span class="n">./go.sum</span> <span class="n">./</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>
<span class="n">COPY</span> <span class="n">. .</span>
<span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">ldflags</span> <span class="s">&#34;-s -w&#34;</span> <span class="o">-</span><span class="n">o</span> <span class="n">server</span> <span class="o">&amp;&amp;</span><span class="n">\</span>
<span class="n">upx</span> <span class="o">--</span><span class="n">best</span> <span class="n">server</span> <span class="o">-</span><span class="n">o_upx_server</span> <span class="o">&amp;&amp;</span> <span class="n">\</span>
<span class="n">mv</span> <span class="o">-</span><span class="n">f_upx_server</span> <span class="n">server</span>

<span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">zoneinfo</span><span class="o">/</span><span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">localtime</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">ssl</span><span class="o">/</span><span class="n">certs</span><span class="o">/</span><span class="n">ca</span><span class="o">-</span><span class="n">certificates.crt</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">ssl</span><span class="o">/</span><span class="n">certs</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">server</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;/opt/app/server&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="scratch">scratch<a hidden class="anchor" aria-hidden="true" href="#scratch">#</a></h2>
<p>回到我们的 hello world，C 语言版本的程序大小为 16 kB，Go 语言版本的程序大小为 2 MB，那么我们到底能不能将镜像缩减到这么小？能否构建一个只包含我需要的程序，没有任何多余文件的镜像？</p>
<p>答案是肯定的，你只需要将多阶段构建的第二阶段的基础镜像改为 scratch 就好了。scratch 是一个虚拟镜像，不能被 pull，也不能运行，因为它表示空、nothing！这就意味着新镜像的构建是从零开始，不存在其他的镜像层。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span>
<span class="n">COPY</span> <span class="n">hello.go</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="n">hello.go</span>
<span class="n">FROM</span> <span class="n">scratch</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>这一次构建的镜像大小正好就是 2 MB，堪称完美！</p>
<p>然而，但是，使用 scratch 作为基础镜像时会带来很多的不便，且听我一一道来。</p>
<h3 id="缺少-shell">缺少 shell<a hidden class="anchor" aria-hidden="true" href="#缺少-shell">#</a></h3>
<p>scratch 镜像的第一个不便是没有 shell，这就意味着 CMD/RUN 语句中不能使用字符串，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="kc">...</span>
<span class="n">FROM</span> <span class="n">scratch</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">./hello</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你使用构建好的镜像创建并运行容器，就会遇到下面的报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">docker</span><span class="o">:</span> <span class="n">Error</span> <span class="n">response</span> <span class="n">from</span> <span class="n">daemon</span><span class="o">:</span> <span class="n">OCI</span> <span class="n">runtime</span> <span class="n">create</span> <span class="n">failed</span><span class="o">:</span> <span class="n">container_linux.go</span><span class="o">:</span><span class="m">345</span><span class="o">:</span> <span class="n">starting</span> <span class="n">container</span> <span class="n">process</span> <span class="n">caused</span> <span class="s">&#34;exec: \&#34;/bin/sh\&#34;: stat /bin/sh: no such file or directory&#34;</span><span class="o">:</span> <span class="n">unknown.</span>
</code></pre></td></tr></table>
</div>
</div><p>从报错信息可以看出，镜像中并不包含 /bin/sh，所以无法运行程序。这是因为当你在 CMD/RUN 语句中使用字符串作为参数时，这些参数会被放到 /bin/sh 中执行，也就是说，下面这两条语句是等效的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">CMD</span> <span class="n">./hello</span>
<span class="n">CMD</span> <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span> <span class="o">-</span><span class="n">c</span> <span class="s">&#34;./hello&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>解决办法其实也很简单：使用 JSON 语法取代字符串语法。例如，将 CMD ./hello 替换为 CMD [&quot;./hello&quot;]，这样 Docker 就会直接运行程序，不会把它放到 shell 中运行。</p>
<h3 id="缺少调试工具">缺少调试工具<a hidden class="anchor" aria-hidden="true" href="#缺少调试工具">#</a></h3>
<p>scratch 镜像不包含任何调试工具，ls、ps、ping 这些统统没有，当然了，shell 也没有（上文提过了），你无法使用 docker exec 进入容器，也无法查看网络堆栈信息等等。</p>
<p>如果想查看容器中的文件，可以使用 docker cp；如果想查看或调试网络堆栈，可以使用 docker run &ndash;net container:，或者使用 nsenter；为了更好地调试容器，Kubernetes 也引入了一个新概念叫 Ephemeral Containers，但现在还是 Alpha 特性。</p>
<p>虽然有这么多杂七杂八的方法可以帮助我们调试容器，但它们会将事情变得更加复杂，我们追求的是简单，越简单越好。</p>
<p>折中一下可以选择 busybox 或 alpine 镜像来替代 scratch，虽然它们多了那么几 MB，但从整体来看，这只是牺牲了少量的空间来换取调试的便利性，还是很值得的。</p>
<h3 id="缺少-libc">缺少 libc<a hidden class="anchor" aria-hidden="true" href="#缺少-libc">#</a></h3>
<p>这是最难解决的问题。使用 scratch 作为基础镜像时，Go 语言版本的 hello world 跑得很欢快，C 语言版本就不行了，或者换个更复杂的 Go 程序也是跑不起来的（例如用到了网络相关的工具包），你会遇到类似于下面的错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">standard_init_linux.go</span><span class="o">:</span><span class="m">211</span><span class="o">:</span> <span class="n">exec</span> <span class="n">user</span> <span class="n">process</span> <span class="n">caused</span> <span class="s">&#34;no such file or directory&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>从报错信息可以看出缺少文件，但没有告诉我们到底缺少哪些文件，其实这些文件就是程序运行所必需的动态库（dynamic library）。</p>
<p>那么，什么是动态库？为什么需要动态库？</p>
<p>所谓动态库、静态库，指的是程序编译的链接阶段，链接成可执行文件的方式。静态库指的是在链接阶段将汇编生成的目标文件.o 与引用到的库一起链接打包到可执行文件中，因此对应的链接方式称为静态链接（static linking）。而动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此对应的链接方式称为动态链接（dynamic linking）。</p>
<p>90 年代的程序大多使用的是静态链接，因为当时的程序大多数都运行在软盘或者盒式磁带上，而且当时根本不存在标准库。这样程序在运行时与函数库再无瓜葛，移植方便。但对于 Linux 这样的分时系统，会在在同一块硬盘上并发运行多个程序，这些程序基本上都会用到标准的 C 库，这时使用动态链接的优点就体现出来了。使用动态链接时，可执行文件不包含标准库文件，只包含到这些库文件的索引。例如，某程序依赖于库文件 libtrigonometry.so 中的 cos 和 sin 函数，该程序运行时就会根据索引找到并加载 libtrigonometry.so，然后程序就可以调用这个库文件中的函数。</p>
<p>使用动态链接的好处显而易见：</p>
<ol>
<li>节省磁盘空间，不同的程序可以共享常见的库。</li>
<li>节省内存，共享的库只需从磁盘中加载到内存一次，然后在不同的程序之间共享。</li>
<li>更便于维护，库文件更新后，不需要重新编译使用该库的所有程序。</li>
</ol>
<p>严格来说，动态库与共享库（shared libraries）相结合才能达到节省内存的功效。Linux 中动态库的扩展名是 .so（ shared object），而 Windows 中动态库的扩展名是 .DLL（Dynamic-link library）。</p>
<p>回到最初的问题，默认情况下，C 程序使用的是动态链接，Go 程序也是。上面的 hello world 程序使用了标准库文件 libc.so.6，所以只有镜像中包含该文件，程序才能正常运行。使用 scratch 作为基础镜像肯定是不行的，使用 busybox 和 alpine 也不行，因为 busybox 不包含标准库，而 alpine 使用的标准库是 musl libc，与大家常用的标准库 glibc 不兼容，后续的文章会详细解读，这里就不赘述了。</p>
<p>那么该如何解决标准库的问题呢？有三种方案。</p>
<h4 id="1使用静态库">1、使用静态库<a hidden class="anchor" aria-hidden="true" href="#1使用静态库">#</a></h4>
<p>我们可以让编译器使用静态库编译程序，办法有很多，如果使用 gcc 作为编译器，只需加上一个参数 -static：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">hello.c</span> <span class="o">-</span><span class="n">static</span>
</code></pre></td></tr></table>
</div>
</div><p>编译完的可执行文件大小为 760 kB，相比于之前的 16kB 是大了好多，这是因为可执行文件中包含了其运行所需要的库文件。编译完的程序就可以跑在 scratch 镜像中了。</p>
<p>如果使用 alpine 镜像作为基础镜像来编译，得到的可执行文件会更小（&lt; 100kB），下篇文章会详述。</p>
<h4 id="2拷贝库文件到镜像中">2、拷贝库文件到镜像中<a hidden class="anchor" aria-hidden="true" href="#2拷贝库文件到镜像中">#</a></h4>
<p>为了找出程序运行需要哪些库文件，可以使用 ldd 工具：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">ldd</span> <span class="n">hello</span>
    <span class="n">linux</span><span class="o">-</span><span class="nf">vdso.so.1 </span><span class="p">(</span><span class="mh">0x00007ffdf8acb000</span><span class="p">)</span>
    <span class="n">libc.so.6</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="nf">libc.so.6 </span><span class="p">(</span><span class="mh">0x00007ff897ef6000</span><span class="p">)</span>
    <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="m">-64</span><span class="n">.so.2</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="m">-64</span><span class="nf">.so.2 </span><span class="p">(</span><span class="mh">0x00007ff8980f7000</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>从输出结果可知，该程序只需要 libc.so.6 这一个库文件。linux-vdso.so.1 与一种叫做 VDSO 的机制有关，用来加速某些系统调用，可有可无。ld-linux-x86-64.so.2 表示动态链接器本身，包含了所有依赖的库文件的信息。</p>
<p>你可以选择将 ldd 列出的所有库文件拷贝到镜像中，但这会很难维护，特别是当程序有大量依赖库时。对于 hello world 程序来说，拷贝库文件完全没有问题，但对于更复杂的程序（例如使用到 DNS 的程序），就会遇到令人费解的问题：glibc（GNU C library）通过一种相当复杂的机制来实现 DNS，这种机制叫 NSS（Name Service Switch, 名称服务开关）。它需要一个配置文件 /etc/nsswitch.conf 和额外的函数库，但使用 ldd 时不会显示这些函数库，因为这些库在程序运行后才会加载。如果想让 DNS 解析正确工作，必须要拷贝这些额外的库文件（/lib64/libnss_*）。</p>
<p>我个人不建议直接拷贝库文件，因为它非常难以维护，后期需要不断地更改，而且还有很多未知的隐患。</p>
<h4 id="3使用-busyboxglibc-作为基础镜像">3、使用 busybox:glibc 作为基础镜像<a hidden class="anchor" aria-hidden="true" href="#3使用-busyboxglibc-作为基础镜像">#</a></h4>
<p>有一个镜像可以完美解决所有的这些问题，那就是 busybox:glibc。它只有 5 MB 大小，并且包含了 glibc 和各种调试工具。如果你想选择一个合适的镜像来运行使用动态链接的程序，busybox:glibc 是最好的选择。</p>
<p>注意：如果你的程序使用到了除标准库之外的库，仍然需要将这些库文件拷贝到镜像中。</p>
<h2 id="alpine">Alpine<a hidden class="anchor" aria-hidden="true" href="#alpine">#</a></h2>
<p>Alpine 是众多 Linux 发行版中的一员，和 CentOS、Ubuntu、Archlinux 之类一样，只是一个发行版的名字，号称小巧安全，有自己的包管理工具 apk。</p>
<p>与 CentOS 和 Ubuntu 不同，Alpine 并没有像 Red Hat 或 Canonical 之类的大公司为其提供维护支持，软件包的数量也比这些发行版少很多（如果只看开箱即用的默认软件仓库，Alpine 只有 10000 个软件包，而 Ubuntu、Debian 和 Fedora 的软件包数量均大于 50000。）</p>
<p>容器崛起之前，Alpine 还是个无名之辈，可能是因为大家并不是很关心操作系统本身的大小，毕竟大家只关心业务数据和文档，程序、库文件和系统本身的大小通常可以忽略不计。</p>
<p>容器技术席卷整个软件产业之后，大家都注意到了一个问题，那就是容器的镜像太大了，浪费磁盘空间，拉取镜像的时间也很长。于是，人们开始寻求适用于容器的更小的镜像。对于那些耳熟能详的发行版（例如 Ubuntu、Debian、Fedora）来说，只能通过删除某些工具（例如 ifconfig 和 netstat）将镜像体积控制在 100M 以下。而对于 Alpine 而言，什么都不用删除，镜像大小也就只有 5M 而已。</p>
<p>Alpine 镜像的另一个优势是包管理工具的执行速度非常快，安装软件体验非常顺滑。诚然，在传统的虚拟机上不需要太关心软件包的安装速度，同一个包只需要装一次即可，无需不停重复安装。容器就不一样了，你可能会定期构建新镜像，也可能会在运行的容器中临时安装某些调试工具，如果软件包的安装速度很慢，会很快消磨掉我们的耐心。</p>
<p>为了更直观，我们来做个简单的对比测试，看看不同的发行版安装 tcpdump 需要多长时间，测试命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">🐳 → <span class="n">time</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">&lt;</span><span class="n">image</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">packagemanager</span><span class="o">&gt;</span> <span class="n">install</span> <span class="n">tcpdump</span>
</code></pre></td></tr></table>
</div>
</div><p>测试结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Base</span> <span class="n">image</span>           <span class="n">Size</span>      <span class="n">Time</span> <span class="n">to</span> <span class="n">install</span> <span class="n">tcpdump</span>
<span class="o">---------------------------------------------------------</span>

<span class="n">alpine</span><span class="o">:</span><span class="m">3.11</span>          <span class="m">5.6</span> <span class="n">MB</span>      <span class="m">1-2</span><span class="n">s</span>
<span class="n">archlinux</span><span class="o">:</span><span class="m">20200106</span>   <span class="m">409</span> <span class="n">MB</span>      <span class="m">7-9</span><span class="n">s</span>
<span class="n">centos</span><span class="o">:</span><span class="m">8</span>             <span class="m">237</span> <span class="n">MB</span>      <span class="m">5-6</span><span class="n">s</span>
<span class="n">debian</span><span class="o">:</span><span class="m">10</span>            <span class="m">114</span> <span class="n">MB</span>      <span class="m">5-7</span><span class="n">s</span>
<span class="n">fedora</span><span class="o">:</span><span class="m">31</span>            <span class="m">194</span> <span class="n">MB</span>    <span class="m">35-60</span><span class="n">s</span>
<span class="n">ubuntu</span><span class="o">:</span><span class="m">18.04</span>          <span class="m">64</span> <span class="n">MB</span>      <span class="m">6-8</span><span class="n">s</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你想了解更多关于 Alpine 的内幕，可以看看 Natanel Copa 的演讲。</p>
<p>好吧，既然 Alpine 这么棒，为什么不用它作为所有镜像的基础镜像呢？别急，先一步一步来，为了趟平所有的坑，需要分两种情况来考虑：</p>
<ol>
<li>使用 Alpine 作为第二构建阶段（run 阶段）的基础镜像</li>
<li>使用 ALpine 作为所有构建阶段（run 阶段和 build 阶段）的基础镜像</li>
</ol>
<h3 id="run-阶段使用-alpine">run 阶段使用 Alpine<a hidden class="anchor" aria-hidden="true" href="#run-阶段使用-alpine">#</a></h3>
<p>带着激动的心情，将 Alpine 镜像加入了 Dockerfile：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">gcc</span> <span class="n">AS</span> <span class="n">mybuildstage</span>
<span class="n">COPY</span> <span class="n">hello.c</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">hello.c</span>

<span class="n">FROM</span> <span class="n">alpine</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">mybuildstage</span> <span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>第一个坑来了，启动容器出现了错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">standard_init_linux.go</span><span class="o">:</span><span class="m">211</span><span class="o">:</span> <span class="n">exec</span> <span class="n">user</span> <span class="n">process</span> <span class="n">caused</span> <span class="s">&#34;no such file or directory&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个报错在上篇文章已经见识过了，上篇文章的场景是使用 scratch 镜像作为 C 语言程序的基础镜像，错误的原因是 scratch 镜像中缺少动态库文件。可是为什么使用 Alpine 镜像也有报错，难道它也缺少动态库文件？</p>
<p>也不完全是，Alpine 使用的也是动态库，毕竟它的设计目标之一就是占用更少的空间。但 Alpine 使用的标准库与大多数发行版不同，它使用的是 musl libc，这个库相比于 glibc 更小、更简单、更安全，但是与大家常用的标准库 glibc 并不兼容。</p>
<p>你可能又要问了：『既然 musl libc 更小、更简单，还特么更安全，为啥其他发行版还在用 glibc？』</p>
<p>因为 glibc 有很多额外的扩展，并且很多程序都用到了这些扩展，而 musl libc 是不包含这些扩展的。详情可以参考 musl 的文档。</p>
<p>也就是说，如果想让程序跑在 Alpine 镜像中，必须在编译时使用 musl libc 作为动态库。</p>
<h3 id="所有阶段使用-alpine">所有阶段使用 Alpine<a hidden class="anchor" aria-hidden="true" href="#所有阶段使用-alpine">#</a></h3>
<p>为了生成一个与 musl libc 链接的二进制文件，有两条路：</p>
<ul>
<li>某些官方镜像提供了 Alpine 版本，可以直接拿来用。</li>
<li>还有些官方镜像没有提供 Alpine 版本，我们需要自己构建。</li>
</ul>
<p>golang 镜像就属于第一种情况，golang:alpine 提供了基于 Alpine 构建的 Go 工具链。</p>
<p>构建 Go 程序可以使用下面的 Dockerfile：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="n">alpine</span>
<span class="n">COPY</span> <span class="n">hello.go</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">build</span> <span class="n">hello.go</span>

<span class="n">FROM</span> <span class="n">alpine</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>生成的镜像大小为 7.5M，对于一个只打印 『hello world』的程序来说确实有点大了，但我们可以换个角度：</p>
<ul>
<li>即使程序很复杂，生成的镜像也不会很大。</li>
<li>包含了很多有用的调试工具。</li>
<li>即使运行时缺少某些特殊的调试工具，也可以迅速安装。</li>
</ul>
<p>Go 语言搞定了，C 语言呢？并没有 gcc:alpine 这样的镜像啊。只能以 Alpine 镜像作为基础镜像，自己安装 C 编译器了，Dockerfile 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">alpine</span>
<span class="n">RUN</span> <span class="n">apk</span> <span class="n">add</span> <span class="n">build</span><span class="o">-</span><span class="n">base</span>
<span class="n">COPY</span> <span class="n">hello.c</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">hello.c</span>

<span class="n">FROM</span> <span class="n">alpine</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="m">0</span> <span class="n">hello</span> <span class="n">.
</span><span class="n">CMD</span> <span class="n">[</span><span class="s">&#34;./hello&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>必须安装 build-base，如果安装 gcc，就只有编译器，没有标准库。build-base 相当于 Ubuntu 的 build-essentials，引入了编译器、标准库和 make 之类的工具。</p>
<p>最后来对比一下不同构建方法得到的 『hello world』镜像大小：</p>
<ul>
<li>
<p>使用基础镜像 golang 构建：805MB</p>
</li>
<li>
<p>多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 ubuntu：66.2MB</p>
</li>
<li>
<p>多阶段构建，build 阶段使用基础镜像 golang:alpine，run 阶段使用基础镜像 alpine：7.6MB</p>
</li>
<li>
<p>多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 scratch：2MB</p>
</li>
</ul>
<p>最终镜像体积减少了 99.75%，相当惊人了。再来看一个更实际的例子，上一节提到的使用 net 的程序，最终的镜像大小对比：</p>
<ul>
<li>使用基础镜像 golang 构建：810MB</li>
<li>多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 ubuntu：71.2MB</li>
<li>多阶段构建，build 阶段使用基础镜像 golang:alpine，run 阶段使用基础镜像 alpine：12.6MB</li>
<li>多阶段构建，build 阶段使用基础镜像 golang，run 阶段使用基础镜像 busybox:glibc：12.2MB</li>
<li>多阶段构建，build 阶段使用基础镜像 golang 并使用参数 CGO_ENABLED=0，run 阶段使用基础镜像 ubuntu：7MB
镜像体积仍然减少了 99%。</li>
</ul>
<h2 id="建议选择alpile">建议选择alpile<a hidden class="anchor" aria-hidden="true" href="#建议选择alpile">#</a></h2>
<p>要减小镜像体积，首先多阶段构建这很重要，这样就可以把编译环境和运行环境分开。</p>
<p>另外，选择 scratch 这个镜像其实很不明智，它虽然很小，但是它太原始了，里面什么工具都没有，程序启动后，连容器都进不去，就算进去了什么都做不了。所以就算一昧的追求尽可能小的镜像体积，也不建议选择 scratch 作为运行环境，我暂时只踩到小部分的坑，后面还有更多坑没踩，我也没有兴趣继续踩 scratch 的坑。</p>
<p>建议选择 alpine ，alpine 的镜像大小是 5.61MB 这个大小其实还是镜像解压后的大小，实际上下载镜像的时候，只需要下载 2.68 MB 。还有，上文所有我说的镜像体积，全都是指解压后的镜像体积，和实际上传下载时的体积是不一样的，docker自己会压缩一次再传输镜像
还有个很小的镜像是 busybox，它的体积是 1.22MB，下载 705.6 KB ，有大部分的linux命令可用，但是运行环境还是很原始，有兴趣可以去尝试</p>
<p>无论是 alpine 还是 busybox ，他们都会上述时区和证书问题，同样按照上面方法就能解决，切换到 alpine 或者 busybox 也很简单，只需要修改 runner 基础镜像就行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">-</span><span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="o">+</span><span class="n">FROM</span> <span class="n">alpine</span> <span class="n">as</span> <span class="n">runner</span>
</code></pre></td></tr></table>
</div>
</div><p>或者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">-</span><span class="n">FROM</span> <span class="n">scratch</span> <span class="n">as</span> <span class="n">runner</span>
<span class="o">+</span><span class="n">FROM</span> <span class="n">busybox</span> <span class="n">as</span> <span class="n">runne</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="最终版本">最终版本<a hidden class="anchor" aria-hidden="true" href="#最终版本">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">FROM</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.13.5</span><span class="o">-</span><span class="n">alpine3.10</span> <span class="n">AS</span> <span class="n">builder</span>

<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">build</span>
<span class="n">RUN</span> <span class="n">adduser</span> <span class="o">-</span><span class="n">u</span> <span class="m">10001</span> <span class="o">-</span><span class="n">D</span> <span class="n">app</span><span class="o">-</span><span class="n">runner</span>

<span class="n">ENV</span> <span class="n">GOPROXY</span> <span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span>
<span class="n">COPY</span> <span class="n">go.mod</span> <span class="n">.
</span><span class="n">COPY</span> <span class="n">go.sum</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>

<span class="n">COPY</span> <span class="n">. .</span>
<span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">GOARCH</span><span class="o">=</span><span class="n">amd64</span> <span class="n">GOOS</span><span class="o">=</span><span class="n">linux</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">o</span> <span class="n">your</span><span class="o">-</span><span class="n">application</span> <span class="n">.
</span><span class="n"></span>
<span class="n">FROM</span> <span class="n">alpine</span><span class="o">:</span><span class="m">3.10</span> <span class="n">AS</span> <span class="n">final</span>

<span class="n">RUN</span> <span class="n">apk</span> <span class="n">update</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span> <span class="o">&amp;&amp;</span> <span class="n">apk</span> <span class="n">add</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">cache</span> <span class="n">ca</span><span class="o">-</span><span class="n">certificates</span> <span class="n">tzdata</span>
<span class="n">ENV</span> <span class="n">TZ</span> <span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">app</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">your</span><span class="o">-</span><span class="n">application</span> <span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">builder</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">passwd</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">passwd</span>

<span class="n">USER</span> <span class="n">app</span><span class="o">-</span><span class="n">runner</span>
<span class="n">ENTRYPOINT</span> <span class="n">[</span><span class="s">&#34;/app/your-application&#34;</span><span class="n">]</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，这个dockerfile分为builder和final两部分。</p>
<p>builder选择了golang:1.13.5-alpine3.10作为编译的基础镜像，相比于golang:1.13, 一方面是因为它体积更小，另一方面是我发现golang:1.13的编译结果，在alpine:3.10中会报not found的错误，虽说有人提供了其它的解决方案，但是能直接避免，为啥不避免呢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">RUN</span> <span class="n">adduser</span> <span class="o">-</span><span class="n">u</span> <span class="m">10001</span> <span class="o">-</span><span class="n">D</span> <span class="n">app</span><span class="o">-</span><span class="n">runner</span>
</code></pre></td></tr></table>
</div>
</div><p>接着是创建了一个app-runner的用户, -D表示无密码。
此用户的信息是是需要拷到final中，作为应用程序的启动用户。这是为了避免使用container中的默认用户root，那可是有安全漏洞的，详细解释，可以参考这篇medium上的文章Processes In Containers Should Not Run As Root
再下面的四行，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">ENV</span> <span class="n">GOPROXY</span> <span class="o">&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">goproxy.cn</span><span class="o">&gt;</span>
<span class="n">COPY</span> <span class="n">go.mod</span> <span class="n">.
</span><span class="n">COPY</span> <span class="n">go.sum</span> <span class="n">.
</span><span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">download</span>
</code></pre></td></tr></table>
</div>
</div><p>是配置了国内的代理，安装依赖包了。这里用go mod download的好处是下次构建镜像文件时，当go.mod和go.sum没有改变时，它是有缓存的，可以避免重复下载依赖包，加快构建。</p>
<p>builder的最后，就是把当前目录的文件拷过去，编译代码了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">COPY</span> <span class="n">. .</span>
<span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="n">GOARCH</span><span class="o">=</span><span class="n">amd64</span> <span class="n">GOOS</span><span class="o">=</span><span class="n">linux</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">o</span> <span class="n">your</span><span class="o">-</span><span class="n">application</span> <span class="n">.
</span></code></pre></td></tr></table>
</div>
</div><p>final选择了alpine:3.10,一方面是体积小，只有5m；另一方面也是和构建镜像的alpine版本保持一致。</p>
<p>接下来几行没啥说的，就是把构建结果、配置文件（有的话）和用户的相关文件拷过去。</p>
<p>下面的这步一定不要忘记了，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">USER</span> <span class="n">app</span><span class="o">-</span><span class="n">runner</span>
</code></pre></td></tr></table>
</div>
</div><p>没有它，container启动时就是用root用户启动了!!! 如果被攻击了，那黑客可是就有root权限了（不要问我为啥会被攻击）。</p>
<p>最后，设置一个ENTRYPOINT，完事!</p>
<p>如果你程序的启动过程比较复杂，或者是要在启动时根据环境变量的值做不同的操作，那还是写个shell文件吧。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://juejin.cn/post/6844904174396637197">构建 Golang 应用最小 Docker 镜像</a>
<a href="https://zhuanlan.zhihu.com/p/115845957">两个奇技淫巧，将 Docker 镜像体积减小 99%</a>
<a href="https://fuckcloudnative.io/posts/docker-images-part2-details-specific-to-different-languages/">Docker 镜像制作教程：针对不同语言的精简策略</a>
<a href="https://juejin.cn/post/6844904073301327879">手把手教你写一个完美的Golang Dockerfile</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/docker/">Docker</a></li>
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
