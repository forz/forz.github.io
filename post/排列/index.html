<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>排列 | Forz Blog</title>
<meta name="keywords" content="STL, Backtracking" />
<meta name="description" content="LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%8E%92%E5%88%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="排列" />
<meta property="og:description" content="LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%8E%92%E5%88%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T23:59:06&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T23:59:06&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="排列"/>
<meta name="twitter:description" content="LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "排列",
      "item": "/post/%E6%8E%92%E5%88%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "排列",
  "name": "排列",
  "description": "LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解析： 此题可以直接用STL中的next_permutation()实现。利用回溯法暴",
  "keywords": [
    "STL", "Backtracking"
  ],
  "articleBody": "LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations.\nFor example, [1,2,3] have the following permutations:\n[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  解析：\n此题可以直接用STL中的next_permutation()实现。利用回溯法暴力搜索。此题保证所有字符仅出现一次，不需要进行判重。\n回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n如果当前dfs影响了全局变量并且该次dfs不是必经之路，那么就需要回溯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public: vectorvectorint  permute(vectorint \u0026num) { vectorvectorint  ret; Helper(ret, num, 0); return ret; } void Helper(vectorvectorint \u0026 ret, vectorint num, int pos) {//需要知道当前dfs位置pos  if(pos == num.size()-1)//递归终止条件  ret.push_back(num); else { for(int i = pos; i  num.size(); i ++) { swap(num[pos], num[i]); Helper(ret, num, pos+1); swap(num[pos], num[i]);//回溯（如果不回溯，影响下一次for循环）  } } } };   补充：STL实现\n1 2 3 4 5 6 7 8 9 10 11  class Solution { public: vectorvectorint  permute(vectorint \u0026num) { vectorvectorint  result; sort(num.begin(), num.end());//使用该函数前要先排序，才能找到所有的排列  do { result.push_back(num); } while(next_permutation(num.begin(), num.end())); return result; } };   LeetCode 47. Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations.\nFor example, [1,1,2] have the following unique permutations:\n[ [1,1,2], [1,2,1], [2,1,1] ]  解析：如果直接进行dfs会出现重复，先进行排序。对于同一个值，只交换一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: vectorvectorint  permuteUnique(vectorint \u0026num) { vectorvectorint  ret; Helper(ret, num, 0); return ret; } void Helper(vectorvectorint \u0026 ret, vectorint num, int pos) { if(pos == num.size()-1)//  ret.push_back(num); else { sort(num.begin()+pos, num.end());//每次dfs前对pos后面的值进行排序，不会影响结果  for(int i = pos; i  num.size(); i ++) { if(i != pos \u0026\u0026 num[i] == num[i-1])//对于同一个值，只交换一次，否则跳过。  continue; swap(num[pos], num[i]); Helper(ret, num, pos+1); swap(num[pos], num[i]);//回溯  } } } };   LeetCode 31. Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place, do not allocate extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  解析:求解每个序列的下一个字典序排列，直接实现STL的相应函数。以下为算法分析。\n对当前排列从后向前扫描，找到一对为升序的相邻元素，记为i和j（i 如果不存在这样一对为升序的相邻元素，则所有排列均已找到，算法结束；否则，重新对当前排列从后向前扫描，找到第一个大于i的元素k，交换i和k，然后对从j开始到结束的子序列反转，则此时得到的新排列就为下一个字典序排列。\n这种方式实现得到的所有排列是按字典序有序的，这也是C++ STL算法next_permutation的思想。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: //寻找整数序列num的下一个全排序列  void nextPermutation(vectorint \u0026num) { if (num.size()  2) return; int i, k; for (i = num.size() - 2; i = 0; --i) if (num[i]  num[i + 1]) break; //i表示逆序扫描中第一个比后一位小的元素  //若不存在子升序，则说明当前排列是最大排列，此时i = -1，下一排列即是最小排列，翻转整个序列即可  if (i  0) { reverse(num.begin() , num.end()); return; } //找到子升序，找到第一个比i大的元素  for (k = num.size() - 1; k  i ; --k) if (num[i]  num[k]) break; swap(num[i], num[k]); reverse(num.begin() + i + 1, num.end()); return; } };   补充：STL方法\n1 2 3 4 5 6  class Solution { public: void nextPermutation(vectorint\u0026 nums) { next_permutation( nums.begin(), nums.end() ); } };   LeetCode 60. Permutation Sequence The set [1,2,3,…,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):\n\"123\" \"132\" \"213\" \"231\" \"312\" \"321\"  Given n and k, return the kth permutation sequence.\nNote: Given n will be between 1 and 9 inclusive.\n解析：给定数字的位数，求某个字典序排列。\n第一位每个数字开头的序列都有（n-1）！个序列，因此n个数字所以共有n！个序列。以此类推，第二位每一个数开头都有（n-2）！个序列。\n如果k定义一个偏移量tmp=(k-1)/(n-i)! ，可以举例来验证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: string getPermutation(int n, int k) { int i,j,data[10],sign[10]; //sign记录数字是否使用过（保证不重复）  data[1]=1; for(i=2;in;++i)data[i]=data[i-1]*i; //记录阶乘值 i! 方便后续计算。  memset(sign,0,sizeof(sign)); string s=\"\"; i=n-1; //i此时为n-1  --k; while(i=0) { int temp=k/data[i]; //tmp表示当前位与其最小可能值的偏移量。  for(j=1;j10;++j) //枚举j，求出当前位的确定值  { if(sign[j]==0)temp--; //只有未使用的数才能影响temp的值  if(temp0)break; //到达目标值，停止枚举  } sign[j]=1; s+=j+'0'; //将j转换为字符后放入s末尾  k%=data[i]; //更新k  i--; //查找下一位的时候序列的阶乘变小  } return s; } };   ",
  "wordCount" : "1706",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T23:59:06Z",
  "dateModified": "2017-06-24T23:59:06Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%8E%92%E5%88%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      排列
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-46-permutations">LeetCode 46. Permutations<a hidden class="anchor" aria-hidden="true" href="#leetcode-46-permutations">#</a></h1>
<p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example, <br>
[1,2,3] have the following permutations:</p>
<pre><code>[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],    
  [3,1,2],
  [3,2,1]
]
</code></pre>
<p>解析：</p>
<p>此题可以直接用STL中的next_permutation()实现。利用回溯法暴力搜索。此题保证所有字符仅出现一次，不需要进行判重。</p>
<p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>如果当前dfs影响了全局变量并且该次dfs不是必经之路，那么就需要回溯</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">Helper</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Helper</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">ret</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span><span class="c1">//需要知道当前dfs位置pos
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="c1">//递归终止条件
</span><span class="c1"></span>        <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">Helper</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//回溯（如果不回溯，影响下一次for循环）
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：STL实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//使用该函数前要先排序，才能找到所有的排列
</span><span class="c1"></span>    <span class="k">do</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-47-permutations-ii">LeetCode 47. Permutations II<a hidden class="anchor" aria-hidden="true" href="#leetcode-47-permutations-ii">#</a></h1>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example, <br>
[1,1,2] have the following unique permutations:</p>
<pre><code>[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>
<p>解析：如果直接进行dfs会出现重复，先进行排序。对于同一个值，只交换一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">permuteUnique</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">Helper</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Helper</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">ret</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="c1">//
</span><span class="c1"></span>        <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">pos</span><span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//每次dfs前对pos后面的值进行排序，不会影响结果
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="c1">//对于同一个值，只交换一次，否则跳过。
</span><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">Helper</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//回溯
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-31-next-permutation">LeetCode 31. Next Permutation<a hidden class="anchor" aria-hidden="true" href="#leetcode-31-next-permutation">#</a></h1>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre>
<p>解析:求解每个序列的下一个字典序排列，直接实现STL的相应函数。以下为算法分析。</p>
<p>对当前排列从后向前扫描，找到一对为升序的相邻元素，记为i和j（i &lt; j）。</p>
<p>如果不存在这样一对为升序的相邻元素，则所有排列均已找到，算法结束；否则，重新对当前排列从后向前扫描，找到第一个大于i的元素k，交换i和k，然后对从j开始到结束的子序列反转，则此时得到的新排列就为下一个字典序排列。</p>
<p>这种方式实现得到的所有排列是按字典序有序的，这也是C++ STL算法next_permutation的思想。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="c1">//寻找整数序列num的下一个全排序列
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">nextPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> 
                <span class="k">break</span><span class="p">;</span>
        <span class="c1">//i表示逆序扫描中第一个比后一位小的元素
</span><span class="c1"></span>        <span class="c1">//若不存在子升序，则说明当前排列是最大排列，此时i = -1，下一排列即是最小排列，翻转整个序列即可
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//找到子升序，找到第一个比i大的元素
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> 
                <span class="k">break</span><span class="p">;</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充：STL方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="nl">public</span><span class="p">:</span>
        <span class="kt">void</span> <span class="n">nextPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">next_permutation</span><span class="p">(</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span> 
        <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-60-permutation-sequence">LeetCode 60. Permutation Sequence<a hidden class="anchor" aria-hidden="true" href="#leetcode-60-permutation-sequence">#</a></h1>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):</p>
<pre><code>&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
</code></pre>
<p>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
<p>解析：给定数字的位数，求某个字典序排列。</p>
<p>第一位每个数字开头的序列都有（n-1）！个序列，因此n个数字所以共有n！个序列。以此类推，第二位每一个数开头都有（n-2）！个序列。</p>
<p>如果k&lt;(n-1)! 那么结果的第一位肯定是1.如果k&lt;(n-2)!,那么结果的第二位肯定是2（1在之前被使用过）.</p>
<p>定义一个偏移量tmp=(k-1)/(n-i)! ，可以举例来验证。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  

<span class="nl">public</span><span class="p">:</span>  
<span class="n">string</span> <span class="n">getPermutation</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>  
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="n">sign</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">//sign记录数字是否使用过（保证不重复）
</span><span class="c1"></span>    <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>  <span class="c1">//记录阶乘值 i! 方便后续计算。
</span><span class="c1"></span>    <span class="n">memset</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sign</span><span class="p">));</span>  
    <span class="n">string</span> <span class="n">s</span><span class="o">=</span><span class="s">&#34;&#34;</span><span class="p">;</span>  
    <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">//i此时为n-1
</span><span class="c1"></span>    <span class="o">--</span><span class="n">k</span><span class="p">;</span> 
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">k</span><span class="o">/</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">//tmp表示当前位与其最小可能值的偏移量。
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>  <span class="c1">//枚举j，求出当前位的确定值
</span><span class="c1"></span>        <span class="p">{</span>  
            <span class="k">if</span><span class="p">(</span><span class="n">sign</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">temp</span><span class="o">--</span><span class="p">;</span>  <span class="c1">//只有未使用的数才能影响temp的值
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>  <span class="c1">//到达目标值，停止枚举
</span><span class="c1"></span>        <span class="p">}</span>  
        <span class="n">sign</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>  
        <span class="n">s</span><span class="o">+=</span><span class="n">j</span><span class="o">+</span><span class="sc">&#39;0&#39;</span><span class="p">;</span>  <span class="c1">//将j转换为字符后放入s末尾
</span><span class="c1"></span>        <span class="n">k</span><span class="o">%=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">//更新k
</span><span class="c1"></span>        <span class="n">i</span><span class="o">--</span><span class="p">;</span>  <span class="c1">//查找下一位的时候序列的阶乘变小
</span><span class="c1"></span>    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="p">};</span> 
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/stl/">STL</a></li>
      <li><a href="/tags/backtracking/">Backtracking</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
