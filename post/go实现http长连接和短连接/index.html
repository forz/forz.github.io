<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go实现HTTP长连接和短连接 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go实现HTTP长连接和短连接" />
<meta property="og:description" content="TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-12-13T15:33:35&#43;00:00" />
<meta property="article:modified_time" content="2018-12-13T15:33:35&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go实现HTTP长连接和短连接"/>
<meta name="twitter:description" content="TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go实现HTTP长连接和短连接",
      "item": "/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go实现HTTP长连接和短连接",
  "name": "Go实现HTTP长连接和短连接",
  "description": "TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕",
  "keywords": [
    "Go"
  ],
  "articleBody": "TCP的长连接与短连接 Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕的服务器资源浪费。会使得服务器可服务的客户端数量大幅度减少。\n而TCP频繁的建立连接，会有一些问题：\n 三次握手建立连接、四次握手断开连接都会对性能有损耗； 断开的连接断开不会立刻释放，会等待2MSL的时间，据我观察是1分钟； 大量TIME_WAIT会占用内存，一个连接实测是3.155KB。而且占用太多，有可能会占满端口，一台服务器最多只能有6万多个端口；  因此，针对短链接和长连接，根据业务的需求，配套不同的处理机制。\n短连接\n一般建立完连接，就立刻传输数据。传输完数据，连接就关闭。服务端根据需要，设定连接的时长。超过时间长度，就算客户端超时。立刻关闭连接。\n长连接\n建立连接后，传输数据，然后要保持连接，然后再次传输数据。直到连接关闭。\nGo里可以利用下面的函数简单地开启长连接\n1  func (c *TCPConn) SetKeepAlive(keepalive bool) error   socket读写可以通过 SetDeadline、SetReadDeadline、SetWriteDeadline设置阻塞的时间。\n1 2 3 4 5 6  func (c *IPConn) SetDeadline(t time.Time) error func (c *IPConn) SetReadDeadline(t time.Time) error func (*IPConn) SetWriteDeadline func (c *IPConn) SetWriteDeadline(t time.Time) error   HTTP 包如何使用 TCP 连接？ http 服务器启动之后，会循环接受新请求，为每一个请求（连接）创建一个协程。\n1 2 3 4 5  // net/http/server.go L1892 for { rw, e := l.Accept() go c.serve() }   下面是每个协程的执行的代码，我只摘录了一部分关键的逻辑。可以发现，serve方法里面还有一个for循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // net/http/server.go L1320 func (c *conn) serve() { defer func() { if !c.hijacked() { c.close() } }() for { w, err := c.readRequest() if err != nil { } serverHandler{c.server}.ServeHTTP(w, w.req) } }   这个循环是用来做什么的？其实也容易理解，如果是长连接，一个协程可以执行多次响应。如果只执行了一次，那就是短连接。长连接会在超时或者出错后退出循环，也就是关闭长连接。defer函数可以让协程结束之后关闭 TCP 连接。\nreadRequest函数用来解析 HTTP 协议。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // net/http/server.go func (c *conn) readRequest() (w *response, err error) { if d := c.server.ReadTimeout; d != 0 { c.rwc.SetReadDeadline(time.Now().Add(d)) } if d := c.server.WriteTimeout; d != 0 { defer func() { c.rwc.SetWriteDeadline(time.Now().Add(d)) }() } if req, err = ReadRequest(c.buf.Reader); err != nil { if c.lr.N == 0 { return nil, errTooLarge } return nil, err } } func ReadRequest(b *bufio.Reader) (req *Request, err error) { // First line: GET /index.html HTTP/1.0 \tvar s string if s, err = tp.ReadLine(); err != nil { return nil, err } req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s) mimeHeader, err := tp.ReadMIMEHeader() }   具体参与解析 HTTP 协议的部分是ReadRequest方法，而调用它之前，设置了读写超时时间。超时时间设置的是绝对时间。所以这里都是通过time.Now().Add(d)来设置的。不同的是写超时是defer执行，也就是函数返回后才执行。\nGo实现HTTP短连接 如果做短连接，直接在Server端的连接上设置SetReadDeadline。当你设置的时限到达，无论客户端是否还在继续传递消息，服务端都不会再接收。并且已经关闭连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { server := \":7373\" netListen, err := net.Listen(\"tcp\", server) if err != nil{ Log(\"connect error: \", err) os.Exit(1) } Log(\"Waiting for Client ...\") for{ conn, err := netListen.Accept() if err != nil{ Log(conn.RemoteAddr().String(), \"Fatal error: \", err) continue } //设置短连接(10秒)  conn.SetReadDeadline(time.Now().Add(time.Duration(10)*time.Second)) Log(conn.RemoteAddr().String(), \"connect success!\") ... } }   这就可以了。在这段代码中，每当10秒中的时限一道，连接就终止了。\nGo实现HTTP长连接 SetKeepAlive GO 可以通过 net.TCPConn 的 SetKeepAlive 来启用 TCP keepalive。在 OS X 和 Linux 系统上，当一个连接空间了2个小时时，会以75秒的间隔发送8个TCP keepalive探测包。换句话说， 在两小时10分钟后(7200+8*75)Read将会返回一个 io.EOF 错误.\n对于你的应用，这个超时间隔可能太长了。在这种情况下你可以调用SetKeepAlivePeriod方法。但这个方法在不同的操作系统上会有不同的表现。在OSX上它会更改发送探测包前连接的空间时间。在Linux上它会更改连接的空间时间与探测包的发送间隔。所以以30秒的参数调用 SetKeepAlivePeriod在OSX系统上会导致共10分30秒(30+8*75)的超时时间，但在linux上却是4分30秒(30+8*30).\n当然，可以设置 http.Transport 的 DisableKeepAlives 来禁用掉持久连接。\n自行实现心跳协议 client每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。发包方可以是客户也可以是服务端..\n心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  //长连接入口 func handleConnection(conn net.Conn,timeout int) { buffer := make([]byte, 2048) for { n, err := conn.Read(buffer) if err != nil { LogErr(conn.RemoteAddr().String(), \" connection error: \", err) return } Data :=(buffer[:n]) messnager := make(chan byte) postda :=make(chan byte) //心跳计时 \tgo HeartBeating(conn,messnager,timeout) //检测每次Client是否有数据传来 \tgo GravelChannel(Data,messnager) Log( \"receive data length:\",n) Log(conn.RemoteAddr().String(), \"receive data string:\", string(Data } } //心跳计时，根据GravelChannel判断Client是否在设定时间内发来信息 func HeartBeating(conn net.Conn, readerChannel chan byte,timeout int) { select { case fk := readerChannel: Log(conn.RemoteAddr().String(), \"receive data string:\", string(fk)) conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second)) //conn.SetReadDeadline(time.Now().Add(time.Duration(5) * time.Second)) \tbreak case time.After(time.Second*5): Log(\"It's really weird to get Nothing!!!\") conn.Close() } } func GravelChannel(n []byte,mess chan byte){ for _ , v := range n{ mess  v } close(mess) } func Log(v ...interface{}) { log.Println(v...) }   这样，就可以成功实现对于长连接的处理了~~，我们可以这么进行测试：\n1 2 3 4 5 6 7 8 9  func sender(conn net.Conn) { for i := 0; i 5; i++ { words:= strconv.Itoa(i)+\"This is a test for long conn\" conn.Write([]byte(words)) time.Sleep(2*time.Second) } fmt.Println(\"send over\") }   可以发现，Sender函数中time.Sleep阻塞的时间设定的比Server中的timeout短的时候，Client端的信息可以自由的发送到循环结束，而当我们设定Sender函数的阻塞时间较长时，就只能发出第一次循环的信息。\n参考:\nhttps://blog.csdn.net/lengyuezuixue/article/details/79235850\nhttp://blog.cyeam.com/golang/2017/05/31/go-http-keepalive\nhttps://blog.csdn.net/u010824081/article/details/78108984\n",
  "wordCount" : "2274",
  "inLanguage": "zh-cn",
  "datePublished": "2018-12-13T15:33:35Z",
  "dateModified": "2018-12-13T15:33:35Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E5%AE%9E%E7%8E%B0http%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go实现HTTP长连接和短连接
    </h1>
    <div class="post-meta">December 13, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="tcp的长连接与短连接">TCP的长连接与短连接<a hidden class="anchor" aria-hidden="true" href="#tcp的长连接与短连接">#</a></h1>
<p>Server和Client建立通讯后，确保连接的及时断开就非常重要。否则，多个客户端长时间占用着连接不关闭，是非常可怕的服务器资源浪费。会使得服务器可服务的客户端数量大幅度减少。</p>
<p>而TCP频繁的建立连接，会有一些问题：</p>
<ul>
<li>三次握手建立连接、四次握手断开连接都会对性能有损耗；</li>
<li>断开的连接断开不会立刻释放，会等待2MSL的时间，据我观察是1分钟；</li>
<li>大量TIME_WAIT会占用内存，一个连接实测是3.155KB。而且占用太多，有可能会占满端口，一台服务器最多只能有6万多个端口；</li>
</ul>
<p>因此，针对短链接和长连接，根据业务的需求，配套不同的处理机制。</p>
<p>短连接</p>
<p>一般建立完连接，就立刻传输数据。传输完数据，连接就关闭。服务端根据需要，设定连接的时长。超过时间长度，就算客户端超时。立刻关闭连接。</p>
<p>长连接</p>
<p>建立连接后，传输数据，然后要保持连接，然后再次传输数据。直到连接关闭。</p>
<p>Go里可以利用下面的函数简单地开启长连接</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">TCPConn</span><span class="p">)</span> <span class="nf">SetKeepAlive</span><span class="p">(</span><span class="nx">keepalive</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>socket读写可以通过 SetDeadline、SetReadDeadline、SetWriteDeadline设置阻塞的时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">IPConn</span><span class="p">)</span> <span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">error</span>  
  
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">IPConn</span><span class="p">)</span> <span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">error</span>  
  
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IPConn</span><span class="p">)</span> <span class="nx">SetWriteDeadline</span>  
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">IPConn</span><span class="p">)</span> <span class="nf">SetWriteDeadline</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">error</span> 
</code></pre></td></tr></table>
</div>
</div><h1 id="http-包如何使用-tcp-连接">HTTP 包如何使用 TCP 连接？<a hidden class="anchor" aria-hidden="true" href="#http-包如何使用-tcp-连接">#</a></h1>
<p>http 服务器启动之后，会循环接受新请求，为每一个请求（连接）创建一个协程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// net/http/server.go L1892
</span><span class="c1"></span><span class="k">for</span> <span class="p">{</span>
	<span class="nx">rw</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
	<span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nf">serve</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是每个协程的执行的代码，我只摘录了一部分关键的逻辑。可以发现，serve方法里面还有一个for循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// net/http/server.go L1320
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">serve</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">hijacked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">readRequest</span><span class="p">()</span>
		
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="p">}</span>
		
		<span class="nx">serverHandler</span><span class="p">{</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">}.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个循环是用来做什么的？其实也容易理解，如果是长连接，一个协程可以执行多次响应。如果只执行了一次，那就是短连接。长连接会在超时或者出错后退出循环，也就是关闭长连接。defer函数可以让协程结束之后关闭 TCP 连接。</p>
<p>readRequest函数用来解析 HTTP 协议。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// net/http/server.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">readRequest</span><span class="p">()</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">ReadTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">WriteTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetWriteDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">ReadRequest</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">buf</span><span class="p">.</span><span class="nx">Reader</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">lr</span><span class="p">.</span><span class="nx">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTooLarge</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ReadRequest</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// First line: GET /index.html HTTP/1.0
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">tp</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	
	<span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Proto</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nf">parseRequestLine</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	
	<span class="nx">mimeHeader</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tp</span><span class="p">.</span><span class="nf">ReadMIMEHeader</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体参与解析 HTTP 协议的部分是ReadRequest方法，而调用它之前，设置了读写超时时间。超时时间设置的是绝对时间。所以这里都是通过time.Now().Add(d)来设置的。不同的是写超时是defer执行，也就是函数返回后才执行。</p>
<h1 id="go实现http短连接">Go实现HTTP短连接<a hidden class="anchor" aria-hidden="true" href="#go实现http短连接">#</a></h1>
<p>如果做短连接，直接在Server端的连接上设置SetReadDeadline。当你设置的时限到达，无论客户端是否还在继续传递消息，服务端都不会再接收。并且已经关闭连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">server</span> <span class="o">:=</span> <span class="s">&#34;:7373&#34;</span>
    <span class="nx">netListen</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">server</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nf">Log</span><span class="p">(</span><span class="s">&#34;connect error: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">Log</span><span class="p">(</span><span class="s">&#34;Waiting for Client ...&#34;</span><span class="p">)</span>
    <span class="k">for</span><span class="p">{</span>
        <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">netListen</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
            <span class="nf">Log</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34;Fatal error: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="c1">//设置短连接(10秒)
</span><span class="c1"></span>        <span class="nx">conn</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">))</span>

        <span class="nf">Log</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34;connect success!&#34;</span><span class="p">)</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这就可以了。在这段代码中，每当10秒中的时限一道，连接就终止了。</p>
<h1 id="go实现http长连接">Go实现HTTP长连接<a hidden class="anchor" aria-hidden="true" href="#go实现http长连接">#</a></h1>
<h2 id="setkeepalive">SetKeepAlive<a hidden class="anchor" aria-hidden="true" href="#setkeepalive">#</a></h2>
<p>GO 可以通过 net.TCPConn 的 SetKeepAlive 来启用 TCP keepalive。在 OS X 和 Linux 系统上，当一个连接空间了2个小时时，会以75秒的间隔发送8个TCP keepalive探测包。换句话说， 在两小时10分钟后(7200+8*75)Read将会返回一个 io.EOF 错误.</p>
<p>对于你的应用，这个超时间隔可能太长了。在这种情况下你可以调用SetKeepAlivePeriod方法。但这个方法在不同的操作系统上会有不同的表现。在OSX上它会更改发送探测包前连接的空间时间。在Linux上它会更改连接的空间时间与探测包的发送间隔。所以以30秒的参数调用 SetKeepAlivePeriod在OSX系统上会导致共10分30秒(30+8*75)的超时时间，但在linux上却是4分30秒(30+8*30).</p>
<p>当然，可以设置 http.Transport 的 DisableKeepAlives 来禁用掉持久连接。</p>
<h2 id="自行实现心跳协议">自行实现心跳协议<a hidden class="anchor" aria-hidden="true" href="#自行实现心跳协议">#</a></h2>
<p>client每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。发包方可以是客户也可以是服务端..</p>
<p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//长连接入口
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">handleConnection</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span><span class="nx">timeout</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">LogErr</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34; connection error: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">Data</span> <span class="o">:=</span><span class="p">(</span><span class="nx">buffer</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
		<span class="nx">messnager</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">byte</span><span class="p">)</span>
		<span class="nx">postda</span> <span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">byte</span><span class="p">)</span>
		<span class="c1">//心跳计时
</span><span class="c1"></span>		<span class="k">go</span> <span class="nf">HeartBeating</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span><span class="nx">messnager</span><span class="p">,</span><span class="nx">timeout</span><span class="p">)</span>
		<span class="c1">//检测每次Client是否有数据传来
</span><span class="c1"></span>		<span class="k">go</span> <span class="nf">GravelChannel</span><span class="p">(</span><span class="nx">Data</span><span class="p">,</span><span class="nx">messnager</span><span class="p">)</span>
		<span class="nf">Log</span><span class="p">(</span> <span class="s">&#34;receive data length:&#34;</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
		<span class="nf">Log</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34;receive data string:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">Data</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//心跳计时，根据GravelChannel判断Client是否在设定时间内发来信息
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HeartBeating</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">readerChannel</span> <span class="kd">chan</span> <span class="kt">byte</span><span class="p">,</span><span class="nx">timeout</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">fk</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">readerChannel</span><span class="p">:</span>
			<span class="nf">Log</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">RemoteAddr</span><span class="p">().</span><span class="nf">String</span><span class="p">(),</span> <span class="s">&#34;receive data string:&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">fk</span><span class="p">))</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">SetDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">))</span>
			<span class="c1">//conn.SetReadDeadline(time.Now().Add(time.Duration(5) * time.Second))
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">5</span><span class="p">):</span>
			<span class="nf">Log</span><span class="p">(</span><span class="s">&#34;It&#39;s really weird to get Nothing!!!&#34;</span><span class="p">)</span>
			<span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GravelChannel</span><span class="p">(</span><span class="nx">n</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span><span class="nx">mess</span> <span class="kd">chan</span> <span class="kt">byte</span><span class="p">){</span>
	<span class="k">for</span> <span class="nx">_</span> <span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">{</span>
		<span class="nx">mess</span> <span class="o">&lt;-</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">mess</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">Log</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，就可以成功实现对于长连接的处理了~~，我们可以这么进行测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sender</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">words</span><span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">+</span><span class="s">&#34;This is a test for long conn&#34;</span> 
		<span class="nx">conn</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">words</span><span class="p">))</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;send over&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以发现，Sender函数中time.Sleep阻塞的时间设定的比Server中的timeout短的时候，Client端的信息可以自由的发送到循环结束，而当我们设定Sender函数的阻塞时间较长时，就只能发出第一次循环的信息。</p>
<p>参考:<br>
<a href="https://blog.csdn.net/lengyuezuixue/article/details/79235850">https://blog.csdn.net/lengyuezuixue/article/details/79235850</a><br>
<a href="http://blog.cyeam.com/golang/2017/05/31/go-http-keepalive">http://blog.cyeam.com/golang/2017/05/31/go-http-keepalive</a><br>
<a href="https://blog.csdn.net/u010824081/article/details/78108984">https://blog.csdn.net/u010824081/article/details/78108984</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
