<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>并发原语sync-Once源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="Once 很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-once%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="并发原语sync-Once源码剖析" />
<meta property="og:description" content="Once 很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-once%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-21T14:36:14&#43;00:00" />
<meta property="article:modified_time" content="2021-05-21T14:36:14&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并发原语sync-Once源码剖析"/>
<meta name="twitter:description" content="Once 很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "并发原语sync-Once源码剖析",
      "item": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-once%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "并发原语sync-Once源码剖析",
  "name": "并发原语sync-Once源码剖析",
  "description": "Once 很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "Once 很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问题,就是如果参数 f 执行很慢的话,后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了,但是获取某些初始化资源的时候可能会得到空的资源,因为 f 还没有执行完。\n所以,一个正确的 Once 实现要使用一个互斥锁,这样初始化的时候如果有并发的 goroutine,就会进入doSlow 方法。互斥锁的机制保证只有一个 goroutine 进行初始化,同时利用双检查的机制(double-checking),再次判断 o.done 是否为 0,如果为 0,则是第一次执行,执行完毕后,就将 o.done 设置为 1,然后释放锁。\n即使此时有多个 goroutine 同时进入了 doSlow 方法,因为双检查的机制,后续的 goroutine 会看到 o.done 的值为 1,也不会再次执行 f。\n这样既保证了并发的 goroutine 会等待 f 完成,而且还不会多次执行 f。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  // Once is an object that will perform exactly one action. // Once 对象可以保证一个动作的绝对一次执行。 type Once struct { // done indicates whether the action has been performed. \t// It is first in the struct because it is used in the hot path. \t// The hot path is inlined at every call site. \t// Placing done first allows more compact instructions on some architectures (amd64/x86), \t// and fewer instructions (to calculate offset) on other architectures. \t// done 表明某个动作是否被执行 \t// 由于其使用频繁（热路径），故将其放在结构体的最上方 \t// 热路径在每个调用点进行内嵌 \t// 将 done 放在第一位，在某些架构下（amd64/x86）能获得更加紧凑的指令， \t// 而在其他架构下能更少的指令（用于计算其偏移量）。 \tdone uint32 m Mutex } // Do calls the function f if and only if Do is being called for the // first time for this instance of Once. In other words, given // var once Once // if once.Do(f) is called multiple times, only the first call will invoke f, // even if f has a different value in each invocation. A new instance of // Once is required for each function to execute. // // Do is intended for initialization that must be run exactly once. Since f // is niladic, it may be necessary to use a function literal to capture the // arguments to a function to be invoked by Do: // config.once.Do(func() { config.init(filename) }) // // Because no call to Do returns until the one call to f returns, if f causes // Do to be called, it will deadlock. // // If f panics, Do considers it to have returned; future calls of Do return // without calling f. // // Do 当且仅当第一次调用时，f 会被执行。换句话说，给定 // var once Once // 如果 once.Do(f) 被多次调用则只有第一次会调用 f，即使每次提供的 f 不同。 // 每次执行必须新建一个 Once 实例。 // // Do 用于变量的一次初始化，由于 f 是无参数的，因此有必要使用函数字面量来捕获参数： // config.once.Do(func() { config.init(filename) }) // // 因为该调用无返回值，因此如果 f 调用了 Do，则会导致死锁。 // // 如果 f 发生 panic，则 Do 认为 f 已经返回；之后的调用也不会调用 f。 // func (o *Once) Do(f func()) { // Note: Here is an incorrect implementation of Do: \t// \t//\tif atomic.CompareAndSwapUint32(\u0026o.done, 0, 1) { \t//\tf() \t//\t} \t// \t// Do guarantees that when it returns, f has finished. \t// This implementation would not implement that guarantee: \t// given two simultaneous calls, the winner of the cas would \t// call f, and the second would return immediately, without \t// waiting for the first's call to f to complete. \t// This is why the slow path falls back to a mutex, and why \t// the atomic.StoreUint32 must be delayed until after f returns. \t// 原子读取 Once 内部的 done 属性，是否为 0，是则进入慢速路径，否则直接调用 \tif atomic.LoadUint32(\u0026o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. \to.doSlow(f) } } func (o *Once) doSlow(f func()) { // 注意，我们只使用原子读读取了 o.done 的值，这是最快速的路径执行原子操作，即 fast-path \t// 但当我们需要确保在并发状态下，是不是有多个人读到 0，因此必须加锁，这个操作相对昂贵，即 slow-path \to.m.Lock() defer o.m.Unlock() // 双检查 \t// 正好我们有一个并发的 goroutine 读到了 0，那么立即执行 f 并在结束时候调用原子写，将 o.done 修改为 1 \tif o.done == 0 { defer atomic.StoreUint32(\u0026o.done, 1) f() } // 当 o.done 为 0 的 goroutine 解锁后，其他人会继续加锁，这时会发现 o.done 已经为了 1 ，于是 f 已经不用在继续执行了 }   有的同学不太理解为什么要使用Mutex。\n使用Mutex并不会影响这个数据结构的性能。因为Mutex的逻辑(也就是doSlow方法)只会在初始化时并发的情况下发生，一旦初始化完成，后续的goroutine在调用Do方法时并不会请求锁。\n所以，使用Mutex主要处理并发初始化的问题。\n假设Once对象的Do方法还没有被初次调用。这个时候有goroutine g2和goroutine g3同时调用Do方法。碰巧，g2和g3可能原子读取done变量会等于0,所以这两个goroutine可能都会同时进入doSlow方法(可能在同一个CPU上，也可能在不同的cpu上)。\n这个时候我们就需要Mutex限制只允许一个goroutine并发执行，也就是将并行变成了串行。假设g2运气好先执行，那么它就会进行初始化，并且执行完毕后把o.done设置为1,再释放锁。\n锁释放后，g3开始执行，这个时候还会执行double checking,再一次检查done字段。这一步是必须的，因为不双检查的话，它又会执行f一次。这里正确地使用了双检查，发现done已经被设置成了1,所以不需要初始化了，就直接返回。\n如果一个goroutine在双检查的时候如果发现done=0,说明还没有goroutine执行过初始化，这种重担压在了自己的身上，就像g2一样，它就会执行初始化函数f。\n所以，这里使用了Mutex,保护并发的初始化。\n我们知道，现代的CPU都是支持乱序执行的。那么最后两行defer atomic.StoreUint32(\u0026o.done, 1)和f()如果乱序了怎么办，那不也是还是没有初始化完毕就把done设置为1了吗？\n而且有些人，包括Russ Cox review这段代码的时候也提出，defer atomic.StoreUint32(\u0026o.done, 1) (源代码和此有所不同)能不能改成o.done=1。\nGo的标准库的代码质量是非常高的，而且都经过大神的仔细review,所以这样设计肯定是有它的用处的。\n首先，第15行的defer atomic.StoreUint32(\u0026o.done, 1)可以确保执行完第16行的f才将done设置为1。\nIan Lance Taylor曾经在论坛中说:\nIn C++ memory model terms I believe that the sync/atomic Load operations are memory_order_acquire, and I believe that the sync/atomic Store operations are memory_order_release. It’s possible that if we ever document it we will go for stronger memory ordering, but I believe that these operations must at least carry those guarantees.\nI’m somewhat less certain of the memory order guarantees of the Swap, CompareAndSwap, and Add functions. I guess that Swap and CompareAndSwap are probably at least memory_order_acq_rel, but Add may be memory_order_relaxed.\nRuss Cox曾经回答过问题,他把go的atomic 操作定位sequential consistency的，这是一个更严格的memory ordering。它们之前的读写操作,不会重排在Load/Store之后， 它们之后的读写操作也不会重排在Load/Store之前，所以建立了一个内存屏障(Memory barrier)。\nrsc 2019年7月16日上午9:12:01\nAlthough there’s been no official resolution to the issue, I think the actual path forward is what I posted a while back: “Go’s atomics guarantee sequential consistency among the atomic variables (behave like C/C++’s seqconst atomics), and that you shouldn’t mix atomic and non-atomic accesses for a given memory word.”\n至少目前，我们可以按照他们的解答进行理解。\n这样的话，Go可以保证第15行defer atomic.StoreUint32(\u0026o.done, 1)肯定会在第16行f()之后执行，这样就不会出现未初始化完成就将done设置为1的问题。\n另一个问题，第14行为什么不使用atomic?\n因为Mutex的happend before关系， g2设置o.done=1之后才释放锁，这个时候g3才获取到锁，所以当g3获取到锁之后，o.done肯定就已经是1了，所以这个时候访问o.done肯定得到1的结果，不会在g2设置o.done=1 g3看不到o.done=1这个write。\n第6行没有Mutex等的保护，所以通过atomic可以保证在o.done设置为1之后能看到这个设置的结果，避免总是落入到doSlow逻辑中。\n参考 https://colobu.com/2017/07/11/dive-into-sync-Map\nhttps://segmentfault.com/a/1190000015242373\nhttps://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/\nhttp://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html\nhttp://www.gogodjzhu.com/index.php/code/basic/397/\nhttp://russellluo.com/2017/06/go-sync-map-diagram.html\n5.4 条件变量\n5.5 同步组\nGo 标准库源码分析 - sync 包的Pool\n5.7 并发安全散列表\n6.1 上下文 Context\ngo context剖析之源码分析\n5.3 原子操作\nGo sync.Once的三重门\n",
  "wordCount" : "2897",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-21T14:36:14Z",
  "dateModified": "2021-05-21T14:36:14Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-once%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      并发原语sync-Once源码剖析
    </h1>
    <div class="post-meta">May 21, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="once">Once<a hidden class="anchor" aria-hidden="true" href="#once">#</a></h2>
<p>很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问题,就是如果参数 f 执行很慢的话,后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了,但是获取某些初始化资源的时候可能会得到空的资源,因为 f 还没有执行完。</p>
<p>所以,一个正确的 Once 实现要使用一个互斥锁,这样初始化的时候如果有并发的 goroutine,就会进入doSlow 方法。互斥锁的机制保证只有一个 goroutine 进行初始化,同时利用双检查的机制(double-checking),再次判断 o.done 是否为 0,如果为 0,则是第一次执行,执行完毕后,就将 o.done 设置为 1,然后释放锁。</p>
<p>即使此时有多个 goroutine 同时进入了 doSlow 方法,因为双检查的机制,后续的 goroutine 会看到 o.done 的值为 1,也不会再次执行 f。</p>
<p>这样既保证了并发的 goroutine 会等待 f 完成,而且还不会多次执行 f。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Once is an object that will perform exactly one action.
</span><span class="c1">// Once 对象可以保证一个动作的绝对一次执行。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// done indicates whether the action has been performed.
</span><span class="c1"></span>	<span class="c1">// It is first in the struct because it is used in the hot path.
</span><span class="c1"></span>	<span class="c1">// The hot path is inlined at every call site.
</span><span class="c1"></span>	<span class="c1">// Placing done first allows more compact instructions on some architectures (amd64/x86),
</span><span class="c1"></span>	<span class="c1">// and fewer instructions (to calculate offset) on other architectures.
</span><span class="c1"></span>	<span class="c1">// done 表明某个动作是否被执行
</span><span class="c1"></span>	<span class="c1">// 由于其使用频繁（热路径），故将其放在结构体的最上方
</span><span class="c1"></span>	<span class="c1">// 热路径在每个调用点进行内嵌
</span><span class="c1"></span>	<span class="c1">// 将 done 放在第一位，在某些架构下（amd64/x86）能获得更加紧凑的指令，
</span><span class="c1"></span>	<span class="c1">// 而在其他架构下能更少的指令（用于计算其偏移量）。
</span><span class="c1"></span>	<span class="nx">done</span> <span class="kt">uint32</span>
	<span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>

<span class="c1">// Do calls the function f if and only if Do is being called for the
</span><span class="c1">// first time for this instance of Once. In other words, given
</span><span class="c1">// 	var once Once
</span><span class="c1">// if once.Do(f) is called multiple times, only the first call will invoke f,
</span><span class="c1">// even if f has a different value in each invocation. A new instance of
</span><span class="c1">// Once is required for each function to execute.
</span><span class="c1">//
</span><span class="c1">// Do is intended for initialization that must be run exactly once. Since f
</span><span class="c1">// is niladic, it may be necessary to use a function literal to capture the
</span><span class="c1">// arguments to a function to be invoked by Do:
</span><span class="c1">// 	config.once.Do(func() { config.init(filename) })
</span><span class="c1">//
</span><span class="c1">// Because no call to Do returns until the one call to f returns, if f causes
</span><span class="c1">// Do to be called, it will deadlock.
</span><span class="c1">//
</span><span class="c1">// If f panics, Do considers it to have returned; future calls of Do return
</span><span class="c1">// without calling f.
</span><span class="c1">//
</span><span class="c1">// Do 当且仅当第一次调用时，f 会被执行。换句话说，给定
</span><span class="c1">// 	var once Once
</span><span class="c1">// 如果 once.Do(f) 被多次调用则只有第一次会调用 f，即使每次提供的 f 不同。
</span><span class="c1">// 每次执行必须新建一个 Once 实例。
</span><span class="c1">//
</span><span class="c1">// Do 用于变量的一次初始化，由于 f 是无参数的，因此有必要使用函数字面量来捕获参数：
</span><span class="c1">// 	config.once.Do(func() { config.init(filename) })
</span><span class="c1">//
</span><span class="c1">// 因为该调用无返回值，因此如果 f 调用了 Do，则会导致死锁。
</span><span class="c1">//
</span><span class="c1">// 如果 f 发生 panic，则 Do 认为 f 已经返回；之后的调用也不会调用 f。
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// Note: Here is an incorrect implementation of Do:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {
</span><span class="c1"></span>	<span class="c1">//		f()
</span><span class="c1"></span>	<span class="c1">//	}
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do guarantees that when it returns, f has finished.
</span><span class="c1"></span>	<span class="c1">// This implementation would not implement that guarantee:
</span><span class="c1"></span>	<span class="c1">// given two simultaneous calls, the winner of the cas would
</span><span class="c1"></span>	<span class="c1">// call f, and the second would return immediately, without
</span><span class="c1"></span>	<span class="c1">// waiting for the first&#39;s call to f to complete.
</span><span class="c1"></span>	<span class="c1">// This is why the slow path falls back to a mutex, and why
</span><span class="c1"></span>	<span class="c1">// the atomic.StoreUint32 must be delayed until after f returns.
</span><span class="c1"></span>	<span class="c1">// 原子读取 Once 内部的 done 属性，是否为 0，是则进入慢速路径，否则直接调用
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Outlined slow-path to allow inlining of the fast-path.
</span><span class="c1"></span>		<span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// 注意，我们只使用原子读读取了 o.done 的值，这是最快速的路径执行原子操作，即 fast-path
</span><span class="c1"></span>	<span class="c1">// 但当我们需要确保在并发状态下，是不是有多个人读到 0，因此必须加锁，这个操作相对昂贵，即 slow-path
</span><span class="c1"></span>	<span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 双检查
</span><span class="c1"></span>	<span class="c1">// 正好我们有一个并发的 goroutine 读到了 0，那么立即执行 f 并在结束时候调用原子写，将 o.done 修改为 1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nf">f</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 当 o.done 为 0 的 goroutine 解锁后，其他人会继续加锁，这时会发现 o.done 已经为了 1 ，于是 f 已经不用在继续执行了
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有的同学不太理解为什么要使用Mutex。</p>
<p>使用Mutex并不会影响这个数据结构的性能。因为Mutex的逻辑(也就是doSlow方法)只会在初始化时并发的情况下发生，一旦初始化完成，后续的goroutine在调用Do方法时并不会请求锁。</p>
<p>所以，使用Mutex主要处理并发初始化的问题。</p>
<p>假设Once对象的Do方法还没有被初次调用。这个时候有goroutine g2和goroutine g3同时调用Do方法。碰巧，g2和g3可能原子读取done变量会等于0,所以这两个goroutine可能都会同时进入doSlow方法(可能在同一个CPU上，也可能在不同的cpu上)。</p>
<p>这个时候我们就需要Mutex限制只允许一个goroutine并发执行，也就是将并行变成了串行。假设g2运气好先执行，那么它就会进行初始化，并且执行完毕后把o.done设置为1,再释放锁。</p>
<p>锁释放后，g3开始执行，这个时候还会执行double checking,再一次检查done字段。这一步是必须的，因为不双检查的话，它又会执行f一次。这里正确地使用了双检查，发现done已经被设置成了1,所以不需要初始化了，就直接返回。</p>
<p>如果一个goroutine在双检查的时候如果发现done=0,说明还没有goroutine执行过初始化，这种重担压在了自己的身上，就像g2一样，它就会执行初始化函数f。</p>
<p>所以，这里使用了Mutex,保护并发的初始化。</p>
<p>我们知道，现代的CPU都是支持乱序执行的。那么最后两行<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>和<code>f()</code>如果乱序了怎么办，那不也是还是没有初始化完毕就把done设置为1了吗？</p>
<p>而且有些人，包括Russ Cox review这段代码的时候也提出，<code>defer atomic.StoreUint32(&amp;o.done, 1)</code> (源代码和此有所不同)能不能改成<code>o.done=1</code>。</p>
<p>Go的标准库的代码质量是非常高的，而且都经过大神的仔细review,所以这样设计肯定是有它的用处的。</p>
<p>首先，第15行的<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>可以确保执行完第16行的f才将done设置为1。</p>
<p>Ian Lance Taylor曾经在论坛中说:</p>
<p>In C++ memory model terms I believe that the sync/atomic Load
operations are memory_order_acquire, and I believe that the
sync/atomic Store operations are memory_order_release. It&rsquo;s possible
that if we ever document it we will go for stronger memory ordering,
but I believe that these operations must at least carry those guarantees.</p>
<p>I&rsquo;m somewhat less certain of the memory order guarantees of the Swap,
CompareAndSwap, and Add functions. I guess that Swap and
CompareAndSwap are probably at least memory_order_acq_rel, but Add may
be memory_order_relaxed.</p>
<p>Russ Cox曾经回答过问题,他把go的atomic 操作定位sequential consistency的，这是一个更严格的memory ordering。它们之前的读写操作,不会重排在Load/Store之后， 它们之后的读写操作也不会重排在Load/Store之前，所以建立了一个内存屏障(Memory barrier)。</p>
<p>rsc
2019年7月16日上午9:12:01</p>
<p>Although there&rsquo;s been no official resolution to the issue, I think the actual path forward is what I posted a while back: &ldquo;Go&rsquo;s atomics guarantee sequential consistency among the atomic variables (behave like C/C++&rsquo;s seqconst atomics), and that you shouldn&rsquo;t mix atomic and non-atomic accesses for a given memory word.&rdquo;</p>
<p>至少目前，我们可以按照他们的解答进行理解。</p>
<p>这样的话，Go可以保证第15行<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>肯定会在第16行f<code>()</code>之后执行，这样就不会出现未初始化完成就将done设置为1的问题。</p>
<p>另一个问题，第14行为什么不使用atomic?</p>
<p>因为Mutex的happend before关系， g2设置<code>o.done=1</code>之后才释放锁，这个时候g3才获取到锁，所以当g3获取到锁之后，<code>o.done</code>肯定就已经是1了，所以这个时候访问o.done肯定得到1的结果，不会在g2设置<code>o.done=1</code> g3看不到<code>o.done=1</code>这个write。</p>
<p>第6行没有Mutex等的保护，所以通过atomic可以保证在o.done设置为1之后能看到这个设置的结果，避免总是落入到doSlow逻辑中。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://colobu.com/2017/07/11/dive-into-sync-Map">https://colobu.com/2017/07/11/dive-into-sync-Map</a></p>
<p><a href="https://segmentfault.com/a/1190000015242373">https://segmentfault.com/a/1190000015242373</a></p>
<p><a href="https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/">https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/</a></p>
<p><a href="http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html">http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html</a></p>
<p><a href="http://www.gogodjzhu.com/index.php/code/basic/397/">http://www.gogodjzhu.com/index.php/code/basic/397/</a></p>
<p><a href="http://russellluo.com/2017/06/go-sync-map-diagram.html">http://russellluo.com/2017/06/go-sync-map-diagram.html</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/cond/">5.4 条件变量</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/waitgroup/">5.5 同步组</a></p>
<p><a href="https://blog.csdn.net/sinat_41790904/article/details/115416237">Go 标准库源码分析 - sync 包的Pool</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/map/">5.7 并发安全散列表</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">6.1 上下文 Context</a></p>
<p><a href="https://juejin.cn/post/6844903741842259975">go context剖析之源码分析</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/atomic/">5.3 原子操作</a></p>
<p><a href="https://colobu.com/2021/05/05/triple-gates-of-sync-Once/">Go sync.Once的三重门</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
