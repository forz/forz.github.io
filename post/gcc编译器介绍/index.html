<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GCC编译器介绍 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现">
<meta name="author" content="">
<link rel="canonical" href="/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="GCC编译器介绍" />
<meta property="og:description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T14:19:06&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T14:19:06&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GCC编译器介绍"/>
<meta name="twitter:description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "GCC编译器介绍",
      "item": "/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GCC编译器介绍",
  "name": "GCC编译器介绍",
  "description": "gcc命令 gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现",
  "keywords": [
    
  ],
  "articleBody": "gcc命令 gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。\n语法 gcc(选项)(参数)  选项 -v / –v / –version 查看gcc版本号\n-I目录 指定头文件目录，注意-I和目录之间没有空格\n-o：指定生成的输出文件；\n-c 只编译，生成.o文件，不进行链接\n-g 包含调试信息，若要使用GDB调试，必须加此选项\n-On n=1~3 编译优化，n越大优化的越多\n-Wall 提示更多告警信息（严格编译)\n-D 编译时定义宏，注意-D和之间没有空格\n-E 生成预处理文件，一般是.i文件,(展开头文件，替换宏常量)\n-M 生成.c文件与头文件依赖关系以用于Makefile，包括系统库的头文件\n-MM 生成.c文件与头文件依赖关系以用于Makefile，不包括系统库的头文件\n参数 C源文件：指定C语言源代码文件。\n##GCC优化级别\nGCC -O选项 这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。\n-O设置一共有五种：-O0、-O1、-O2、-O3和-Os。你只能在/etc/make.conf里面设置其中的一种。 除了-O0以外，每一个-O设置都会多启用几个选项，请查阅gcc手册的优化选项章节，以便了解每个-O等级启用了哪些选项及它们有何作用。\n让我们来逐一考察各个优化等级：\n-O0：这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置-O等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。\n-O1：这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。\n-O2：-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。\n-O3：这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。这样做将得不偿失，记住过犹不及。在gcc 4.x.中使用-O3是不推荐的。\n-Os：这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。\nGCC调试级别 如果不打开-g或者-ggdb(GDB专用)调试开关，GCC编译时不会加入调试信息，因为这会增大生成代码的体积。\nGCC采用了分级调试，通过在-g选项后附加数字1、2或3来指定在代码中加入调试信息量。\n默认的级别是2（-g2），此时调试信息包括扩展的符号表、行号、局部或外部变量信息。级别3（- g3）包含级别2中的调试信息和源代码中定义的宏。级别1（-g1）不包含局部变量和与行号有关的调试信息，只能用于回溯跟踪和堆栈转储之用。s\n【回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段。】\n实例 常用编译命令选项 假设源程序文件名为test.c\n无选项编译链接\ngcc test.c  将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。\n选项 -o\ngcc test.c -o test  将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。\n选项 -E\ngcc -E test.c -o test.i  将test.c预处理输出test.i文件。\n选项 -S\ngcc -S test.i  将预处理输出文件test.i汇编成test.s文件。\n选项 -c\ngcc -c test.s  将汇编输出文件test.s编译输出test.o文件。\n无选项链接\ngcc test.o -o test  将编译输出文件test.o链接成最终可执行文件test。\n选项 -O\ngcc -O1 test.c -o test  使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。\n多源文件的编译方法 如果有多个源文件，基本上有两种编译方法：\n假设有两个源文件为test.c和testfun.c 多个文件一起编译\ngcc testfun.c test.c -o test  将testfun.c和test.c分别编译后链接成test可执行文件。\n分别编译各个源文件，之后对编译后输出的目标文件链接。\ngcc -c testfun.c #将testfun.c编译成testfun.o gcc -c test.c #将test.c编译成test.o gcc -o testfun.o test.o -o test #将testfun.o和test.o链接成test  以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。\nGCC的检错功能 gcc -pedantic illcode.c -o illcode  -pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。\n除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。\ngcc -Wall illcode.c -o illcode  GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：\ngcc -Werror test.c -o test  库文件连接 开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。\n虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。\n例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so\n其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib\n  编译成可执行文件\n首先我们要进行编译test.c为目标文件，这个时候需要执行\n gcc –c –I /usr/dev/mysql/include test.c –o test.o    链接\n最后我们把所有目标文件链接成可执行文件:\n gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test  Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。\n  强制链接时使用静态链接库\n默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。\n在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:\n gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test    静态库链接时搜索路径顺序  ld会去找GCC命令中的参数-L 再找gcc的环境变量LIBRARY_PATH 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的  动态链接时、执行时搜索路径顺序:  编译目标代码时指定的动态库搜索路径 环境变量LD_LIBRARY_PATH指定的动态库搜索路径 配置文件/etc/ld.so.conf中指定的动态库搜索路径 默认的动态库搜索路径/lib 默认的动态库搜索路径/usr/lib  有关环境变量：\nLIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径\nLD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径\ngcc和g++的区别 GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。\ngcc是GCC中的GUN C Compiler（C 编译器）\ng++是GCC中的GUN C++ Compiler（C++编译器）\n一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：\nStep1：Call a preprocessor, like cpp.\nStep2：Call an actual compiler, like cc or cc1.\nStep3：Call an assembler, like as.\nStep4：Call a linker, like ld\n由于编译器是可以更换的，所以gcc不仅仅可以编译C文件\n所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler\ngcc和g++的主要区别   对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）\n  对于 .c和.cpp文件，g++则统一当做cpp文件编译\n  g++链接文件时，会自动链接标准库STL，而gcc不会自动链接STL\n  gcc在编译C文件时，可使用的预定义宏是比较少的,\n  【gcc在编译cpp文件时】或【g++在编译c文件和cpp文件时】（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：\n1 2 3 4 5 6  #define __GXX_WEAK__ 1 #define __cplusplus 1 #define __DEPRECATED 1 #define __GNUG__ 4 #define __EXCEPTIONS 1 #define __private_extern__ extern   ``\n  在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个\n  转载： http://man.linuxde.net/gcc http://blog.csdn.net/a312024054/article/details/46973995\n",
  "wordCount" : "4392",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T14:19:06Z",
  "dateModified": "2017-06-25T14:19:06Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      GCC编译器介绍
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="gcc命令">gcc命令<a hidden class="anchor" aria-hidden="true" href="#gcc命令">#</a></h1>
<p>gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。</p>
<h2 id="语法">语法<a hidden class="anchor" aria-hidden="true" href="#语法">#</a></h2>
<pre><code>gcc(选项)(参数) 
</code></pre>
<h2 id="选项">选项<a hidden class="anchor" aria-hidden="true" href="#选项">#</a></h2>
<p>-v / –v / –version 查看gcc版本号</p>
<p>-I目录 指定头文件目录，注意-I和目录之间没有空格</p>
<p>-o：指定生成的输出文件；</p>
<p>-c 只编译，生成.o文件，不进行链接</p>
<p>-g 包含调试信息，若要使用GDB调试，必须加此选项</p>
<p>-On n=1~3 编译优化，n越大优化的越多</p>
<p>-Wall 提示更多告警信息（严格编译)</p>
<p>-D 编译时定义宏，注意-D和之间没有空格</p>
<p>-E 生成预处理文件，一般是.i文件,(展开头文件，替换宏常量)</p>
<p>-M 生成.c文件与头文件依赖关系以用于Makefile，包括系统库的头文件</p>
<p>-MM 生成.c文件与头文件依赖关系以用于Makefile，不包括系统库的头文件</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170529203012.png" alt=""  />
</p>
<h2 id="参数">参数<a hidden class="anchor" aria-hidden="true" href="#参数">#</a></h2>
<p>C源文件：指定C语言源代码文件。</p>
<p>##GCC优化级别</p>
<h3 id="gcc--o选项">GCC -O选项<a hidden class="anchor" aria-hidden="true" href="#gcc--o选项">#</a></h3>
<p>这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。</p>
<p>-O设置一共有五种：-O0、-O1、-O2、-O3和-Os。你只能在/etc/make.conf里面设置其中的一种。
除了-O0以外，每一个-O设置都会多启用几个选项，请查阅gcc手册的优化选项章节，以便了解每个-O等级启用了哪些选项及它们有何作用。</p>
<p>让我们来逐一考察各个优化等级：</p>
<p>-O0：这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置-O等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。</p>
<p>-O1：这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。</p>
<p>-O2：-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。</p>
<p>-O3：这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。这样做将得不偿失，记住过犹不及。在gcc 4.x.中使用-O3是不推荐的。</p>
<p>-Os：这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。</p>
<h2 id="gcc调试级别">GCC调试级别<a hidden class="anchor" aria-hidden="true" href="#gcc调试级别">#</a></h2>
<p>如果不打开-g或者-ggdb(GDB专用)调试开关，GCC编译时不会加入调试信息，因为这会增大生成代码的体积。</p>
<p>GCC采用了分级调试，通过在-g选项后附加数字1、2或3来指定在代码中加入调试信息量。</p>
<p>默认的级别是2（-g2），此时调试信息包括扩展的符号表、行号、局部或外部变量信息。级别3（- g3）包含级别2中的调试信息和源代码中定义的宏。级别1（-g1）不包含局部变量和与行号有关的调试信息，只能用于回溯跟踪和堆栈转储之用。s</p>
<p>【回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段。】</p>
<h2 id="实例">实例<a hidden class="anchor" aria-hidden="true" href="#实例">#</a></h2>
<h3 id="常用编译命令选项">常用编译命令选项<a hidden class="anchor" aria-hidden="true" href="#常用编译命令选项">#</a></h3>
<p>假设源程序文件名为test.c</p>
<p>无选项编译链接</p>
<pre><code>gcc test.c 
</code></pre>
<p>将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。</p>
<p>选项 -o</p>
<pre><code>gcc test.c -o test 
</code></pre>
<p>将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。</p>
<p>选项 -E</p>
<pre><code>gcc -E test.c -o test.i 
</code></pre>
<p>将test.c预处理输出test.i文件。</p>
<p>选项 -S</p>
<pre><code>gcc -S test.i 
</code></pre>
<p>将预处理输出文件test.i汇编成test.s文件。</p>
<p>选项 -c</p>
<pre><code>gcc -c test.s 
</code></pre>
<p>将汇编输出文件test.s编译输出test.o文件。</p>
<p>无选项链接</p>
<pre><code>gcc test.o -o test 
</code></pre>
<p>将编译输出文件test.o链接成最终可执行文件test。</p>
<p>选项 -O</p>
<pre><code>gcc -O1 test.c -o test 
</code></pre>
<p>使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<h2 id="多源文件的编译方法">多源文件的编译方法<a hidden class="anchor" aria-hidden="true" href="#多源文件的编译方法">#</a></h2>
<p>如果有多个源文件，基本上有两种编译方法：</p>
<p>假设有两个源文件为test.c和testfun.c 多个文件一起编译</p>
<pre><code>gcc testfun.c test.c -o test 
</code></pre>
<p>将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<p>分别编译各个源文件，之后对编译后输出的目标文件链接。</p>
<pre><code>gcc -c testfun.c #将testfun.c编译成testfun.o 
gcc -c test.c #将test.c编译成test.o 
gcc -o testfun.o test.o -o test #将testfun.o和test.o链接成test 
</code></pre>
<p>以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。</p>
<h2 id="gcc的检错功能">GCC的检错功能<a hidden class="anchor" aria-hidden="true" href="#gcc的检错功能">#</a></h2>
<pre><code>gcc -pedantic illcode.c -o illcode
</code></pre>
<p>-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>
<p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。</p>
<pre><code>gcc -Wall illcode.c -o illcode
</code></pre>
<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p>
<pre><code>gcc -Werror test.c -o test
</code></pre>
<h2 id="库文件连接">库文件连接<a hidden class="anchor" aria-hidden="true" href="#库文件连接">#</a></h2>
<p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。</p>
<p>虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p>
<p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p>
<p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p>
<ol>
<li>
<p>编译成可执行文件</p>
<p>首先我们要进行编译test.c为目标文件，这个时候需要执行</p>
<pre><code> gcc –c –I /usr/dev/mysql/include test.c –o test.o
</code></pre>
</li>
<li>
<p>链接</p>
<p>最后我们把所有目标文件链接成可执行文件:</p>
<pre><code> gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test
</code></pre>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p>
</li>
<li>
<p>强制链接时使用静态链接库</p>
<p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:</p>
<pre><code> gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
</code></pre>
</li>
</ol>
<h3 id="静态库链接时搜索路径顺序">静态库链接时搜索路径顺序<a hidden class="anchor" aria-hidden="true" href="#静态库链接时搜索路径顺序">#</a></h3>
<ol>
<li>ld会去找GCC命令中的参数-L</li>
<li>再找gcc的环境变量LIBRARY_PATH</li>
<li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li>
</ol>
<h3 id="动态链接时执行时搜索路径顺序">动态链接时、执行时搜索路径顺序:<a hidden class="anchor" aria-hidden="true" href="#动态链接时执行时搜索路径顺序">#</a></h3>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib</li>
<li>默认的动态库搜索路径/usr/lib</li>
</ol>
<p>有关环境变量：</p>
<p>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径</p>
<p>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>
<h1 id="gcc和g的区别">gcc和g++的区别<a hidden class="anchor" aria-hidden="true" href="#gcc和g的区别">#</a></h1>
<p>GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p>
<p>gcc是GCC中的GUN C Compiler（C 编译器）</p>
<p>g++是GCC中的GUN C++ Compiler（C++编译器）</p>
<p>一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</p>
<p>Step1：Call a preprocessor, like cpp.</p>
<p>Step2：Call an actual compiler, like cc or cc1.</p>
<p>Step3：Call an assembler, like as.</p>
<p>Step4：Call a linker, like ld</p>
<p>由于编译器是可以更换的，所以gcc不仅仅可以编译C文件</p>
<p>所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler</p>
<h2 id="gcc和g的主要区别">gcc和g++的主要区别<a hidden class="anchor" aria-hidden="true" href="#gcc和g的主要区别">#</a></h2>
<ol>
<li>
<p>对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</p>
</li>
<li>
<p>对于 .c和.cpp文件，g++则统一当做cpp文件编译</p>
</li>
<li>
<p>g++链接文件时，会自动链接标准库STL，而gcc不会自动链接STL</p>
</li>
<li>
<p>gcc在编译C文件时，可使用的预定义宏是比较少的,</p>
</li>
<li>
<p>【gcc在编译cpp文件时】或【g++在编译c文件和cpp文件时】（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define __GXX_WEAK__ 1
</span><span class="cp">#define __cplusplus 1
</span><span class="cp">#define __DEPRECATED 1
</span><span class="cp">#define __GNUG__ 4
</span><span class="cp">#define __EXCEPTIONS 1
</span><span class="cp">#define __private_extern__ extern
</span></code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
<li>
<p>在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个</p>
</li>
</ol>
<p>转载： <br>
<a href="">http://man.linuxde.net/gcc</a>
<a href="">http://blog.csdn.net/a312024054/article/details/46973995</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
