<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>GCC编译器介绍 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.91.1 with theme even" />


<link rel="canonical" href="/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="GCC编译器介绍" />
<meta property="og:description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T14:19:06+00:00" />
<meta property="article:modified_time" content="2017-06-25T14:19:06+00:00" />

<meta itemprop="name" content="GCC编译器介绍">
<meta itemprop="description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现"><meta itemprop="datePublished" content="2017-06-25T14:19:06+00:00" />
<meta itemprop="dateModified" content="2017-06-25T14:19:06+00:00" />
<meta itemprop="wordCount" content="4392">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GCC编译器介绍"/>
<meta name="twitter:description" content="gcc命令 gcc命令使用GNU推出的基于C/C&#43;&#43;的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">GCC编译器介绍</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-25 </span>
        <div class="post-category">
            <a href="/categories/linux%E7%BC%96%E7%A8%8B/"> Linux编程 </a>
            </div>
          <span class="more-meta"> 约 4392 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#语法">语法</a></li>
    <li><a href="#选项">选项</a></li>
    <li><a href="#参数">参数</a>
      <ul>
        <li><a href="#gcc--o选项">GCC -O选项</a></li>
      </ul>
    </li>
    <li><a href="#gcc调试级别">GCC调试级别</a></li>
    <li><a href="#实例">实例</a>
      <ul>
        <li><a href="#常用编译命令选项">常用编译命令选项</a></li>
      </ul>
    </li>
    <li><a href="#多源文件的编译方法">多源文件的编译方法</a></li>
    <li><a href="#gcc的检错功能">GCC的检错功能</a></li>
    <li><a href="#库文件连接">库文件连接</a>
      <ul>
        <li><a href="#静态库链接时搜索路径顺序">静态库链接时搜索路径顺序</a></li>
        <li><a href="#动态链接时执行时搜索路径顺序">动态链接时、执行时搜索路径顺序:</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#gcc和g的主要区别">gcc和g++的主要区别</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="gcc命令">gcc命令</h1>
<p>gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。</p>
<h2 id="语法">语法</h2>
<pre><code>gcc(选项)(参数) 
</code></pre>
<h2 id="选项">选项</h2>
<p>-v / –v / –version 查看gcc版本号</p>
<p>-I目录 指定头文件目录，注意-I和目录之间没有空格</p>
<p>-o：指定生成的输出文件；</p>
<p>-c 只编译，生成.o文件，不进行链接</p>
<p>-g 包含调试信息，若要使用GDB调试，必须加此选项</p>
<p>-On n=1~3 编译优化，n越大优化的越多</p>
<p>-Wall 提示更多告警信息（严格编译)</p>
<p>-D 编译时定义宏，注意-D和之间没有空格</p>
<p>-E 生成预处理文件，一般是.i文件,(展开头文件，替换宏常量)</p>
<p>-M 生成.c文件与头文件依赖关系以用于Makefile，包括系统库的头文件</p>
<p>-MM 生成.c文件与头文件依赖关系以用于Makefile，不包括系统库的头文件</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170529203012.png" alt=""></p>
<h2 id="参数">参数</h2>
<p>C源文件：指定C语言源代码文件。</p>
<p>##GCC优化级别</p>
<h3 id="gcc--o选项">GCC -O选项</h3>
<p>这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。</p>
<p>-O设置一共有五种：-O0、-O1、-O2、-O3和-Os。你只能在/etc/make.conf里面设置其中的一种。
除了-O0以外，每一个-O设置都会多启用几个选项，请查阅gcc手册的优化选项章节，以便了解每个-O等级启用了哪些选项及它们有何作用。</p>
<p>让我们来逐一考察各个优化等级：</p>
<p>-O0：这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置-O等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。</p>
<p>-O1：这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。</p>
<p>-O2：-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。</p>
<p>-O3：这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。这样做将得不偿失，记住过犹不及。在gcc 4.x.中使用-O3是不推荐的。</p>
<p>-Os：这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。</p>
<h2 id="gcc调试级别">GCC调试级别</h2>
<p>如果不打开-g或者-ggdb(GDB专用)调试开关，GCC编译时不会加入调试信息，因为这会增大生成代码的体积。</p>
<p>GCC采用了分级调试，通过在-g选项后附加数字1、2或3来指定在代码中加入调试信息量。</p>
<p>默认的级别是2（-g2），此时调试信息包括扩展的符号表、行号、局部或外部变量信息。级别3（- g3）包含级别2中的调试信息和源代码中定义的宏。级别1（-g1）不包含局部变量和与行号有关的调试信息，只能用于回溯跟踪和堆栈转储之用。s</p>
<p>【回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段。】</p>
<h2 id="实例">实例</h2>
<h3 id="常用编译命令选项">常用编译命令选项</h3>
<p>假设源程序文件名为test.c</p>
<p>无选项编译链接</p>
<pre><code>gcc test.c 
</code></pre>
<p>将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。</p>
<p>选项 -o</p>
<pre><code>gcc test.c -o test 
</code></pre>
<p>将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。</p>
<p>选项 -E</p>
<pre><code>gcc -E test.c -o test.i 
</code></pre>
<p>将test.c预处理输出test.i文件。</p>
<p>选项 -S</p>
<pre><code>gcc -S test.i 
</code></pre>
<p>将预处理输出文件test.i汇编成test.s文件。</p>
<p>选项 -c</p>
<pre><code>gcc -c test.s 
</code></pre>
<p>将汇编输出文件test.s编译输出test.o文件。</p>
<p>无选项链接</p>
<pre><code>gcc test.o -o test 
</code></pre>
<p>将编译输出文件test.o链接成最终可执行文件test。</p>
<p>选项 -O</p>
<pre><code>gcc -O1 test.c -o test 
</code></pre>
<p>使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<h2 id="多源文件的编译方法">多源文件的编译方法</h2>
<p>如果有多个源文件，基本上有两种编译方法：</p>
<p>假设有两个源文件为test.c和testfun.c 多个文件一起编译</p>
<pre><code>gcc testfun.c test.c -o test 
</code></pre>
<p>将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<p>分别编译各个源文件，之后对编译后输出的目标文件链接。</p>
<pre><code>gcc -c testfun.c #将testfun.c编译成testfun.o 
gcc -c test.c #将test.c编译成test.o 
gcc -o testfun.o test.o -o test #将testfun.o和test.o链接成test 
</code></pre>
<p>以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。</p>
<h2 id="gcc的检错功能">GCC的检错功能</h2>
<pre><code>gcc -pedantic illcode.c -o illcode
</code></pre>
<p>-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>
<p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。</p>
<pre><code>gcc -Wall illcode.c -o illcode
</code></pre>
<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p>
<pre><code>gcc -Werror test.c -o test
</code></pre>
<h2 id="库文件连接">库文件连接</h2>
<p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。</p>
<p>虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p>
<p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p>
<p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p>
<ol>
<li>
<p>编译成可执行文件</p>
<p>首先我们要进行编译test.c为目标文件，这个时候需要执行</p>
<pre><code> gcc –c –I /usr/dev/mysql/include test.c –o test.o
</code></pre>
</li>
<li>
<p>链接</p>
<p>最后我们把所有目标文件链接成可执行文件:</p>
<pre><code> gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test
</code></pre>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p>
</li>
<li>
<p>强制链接时使用静态链接库</p>
<p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:</p>
<pre><code> gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
</code></pre>
</li>
</ol>
<h3 id="静态库链接时搜索路径顺序">静态库链接时搜索路径顺序</h3>
<ol>
<li>ld会去找GCC命令中的参数-L</li>
<li>再找gcc的环境变量LIBRARY_PATH</li>
<li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li>
</ol>
<h3 id="动态链接时执行时搜索路径顺序">动态链接时、执行时搜索路径顺序:</h3>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib</li>
<li>默认的动态库搜索路径/usr/lib</li>
</ol>
<p>有关环境变量：</p>
<p>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径</p>
<p>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>
<h1 id="gcc和g的区别">gcc和g++的区别</h1>
<p>GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p>
<p>gcc是GCC中的GUN C Compiler（C 编译器）</p>
<p>g++是GCC中的GUN C++ Compiler（C++编译器）</p>
<p>一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</p>
<p>Step1：Call a preprocessor, like cpp.</p>
<p>Step2：Call an actual compiler, like cc or cc1.</p>
<p>Step3：Call an assembler, like as.</p>
<p>Step4：Call a linker, like ld</p>
<p>由于编译器是可以更换的，所以gcc不仅仅可以编译C文件</p>
<p>所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler</p>
<h2 id="gcc和g的主要区别">gcc和g++的主要区别</h2>
<ol>
<li>
<p>对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</p>
</li>
<li>
<p>对于 .c和.cpp文件，g++则统一当做cpp文件编译</p>
</li>
<li>
<p>g++链接文件时，会自动链接标准库STL，而gcc不会自动链接STL</p>
</li>
<li>
<p>gcc在编译C文件时，可使用的预定义宏是比较少的,</p>
</li>
<li>
<p>【gcc在编译cpp文件时】或【g++在编译c文件和cpp文件时】（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define __GXX_WEAK__ 1
</span><span class="cp">#define __cplusplus 1
</span><span class="cp">#define __DEPRECATED 1
</span><span class="cp">#define __GNUG__ 4
</span><span class="cp">#define __EXCEPTIONS 1
</span><span class="cp">#define __private_extern__ extern
</span></code></pre></td></tr></table>
</div>
</div><p>``</p>
</li>
<li>
<p>在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个</p>
</li>
</ol>
<p>转载： <br>
<a href="">http://man.linuxde.net/gcc</a>
<a href="">http://blog.csdn.net/a312024054/article/details/46973995</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%88%A9%E7%94%A8linux%E7%9A%84mtrace%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-memory-leak/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">利用linux的mtrace命令定位内存泄露(Memory Leak)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/coredump%E8%AF%A6%E8%A7%A3/">
            <span class="next-text nav-default">coredump详解</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
