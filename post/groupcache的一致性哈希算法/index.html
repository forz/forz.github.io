<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Groupcache的一致性哈希算法 | Forz Blog</title>
<meta name="keywords" content="groupcache" />
<meta name="description" content="源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68">
<meta name="author" content="">
<link rel="canonical" href="/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Groupcache的一致性哈希算法" />
<meta property="og:description" content="源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-14T13:41:45&#43;00:00" />
<meta property="article:modified_time" content="2019-10-14T13:41:45&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Groupcache的一致性哈希算法"/>
<meta name="twitter:description" content="源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Groupcache的一致性哈希算法",
      "item": "/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Groupcache的一致性哈希算法",
  "name": "Groupcache的一致性哈希算法",
  "description": "源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68",
  "keywords": [
    "groupcache"
  ],
  "articleBody": "源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  /* Copyright 2013 Google Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ // Package consistenthash provides an implementation of a ring hash. package consistenthash import ( \"hash/crc32\" \"sort\" \"strconv\" ) type Hash func(data []byte) uint32 type Map struct { hash Hash replicas int keys []int // Sorted \thashMap map[int]string } func New(replicas int, fn Hash) *Map { m := \u0026Map{ replicas: replicas, hash: fn, hashMap: make(map[int]string), } if m.hash == nil { m.hash = crc32.ChecksumIEEE } return m } // Returns true if there are no items available. func (m *Map) IsEmpty() bool { return len(m.keys) == 0 } // Adds some keys to the hash. func (m *Map) Add(keys ...string) { for _, key := range keys { for i := 0; i  m.replicas; i++ { hash := int(m.hash([]byte(strconv.Itoa(i) + key))) m.keys = append(m.keys, hash) m.hashMap[hash] = key } } sort.Ints(m.keys) } // Gets the closest item in the hash to the provided key. func (m *Map) Get(key string) string { if m.IsEmpty() { return \"\" } hash := int(m.hash([]byte(key))) // Binary search for appropriate replica. \tidx := sort.Search(len(m.keys), func(i int) bool { return m.keys[i] = hash }) // Means we have cycled back to the first replica. \tif idx == len(m.keys) { idx = 0 } return m.hashMap[m.keys[idx]] }   分析 Map 结构 1 2 3 4 5 6  type Map struct { hash Hash // hash 函数  replicas int keys []int // Sorted  hashMap map[int]string }   Map 结构，定义核心数据结构,其中hash是哈希函数，用于对key进行hash，keys字段保存所有的节点（包括虚拟节点）是可排序的，hashmap 则是虚拟节点到真实节点的映射。\n一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。replicas是指的是每个节点和虚拟节点的个数。\nNew方法 1 2 3 4 5 6 7 8 9 10 11 12  func New(replicas int, fn Hash) *Map { m := \u0026Map{ replicas: replicas, hash: fn, hashMap: make(map[int]string), } // 默认使用CRC32算法 \tif m.hash == nil { m.hash = crc32.ChecksumIEEE } return m }   Add方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Adds some keys to the hash. // Add 方法用来添加缓存节点，参数为节点key，比如使用IP func (m *Map) Add(keys ...string) { for _, key := range keys { // 结合复制因子计算所有虚拟节点的hash值，并存入m.keys中，同时在m.hashMap中保存哈希值和key的映射  for i := 0; i  m.replicas; i++ { hash := int(m.hash([]byte(strconv.Itoa(i) + key))) m.keys = append(m.keys, hash) m.hashMap[hash] = key } } // 对所有虚拟节点的哈希值进行排序，方便之后进行二分查找  sort.Ints(m.keys) }   Map的Add方法，添加节点到圆环，参数是一个或者多个string，对每一个key关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，在添加每个关键字的时候，并添加对应的虚拟节点，每个真实节点和虚拟节点个数有replicas字段指定，保存虚拟节点到真实节点的对应关系到hashmap字段。\n比如在测试用例中， hash.Add(“6”, “4”, “2”)，则所有的节点是 2, 4, 6, 12, 14, 16, 22, 24, 26, 当has.Get(‘11’) 时，对应的节点是12，而12对应的真实节点是2\nhash.Add(“6”, “4”, “2”)是数据值：\n1 2 3  2014/02/20 15:45:16 replicas: 3 2014/02/20 15:45:16 keys: [2 4 6 12 14 16 22 24 26] 2014/02/20 15:45:16 hashmap map[16:6 26:6 4:4 24:4 2:2 6:6 14:4 12:2 22:2]   说明: 此处添加虚拟节点的算法是有问题的，比如replicas = 3，传入的key为2,12,22，则就会出现某个节点的虚拟实际上就是 另外的真实节点。不过在groupcache中的应用不存在这个情况，因为keys都是字符串，而且是host:port形式的字符串，所以就不会出现上面的情况。\nGet方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Get 方法根据给定的对象获取最靠近它的那个节点key // Gets the closest item in the hash to the provided key. func (m *Map) Get(key string) string { if m.IsEmpty() { return \"\" } hash := int(m.hash([]byte(key))) // Binary search for appropriate replica.  // 顺时针“行走”，找到第一个大于哈希值的节点  // 通过二分查找获取最优节点，第一个节点hash值大于对象hash值的就是最优节点  idx := sort.Search(len(m.keys), func(i int) bool { return m.keys[i] = hash }) // 如果查找结果大于节点哈希数组的最大索引，表示此时该对象哈希值位于最后一个节点之后，那么放入第一个节点中 \t// Means we have cycled back to the first replica. \tif idx == len(m.keys) { idx = 0 } // hash值大于最大节点哈希值的情况 \treturn m.hashMap[m.keys[idx]]// 返回真实节点 }   Get方法根据提供的key定位数据访问到相应服务器节点，算法是：将数据key使用相同的哈希函数H计算出哈希值h，根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。\n",
  "wordCount" : "1640",
  "inLanguage": "zh-cn",
  "datePublished": "2019-10-14T13:41:45Z",
  "dateModified": "2019-10-14T13:41:45Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/groupcache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Groupcache的一致性哈希算法
    </h1>
    <div class="post-meta">October 14, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="源码">源码<a hidden class="anchor" aria-hidden="true" href="#源码">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/*
</span><span class="cm">Copyright 2013 Google Inc.
</span><span class="cm">
</span><span class="cm">Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
</span><span class="cm">you may not use this file except in compliance with the License.
</span><span class="cm">You may obtain a copy of the License at
</span><span class="cm">
</span><span class="cm">     http://www.apache.org/licenses/LICENSE-2.0
</span><span class="cm">
</span><span class="cm">Unless required by applicable law or agreed to in writing, software
</span><span class="cm">distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
</span><span class="cm">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class="cm">See the License for the specific language governing permissions and
</span><span class="cm">limitations under the License.
</span><span class="cm">*/</span>

<span class="c1">// Package consistenthash provides an implementation of a ring hash.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">consistenthash</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;hash/crc32&#34;</span>
	<span class="s">&#34;sort&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Hash</span> <span class="kd">func</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">uint32</span>

<span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">hash</span>     <span class="nx">Hash</span>
	<span class="nx">replicas</span> <span class="kt">int</span>
	<span class="nx">keys</span>     <span class="p">[]</span><span class="kt">int</span> <span class="c1">// Sorted
</span><span class="c1"></span>	<span class="nx">hashMap</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">replicas</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">fn</span> <span class="nx">Hash</span><span class="p">)</span> <span class="o">*</span><span class="nx">Map</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Map</span><span class="p">{</span>
		<span class="nx">replicas</span><span class="p">:</span> <span class="nx">replicas</span><span class="p">,</span>
		<span class="nx">hash</span><span class="p">:</span>     <span class="nx">fn</span><span class="p">,</span>
		<span class="nx">hashMap</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">hash</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">hash</span> <span class="p">=</span> <span class="nx">crc32</span><span class="p">.</span><span class="nx">ChecksumIEEE</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>

<span class="c1">// Returns true if there are no items available.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Adds some keys to the hash.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">keys</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">replicas</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">hash</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">hash</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)))</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">hash</span><span class="p">)</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">hashMap</span><span class="p">[</span><span class="nx">hash</span><span class="p">]</span> <span class="p">=</span> <span class="nx">key</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Gets the closest item in the hash to the provided key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>

	<span class="nx">hash</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">hash</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">)))</span>

	<span class="c1">// Binary search for appropriate replica.
</span><span class="c1"></span>	<span class="nx">idx</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">hash</span> <span class="p">})</span>

	<span class="c1">// Means we have cycled back to the first replica.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">idx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">hashMap</span><span class="p">[</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">[</span><span class="nx">idx</span><span class="p">]]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="分析">分析<a hidden class="anchor" aria-hidden="true" href="#分析">#</a></h1>
<h2 id="map-结构">Map 结构<a hidden class="anchor" aria-hidden="true" href="#map-结构">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">hash</span>     <span class="nx">Hash</span> <span class="c1">// hash 函数
</span><span class="c1"></span>    <span class="nx">replicas</span> <span class="kt">int</span>
    <span class="nx">keys</span>     <span class="p">[]</span><span class="kt">int</span> <span class="c1">// Sorted
</span><span class="c1"></span>    <span class="nx">hashMap</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Map 结构，定义核心数据结构,其中hash是哈希函数，用于对key进行hash，keys字段保存所有的节点（包括虚拟节点）是可排序的，hashmap 则是虚拟节点到真实节点的映射。</p>
<p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。replicas是指的是每个节点和虚拟节点的个数。</p>
<h2 id="new方法">New方法<a hidden class="anchor" aria-hidden="true" href="#new方法">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">replicas</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">fn</span> <span class="nx">Hash</span><span class="p">)</span> <span class="o">*</span><span class="nx">Map</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Map</span><span class="p">{</span>
		<span class="nx">replicas</span><span class="p">:</span> <span class="nx">replicas</span><span class="p">,</span>
		<span class="nx">hash</span><span class="p">:</span>     <span class="nx">fn</span><span class="p">,</span>
		<span class="nx">hashMap</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="c1">// 默认使用CRC32算法
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">hash</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">hash</span> <span class="p">=</span> <span class="nx">crc32</span><span class="p">.</span><span class="nx">ChecksumIEEE</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="add方法">Add方法<a hidden class="anchor" aria-hidden="true" href="#add方法">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Adds some keys to the hash.
</span><span class="c1">// Add 方法用来添加缓存节点，参数为节点key，比如使用IP
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">keys</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
        <span class="c1">// 结合复制因子计算所有虚拟节点的hash值，并存入m.keys中，同时在m.hashMap中保存哈希值和key的映射
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">replicas</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">hash</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">hash</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)))</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">hash</span><span class="p">)</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">hashMap</span><span class="p">[</span><span class="nx">hash</span><span class="p">]</span> <span class="p">=</span> <span class="nx">key</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 对所有虚拟节点的哈希值进行排序，方便之后进行二分查找
</span><span class="c1"></span>    <span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Map的Add方法，添加节点到圆环，参数是一个或者多个string，对每一个key关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，在添加每个关键字的时候，并添加对应的虚拟节点，每个真实节点和虚拟节点个数有replicas字段指定，保存虚拟节点到真实节点的对应关系到hashmap字段。</p>
<p>比如在测试用例中， hash.Add(&ldquo;6&rdquo;, &ldquo;4&rdquo;, &ldquo;2&rdquo;)，则所有的节点是 2, 4, 6, 12, 14, 16, 22, 24, 26, 当has.Get(&lsquo;11&rsquo;) 时，对应的节点是12，而12对应的真实节点是2</p>
<p>hash.Add(&ldquo;6&rdquo;, &ldquo;4&rdquo;, &ldquo;2&rdquo;)是数据值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mi">2014</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">20</span> <span class="mi">15</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mi">16</span> <span class="nx">replicas</span><span class="p">:</span> <span class="mi">3</span>
<span class="mi">2014</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">20</span> <span class="mi">15</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mi">16</span> <span class="nx">keys</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">12</span> <span class="mi">14</span> <span class="mi">16</span> <span class="mi">22</span> <span class="mi">24</span> <span class="mi">26</span><span class="p">]</span>
<span class="mi">2014</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">20</span> <span class="mi">15</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mi">16</span> <span class="nx">hashmap</span> <span class="kd">map</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">6</span> <span class="mi">26</span><span class="p">:</span><span class="mi">6</span> <span class="mi">4</span><span class="p">:</span><span class="mi">4</span> <span class="mi">24</span><span class="p">:</span><span class="mi">4</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span> <span class="mi">6</span><span class="p">:</span><span class="mi">6</span> <span class="mi">14</span><span class="p">:</span><span class="mi">4</span> <span class="mi">12</span><span class="p">:</span><span class="mi">2</span> <span class="mi">22</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>说明: 此处添加虚拟节点的算法是有问题的，比如replicas = 3，传入的key为2,12,22，则就会出现某个节点的虚拟实际上就是 另外的真实节点。不过在groupcache中的应用不存在这个情况，因为keys都是字符串，而且是host:port形式的字符串，所以就不会出现上面的情况。</p>
<h1 id="get方法">Get方法<a hidden class="anchor" aria-hidden="true" href="#get方法">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get 方法根据给定的对象获取最靠近它的那个节点key
</span><span class="c1">// Gets the closest item in the hash to the provided key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>

	<span class="nx">hash</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">hash</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">)))</span>

    <span class="c1">// Binary search for appropriate replica.
</span><span class="c1"></span>    <span class="c1">// 顺时针“行走”，找到第一个大于哈希值的节点
</span><span class="c1"></span>    <span class="c1">// 通过二分查找获取最优节点，第一个节点hash值大于对象hash值的就是最优节点
</span><span class="c1"></span>    <span class="nx">idx</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">hash</span> <span class="p">})</span>
    
    <span class="c1">// 如果查找结果大于节点哈希数组的最大索引，表示此时该对象哈希值位于最后一个节点之后，那么放入第一个节点中
</span><span class="c1"></span>	<span class="c1">// Means we have cycled back to the first replica.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">idx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="c1">// hash值大于最大节点哈希值的情况
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">hashMap</span><span class="p">[</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">[</span><span class="nx">idx</span><span class="p">]]</span><span class="c1">// 返回真实节点
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Get方法根据提供的key定位数据访问到相应服务器节点，算法是：将数据key使用相同的哈希函数H计算出哈希值h，根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/groupcache/">groupcache</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
