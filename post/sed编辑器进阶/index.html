<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>sed编辑器进阶 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。 N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理">
<meta name="author" content="">
<link rel="canonical" href="/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="sed编辑器进阶" />
<meta property="og:description" content="多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。 N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-08-11T20:44:40&#43;00:00" />
<meta property="article:modified_time" content="2017-08-11T20:44:40&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="sed编辑器进阶"/>
<meta name="twitter:description" content="多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。 N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "sed编辑器进阶",
      "item": "/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "sed编辑器进阶",
  "name": "sed编辑器进阶",
  "description": "多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。 N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理",
  "keywords": [
    
  ],
  "articleBody": "多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。\n N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理。 D:删除多行组中的一行。 P:打印多行组中的一行。  next命令 单行的next命令 小写的n命令会告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始 再执行一遍。记住，通常sed编辑器在移动到数据流中的下一文本行之前，会在当前行上执行完 所有定义好的命令。单行next命令改变了这个流程。\n$ sed '/header/{n ; d}' data1.txt  脚本要查找含有单词header的那一行。找到之后，n命令会让sed编辑器移动到文 本的下一行，这时，sed编辑器会继续执行命令列表，该命令列表使用d命令来删除行。\nsed编辑器执 行完命令脚本后，会从数据流中读取下一行文本，并从头开始执行命令脚本。因为sed编辑器再 也找不到包含单词header的行了。所以也不会有其他行会被删掉。\n合并文本行 单行next命令会将数据流中的下一文本 行移动到sed编辑器的工作空间(称为模式空间)。多行版本的next命令(用大写N)会将下一文 本行添加到模式空间中已有的文本后。\n这样的作用是将数据流中的两个文本行合并到同一个模式空间中。文本行仍然用换行符分 隔，但sed编辑器现在会将两行文本当成一行来处理。\n$ sed '/first/{ N ; s/\\n/ / }' data2.txt  sed编辑器脚本查找含有单词first的那行文本。找到该行后，它会用N命令将下一行合并到那 5 行，然后用替换命令s将换行符替换成空格。结果是，文本文件中的两行在sed编辑器的输出中成了一行。\n如果要在数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程 序。\n$ sed 'N ; s/System Administrator/Desktop User/' data3.txt  替换命令会在文本文件中查找特定的双词短语System Administrator。如果短语在一行 中的话，事情很好处理，替换命令可以直接替换文本。但如果短语分散在两行中的话，替换命令 就没法识别匹配的模式了。这时N命令就可以派上用场了。\n$ sed 'N ; s/System.Administrator/Desktop User/' data3.txt  注意，替换命令在System和Administrator之间用了通配符模式(.)来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这 可能不是你想要的。\n要解决这个问题，可以在sed编辑器脚本中用两个替换命令:一个用来匹配短语出现在多行 中的情况，一个用来匹配短语出现在单行中的情况。\n$ sed 'N  s/System\\nAdministrator/Desktop\\nUser/  s/System Administrator/Desktop User/  ' data3.txt  但这个脚本中仍有个小问题。这个脚本总是在执行sed编辑器命令前将下一行文本读入到模 式空间。当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止。如果 要匹配的文本正好在数据流的最后一行上，命令就不会发现要匹配的数据。\n你可以轻松地解决这个问题——将单行命令放到N命令 前面，并将多行命令放到N命令后面\n$ sed '  s/System Administrator/Desktop User/ N  s/System\\nAdministrator/Desktop\\nUser/  ' data4.txt  多行删除命令 sed编辑器用单行删除命令(d)来删除模式空间中的当前行。但和N命令一起使用时，使用单行删除命令就要小心了。\n$ sed 'N ; /System\\nAdministrator/d' data4.txt  删除命令会在不同的行中查找单词System和Administrator，然后在模式空间中将两行都删掉。 这未必是你想要的结果。\nsed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符(含换行符)为止的所有字符。\n这里有个例子，它会删除数据流中出现在第一行前的空白行。\n$ sed '/^$/{N ; /header/D}' data5.txt  sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式 空间内容含有单词header，则D命令会删除模式空间中的第一行。\n多行打印命令 多行打印命令(P)只打印多行模式空间中的第一行。这包括模式空间中直到换行符为止的所有字符。当你用-n选项来阻止脚本输出时，它和显示文本的单行p命令的用法大同小异。\n保持空间 模式空间(pattern space)是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本。但它并不是sed编辑器保存文本的唯一空间。\nsed编辑器有另一块称作保持空间(hold space)的缓冲区域。在处理模式空间中的某些行时， 可以用保持空间来临时保存一些行。有5条命令可用来操作保持空间，\n通常，在使用h或H命令将字符串移动到保持空间后，最终还要用g、G或x命令将保存的字符 串移回模式空间(否则，你就不用在一开始考虑保存它们了)。\n由于有两个缓冲区域，弄明白哪行文本在哪个缓冲区域有时会比较麻烦。这里有个简短的例 子演示了如何用h和g命令来将数据在sed编辑器缓冲空间之间移动。\n1 2 3 4 5 6 7 8 9 10 11 12  $ cat data2.txt This is the header line. This is the first data line. This is the second data line. This is the last line. $ $ sed -n '/first/ {h ; p ; n ; p ; g ; p }' data2.txt This is the first data line. This is the second data line. This is the first data line. $   我们来一步一步看上面这个代码例子:\n(1) sed脚本在地址中用正则表达式来过滤出含有单词first的行;\n(2) 当含有单词first的行出现时，h命令将该行放到保持空间;\n(3) p命令打印模式空间也就是第一个数据行的内容;\n(4) n命令提取数据流中的下一行(This is the second data line)，并将它放到模式空间;\n(5) p命令打印模式空间的内容，现在是第二个数据行;\n(6) g命令将保持空间的内容(This is the first data line)放回模式空间，替换当 前文本;\n(7) p命令打印模式空间的当前内容，现在变回第一个数据行了。\n通过使用保持空间来回移动文本行，你可以强制输出中第一个数据行出现在第二个数据行后 面。如果丢掉了第一个p命令，你可以以相反的顺序输出这两行。\n排除命令 感叹号命令(!)用来排除(negate)命令，也就是让原本会起作用的命令不起作用。下面的例子演示了这一特性。\n$ sed -n '/header/!p' data2.txt  普通p命令只打印data2文件中包含单词header的那行。加了感叹号之后，情况就相反了:除了包含单词header那一行外，文件中其他所有的行都被打印出来了。\n很多情况下sed编辑器无法处理数据流中最后一行文本，因为之后再没有其他行了。可以使用感叹号与N命令以及与美元符特殊地址。\n$ sed '$!N;  s/System\\nAdministrator/Desktop\\nUser/  s/System Administrator/Desktop User/  ' data4.txt  美元符表示数据流中 的最后一行文本，所以当sed编辑器到了最后一行时，它没有执行N命令，但它对所有其他行都执行了这个命令。\n改变流 通常，sed编辑器会从脚本的顶部开始，一直执行到脚本的结尾(D命令是个例外，它会强制 sed编辑器返回到脚本的顶部，而不读取新的行)。sed编辑器提供了一个方法来改变命令脚本的执 行流程，其结果与结构化编程类似。\n分支 sed编辑器提供了一种方法，可以基于地址、地址模式或地址区间排除一整块命令。这允许你只对数据流中的特定行执行一组命令。\n分支(branch)命令b的格式如下:\n[address]b [label]  address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如 果没有加label参数，跳转命令会跳转到脚本的结尾。\nsed '{2,3b ; s/This is/Is this/ ; s/line./test?/}' data2.txt  分支命令在数据流中的第2行和第3行处跳过了两个替换命令。\n要是不想直接跳到脚本的结尾，可以为分支命令定义一个要跳转到的标签。标签以冒号开始， 最多可以是7个字符长度。\n:label2  要指定标签，将它加到b命令后即可。使用标签允许你跳过地址匹配处的命令，但仍然执行 脚本中的其他命令。\n$ sed '{/first/b jump1 ; s/This is the/No jump on/  :jump1  s/This is the/Jump here on/}' data2.txt  跳转命令指定如果文本行中出现了first，程序应该跳到标签为jump1的脚本行。如果分支命令的模式没有匹配，sed编辑器会继续执行脚本中的命令，包括分支标签后的命令(因此，所 有的替换命令都会在不匹配分支模式的行上执行)。\n如果某行匹配了分支模式， sed编辑器就会跳转到带有分支标签的那行。因此，只有最后一 个替换命令会执行。\n这个例子演示了跳转到sed脚本后面的标签上。也可以跳转到脚本中靠前面的标签上，这样 就达到了循环的效果。\n$ echo \"This, is, a, test, to, remove, commas.\" | sed -n '{  :start  s/,//1p  b start  }'  脚本的每次迭代都会删除文本中的第一个逗号，并打印字符串。这个脚本有个问题:它永远 不会结束。这就形成了一个无穷循环，不停地查找逗号，直到使用Ctrl+C组合键发送一个信号，手动停止这个脚本。\n要防止这个问题，可以为分支命令指定一个地址模式来查找。如果没有模式，跳转就应该 结束。\n$ echo \"This, is, a, test, to, remove, commas.\" | sed -n '{  :start  s/,//1p  /,/b start  }'  现在分支命令只会在行中有逗号的情况下跳转。在最后一个逗号被删除后，分支命令不会再 执行，脚本也就能正常停止了。\n测试 类似于分支命令，测试(test)命令(t)也可以用来改变sed编辑器脚本的执行流程。测 试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。\n如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令 未能匹配指定的模式，测试命令就不会跳转。\n测试命令使用与分支命令相同的格式。\n[address]t [label]  跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。 测试命令提供了对数据流中的文本执行基本的if-then语句的一个低成本办法。举个例子， 如果已经做了一个替换，不需要再做另一个替换，那么测试命令能帮上忙。\n$ sed '{  s/first/matched/ t  s/This is the/No match on/  }' data2.txt  第一个替换命令会查找模式文本first。如果匹配了行中的模式，它就会替换文本，而且测 试命令会跳过后面的替换命令。如果第一个替换命令未能匹配模式，第二个替换命令就会被执行。\n有了测试命令，你就能结束之前用分支命令形成的无限循环。\n1 2 3 4 5  $ echo \"This, is, a, test, to, remove, commas. \" | sed -n '{  :start  s/,//1p  t start  }'   当无需替换时，测试命令不会跳转而是继续执行剩下的脚本。\n模式替代 你已经知道了如何在sed命令中使用模式来替代数据流中的文本。然而在使用通配符时，很 难知道到底哪些文本会匹配模式。用于替代的字符串无法匹配 已匹配单词中的通配符字符。\n$ echo \"The cat sleeps in his hat.\" | sed 's/.at/\".at\"/g' The \".at\" sleeps in his \".at\". $  \u0026符号 sed编辑器提供了一个解决办法。\u0026符号可以用来代表替换命令中的匹配的模式。不管模式匹 配的是什么样的文本，你都可以在替代模式中使用\u0026符号来使用这段文本。这样就可以操作模式 所匹配到的任何单词了。\n$ echo \"The cat sleeps in his hat.\" | sed 's/.at/\"\u0026\"/g' The \"cat\" sleeps in his \"hat\". $  替代单独的单词 sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用 每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子模式分配字符\\1，给第二个子模式分配字符\\2，依此类推。\n当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆 括号。这跟转义其他特殊字符正好相反。\n$ echo \"The System Administrator manual\" | sed '  s/\\(System\\) Administrator/\\1 User/' The System User manual 12 $  这个替换命令用一对圆括号将单词System括起来，将其标示为一个子模式。然后它在替代模 式中使用\\1来提取第一个匹配的子模式。这没什么特别的，但在处理通配符模式时却特别有用。\n如果需要用一个单词来替换一个短语，而这个单词刚好是该短语的子字符串，但那个子字符 串碰巧使用了通配符，这时使用子模式会方便很多。\n$ echo \"That furry cat is pretty\" | sed 's/furry \\(.at\\)/\\1/'  当需要在两个或多个子模式间插入文本时，这个特性尤其有用。这里有个脚本，它使用子模 式在大数字中插入逗号。\n1 2 3 4 5 6 7  $ echo \"1234567\" | sed '{  :start  s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/  t start  }' 1,234,567 $   这个模式会查找两个子模式。第一个子模式是以数字结尾的任意长度的字符。第二个子模式 是若干组三位数字.如果这个模式 在文本中找到了，替代文本会在两个子模式之间加一个逗号，每个子模式都会通过其位置来标示。 这个脚本使用测试命令来遍历这个数字，直到放置好所有的逗号。\n在脚本中使用sed 使用包装脚本 你可能已经注意到，实现sed编辑器脚本的过程很烦琐，尤其是脚本很长的话。可以将sed编 辑器命令放到shell包装脚本(wrapper)中，不用每次使用时都重新键入整个脚本。包装脚本充当 着sed编辑器脚本和命令行之间的中间人角色。\n在shell脚本中，可以将普通的shell变量及参数和sed编辑器脚本一起使用。这里有个将命令行 参数变量作为sed脚本输入的例子。\n1 2 3 4 5 6 7 8  $ cat reverse.sh #!/bin/bash # Shell wrapper for sed editor script. # to reverse text file lines. # sed -n '{ 1!G ; h ; $p }' $1 # $   名为reverse的shell脚本用sed编辑器脚本来反转数据流中的文本行。它使用shell参数$1从命令 2 行中提取第一个参数，这正是需要进行反转的文件名。\n重定向sed的输出 默认情况下，sed编辑器会将脚本的结果输出到STDOUT上。你可以在shell脚本中使用各种标 准方法对sed编辑器的输出进行重定向。\n可以在脚本中用$()将sed编辑器命令的输出重定向到一个变量中，以备后用。\n1 2 3 4  result=$(echo $factorial | sed '{ :start s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/ t start }')   ",
  "wordCount" : "5026",
  "inLanguage": "zh-cn",
  "datePublished": "2017-08-11T20:44:40Z",
  "dateModified": "2017-08-11T20:44:40Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/sed%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      sed编辑器进阶
    </h1>
    <div class="post-meta">August 11, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="多行命令">多行命令<a hidden class="anchor" aria-hidden="true" href="#多行命令">#</a></h1>
<p>sed编辑器包含了三个可用来处理多行文本的特殊命令。</p>
<ol>
<li>N:将数据流中的下一行加进来创建一个多行组(multiline group)来处理。</li>
<li>D:删除多行组中的一行。</li>
<li>P:打印多行组中的一行。</li>
</ol>
<h2 id="next命令">next命令<a hidden class="anchor" aria-hidden="true" href="#next命令">#</a></h2>
<h3 id="单行的next命令">单行的next命令<a hidden class="anchor" aria-hidden="true" href="#单行的next命令">#</a></h3>
<p>小写的n命令会告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始 再执行一遍。记住，通常sed编辑器在移动到数据流中的下一文本行之前，会在当前行上执行完 所有定义好的命令。单行next命令改变了这个流程。</p>
<pre><code>$ sed '/header/{n ; d}' data1.txt
</code></pre>
<p>脚本要查找含有单词header的那一行。找到之后，n命令会让sed编辑器移动到文 本的下一行，这时，sed编辑器会继续执行命令列表，该命令列表使用d命令来删除行。</p>
<p>sed编辑器执 行完命令脚本后，会从数据流中读取下一行文本，并从头开始执行命令脚本。因为sed编辑器再 也找不到包含单词header的行了。所以也不会有其他行会被删掉。</p>
<h3 id="合并文本行">合并文本行<a hidden class="anchor" aria-hidden="true" href="#合并文本行">#</a></h3>
<p>单行next命令会将数据流中的下一文本 行移动到sed编辑器的工作空间(称为模式空间)。多行版本的next命令(用大写N)会将下一文 本行添加到模式空间中已有的文本后。</p>
<p>这样的作用是将数据流中的两个文本行合并到同一个模式空间中。文本行仍然用换行符分 隔，但sed编辑器现在会将两行文本当成一行来处理。</p>
<pre><code>$ sed '/first/{ N ; s/\n/ / }' data2.txt
</code></pre>
<p>sed编辑器脚本查找含有单词first的那行文本。找到该行后，它会用N命令将下一行合并到那 5 行，然后用替换命令s将换行符替换成空格。结果是，文本文件中的两行在sed编辑器的输出中成了一行。</p>
<p>如果要在数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程
序。</p>
<pre><code>$ sed 'N ; s/System Administrator/Desktop User/' data3.txt
</code></pre>
<p>替换命令会在文本文件中查找特定的双词短语System Administrator。如果短语在一行 中的话，事情很好处理，替换命令可以直接替换文本。但如果短语分散在两行中的话，替换命令 就没法识别匹配的模式了。这时N命令就可以派上用场了。</p>
<pre><code>$ sed 'N ; s/System.Administrator/Desktop User/' data3.txt
</code></pre>
<p>注意，替换命令在System和Administrator之间用了通配符模式(.)来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这 可能不是你想要的。</p>
<p>要解决这个问题，可以在sed编辑器脚本中用两个替换命令:一个用来匹配短语出现在多行 中的情况，一个用来匹配短语出现在单行中的情况。</p>
<pre><code>$ sed 'N
&gt; s/System\nAdministrator/Desktop\nUser/ 
&gt; s/System Administrator/Desktop User/
&gt; ' data3.txt
</code></pre>
<p>但这个脚本中仍有个小问题。这个脚本总是在执行sed编辑器命令前将下一行文本读入到模 式空间。当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止。如果 要匹配的文本正好在数据流的最后一行上，命令就不会发现要匹配的数据。</p>
<p>你可以轻松地解决这个问题——将单行命令放到N命令 前面，并将多行命令放到N命令后面</p>
<pre><code>$ sed '
&gt; s/System Administrator/Desktop User/ 
&gt;N
&gt; s/System\nAdministrator/Desktop\nUser/ 
&gt; ' data4.txt
</code></pre>
<h2 id="多行删除命令">多行删除命令<a hidden class="anchor" aria-hidden="true" href="#多行删除命令">#</a></h2>
<p>sed编辑器用单行删除命令(d)来删除模式空间中的当前行。但和N命令一起使用时，使用单行删除命令就要小心了。</p>
<pre><code>$ sed 'N ; /System\nAdministrator/d' data4.txt
</code></pre>
<p>删除命令会在不同的行中查找单词System和Administrator，然后在模式空间中将两行都删掉。 这未必是你想要的结果。</p>
<p>sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符(含换行符)为止的所有字符。</p>
<p>这里有个例子，它会删除数据流中出现在第一行前的空白行。</p>
<pre><code>$ sed '/^$/{N ; /header/D}' data5.txt
</code></pre>
<p>sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式 空间内容含有单词header，则D命令会删除模式空间中的第一行。</p>
<h2 id="多行打印命令">多行打印命令<a hidden class="anchor" aria-hidden="true" href="#多行打印命令">#</a></h2>
<p>多行打印命令(P)只打印多行模式空间中的第一行。这包括模式空间中直到换行符为止的所有字符。当你用-n选项来阻止脚本输出时，它和显示文本的单行p命令的用法大同小异。</p>
<h1 id="保持空间">保持空间<a hidden class="anchor" aria-hidden="true" href="#保持空间">#</a></h1>
<p>模式空间(pattern space)是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本。但它并不是sed编辑器保存文本的唯一空间。</p>
<p>sed编辑器有另一块称作保持空间(hold space)的缓冲区域。在处理模式空间中的某些行时， 可以用保持空间来临时保存一些行。有5条命令可用来操作保持空间，</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170812-145144@2x.png" alt=""  />
</p>
<p>通常，在使用h或H命令将字符串移动到保持空间后，最终还要用g、G或x命令将保存的字符 串移回模式空间(否则，你就不用在一开始考虑保存它们了)。</p>
<p>由于有两个缓冲区域，弄明白哪行文本在哪个缓冲区域有时会比较麻烦。这里有个简短的例 子演示了如何用h和g命令来将数据在sed编辑器缓冲空间之间移动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ cat data2.txt
This is the header line.
This is the first data line.
This is the second data line.
This is the last line.
$
$ sed -n <span class="s1">&#39;/first/ {h ; p ; n ; p ; g ; p }&#39;</span> data2.txt

This is the first data line.
This is the second data line.
This is the first data line.
$
</code></pre></td></tr></table>
</div>
</div><p>我们来一步一步看上面这个代码例子:</p>
<p>(1) sed脚本在地址中用正则表达式来过滤出含有单词first的行;</p>
<p>(2) 当含有单词first的行出现时，h命令将该行放到保持空间;</p>
<p>(3) p命令打印模式空间也就是第一个数据行的内容;</p>
<p>(4) n命令提取数据流中的下一行(This is the second data line)，并将它放到模式空间;</p>
<p>(5) p命令打印模式空间的内容，现在是第二个数据行;</p>
<p>(6) g命令将保持空间的内容(This is the first data line)放回模式空间，替换当
前文本;</p>
<p>(7) p命令打印模式空间的当前内容，现在变回第一个数据行了。</p>
<p>通过使用保持空间来回移动文本行，你可以强制输出中第一个数据行出现在第二个数据行后 面。如果丢掉了第一个p命令，你可以以相反的顺序输出这两行。</p>
<h1 id="排除命令">排除命令<a hidden class="anchor" aria-hidden="true" href="#排除命令">#</a></h1>
<p>感叹号命令(!)用来排除(negate)命令，也就是让原本会起作用的命令不起作用。下面的例子演示了这一特性。</p>
<pre><code>$ sed -n '/header/!p' data2.txt
</code></pre>
<p>普通p命令只打印data2文件中包含单词header的那行。加了感叹号之后，情况就相反了:除了包含单词header那一行外，文件中其他所有的行都被打印出来了。</p>
<p>很多情况下sed编辑器无法处理数据流中最后一行文本，因为之后再没有其他行了。可以使用感叹号与N命令以及与美元符特殊地址。</p>
<pre><code>$ sed '$!N;
&gt; s/System\nAdministrator/Desktop\nUser/ 
&gt; s/System Administrator/Desktop User/
&gt; ' data4.txt
</code></pre>
<p>美元符表示数据流中 的最后一行文本，所以当sed编辑器到了最后一行时，它没有执行N命令，但它对所有其他行都执行了这个命令。</p>
<h1 id="改变流">改变流<a hidden class="anchor" aria-hidden="true" href="#改变流">#</a></h1>
<p>通常，sed编辑器会从脚本的顶部开始，一直执行到脚本的结尾(D命令是个例外，它会强制 sed编辑器返回到脚本的顶部，而不读取新的行)。sed编辑器提供了一个方法来改变命令脚本的执 行流程，其结果与结构化编程类似。</p>
<h2 id="分支">分支<a hidden class="anchor" aria-hidden="true" href="#分支">#</a></h2>
<p>sed编辑器提供了一种方法，可以基于地址、地址模式或地址区间排除一整块命令。这允许你只对数据流中的特定行执行一组命令。</p>
<p>分支(branch)命令b的格式如下:</p>
<pre><code>[address]b [label]
</code></pre>
<p>address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如 果没有加label参数，跳转命令会跳转到脚本的结尾。</p>
<pre><code>sed '{2,3b ; s/This is/Is this/ ; s/line./test?/}' data2.txt
</code></pre>
<p>分支命令在数据流中的第2行和第3行处跳过了两个替换命令。</p>
<p>要是不想直接跳到脚本的结尾，可以为分支命令定义一个要跳转到的标签。标签以冒号开始， 最多可以是7个字符长度。</p>
<pre><code>:label2 
</code></pre>
<p>要指定标签，将它加到b命令后即可。使用标签允许你跳过地址匹配处的命令，但仍然执行
脚本中的其他命令。</p>
<pre><code>$ sed '{/first/b jump1 ; s/This is the/No jump on/ 
&gt; :jump1
&gt; s/This is the/Jump here on/}' data2.txt
</code></pre>
<p>跳转命令指定如果文本行中出现了first，程序应该跳到标签为jump1的脚本行。如果分支命令的模式没有匹配，sed编辑器会继续执行脚本中的命令，包括分支标签后的命令(因此，所 有的替换命令都会在不匹配分支模式的行上执行)。</p>
<p>如果某行匹配了分支模式， sed编辑器就会跳转到带有分支标签的那行。因此，只有最后一 个替换命令会执行。</p>
<p>这个例子演示了跳转到sed脚本后面的标签上。也可以跳转到脚本中靠前面的标签上，这样
就达到了循环的效果。</p>
<pre><code>$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n 	'{ &gt; :start
&gt; s/,//1p
&gt; b start
&gt; }'
</code></pre>
<p>脚本的每次迭代都会删除文本中的第一个逗号，并打印字符串。这个脚本有个问题:它永远 不会结束。这就形成了一个无穷循环，不停地查找逗号，直到使用Ctrl+C组合键发送一个信号，手动停止这个脚本。</p>
<p>要防止这个问题，可以为分支命令指定一个地址模式来查找。如果没有模式，跳转就应该
结束。</p>
<pre><code>$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n '{ &gt; :start
&gt; s/,//1p
&gt; /,/b start
&gt; }'
</code></pre>
<p>现在分支命令只会在行中有逗号的情况下跳转。在最后一个逗号被删除后，分支命令不会再 执行，脚本也就能正常停止了。</p>
<h2 id="测试">测试<a hidden class="anchor" aria-hidden="true" href="#测试">#</a></h2>
<p>类似于分支命令，测试(test)命令(t)也可以用来改变sed编辑器脚本的执行流程。测 试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。</p>
<p>如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令 未能匹配指定的模式，测试命令就不会跳转。</p>
<p>测试命令使用与分支命令相同的格式。</p>
<pre><code>[address]t [label] 
</code></pre>
<p>跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。 测试命令提供了对数据流中的文本执行基本的if-then语句的一个低成本办法。举个例子，
如果已经做了一个替换，不需要再做另一个替换，那么测试命令能帮上忙。</p>
<pre><code>$ sed '{
&gt; s/first/matched/
&gt;t
&gt; s/This is the/No match on/ &gt; }' data2.txt
</code></pre>
<p>第一个替换命令会查找模式文本first。如果匹配了行中的模式，它就会替换文本，而且测 试命令会跳过后面的替换命令。如果第一个替换命令未能匹配模式，第二个替换命令就会被执行。</p>
<p>有了测试命令，你就能结束之前用分支命令形成的无限循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">echo</span> <span class="s2">&#34;This, is, a, test, to, remove, commas. &#34;</span> <span class="p">|</span> sed -n <span class="s1">&#39;{ 
</span><span class="s1">&gt; :start
</span><span class="s1">&gt; s/,//1p
</span><span class="s1">&gt; t start
</span><span class="s1">&gt; }&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>当无需替换时，测试命令不会跳转而是继续执行剩下的脚本。</p>
<h1 id="模式替代">模式替代<a hidden class="anchor" aria-hidden="true" href="#模式替代">#</a></h1>
<p>你已经知道了如何在sed命令中使用模式来替代数据流中的文本。然而在使用通配符时，很 难知道到底哪些文本会匹配模式。用于替代的字符串无法匹配 已匹配单词中的通配符字符。</p>
<pre><code>$ echo &quot;The cat sleeps in his hat.&quot; | sed 's/.at/&quot;.at&quot;/g' 
The &quot;.at&quot; sleeps in his &quot;.at&quot;.
$
</code></pre>
<h2 id="符号">&amp;符号<a hidden class="anchor" aria-hidden="true" href="#符号">#</a></h2>
<p>sed编辑器提供了一个解决办法。&amp;符号可以用来代表替换命令中的匹配的模式。不管模式匹 配的是什么样的文本，你都可以在替代模式中使用&amp;符号来使用这段文本。这样就可以操作模式 所匹配到的任何单词了。</p>
<pre><code>$ echo &quot;The cat sleeps in his hat.&quot; | sed 's/.at/&quot;&amp;&quot;/g'
 The &quot;cat&quot; sleeps in his &quot;hat&quot;.
$
</code></pre>
<h2 id="替代单独的单词">替代单独的单词<a hidden class="anchor" aria-hidden="true" href="#替代单独的单词">#</a></h2>
<p>sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用
每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子模式分配字符\1，给第二个子模式分配字符\2，依此类推。</p>
<p>当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆 括号。这跟转义其他特殊字符正好相反。</p>
<pre><code>$ echo &quot;The System Administrator manual&quot; | sed '
&gt; s/\(System\) Administrator/\1 User/'
The System User manual 12 
$
</code></pre>
<p>这个替换命令用一对圆括号将单词System括起来，将其标示为一个子模式。然后它在替代模 式中使用\1来提取第一个匹配的子模式。这没什么特别的，但在处理通配符模式时却特别有用。</p>
<p>如果需要用一个单词来替换一个短语，而这个单词刚好是该短语的子字符串，但那个子字符 串碰巧使用了通配符，这时使用子模式会方便很多。</p>
<pre><code>$ echo &quot;That furry cat is pretty&quot; | sed 's/furry \(.at\)/\1/'
</code></pre>
<p>当需要在两个或多个子模式间插入文本时，这个特性尤其有用。这里有个脚本，它使用子模
式在大数字中插入逗号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">echo</span> <span class="s2">&#34;1234567&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;{
</span><span class="s1">&gt; :start
</span><span class="s1">&gt; s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/ 
</span><span class="s1">&gt; t start
</span><span class="s1">&gt; }&#39;</span>
1,234,567
$
</code></pre></td></tr></table>
</div>
</div><p>这个模式会查找两个子模式。第一个子模式是以数字结尾的任意长度的字符。第二个子模式 是若干组三位数字.如果这个模式 在文本中找到了，替代文本会在两个子模式之间加一个逗号，每个子模式都会通过其位置来标示。 这个脚本使用测试命令来遍历这个数字，直到放置好所有的逗号。</p>
<h1 id="在脚本中使用sed">在脚本中使用sed<a hidden class="anchor" aria-hidden="true" href="#在脚本中使用sed">#</a></h1>
<h2 id="使用包装脚本">使用包装脚本<a hidden class="anchor" aria-hidden="true" href="#使用包装脚本">#</a></h2>
<p>你可能已经注意到，实现sed编辑器脚本的过程很烦琐，尤其是脚本很长的话。可以将sed编 辑器命令放到shell包装脚本(wrapper)中，不用每次使用时都重新键入整个脚本。包装脚本充当 着sed编辑器脚本和命令行之间的中间人角色。</p>
<p>在shell脚本中，可以将普通的shell变量及参数和sed编辑器脚本一起使用。这里有个将命令行 参数变量作为sed脚本输入的例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ cat reverse.sh
<span class="c1">#!/bin/bash</span>
<span class="c1"># Shell wrapper for sed editor script.</span>
<span class="c1"># to reverse text file lines.</span>
<span class="c1">#</span>
sed -n <span class="s1">&#39;{ 1!G ; h ; $p }&#39;</span> <span class="nv">$1</span>
<span class="c1">#</span>
$
</code></pre></td></tr></table>
</div>
</div><p>名为reverse的shell脚本用sed编辑器脚本来反转数据流中的文本行。它使用shell参数$1从命令 2 行中提取第一个参数，这正是需要进行反转的文件名。</p>
<h2 id="重定向sed的输出">重定向sed的输出<a hidden class="anchor" aria-hidden="true" href="#重定向sed的输出">#</a></h2>
<p>默认情况下，sed编辑器会将脚本的结果输出到STDOUT上。你可以在shell脚本中使用各种标 准方法对sed编辑器的输出进行重定向。</p>
<p>可以在脚本中用$()将sed编辑器命令的输出重定向到一个变量中，以备后用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="nv">result</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$factorial</span> <span class="p">|</span> sed <span class="s1">&#39;{ :start s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
</span><span class="s1">t start
</span><span class="s1">}&#39;</span><span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
