<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>线性同余法与伪随机数 | Forz Blog</title>
<meta name="keywords" content="线性同余, 随机数" />
<meta name="description" content="公式定义 在离散数据及其应用中，如果 那么，称a模m同余b（或者称模m时，a等价于b），可以记为 而线性同余式就可以这样表示： 线性同余发生器与上面">
<meta name="author" content="">
<link rel="canonical" href="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="线性同余法与伪随机数" />
<meta property="og:description" content="公式定义 在离散数据及其应用中，如果 那么，称a模m同余b（或者称模m时，a等价于b），可以记为 而线性同余式就可以这样表示： 线性同余发生器与上面" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-09T15:10:17&#43;00:00" />
<meta property="article:modified_time" content="2019-10-09T15:10:17&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="线性同余法与伪随机数"/>
<meta name="twitter:description" content="公式定义 在离散数据及其应用中，如果 那么，称a模m同余b（或者称模m时，a等价于b），可以记为 而线性同余式就可以这样表示： 线性同余发生器与上面"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "线性同余法与伪随机数",
      "item": "/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "线性同余法与伪随机数",
  "name": "线性同余法与伪随机数",
  "description": "公式定义 在离散数据及其应用中，如果 那么，称a模m同余b（或者称模m时，a等价于b），可以记为 而线性同余式就可以这样表示： 线性同余发生器与上面",
  "keywords": [
    "线性同余", "随机数"
  ],
  "articleBody": "公式定义 在离散数据及其应用中，如果\n那么，称a模m同余b（或者称模m时，a等价于b），可以记为\n而线性同余式就可以这样表示：\n线性同余发生器与上面的线性同余式多少有一些关系。\n按照The Art of Computer Programming,Volume 2[1]中3.21. The Linear Congruential Method的思路，线性同余发生器（LCG：Linear Congruential Generators ）可以采用如下公式化定义:\n其中：\n模数m和系数a是这个公式中最重要的参数，如何合理的选择这两个参数决定了其产生的线性同余序列（LCS：Linear Congruential Scquence）：质量的优劣($X_1$,$X_2$,$X_3$..$X_n$…)。\n常数c可以为0，也可以不为0。通常，如果c=0，那么（2）式也称作乘法线性同余发生器（MCG：Multiplicative Congruential Generator），如果c非0，（2）式,则称作混合线性同余发生器（Mixed Linear Congruential Generator）。\n$X_0$称作初始值，也就是所谓的种子seed。\n线性同余序列的周期 如上的线性同余发生器产生的线性同余序列必然会存在一个周期P。在TAOCP中，作者以一个练习的方式提出了这个问题（exercise 3.1-6）。以下通过一种简单直白但不严谨的推理来解释这个问题。\n将上述线性同余公式抽象为一个函数f（将$X_n$映射为$X_{n+1}$），这个函数具有自封闭特性。不难发现，实际上存在以下已知条件：\n定义两个集合：S和T。初始状态下，集合S包含了从0到m-1所有的m个元素，集合T是一个空集。\n现模拟产生LCS的过程，以任意值$X_0$为参数，产生第一个伪随机数$X_1$。其值必然属于集合S，此时将$X_1$从集合S移动到集合T。\n以$X_1$为参数，产生第二个伪随机数$X_2$=f($X_1$)，此时，$X_2$有可能属于集合S，也有可能属于集合T。\n  如果$X_2$属于集合S，那么此时还没有产生一个周期；\n  如果$X_2$属于集合T，此处也就是刚好等于$X_1$，那么此时一个周期产生，周期P=1。\n  更一般地，假设在生成$X_1$到$X_{i-1}$过程中，每个数都是在集合S中找到的，则每个数都从集合S中移动到了集合T，此时两个集合的状态为：\n然后生成$X_i$时，\n  如果$X_i$=f($X_{i-1}$)在集合S中，则未能产生一个周期；\n  如果$X_i$=f($X_{i-1}$)在集合T中，则一个周期产生，此时周期P 当然周期P也有可能等于m，也就是集合S最终为空集，集合T容纳了0到m-1的所有元素，且f(Xm)=$X_1$。\n因此，从以上推理不难得知，LCS必然存在一个周期P，且P进而不难推断：\n  如果某LCG产生的随机序列的周期P小于m，则选取不同的初始值$X_0$产生的LCS可能有不同的周期。\n  如果其周期P=m，则即使选取不同的$X_0$，产生的这些LCS具有相同的周期且必定为P。\n  例如，对于下面发生器：\n如果以初始值$X_0$=12产生随机序列为：\n1  7,6,9,0,7,6,9,0,7,6,9,0,7,6,9,0......   如果以初始值$X_0$=13产生随机序列则为：\n1  8,3,8,3,8,3,8,3,8,3,8,3,8,3......   但是，对于如下的发生器：\n无论选取何值为种子产生的随机序列，其周期都是16。\n关于参数选择 构造一个表现良好的线性同余发生器并非易事，不但考虑其产生的随机序列的周期、随机分布特点，还要考虑计算的效率。\n在参数的选择方面，最关键的就是m和a的选择。\nm 选择 m应该尽可能大，这样才有可能产生较长的周期。如果计算机的字长为w位，TAOCP中推荐，应该取m=2^w，或者m=2^w+1，或者m=2^w-1，也可以取小于2^w的最大的素数，在论文TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE[2] 中就采用了这种m值选取的方式。\n通常而言，如果取m=2^w，则利用位运算往往会使计算过程更加方便和高效，但是会存在一个问题：产生的随机序列中各元素的低比特位的随机性并不是很好。\n简单的解释是，当m=2^w时，对于一个s位的整数Z，Z模m的结果实际上就是Z的比特位中右边的s-w位的结果。\n作者在原文中用了比较形式化的描述来说明这个问题：\n假设d是m的一个因子，q为某一整数，令Yn满足如下关系：\n然后进行如下变换：\n不难发现由公式3-1-1实际就是一个线性同余发生器，产生的随机序列也具有周期，但是其周期小于等于d。\n这里的序列实际上对应了原线性同余序列的低位字节，可以将序列理解为是将的低位单独抽取出来组成的一个序列。例如如果d=2^4， 则序列的周期最大也就是16，对应了序列中各个元素的低4位比特位的周期最大是16，显然低位的随机性并不是很好。正是由于这个原因，有些平台的实现会丢弃这些随机性不好的低比特位，截取高比特位以取得一个比较好的随机性效果。大多数应用场景中，低比特位并不会对最终用途产生影响，因此选取m=2^w 基本能够满足要求，实际上很多平台也确实都是取m=2^w。\n如果m取2^w +1或者m=2^w -1，则不会产生上述问题。\na 选择 a的选择推理过程比较复杂一些。一般来讲，应该使LCS的周期尽量长（最长为m），然后只使用一个周期内的元素，但是周期长的序列可能并不具有很好的随机性。\n比如如下的线性同余发生器：\n以初始值$X_0$=3产生随机序列的结果：\n1  4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3......   可见，以上序列的随机性表现很糟糕。\n在TAOCP中证明了如下定理，按照如下方式来选定系数a可以产生最大周期为m的LCS。\n以上定理表明当c不等0时（c与m互质当然就不可能等于0），有可能产生周期为m的LCS。\n另一方面，当c=0时，也即：\n是否也有可能产生周期为m的LCS呢？答案是必然不可能。\n一个简单的反证法：\n如果c=0时，产生了周期为m的LCS，那么0必然在这个序列中，但是如果0在序列中，必然会导致LCS退化成全0的序列，因此原命题必然不成立。\n从另一个角度考虑：\n考虑d是m的一个因子，且$X_n$是d的倍数，也即$X_n$=kd，其中k为某整数。于是有如下推导：\n由此可知，$X_n$+1也是d的倍数，同理，后面的$X_n$+2，$X_n$+2也是d的倍数，现在这样的序列也不是一个号的序列。所以如果要求序列中各个元素分别与m形成互质关系，因此这样的序列的元素个数实际就是欧拉函数对m求值，也即：\n总结 简单总结几点即是：\n  模数m应该尽可能大，通常至少大于2^30，为了计算效率，通常会结合计算机的字长考虑选取m的值。m值直接影响伪随机数序列的周期长短。\n  如果m选取为2的幂，也即m=2^w，则选取的a通常应该满足a模8等于5。当a=1的时候，Xn=（X0+nc）mod m ，它不具有随机序列的特性；而当a=0的时候甚至更糟糕。因此，为实用起见，选择2  当参数m和a的选定比较合理时，对于c的选择约束性不是很强烈，但要保证c与m互质。例如c可以选择1或者11。当c=0时，数的生成过程比c！=0的时候要稍微快些，它的限制缩短了这个序列的周期长度，但是也仍然有可能得到一个相当长的周期。当c=0时被称为乘同余法，c！=0称为混合同余法。为了一般性，我建议选择采用混合同余法。增量c满足b=2q+1。其中p,q都是正整数。\n  种子seed应该是随机选取的，可以将时间戳作为种子。\n  a和c值越大，产生的伪随机数越均匀。\n  a和m互质，产生的随机数效果较不互质好。\n  因为$X_n$的低有效位的随机性表现并不是很好，所以在对$X_n$的随机特性比较敏感的应用场景中，应该尽量采用高比特位。事实上，更应该将值$X_n$/m视为0到1之间的均匀分布，而不是直接将$X_n$视为0到m-1之间的均匀分布。所以，如果希望产生0到k-1之间的均匀分布伪随机数，应该采用k$X_n$/m的方式。\nMCG 当LCG的c = 0，它被称为multiplier congruence generator(MCG). 这种情况下不可能达到满周期，即周期一定小于M。且种子不能为0（也不能是M、2M、3M…），否则得到的序列将是全zero。\n在MCG中，若a是M的Primitive Root，则此MCG的周期等于T-1。一个具体的例子，当M=2^31 − 1，则M具有以下Primitive Root: 16807, 397204094, 764261123, 630360016. 就我目前看过的代码中, 选16807的居多.\n因为 M = 2^31 − 1 = 2147483647 = 127773 * 16807 + 2836\n我们可以用127773把seed分成高位和低位两部分.\nseed = hi* 127773 + lo ;\n所以 seed * 16807 = hi* 127773 * 16807 + lo * 16807 = hi * (M - 2836) + lo * 16807\n上式最右端对M取余后得到 lo * 16807 - hi * 2836\n但是这个计算结果有可能是负数, 此时让它加上M. 就回到[0,M)的范围内了.\n但是这个技巧其实并不高明. 因为把seed拆成hi和lo两部分的时候, 需要计算除法. 而在现代CPU上, 除法的代价是乘法的10-30倍, 很可怕.\n注意，multiplier congruence generator（c=0）生成的是[1，M - 1]上的均匀分布。所以一般来说会把它减去1后再返回，这样得到的就是[0, M-2]上的均匀分布. 假如你拿它做随机抽样, 结果数组中第一个元素永远也抽不中.\n参考:\nhttps://www.cnblogs.com/qcblog/p/8450427.html\nhttps://blog.csdn.net/orchidzouqr/article/details/53139220 http://www.voidcn.com/article/p-kprhvxyq-pn.html\n",
  "wordCount" : "3629",
  "inLanguage": "zh-cn",
  "datePublished": "2019-10-09T15:10:17Z",
  "dateModified": "2019-10-09T15:10:17Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95%E4%B8%8E%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      线性同余法与伪随机数
    </h1>
    <div class="post-meta">October 9, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="公式定义">公式定义<a hidden class="anchor" aria-hidden="true" href="#公式定义">#</a></h1>
<p>在离散数据及其应用中，如果</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009163955.png" alt=""  />
</p>
<p>那么，称a模m同余b（或者称模m时，a等价于b），可以记为</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009164001.png" alt=""  />
</p>
<p>而线性同余式就可以这样表示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009164010.png" alt=""  />
</p>
<p>线性同余发生器与上面的线性同余式多少有一些关系。</p>
<p>按照The Art of Computer Programming,Volume 2[1]中3.21. The Linear Congruential Method的思路，线性同余发生器（LCG：Linear Congruential Generators  ）可以采用如下公式化定义:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009164144.png" alt=""  />
</p>
<p>其中：</p>
<p>模数m和系数a是这个公式中最重要的参数，如何合理的选择这两个参数决定了其产生的线性同余序列（LCS：Linear Congruential Scquence）：质量的优劣($X_1$,$X_2$,$X_3$..$X_n$&hellip;)。</p>
<p>常数c可以为0，也可以不为0。通常，如果c=0，那么（2）式也称作乘法线性同余发生器（MCG：Multiplicative Congruential Generator），如果c非0，（2）式,则称作混合线性同余发生器（Mixed Linear Congruential Generator）。</p>
<p>$X_0$称作初始值，也就是所谓的种子seed。</p>
<h1 id="线性同余序列的周期">线性同余序列的周期<a hidden class="anchor" aria-hidden="true" href="#线性同余序列的周期">#</a></h1>
<p>如上的线性同余发生器产生的线性同余序列必然会存在一个周期P。在TAOCP中，作者以一个练习的方式提出了这个问题（exercise 3.1-6）。以下通过一种简单直白但不严谨的推理来解释这个问题。</p>
<p>将上述线性同余公式抽象为一个函数f（将$X_n$映射为$X_{n+1}$），这个函数具有自封闭特性。不难发现，实际上存在以下已知条件：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009165144.png" alt=""  />
</p>
<p>定义两个集合：S和T。初始状态下，集合S包含了从0到m-1所有的m个元素，集合T是一个空集。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009165154.png" alt=""  />
</p>
<p>现模拟产生LCS的过程，以任意值$X_0$为参数，产生第一个伪随机数$X_1$。其值必然属于集合S，此时将$X_1$从集合S移动到集合T。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009165202.png" alt=""  />
</p>
<p>以$X_1$为参数，产生第二个伪随机数$X_2$=f($X_1$)，此时，$X_2$有可能属于集合S，也有可能属于集合T。</p>
<ol>
<li>
<p>如果$X_2$属于集合S，那么此时还没有产生一个周期；</p>
</li>
<li>
<p>如果$X_2$属于集合T，此处也就是刚好等于$X_1$，那么此时一个周期产生，周期P=1。</p>
</li>
</ol>
<p>更一般地，假设在生成$X_1$到$X_{i-1}$过程中，每个数都是在集合S中找到的，则每个数都从集合S中移动到了集合T，此时两个集合的状态为：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009165608.png" alt=""  />
</p>
<p>然后生成$X_i$时，</p>
<ol>
<li>
<p>如果$X_i$=f($X_{i-1}$)在集合S中，则未能产生一个周期；</p>
</li>
<li>
<p>如果$X_i$=f($X_{i-1}$)在集合T中，则一个周期产生，此时周期P&lt;=i-1。</p>
</li>
</ol>
<p>当然周期P也有可能等于m，也就是集合S最终为空集，集合T容纳了0到m-1的所有元素，且f(Xm)=$X_1$。</p>
<p>因此，从以上推理不难得知，LCS必然存在一个周期P，且P&lt;=m。</p>
<p>进而不难推断：</p>
<ol>
<li>
<p>如果某LCG产生的随机序列的周期P小于m，则选取不同的初始值$X_0$产生的LCS可能有不同的周期。</p>
</li>
<li>
<p>如果其周期P=m，则即使选取不同的$X_0$，产生的这些LCS具有相同的周期且必定为P。</p>
</li>
</ol>
<p>例如，对于下面发生器：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009165801.png" alt=""  />
</p>
<p>如果以初始值$X_0$=12产生随机序列为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">7,6,9,0,7,6,9,0,7,6,9,0,7,6,9,0......
</code></pre></td></tr></table>
</div>
</div><p>如果以初始值$X_0$=13产生随机序列则为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">8,3,8,3,8,3,8,3,8,3,8,3,8,3......
</code></pre></td></tr></table>
</div>
</div><p>但是，对于如下的发生器：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009165808.png" alt=""  />
</p>
<p>无论选取何值为种子产生的随机序列，其周期都是16。</p>
<h1 id="关于参数选择">关于参数选择<a hidden class="anchor" aria-hidden="true" href="#关于参数选择">#</a></h1>
<p>构造一个表现良好的线性同余发生器并非易事，不但考虑其产生的随机序列的周期、随机分布特点，还要考虑计算的效率。</p>
<p>在参数的选择方面，最关键的就是m和a的选择。</p>
<h2 id="m-选择">m 选择<a hidden class="anchor" aria-hidden="true" href="#m-选择">#</a></h2>
<p>m应该尽可能大，这样才有可能产生较长的周期。如果计算机的字长为w位，TAOCP中推荐，应该取m=2^w，或者m=2^w+1，或者m=2^w-1，也可以取小于2^w的最大的素数，在论文TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE[2] 中就采用了这种m值选取的方式。</p>
<p>通常而言，如果取m=2^w，则利用位运算往往会使计算过程更加方便和高效，但是会存在一个问题：产生的随机序列中各元素的低比特位的随机性并不是很好。</p>
<p>简单的解释是，当m=2^w时，对于一个s位的整数Z，Z模m的结果实际上就是Z的比特位中右边的s-w位的结果。</p>
<p>作者在原文中用了比较形式化的描述来说明这个问题：</p>
<p>假设d是m的一个因子，q为某一整数，令Yn满足如下关系：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009171203.png" alt=""  />
</p>
<p>然后进行如下变换：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009171212.png" alt=""  />
</p>
<p>不难发现由公式3-1-1实际就是一个线性同余发生器，产生的随机序列也具有周期，但是其周期小于等于d。</p>
<p>这里的&lt;Y&gt;序列实际上对应了原线性同余序列&lt;X&gt;的低位字节，可以将序列&lt;Y&gt;理解为是将&lt;X&gt;的低位单独抽取出来组成的一个序列。例如如果d=2^4， 则序列<!-- raw HTML omitted -->的周期最大也就是16，对应了序列<!-- raw HTML omitted -->中各个元素的低4位比特位的周期最大是16，显然低位的随机性并不是很好。正是由于这个原因，有些平台的实现会丢弃这些随机性不好的低比特位，截取高比特位以取得一个比较好的随机性效果。大多数应用场景中，低比特位并不会对最终用途产生影响，因此选取m=2^w 基本能够满足要求，实际上很多平台也确实都是取m=2^w。</p>
<p>如果m取2^w +1或者m=2^w -1，则不会产生上述问题。</p>
<h2 id="a-选择">a 选择<a hidden class="anchor" aria-hidden="true" href="#a-选择">#</a></h2>
<p>a的选择推理过程比较复杂一些。一般来讲，应该使LCS的周期尽量长（最长为m），然后只使用一个周期内的元素，但是周期长的序列可能并不具有很好的随机性。</p>
<p>比如如下的线性同余发生器：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009173744.png" alt=""  />
</p>
<p>以初始值$X_0$=3产生随机序列的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3......
</code></pre></td></tr></table>
</div>
</div><p>可见，以上序列的随机性表现很糟糕。</p>
<p>在TAOCP中证明了如下定理，按照如下方式来选定系数a可以产生最大周期为m的LCS。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009173751.png" alt=""  />
</p>
<p>以上定理表明当c不等0时（c与m互质当然就不可能等于0），有可能产生周期为m的LCS。</p>
<p>另一方面，当c=0时，也即：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009174404.png" alt=""  />
</p>
<p>是否也有可能产生周期为m的LCS呢？答案是必然不可能。</p>
<p>一个简单的反证法：</p>
<p>如果c=0时，产生了周期为m的LCS，那么0必然在这个序列中，但是如果0在序列中，必然会导致LCS退化成全0的序列，因此原命题必然不成立。</p>
<p>从另一个角度考虑：</p>
<p>考虑d是m的一个因子，且$X_n$是d的倍数，也即$X_n$=kd，其中k为某整数。于是有如下推导：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009174425.png" alt=""  />
</p>
<p>由此可知，$X_n$+1也是d的倍数，同理，后面的$X_n$+2，$X_n$+2也是d的倍数，现在这样的序列也不是一个号的序列。所以如果要求序列中各个元素分别与m形成互质关系，因此这样的序列的元素个数实际就是欧拉函数对m求值，也即：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191009174440.png" alt=""  />
</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>简单总结几点即是：</p>
<ol>
<li>
<p>模数m应该尽可能大，通常至少大于2^30，为了计算效率，通常会结合计算机的字长考虑选取m的值。m值直接影响伪随机数序列的周期长短。</p>
</li>
<li>
<p>如果m选取为2的幂，也即m=2^w，则选取的a通常应该满足a模8等于5。当a=1的时候，Xn=（X0+nc）mod m ，它不具有随机序列的特性；而当a=0的时候甚至更糟糕。因此，为实用起见，选择2 &lt;= a&lt; m比较合理。乘数a最好满足a=4p+1；</p>
</li>
<li>
<p>当参数m和a的选定比较合理时，对于c的选择约束性不是很强烈，但要保证c与m互质。例如c可以选择1或者11。当c=0时，数的生成过程比c！=0的时候要稍微快些，它的限制缩短了这个序列的周期长度，但是也仍然有可能得到一个相当长的周期。当c=0时被称为乘同余法，c！=0称为混合同余法。为了一般性，我建议选择采用混合同余法。增量c满足b=2q+1。其中p,q都是正整数。</p>
</li>
<li>
<p>种子seed应该是随机选取的，可以将时间戳作为种子。</p>
</li>
<li>
<p>a和c值越大，产生的伪随机数越均匀。</p>
</li>
<li>
<p>a和m互质，产生的随机数效果较不互质好。</p>
</li>
</ol>
<p>因为$X_n$的低有效位的随机性表现并不是很好，所以在对$X_n$的随机特性比较敏感的应用场景中，应该尽量采用高比特位。事实上，更应该将值$X_n$/m视为0到1之间的均匀分布，而不是直接将$X_n$视为0到m-1之间的均匀分布。所以，如果希望产生0到k-1之间的均匀分布伪随机数，应该采用k$X_n$/m的方式。</p>
<h1 id="mcg">MCG<a hidden class="anchor" aria-hidden="true" href="#mcg">#</a></h1>
<p>当LCG的c = 0，它被称为multiplier congruence generator(MCG). 这种情况下不可能达到满周期，即周期一定小于M。且种子不能为0（也不能是M、2M、3M&hellip;），否则得到的序列将是全zero。</p>
<p>在MCG中，若a是M的Primitive Root，则此MCG的周期等于T-1。一个具体的例子，当M=2^31 − 1，则M具有以下Primitive Root: 16807, 397204094,  764261123, 630360016. 就我目前看过的代码中, 选16807的居多.</p>
<p>因为 M = 2^31 − 1 = 2147483647 = 127773 * 16807 + 2836</p>
<p>我们可以用127773把seed分成高位和低位两部分.</p>
<p>seed = hi* 127773 + lo ;</p>
<p>所以 seed * 16807 = hi* 127773 * 16807 + lo * 16807 = hi * (M - 2836) + lo * 16807</p>
<p>上式最右端对M取余后得到 lo * 16807 - hi * 2836</p>
<p>但是这个计算结果有可能是负数, 此时让它加上M. 就回到[0,M)的范围内了.</p>
<p>但是这个技巧其实并不高明. 因为把seed拆成hi和lo两部分的时候, 需要计算除法. 而在现代CPU上, 除法的代价是乘法的10-30倍, 很可怕.</p>
<p>注意，multiplier congruence generator（c=0）生成的是[1，M - 1]上的均匀分布。所以一般来说会把它减去1后再返回，这样得到的就是[0, M-2]上的均匀分布. 假如你拿它做随机抽样, 结果数组中第一个元素永远也抽不中.</p>
<p>参考:<br>
<a href="https://www.cnblogs.com/qcblog/p/8450427.html">https://www.cnblogs.com/qcblog/p/8450427.html</a><br>
<a href="https://blog.csdn.net/orchidzouqr/article/details/53139220">https://blog.csdn.net/orchidzouqr/article/details/53139220</a>
<a href="http://www.voidcn.com/article/p-kprhvxyq-pn.html">http://www.voidcn.com/article/p-kprhvxyq-pn.html</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99/">线性同余</a></li>
      <li><a href="/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/">随机数</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
