<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Prometheus的GoClient分析 | Forz Blog</title>
<meta name="keywords" content="Prometheus, Go" />
<meta name="description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro">
<meta name="author" content="">
<link rel="canonical" href="/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Prometheus的GoClient分析" />
<meta property="og:description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-17T16:43:42&#43;00:00" />
<meta property="article:modified_time" content="2020-07-17T16:43:42&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Prometheus的GoClient分析"/>
<meta name="twitter:description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Prometheus的GoClient分析",
      "item": "/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Prometheus的GoClient分析",
  "name": "Prometheus的GoClient分析",
  "description": "整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro",
  "keywords": [
    "Prometheus", "Go"
  ],
  "articleBody": "整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。\nCollector prometheus的Golang SDK设计得很地道, 充分利用了GO语言的特性.\n在SDK中所有的指标类型都实现了prometheus.Collector 接口.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // Collector is the interface implemented by anything that can be used by // Prometheus to collect metrics. A Collector has to be registered for // collection. See Registerer.Register. // // The stock metrics provided by this package (Gauge, Counter, Summary, // Histogram, Untyped) are also Collectors (which only ever collect one metric, // namely itself). An implementer of Collector may, however, collect multiple // metrics in a coordinated fashion and/or create metrics on the fly. Examples // for collectors already implemented in this library are the metric vectors // (i.e. collection of multiple instances of the same Metric but with different // label values) like GaugeVec or SummaryVec, and the ExpvarCollector. type Collector interface { // Describe sends the super-set of all possible descriptors of metrics \t// collected by this Collector to the provided channel and returns once \t// the last descriptor has been sent. The sent descriptors fulfill the \t// consistency and uniqueness requirements described in the Desc \t// documentation. (It is valid if one and the same Collector sends \t// duplicate descriptors. Those duplicates are simply ignored. However, \t// two different Collectors must not send duplicate descriptors.) This \t// method idempotently sends the same descriptors throughout the \t// lifetime of the Collector. If a Collector encounters an error while \t// executing this method, it must send an invalid descriptor (created \t// with NewInvalidDesc) to signal the error to the registry. \tDescribe(chan *Desc) // Collect is called by the Prometheus registry when collecting \t// metrics. The implementation sends each collected metric via the \t// provided channel and returns once the last metric has been sent. The \t// descriptor of each sent metric is one of those returned by \t// Describe. Returned metrics that share the same descriptor must differ \t// in their variable label values. This method may be called \t// concurrently and must therefore be implemented in a concurrency safe \t// way. Blocking occurs at the expense of total performance of rendering \t// all registered metrics. Ideally, Collector implementations support \t// concurrent readers. \tCollect(chan Metric) }   prometheus.Collector 接口中的方法传参都是只写的chan, 使得实现接口的代码无论是同步还是并行都可以. Describe(chanCollector 中 Describe 和 Collect 方法都是无状态的函数，其中 Describe 暴露全部可能的 Metric 描述列表，在注册（Register）或注销（Unregister）Collector 时会调用 Describe 来获取完整的 Metric 列表，用以检测 Metric 定义的冲突.\n另外在 github.com/prometheus/client_golang/prometheus/promhttp 下的 Instrument Handler 中，也会通过 Describe 获取 Metric 列表，并检查 label 列表（InstrumentHandler 中只支持 code 和 method 两种自定义 label）；而通过 Collect 可以获取采样数据，然后通过 HTTP 接口暴露给 Prom Server。另外，一些临时性的进程，如批处理任务，可以把数据 push 到 Push Gateway，由 Push Gateway 暴露 pull 接口，此处不赘述。\n四种指标 客户端对数据的收集大多是针对标准数据结构来进行的：\n Counter：收集事件次数等单调递增的数据 Gauge：收集当前的状态，比如数据库连接数 Histogram：收集随机正态分布数据，比如响应延迟 Summary：收集随机正态分布数据，和 Histogram 是类似的  每种标准数据结构还对应了 Vec 结构，通过 Vec 可以简洁的定义一组相同性质的 Metric，在采集数据的时候传入一组自定义的 Label/Value 获取具体的 Metric（Counter/Gauge/Histogram/Summary），最终都会落实到基本的数据结构上，这里不再赘述。\nCounter 和 Gauge Counter是计数器, 单调递增的, 只有服务重启时才会清零, 比如http请求数, errorLevel的log数. 值得一提的是, prometheus的内置函数求值时会自动处理重启清零的情况.\nGuage是一个可增可减的数值指标, 比如CPU使用率, 内存使用率, 协程数.\nGauge 和 Counter 基本实现上看是一个进程内共享的浮点数，基于 value 结构实现，而 Counter 和 Gauge 仅仅封装了对这个共享浮点数的各种操作和合法性检查逻辑。\n先看 Counter 中 Inc 函数的实现，图为 value 结构中 Inc 函数的实现。\ncounter的value是float64, 怎么无锁地操作float64呢? 答案是用math包将其视作uint64来操作.\nvalue.Add 中修改共享数据时采用了“无锁”实现，相比“有锁 (Mutex)”实现可以更充分利用多核处理器的并行计算能力，性能相比加 Mutex 的实现会有很大提升。图中是 Go Benchmark 的测试结果，对比了“有锁”（用 defer 或不用 defer 来释放锁）和“无锁”实现在多核场景下对性能的影响。\n注意图中针对“有锁”的实现，进行了两组实验，其中一组用 defer 来释放锁，可见在多核场景下“无锁”实现的性能最好也最稳定。\ncounter的Add方法不能传负数, 否则会panic.\nCounter 和 Gauge 中的其他操作都很简单，不赘述。\nHistogram Historygram是直方图, 适合需要知道数值分布范围的场景, 比如http请求的响应时长, http请求的响应包体大小等.\n直方图的组距不一定是固定的, 可以自己定义适合, 这里称其为bucket, 每一个metric value根据其数值大小落在对应的bucket.\nHistogram 实现了 Observer 接口，用来获取客户端状态初始化（重启）到某个时间点的采样点分布，监控数据常需要服从正态分布。\n先看通过 Histogram 采集一个 float64 数据的 Observe 方法实现（图 1.3.2）。\n此处每个 bucket 对应的 count 是不互相包含的，bucket 的计数器之和应该等于全局计数器，即 h.count == sum(h.counts) 是成立的。然而为了便于服务端存储和计算，最终服务端收集到的数据是向下包含的，这是在 histogram.Write（图 1.3.3）中实现的。\n图 1.3.4 中用表格形式给出了 Histogram 采集和整理数据的过程。\nHistogram 在客户端也是无锁的，因为每个采样点只更新一个具体 bucket 内的 Counter（float64），因此客户端性能开销相比 Counter 和 Gauge 而言没有明显改变，适合高并发的数据收集。\n图 1.3.5 为 Go 客户端的 Histogram 默认 bucket 设置，可以用来采集 Web 服务响应时间，实际应用中通常需要为监控对象选择合理的 buckets，buckets 应设置为正态分布中常用的分位点。\nSummary Summary相比Historygram是按百分位聚合好的直方图, 适合需要知道百分比分布范围的场景, 比如对于 http请求的响应时长, Historygram是侧重在于统计小于1ms的请求有多少个, 1ms~10ms的请求有多少个, 10ms以上的请求有多少个, 而Summary在于统计20%的请求的响应时间是多少, 50%的请求的响应时间是多少, 99%的请求的响应时间是多少. Historygram是计数原始数据, 开销小, 执行查询时有对应的函数计算得到p50, p99, 而Summary是在客户端SDK测做了聚合计算得到指定的百分位, 开销更大一些.\nSummary 是标准数据结构中最复杂的一个，用来收集服从正态分布的采样数据。在 Go 客户端 Summary 结构和 Histogram 一样，都实现了 Observer 接口（图 1.3.1）。\nSummary 中 quantile 实际上是正态分布中的分位点 ，如图 1.4.1 所示，图中的实心圆点分别代表 [0.025 0.25 0.50 0.75 0.975] 分位点，图 2.1.10 中 0.5 分位点的采样数据为 0，而 0.975 分位点的采样值为 2，这说明采样数据的绝大部分的峰值都在 2 附近。\n由于 Summary 结构的客户端实现相比其他几个结构而言复杂一些，先看一下 summary 结构的定义（图 1.4.2）。\nSummary 会将采集到的数据经过正态分布逼近得出对应分位点的采样数据，数据流如图 1.4.3 所示。\n接下来看 summary.Observe 实现，图 1.4.4 和 1.4.5 中加入了代码逻辑的注解。\n再看 summary.Write 实现，图 1.4.6 中加入了代码逻辑的注解。\nVec 带label的指标类型使用prometheus.NewCounterVec prometheus.NewGaugeVec prometheus.NewHistogramVec prometheus.NewSummaryVec, 不同的label值就像空间直角坐标系中的以原点为七点的不同方向的向量一样.\n调用Vec类型的WithLabelValues方法传入的value参数数量一定要和注册时定义的label数量一致, 否则会panic.\n以下是client go提供的对数组全部操作的接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  //metricVec实现了具体结构和接口，提供给四种数组类型调用,部分接口不提供给用户 //位于github.com/prometheus/client_golang/prometheus/vec.go type metricVec struct { *metricMap curry []curriedLabelValue hashAdd func(h uint64, s string) uint64 hashAddByte func(h uint64, b byte) uint64 } //删除匹配的labels，删除成功返回true，如果未找到则返回false，并不是error //两者的不同： // Delete用法： vec.Delete(Labels{\"l1\": \"v1\", \"l2\": \"v2\"}) // DeleteLabelValues用法： vec.DeleteLabelValues(\"v1\", \"v2\") //如果后者参数的顺序有问题，则返回false，而前者不会 //但是与之带来的是前者的开销要比后者大，因为前者要构建Labels映射 func (m *metricVec) DeleteLabelValues(lvs ...string) bool{} func (m *metricVec) Delete(labels Labels) bool {} type Observer interface { Observe(float64) } //XXX需要使用Counter,Gauge,Histogram,Summary来代替 //以下接口实现于counter.go, gauge.go, histogram.go, summary.go type XXXVec struct { *metricVec } //将返回数组实例，如 NewCounterVec，将返回一个 *CounterVec， //注意，调用时，opts 中， Histogtam的Budket不能有\"le\", Summary的quantile不能有\"quantile\"，否则painc() func NewXXXVec(opts XXXOpts, labelNames []string) *XXXVec{} //如果CounterVec则 TTT为Counter，GaugeVec则TTT为Gauge，Histogram和Summary则TTT为Observer  //获取Counter,Gauge,Histogram或Summary，如果存在则返回，不存在则创建，如果name相同，描述不同，则返回error。 //用法： // vec.GetMetricWith(Labels{\"l1\": \"v1\", \"l2\": \"v2\"}) // vec.GetMetricWithLabelValues(\"v1\", \"v2\") //很容易因为顺序问题而导致错误或获取不到，所以建议使用前者，但与之带来的是前者会有额外消耗 //如果我们只想获取，如果获取不到不创建新的的话，那么是做不到的，不过我们不保存返回的实例就好了。如果考虑到消耗，也可以使用Delete来移除它 func (v *XXXVec) GetMetricWith(labels Labels) (TTT, error){} func (v *XXXVec) GetMetricWithLabelValues(lvs ...string)(TTT, error){} //分别为GetMetricWith和GetMetricWithLabelValues的must形式 //即如果出错则panic(),不会返回error //不建议使用must形式，因为觉得我们自己处理error的能力还是要有的，即使我们捕捉到error之后和它做相同的事 func (v *XXXVec) WithLabelValues(lvs ...string) TTT{} func (v *XXXVec) With(labels Labels) TTT{} //CurryWith将根据传入的labels，进行匹配，返回xxxVec形式，xxxVec并不是数组类型！ //作用为了返回子xxxVec //注意，不要对返回值进行for range，因为不是数组，并且里面的值和方法并不是公开的。 //可能的使用情况： // TestHistogramVec := NewHistogramVec(HistogramVecOpts{ // Name : \"test_name\", // Help : \"test_help\", // Buckets: prometheus.LinearBuckets(20, 5, 5), // },[]string{\"color\",\"size\",\"weight\"}) // TestHistogramVecSon := CurryWith(\"color\":\"black\") func (v *XXXVec) CurryWith(labels Labels) (TTTVec, error){} //CurryWith的Must形式，出现异常直接panic() func (v *XXXVec) MustCurryWith(labels Labels) TTTVec{}   数组的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package main import ( \"net/http\" \"time\" \"log\" \"math\" \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" ) var ( MyTestHistogramVec = prometheus.NewHistogramVec(prometheus.HistogramOpts{ Name: \"human_weight_histogram\", Help: \"human weight histogram\", Buckets: prometheus.LinearBuckets(1, 10, 15), //第一个桶1起，每个桶间隔10, 共15个桶。 所以1,11,21,31,...,141 \t},[]string{\"sex\",\"age\",\"race\"},) ) func main() { prometheus.MustRegister(MyTestHistogramVec) go func(){ var i float64 for i  20 { //不要太在意赋的什么值了，随便写的，主要为了了解用法 \tMyTestHistogramVec.With(prometheus.Labels{\"sex\":\"man\",\"age\":\"20\",\"race\":\"black\"}).Observe(90 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels{\"sex\":\"woman\",\"age\":\"20\",\"race\":\"black\"}).Observe(70 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels{\"sex\":\"man\",\"age\":\"25\",\"race\":\"black\"}).Observe(95 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels{\"sex\":\"woman\",\"age\":\"25\",\"race\":\"black\"}).Observe(95 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) MyTestHistogramVec.With(prometheus.Labels{\"sex\":\"man\",\"age\":\"20\",\"race\":\"yellow\"}).Observe(90 + math.Floor(400*math.Sin(float64(i*127)*0.1))/10) time.Sleep(time.Second) i++ } }() http.Handle(\"/metrics\", promhttp.Handler()) log.Fatal(http.ListenAndServe(\"0.0.0.0:8080\", nil) }   Func 默认情况下, Collector都是主动去计数, 但有的指标无法主动计数, 比如监控服务当前打开的DB连接数, 这个指标更适合在拉取指标时去获取值, 这个时候就可以使用prometheus.NewCounterFunc prometheus.NewGaugeFunc, 传入一个返回指标值的函数func() float64, 在拉取指标时就会调用这个函数.\n自定义Collector go client Colletor只会在每次响应pro请求的时候才收集数据，并且需要每次显式传递变量的值，否则就不会再维持该变量，在pro也将看不到这个变量，Collector是一个接口，所有收集metrics数据的对象都需要实现这个接口，Counter和Gauage等不例外，它内部提供了两个函数，Collector用于收集用户数据，将收集好的数据传递给传入参数Channel就可，Descirbe函数用于描述这个Collector。当收集系统数据代价较大时，就可以自定义Collector收集的方式，优化流程，并且在某些情况下如果已经有了一个成熟的metrics，就不需要使用Counter,Gauage等这些数据结构，直接在Collector内部实现一个代理的功能即可，一些高阶的用法都可以通过自定义Collector实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  package main import ( \"github.com/prometheus/client_golang/prometheus\" \"github.com/prometheus/client_golang/prometheus/promhttp\" \"net/http\" ) type ClusterManager struct { Zone string OOMCountDesc *prometheus.Desc RAMUsageDesc *prometheus.Desc // ... many more fields } // Simulate prepare the data func (c *ClusterManager) ReallyExpensiveAssessmentOfTheSystemState() ( oomCountByHost map[string]int, ramUsageByHost map[string]float64, ) { // Just example fake data. \toomCountByHost = map[string]int{ \"foo.example.org\": 42, \"bar.example.org\": 2001, } ramUsageByHost = map[string]float64{ \"foo.example.org\": 6.023e23, \"bar.example.org\": 3.14, } return } // Describe simply sends the two Descs in the struct to the channel. func (c *ClusterManager) Describe(ch chan *prometheus.Desc) { ch  c.OOMCountDesc ch  c.RAMUsageDesc } func (c *ClusterManager) Collect(ch chan prometheus.Metric) { oomCountByHost, ramUsageByHost := c.ReallyExpensiveAssessmentOfTheSystemState() for host, oomCount := range oomCountByHost { ch  prometheus.MustNewConstMetric( c.OOMCountDesc, prometheus.CounterValue, float64(oomCount), host, ) } for host, ramUsage := range ramUsageByHost { ch  prometheus.MustNewConstMetric( c.RAMUsageDesc, prometheus.GaugeValue, ramUsage, host, ) } } // NewClusterManager creates the two Descs OOMCountDesc and RAMUsageDesc. Note // that the zone is set as a ConstLabel. (It's different in each instance of the // ClusterManager, but constant over the lifetime of an instance.) Then there is // a variable label \"host\", since we want to partition the collected metrics by // host. Since all Descs created in this way are consistent across instances, // with a guaranteed distinction by the \"zone\" label, we can register different // ClusterManager instances with the same registry. func NewClusterManager(zone string) *ClusterManager { return \u0026ClusterManager{ Zone: zone, OOMCountDesc: prometheus.NewDesc( \"clustermanager_oom_crashes_total\", \"Number of OOM crashes.\", []string{\"host\"}, prometheus.Labels{\"zone\": zone}, ), RAMUsageDesc: prometheus.NewDesc( \"clustermanager_ram_usage_bytes\", \"RAM usage as reported to the cluster manager.\", []string{\"host\"}, prometheus.Labels{\"zone\": zone}, ), } } func main() { workerDB := NewClusterManager(\"db\") workerCA := NewClusterManager(\"ca\") // Since we are dealing with custom Collector implementations, it might \t// be a good idea to try it out with a pedantic registry. \treg := prometheus.NewPedanticRegistry() reg.MustRegister(workerDB) reg.MustRegister(workerCA) http.Handle(\"/metrics\", promhttp.HandlerFor(reg, promhttp.HandlerOpts{})) http.ListenAndServe(\":8888\", nil) }   此时就可以去 http://localhost:8888/metrics 看到传递过去的数据了。示例中定义了两个matrics, host和zone分别是其label。 其实pro client内部提供了几个Collector供我们使用，我们可以参考他的实现，在源码包中可以找到go_collector.go, process_collecor.go, expvar_collector这三个文件的Collecor实现。\n集成优化建议 在编辑图表写查询语句时,不会显示指标类型, 所以最好看到metric name就能知道是一个什么类型的指标, 约定counter类型的指标名字以_total为后缀.\n在编辑图表写查询语句时, 也不会显示指标类型的单位, 所以最好看到metric name就能知道是一个什么单位的指标, 比如时长要写是纳秒还是毫秒还是秒, http_request_duration_seconds, 数据大小要写是MB还是bytes, client_grpc_sent_bytes_total.\n每个指标要有单个词的namespace前缀, 比如process_cpu_seconds_total, http_request_duration_seconds.\n客户端集成时，需要关注采集监控数据对程序性能和可靠性的影响，同时也需要关注数据完备性，即采集到的数据应完整、正确地反映监控对象的状态和变化，笔者提出以下两点思路：\n 为监控对象定义“恰当”的监控数据集，“恰当”要求在详细设计阶段梳理并细化整个监控对象，不引入多余的监控数据，也不应该出现监控盲点 根据每个监控数据的实际情况选择合理的数据结构  Go 客户端为 HTTP 层的集成提供了方便的 API，但使用中需要注意不要使用 github.com/prometheus/client_golang/prometheus 下定义的已经 deprecated 的 Instrument 函数（如图 1.5.1 中注释部分），除了会引入额外（通常不需要）的监控数据，不仅会对程序性能造成不利影响，而且可能存在危险的 race（如计算请求大小时存在 goroutine 并发地访问 Header 逻辑）。\nGo 客户端在后续的版本中给出了优化的 API，即 github.com/prometheus/client_golang/prometheus/promhttp 下的实现，为 HTTP Handler 的不同监控数据定义了独立的 InstrumentHandlerXXX（图 1.5.2），让监控数据集保持灵活可控，完全规避了图 1.5.1 中提到的几个问题。\n另外一个难点是根据实际使用场景，从 Histogram 和 Summary 中作出选择以及给予合理的初始化配置。\nHistogram 常使用 histogram_quantile 执行数据分析， histogram_quantile 函数通过分段线性近似模型逼近采样数据分布的 UpperBound（如图 1.5.3），误差是比较大的，其中红色曲线为实际的采样分布（正态分布），而实心圆点是 Histogram 的 bucket(0.01 0.25 0.50 0.75 0.95)，当求解 0.9 quantile 的采样值时会用 (0.75, 0.95) 两个相邻的的 bucket 来线性近似。\n而 Summary 的分位点是客户端预先定义好的，已知分位点可以求该分位点的采样值，相比 Histogram 而言能更准确地获取分位点的采样值。\n当然，Summary 精度高的代价是在客户端增加了额外的计算开销，而且 Summary 结构有频繁的全局锁操作，对高并发程序性能存在一定影响，图 1.5.4 是对 Histogram 和 Summary 分析 Benchmark 的结果，Observe 和 Write 操作都有着指数级别的差异，需要结合实际应用场景作出选择。\n带label的每次会去计算label值的hash找到对应的向量, 然后去计数, 所以label数不要太多, label值的长度不要太长, label值是要可枚举的并且不能太多, 否则执行查询时慢, 面板加载慢, 存储也费空间. label如果可以提前计算则尽量使用GetMetricWithLabelValues提前计算好得到一个普通的计数器, 减少每次计数的一次计算label的hash, 提升程序性能.\n对于时长time.Duration数据类型的指标值收集, time.Since是优化过的, 直接走runtimeNano, 无需走系统调用取当前时间, 性能优于time.Now后相减, 另外, 频繁调用time.Now在性能要求高的程序中也会变成不小的开销.\n参考:\nPrometheus 原理和源码分析 浅谈prometheus client golang\n",
  "wordCount" : "6572",
  "inLanguage": "zh-cn",
  "datePublished": "2020-07-17T16:43:42Z",
  "dateModified": "2020-07-17T16:43:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Prometheus的GoClient分析
    </h1>
    <div class="post-meta">July 17, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="整体结构分析">整体结构分析<a hidden class="anchor" aria-hidden="true" href="#整体结构分析">#</a></h1>
<p>无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717164717.png" alt=""  />
</p>
<h2 id="collector">Collector<a hidden class="anchor" aria-hidden="true" href="#collector">#</a></h2>
<p>prometheus的Golang SDK设计得很地道, 充分利用了GO语言的特性.</p>
<p>在SDK中所有的指标类型都实现了prometheus.Collector 接口.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Collector is the interface implemented by anything that can be used by
</span><span class="c1">// Prometheus to collect metrics. A Collector has to be registered for
</span><span class="c1">// collection. See Registerer.Register.
</span><span class="c1">//
</span><span class="c1">// The stock metrics provided by this package (Gauge, Counter, Summary,
</span><span class="c1">// Histogram, Untyped) are also Collectors (which only ever collect one metric,
</span><span class="c1">// namely itself). An implementer of Collector may, however, collect multiple
</span><span class="c1">// metrics in a coordinated fashion and/or create metrics on the fly. Examples
</span><span class="c1">// for collectors already implemented in this library are the metric vectors
</span><span class="c1">// (i.e. collection of multiple instances of the same Metric but with different
</span><span class="c1">// label values) like GaugeVec or SummaryVec, and the ExpvarCollector.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Collector</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Describe sends the super-set of all possible descriptors of metrics
</span><span class="c1"></span>	<span class="c1">// collected by this Collector to the provided channel and returns once
</span><span class="c1"></span>	<span class="c1">// the last descriptor has been sent. The sent descriptors fulfill the
</span><span class="c1"></span>	<span class="c1">// consistency and uniqueness requirements described in the Desc
</span><span class="c1"></span>	<span class="c1">// documentation. (It is valid if one and the same Collector sends
</span><span class="c1"></span>	<span class="c1">// duplicate descriptors. Those duplicates are simply ignored. However,
</span><span class="c1"></span>	<span class="c1">// two different Collectors must not send duplicate descriptors.) This
</span><span class="c1"></span>	<span class="c1">// method idempotently sends the same descriptors throughout the
</span><span class="c1"></span>	<span class="c1">// lifetime of the Collector. If a Collector encounters an error while
</span><span class="c1"></span>	<span class="c1">// executing this method, it must send an invalid descriptor (created
</span><span class="c1"></span>	<span class="c1">// with NewInvalidDesc) to signal the error to the registry.
</span><span class="c1"></span>	<span class="nf">Describe</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
	<span class="c1">// Collect is called by the Prometheus registry when collecting
</span><span class="c1"></span>	<span class="c1">// metrics. The implementation sends each collected metric via the
</span><span class="c1"></span>	<span class="c1">// provided channel and returns once the last metric has been sent. The
</span><span class="c1"></span>	<span class="c1">// descriptor of each sent metric is one of those returned by
</span><span class="c1"></span>	<span class="c1">// Describe. Returned metrics that share the same descriptor must differ
</span><span class="c1"></span>	<span class="c1">// in their variable label values. This method may be called
</span><span class="c1"></span>	<span class="c1">// concurrently and must therefore be implemented in a concurrency safe
</span><span class="c1"></span>	<span class="c1">// way. Blocking occurs at the expense of total performance of rendering
</span><span class="c1"></span>	<span class="c1">// all registered metrics. Ideally, Collector implementations support
</span><span class="c1"></span>	<span class="c1">// concurrent readers.
</span><span class="c1"></span>	<span class="nf">Collect</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>prometheus.Collector 接口中的方法传参都是只写的chan, 使得实现接口的代码无论是同步还是并行都可以. Describe(chan&lt;- *Desc)方法是在将Collector注册或注销时调用的, Collect(chan&lt;- Metric)方法是在被抓取收集指标时调用的.</p>
<p>Collector 中 Describe 和 Collect 方法都是无状态的函数，其中 Describe 暴露全部可能的 Metric 描述列表，在注册（Register）或注销（Unregister）Collector 时会调用 Describe 来获取完整的 Metric 列表，用以检测 Metric 定义的冲突.</p>
<p>另外在 github.com/prometheus/client_golang/prometheus/promhttp 下的 Instrument Handler 中，也会通过 Describe 获取 Metric 列表，并检查 label 列表（InstrumentHandler 中只支持 code 和 method 两种自定义 label）；而通过 Collect 可以获取采样数据，然后通过 HTTP 接口暴露给 Prom Server。另外，一些临时性的进程，如批处理任务，可以把数据 push 到 Push Gateway，由 Push Gateway 暴露 pull 接口，此处不赘述。</p>
<h2 id="四种指标">四种指标<a hidden class="anchor" aria-hidden="true" href="#四种指标">#</a></h2>
<p>客户端对数据的收集大多是针对标准数据结构来进行的：</p>
<ul>
<li>Counter：收集事件次数等单调递增的数据</li>
<li>Gauge：收集当前的状态，比如数据库连接数</li>
<li>Histogram：收集随机正态分布数据，比如响应延迟</li>
<li>Summary：收集随机正态分布数据，和 Histogram 是类似的</li>
</ul>
<p>每种标准数据结构还对应了 Vec 结构，通过 Vec 可以简洁的定义一组相同性质的 Metric，在采集数据的时候传入一组自定义的 Label/Value 获取具体的 Metric（Counter/Gauge/Histogram/Summary），最终都会落实到基本的数据结构上，这里不再赘述。</p>
<h1 id="counter-和-gauge">Counter 和 Gauge<a hidden class="anchor" aria-hidden="true" href="#counter-和-gauge">#</a></h1>
<p>Counter是计数器, 单调递增的, 只有服务重启时才会清零, 比如http请求数, errorLevel的log数. 值得一提的是, prometheus的内置函数求值时会自动处理重启清零的情况.</p>
<p>Guage是一个可增可减的数值指标, 比如CPU使用率, 内存使用率, 协程数.</p>
<p>Gauge 和 Counter 基本实现上看是一个进程内共享的浮点数，基于 value 结构实现，而 Counter 和 Gauge 仅仅封装了对这个共享浮点数的各种操作和合法性检查逻辑。</p>
<p>先看 Counter 中 Inc 函数的实现，图为 value 结构中 Inc 函数的实现。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717165337.png" alt=""  />
</p>
<p>counter的value是float64, 怎么无锁地操作float64呢? 答案是用math包将其视作uint64来操作.</p>
<p>value.Add 中修改共享数据时采用了“无锁”实现，相比“有锁 (Mutex)”实现可以更充分利用多核处理器的并行计算能力，性能相比加 Mutex 的实现会有很大提升。图中是 Go Benchmark 的测试结果，对比了“有锁”（用 defer 或不用 defer 来释放锁）和“无锁”实现在多核场景下对性能的影响。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717170718.png" alt=""  />
</p>
<p>注意图中针对“有锁”的实现，进行了两组实验，其中一组用 defer 来释放锁，可见在多核场景下“无锁”实现的性能最好也最稳定。</p>
<p>counter的Add方法不能传负数, 否则会panic.</p>
<p>Counter 和 Gauge 中的其他操作都很简单，不赘述。</p>
<h1 id="histogram">Histogram<a hidden class="anchor" aria-hidden="true" href="#histogram">#</a></h1>
<p>Historygram是直方图, 适合需要知道数值分布范围的场景, 比如http请求的响应时长, http请求的响应包体大小等.</p>
<p>直方图的组距不一定是固定的, 可以自己定义适合, 这里称其为bucket, 每一个metric value根据其数值大小落在对应的bucket.</p>
<p>Histogram 实现了 Observer 接口，用来获取客户端状态初始化（重启）到某个时间点的采样点分布，监控数据常需要服从正态分布。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717170929.png" alt=""  />
</p>
<p>先看通过 Histogram 采集一个 float64 数据的 Observe 方法实现（图 1.3.2）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717170955.png" alt=""  />
</p>
<p>此处每个 bucket 对应的 count 是不互相包含的，bucket 的计数器之和应该等于全局计数器，即 h.count == sum(h.counts) 是成立的。然而为了便于服务端存储和计算，最终服务端收集到的数据是向下包含的，这是在 histogram.Write（图 1.3.3）中实现的。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171312.png" alt=""  />
</p>
<p>图 1.3.4 中用表格形式给出了 Histogram 采集和整理数据的过程。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171331.png" alt=""  />
</p>
<p>Histogram 在客户端也是无锁的，因为每个采样点只更新一个具体 bucket 内的 Counter（float64），因此客户端性能开销相比 Counter 和 Gauge 而言没有明显改变，适合高并发的数据收集。</p>
<p>图 1.3.5 为 Go 客户端的 Histogram 默认 bucket 设置，可以用来采集 Web 服务响应时间，实际应用中通常需要为监控对象选择合理的 buckets，buckets 应设置为正态分布中常用的分位点。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171417.png" alt=""  />
</p>
<h1 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h1>
<p>Summary相比Historygram是按百分位聚合好的直方图, 适合需要知道百分比分布范围的场景, 比如对于 http请求的响应时长, Historygram是侧重在于统计小于1ms的请求有多少个, 1ms~10ms的请求有多少个, 10ms以上的请求有多少个, 而Summary在于统计20%的请求的响应时间是多少, 50%的请求的响应时间是多少, 99%的请求的响应时间是多少. Historygram是计数原始数据, 开销小, 执行查询时有对应的函数计算得到p50, p99, 而Summary是在客户端SDK测做了聚合计算得到指定的百分位, 开销更大一些.</p>
<p>Summary 是标准数据结构中最复杂的一个，用来收集服从正态分布的采样数据。在 Go 客户端 Summary 结构和 Histogram 一样，都实现了 Observer 接口（图 1.3.1）。</p>
<p>Summary 中 quantile 实际上是正态分布中的分位点 ，如图 1.4.1 所示，图中的实心圆点分别代表 [0.025 0.25 0.50 0.75 0.975] 分位点，图 2.1.10 中 0.5 分位点的采样数据为 0，而 0.975 分位点的采样值为 2，这说明采样数据的绝大部分的峰值都在 2 附近。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171449.png" alt=""  />
</p>
<p>由于 Summary 结构的客户端实现相比其他几个结构而言复杂一些，先看一下 summary 结构的定义（图 1.4.2）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171510.png" alt=""  />
</p>
<p>Summary 会将采集到的数据经过正态分布逼近得出对应分位点的采样数据，数据流如图 1.4.3 所示。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171620.png" alt=""  />
</p>
<p>接下来看 summary.Observe 实现，图 1.4.4 和 1.4.5 中加入了代码逻辑的注解。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717173109.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717173328.png" alt=""  />
</p>
<p>再看 summary.Write 实现，图 1.4.6 中加入了代码逻辑的注解。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180630.png" alt=""  />
</p>
<h1 id="vec">Vec<a hidden class="anchor" aria-hidden="true" href="#vec">#</a></h1>
<p>带label的指标类型使用prometheus.NewCounterVec prometheus.NewGaugeVec prometheus.NewHistogramVec prometheus.NewSummaryVec, 不同的label值就像空间直角坐标系中的以原点为七点的不同方向的向量一样.</p>
<p>调用Vec类型的WithLabelValues方法传入的value参数数量一定要和注册时定义的label数量一致, 否则会panic.</p>
<p>以下是client go提供的对数组全部操作的接口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//metricVec实现了具体结构和接口，提供给四种数组类型调用,部分接口不提供给用户
</span><span class="c1">//位于github.com/prometheus/client_golang/prometheus/vec.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">metricVec</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">metricMap</span>
    <span class="nx">curry</span> <span class="p">[]</span><span class="nx">curriedLabelValue</span>

    <span class="nx">hashAdd</span>     <span class="kd">func</span><span class="p">(</span><span class="nx">h</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">uint64</span>
    <span class="nx">hashAddByte</span> <span class="kd">func</span><span class="p">(</span><span class="nx">h</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">//删除匹配的labels，删除成功返回true，如果未找到则返回false，并不是error
</span><span class="c1">//两者的不同：
</span><span class="c1">//  Delete用法： vec.Delete(Labels{&#34;l1&#34;: &#34;v1&#34;, &#34;l2&#34;: &#34;v2&#34;})
</span><span class="c1">//  DeleteLabelValues用法： vec.DeleteLabelValues(&#34;v1&#34;, &#34;v2&#34;)
</span><span class="c1">//如果后者参数的顺序有问题，则返回false，而前者不会
</span><span class="c1">//但是与之带来的是前者的开销要比后者大，因为前者要构建Labels映射
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">metricVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">metricVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{}</span>


<span class="kd">type</span> <span class="nx">Observer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//XXX需要使用Counter,Gauge,Histogram,Summary来代替
</span><span class="c1">//以下接口实现于counter.go, gauge.go, histogram.go, summary.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">XXXVec</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">metricVec</span>
<span class="p">}</span>

<span class="c1">//将返回数组实例，如 NewCounterVec，将返回一个 *CounterVec，
</span><span class="c1">//注意，调用时，opts 中， Histogtam的Budket不能有&#34;le&#34;, Summary的quantile不能有&#34;quantile&#34;，否则painc()
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewXXXVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">XXXOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">{}</span>

<span class="c1">//如果CounterVec则 TTT为Counter，GaugeVec则TTT为Gauge，Histogram和Summary则TTT为Observer
</span><span class="c1"></span>
<span class="c1">//获取Counter,Gauge,Histogram或Summary，如果存在则返回，不存在则创建，如果name相同，描述不同，则返回error。
</span><span class="c1">//用法：
</span><span class="c1">//  vec.GetMetricWith(Labels{&#34;l1&#34;: &#34;v1&#34;, &#34;l2&#34;: &#34;v2&#34;})
</span><span class="c1">//  vec.GetMetricWithLabelValues(&#34;v1&#34;, &#34;v2&#34;)
</span><span class="c1">//很容易因为顺序问题而导致错误或获取不到，所以建议使用前者，但与之带来的是前者会有额外消耗
</span><span class="c1">//如果我们只想获取，如果获取不到不创建新的的话，那么是做不到的，不过我们不保存返回的实例就好了。如果考虑到消耗，也可以使用Delete来移除它
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">TTT</span><span class="p">,</span> <span class="kt">error</span><span class="p">){}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)(</span><span class="nx">TTT</span><span class="p">,</span> <span class="kt">error</span><span class="p">){}</span>

<span class="c1">//分别为GetMetricWith和GetMetricWithLabelValues的must形式
</span><span class="c1">//即如果出错则panic(),不会返回error
</span><span class="c1">//不建议使用must形式，因为觉得我们自己处理error的能力还是要有的，即使我们捕捉到error之后和它做相同的事
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">TTT</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">TTT</span><span class="p">{}</span>

<span class="c1">//CurryWith将根据传入的labels，进行匹配，返回xxxVec形式，xxxVec并不是数组类型！
</span><span class="c1">//作用为了返回子xxxVec
</span><span class="c1">//注意，不要对返回值进行for range，因为不是数组，并且里面的值和方法并不是公开的。
</span><span class="c1">//可能的使用情况：
</span><span class="c1">//  TestHistogramVec := NewHistogramVec(HistogramVecOpts{
</span><span class="c1">//      Name : &#34;test_name&#34;,
</span><span class="c1">//      Help : &#34;test_help&#34;,
</span><span class="c1">//      Buckets: prometheus.LinearBuckets(20, 5, 5),
</span><span class="c1">//  },[]string{&#34;color&#34;,&#34;size&#34;,&#34;weight&#34;})
</span><span class="c1">//  TestHistogramVecSon := CurryWith(&#34;color&#34;:&#34;black&#34;)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">TTTVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">){}</span>
<span class="c1">//CurryWith的Must形式，出现异常直接panic()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">TTTVec</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>数组的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

   <span class="kn">import</span> <span class="p">(</span>
       <span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
       <span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
   <span class="p">)</span>

   <span class="kd">var</span> <span class="p">(</span>
	<span class="nx">MyTestHistogramVec</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;human_weight_histogram&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;human weight histogram&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="c1">//第一个桶1起，每个桶间隔10, 共15个桶。 所以1,11,21,31,...,141
</span><span class="c1"></span>	<span class="p">},[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">},)</span>
   <span class="p">)</span>

   <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">MyTestHistogramVec</span><span class="p">)</span>
       <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
		<span class="kd">var</span> <span class="nx">i</span> <span class="kt">float64</span>
           <span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span> <span class="p">{</span>
               <span class="c1">//不要太在意赋的什么值了，随便写的，主要为了了解用法
</span><span class="c1"></span>			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;man&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">90</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;woman&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">70</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;man&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;25&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">95</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;woman&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;25&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">95</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;man&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;yellow&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">90</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}()</span>

       <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;0.0.0.0:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
   <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func">Func<a hidden class="anchor" aria-hidden="true" href="#func">#</a></h1>
<p>默认情况下, Collector都是主动去计数, 但有的指标无法主动计数, 比如监控服务当前打开的DB连接数, 这个指标更适合在拉取指标时去获取值, 这个时候就可以使用prometheus.NewCounterFunc prometheus.NewGaugeFunc, 传入一个返回指标值的函数func() float64, 在拉取指标时就会调用这个函数.</p>
<h1 id="自定义collector">自定义Collector<a hidden class="anchor" aria-hidden="true" href="#自定义collector">#</a></h1>
<p>go client Colletor只会在每次响应pro请求的时候才收集数据，并且需要每次显式传递变量的值，否则就不会再维持该变量，在pro也将看不到这个变量，Collector是一个接口，所有收集metrics数据的对象都需要实现这个接口，Counter和Gauage等不例外，它内部提供了两个函数，Collector用于收集用户数据，将收集好的数据传递给传入参数Channel就可，Descirbe函数用于描述这个Collector。当收集系统数据代价较大时，就可以自定义Collector收集的方式，优化流程，并且在某些情况下如果已经有了一个成熟的metrics，就不需要使用Counter,Gauage等这些数据结构，直接在Collector内部实现一个代理的功能即可，一些高阶的用法都可以通过自定义Collector实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ClusterManager</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Zone</span>         <span class="kt">string</span>
	<span class="nx">OOMCountDesc</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span>
	<span class="nx">RAMUsageDesc</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span>
	<span class="c1">// ... many more fields
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Simulate prepare the data
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span> <span class="p">(</span>
	<span class="nx">oomCountByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Just example fake data.
</span><span class="c1"></span>	<span class="nx">oomCountByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mi">2001</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ramUsageByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mf">6.023e23</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mf">3.14</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Describe simply sends the two Descs in the struct to the channel.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">OOMCountDesc</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">RAMUsageDesc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">oomCountByHost</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">oomCount</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oomCountByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">OOMCountDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterValue</span><span class="p">,</span>
			<span class="nb">float64</span><span class="p">(</span><span class="nx">oomCount</span><span class="p">),</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">ramUsage</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ramUsageByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">RAMUsageDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeValue</span><span class="p">,</span>
			<span class="nx">ramUsage</span><span class="p">,</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NewClusterManager creates the two Descs OOMCountDesc and RAMUsageDesc. Note
</span><span class="c1">// that the zone is set as a ConstLabel. (It&#39;s different in each instance of the
</span><span class="c1">// ClusterManager, but constant over the lifetime of an instance.) Then there is
</span><span class="c1">// a variable label &#34;host&#34;, since we want to partition the collected metrics by
</span><span class="c1">// host. Since all Descs created in this way are consistent across instances,
</span><span class="c1">// with a guaranteed distinction by the &#34;zone&#34; label, we can register different
</span><span class="c1">// ClusterManager instances with the same registry.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="nx">zone</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">ClusterManager</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ClusterManager</span><span class="p">{</span>
		<span class="nx">Zone</span><span class="p">:</span> <span class="nx">zone</span><span class="p">,</span>
		<span class="nx">OOMCountDesc</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
			<span class="s">&#34;clustermanager_oom_crashes_total&#34;</span><span class="p">,</span>
			<span class="s">&#34;Number of OOM crashes.&#34;</span><span class="p">,</span>
			<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;zone&#34;</span><span class="p">:</span> <span class="nx">zone</span><span class="p">},</span>
		<span class="p">),</span>
		<span class="nx">RAMUsageDesc</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
			<span class="s">&#34;clustermanager_ram_usage_bytes&#34;</span><span class="p">,</span>
			<span class="s">&#34;RAM usage as reported to the cluster manager.&#34;</span><span class="p">,</span>
			<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;zone&#34;</span><span class="p">:</span> <span class="nx">zone</span><span class="p">},</span>
		<span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">workerDB</span> <span class="o">:=</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;db&#34;</span><span class="p">)</span>
	<span class="nx">workerCA</span> <span class="o">:=</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;ca&#34;</span><span class="p">)</span>

	<span class="c1">// Since we are dealing with custom Collector implementations, it might
</span><span class="c1"></span>	<span class="c1">// be a good idea to try it out with a pedantic registry.
</span><span class="c1"></span>	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewPedanticRegistry</span><span class="p">()</span>
	<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">workerDB</span><span class="p">)</span>
	<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">workerCA</span><span class="p">)</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">HandlerFor</span><span class="p">(</span><span class="nx">reg</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nx">HandlerOpts</span><span class="p">{}))</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8888&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此时就可以去 http://localhost:8888/metrics 看到传递过去的数据了。示例中定义了两个matrics, host和zone分别是其label。 其实pro client内部提供了几个Collector供我们使用，我们可以参考他的实现，在源码包中可以找到go_collector.go, process_collecor.go, expvar_collector这三个文件的Collecor实现。</p>
<h1 id="集成优化建议">集成优化建议<a hidden class="anchor" aria-hidden="true" href="#集成优化建议">#</a></h1>
<p>在编辑图表写查询语句时,不会显示指标类型, 所以最好看到metric name就能知道是一个什么类型的指标, 约定counter类型的指标名字以_total为后缀.</p>
<p>在编辑图表写查询语句时, 也不会显示指标类型的单位, 所以最好看到metric name就能知道是一个什么单位的指标, 比如时长要写是纳秒还是毫秒还是秒, http_request_duration_seconds, 数据大小要写是MB还是bytes, client_grpc_sent_bytes_total.</p>
<p>每个指标要有单个词的namespace前缀, 比如process_cpu_seconds_total, http_request_duration_seconds.</p>
<p>客户端集成时，需要关注采集监控数据对程序性能和可靠性的影响，同时也需要关注数据完备性，即采集到的数据应完整、正确地反映监控对象的状态和变化，笔者提出以下两点思路：</p>
<ul>
<li>为监控对象定义“恰当”的监控数据集，“恰当”要求在详细设计阶段梳理并细化整个监控对象，不引入多余的监控数据，也不应该出现监控盲点</li>
<li>根据每个监控数据的实际情况选择合理的数据结构</li>
</ul>
<p>Go 客户端为 HTTP 层的集成提供了方便的 API，但使用中需要注意不要使用 github.com/prometheus/client_golang/prometheus 下定义的已经 deprecated 的 Instrument 函数（如图 1.5.1 中注释部分），除了会引入额外（通常不需要）的监控数据，不仅会对程序性能造成不利影响，而且可能存在危险的 race（如计算请求大小时存在 goroutine 并发地访问 Header 逻辑）。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180709.png" alt=""  />
</p>
<p>Go 客户端在后续的版本中给出了优化的 API，即 github.com/prometheus/client_golang/prometheus/promhttp 下的实现，为 HTTP Handler 的不同监控数据定义了独立的 InstrumentHandlerXXX（图 1.5.2），让监控数据集保持灵活可控，完全规避了图 1.5.1 中提到的几个问题。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180723.png" alt=""  />
</p>
<p>另外一个难点是根据实际使用场景，从 Histogram 和 Summary 中作出选择以及给予合理的初始化配置。</p>
<p>Histogram 常使用 histogram_quantile 执行数据分析， histogram_quantile 函数通过分段线性近似模型逼近采样数据分布的 UpperBound（如图 1.5.3），误差是比较大的，其中红色曲线为实际的采样分布（正态分布），而实心圆点是 Histogram 的 bucket(0.01 0.25 0.50 0.75 0.95)，当求解 0.9 quantile 的采样值时会用 (0.75, 0.95) 两个相邻的的 bucket 来线性近似。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180805.png" alt=""  />
</p>
<p>而 Summary 的分位点是客户端预先定义好的，已知分位点可以求该分位点的采样值，相比 Histogram 而言能更准确地获取分位点的采样值。</p>
<p>当然，Summary 精度高的代价是在客户端增加了额外的计算开销，而且 Summary 结构有频繁的全局锁操作，对高并发程序性能存在一定影响，图 1.5.4 是对 Histogram 和 Summary 分析 Benchmark 的结果，Observe 和 Write 操作都有着指数级别的差异，需要结合实际应用场景作出选择。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180838.png" alt=""  />
</p>
<p>带label的每次会去计算label值的hash找到对应的向量, 然后去计数, 所以label数不要太多, label值的长度不要太长, label值是要可枚举的并且不能太多, 否则执行查询时慢, 面板加载慢, 存储也费空间. label如果可以提前计算则尽量使用GetMetricWithLabelValues提前计算好得到一个普通的计数器, 减少每次计数的一次计算label的hash, 提升程序性能.</p>
<p>对于时长time.Duration数据类型的指标值收集, time.Since是优化过的, 直接走runtimeNano, 无需走系统调用取当前时间, 性能优于time.Now后相减, 另外, 频繁调用time.Now在性能要求高的程序中也会变成不小的开销.</p>
<p>参考:<br>
<a href="https://www.infoq.cn/article/Prometheus-theory-source-code">Prometheus 原理和源码分析</a>
<a href="https://skyingzz.github.io/2020/01/19/prometheus-client-go/">浅谈prometheus client golang</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/prometheus/">Prometheus</a></li>
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
