<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Prometheus的GoClient分析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Prometheus的GoClient分析" />
<meta property="og:description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/prometheus%E7%9A%84goclient%E5%88%86%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-17T16:43:42+00:00" />
<meta property="article:modified_time" content="2020-07-17T16:43:42+00:00" />

<meta itemprop="name" content="Prometheus的GoClient分析">
<meta itemprop="description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro"><meta itemprop="datePublished" content="2020-07-17T16:43:42+00:00" />
<meta itemprop="dateModified" content="2020-07-17T16:43:42+00:00" />
<meta itemprop="wordCount" content="6572">
<meta itemprop="keywords" content="Prometheus,Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Prometheus的GoClient分析"/>
<meta name="twitter:description" content="整体结构分析 无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。 Collector pro"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Prometheus的GoClient分析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-07-17 </span>
        <div class="post-category">
            <a href="/categories/prometheus/"> Prometheus </a>
            </div>
          <span class="more-meta"> 约 6572 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#collector">Collector</a></li>
    <li><a href="#四种指标">四种指标</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="整体结构分析">整体结构分析</h1>
<p>无论是 Prom 拉取 (pull) 数据，还是客户端主动推送 (push) 数据，都可以从 Collector 获取 Metric 的定义，UML 图描述了 Go 客户端中主要结构和接口之间的关系。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717164717.png" alt=""></p>
<h2 id="collector">Collector</h2>
<p>prometheus的Golang SDK设计得很地道, 充分利用了GO语言的特性.</p>
<p>在SDK中所有的指标类型都实现了prometheus.Collector 接口.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Collector is the interface implemented by anything that can be used by
</span><span class="c1">// Prometheus to collect metrics. A Collector has to be registered for
</span><span class="c1">// collection. See Registerer.Register.
</span><span class="c1">//
</span><span class="c1">// The stock metrics provided by this package (Gauge, Counter, Summary,
</span><span class="c1">// Histogram, Untyped) are also Collectors (which only ever collect one metric,
</span><span class="c1">// namely itself). An implementer of Collector may, however, collect multiple
</span><span class="c1">// metrics in a coordinated fashion and/or create metrics on the fly. Examples
</span><span class="c1">// for collectors already implemented in this library are the metric vectors
</span><span class="c1">// (i.e. collection of multiple instances of the same Metric but with different
</span><span class="c1">// label values) like GaugeVec or SummaryVec, and the ExpvarCollector.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Collector</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Describe sends the super-set of all possible descriptors of metrics
</span><span class="c1"></span>	<span class="c1">// collected by this Collector to the provided channel and returns once
</span><span class="c1"></span>	<span class="c1">// the last descriptor has been sent. The sent descriptors fulfill the
</span><span class="c1"></span>	<span class="c1">// consistency and uniqueness requirements described in the Desc
</span><span class="c1"></span>	<span class="c1">// documentation. (It is valid if one and the same Collector sends
</span><span class="c1"></span>	<span class="c1">// duplicate descriptors. Those duplicates are simply ignored. However,
</span><span class="c1"></span>	<span class="c1">// two different Collectors must not send duplicate descriptors.) This
</span><span class="c1"></span>	<span class="c1">// method idempotently sends the same descriptors throughout the
</span><span class="c1"></span>	<span class="c1">// lifetime of the Collector. If a Collector encounters an error while
</span><span class="c1"></span>	<span class="c1">// executing this method, it must send an invalid descriptor (created
</span><span class="c1"></span>	<span class="c1">// with NewInvalidDesc) to signal the error to the registry.
</span><span class="c1"></span>	<span class="nf">Describe</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Desc</span><span class="p">)</span>
	<span class="c1">// Collect is called by the Prometheus registry when collecting
</span><span class="c1"></span>	<span class="c1">// metrics. The implementation sends each collected metric via the
</span><span class="c1"></span>	<span class="c1">// provided channel and returns once the last metric has been sent. The
</span><span class="c1"></span>	<span class="c1">// descriptor of each sent metric is one of those returned by
</span><span class="c1"></span>	<span class="c1">// Describe. Returned metrics that share the same descriptor must differ
</span><span class="c1"></span>	<span class="c1">// in their variable label values. This method may be called
</span><span class="c1"></span>	<span class="c1">// concurrently and must therefore be implemented in a concurrency safe
</span><span class="c1"></span>	<span class="c1">// way. Blocking occurs at the expense of total performance of rendering
</span><span class="c1"></span>	<span class="c1">// all registered metrics. Ideally, Collector implementations support
</span><span class="c1"></span>	<span class="c1">// concurrent readers.
</span><span class="c1"></span>	<span class="nf">Collect</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">Metric</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>prometheus.Collector 接口中的方法传参都是只写的chan, 使得实现接口的代码无论是同步还是并行都可以. Describe(chan&lt;- *Desc)方法是在将Collector注册或注销时调用的, Collect(chan&lt;- Metric)方法是在被抓取收集指标时调用的.</p>
<p>Collector 中 Describe 和 Collect 方法都是无状态的函数，其中 Describe 暴露全部可能的 Metric 描述列表，在注册（Register）或注销（Unregister）Collector 时会调用 Describe 来获取完整的 Metric 列表，用以检测 Metric 定义的冲突.</p>
<p>另外在 github.com/prometheus/client_golang/prometheus/promhttp 下的 Instrument Handler 中，也会通过 Describe 获取 Metric 列表，并检查 label 列表（InstrumentHandler 中只支持 code 和 method 两种自定义 label）；而通过 Collect 可以获取采样数据，然后通过 HTTP 接口暴露给 Prom Server。另外，一些临时性的进程，如批处理任务，可以把数据 push 到 Push Gateway，由 Push Gateway 暴露 pull 接口，此处不赘述。</p>
<h2 id="四种指标">四种指标</h2>
<p>客户端对数据的收集大多是针对标准数据结构来进行的：</p>
<ul>
<li>Counter：收集事件次数等单调递增的数据</li>
<li>Gauge：收集当前的状态，比如数据库连接数</li>
<li>Histogram：收集随机正态分布数据，比如响应延迟</li>
<li>Summary：收集随机正态分布数据，和 Histogram 是类似的</li>
</ul>
<p>每种标准数据结构还对应了 Vec 结构，通过 Vec 可以简洁的定义一组相同性质的 Metric，在采集数据的时候传入一组自定义的 Label/Value 获取具体的 Metric（Counter/Gauge/Histogram/Summary），最终都会落实到基本的数据结构上，这里不再赘述。</p>
<h1 id="counter-和-gauge">Counter 和 Gauge</h1>
<p>Counter是计数器, 单调递增的, 只有服务重启时才会清零, 比如http请求数, errorLevel的log数. 值得一提的是, prometheus的内置函数求值时会自动处理重启清零的情况.</p>
<p>Guage是一个可增可减的数值指标, 比如CPU使用率, 内存使用率, 协程数.</p>
<p>Gauge 和 Counter 基本实现上看是一个进程内共享的浮点数，基于 value 结构实现，而 Counter 和 Gauge 仅仅封装了对这个共享浮点数的各种操作和合法性检查逻辑。</p>
<p>先看 Counter 中 Inc 函数的实现，图为 value 结构中 Inc 函数的实现。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717165337.png" alt=""></p>
<p>counter的value是float64, 怎么无锁地操作float64呢? 答案是用math包将其视作uint64来操作.</p>
<p>value.Add 中修改共享数据时采用了“无锁”实现，相比“有锁 (Mutex)”实现可以更充分利用多核处理器的并行计算能力，性能相比加 Mutex 的实现会有很大提升。图中是 Go Benchmark 的测试结果，对比了“有锁”（用 defer 或不用 defer 来释放锁）和“无锁”实现在多核场景下对性能的影响。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717170718.png" alt=""></p>
<p>注意图中针对“有锁”的实现，进行了两组实验，其中一组用 defer 来释放锁，可见在多核场景下“无锁”实现的性能最好也最稳定。</p>
<p>counter的Add方法不能传负数, 否则会panic.</p>
<p>Counter 和 Gauge 中的其他操作都很简单，不赘述。</p>
<h1 id="histogram">Histogram</h1>
<p>Historygram是直方图, 适合需要知道数值分布范围的场景, 比如http请求的响应时长, http请求的响应包体大小等.</p>
<p>直方图的组距不一定是固定的, 可以自己定义适合, 这里称其为bucket, 每一个metric value根据其数值大小落在对应的bucket.</p>
<p>Histogram 实现了 Observer 接口，用来获取客户端状态初始化（重启）到某个时间点的采样点分布，监控数据常需要服从正态分布。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717170929.png" alt=""></p>
<p>先看通过 Histogram 采集一个 float64 数据的 Observe 方法实现（图 1.3.2）。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717170955.png" alt=""></p>
<p>此处每个 bucket 对应的 count 是不互相包含的，bucket 的计数器之和应该等于全局计数器，即 h.count == sum(h.counts) 是成立的。然而为了便于服务端存储和计算，最终服务端收集到的数据是向下包含的，这是在 histogram.Write（图 1.3.3）中实现的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171312.png" alt=""></p>
<p>图 1.3.4 中用表格形式给出了 Histogram 采集和整理数据的过程。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171331.png" alt=""></p>
<p>Histogram 在客户端也是无锁的，因为每个采样点只更新一个具体 bucket 内的 Counter（float64），因此客户端性能开销相比 Counter 和 Gauge 而言没有明显改变，适合高并发的数据收集。</p>
<p>图 1.3.5 为 Go 客户端的 Histogram 默认 bucket 设置，可以用来采集 Web 服务响应时间，实际应用中通常需要为监控对象选择合理的 buckets，buckets 应设置为正态分布中常用的分位点。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171417.png" alt=""></p>
<h1 id="summary">Summary</h1>
<p>Summary相比Historygram是按百分位聚合好的直方图, 适合需要知道百分比分布范围的场景, 比如对于 http请求的响应时长, Historygram是侧重在于统计小于1ms的请求有多少个, 1ms~10ms的请求有多少个, 10ms以上的请求有多少个, 而Summary在于统计20%的请求的响应时间是多少, 50%的请求的响应时间是多少, 99%的请求的响应时间是多少. Historygram是计数原始数据, 开销小, 执行查询时有对应的函数计算得到p50, p99, 而Summary是在客户端SDK测做了聚合计算得到指定的百分位, 开销更大一些.</p>
<p>Summary 是标准数据结构中最复杂的一个，用来收集服从正态分布的采样数据。在 Go 客户端 Summary 结构和 Histogram 一样，都实现了 Observer 接口（图 1.3.1）。</p>
<p>Summary 中 quantile 实际上是正态分布中的分位点 ，如图 1.4.1 所示，图中的实心圆点分别代表 [0.025 0.25 0.50 0.75 0.975] 分位点，图 2.1.10 中 0.5 分位点的采样数据为 0，而 0.975 分位点的采样值为 2，这说明采样数据的绝大部分的峰值都在 2 附近。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171449.png" alt=""></p>
<p>由于 Summary 结构的客户端实现相比其他几个结构而言复杂一些，先看一下 summary 结构的定义（图 1.4.2）。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171510.png" alt=""></p>
<p>Summary 会将采集到的数据经过正态分布逼近得出对应分位点的采样数据，数据流如图 1.4.3 所示。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717171620.png" alt=""></p>
<p>接下来看 summary.Observe 实现，图 1.4.4 和 1.4.5 中加入了代码逻辑的注解。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717173109.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717173328.png" alt=""></p>
<p>再看 summary.Write 实现，图 1.4.6 中加入了代码逻辑的注解。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180630.png" alt=""></p>
<h1 id="vec">Vec</h1>
<p>带label的指标类型使用prometheus.NewCounterVec prometheus.NewGaugeVec prometheus.NewHistogramVec prometheus.NewSummaryVec, 不同的label值就像空间直角坐标系中的以原点为七点的不同方向的向量一样.</p>
<p>调用Vec类型的WithLabelValues方法传入的value参数数量一定要和注册时定义的label数量一致, 否则会panic.</p>
<p>以下是client go提供的对数组全部操作的接口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//metricVec实现了具体结构和接口，提供给四种数组类型调用,部分接口不提供给用户
</span><span class="c1">//位于github.com/prometheus/client_golang/prometheus/vec.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">metricVec</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">metricMap</span>
    <span class="nx">curry</span> <span class="p">[]</span><span class="nx">curriedLabelValue</span>

    <span class="nx">hashAdd</span>     <span class="kd">func</span><span class="p">(</span><span class="nx">h</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">uint64</span>
    <span class="nx">hashAddByte</span> <span class="kd">func</span><span class="p">(</span><span class="nx">h</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">//删除匹配的labels，删除成功返回true，如果未找到则返回false，并不是error
</span><span class="c1">//两者的不同：
</span><span class="c1">//  Delete用法： vec.Delete(Labels{&#34;l1&#34;: &#34;v1&#34;, &#34;l2&#34;: &#34;v2&#34;})
</span><span class="c1">//  DeleteLabelValues用法： vec.DeleteLabelValues(&#34;v1&#34;, &#34;v2&#34;)
</span><span class="c1">//如果后者参数的顺序有问题，则返回false，而前者不会
</span><span class="c1">//但是与之带来的是前者的开销要比后者大，因为前者要构建Labels映射
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">metricVec</span><span class="p">)</span> <span class="nf">DeleteLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">metricVec</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{}</span>


<span class="kd">type</span> <span class="nx">Observer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Observe</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//XXX需要使用Counter,Gauge,Histogram,Summary来代替
</span><span class="c1">//以下接口实现于counter.go, gauge.go, histogram.go, summary.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">XXXVec</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">metricVec</span>
<span class="p">}</span>

<span class="c1">//将返回数组实例，如 NewCounterVec，将返回一个 *CounterVec，
</span><span class="c1">//注意，调用时，opts 中， Histogtam的Budket不能有&#34;le&#34;, Summary的quantile不能有&#34;quantile&#34;，否则painc()
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewXXXVec</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">XXXOpts</span><span class="p">,</span> <span class="nx">labelNames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">{}</span>

<span class="c1">//如果CounterVec则 TTT为Counter，GaugeVec则TTT为Gauge，Histogram和Summary则TTT为Observer
</span><span class="c1"></span>
<span class="c1">//获取Counter,Gauge,Histogram或Summary，如果存在则返回，不存在则创建，如果name相同，描述不同，则返回error。
</span><span class="c1">//用法：
</span><span class="c1">//  vec.GetMetricWith(Labels{&#34;l1&#34;: &#34;v1&#34;, &#34;l2&#34;: &#34;v2&#34;})
</span><span class="c1">//  vec.GetMetricWithLabelValues(&#34;v1&#34;, &#34;v2&#34;)
</span><span class="c1">//很容易因为顺序问题而导致错误或获取不到，所以建议使用前者，但与之带来的是前者会有额外消耗
</span><span class="c1">//如果我们只想获取，如果获取不到不创建新的的话，那么是做不到的，不过我们不保存返回的实例就好了。如果考虑到消耗，也可以使用Delete来移除它
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">GetMetricWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">TTT</span><span class="p">,</span> <span class="kt">error</span><span class="p">){}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">GetMetricWithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)(</span><span class="nx">TTT</span><span class="p">,</span> <span class="kt">error</span><span class="p">){}</span>

<span class="c1">//分别为GetMetricWith和GetMetricWithLabelValues的must形式
</span><span class="c1">//即如果出错则panic(),不会返回error
</span><span class="c1">//不建议使用must形式，因为觉得我们自己处理error的能力还是要有的，即使我们捕捉到error之后和它做相同的事
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">lvs</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">TTT</span><span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">With</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">TTT</span><span class="p">{}</span>

<span class="c1">//CurryWith将根据传入的labels，进行匹配，返回xxxVec形式，xxxVec并不是数组类型！
</span><span class="c1">//作用为了返回子xxxVec
</span><span class="c1">//注意，不要对返回值进行for range，因为不是数组，并且里面的值和方法并不是公开的。
</span><span class="c1">//可能的使用情况：
</span><span class="c1">//  TestHistogramVec := NewHistogramVec(HistogramVecOpts{
</span><span class="c1">//      Name : &#34;test_name&#34;,
</span><span class="c1">//      Help : &#34;test_help&#34;,
</span><span class="c1">//      Buckets: prometheus.LinearBuckets(20, 5, 5),
</span><span class="c1">//  },[]string{&#34;color&#34;,&#34;size&#34;,&#34;weight&#34;})
</span><span class="c1">//  TestHistogramVecSon := CurryWith(&#34;color&#34;:&#34;black&#34;)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">CurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="p">(</span><span class="nx">TTTVec</span><span class="p">,</span> <span class="kt">error</span><span class="p">){}</span>
<span class="c1">//CurryWith的Must形式，出现异常直接panic()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">XXXVec</span><span class="p">)</span> <span class="nf">MustCurryWith</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">Labels</span><span class="p">)</span> <span class="nx">TTTVec</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>数组的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

   <span class="kn">import</span> <span class="p">(</span>
       <span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
       <span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
   <span class="p">)</span>

   <span class="kd">var</span> <span class="p">(</span>
	<span class="nx">MyTestHistogramVec</span> <span class="p">=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewHistogramVec</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">HistogramOpts</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;human_weight_histogram&#34;</span><span class="p">,</span>
		<span class="nx">Help</span><span class="p">:</span> <span class="s">&#34;human weight histogram&#34;</span><span class="p">,</span>
		<span class="nx">Buckets</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">LinearBuckets</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="c1">//第一个桶1起，每个桶间隔10, 共15个桶。 所以1,11,21,31,...,141
</span><span class="c1"></span>	<span class="p">},[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">},)</span>
   <span class="p">)</span>

   <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">MyTestHistogramVec</span><span class="p">)</span>
       <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
		<span class="kd">var</span> <span class="nx">i</span> <span class="kt">float64</span>
           <span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span> <span class="p">{</span>
               <span class="c1">//不要太在意赋的什么值了，随便写的，主要为了了解用法
</span><span class="c1"></span>			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;man&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">90</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;woman&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">70</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;man&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;25&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">95</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;woman&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;25&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;black&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">95</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">MyTestHistogramVec</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;sex&#34;</span><span class="p">:</span><span class="s">&#34;man&#34;</span><span class="p">,</span><span class="s">&#34;age&#34;</span><span class="p">:</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="s">&#34;race&#34;</span><span class="p">:</span><span class="s">&#34;yellow&#34;</span><span class="p">}).</span><span class="nf">Observe</span><span class="p">(</span><span class="mi">90</span> <span class="o">+</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">))</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}()</span>

       <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">Handler</span><span class="p">())</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;0.0.0.0:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
   <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func">Func</h1>
<p>默认情况下, Collector都是主动去计数, 但有的指标无法主动计数, 比如监控服务当前打开的DB连接数, 这个指标更适合在拉取指标时去获取值, 这个时候就可以使用prometheus.NewCounterFunc prometheus.NewGaugeFunc, 传入一个返回指标值的函数func() float64, 在拉取指标时就会调用这个函数.</p>
<h1 id="自定义collector">自定义Collector</h1>
<p>go client Colletor只会在每次响应pro请求的时候才收集数据，并且需要每次显式传递变量的值，否则就不会再维持该变量，在pro也将看不到这个变量，Collector是一个接口，所有收集metrics数据的对象都需要实现这个接口，Counter和Gauage等不例外，它内部提供了两个函数，Collector用于收集用户数据，将收集好的数据传递给传入参数Channel就可，Descirbe函数用于描述这个Collector。当收集系统数据代价较大时，就可以自定义Collector收集的方式，优化流程，并且在某些情况下如果已经有了一个成熟的metrics，就不需要使用Counter,Gauage等这些数据结构，直接在Collector内部实现一个代理的功能即可，一些高阶的用法都可以通过自定义Collector实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
	<span class="s">&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ClusterManager</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Zone</span>         <span class="kt">string</span>
	<span class="nx">OOMCountDesc</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span>
	<span class="nx">RAMUsageDesc</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span>
	<span class="c1">// ... many more fields
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Simulate prepare the data
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span> <span class="p">(</span>
	<span class="nx">oomCountByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Just example fake data.
</span><span class="c1"></span>	<span class="nx">oomCountByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mi">2001</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ramUsageByHost</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span>
		<span class="s">&#34;foo.example.org&#34;</span><span class="p">:</span> <span class="mf">6.023e23</span><span class="p">,</span>
		<span class="s">&#34;bar.example.org&#34;</span><span class="p">:</span> <span class="mf">3.14</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Describe simply sends the two Descs in the struct to the channel.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">Describe</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">prometheus</span><span class="p">.</span><span class="nx">Desc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">OOMCountDesc</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">RAMUsageDesc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ClusterManager</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nx">Metric</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">oomCountByHost</span><span class="p">,</span> <span class="nx">ramUsageByHost</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ReallyExpensiveAssessmentOfTheSystemState</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">oomCount</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oomCountByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">OOMCountDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">CounterValue</span><span class="p">,</span>
			<span class="nb">float64</span><span class="p">(</span><span class="nx">oomCount</span><span class="p">),</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">ramUsage</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ramUsageByHost</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">MustNewConstMetric</span><span class="p">(</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">RAMUsageDesc</span><span class="p">,</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">GaugeValue</span><span class="p">,</span>
			<span class="nx">ramUsage</span><span class="p">,</span>
			<span class="nx">host</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NewClusterManager creates the two Descs OOMCountDesc and RAMUsageDesc. Note
</span><span class="c1">// that the zone is set as a ConstLabel. (It&#39;s different in each instance of the
</span><span class="c1">// ClusterManager, but constant over the lifetime of an instance.) Then there is
</span><span class="c1">// a variable label &#34;host&#34;, since we want to partition the collected metrics by
</span><span class="c1">// host. Since all Descs created in this way are consistent across instances,
</span><span class="c1">// with a guaranteed distinction by the &#34;zone&#34; label, we can register different
</span><span class="c1">// ClusterManager instances with the same registry.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="nx">zone</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">ClusterManager</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ClusterManager</span><span class="p">{</span>
		<span class="nx">Zone</span><span class="p">:</span> <span class="nx">zone</span><span class="p">,</span>
		<span class="nx">OOMCountDesc</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
			<span class="s">&#34;clustermanager_oom_crashes_total&#34;</span><span class="p">,</span>
			<span class="s">&#34;Number of OOM crashes.&#34;</span><span class="p">,</span>
			<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;zone&#34;</span><span class="p">:</span> <span class="nx">zone</span><span class="p">},</span>
		<span class="p">),</span>
		<span class="nx">RAMUsageDesc</span><span class="p">:</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewDesc</span><span class="p">(</span>
			<span class="s">&#34;clustermanager_ram_usage_bytes&#34;</span><span class="p">,</span>
			<span class="s">&#34;RAM usage as reported to the cluster manager.&#34;</span><span class="p">,</span>
			<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;host&#34;</span><span class="p">},</span>
			<span class="nx">prometheus</span><span class="p">.</span><span class="nx">Labels</span><span class="p">{</span><span class="s">&#34;zone&#34;</span><span class="p">:</span> <span class="nx">zone</span><span class="p">},</span>
		<span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">workerDB</span> <span class="o">:=</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;db&#34;</span><span class="p">)</span>
	<span class="nx">workerCA</span> <span class="o">:=</span> <span class="nf">NewClusterManager</span><span class="p">(</span><span class="s">&#34;ca&#34;</span><span class="p">)</span>

	<span class="c1">// Since we are dealing with custom Collector implementations, it might
</span><span class="c1"></span>	<span class="c1">// be a good idea to try it out with a pedantic registry.
</span><span class="c1"></span>	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">prometheus</span><span class="p">.</span><span class="nf">NewPedanticRegistry</span><span class="p">()</span>
	<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">workerDB</span><span class="p">)</span>
	<span class="nx">reg</span><span class="p">.</span><span class="nf">MustRegister</span><span class="p">(</span><span class="nx">workerCA</span><span class="p">)</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/metrics&#34;</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nf">HandlerFor</span><span class="p">(</span><span class="nx">reg</span><span class="p">,</span> <span class="nx">promhttp</span><span class="p">.</span><span class="nx">HandlerOpts</span><span class="p">{}))</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8888&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>此时就可以去 http://localhost:8888/metrics 看到传递过去的数据了。示例中定义了两个matrics, host和zone分别是其label。 其实pro client内部提供了几个Collector供我们使用，我们可以参考他的实现，在源码包中可以找到go_collector.go, process_collecor.go, expvar_collector这三个文件的Collecor实现。</p>
<h1 id="集成优化建议">集成优化建议</h1>
<p>在编辑图表写查询语句时,不会显示指标类型, 所以最好看到metric name就能知道是一个什么类型的指标, 约定counter类型的指标名字以_total为后缀.</p>
<p>在编辑图表写查询语句时, 也不会显示指标类型的单位, 所以最好看到metric name就能知道是一个什么单位的指标, 比如时长要写是纳秒还是毫秒还是秒, http_request_duration_seconds, 数据大小要写是MB还是bytes, client_grpc_sent_bytes_total.</p>
<p>每个指标要有单个词的namespace前缀, 比如process_cpu_seconds_total, http_request_duration_seconds.</p>
<p>客户端集成时，需要关注采集监控数据对程序性能和可靠性的影响，同时也需要关注数据完备性，即采集到的数据应完整、正确地反映监控对象的状态和变化，笔者提出以下两点思路：</p>
<ul>
<li>为监控对象定义“恰当”的监控数据集，“恰当”要求在详细设计阶段梳理并细化整个监控对象，不引入多余的监控数据，也不应该出现监控盲点</li>
<li>根据每个监控数据的实际情况选择合理的数据结构</li>
</ul>
<p>Go 客户端为 HTTP 层的集成提供了方便的 API，但使用中需要注意不要使用 github.com/prometheus/client_golang/prometheus 下定义的已经 deprecated 的 Instrument 函数（如图 1.5.1 中注释部分），除了会引入额外（通常不需要）的监控数据，不仅会对程序性能造成不利影响，而且可能存在危险的 race（如计算请求大小时存在 goroutine 并发地访问 Header 逻辑）。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180709.png" alt=""></p>
<p>Go 客户端在后续的版本中给出了优化的 API，即 github.com/prometheus/client_golang/prometheus/promhttp 下的实现，为 HTTP Handler 的不同监控数据定义了独立的 InstrumentHandlerXXX（图 1.5.2），让监控数据集保持灵活可控，完全规避了图 1.5.1 中提到的几个问题。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180723.png" alt=""></p>
<p>另外一个难点是根据实际使用场景，从 Histogram 和 Summary 中作出选择以及给予合理的初始化配置。</p>
<p>Histogram 常使用 histogram_quantile 执行数据分析， histogram_quantile 函数通过分段线性近似模型逼近采样数据分布的 UpperBound（如图 1.5.3），误差是比较大的，其中红色曲线为实际的采样分布（正态分布），而实心圆点是 Histogram 的 bucket(0.01 0.25 0.50 0.75 0.95)，当求解 0.9 quantile 的采样值时会用 (0.75, 0.95) 两个相邻的的 bucket 来线性近似。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180805.png" alt=""></p>
<p>而 Summary 的分位点是客户端预先定义好的，已知分位点可以求该分位点的采样值，相比 Histogram 而言能更准确地获取分位点的采样值。</p>
<p>当然，Summary 精度高的代价是在客户端增加了额外的计算开销，而且 Summary 结构有频繁的全局锁操作，对高并发程序性能存在一定影响，图 1.5.4 是对 Histogram 和 Summary 分析 Benchmark 的结果，Observe 和 Write 操作都有着指数级别的差异，需要结合实际应用场景作出选择。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200717180838.png" alt=""></p>
<p>带label的每次会去计算label值的hash找到对应的向量, 然后去计数, 所以label数不要太多, label值的长度不要太长, label值是要可枚举的并且不能太多, 否则执行查询时慢, 面板加载慢, 存储也费空间. label如果可以提前计算则尽量使用GetMetricWithLabelValues提前计算好得到一个普通的计数器, 减少每次计数的一次计算label的hash, 提升程序性能.</p>
<p>对于时长time.Duration数据类型的指标值收集, time.Since是优化过的, 直接走runtimeNano, 无需走系统调用取当前时间, 性能优于time.Now后相减, 另外, 频繁调用time.Now在性能要求高的程序中也会变成不小的开销.</p>
<p>参考:<br>
<a href="https://www.infoq.cn/article/Prometheus-theory-source-code">Prometheus 原理和源码分析</a>
<a href="https://skyingzz.github.io/2020/01/19/prometheus-client-go/">浅谈prometheus client golang</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-07-17
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/prometheus/">Prometheus</a>
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/prometheus%E7%9A%84promql%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Prometheus的PromQL实现分析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%9C%A8httpapi%E4%B8%AD%E4%BD%BF%E7%94%A8promql/">
            <span class="next-text nav-default">在HTTPAPI中使用PromQL</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
