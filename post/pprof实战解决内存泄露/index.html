<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Pprof实战:解决内存泄露 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.2 with theme even" />


<link rel="canonical" href="/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Pprof实战:解决内存泄露" />
<meta property="og:description" content="前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/pprof%E5%AE%9E%E6%88%98%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-02-09T18:49:21+00:00" />
<meta property="article:modified_time" content="2020-02-09T18:49:21+00:00" />

<meta itemprop="name" content="Pprof实战:解决内存泄露">
<meta itemprop="description" content="前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄"><meta itemprop="datePublished" content="2020-02-09T18:49:21+00:00" />
<meta itemprop="dateModified" content="2020-02-09T18:49:21+00:00" />
<meta itemprop="wordCount" content="7368">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pprof实战:解决内存泄露"/>
<meta name="twitter:description" content="前言 关于Go的内存泄露有这么一句话不知道你听过没有： 10次内存泄露，有9次是goroutine泄露。 我所解决的问题，也是goroutine泄"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Pprof实战:解决内存泄露</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-09 </span>
        <div class="post-category">
            <a href="/categories/go%E8%B0%83%E4%BC%98/"> Go调优 </a>
            </div>
          <span class="more-meta"> 约 7368 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#监控工具查看进程内在占用情况">监控工具查看进程内在占用情况</a></li>
    <li><a href="#go-pprof发现存在内存问题">go pprof发现存在内存问题</a></li>
  </ul>

  <ul>
    <li><a href="#web可视化查看">Web可视化查看</a></li>
    <li><a href="#方式二">方式二</a></li>
  </ul>

  <ul>
    <li><a href="#goroutine泄露的本质">goroutine泄露的本质</a></li>
    <li><a href="#goroutine泄露的发现和定位">goroutine泄露的发现和定位</a></li>
    <li><a href="#goroutine泄露的场景">goroutine泄露的场景</a></li>
    <li><a href="#编码goroutine泄露的建议">编码goroutine泄露的建议</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="前言">前言</h1>
<p>关于Go的内存泄露有这么一句话不知道你听过没有：</p>
<p>10次内存泄露，有9次是goroutine泄露。</p>
<p>我所解决的问题，也是goroutine泄露导致的内存泄露，所以这篇文章主要介绍Go程序的goroutine泄露，掌握了如何定位和解决goroutine泄露，就掌握了内存泄露的大部分场景。</p>
<h1 id="什么是内存泄露">什么是内存泄露</h1>
<p>内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。</p>
<p>Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。</p>
<h1 id="怎么发现内存泄露">怎么发现内存泄露</h1>
<p>在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：</p>
<ul>
<li>监控工具：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。</li>
<li>go pprof：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。</li>
</ul>
<p>这2种方式分别介绍一下。</p>
<h2 id="监控工具查看进程内在占用情况">监控工具查看进程内在占用情况</h2>
<p>如果使用云平台部署Go程序，云平台都提供了内存查看的工具，可以查看OS的内存占用情况和某个进程的内存占用情况，比如阿里云，我们在1个云主机上只部署了1个Go服务，所以OS的内存占用情况，基本是也反映了进程内存占用情况，OS内存占用情况如下，可以看到随着时间的推进，内存的占用率在不断的提高，这是内存泄露的最明显现象：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200210152806.png" alt=""></p>
<p>如果没有云平台这种内存监控工具，可以制作一个简单的内存记录工具。</p>
<p>1、建立一个脚本prog_mem.sh，获取进程占用的物理内存情况，脚本内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nv">prog_name</span><span class="o">=</span><span class="s2">&#34;your_programe_name&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">prog_mem</span><span class="o">=</span><span class="k">$(</span>pidstat  -r -u -h -C <span class="nv">$prog_name</span> <span class="p">|</span>awk <span class="s1">&#39;NR==4{print $12}&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">time</span><span class="o">=</span><span class="k">$(</span>date <span class="s2">&#34;+%Y-%m-%d %H:%M:%S&#34;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="nv">$time</span><span class="s2">&#34;\tmemory(Byte)\t&#34;</span><span class="nv">$prog_mem</span> &gt;&gt;~/record/prog_mem.log
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、然后使用crontab建立定时任务，每分钟记录1次。使用crontab -e编辑crontab配置，在最后增加1行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">*/1 * * * * ~/record/prog_mem.sh
</span></span></code></pre></td></tr></table>
</div>
</div><p>脚本输出的内容保存在prog_mem.log，只要大体浏览一下就可以发现内存的增长情况，判断是否存在内存泄露。如果需要可视化，可以直接黏贴prog_mem.log内容到Excel等表格工具，绘制内存占用图。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200210152859.png" alt=""></p>
<h2 id="go-pprof发现存在内存问题">go pprof发现存在内存问题</h2>
<p>如果你Google或者百度，Go程序内存泄露的文章，它总会告诉你使用pprof heap，能够生成漂亮的调用路径图，火焰图等等，然后你根据调用路径就能定位内存泄露问题，我最初也是对此深信不疑，尝试了若干天后，只是发现内存泄露跟某种场景有关，根本找不到内存泄露的根源，如果哪位朋友用heap就能定位内存泄露的线上问题，麻烦介绍下。</p>
<p>后来读了Dave的《High Performance Go Workshop》，刷新了对heap的认识，内存pprof的简要内容如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200210153147.png" alt=""></p>
<p>Dave讲了以下几点：</p>
<ul>
<li>内存profiling记录的是堆内存分配的情况，以及调用栈信息，并不是进程完整的内存情况，猜测这也是在go pprof中称为heap而不是memory的原因。</li>
<li>栈内存的分配是在调用栈结束后会被释放的内存，所以并不在内存profile中。</li>
<li>内存profiling是基于抽样的，默认是每1000次堆内存分配，执行1次profile记录。</li>
<li>因为内存profiling是基于抽样和它跟踪的是已分配的内存，而不是使用中的内存，（比如有些内存已经分配，看似使用，但实际已经不使用的内存，比如内存泄露的那部分），所以不能使用内存profiling衡量程序总体的内存使用情况。</li>
<li>Dave个人观点：使用内存profiling不能够发现内存泄露。</li>
</ul>
<p>基于目前对heap的认知，我有2个观点：</p>
<ul>
<li>heap能帮助我们发现内存问题，但不一定能发现内存泄露问题，这个看法与Dave是类似的。heap记录了内存分配的情况，我们能通过heap观察内存的变化，增长与减少，内存主要被哪些代码占用了，程序存在内存问题，这只能说明内存有使用不合理的地方，但并不能说明这是内存泄露。</li>
<li>heap在帮助定位内存泄露原因上贡献的力量微乎其微。如第一条所言，能通过heap找到占用内存多的位置，但这个位置通常不一定是内存泄露，就算是内存泄露，也只是内存泄露的结果，并不是真正导致内存泄露的根源。</li>
</ul>
<p>接下来，我介绍怎么用heap发现问题，然后再解释为什么heap几乎不能定位内存泄露的根因。</p>
<h1 id="怎么用heap发现内存问题">怎么用heap发现内存问题</h1>
<p>使用pprof的heap能够获取程序运行时的内存信息，在程序平稳运行的情况下，每个一段时间使用heap获取内存的profile，然后使用base能够对比两个profile文件的差别，就像diff命令一样显示出增加和减少的变化，使用一个简单的demo来说明heap和base的使用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 展示内存增长和pprof，并不是泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 运行一段时间：fatal error: runtime: out of memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开启pprof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ip</span> <span class="o">:=</span> <span class="s">&#34;0.0.0.0:6060&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">ip</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;start pprof failed on %s\n&#34;</span><span class="p">,</span> <span class="nx">ip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="k">range</span> <span class="nx">tick</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">buf</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将上面代码运行起来，执行以下命令获取profile文件，Ctrl-D退出，1分钟后再获取1次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go tool pprof http://localhost:6060/debug/pprof/heap
</span></span></code></pre></td></tr></table>
</div>
</div><p>我已经获取到了两个profile文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ ls
</span></span><span class="line"><span class="cl">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz
</span></span><span class="line"><span class="cl">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用base把001文件作为基准，然后用002和001对比，先执行top看top的对比，然后执行list main列出main函数的内存对比，结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ go tool pprof -base pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">File: demo2
</span></span><span class="line"><span class="cl">Type: inuse_space
</span></span><span class="line"><span class="cl">Time: May 14, 2019 at 2:33pm (CST)
</span></span><span class="line"><span class="cl">Entering interactive mode (type &#34;help&#34; for commands, &#34;o&#34; for options)
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof) top
</span></span><span class="line"><span class="cl">Showing nodes accounting for 970.34MB, 32.30% of 3003.99MB total
</span></span><span class="line"><span class="cl">      flat  flat%   sum%        cum   cum%
</span></span><span class="line"><span class="cl">  970.34MB 32.30% 32.30%   970.34MB 32.30%  main.main   // 看这
</span></span><span class="line"><span class="cl">         0     0% 32.30%   970.34MB 32.30%  runtime.main
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof) list main.main
</span></span><span class="line"><span class="cl">Total: 2.93GB
</span></span><span class="line"><span class="cl">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go
</span></span><span class="line"><span class="cl">  970.34MB   970.34MB (flat, cum) 32.30% of Total
</span></span><span class="line"><span class="cl">         .          .     20:	}()
</span></span><span class="line"><span class="cl">         .          .     21:
</span></span><span class="line"><span class="cl">         .          .     22:	tick := time.Tick(time.Second / 100)
</span></span><span class="line"><span class="cl">         .          .     23:	var buf []byte
</span></span><span class="line"><span class="cl">         .          .     24:	for range tick {
</span></span><span class="line"><span class="cl">  970.34MB   970.34MB     25:		buf = append(buf, make([]byte, 1024*1024)...) // 看这
</span></span><span class="line"><span class="cl">         .          .     26:	}
</span></span><span class="line"><span class="cl">         .          .     27:}
</span></span><span class="line"><span class="cl">         .          .     28:
</span></span></code></pre></td></tr></table>
</div>
</div><p>top列出了main.main和runtime.main，main.main就是我们编写的main函数，runtime.main是runtime包中的main函数，也就是所有main函数的入口.</p>
<p>top显示main.main 第2次内存占用，比第1次内存占用多了970.34MB。</p>
<p>list main.main告诉了我们增长的内存都在这一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">buf</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>001和002 profile的文件不进去看了，你本地测试下计算差值，绝对是刚才对比出的970.34MB。</p>
<h1 id="heap不能定位内存泄露">heap“不能”定位内存泄露</h1>
<p>heap能显示内存的分配情况，以及哪行代码占用了多少内存，我们能轻易的找到占用内存最多的地方，如果这个地方的数值还在不断怎大，基本可以认定这里就是内存泄露的位置。</p>
<p>曾想按图索骥，从内存泄露的位置，根据调用栈向上查找，总能找到内存泄露的原因，这种方案看起来是不错的，但实施起来却找不到内存泄露的原因，结果是事半功倍。</p>
<p>原因在于一个Go程序，其中有大量的goroutine，这其中的调用关系也许有点复杂，也许内存泄露是在某个三方包里。举个栗子，比如下面这幅图，每个椭圆代表1个goroutine，其中的数字为编号，箭头代表调用关系。heap profile显示g111（最下方标红节点）这个协程的代码出现了泄露，任何一个从g101到g111的调用路径都可能造成了g111的内存泄露，有2类可能：</p>
<ol>
<li>该goroutine只调用了少数几次，但消耗了大量的内存，说明每个goroutine调用都消耗了不少内存，内存泄露的原因基本就在该协程内部。</li>
<li>该goroutine的调用次数非常多，虽然每个协程调用过程中消耗的内存不多，但该调用路径上，协程数量巨大，造成消耗大量的内存，并且这些goroutine由于某种原因无法退出，占用的内存不会释放，内存泄露的原因在到g111调用路径上某段代码实现有问题，造成创建了大量的g111。</li>
</ol>
<p>第2种情况，就是goroutine泄露，这是通过heap无法发现的，所以heap在定位内存泄露这件事上，发挥的作用不大。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200210154515.png" alt=""></p>
<h1 id="什么是goroutine泄露">什么是goroutine泄露</h1>
<p>如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p>
<h1 id="goroutine泄露怎么导致内存泄露">goroutine泄露怎么导致内存泄露</h1>
<p>每个goroutine占用2KB内存，泄露1百万goroutine至少泄露2KB * 1000000 = 2GB内存，为什么说至少呢？</p>
<p>goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p>
<p>所以goroutine泄露有2种方式造成内存泄露：</p>
<ul>
<li>goroutine本身的栈所占用的空间造成内存泄露。</li>
<li>goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。</li>
</ul>
<p>Dave在文章中也提到了，如果不知道何时停止一个goroutine，这个goroutine就是潜在的内存泄露：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">7.1.1 Know when to stop a goroutine
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">If you don’t know the answer, that’s a potential memory leak as the goroutine will pin its stack’s memory on the heap, as well as any heap allocated variables reachable from the stack.
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="怎么确定是goroutine泄露引发的内存泄露">怎么确定是goroutine泄露引发的内存泄露</h1>
<p>掌握了前面的pprof命令行的基本用法，很快就可以确认是否是goroutine泄露导致内存泄露.</p>
<p>判断依据：在节点正常运行的情况下，隔一段时间获取goroutine的数量，如果后面获取的那次，某些goroutine比前一次多，如果多获取几次，是持续增长的，就极有可能是goroutine泄露。</p>
<p>goroutine导致内存泄露的demo：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// goroutine泄露导致内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开启pprof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ip</span> <span class="o">:=</span> <span class="s">&#34;0.0.0.0:6060&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">ip</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;start pprof failed on %s\n&#34;</span><span class="p">,</span> <span class="nx">ip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">outCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 死代码，永不读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">&lt;-</span><span class="nx">outCh</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 每s起100个goroutine，goroutine会阻塞，不释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="k">range</span> <span class="nx">tick</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">alloc1</span><span class="p">(</span><span class="nx">outCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">alloc1</span><span class="p">(</span><span class="nx">outCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">alloc2</span><span class="p">(</span><span class="nx">outCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">alloc2</span><span class="p">(</span><span class="nx">outCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;alloc-fm exit&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 分配内存，假用一下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;alloc done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">outCh</span> <span class="o">&lt;-</span> <span class="mi">0</span> <span class="c1">// 53行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译并运行以上代码，然后使用go tool pprof获取gorourine的profile文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go tool pprof http://localhost:6060/debug/pprof/goroutine
</span></span></code></pre></td></tr></table>
</div>
</div><p>已经通过pprof命令获取了2个goroutine的profile文件:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ls
</span></span><span class="line"><span class="cl">/home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz
</span></span><span class="line"><span class="cl">/home/ubuntu/pprof/pprof.leak_demo.goroutine.002.pb.gz
</span></span></code></pre></td></tr></table>
</div>
</div><p>同heap一样，我们可以使用base对比2个goroutine profile文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">$go</span> tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gz
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">File: leak_demo
</span></span><span class="line"><span class="cl">Type: goroutine
</span></span><span class="line"><span class="cl">Time: May 16, <span class="m">2019</span> at 2:44pm <span class="o">(</span>CST<span class="o">)</span>
</span></span><span class="line"><span class="cl">Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>pprof<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>pprof<span class="o">)</span> top
</span></span><span class="line"><span class="cl">Showing nodes accounting <span class="k">for</span> 20312, 100% of <span class="m">20312</span> total
</span></span><span class="line"><span class="cl">      flat  flat%   sum%        cum   cum%
</span></span><span class="line"><span class="cl">     <span class="m">20312</span>   100%   100%      <span class="m">20312</span>   100%  runtime.gopark
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">20312</span>   100%  main.alloc2
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">20312</span>   100%  main.alloc2.func1
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">20312</span>   100%  runtime.chansend
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">20312</span>   100%  runtime.chansend1
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">20312</span>   100%  runtime.goparkunlock
</span></span><span class="line"><span class="cl"><span class="o">(</span>pprof<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到运行到runtime.gopark的goroutine数量增加了20312个。再通过002文件，看一眼执行到gopark的goroutine数量，即挂起的goroutine数量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go tool pprof pprof.leak_demo.goroutine.002.pb.gz
</span></span><span class="line"><span class="cl">File: leak_demo
</span></span><span class="line"><span class="cl">Type: goroutine
</span></span><span class="line"><span class="cl">Time: May 16, <span class="m">2019</span> at 2:47pm <span class="o">(</span>CST<span class="o">)</span>
</span></span><span class="line"><span class="cl">Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>pprof<span class="o">)</span> top
</span></span><span class="line"><span class="cl">Showing nodes accounting <span class="k">for</span> 24330, 100% of <span class="m">24331</span> total
</span></span><span class="line"><span class="cl">Dropped <span class="m">32</span> nodes <span class="o">(</span>cum &lt;<span class="o">=</span> 121<span class="o">)</span>
</span></span><span class="line"><span class="cl">      flat  flat%   sum%        cum   cum%
</span></span><span class="line"><span class="cl">     <span class="m">24330</span>   100%   100%      <span class="m">24330</span>   100%  runtime.gopark
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">24326</span>   100%  main.alloc2
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">24326</span>   100%  main.alloc2.func1
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">24326</span>   100%  runtime.chansend
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">24326</span>   100%  runtime.chansend1
</span></span><span class="line"><span class="cl">         <span class="m">0</span>     0%   100%      <span class="m">24327</span>   100%  runtime.goparkunlock
</span></span></code></pre></td></tr></table>
</div>
</div><p>显示有24330个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</p>
<p>是什么导致如此多的goroutine被挂起而无法退出？接下来就看怎么定位goroutine泄露。</p>
<h1 id="定位goroutine泄露的2种方法">定位goroutine泄露的2种方法</h1>
<p>使用pprof有2种方式，一种是web网页，一种是go tool pprof命令行交互，这两种方法查看goroutine都支持，但有轻微不同，也有各自的优缺点。</p>
<p>我们先看Web的方式，再看命令行交互的方式，这两种都很好使用，结合起来用也不错。</p>
<h2 id="web可视化查看">Web可视化查看</h2>
<p>Web方式适合web服务器的端口能访问的情况，使用起来方便，有2种方式：</p>
<ul>
<li>查看某条调用路径上，当前阻塞在此goroutine的数量</li>
<li>查看所有goroutine的运行栈（调用路径），可以显示阻塞在此的时间</li>
</ul>
<p>方式一</p>
<p>url请求中设置debug=1：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">http://ip:port/debug/pprof/goroutine?debug=1
</span></span></code></pre></td></tr></table>
</div>
</div><p>效果如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200210155211.png" alt=""></p>
<p>看起来密密麻麻的，其实简单又十分有用，看上图标出来的部分，手机上图看起来可能不方便，那就放大图片，或直接看下面各字段的含义：</p>
<ul>
<li>goroutine profile: total 32023：32023是goroutine的总数量，</li>
<li>32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 &hellip;：32015代表当前有32015个goroutine运行这个调用栈，并且停在相同位置，@后面的十六进制，现在用不到这个数据，所以暂不深究了。</li>
<li>下面是当前goroutine的调用栈，列出了函数和所在文件的行数，这个行数对定位很有帮助，如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 0x6d8559 0x6d831b 0x45abe1
</span></span><span class="line"><span class="cl">#	0x6d8558	main.alloc2.func1+0xf8	/home/ubuntu/heap/leak_demo.go:53
</span></span><span class="line"><span class="cl">#	0x6d831a	main.alloc2+0x2a	/home/ubuntu/heap/leak_demo.go:54
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据上面的提示，就能判断32015个goroutine运行到leak_demo.go的53行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">alloc2</span><span class="p">(</span><span class="nx">outCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;alloc-fm exit&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 分配内存，假用一下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;alloc done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">outCh</span> <span class="o">&lt;-</span> <span class="mi">0</span> <span class="c1">// 53行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>阻塞的原因是outCh这个写操作无法完成，outCh是无缓冲的通道，并且由于以下代码是死代码，所以goroutine始终没有从outCh读数据，造成outCh阻塞，进而造成无数个alloc2的goroutine阻塞，形成内存泄露：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;-</span><span class="nx">outCh</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="方式二">方式二</h2>
<p>url请求中设置debug=2：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">http://ip:port/debug/pprof/goroutine?debug=2
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200210155828.png" alt=""></p>
<p>第2种方式和第1种方式是互补的，它可以看到每个goroutine的信息：</p>
<ul>
<li>goroutine 20 [chan send, 2 minutes]：20是goroutine id，[]中是当前goroutine的状态，阻塞在写channel，并且阻塞了2分钟，长时间运行的系统，你能看到阻塞时间更长的情况。</li>
<li>同时，也可以看到调用栈，看当前执行停到哪了：leak_demo.go的53行，</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">goroutine 20 [chan send, 2 minutes]:
</span></span><span class="line"><span class="cl">main.alloc2.func1(0xc42015e060)
</span></span><span class="line"><span class="cl">	/home/ubuntu/heap/leak_demo.go:53 +0xf9  // 这
</span></span><span class="line"><span class="cl">main.alloc2(0xc42015e060)
</span></span><span class="line"><span class="cl">	/home/ubuntu/heap/leak_demo.go:54 +0x2b
</span></span><span class="line"><span class="cl">created by main.alloc1
</span></span><span class="line"><span class="cl">	/home/ubuntu/heap/leak_demo.go:42 +0x3f
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="命令行交互式方法">命令行交互式方法</h1>
<p>Web的方法是简单粗暴，无需登录服务器，浏览器打开看看就行了。但就像前面提的，没有浏览器可访问时，命令行交互式才是最佳的方式，并且也是手到擒来，感觉比Web一样方便。</p>
<p>命令行交互式只有1种获取goroutine profile的方法，不像Web网页分debug=1和debug=22中方式，并将profile文件保存到本地：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 注意命令没有`debug=1`，debug=1，加debug有些版本的go不支持
</span></span><span class="line"><span class="cl">$ go tool pprof http://0.0.0.0:6060/debug/pprof/goroutine
</span></span><span class="line"><span class="cl">Fetching profile over HTTP from http://localhost:6061/debug/pprof/goroutine
</span></span><span class="line"><span class="cl">Saved profile in /home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz  // profile文件保存位置
</span></span><span class="line"><span class="cl">File: leak_demo
</span></span><span class="line"><span class="cl">Type: goroutine
</span></span><span class="line"><span class="cl">Time: May 16, 2019 at 2:44pm (CST)
</span></span><span class="line"><span class="cl">Entering interactive mode (type &#34;help&#34; for commands, &#34;o&#34; for options)
</span></span><span class="line"><span class="cl">(pprof)
</span></span></code></pre></td></tr></table>
</div>
</div><p>命令行只需要掌握3个命令就好:</p>
<ul>
<li>top：显示正运行到某个函数goroutine的数量</li>
<li>traces：显示所有goroutine的调用栈</li>
<li>list：列出代码详细的信息。</li>
</ul>
<p>我们依然使用这个demo:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// goroutine泄露导致内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 开启pprof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ip</span> <span class="o">:=</span> <span class="s">&#34;0.0.0.0:6060&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">ip</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;start pprof failed on %s\n&#34;</span><span class="p">,</span> <span class="nx">ip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">outCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 死代码，永不读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">&lt;-</span><span class="nx">outCh</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 每s起100个goroutine，goroutine会阻塞，不释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="k">range</span> <span class="nx">tick</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">alloc1</span><span class="p">(</span><span class="nx">outCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">alloc1</span><span class="p">(</span><span class="nx">outCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">alloc2</span><span class="p">(</span><span class="nx">outCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">alloc2</span><span class="p">(</span><span class="nx">outCh</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;alloc-fm exit&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 分配内存，假用一下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;alloc done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">outCh</span> <span class="o">&lt;-</span> <span class="mi">0</span> <span class="c1">// 53行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$  go tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gz
</span></span><span class="line"><span class="cl">File: leak_demo
</span></span><span class="line"><span class="cl">Type: goroutine
</span></span><span class="line"><span class="cl">Time: May 16, 2019 at 2:44pm (CST)
</span></span><span class="line"><span class="cl">Entering interactive mode (type &#34;help&#34; for commands, &#34;o&#34; for options)
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof) top
</span></span><span class="line"><span class="cl">Showing nodes accounting for 20312, 100% of 20312 total
</span></span><span class="line"><span class="cl">      flat  flat%   sum%        cum   cum%
</span></span><span class="line"><span class="cl">     20312   100%   100%      20312   100%  runtime.gopark
</span></span><span class="line"><span class="cl">         0     0%   100%      20312   100%  main.alloc2
</span></span><span class="line"><span class="cl">         0     0%   100%      20312   100%  main.alloc2.func1
</span></span><span class="line"><span class="cl">         0     0%   100%      20312   100%  runtime.chansend
</span></span><span class="line"><span class="cl">         0     0%   100%      20312   100%  runtime.chansend1
</span></span><span class="line"><span class="cl">         0     0%   100%      20312   100%  runtime.goparkunlock
</span></span><span class="line"><span class="cl">(pprof)
</span></span><span class="line"><span class="cl">(pprof) traces
</span></span><span class="line"><span class="cl">File: leak_demo
</span></span><span class="line"><span class="cl">Type: goroutine
</span></span><span class="line"><span class="cl">Time: May 16, 2019 at 2:44pm (CST)
</span></span><span class="line"><span class="cl">-----------+-------------------------------------------------------
</span></span><span class="line"><span class="cl">     20312   runtime.gopark
</span></span><span class="line"><span class="cl">             runtime.goparkunlock
</span></span><span class="line"><span class="cl">             runtime.chansend
</span></span><span class="line"><span class="cl">             runtime.chansend1 // channel发送
</span></span><span class="line"><span class="cl">             main.alloc2.func1 // alloc2中的匿名函数
</span></span><span class="line"><span class="cl">             main.alloc2
</span></span><span class="line"><span class="cl">-----------+-------------------------------------------------------
</span></span></code></pre></td></tr></table>
</div>
</div><p>top命令在怎么确定是goroutine泄露引发的内存泄露介绍过了，直接看traces命令，traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数alloc2.func1调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出alloc2.func1的代码，显示有20312个goroutine阻塞在53行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(pprof) list main.alloc2.func1
</span></span><span class="line"><span class="cl">Total: 20312
</span></span><span class="line"><span class="cl">ROUTINE ======================== main.alloc2.func1 in /home/ubuntu/heap/leak_demo.go
</span></span><span class="line"><span class="cl">         0      20312 (flat, cum)   100% of Total
</span></span><span class="line"><span class="cl">         .          .     48:		// 分配内存，假用一下
</span></span><span class="line"><span class="cl">         .          .     49:		buf := make([]byte, 1024*1024*10)
</span></span><span class="line"><span class="cl">         .          .     50:		_ = len(buf)
</span></span><span class="line"><span class="cl">         .          .     51:		fmt.Println(&#34;alloc done&#34;)
</span></span><span class="line"><span class="cl">         .          .     52:
</span></span><span class="line"><span class="cl">         .      20312     53:		outCh &lt;- 0  // 看这
</span></span><span class="line"><span class="cl">         .          .     54:	}()
</span></span><span class="line"><span class="cl">         .          .     55:}
</span></span><span class="line"><span class="cl">         .          .     56:
</span></span></code></pre></td></tr></table>
</div>
</div><p>友情提醒：使用list命令的前提是程序的源码在当前机器，不然可没法列出源码。服务器上，通常没有源码，那我们咋办呢？刚才介绍了Web查看的方式，那里会列出代码行数，我们可以使用wget下载网页：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">wget http://localhost:6060/debug/pprof/goroutine?debug<span class="o">=</span><span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下载网页后，使用编辑器打开文件，使用关键字main.alloc2.func1进行搜索，找到与当前相同的调用栈，就可以看到该goroutine阻塞在哪一行了，不要忘记使用debug=2还可以看到阻塞了多久和原因.</p>
<h1 id="总结">总结</h1>
<h2 id="goroutine泄露的本质">goroutine泄露的本质</h2>
<p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p>
<h2 id="goroutine泄露的发现和定位">goroutine泄露的发现和定位</h2>
<p>利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p>
<h2 id="goroutine泄露的场景">goroutine泄露的场景</h2>
<p>泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p>
<ul>
<li>channel的读或者写：
<ul>
<li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li>
<li>有缓冲的channel因为缓冲区满了，写操作阻塞</li>
<li>期待从channel读数据，结果没有goroutine写</li>
</ul>
</li>
<li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li>
</ul>
<h2 id="编码goroutine泄露的建议">编码goroutine泄露的建议</h2>
<p>为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p>
<ul>
<li>goroutine如何退出？</li>
<li>是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？</li>
</ul>
<p>转载:<a href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">http://lessisbetter.site/2019/05/18/go-goroutine-leak/</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-02-09
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7trace%E4%BB%8B%E7%BB%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go性能分析工具trace介绍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/pprof%E5%AE%9E%E6%88%98%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%92%E6%9F%A5%E7%82%B8%E5%BC%B9%E7%A8%8B%E5%BA%8F/">
            <span class="next-text nav-default">Pprof实战:从零开始排查炸弹程序</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
