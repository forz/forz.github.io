<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hystrix-go源码剖析 | Forz Blog</title>
<meta name="keywords" content="hystrix" />
<meta name="description" content="执行:Do与Go 同步执行，直接调用Do方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48">
<meta name="author" content="">
<link rel="canonical" href="/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="hystrix-go源码剖析" />
<meta property="og:description" content="执行:Do与Go 同步执行，直接调用Do方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-11-04T16:07:01&#43;00:00" />
<meta property="article:modified_time" content="2019-11-04T16:07:01&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="hystrix-go源码剖析"/>
<meta name="twitter:description" content="执行:Do与Go 同步执行，直接调用Do方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "hystrix-go源码剖析",
      "item": "/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "hystrix-go源码剖析",
  "name": "hystrix-go源码剖析",
  "description": "执行:Do与Go 同步执行，直接调用Do方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48",
  "keywords": [
    "hystrix"
  ],
  "articleBody": "执行:Do与Go 同步执行，直接调用Do方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // Do runs your function in a synchronous manner, blocking until either your function succeeds // or an error is returned, including hystrix circuit errors func Do(name string, run runFunc, fallback fallbackFunc) error { runC := func(ctx context.Context) error { return run() } var fallbackC fallbackFuncC if fallback != nil { fallbackC = func(ctx context.Context, err error) error { return fallback(err) } } return DoC(context.Background(), name, runC, fallbackC) } // DoC runs your function in a synchronous manner, blocking until either your function succeeds // or an error is returned, including hystrix circuit errors func DoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) error { done := make(chan struct{}, 1) r := func(ctx context.Context) error { err := run(ctx) if err != nil { return err } done  struct{}{} return nil } f := func(ctx context.Context, e error) error { err := fallback(ctx, e) if err != nil { return err } done  struct{}{} return nil } var errChan chan error if fallback == nil { errChan = GoC(ctx, name, r, nil) } else { errChan = GoC(ctx, name, r, f) } select { case done: return nil case err := errChan: return err } }   异步执行Go方法,内部实现是启动了一个gorouting，如果想得到自定义方法的数据，需要你传channel来处理数据，或者输出。返回的error也是一个channel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Go runs your function while tracking the health of previous calls to it. // If your function begins slowing down or failing repeatedly, we will block // new calls to it for you to give the dependent service time to repair. // // Define a fallback function if you want to define some code to execute during outages. func Go(name string, run runFunc, fallback fallbackFunc) chan error { runC := func(ctx context.Context) error { return run() } var fallbackC fallbackFuncC if fallback != nil { fallbackC = func(ctx context.Context, err error) error { return fallback(err) } } return GoC(context.Background(), name, runC, fallbackC) }   大概的执行流程图\n其实方法Do和Go方法内部都是调用了hystrix.GoC方法，只是Do方法处理了异步的过程,稍后讨论\n配置:CommandConfig 1 2 3 4 5 6 7 8  // CommandConfig is used to tune circuit settings at runtime type CommandConfig struct { Timeout int `json:\"timeout\"`// 超时时间定义 \tMaxConcurrentRequests int `json:\"max_concurrent_requests\"`// 最大并发请求数 \tRequestVolumeThreshold int `json:\"request_volume_threshold\"`// 跳闸的最小请求数（不健康的断路器） \tSleepWindow int `json:\"sleep_window\"`// 跳闸之后可以重试的时间 \tErrorPercentThreshold int `json:\"error_percent_threshold\"`// 请求出错比 }   CommandConfig 几个字段的意义：\n Timeout: 执行command的超时时间。默认时间是1000毫秒 MaxConcurrentRequests：command的最大并发量 默认值是10 SleepWindow：当熔断器被打开后，SleepWindow的时间就是控制过多久后去尝试服务是否可用了。默认值是5000毫秒 RequestVolumeThreshold： 一个统计窗口10秒内请求数量。达到这个请求数量后才去判断是否要开启熔断。默认值是20 ErrorPercentThreshold：错误百分比，请求数量大于等于RequestVolumeThreshold并且错误率到达这个百分比后就会启动熔断 默认值是50  RequestVolumeThreshold与ErrorPercentThreshold通常组合使用\n当然如果不配置他们，会使用默认值.\n断路器:CircuitBreaker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // CircuitBreaker is created for each ExecutorPool to track whether requests // should be attempted, or rejected if the Health of the circuit is too low. type CircuitBreaker struct { // 断路器-定义  Name string // 名字  open bool // 开启与否，关闭\"open\"=true，开启\"open\" = false  forceOpen bool // 强制开启  mutex *sync.RWMutex // 读写锁（unblock reading, block writer）  openedOrLastTestedTime int64 // 断路器被打开或者最近一次尝试的时间，尝试指断路器打开之后，系统探测是否可以发送请求。  executorPool *executorPool // 执行池  metrics *metricExchange // 监控断路器 } var ( circuitBreakersMutex *sync.RWMutex // 断路器锁  circuitBreakers map[string]*CircuitBreaker // 注册断路器，所有的断路器都保存在这里 ) func init() { circuitBreakersMutex = \u0026sync.RWMutex{} // 初始化断路器锁  circuitBreakers = make(map[string]*CircuitBreaker) // 初始化断路器 }   获取断路器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // GetCircuit returns the circuit for the given command and whether this call created it. func GetCircuit(name string) (*CircuitBreaker, bool, error) { circuitBreakersMutex.RLock() _, ok := circuitBreakers[name] if !ok { circuitBreakersMutex.RUnlock() circuitBreakersMutex.Lock() defer circuitBreakersMutex.Unlock() // 注意这里同时加了两次锁且第二把锁是互斥锁，其中一个goroutine hold住并且赋值，锁释放。其他goroutine从内存中获取断路器  if cb, ok := circuitBreakers[name]; ok { // double check，防止其他的goroutine修改了全局变量circuitBreakers  return cb, false, nil } circuitBreakers[name] = newCircuitBreaker(name) } else { defer circuitBreakersMutex.RUnlock() } return circuitBreakers[name], !ok, nil }   监控:metricExchange 每一次断路器逻辑的执行都会上报执行过程中的状态:\n断路器–执行–上报执行状态信息–保存到相应的Buckets\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // ReportEvent records command metrics for tracking recent error rates and exposing data to the dashboard. func (circuit *CircuitBreaker) ReportEvent(eventTypes []string, start time.Time, runDuration time.Duration) error { if len(eventTypes) == 0 { return fmt.Errorf(\"no event types sent for metrics\") } circuit.mutex.RLock() o := circuit.open circuit.mutex.RUnlock() if eventTypes[0] == \"success\" \u0026\u0026 o { circuit.setClose() } var concurrencyInUse float64 if circuit.executorPool.Max  0 { concurrencyInUse = float64(circuit.executorPool.ActiveCount()) / float64(circuit.executorPool.Max) } select { case circuit.metrics.Updates  \u0026commandExecution{ Types: eventTypes, Start: start, RunDuration: runDuration, ConcurrencyInUse: concurrencyInUse, }: default: return CircuitError{Message: fmt.Sprintf(\"metrics channel (%v) is at capacity\", circuit.Name)} } return nil }   circuit.metrics.Updates 这个信道就是处理上报信息的，上报执行状态信息的结构是metricExchange，结构体很简单只有4个字段:\n Updates:有buffer的commandExecution通道,默认的数量是2000个,所有的状态信息都在他里面 metricCollectors:保存的具体的这个command执行过程中的各种信息  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type metricExchange struct { Name string Updates chan *commandExecution Mutex *sync.RWMutex metricCollectors []metricCollector.MetricCollector } type commandExecution struct { Types []string `json:\"types\"` Start time.Time `json:\"start_time\"` RunDuration time.Duration `json:\"run_duration\"` ConcurrencyInUse float64 `json:\"concurrency_inuse\"` }   在执行newMetricExchange的时候会启动一个协程 go m.Monitor()去监控Updates的数据，然后上报给metricCollectors 保存执行的信息数据比如前面提到的调用次数，失败次数，被拒绝次数等等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func newMetricExchange(name string) *metricExchange { m := \u0026metricExchange{} m.Name = name m.Updates = make(chan *commandExecution, 2000) m.Mutex = \u0026sync.RWMutex{} m.metricCollectors = metricCollector.Registry.InitializeMetricCollectors(name) m.Reset() go m.Monitor() return m } func (m *metricExchange) Monitor() { for update := range m.Updates { // we only grab a read lock to make sure Reset() isn't changing the numbers.  m.Mutex.RLock() totalDuration := time.Since(update.Start) wg := \u0026sync.WaitGroup{} for _, collector := range m.metricCollectors { wg.Add(1) go m.IncrementMetrics(wg, collector, update, totalDuration) } wg.Wait() m.Mutex.RUnlock() } }   更新调用的是go m.IncrementMetrics(wg, collector, update, totalDuration)，里面判断了他的状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func (m *metricExchange) IncrementMetrics(wg *sync.WaitGroup, collector metricCollector.MetricCollector, update *commandExecution, totalDuration time.Duration) { // granular metrics  r := metricCollector.MetricResult{ Attempts: 1, TotalDuration: totalDuration, RunDuration: update.RunDuration, ConcurrencyInUse: update.ConcurrencyInUse, } switch update.Types[0] { case \"success\": r.Successes = 1 case \"failure\": r.Failures = 1 r.Errors = 1 case \"rejected\": r.Rejects = 1 r.Errors = 1 // ...  } // ...  collector.Update(r) wg.Done() }   底层控制器:MetricCollector 每一个Command都会有一个默认统计控制器，当然也可以添加多个自定义的控制器。\n默认的统计控制器DefaultMetricCollector保存着熔断器的所有状态，调用次数，失败次数，被拒绝次数等等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // DefaultMetricCollector holds information about the circuit state. // This implementation of MetricCollector is the canonical source of information about the circuit. // It is used for for all internal hystrix operations // including circuit health checks and metrics sent to the hystrix dashboard. // // Metric Collectors do not need Mutexes as they are updated by circuits within a locked context. type DefaultMetricCollector struct { mutex *sync.RWMutex numRequests *rolling.Number errors *rolling.Number successes *rolling.Number failures *rolling.Number rejects *rolling.Number shortCircuits *rolling.Number timeouts *rolling.Number contextCanceled *rolling.Number contextDeadlineExceeded *rolling.Number fallbackSuccesses *rolling.Number fallbackFailures *rolling.Number totalDuration *rolling.Timing runDuration *rolling.Timing }   最主要的还是要看一下rolling.Number，rolling.Number才是状态最终保存的地方\nNumber保存了10秒内的Buckets数据信息，每一个Bucket的统计时长为1秒\n1 2 3 4 5 6 7 8 9 10  // Number tracks a numberBucket over a bounded number of // time buckets. Currently the buckets are one second long and only the last 10 seconds are kept. type Number struct { Buckets map[int64]*numberBucket Mutex *sync.RWMutex } type numberBucket struct { Value float64 }   字典字段Buckets map[int64]*numberBucket 中的Key保存的是当前时间\n可能你会好奇Number是如何保证只保存10秒内的数据的。每一次对熔断器的状态进行修改时，Number都要先得到当前的时间(秒级)的Bucket不存在则创建。\n1 2 3 4 5 6 7 8 9 10 11 12  func (r *Number) getCurrentBucket() *numberBucket { now := time.Now().Unix() var bucket *numberBucket var ok bool if bucket, ok = r.Buckets[now]; !ok { bucket = \u0026numberBucket{} r.Buckets[now] = bucket } return bucket }   修改完后去掉10秒外的数据\n1 2 3 4 5 6 7 8 9 10  func (r *Number) removeOldBuckets() { now := time.Now().Unix() - 10 for timestamp := range r.Buckets { // TODO: configurable rolling window  if timestamp  now { delete(r.Buckets, timestamp) } } }   比如Increment方法，先得到Bucket再删除旧的数据\n1 2 3 4 5 6 7 8 9 10 11 12  func (r *Number) Increment(i float64) { if i == 0 { return } r.Mutex.Lock() defer r.Mutex.Unlock() b := r.getCurrentBucket() b.Value += i r.removeOldBuckets() }   统计控制器是最基层和最重要的一个实现，上层所有的执行判断都是基于他的数据进行逻辑处理的\n执行池:executorPool hystrix-go对流量控制的代码是很简单的。用了一个简单的令牌算法，能得到令牌的就可以执行后继的工作，执行完后要返还令牌。得不到令牌就拒绝，拒绝后调用用户设置的callback方法，如果没有设置就不执行。\n结构体executorPool就是hystrix-go执行池的具体实现。字段Max就是每秒最大的并发值。\n1 2 3 4 5 6  type executorPool struct { // 执行池  Name string // 名字  Metrics *poolMetrics // 执行池监控  Max int // 最大的并发请求数量  Tickets chan *struct{} // 票证 }   在创建executorPool的时候，会根据Max值来创建令牌。Max值如果没有设置会使用默认值10\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //开启新的执行池 func newExecutorPool(name string) *executorPool { p := \u0026executorPool{} p.Name = name//名字  p.Metrics = newPoolMetrics(name) p.Max = getSettings(name).MaxConcurrentRequests// 从配置中获取最大的并发请求数量，如果配置中没有，则从默认配置中获取  p.Tickets = make(chan *struct{}, p.Max)// 初始化buffer chan  for i := 0; i  p.Max; i++ { p.Tickets  \u0026struct{}{} } return p } //上报状态 func (p *executorPool) Return(ticket *struct{}) { if ticket == nil { return } p.Metrics.Updates  poolMetricsUpdate{ activeCount: p.ActiveCount(), } p.Tickets  ticket } func (p *executorPool) ActiveCount() int { return p.Max - len(p.Tickets) }   注意一下字段 Metrics 他用于统计执行数量，比如：执行的总数量,最大的并发数.这个数量也可以显露出，供可视化程序直观的表现出来。\n1 2 3 4 5 6 7 8 9 10 11  type poolMetrics struct { Mutex *sync.RWMutex Updates chan poolMetricsUpdate Name string MaxActiveRequests *rolling.Number Executed *rolling.Number } type poolMetricsUpdate struct { activeCount int }   令牌使用完后是需要返还的，返回的时候才会做上面所说的统计工作。\n执行实体:GoC hystrix在执行一次command会调用GoC方法，就是在判断断路器是否已打开，得到Ticket得不到就限流，执行我们自己的的方法，判断context是否Done或者执行是否超时.每次执行结果都要上报执行状态,最后要返还Ticket\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  // GoC runs your function while tracking the health of previous calls to it. // If your function begins slowing down or failing repeatedly, we will block // new calls to it for you to give the dependent service time to repair. // // Define a fallback function if you want to define some code to execute during outages. func GoC(ctx context.Context, name string, run runFuncC, fallback fallbackFuncC) chan error { cmd := \u0026command{// command执行者 \trun: run, //run \tfallback: fallback,//fallback \tstart: time.Now(), //开始时间 \terrChan: make(chan error, 1), //错误 \tfinished: make(chan bool, 1), //是否完成 \t} // dont have methods with explicit params and returns \t// let data come in and out naturally, like with any closure \t// explicit error return to give place for us to kill switch the operation (fallback)  //得到断路器,不存在则创建 \tcircuit, _, err := GetCircuit(name) if err != nil { cmd.errChan  err return cmd.errChan } cmd.circuit = circuit ticketCond := sync.NewCond(cmd)// cond条件 \tticketChecked := false // When the caller extracts error from returned errChan, it's assumed that \t// the ticket's been returned to executorPool. Therefore, returnTicket() can  // not run after cmd.errorWithFallback().  // 返还ticket \treturnTicket := func() { cmd.Lock() // Avoid releasing before a ticket is acquired. \tfor !ticketChecked { ticketCond.Wait()// 相当于select{} \t} cmd.circuit.executorPool.Return(cmd.ticket)// 将ticket放回池子中 \tcmd.Unlock() } // Shared by the following two goroutines. It ensures only the faster  // goroutine runs errWithFallback() and reportAllEvent().  // 上报执行状态 \treturnOnce := \u0026sync.Once{}// 确保被multi goroutine执行一次 \treportAllEvent := func() {// events采集，后续dashboard使用 \terr := cmd.circuit.ReportEvent(cmd.events, cmd.start, cmd.runDuration) if err != nil { log.Printf(err.Error()) } } // g1, 检测断路器不允许通过，尝试fallback，将中途遇到的event上报。 \tgo func() { defer func() { cmd.finished  true }() // Circuits get opened when recent executions have shown to have a high error rate. \t// Rejecting new executions allows backends to recover, and the circuit will allow  // new traffic when it feels a healthly state has returned.  // 查看断路器是否已打开 \tif !cmd.circuit.AllowRequest() { cmd.Lock() // It's safe for another goroutine to go ahead releasing a nil ticket. \tticketChecked = true ticketCond.Signal() cmd.Unlock() returnOnce.Do(func() { returnTicket() cmd.errorWithFallback(ctx, ErrCircuitOpen) reportAllEvent() }) return } // As backends falter, requests take longer but don't always fail. \t// \t// When requests slow down but the incoming rate of requests stays the same, you have to \t// run more at a time to keep up. By controlling concurrency during these situations, you can \t// shed load which accumulates due to the increasing ratio of active commands to incoming requests.  cmd.Lock() // 获取ticket 如果得不到就限流 \tselect { case cmd.ticket = circuit.executorPool.Tickets:// 从池子中取出ticket \tticketChecked = true ticketCond.Signal()// 通知cond.Wait() \tcmd.Unlock() default: ticketChecked = true ticketCond.Signal() cmd.Unlock() returnOnce.Do(func() { returnTicket() cmd.errorWithFallback(ctx, ErrMaxConcurrency)// 并发过高 \treportAllEvent() }) return } // 执行我们自已的方法，并上报执行信息 \trunStart := time.Now() runErr := run(ctx) returnOnce.Do(func() { defer reportAllEvent() cmd.runDuration = time.Since(runStart)// 运行时间 \treturnTicket()// 把ticket返回去 \tif runErr != nil { cmd.errorWithFallback(ctx, runErr) return } cmd.reportEvent(\"success\")// 执行成功 \t}) }() // 等待context是否被结束，或执行者超时，并上报 \tgo func() { timer := time.NewTimer(getSettings(name).Timeout) defer timer.Stop() select { case cmd.finished:// 结束select \t// returnOnce has been executed in another goroutine \tcase ctx.Done():// 处理ctx错误 \treturnOnce.Do(func() { returnTicket() cmd.errorWithFallback(ctx, ctx.Err()) reportAllEvent() }) return case timer.C:// 处理超时 \treturnOnce.Do(func() { returnTicket() cmd.errorWithFallback(ctx, ErrTimeout) reportAllEvent() }) return } }() return cmd.errChan// 错误返回至上层 }   可视化:StreamHandler 代码中StreamHandler就是把所有断路器的状态以流的方式不断的推送到dashboard. 这部分代码我就不用说了，很简单。\n需要在你的服务端加3行代码，启动我们的流服务:\n1 2 3  hystrixStreamHandler := hystrix.NewStreamHandler() hystrixStreamHandler.Start() go http.ListenAndServe(net.JoinHostPort(\"\", \"81\"), hystrixStreamHandler)   如果是集群可以使用Turbine进行监控\n参考:\nhttps://www.cnblogs.com/li-peng/p/11050563.html\nhttps://www.zybuluo.com/aliasliyu4/note/1248898\n",
  "wordCount" : "4679",
  "inLanguage": "zh-cn",
  "datePublished": "2019-11-04T16:07:01Z",
  "dateModified": "2019-11-04T16:07:01Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/hystrix-go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      hystrix-go源码剖析
    </h1>
    <div class="post-meta">November 4, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="执行do与go">执行:Do与Go<a hidden class="anchor" aria-hidden="true" href="#执行do与go">#</a></h1>
<p>同步执行，直接调用Do方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Do runs your function in a synchronous manner, blocking until either your function succeeds
</span><span class="c1">// or an error is returned, including hystrix circuit errors
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">run</span> <span class="nx">runFunc</span><span class="p">,</span> <span class="nx">fallback</span> <span class="nx">fallbackFunc</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">runC</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">run</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">fallbackC</span> <span class="nx">fallbackFuncC</span>
	<span class="k">if</span> <span class="nx">fallback</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fallbackC</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">fallback</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">DoC</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">runC</span><span class="p">,</span> <span class="nx">fallbackC</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// DoC runs your function in a synchronous manner, blocking until either your function succeeds
</span><span class="c1">// or an error is returned, including hystrix circuit errors
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DoC</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">run</span> <span class="nx">runFuncC</span><span class="p">,</span> <span class="nx">fallback</span> <span class="nx">fallbackFuncC</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nf">run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nf">fallback</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">errChan</span> <span class="kd">chan</span> <span class="kt">error</span>
	<span class="k">if</span> <span class="nx">fallback</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errChan</span> <span class="p">=</span> <span class="nf">GoC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">errChan</span> <span class="p">=</span> <span class="nf">GoC</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errChan</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>异步执行Go方法,内部实现是启动了一个gorouting，如果想得到自定义方法的数据，需要你传channel来处理数据，或者输出。返回的error也是一个channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go runs your function while tracking the health of previous calls to it.
</span><span class="c1">// If your function begins slowing down or failing repeatedly, we will block
</span><span class="c1">// new calls to it for you to give the dependent service time to repair.
</span><span class="c1">//
</span><span class="c1">// Define a fallback function if you want to define some code to execute during outages.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">run</span> <span class="nx">runFunc</span><span class="p">,</span> <span class="nx">fallback</span> <span class="nx">fallbackFunc</span><span class="p">)</span> <span class="kd">chan</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">runC</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">run</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">fallbackC</span> <span class="nx">fallbackFuncC</span>
	<span class="k">if</span> <span class="nx">fallback</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fallbackC</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">fallback</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">GoC</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">runC</span><span class="p">,</span> <span class="nx">fallbackC</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>大概的执行流程图</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191105102052.png" alt=""  />
</p>
<p>其实方法Do和Go方法内部都是调用了hystrix.GoC方法，只是Do方法处理了异步的过程,稍后讨论</p>
<h1 id="配置commandconfig">配置:CommandConfig<a hidden class="anchor" aria-hidden="true" href="#配置commandconfig">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CommandConfig is used to tune circuit settings at runtime
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CommandConfig</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Timeout</span>                <span class="kt">int</span> <span class="s">`json:&#34;timeout&#34;`</span><span class="c1">// 超时时间定义
</span><span class="c1"></span>	<span class="nx">MaxConcurrentRequests</span>  <span class="kt">int</span> <span class="s">`json:&#34;max_concurrent_requests&#34;`</span><span class="c1">// 最大并发请求数
</span><span class="c1"></span>	<span class="nx">RequestVolumeThreshold</span> <span class="kt">int</span> <span class="s">`json:&#34;request_volume_threshold&#34;`</span><span class="c1">// 跳闸的最小请求数（不健康的断路器）
</span><span class="c1"></span>	<span class="nx">SleepWindow</span>            <span class="kt">int</span> <span class="s">`json:&#34;sleep_window&#34;`</span><span class="c1">// 跳闸之后可以重试的时间
</span><span class="c1"></span>	<span class="nx">ErrorPercentThreshold</span>  <span class="kt">int</span> <span class="s">`json:&#34;error_percent_threshold&#34;`</span><span class="c1">// 请求出错比
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CommandConfig 几个字段的意义：</p>
<ul>
<li>Timeout: 执行command的超时时间。默认时间是1000毫秒</li>
<li>MaxConcurrentRequests：command的最大并发量 默认值是10</li>
<li>SleepWindow：当熔断器被打开后，SleepWindow的时间就是控制过多久后去尝试服务是否可用了。默认值是5000毫秒</li>
<li>RequestVolumeThreshold： 一个统计窗口10秒内请求数量。达到这个请求数量后才去判断是否要开启熔断。默认值是20</li>
<li>ErrorPercentThreshold：错误百分比，请求数量大于等于RequestVolumeThreshold并且错误率到达这个百分比后就会启动熔断 默认值是50</li>
</ul>
<p>RequestVolumeThreshold与ErrorPercentThreshold通常组合使用</p>
<p>当然如果不配置他们，会使用默认值.</p>
<h1 id="断路器circuitbreaker">断路器:CircuitBreaker<a hidden class="anchor" aria-hidden="true" href="#断路器circuitbreaker">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CircuitBreaker is created for each ExecutorPool to track whether requests
</span><span class="c1">// should be attempted, or rejected if the Health of the circuit is too low.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CircuitBreaker</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 断路器-定义
</span><span class="c1"></span>    <span class="nx">Name</span>                   <span class="kt">string</span> <span class="c1">// 名字
</span><span class="c1"></span>    <span class="nx">open</span>                   <span class="kt">bool</span>   <span class="c1">// 开启与否，关闭&#34;open&#34;=true，开启&#34;open&#34; = false
</span><span class="c1"></span>    <span class="nx">forceOpen</span>              <span class="kt">bool</span>   <span class="c1">// 强制开启
</span><span class="c1"></span>    <span class="nx">mutex</span>                  <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// 读写锁（unblock reading, block writer）
</span><span class="c1"></span>    <span class="nx">openedOrLastTestedTime</span> <span class="kt">int64</span> <span class="c1">// 断路器被打开或者最近一次尝试的时间，尝试指断路器打开之后，系统探测是否可以发送请求。
</span><span class="c1"></span>    <span class="nx">executorPool</span> <span class="o">*</span><span class="nx">executorPool</span> <span class="c1">// 执行池
</span><span class="c1"></span>    <span class="nx">metrics</span>      <span class="o">*</span><span class="nx">metricExchange</span> <span class="c1">// 监控断路器
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">circuitBreakersMutex</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// 断路器锁
</span><span class="c1"></span>    <span class="nx">circuitBreakers</span>      <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CircuitBreaker</span> <span class="c1">// 注册断路器，所有的断路器都保存在这里
</span><span class="c1"></span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">circuitBreakersMutex</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{}</span> <span class="c1">// 初始化断路器锁
</span><span class="c1"></span>    <span class="nx">circuitBreakers</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">CircuitBreaker</span><span class="p">)</span> <span class="c1">// 初始化断路器
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>获取断路器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GetCircuit returns the circuit for the given command and whether this call created it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetCircuit</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">CircuitBreaker</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">circuitBreakersMutex</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span> 
    <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">circuitBreakers</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">circuitBreakersMutex</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
        <span class="nx">circuitBreakersMutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="k">defer</span> <span class="nx">circuitBreakersMutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span> <span class="c1">// 注意这里同时加了两次锁且第二把锁是互斥锁，其中一个goroutine hold住并且赋值，锁释放。其他goroutine从内存中获取断路器
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">circuitBreakers</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span> <span class="c1">// double check，防止其他的goroutine修改了全局变量circuitBreakers
</span><span class="c1"></span>            <span class="k">return</span> <span class="nx">cb</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">circuitBreakers</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newCircuitBreaker</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nx">circuitBreakersMutex</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">circuitBreakers</span><span class="p">[</span><span class="nx">name</span><span class="p">],</span> <span class="p">!</span><span class="nx">ok</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="监控metricexchange">监控:metricExchange<a hidden class="anchor" aria-hidden="true" href="#监控metricexchange">#</a></h1>
<p>每一次断路器逻辑的执行都会上报执行过程中的状态:</p>
<p>断路器&ndash;&gt;执行&ndash;&gt;上报执行状态信息&ndash;&gt;保存到相应的Buckets</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191105152430.png" alt=""  />
</p>
<p>代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ReportEvent records command metrics for tracking recent error rates and exposing data to the dashboard.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">circuit</span> <span class="o">*</span><span class="nx">CircuitBreaker</span><span class="p">)</span> <span class="nf">ReportEvent</span><span class="p">(</span><span class="nx">eventTypes</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">start</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">runDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">eventTypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;no event types sent for metrics&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">circuit</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">o</span> <span class="o">:=</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">open</span>
	<span class="nx">circuit</span><span class="p">.</span><span class="nx">mutex</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">eventTypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;success&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">o</span> <span class="p">{</span>
		<span class="nx">circuit</span><span class="p">.</span><span class="nf">setClose</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">concurrencyInUse</span> <span class="kt">float64</span>
	<span class="k">if</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">executorPool</span><span class="p">.</span><span class="nx">Max</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">concurrencyInUse</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">executorPool</span><span class="p">.</span><span class="nf">ActiveCount</span><span class="p">())</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">executorPool</span><span class="p">.</span><span class="nx">Max</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">metrics</span><span class="p">.</span><span class="nx">Updates</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">commandExecution</span><span class="p">{</span>
		<span class="nx">Types</span><span class="p">:</span>            <span class="nx">eventTypes</span><span class="p">,</span>
		<span class="nx">Start</span><span class="p">:</span>            <span class="nx">start</span><span class="p">,</span>
		<span class="nx">RunDuration</span><span class="p">:</span>      <span class="nx">runDuration</span><span class="p">,</span>
		<span class="nx">ConcurrencyInUse</span><span class="p">:</span> <span class="nx">concurrencyInUse</span><span class="p">,</span>
	<span class="p">}:</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">CircuitError</span><span class="p">{</span><span class="nx">Message</span><span class="p">:</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;metrics channel (%v) is at capacity&#34;</span><span class="p">,</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">Name</span><span class="p">)}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>circuit.metrics.Updates 这个信道就是处理上报信息的，上报执行状态信息的结构是metricExchange，结构体很简单只有4个字段:</p>
<ul>
<li>Updates:有buffer的commandExecution通道,默认的数量是2000个,所有的状态信息都在他里面</li>
<li>metricCollectors:保存的具体的这个command执行过程中的各种信息</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">metricExchange</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span>    <span class="kt">string</span>
    <span class="nx">Updates</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">commandExecution</span>
    <span class="nx">Mutex</span>   <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>

    <span class="nx">metricCollectors</span> <span class="p">[]</span><span class="nx">metricCollector</span><span class="p">.</span><span class="nx">MetricCollector</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">commandExecution</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Types</span>            <span class="p">[]</span><span class="kt">string</span>      <span class="s">`json:&#34;types&#34;`</span>
    <span class="nx">Start</span>            <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>     <span class="s">`json:&#34;start_time&#34;`</span>
    <span class="nx">RunDuration</span>      <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="s">`json:&#34;run_duration&#34;`</span>
    <span class="nx">ConcurrencyInUse</span> <span class="kt">float64</span>       <span class="s">`json:&#34;concurrency_inuse&#34;`</span>
<span class="p">}</span>


</code></pre></td></tr></table>
</div>
</div><p>在执行newMetricExchange的时候会启动一个协程 go m.Monitor()去监控Updates的数据，然后上报给metricCollectors 保存执行的信息数据比如前面提到的调用次数，失败次数，被拒绝次数等等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">newMetricExchange</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">metricExchange</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">metricExchange</span><span class="p">{}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="nx">name</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">Updates</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">commandExecution</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Mutex</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">metricCollectors</span> <span class="p">=</span> <span class="nx">metricCollector</span><span class="p">.</span><span class="nx">Registry</span><span class="p">.</span><span class="nf">InitializeMetricCollectors</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>

    <span class="k">go</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Monitor</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">metricExchange</span><span class="p">)</span> <span class="nf">Monitor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">update</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Updates</span> <span class="p">{</span>
        <span class="c1">// we only grab a read lock to make sure Reset() isn&#39;t changing the numbers.
</span><span class="c1"></span>        <span class="nx">m</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>

        <span class="nx">totalDuration</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">Start</span><span class="p">)</span>
        <span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">collector</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nx">metricCollectors</span> <span class="p">{</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">go</span> <span class="nx">m</span><span class="p">.</span><span class="nf">IncrementMetrics</span><span class="p">(</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">collector</span><span class="p">,</span> <span class="nx">update</span><span class="p">,</span> <span class="nx">totalDuration</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>

        <span class="nx">m</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>更新调用的是go m.IncrementMetrics(wg, collector, update, totalDuration)，里面判断了他的状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">metricExchange</span><span class="p">)</span> <span class="nf">IncrementMetrics</span><span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">collector</span> <span class="nx">metricCollector</span><span class="p">.</span><span class="nx">MetricCollector</span><span class="p">,</span> <span class="nx">update</span> <span class="o">*</span><span class="nx">commandExecution</span><span class="p">,</span> <span class="nx">totalDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// granular metrics
</span><span class="c1"></span>    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">metricCollector</span><span class="p">.</span><span class="nx">MetricResult</span><span class="p">{</span>
        <span class="nx">Attempts</span><span class="p">:</span>         <span class="mi">1</span><span class="p">,</span>
        <span class="nx">TotalDuration</span><span class="p">:</span>    <span class="nx">totalDuration</span><span class="p">,</span>
        <span class="nx">RunDuration</span><span class="p">:</span>      <span class="nx">update</span><span class="p">.</span><span class="nx">RunDuration</span><span class="p">,</span>
        <span class="nx">ConcurrencyInUse</span><span class="p">:</span> <span class="nx">update</span><span class="p">.</span><span class="nx">ConcurrencyInUse</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">update</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">&#34;success&#34;</span><span class="p">:</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Successes</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="s">&#34;failure&#34;</span><span class="p">:</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Failures</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="s">&#34;rejected&#34;</span><span class="p">:</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Rejects</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">collector</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="底层控制器metriccollector">底层控制器:MetricCollector<a hidden class="anchor" aria-hidden="true" href="#底层控制器metriccollector">#</a></h1>
<p>每一个Command都会有一个默认统计控制器，当然也可以添加多个自定义的控制器。</p>
<p>默认的统计控制器DefaultMetricCollector保存着熔断器的所有状态，调用次数，失败次数，被拒绝次数等等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DefaultMetricCollector holds information about the circuit state.
</span><span class="c1">// This implementation of MetricCollector is the canonical source of information about the circuit.
</span><span class="c1">// It is used for for all internal hystrix operations
</span><span class="c1">// including circuit health checks and metrics sent to the hystrix dashboard.
</span><span class="c1">//
</span><span class="c1">// Metric Collectors do not need Mutexes as they are updated by circuits within a locked context.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DefaultMetricCollector</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mutex</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>

	<span class="nx">numRequests</span> <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">errors</span>      <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>

	<span class="nx">successes</span>               <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">failures</span>                <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">rejects</span>                 <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">shortCircuits</span>           <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">timeouts</span>                <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">contextCanceled</span>         <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">contextDeadlineExceeded</span> <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>

	<span class="nx">fallbackSuccesses</span> <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">fallbackFailures</span>  <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">totalDuration</span>     <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Timing</span>
	<span class="nx">runDuration</span>       <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Timing</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最主要的还是要看一下rolling.Number，rolling.Number才是状态最终保存的地方</p>
<p>Number保存了10秒内的Buckets数据信息，每一个Bucket的统计时长为1秒</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191105152012.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Number tracks a numberBucket over a bounded number of
</span><span class="c1">// time buckets. Currently the buckets are one second long and only the last 10 seconds are kept.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Number</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="o">*</span><span class="nx">numberBucket</span>
	<span class="nx">Mutex</span>   <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">numberBucket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Value</span> <span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>字典字段Buckets map[int64]*numberBucket 中的Key保存的是当前时间</p>
<p>可能你会好奇Number是如何保证只保存10秒内的数据的。每一次对熔断器的状态进行修改时，Number都要先得到当前的时间(秒级)的Bucket不存在则创建。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Number</span><span class="p">)</span> <span class="nf">getCurrentBucket</span><span class="p">()</span> <span class="o">*</span><span class="nx">numberBucket</span> <span class="p">{</span>
    <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">bucket</span> <span class="o">*</span><span class="nx">numberBucket</span>
    <span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>

    <span class="k">if</span> <span class="nx">bucket</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">now</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">bucket</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">numberBucket</span><span class="p">{}</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">now</span><span class="p">]</span> <span class="p">=</span> <span class="nx">bucket</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">bucket</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>修改完后去掉10秒外的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Number</span><span class="p">)</span> <span class="nf">removeOldBuckets</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span> <span class="o">-</span> <span class="mi">10</span>

    <span class="k">for</span> <span class="nx">timestamp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Buckets</span> <span class="p">{</span>
        <span class="c1">// TODO: configurable rolling window
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">timestamp</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
            <span class="nb">delete</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">,</span> <span class="nx">timestamp</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>比如Increment方法，先得到Bucket再删除旧的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Number</span><span class="p">)</span> <span class="nf">Increment</span><span class="p">(</span><span class="nx">i</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">r</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">getCurrentBucket</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="nx">r</span><span class="p">.</span><span class="nf">removeOldBuckets</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>统计控制器是最基层和最重要的一个实现，上层所有的执行判断都是基于他的数据进行逻辑处理的</p>
<h1 id="执行池executorpool">执行池:executorPool<a hidden class="anchor" aria-hidden="true" href="#执行池executorpool">#</a></h1>
<p>hystrix-go对流量控制的代码是很简单的。用了一个简单的令牌算法，能得到令牌的就可以执行后继的工作，执行完后要返还令牌。得不到令牌就拒绝，拒绝后调用用户设置的callback方法，如果没有设置就不执行。</p>
<p>结构体executorPool就是hystrix-go执行池的具体实现。字段Max就是每秒最大的并发值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">executorPool</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 执行池
</span><span class="c1"></span>    <span class="nx">Name</span>    <span class="kt">string</span>  <span class="c1">// 名字
</span><span class="c1"></span>    <span class="nx">Metrics</span> <span class="o">*</span><span class="nx">poolMetrics</span> <span class="c1">// 执行池监控
</span><span class="c1"></span>    <span class="nx">Max</span>     <span class="kt">int</span> <span class="c1">// 最大的并发请求数量
</span><span class="c1"></span>    <span class="nx">Tickets</span> <span class="kd">chan</span> <span class="o">*</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// 票证
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在创建executorPool的时候，会根据Max值来创建令牌。Max值如果没有设置会使用默认值10</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//开启新的执行池
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newExecutorPool</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">executorPool</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">executorPool</span><span class="p">{}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="nx">name</span><span class="c1">//名字
</span><span class="c1"></span>    <span class="nx">p</span><span class="p">.</span><span class="nx">Metrics</span> <span class="p">=</span> <span class="nf">newPoolMetrics</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Max</span> <span class="p">=</span> <span class="nf">getSettings</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nx">MaxConcurrentRequests</span><span class="c1">// 从配置中获取最大的并发请求数量，如果配置中没有，则从默认配置中获取
</span><span class="c1"></span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Tickets</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="kd">struct</span><span class="p">{},</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Max</span><span class="p">)</span><span class="c1">// 初始化buffer chan
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Max</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">Tickets</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="kd">struct</span><span class="p">{}{}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
<span class="c1">//上报状态
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">executorPool</span><span class="p">)</span> <span class="nf">Return</span><span class="p">(</span><span class="nx">ticket</span> <span class="o">*</span><span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">ticket</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Metrics</span><span class="p">.</span><span class="nx">Updates</span> <span class="o">&lt;-</span> <span class="nx">poolMetricsUpdate</span><span class="p">{</span>
        <span class="nx">activeCount</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ActiveCount</span><span class="p">(),</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Tickets</span> <span class="o">&lt;-</span> <span class="nx">ticket</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">executorPool</span><span class="p">)</span> <span class="nf">ActiveCount</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Max</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Tickets</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意一下字段 Metrics 他用于统计执行数量，比如：执行的总数量,最大的并发数.这个数量也可以显露出，供可视化程序直观的表现出来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolMetrics</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Mutex</span>   <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">Updates</span> <span class="kd">chan</span> <span class="nx">poolMetricsUpdate</span>

	<span class="nx">Name</span>              <span class="kt">string</span>
	<span class="nx">MaxActiveRequests</span> <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
	<span class="nx">Executed</span>          <span class="o">*</span><span class="nx">rolling</span><span class="p">.</span><span class="nx">Number</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">poolMetricsUpdate</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">activeCount</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>令牌使用完后是需要返还的，返回的时候才会做上面所说的统计工作。</p>
<h1 id="执行实体goc">执行实体:GoC<a hidden class="anchor" aria-hidden="true" href="#执行实体goc">#</a></h1>
<p>hystrix在执行一次command会调用GoC方法，就是在判断断路器是否已打开，得到Ticket得不到就限流，执行我们自己的的方法，判断context是否Done或者执行是否超时.每次执行结果都要上报执行状态,最后要返还Ticket</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GoC runs your function while tracking the health of previous calls to it.
</span><span class="c1">// If your function begins slowing down or failing repeatedly, we will block
</span><span class="c1">// new calls to it for you to give the dependent service time to repair.
</span><span class="c1">//
</span><span class="c1">// Define a fallback function if you want to define some code to execute during outages.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GoC</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">run</span> <span class="nx">runFuncC</span><span class="p">,</span> <span class="nx">fallback</span> <span class="nx">fallbackFuncC</span><span class="p">)</span> <span class="kd">chan</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cmd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">command</span><span class="p">{</span><span class="c1">// command执行者
</span><span class="c1"></span>		<span class="nx">run</span><span class="p">:</span>      <span class="nx">run</span><span class="p">,</span> <span class="c1">//run
</span><span class="c1"></span>		<span class="nx">fallback</span><span class="p">:</span> <span class="nx">fallback</span><span class="p">,</span><span class="c1">//fallback
</span><span class="c1"></span>		<span class="nx">start</span><span class="p">:</span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span> <span class="c1">//开始时间
</span><span class="c1"></span>		<span class="nx">errChan</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">//错误
</span><span class="c1"></span>		<span class="nx">finished</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">//是否完成
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// dont have methods with explicit params and returns
</span><span class="c1"></span>	<span class="c1">// let data come in and out naturally, like with any closure
</span><span class="c1"></span>	<span class="c1">// explicit error return to give place for us to kill switch the operation (fallback)
</span><span class="c1"></span>    <span class="c1">//得到断路器,不存在则创建
</span><span class="c1"></span>	<span class="nx">circuit</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetCircuit</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cmd</span><span class="p">.</span><span class="nx">errChan</span> <span class="o">&lt;-</span> <span class="nx">err</span>
		<span class="k">return</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">errChan</span>
	<span class="p">}</span>
	<span class="nx">cmd</span><span class="p">.</span><span class="nx">circuit</span> <span class="p">=</span> <span class="nx">circuit</span>
	<span class="nx">ticketCond</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="nx">cmd</span><span class="p">)</span><span class="c1">// cond条件
</span><span class="c1"></span>	<span class="nx">ticketChecked</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="c1">// When the caller extracts error from returned errChan, it&#39;s assumed that
</span><span class="c1"></span>	<span class="c1">// the ticket&#39;s been returned to executorPool. Therefore, returnTicket() can
</span><span class="c1"></span>    <span class="c1">// not run after cmd.errorWithFallback().
</span><span class="c1"></span>    <span class="c1">// 返还ticket
</span><span class="c1"></span>	<span class="nx">returnTicket</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">cmd</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// Avoid releasing before a ticket is acquired.
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">!</span><span class="nx">ticketChecked</span> <span class="p">{</span>
			<span class="nx">ticketCond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span><span class="c1">// 相当于select{}
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="nx">cmd</span><span class="p">.</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">executorPool</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">ticket</span><span class="p">)</span><span class="c1">// 将ticket放回池子中
</span><span class="c1"></span>		<span class="nx">cmd</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// Shared by the following two goroutines. It ensures only the faster
</span><span class="c1"></span>    <span class="c1">// goroutine runs errWithFallback() and reportAllEvent().
</span><span class="c1"></span>    <span class="c1">// 上报执行状态
</span><span class="c1"></span>	<span class="nx">returnOnce</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">{}</span><span class="c1">// 确保被multi goroutine执行一次
</span><span class="c1"></span>	<span class="nx">reportAllEvent</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="c1">// events采集，后续dashboard使用
</span><span class="c1"></span>		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">circuit</span><span class="p">.</span><span class="nf">ReportEvent</span><span class="p">(</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">events</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">start</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">runDuration</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// g1, 检测断路器不允许通过，尝试fallback，将中途遇到的event上报。
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">finished</span> <span class="o">&lt;-</span> <span class="kc">true</span> <span class="p">}()</span>

		<span class="c1">// Circuits get opened when recent executions have shown to have a high error rate.
</span><span class="c1"></span>		<span class="c1">// Rejecting new executions allows backends to recover, and the circuit will allow
</span><span class="c1"></span>        <span class="c1">// new traffic when it feels a healthly state has returned.
</span><span class="c1"></span>        <span class="c1">// 查看断路器是否已打开
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">circuit</span><span class="p">.</span><span class="nf">AllowRequest</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">cmd</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="c1">// It&#39;s safe for another goroutine to go ahead releasing a nil ticket.
</span><span class="c1"></span>			<span class="nx">ticketChecked</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">ticketCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
			<span class="nx">cmd</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">returnOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">returnTicket</span><span class="p">()</span>
				<span class="nx">cmd</span><span class="p">.</span><span class="nf">errorWithFallback</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ErrCircuitOpen</span><span class="p">)</span>
				<span class="nf">reportAllEvent</span><span class="p">()</span>
			<span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// As backends falter, requests take longer but don&#39;t always fail.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// When requests slow down but the incoming rate of requests stays the same, you have to
</span><span class="c1"></span>		<span class="c1">// run more at a time to keep up. By controlling concurrency during these situations, you can
</span><span class="c1"></span>		<span class="c1">// shed load which accumulates due to the increasing ratio of active commands to incoming requests.
</span><span class="c1"></span>        <span class="nx">cmd</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="c1">// 获取ticket 如果得不到就限流
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">ticket</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">executorPool</span><span class="p">.</span><span class="nx">Tickets</span><span class="p">:</span><span class="c1">// 从池子中取出ticket
</span><span class="c1"></span>			<span class="nx">ticketChecked</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">ticketCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span><span class="c1">// 通知cond.Wait()
</span><span class="c1"></span>			<span class="nx">cmd</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">ticketChecked</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">ticketCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
			<span class="nx">cmd</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">returnOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">returnTicket</span><span class="p">()</span>
				<span class="nx">cmd</span><span class="p">.</span><span class="nf">errorWithFallback</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ErrMaxConcurrency</span><span class="p">)</span><span class="c1">// 并发过高
</span><span class="c1"></span>				<span class="nf">reportAllEvent</span><span class="p">()</span>
			<span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">// 执行我们自已的方法，并上报执行信息
</span><span class="c1"></span>		<span class="nx">runStart</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
        <span class="nx">runErr</span> <span class="o">:=</span> <span class="nf">run</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="nx">returnOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nf">reportAllEvent</span><span class="p">()</span>
			<span class="nx">cmd</span><span class="p">.</span><span class="nx">runDuration</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">runStart</span><span class="p">)</span><span class="c1">// 运行时间
</span><span class="c1"></span>			<span class="nf">returnTicket</span><span class="p">()</span><span class="c1">// 把ticket返回去
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">runErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">cmd</span><span class="p">.</span><span class="nf">errorWithFallback</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">runErr</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">cmd</span><span class="p">.</span><span class="nf">reportEvent</span><span class="p">(</span><span class="s">&#34;success&#34;</span><span class="p">)</span><span class="c1">// 执行成功
</span><span class="c1"></span>		<span class="p">})</span>
	<span class="p">}()</span>
    <span class="c1">// 等待context是否被结束，或执行者超时，并上报
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nf">getSettings</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nx">Timeout</span><span class="p">)</span>
		<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">finished</span><span class="p">:</span><span class="c1">// 结束select
</span><span class="c1"></span>			<span class="c1">// returnOnce has been executed in another goroutine
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span><span class="c1">// 处理ctx错误
</span><span class="c1"></span>			<span class="nx">returnOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">returnTicket</span><span class="p">()</span>
				<span class="nx">cmd</span><span class="p">.</span><span class="nf">errorWithFallback</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
				<span class="nf">reportAllEvent</span><span class="p">()</span>
			<span class="p">})</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span><span class="c1">// 处理超时
</span><span class="c1"></span>			<span class="nx">returnOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">returnTicket</span><span class="p">()</span>
				<span class="nx">cmd</span><span class="p">.</span><span class="nf">errorWithFallback</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ErrTimeout</span><span class="p">)</span>
				<span class="nf">reportAllEvent</span><span class="p">()</span>
			<span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">return</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">errChan</span><span class="c1">// 错误返回至上层
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="可视化streamhandler">可视化:StreamHandler<a hidden class="anchor" aria-hidden="true" href="#可视化streamhandler">#</a></h1>
<p>代码中StreamHandler就是把所有断路器的状态以流的方式不断的推送到dashboard. 这部分代码我就不用说了，很简单。</p>
<p>需要在你的服务端加3行代码，启动我们的流服务:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">hystrixStreamHandler</span> <span class="o">:=</span> <span class="nx">hystrix</span><span class="p">.</span><span class="nf">NewStreamHandler</span><span class="p">()</span>
<span class="nx">hystrixStreamHandler</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
<span class="k">go</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nf">JoinHostPort</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;81&#34;</span><span class="p">),</span> <span class="nx">hystrixStreamHandler</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是集群可以使用Turbine进行监控</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191105153440.png" alt=""  />
</p>
<p>参考:<br>
<a href="https://www.cnblogs.com/li-peng/p/11050563.html">https://www.cnblogs.com/li-peng/p/11050563.html</a><br>
<a href="https://www.zybuluo.com/aliasliyu4/note/1248898">https://www.zybuluo.com/aliasliyu4/note/1248898</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/hystrix/">hystrix</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
