<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>http包解析 | Forz Blog</title>
<meta name="keywords" content="Go标准库使用" />
<meta name="description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent">
<meta name="author" content="">
<link rel="canonical" href="/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="http包解析" />
<meta property="og:description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:28:57&#43;00:00" />
<meta property="article:modified_time" content="2018-11-15T18:28:57&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="http包解析"/>
<meta name="twitter:description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "http包解析",
      "item": "/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "http包解析",
  "name": "http包解析",
  "description": "预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent",
  "keywords": [
    "Go标准库使用"
  ],
  "articleBody": "预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent = 205 StatusPartialContent = 206 StatusMultipleChoices = 300 StatusMovedPermanently = 301 StatusFound = 302 StatusSeeOther = 303 StatusNotModified = 304 StatusUseProxy = 305 StatusTemporaryRedirect = 307 StatusBadRequest = 400 StatusUnauthorized = 401 StatusPaymentRequired = 402 StatusForbidden = 403 StatusNotFound = 404 StatusMethodNotAllowed = 405 StatusNotAcceptable = 406 StatusProxyAuthRequired = 407 StatusRequestTimeout = 408 StatusConflict = 409 StatusGone = 410 StatusLengthRequired = 411 StatusPreconditionFailed = 412 StatusRequestEntityTooLarge = 413 StatusRequestURITooLong = 414 StatusUnsupportedMediaType = 415 StatusRequestedRangeNotSatisfiable = 416 StatusExpectationFailed = 417 StatusTeapot = 418 StatusInternalServerError = 500 StatusNotImplemented = 501 StatusBadGateway = 502 StatusServiceUnavailable = 503 StatusGatewayTimeout = 504 StatusHTTPVersionNotSupported = 505 )   const DefaultMaxHeaderBytes = 1  DefaultMaxHeaderBytes是HTTP请求的头域最大允许长度。可以通过设置Server.MaxHeaderBytes字段来覆盖。\nconst DefaultMaxIdleConnsPerHost = 2  DefaultMaxIdleConnsPerHost是Transport的MaxIdleConnsPerHost的默认值。\nconst TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\"  TimeFormat是当解析或生产HTTP头域中的时间时，用与time.Parse或time.Format函数的时间格式。这种格式类似time.RFC1123但强制采用GMT时区。\nVariables 1 2 3 4 5 6 7 8 9  var ( ErrHeaderTooLong = \u0026ProtocolError{\"header too long\"} ErrShortBody = \u0026ProtocolError{\"entity body too short\"} ErrNotSupported = \u0026ProtocolError{\"feature not supported\"} ErrUnexpectedTrailer = \u0026ProtocolError{\"trailer header without chunked transfer encoding\"} ErrMissingContentLength = \u0026ProtocolError{\"missing ContentLength in HEAD response\"} ErrNotMultipart = \u0026ProtocolError{\"request Content-Type isn't multipart/form-data\"} ErrMissingBoundary = \u0026ProtocolError{\"no multipart boundary param in Content-Type\"} )   HTTP请求的解析错误。\n1 2 3 4 5 6  var ( ErrWriteAfterFlush = errors.New(\"Conn.Write called after Flush\") ErrBodyNotAllowed = errors.New(\"http: request method or response status code does not allow body\") ErrHijacked = errors.New(\"Conn has been hijacked\") ErrContentLength = errors.New(\"Conn.Write wrote more than the declared Content-Length\") )   会被HTTP服务端返回的错误。\nvar DefaultClient = \u0026Client{}  DefaultClient是用于包函数Get、Head和Post的默认Client。\nvar DefaultServeMux = NewServeMux()  DefaultServeMux是用于Serve的默认ServeMux。\nvar ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")  在Resquest或Response的Body字段已经关闭后，试图从中读取时，就会返回ErrBodyReadAfterClose。这个错误一般发生在：HTTP处理器中调用完ResponseWriter 接口的WriteHeader或Write后从请求中读取数据的时候。\nvar ErrHandlerTimeout = errors.New(\"http: Handler timeout\")  在处理器超时以后调用ResponseWriter接口的Write方法，就会返回ErrHandlerTimeout。\nvar ErrLineTooLong = errors.New(\"header line too long\") var ErrMissingFile = errors.New(\"http: no such file\")  当请求中没有提供给FormFile函数的文件字段名，或者该字段名不是文件字段时，该函数就会返回ErrMissingFile。\nvar ErrNoCookie = errors.New(\"http: named cookie not present\") var ErrNoLocation = errors.New(\"http: no Location header in response\")  type ProtocolError type ProtocolError struct { ErrorString string }\nHTTP请求解析错误。\nfunc (*ProtocolError) Error func (err *ProtocolError) Error() string  func CanonicalHeaderKey func CanonicalHeaderKey(s string) string  CanonicalHeaderKey函数返回头域（表示为Header类型）的键s的规范化格式。规范化过程中让单词首字母和'-‘后的第一个字母大写，其余字母小写。例如，“accept-encoding\"规范化为\"Accept-Encoding”。\nfunc DetectContentType func DetectContentType(data []byte) string  DetectContentType函数实现了http://mimesniff.spec.whatwg.org/描述的算法，用于确定数据的Content-Type。函数总是返回一个合法的MIME类型；如果它不能确定数据的类型，将返回\"application/octet-stream\"。它最多检查数据的前512字节。\nfunc ParseHTTPVersion func ParseHTTPVersion(vers string) (major, minor int, ok bool)  ParseHTTPVersion解析HTTP版本字符串。如\"HTTP/1.0\"返回(1, 0, true)。\nfunc ParseTime func ParseTime(text string) (t time.Time, err error)  ParseTime用3种格式TimeFormat,\ntime.RFC850和time.ANSIC尝试解析一个时间头的值（如Date: header）。\nfunc StatusText func StatusText(code int) string StatusText返回HTTP状态码code对应的文本，如220对应\"OK\"。如果code是未知的状态码，会返回\"\"。\ntype ConnState type ConnState int  ConnState代表一个客户端到服务端的连接的状态。本类型用于可选的Server.ConnState回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const ( // StateNew代表一个新的连接，将要立刻发送请求。  // 连接从这个状态开始，然后转变为StateAlive或StateClosed。  StateNew ConnState = iota // StateActive代表一个已经读取了请求数据1到多个字节的连接。  // 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，  // 等到请求被处理完后，Server.ConnState回调函数再次被触发。  // 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。  StateActive // StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。  // 连接状态可以从StateIdle改变为StateActive或StateClosed。  StateIdle // 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。  StateHijacked // StateClosed代表一个关闭的连接。  // 这是一个终止状态。被劫持的连接不会转变为StateClosed。  StateClosed )   func (ConnState) String func (c ConnState) String() string  type Header type Header map[string][]string  Header代表HTTP头域的键值对。\nfunc (Header) Get func (h Header) Get(key string) string  Get返回键对应的第一个值，如果键不存在会返回\"\"。如要获取该键对应的值切片，请直接用规范格式的键访问map。\nfunc (Header) Set func (h Header) Set(key, value string)  Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。\nfunc (Header) Add func (h Header) Add(key, value string)  Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。\nfunc (Header) Del func (h Header) Del(key string)  Del删除键值对。\nfunc (Header) Write func (h Header) Write(w io.Writer) error  Write以有线格式将头域写入w。\nfunc (Header) WriteSubset func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error  WriteSubset以有线格式将头域写入w。当exclude不为nil时，如果h的键值对的键在exclude中存在且其对应值为真，该键值对就不会被写入w。\ntype Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  type Response struct { Status string // 例如\"200 OK\"  StatusCode int // 例如200  Proto string // 例如\"HTTP/1.0\"  ProtoMajor int // 例如1  ProtoMinor int // 例如0  // Header保管头域的键值对。  // 如果回复中有多个头的键相同，Header中保存为该键对应用逗号分隔串联起来的这些头的值  // （参见RFC 2616 Section 4.2）  // 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。  //  // Header中的键都是规范化的，参见CanonicalHeaderKey函数  Header Header // Body代表回复的主体。  // Client类型和Transport类型会保证Body字段总是非nil的，即使回复没有主体或主体长度为0。  // 关闭主体是调用者的责任。  // 如果服务端采用\"chunked\"传输编码发送的回复，Body字段会自动进行解码。  Body io.ReadCloser // ContentLength记录相关内容的长度。  // 其值为-1表示长度未知（采用chunked传输编码）  // 除非对应的Request.Method是\"HEAD\"，其值=0表示可以从Body读取的字节数  ContentLength int64 // TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示\"identity\"编码。  TransferEncoding []string // Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）  // 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。  Close bool // Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型  Trailer Header // Request是用来获取此回复的请求  // Request的Body字段是nil（因为已经被用掉了）  // 这个字段是被Client类型发出请求并获得回复后填充的  Request *Request // TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。  // 返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。  TLS *tls.ConnectionState }   Response代表一个HTTP请求的回复。\nfunc ReadResponse func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)  ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的trailer的键值对。（本函数主要用在客户端从下层获取回复）\nfunc (*Response) ProtoAtLeast func (r *Response) ProtoAtLeast(major, minor int) bool  ProtoAtLeast报告该回复使用的HTTP协议版本至少是major.minor。\nfunc (*Response) Cookies func (r *Response) Cookies() []*Cookie  Cookies解析并返回该回复中的Set-Cookie头设置的cookie。\nfunc (*Response) Location func (r *Response) Location() (*url.URL, error)  Location返回该回复的Location头设置的URL。相对地址的重定向会相对于该回复对应的请求来确定绝对地址。如果回复中没有Location头，会返回nil, ErrNoLocation。\nfunc (*Response) Write func (r *Response) Write(w io.Writer) error  Write以有线格式将回复写入w（用于将回复写入下层TCPConn等）。本方法会考虑如下字段：\nStatusCode ProtoMajor ProtoMinor Request.Method TransferEncoding Trailer Body ContentLength Header（不规范的键名和它对应的值会导致不可预知的行为）  Body字段在发送完回复后会被关闭。\ntype ResponseWriter 1 2 3 4 5 6 7 8 9 10 11 12 13 14  type ResponseWriter interface { // Header返回一个Header类型值，该值会被WriteHeader方法发送。  // 在调用WriteHeader或Write方法后再改变该对象是没有意义的。  Header() Header // WriteHeader该方法发送HTTP回复的头域和状态码。  // 如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)  // WriterHeader的显式调用主要用于发送错误码。  WriteHeader(int) // Write向连接中写入作为HTTP的一部分回复的数据。  // 如果被调用时还未调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)  // 如果Header中没有\"Content-Type\"键，  // 本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。  Write([]byte) (int, error) }   ResponseWriter接口被HTTP处理器用于构造HTTP回复。\ntype Flusher 1 2 3 4  type Flusher interface { // Flush将缓冲中的所有数据发送到客户端  Flush() }   HTTP处理器ResponseWriter接口参数的下层如果实现了Flusher接口，可以让HTTP处理器将缓冲中的数据发送到客户端。\n注意：即使ResponseWriter接口的下层支持Flush方法，如果客户端是通过HTTP代理连接的，缓冲中的数据也可能直到回复完毕才被传输到客户端。\ntype CloseNotifier 1 2 3 4  type CloseNotifier interface { // CloseNotify返回一个通道，该通道会在客户端连接丢失时接收到唯一的值  CloseNotify() chan bool }   HTTP处理器ResponseWriter接口参数的下层如果实现了CloseNotifier接口，可以让用户检测下层的连接是否停止。如果客户端在回复准备好之前关闭了连接，该机制可以用于取消服务端耗时较长的操作。\ntype Hijacker 1 2 3 4 5 6  type Hijacker interface { // Hijack让调用者接管连接，返回连接和关联到该连接的一个缓冲读写器。  // 调用本方法后，HTTP服务端将不再对连接进行任何操作，  // 调用者有责任管理、关闭返回的连接。  Hijack() (net.Conn, *bufio.ReadWriter, error) }   HTTP处理器ResponseWriter接口参数的下层如果实现了Hijacker接口，可以让HTTP处理器接管该连接。\ntype RoundTripper 1 2 3 4 5 6 7 8 9 10 11 12  type RoundTripper interface { // RoundTrip执行单次HTTP事务，接收并发挥请求req的回复。  // RoundTrip不应试图解析/修改得到的回复。  // 尤其要注意，只要RoundTrip获得了一个回复，不管该回复的HTTP状态码如何，  // 它必须将返回值err设置为nil。  // 非nil的返回值err应该留给获取回复失败的情况。  // 类似的，RoundTrip不能试图管理高层次的细节，如重定向、认证、cookie。  //  // 除了从请求的主体读取并关闭主体之外，RoundTrip不应修改请求，包括（请求的）错误。  // RoundTrip函数接收的请求的URL和Header字段可以保证是（被）初始化了的。  RoundTrip(*Request) (*Response, error) }   RoundTripper接口是具有执行单次HTTP事务的能力（接收指定请求的回复）的接口。\nRoundTripper接口的类型必须可以安全的被多线程同时使用。\ntype Transport 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  type Transport struct { // Proxy指定一个对给定请求返回代理的函数。  // 如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。  // 如果Proxy为nil或返回nil的*URL置，将不使用代理。  Proxy func(*Request) (*url.URL, error) // Dial指定创建TCP连接的拨号函数。如果Dial为nil，会使用net.Dial。  Dial func(network, addr string) (net.Conn, error) // TLSClientConfig指定用于tls.Client的TLS配置信息。  // 如果该字段为nil，会使用默认的配置信息。  TLSClientConfig *tls.Config // TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。  TLSHandshakeTimeout time.Duration // 如果DisableKeepAlives为真，会禁止不同HTTP请求之间TCP连接的重用。  DisableKeepAlives bool // 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，  // 主动添加\"Accept-Encoding: gzip\"头，以获取压缩数据。  // 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。  // 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。  DisableCompression bool // 如果MaxIdleConnsPerHost!=0，会控制每个主机下的最大闲置连接。  // 如果MaxIdleConnsPerHost==0，会使用DefaultMaxIdleConnsPerHost。  MaxIdleConnsPerHost int // ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，  // 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。  // 该时间不包括获取回复主体的时间。  ResponseHeaderTimeout time.Duration // 内含隐藏或非导出字段 }   Transport类型实现了RoundTripper接口，支持http、https和http/https代理。Transport类型可以缓存连接以在未来重用。\n1 2 3 4 5 6 7 8  var DefaultTransport RoundTripper = \u0026Transport{ Proxy: ProxyFromEnvironment, Dial: (\u0026net.Dialer{ Timeout: 30 * time.Second, KeepAlive: 30 * time.Second, }).Dial, TLSHandshakeTimeout: 10 * time.Second, }   DefaultTransport是被包变量DefaultClient使用的默认RoundTripper接口。它会根据需要创建网络连接，并缓存以便在之后的请求中重用这些连接。它使用环境变量$HTTP_PROXY和$NO_PROXY（或$http_proxy和$no_proxy）指定的HTTP代理。\nfunc (*Transport) RegisterProtocol func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)  RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。\nRegisterProtocol可以被其他包用于提供\"ftp\"或\"file\"等协议的实现。\nfunc (*Transport) RoundTrip func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)  RoundTrip方法实现了RoundTripper接口。\n高层次的HTTP客户端支持（如管理cookie和重定向）请参见Get、Post等函数和Client类型。\nfunc (*Transport) CloseIdleConnections func (t *Transport) CloseIdleConnections()  CloseIdleConnections关闭所有之前的请求建立但目前处于闲置状态的连接。本方法不会中断正在使用的连接。\nfunc (*Transport) CancelRequest func (t *Transport) CancelRequest(req *Request)  CancelRequest通过关闭请求所在的连接取消一个执行中的请求。\ntype Request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  type Request struct { // Method指定HTTP方法（GET、POST、PUT等）。对客户端，\"\"代表GET。  Method string // URL在服务端表示被请求的URI，在客户端表示要访问的URL。  //  // 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，  // 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。  // （参见RFC 2616, Section 5.1.2）  //  // 在客户端，URL的Host字段指定了要连接的服务器，  // 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。  URL *url.URL // 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1  Proto string // \"HTTP/1.0\"  ProtoMajor int // 1  ProtoMinor int // 0  // Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：  //\taccept-encoding: gzip, deflate  //\tAccept-Language: en-us  //\tConnection: keep-alive  // 则：  //\tHeader = map[string][]string{  //\t\"Accept-Encoding\": {\"gzip, deflate\"},  //\t\"Accept-Language\": {\"en-us\"},  //\t\"Connection\": {\"keep-alive\"},  //\t}  // HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。  // 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。  Header Header // Body是请求的主体。  //  // 在客户端，如果Body是nil表示该请求没有主体买入GET请求。  // Client的Transport字段会负责调用Body的Close方法。  //  // 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。  // Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。  Body io.ReadCloser // ContentLength记录相关内容的长度。  // 如果为-1，表示长度未知，如果=0，表示可以从Body字段读取ContentLength字节数据。  // 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。  ContentLength int64 // TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示\"identity\"编码。  // 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除\"chunked\"传输编码。  TransferEncoding []string // Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。  Close bool // 在服务端，Host指定URL会在其上寻找资源的主机。  // 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。  // Host的格式可以是\"host:port\"。  //  // 在客户端，请求的Host字段（可选地）用来重写请求的Host头。  // 如过该字段为\"\"，Request.Write方法会使用URL字段的Host。  Host string // Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。  // 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。  Form url.Values // PostForm是解析好的POST或PUT的表单数据。  // 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。  PostForm url.Values // MultipartForm是解析好的多部件表单，包括上传的文件。  // 本字段只有在调用ParseMultipartForm后才有效。  // 在客户端，会忽略请求中的本字段而使用Body替代。  MultipartForm *multipart.Form // Trailer指定了会在请求主体之后发送的额外的头域。  //  // 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。  // （客户端会声明哪些trailer会发送）  // 在处理器从Body读取时，不能使用本字段。  // 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。  // （如果客户端发送了这些键值对），此时才可以访问本字段。  //  // 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）  // ContentLength字段必须是0或-1，以启用\"chunked\"传输编码发送请求。  // 在开始发送请求后，Trailer可以在读取请求主体期间被修改，  // 一旦请求主体返回EOF，调用者就不可再修改Trailer。  //  // 很少有HTTP客户端、服务端或代理支持HTTP trailer。  Trailer Header // RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。  // 本字段不是ReadRequest函数填写的，也没有定义格式。  // 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为\"IP:port\"格式的地址。  // 客户端会忽略请求中的RemoteAddr字段。  RemoteAddr string // RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI  // （参见RFC 2616, Section 5.1）  // 一般应使用URI字段，在客户端设置请求的本字段会导致错误。  RequestURI string // TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息  // 本字段不是ReadRequest函数填写的。  // 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。  // 客户端会忽略请求中的TLS字段。  TLS *tls.ConnectionState }   Request类型代表一个服务端接受到的或者客户端发送出去的HTTP请求。\nRequest各字段的意义和用途在服务端和客户端是不同的。除了字段本身上方文档，还可参见Request.Write方法和RoundTripper接口的文档。\nfunc NewRequest func NewRequest(method, urlStr string, body io.Reader) (*Request, error)  NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。\n如果body参数实现了io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client类型的Do、Post和PostFOrm方法以及Transport.RoundTrip方法关闭。\nfunc ReadRequest func ReadRequest(b *bufio.Reader) (req *Request, err error)  ReadRequest从b读F取并解析出一个HTTP请求。（本函数主要用在服务端从下层获取请求）\nfunc (*Request) ProtoAtLeast func (r *Request) ProtoAtLeast(major, minor int) bool  ProtoAtLeast报告该请求使用的HTTP协议版本至少是major.minor。\nfunc (*Request) UserAgent func (r *Request) UserAgent() string  UserAgent返回请求中的客户端用户代理信息（请求的User-Agent头）。\nfunc (*Request) Referer func (r *Request) Referer() string  Referer返回请求中的访问来路信息。（请求的Referer头）\nReferer在请求中就是拼错了的，这是HTTP早期就有的错误。该值也可以从用Header[“Referer”]获取； 让获取Referer字段变成方法的好处是，编译器可以诊断使用正确单词拼法的req.Referrer()的程序，但却不能诊断使用Header[“Referrer”]的程序。\nfunc (*Request) AddCookie func (r *Request) AddCookie(c *Cookie)  AddCookie向请求中添加一个cookie。按照RFC 6265 section 5.4的跪地，AddCookie不会添加超过一个Cookie头字段。这表示所有的cookie都写在同一行，用分号分隔（cookie内部用逗号分隔属性）。\nfunc (*Request) SetBasicAuth func (r *Request) SetBasicAuth(username, password string)  SetBasicAuth使用提供的用户名和密码，采用HTTP基本认证，设置请求的Authorization头。HTTP基本认证会明码传送用户名和密码。\nfunc (*Request) Write func (r *Request) Write(w io.Writer) error  Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：\nHost URL Method (defaults to \"GET\") Header ContentLength TransferEncoding Body  如果存在Body，ContentLength字段func (*Request) WriteProxy func (r *Request) WriteProxy(w io.Writer) error  WriteProxy类似Write但会将请求以HTTP代理期望的格式发送。\n尤其是，按照RFC 2616 Section 5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。\nfunc (*Request) Cookies func (r *Request) Cookies() []*Cookie  Cookies解析并返回该请求的Cookie头设置的cookie。\nfunc (*Request) Cookie func (r *Request) Cookie(name string) (*Cookie, error)  Cookie返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。\nfunc (*Request) ParseForm func (r *Request) ParseForm() error  ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。\n对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。\n如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。\nParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。\nfunc (*Request) ParseMultipartForm func (r *Request) ParseMultipartForm(maxMemory int64) error  ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用ParseForm。重复调用本方法是无意义的。\nfunc (*Request) FormValue func (r *Request) FormValue(key string) string  FormValue返回查询的命名组件的第一个值。 POST和PUT正文参数优先于URL查询字符串值。 如有必要，FormValue会调用ParseMultipartForm和ParseForm，并忽略这些函数返回的任何错误。 如果key不存在，FormValue将返回空字符串。 要访问同一个键的多个值，请调用ParseForm，然后直接检查Request.Form。\nfunc (*Request) PostFormValue func (r *Request) PostFormValue(key string) string  PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。\nfunc (*Request) FormFile func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)  FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。查询失败会返回ErrMissingFile错误。\nfunc (*Request) MultipartReader func (r *Request) MultipartReader() (*multipart.Reader, error)  如果请求是multipart/form-data POST请求，MultipartReader返回一个multipart.Reader接口，否则返回nil和一个错误。使用本函数代替ParseMultipartForm，可以将r.Body作为流处理。\ntype Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  type Client struct { // Transport指定执行独立、单次HTTP请求的机制。  // 如果Transport为nil，则使用DefaultTransport。  Transport RoundTripper // CheckRedirect指定处理重定向的策略。  // 如果CheckRedirect不为nil，客户端会在执行重定向之前调用本函数字段。  // 参数req和via是将要执行的请求和已经执行的请求（切片，越新的请求越靠后）。  // 如果CheckRedirect返回一个错误，本类型的Get方法不会发送请求req，  // 而是返回之前得到的最后一个回复和该错误。（包装进url.Error类型里）  //  // 如果CheckRedirect为nil，会采用默认策略：连续10此请求后停止。  CheckRedirect func(req *Request, via []*Request) error // Jar指定cookie管理器。  // 如果Jar为nil，请求中不会发送cookie，回复中的cookie会被忽略。  Jar CookieJar // Timeout指定本类型的值执行请求的时间限制。  // 该超时限制包括连接时间、重定向和读取回复主体的时间。  // 计时器会在Head、Get、Post或Do方法返回后继续运作并在超时后中断回复主体的读取。  //  // Timeout为零值表示不设置超时。  //  // Client实例的Transport字段必须支持CancelRequest方法，  // 否则Client会在试图用Head、Get、Post或Do方法执行请求时返回错误。  // 本类型的Transport字段默认值（DefaultTransport）支持CancelRequest方法。  Timeout time.Duration }   Client类型代表HTTP客户端。它的零值（DefaultClient）是一个可用的使用DefaultTransport的客户端。\nClient的Transport字段一般会含有内部状态（缓存TCP连接），因此Client类型值应尽量被重用而不是每次需要都创建新的。Client类型值可以安全的被多个go程同时使用。\nClient类型的层次比RoundTripper接口（如Transport）高，还会管理HTTP的cookie和重定向等细节。\nfunc (*Client) Do func (c *Client) Do(req *Request) (resp *Response, err error)  Do方法发送请求，返回HTTP回复。它会遵守客户端c设置的策略（如重定向、cookie、认证）。\n如果客户端的策略（如重定向）返回错误或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。\n如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。如果返回值resp的主体未关闭，c下层的RoundTripper接口（一般为Transport类型）可能无法重用resp主体下层保持的TCP连接去执行之后的请求。\n请求的主体，如果非nil，会在执行后被c.Transport关闭，即使出现错误。\n一般应使用Get、Post或PostForm方法代替Do方法。\nfunc (*Client) Head func (c *Client) Head(url string) (resp *Response, err error)  Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：\n301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect)  func (*Client) Get func (c *Client) Get(url string) (resp *Response, err error)  Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：\n301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect)  如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。\nfunc (*Client) Post func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)  Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。\nfunc (*Client) PostForm func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)  PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。POST数据的类型一般会设为\"application/x-www-form-urlencoded\"。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。\ntype Handler type Handler interface { ServeHTTP(ResponseWriter, *Request) }  实现了Handler接口的对象可以注册到HTTP服务端，为特定的路径及其子树提供服务。\nServeHTTP应该将回复的头域和数据写入ResponseWriter接口然后返回。返回标志着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。\nfunc NotFoundHandler func NotFoundHandler() Handler  NotFoundHandler返回一个简单的请求处理器，该处理器会对每个请求都回复\"404 page not found\"。\nfunc RedirectHandler func RedirectHandler(url string, code int) Handler  RedirectHandler返回一个请求处理器，该处理器会对每个请求都使用状态码code重定向到网址url。\nfunc TimeoutHandler func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler  TimeoutHandler返回一个采用指定时间限制的请求处理器。\n返回的Handler会调用h.ServeHTTP去处理每个请求，但如果某一次调用耗时超过了时间限制，该处理器会回复请求状态码503 Service Unavailable，并将msg作为回复的主体（如果msg为空字符串，将发送一个合理的默认信息）。在超时后，h对它的ResponseWriter接口参数的写入操作会返回ErrHandlerTimeout。\nfunc StripPrefix func StripPrefix(prefix string, h Handler) Handler  StripPrefix返回一个处理器，该处理器会将请求的URL.Path字段中给定前缀prefix去除后再交由h处理。StripPrefix会向URL.Path字段中没有给定前缀的请求回复404 page not found。\ntype HandlerFunc type HandlerFunc func(ResponseWriter, *Request)  HandlerFunc type是一个适配器，通过类型转换让我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。\nfunc (HandlerFunc) ServeHTTP func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)  ServeHTTP方法会调用f(w, r)\ntype ServeMux type ServeMux struct { // 内含隐藏或非导出字段 }  ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。\n模式是固定的、由根开始的路径，如\"/favicon.ico\"，或由根开始的子树，如\"/images/\"（注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式\"/images/“和”/images/thumbnails/“都注册了处理器，后一个处理器会用于路径以”/images/thumbnails/“开始的请求，前一个处理器会接收到其余的路径在”/images/“子树下的请求。\n注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式”/“会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径”/\"。\n模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式\"/codesearch\"和\"codesearch.google.com/“的处理器不会接管目标为\"http://www.google.com/“的请求。\nServeMux还会注意到请求的URL路径的无害化，将任何路径中包含”.“或”..“元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）\nfunc NewServeMux func NewServeMux() *ServeMux  NewServeMux创建并返回一个新的*ServeMux\nfunc (*ServeMux) Handle func (mux *ServeMux) Handle(pattern string, handler Handler)  Handle注册HTTP处理器handler和对应的模式pattern。如果该模式已经注册有一个处理器，Handle会panic。\nfunc (*ServeMux) HandleFunc func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))  HandleFunc注册一个处理器函数handler和对应的模式pattern。\nfunc (*ServeMux) Handler func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)  Handler根据r.Method、r.Host和r.URL.Path等数据，返回将用于处理该请求的HTTP处理器。它总是返回一个非nil的处理器。如果路径不是它的规范格式，将返回内建的用于重定向到等价的规范路径的处理器。\nHandler也会返回匹配该请求的的已注册模式；在内建重定向处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，本方法将返回一个内建的\"404 page not found\"处理器和一个空字符串模式。\nfunc (*ServeMux) ServeHTTP func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)  ServeHTTP将请求派遣到与请求的URL最匹配的模式对应的处理器。\ntype Server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  type Server struct { Addr string // 监听的TCP地址，如果为空字符串会使用\":http\"  Handler Handler // 调用的处理器，如为nil会调用http.DefaultServeMux  ReadTimeout time.Duration // 请求的读取操作在超时前的最大持续时间  WriteTimeout time.Duration // 回复的写入操作在超时前的最大持续时间  MaxHeaderBytes int // 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes  TLSConfig *tls.Config // 可选的TLS配置，用于ListenAndServeTLS方法  // TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。  // 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，  // 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。  // 连接在函数返回时会自动关闭。  TLSNextProto map[string]func(*Server, *tls.Conn, Handler) // ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。  // 参见ConnState类型和相关常数获取细节。  ConnState func(net.Conn, ConnState) // ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。  // 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。  ErrorLog *log.Logger // 内含隐藏或非导出字段 }   Server类型定义了运行HTTP服务端的参数。Server的零值是合法的配置。\nfunc (*Server) SetKeepAlivesEnabled func (s *Server) SetKeepAlivesEnabled(v bool)  SetKeepAlivesEnabled控制是否允许HTTP闲置连接重用（keep-alive）功能。默认该功能总是被启用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。\nfunc (*Server) Serve func (srv *Server) Serve(l net.Listener) error  Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用srv.Handler回复请求。\nfunc (*Server) ListenAndServe func (srv *Server) ListenAndServe() error  ListenAndServe监听srv.Addr指定的TCP地址，并且会调用Serve方法接收到的连接。如果srv.Addr为空字符串，会使用”:http”。\nfunc (*Server) ListenAndServeTLS func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error  ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用\":https\"。\ntype File 1 2 3 4 5 6 7  type File interface { io.Closer io.Reader Readdir(count int) ([]os.FileInfo, error) Seek(offset int64, whence int) (int64, error) Stat() (os.FileInfo, error) }   File是被FileSystem接口的Open方法返回的接口类型，可以被FileServer等函数用于文件访问服务。\n该接口的方法的行为应该和*os.File类型的同名方法相同。\ntype FileSystem 1 2 3  type FileSystem interface { Open(name string) (File, error) }   FileSystem接口实现了对一系列命名文件的访问。文件路径的分隔符为’/'，不管主机操作系统的惯例如何。\ntype Dir type Dir string  Dir使用限制到指定目录树的本地文件系统实现了http.FileSystem接口。空Dir被视为\".\"，即代表当前目录。\nfunc (Dir) Open func (d Dir) Open(name string) (File, error)  func NewFileTransport func NewFileTransport(fs FileSystem) RoundTripper  NewFileTransport返回一个RoundTripper接口，使用FileSystem接口fs提供文件访问服务。 返回的RoundTripper接口会忽略接收的请求的URL主机及其他绝大多数属性。\nNewFileTransport函数的典型使用情况是给Transport类型的值注册\"file\"协议，如下所示：\n1 2 3 4 5  t := \u0026http.Transport{} t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\"))) c := \u0026http.Client{Transport: t} res, err := c.Get(\"file:///etc/passwd\") ...   func FileServer func FileServer(root FileSystem) Handler  FileServer返回一个使用FileSystem接口root提供文件访问服务的HTTP处理器。要使用操作系统的FileSystem接口实现，可使用http.Dir：\n1  http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))   func ProxyURL func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)  ProxyURL返回一个代理函数（用于Transport类型），该函数总是返回同一个URL。\nfunc ProxyFromEnvironment func ProxyFromEnvironment(req *Request) (*url.URL, error)  ProxyFromEnvironment使用环境变量$HTTP_PROXY和$NO_PROXY(或$http_proxy和$no_proxy)的配置返回用于req的代理。如果代理环境不合法将返回错误；如果环境未设定代理或者给定的request不应使用代理时，将返回(nil, nil)；如果req.URL.Host字段是\"localhost\"（可以有端口号，也可以没有），也会返回(nil, nil)。\nfunc SetCookie func SetCookie(w ResponseWriter, cookie *Cookie)  SetCookie在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。\nfunc Redirect func Redirect(w ResponseWriter, r *Request, urlStr string, code int)  Redirect回复请求一个重定向地址urlStr和状态码code。该重定向地址可以是相对于请求r的相对地址。\nfunc NotFound func NotFound(w ResponseWriter, r *Request)  NotFound回复请求404状态码（not found：目标未发现）。\nfunc Error func Error(w ResponseWriter, error string, code int)  Error使用指定的错误信息和状态码回复请求，将数据写入w。错误信息必须是明文。\nfunc ServeContent func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)  ServeContent使用提供的ReadSeeker的内容回复请求。ServeContent比起io.Copy函数的主要优点，是可以处理范围类请求（只要一部分内容）、设置MIME类型，处理If-Modified-Since请求。\n如果未设定回复的Content-Type头，本函数首先会尝试从name的文件扩展名推断数据类型；如果失败，会用读取content的第1块数据并提供给DetectContentType推断类型；之后会设置Content-Type头。参数name不会用于别的地方，甚至于它可以是空字符串，也永远不会发送到回复里。\n如果modtime不是Time零值，函数会在回复的头域里设置Last-Modified头。如果请求的头域包含If-Modified-Since头，本函数会使用modtime参数来确定是否应该发送内容。如果调用者设置了w的ETag头，ServeContent会使用它处理包含If-Range头和If-None-Match头的请求。\n参数content的Seek方法必须有效：函数使用Seek来确定它的大小。\n注意：本包File接口和*os.File类型都实现了io.ReadSeeker接口。\nfunc ServeFile func ServeFile(w ResponseWriter, r *Request, name string)  ServeFile回复请求name指定的文件或者目录的内容。\nfunc MaxBytesReader func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser  MaxBytesReader类似io.LimitReader，但它是用来限制接收到的请求的Body的大小的。不同于io.LimitReader，本函数返回一个ReadCloser，返回值的Read方法在读取的数据超过大小限制时会返回非EOF错误，其Close方法会关闭下层的io.ReadCloser接口r。\nMaxBytesReader预防客户端因为意外或者蓄意发送的“大”请求，以避免尺寸过大的请求浪费服务端资源。\nfunc Head func Head(url string) (resp *Response, err error)  Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：\n1 2 3 4  301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect)   Head是对包变量DefaultClient的Head方法的包装。\nfunc Get func Get(url string) (resp *Response, err error)  Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：\n1 2 3 4  301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect)   如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。\nGet是对包变量DefaultClient的Get方法的包装。\nfunc Post func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)  Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。\nPost是对包变量DefaultClient的Post方法的包装。\nfunc PostForm func PostForm(url string, data url.Values) (resp *Response, err error)  PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。\nPostForm是对包变量DefaultClient的PostForm方法的包装。\nfunc Handle func Handle(pattern string, handler Handler)  Handle注册HTTP处理器handler和对应的模式pattern（注册到DefaultServeMux）。如果该模式已经注册有一个处理器，Handle会panic。ServeMux的文档解释了模式的匹配机制。\nfunc HandleFunc func HandleFunc(pattern string, handler func(ResponseWriter, *Request))  HandleFunc注册一个处理器函数handler和对应的模式pattern（注册到DefaultServeMux）。ServeMux的文档解释了模式的匹配机制。\nfunc Serve func Serve(l net.Listener, handler Handler) error  Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用handler回复请求。handler参数一般会设为nil，此时会使用DefaultServeMux。\nfunc ListenAndServe func ListenAndServe(addr string, handler Handler) error  ListenAndServe监听TCP地址addr，并且会使用handler参数调用Serve函数处理接收到的连接。handler参数一般会设为nil，此时会使用DefaultServeMux。\n一个简单的服务端例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  package main import ( \"io\" \"net/http\" \"log\" ) // hello world, the web server func HelloServer(w http.ResponseWriter, req *http.Request) { io.WriteString(w, \"hello, world!\\n\") } func main() { http.HandleFunc(\"/hello\", HelloServer) err := http.ListenAndServe(\":12345\", nil) if err != nil { log.Fatal(\"ListenAndServe: \", err) } }   func ListenAndServeTLS func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error  ListenAndServeTLS函数和ListenAndServe函数的行为基本一致，除了它期望HTTPS连接之外。此外，必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用\":https\"。\n一个简单的服务端例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import ( \"log\" \"net/http\" ) func handler(w http.ResponseWriter, req *http.Request) { w.Header().Set(\"Content-Type\", \"text/plain\") w.Write([]byte(\"This is an example server.\\n\")) } func main() { http.HandleFunc(\"/\", handler) log.Printf(\"About to listen on 10443. Go to https://127.0.0.1:10443/\") err := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil) if err != nil { log.Fatal(err) } }   程序员可以使用crypto/tls包的generate_cert.go文件来生成cert.pem和key.pem两个文件。\ntype Cookie 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type Cookie struct { Name string Value string Path string Domain string Expires time.Time RawExpires string // MaxAge=0表示未设置Max-Age属性  // MaxAge // MaxAge0表示存在Max-Age属性，单位是秒  MaxAge int Secure bool HttpOnly bool Raw string Unparsed []string // 未解析的“属性-值”对的原始文本 }   Cookie代表一个出现在HTTP回复的头域中Set-Cookie头的值里或者HTTP请求的头域中Cookie头的值里的HTTP cookie。\nfunc (*Cookie) String func (c *Cookie) String() string  String返回该cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。\ntype CookieJar 1 2 3 4 5 6 7 8  type CookieJar interface { // SetCookies管理从u的回复中收到的cookie  // 根据其策略和实现，它可以选择是否存储cookie  SetCookies(u *url.URL, cookies []*Cookie) // Cookies返回发送请求到u时应使用的cookie  // 本方法有责任遵守RFC 6265规定的标准cookie限制  Cookies(u *url.URL) []*Cookie }   CookieJar管理cookie的存储和在HTTP请求中的使用。CookieJar的实现必须能安全的被多个go程同时使用。\nnet/http/cookiejar包提供了一个CookieJar的实现。\n",
  "wordCount" : "19513",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-15T18:28:57Z",
  "dateModified": "2018-11-15T18:28:57Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      http包解析
    </h1>
    <div class="post-meta">November 15, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="预设值">预设值<a hidden class="anchor" aria-hidden="true" href="#预设值">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">StatusContinue</span>           <span class="p">=</span> <span class="mi">100</span>
    <span class="nx">StatusSwitchingProtocols</span> <span class="p">=</span> <span class="mi">101</span>
    <span class="nx">StatusOK</span>                   <span class="p">=</span> <span class="mi">200</span>
    <span class="nx">StatusCreated</span>              <span class="p">=</span> <span class="mi">201</span>
    <span class="nx">StatusAccepted</span>             <span class="p">=</span> <span class="mi">202</span>
    <span class="nx">StatusNonAuthoritativeInfo</span> <span class="p">=</span> <span class="mi">203</span>
    <span class="nx">StatusNoContent</span>            <span class="p">=</span> <span class="mi">204</span>
    <span class="nx">StatusResetContent</span>         <span class="p">=</span> <span class="mi">205</span>
    <span class="nx">StatusPartialContent</span>       <span class="p">=</span> <span class="mi">206</span>
    <span class="nx">StatusMultipleChoices</span>   <span class="p">=</span> <span class="mi">300</span>
    <span class="nx">StatusMovedPermanently</span>  <span class="p">=</span> <span class="mi">301</span>
    <span class="nx">StatusFound</span>             <span class="p">=</span> <span class="mi">302</span>
    <span class="nx">StatusSeeOther</span>          <span class="p">=</span> <span class="mi">303</span>
    <span class="nx">StatusNotModified</span>       <span class="p">=</span> <span class="mi">304</span>
    <span class="nx">StatusUseProxy</span>          <span class="p">=</span> <span class="mi">305</span>
    <span class="nx">StatusTemporaryRedirect</span> <span class="p">=</span> <span class="mi">307</span>
    <span class="nx">StatusBadRequest</span>                   <span class="p">=</span> <span class="mi">400</span>
    <span class="nx">StatusUnauthorized</span>                 <span class="p">=</span> <span class="mi">401</span>
    <span class="nx">StatusPaymentRequired</span>              <span class="p">=</span> <span class="mi">402</span>
    <span class="nx">StatusForbidden</span>                    <span class="p">=</span> <span class="mi">403</span>
    <span class="nx">StatusNotFound</span>                     <span class="p">=</span> <span class="mi">404</span>
    <span class="nx">StatusMethodNotAllowed</span>             <span class="p">=</span> <span class="mi">405</span>
    <span class="nx">StatusNotAcceptable</span>                <span class="p">=</span> <span class="mi">406</span>
    <span class="nx">StatusProxyAuthRequired</span>            <span class="p">=</span> <span class="mi">407</span>
    <span class="nx">StatusRequestTimeout</span>               <span class="p">=</span> <span class="mi">408</span>
    <span class="nx">StatusConflict</span>                     <span class="p">=</span> <span class="mi">409</span>
    <span class="nx">StatusGone</span>                         <span class="p">=</span> <span class="mi">410</span>
    <span class="nx">StatusLengthRequired</span>               <span class="p">=</span> <span class="mi">411</span>
    <span class="nx">StatusPreconditionFailed</span>           <span class="p">=</span> <span class="mi">412</span>
    <span class="nx">StatusRequestEntityTooLarge</span>        <span class="p">=</span> <span class="mi">413</span>
    <span class="nx">StatusRequestURITooLong</span>            <span class="p">=</span> <span class="mi">414</span>
    <span class="nx">StatusUnsupportedMediaType</span>         <span class="p">=</span> <span class="mi">415</span>
    <span class="nx">StatusRequestedRangeNotSatisfiable</span> <span class="p">=</span> <span class="mi">416</span>
    <span class="nx">StatusExpectationFailed</span>            <span class="p">=</span> <span class="mi">417</span>
    <span class="nx">StatusTeapot</span>                       <span class="p">=</span> <span class="mi">418</span>
    <span class="nx">StatusInternalServerError</span>     <span class="p">=</span> <span class="mi">500</span>
    <span class="nx">StatusNotImplemented</span>          <span class="p">=</span> <span class="mi">501</span>
    <span class="nx">StatusBadGateway</span>              <span class="p">=</span> <span class="mi">502</span>
    <span class="nx">StatusServiceUnavailable</span>      <span class="p">=</span> <span class="mi">503</span>
    <span class="nx">StatusGatewayTimeout</span>          <span class="p">=</span> <span class="mi">504</span>
    <span class="nx">StatusHTTPVersionNotSupported</span> <span class="p">=</span> <span class="mi">505</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><pre><code>const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB
</code></pre>
<p>DefaultMaxHeaderBytes是HTTP请求的头域最大允许长度。可以通过设置Server.MaxHeaderBytes字段来覆盖。</p>
<pre><code>const DefaultMaxIdleConnsPerHost = 2
</code></pre>
<p>DefaultMaxIdleConnsPerHost是Transport的MaxIdleConnsPerHost的默认值。</p>
<pre><code>const TimeFormat = &quot;Mon, 02 Jan 2006 15:04:05 GMT&quot;
</code></pre>
<p>TimeFormat是当解析或生产HTTP头域中的时间时，用与time.Parse或time.Format函数的时间格式。这种格式类似time.RFC1123但强制采用GMT时区。</p>
<h2 id="variables">Variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrHeaderTooLong</span>        <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;header too long&#34;</span><span class="p">}</span>
    <span class="nx">ErrShortBody</span>            <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;entity body too short&#34;</span><span class="p">}</span>
    <span class="nx">ErrNotSupported</span>         <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;feature not supported&#34;</span><span class="p">}</span>
    <span class="nx">ErrUnexpectedTrailer</span>    <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;trailer header without chunked transfer encoding&#34;</span><span class="p">}</span>
    <span class="nx">ErrMissingContentLength</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;missing ContentLength in HEAD response&#34;</span><span class="p">}</span>
    <span class="nx">ErrNotMultipart</span>         <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;request Content-Type isn&#39;t multipart/form-data&#34;</span><span class="p">}</span>
    <span class="nx">ErrMissingBoundary</span>      <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;no multipart boundary param in Content-Type&#34;</span><span class="p">}</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP请求的解析错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrWriteAfterFlush</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Conn.Write called after Flush&#34;</span><span class="p">)</span>
    <span class="nx">ErrBodyNotAllowed</span>  <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: request method or response status code does not allow body&#34;</span><span class="p">)</span>
    <span class="nx">ErrHijacked</span>        <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Conn has been hijacked&#34;</span><span class="p">)</span>
    <span class="nx">ErrContentLength</span>   <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Conn.Write wrote more than the declared Content-Length&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>会被HTTP服务端返回的错误。</p>
<pre><code>var DefaultClient = &amp;Client{}
</code></pre>
<p>DefaultClient是用于包函数Get、Head和Post的默认Client。</p>
<pre><code>var DefaultServeMux = NewServeMux()
</code></pre>
<p>DefaultServeMux是用于Serve的默认ServeMux。</p>
<pre><code>var ErrBodyReadAfterClose = errors.New(&quot;http: invalid Read on closed Body&quot;)
</code></pre>
<p>在Resquest或Response的Body字段已经关闭后，试图从中读取时，就会返回ErrBodyReadAfterClose。这个错误一般发生在：HTTP处理器中调用完ResponseWriter 接口的WriteHeader或Write后从请求中读取数据的时候。</p>
<pre><code>var ErrHandlerTimeout = errors.New(&quot;http: Handler timeout&quot;)
</code></pre>
<p>在处理器超时以后调用ResponseWriter接口的Write方法，就会返回ErrHandlerTimeout。</p>
<pre><code>var ErrLineTooLong = errors.New(&quot;header line too long&quot;)
var ErrMissingFile = errors.New(&quot;http: no such file&quot;)
</code></pre>
<p>当请求中没有提供给FormFile函数的文件字段名，或者该字段名不是文件字段时，该函数就会返回ErrMissingFile。</p>
<pre><code>var ErrNoCookie = errors.New(&quot;http: named cookie not present&quot;)
var ErrNoLocation = errors.New(&quot;http: no Location header in response&quot;)
</code></pre>
<h1 id="type-protocolerror">type ProtocolError<a hidden class="anchor" aria-hidden="true" href="#type-protocolerror">#</a></h1>
<p>type ProtocolError struct {
ErrorString string
}</p>
<p>HTTP请求解析错误。</p>
<h2 id="func-protocolerror-error">func (*ProtocolError) Error<a hidden class="anchor" aria-hidden="true" href="#func-protocolerror-error">#</a></h2>
<pre><code>func (err *ProtocolError) Error() string
</code></pre>
<h1 id="func-canonicalheaderkey">func CanonicalHeaderKey<a hidden class="anchor" aria-hidden="true" href="#func-canonicalheaderkey">#</a></h1>
<pre><code>func CanonicalHeaderKey(s string) string
</code></pre>
<p>CanonicalHeaderKey函数返回头域（表示为Header类型）的键s的规范化格式。规范化过程中让单词首字母和'-&lsquo;后的第一个字母大写，其余字母小写。例如，&ldquo;accept-encoding&quot;规范化为&quot;Accept-Encoding&rdquo;。</p>
<h1 id="func-detectcontenttype">func DetectContentType<a hidden class="anchor" aria-hidden="true" href="#func-detectcontenttype">#</a></h1>
<pre><code>func DetectContentType(data []byte) string
</code></pre>
<p>DetectContentType函数实现了http://mimesniff.spec.whatwg.org/描述的算法，用于确定数据的Content-Type。函数总是返回一个合法的MIME类型；如果它不能确定数据的类型，将返回&quot;application/octet-stream&quot;。它最多检查数据的前512字节。</p>
<h1 id="func-parsehttpversion">func ParseHTTPVersion<a hidden class="anchor" aria-hidden="true" href="#func-parsehttpversion">#</a></h1>
<pre><code>func ParseHTTPVersion(vers string) (major, minor int, ok bool)
</code></pre>
<p>ParseHTTPVersion解析HTTP版本字符串。如&quot;HTTP/1.0&quot;返回(1, 0, true)。</p>
<h1 id="func-parsetime">func ParseTime<a hidden class="anchor" aria-hidden="true" href="#func-parsetime">#</a></h1>
<pre><code>func ParseTime(text string) (t time.Time, err error)
</code></pre>
<p>ParseTime用3种格式TimeFormat,</p>
<p>time.RFC850和time.ANSIC尝试解析一个时间头的值（如Date: header）。</p>
<h1 id="func-statustext">func StatusText<a hidden class="anchor" aria-hidden="true" href="#func-statustext">#</a></h1>
<p>func StatusText(code int) string
StatusText返回HTTP状态码code对应的文本，如220对应&quot;OK&quot;。如果code是未知的状态码，会返回&quot;&quot;。</p>
<h1 id="type-connstate">type ConnState<a hidden class="anchor" aria-hidden="true" href="#type-connstate">#</a></h1>
<pre><code>type ConnState int
</code></pre>
<p>ConnState代表一个客户端到服务端的连接的状态。本类型用于可选的Server.ConnState回调函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// StateNew代表一个新的连接，将要立刻发送请求。
</span><span class="c1"></span>    <span class="c1">// 连接从这个状态开始，然后转变为StateAlive或StateClosed。
</span><span class="c1"></span>    <span class="nx">StateNew</span> <span class="nx">ConnState</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="c1">// StateActive代表一个已经读取了请求数据1到多个字节的连接。
</span><span class="c1"></span>    <span class="c1">// 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，
</span><span class="c1"></span>    <span class="c1">// 等到请求被处理完后，Server.ConnState回调函数再次被触发。
</span><span class="c1"></span>    <span class="c1">// 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。
</span><span class="c1"></span>    <span class="nx">StateActive</span>
    <span class="c1">// StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。
</span><span class="c1"></span>    <span class="c1">// 连接状态可以从StateIdle改变为StateActive或StateClosed。
</span><span class="c1"></span>    <span class="nx">StateIdle</span>
    <span class="c1">// 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。
</span><span class="c1"></span>    <span class="nx">StateHijacked</span>
    <span class="c1">// StateClosed代表一个关闭的连接。
</span><span class="c1"></span>    <span class="c1">// 这是一个终止状态。被劫持的连接不会转变为StateClosed。
</span><span class="c1"></span>    <span class="nx">StateClosed</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-connstate-string">func (ConnState) String<a hidden class="anchor" aria-hidden="true" href="#func-connstate-string">#</a></h1>
<pre><code>func (c ConnState) String() string
</code></pre>
<h1 id="type-header">type Header<a hidden class="anchor" aria-hidden="true" href="#type-header">#</a></h1>
<pre><code>type Header map[string][]string
</code></pre>
<p>Header代表HTTP头域的键值对。</p>
<h2 id="func-header-get">func (Header) Get<a hidden class="anchor" aria-hidden="true" href="#func-header-get">#</a></h2>
<pre><code>func (h Header) Get(key string) string
</code></pre>
<p>Get返回键对应的第一个值，如果键不存在会返回&quot;&quot;。如要获取该键对应的值切片，请直接用规范格式的键访问map。</p>
<h2 id="func-header-set">func (Header) Set<a hidden class="anchor" aria-hidden="true" href="#func-header-set">#</a></h2>
<pre><code>func (h Header) Set(key, value string)
</code></pre>
<p>Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。</p>
<h2 id="func-header-add">func (Header) Add<a hidden class="anchor" aria-hidden="true" href="#func-header-add">#</a></h2>
<pre><code>func (h Header) Add(key, value string)
</code></pre>
<p>Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。</p>
<h2 id="func-header-del">func (Header) Del<a hidden class="anchor" aria-hidden="true" href="#func-header-del">#</a></h2>
<pre><code>func (h Header) Del(key string)
</code></pre>
<p>Del删除键值对。</p>
<h2 id="func-header-write">func (Header) Write<a hidden class="anchor" aria-hidden="true" href="#func-header-write">#</a></h2>
<pre><code>func (h Header) Write(w io.Writer) error
</code></pre>
<p>Write以有线格式将头域写入w。</p>
<h2 id="func-header-writesubset">func (Header) WriteSubset<a hidden class="anchor" aria-hidden="true" href="#func-header-writesubset">#</a></h2>
<pre><code>func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error
</code></pre>
<p>WriteSubset以有线格式将头域写入w。当exclude不为nil时，如果h的键值对的键在exclude中存在且其对应值为真，该键值对就不会被写入w。</p>
<h1 id="type-response">type Response<a hidden class="anchor" aria-hidden="true" href="#type-response">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Status</span>     <span class="kt">string</span> <span class="c1">// 例如&#34;200 OK&#34;
</span><span class="c1"></span>    <span class="nx">StatusCode</span> <span class="kt">int</span>    <span class="c1">// 例如200
</span><span class="c1"></span>    <span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// 例如&#34;HTTP/1.0&#34;
</span><span class="c1"></span>    <span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// 例如1
</span><span class="c1"></span>    <span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// 例如0
</span><span class="c1"></span>    <span class="c1">// Header保管头域的键值对。
</span><span class="c1"></span>    <span class="c1">// 如果回复中有多个头的键相同，Header中保存为该键对应用逗号分隔串联起来的这些头的值
</span><span class="c1"></span>    <span class="c1">// （参见RFC 2616 Section 4.2）
</span><span class="c1"></span>    <span class="c1">// 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Header中的键都是规范化的，参见CanonicalHeaderKey函数
</span><span class="c1"></span>    <span class="nx">Header</span> <span class="nx">Header</span>
    <span class="c1">// Body代表回复的主体。
</span><span class="c1"></span>    <span class="c1">// Client类型和Transport类型会保证Body字段总是非nil的，即使回复没有主体或主体长度为0。
</span><span class="c1"></span>    <span class="c1">// 关闭主体是调用者的责任。
</span><span class="c1"></span>    <span class="c1">// 如果服务端采用&#34;chunked&#34;传输编码发送的回复，Body字段会自动进行解码。
</span><span class="c1"></span>    <span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>
    <span class="c1">// ContentLength记录相关内容的长度。
</span><span class="c1"></span>    <span class="c1">// 其值为-1表示长度未知（采用chunked传输编码）
</span><span class="c1"></span>    <span class="c1">// 除非对应的Request.Method是&#34;HEAD&#34;，其值&gt;=0表示可以从Body读取的字节数
</span><span class="c1"></span>    <span class="nx">ContentLength</span> <span class="kt">int64</span>
    <span class="c1">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示&#34;identity&#34;编码。
</span><span class="c1"></span>    <span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="c1">// Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）
</span><span class="c1"></span>    <span class="c1">// 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。
</span><span class="c1"></span>    <span class="nx">Close</span> <span class="kt">bool</span>
    <span class="c1">// Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型
</span><span class="c1"></span>    <span class="nx">Trailer</span> <span class="nx">Header</span>
    <span class="c1">// Request是用来获取此回复的请求
</span><span class="c1"></span>    <span class="c1">// Request的Body字段是nil（因为已经被用掉了）
</span><span class="c1"></span>    <span class="c1">// 这个字段是被Client类型发出请求并获得回复后填充的
</span><span class="c1"></span>    <span class="nx">Request</span> <span class="o">*</span><span class="nx">Request</span>
    <span class="c1">// TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。
</span><span class="c1"></span>    <span class="c1">// 返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。
</span><span class="c1"></span>    <span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Response代表一个HTTP请求的回复。</p>
<h2 id="func-readresponse">func ReadResponse<a hidden class="anchor" aria-hidden="true" href="#func-readresponse">#</a></h2>
<pre><code>func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)
</code></pre>
<p>ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的trailer的键值对。（本函数主要用在客户端从下层获取回复）</p>
<h2 id="func-response-protoatleast">func (*Response) ProtoAtLeast<a hidden class="anchor" aria-hidden="true" href="#func-response-protoatleast">#</a></h2>
<pre><code>func (r *Response) ProtoAtLeast(major, minor int) bool
</code></pre>
<p>ProtoAtLeast报告该回复使用的HTTP协议版本至少是major.minor。</p>
<h2 id="func-response-cookies">func (*Response) Cookies<a hidden class="anchor" aria-hidden="true" href="#func-response-cookies">#</a></h2>
<pre><code>func (r *Response) Cookies() []*Cookie
</code></pre>
<p>Cookies解析并返回该回复中的Set-Cookie头设置的cookie。</p>
<h2 id="func-response-location">func (*Response) Location<a hidden class="anchor" aria-hidden="true" href="#func-response-location">#</a></h2>
<pre><code>func (r *Response) Location() (*url.URL, error)
</code></pre>
<p>Location返回该回复的Location头设置的URL。相对地址的重定向会相对于该回复对应的请求来确定绝对地址。如果回复中没有Location头，会返回nil, ErrNoLocation。</p>
<h2 id="func-response-write">func (*Response) Write<a hidden class="anchor" aria-hidden="true" href="#func-response-write">#</a></h2>
<pre><code>func (r *Response) Write(w io.Writer) error
</code></pre>
<p>Write以有线格式将回复写入w（用于将回复写入下层TCPConn等）。本方法会考虑如下字段：</p>
<pre><code>StatusCode
ProtoMajor
ProtoMinor
Request.Method
TransferEncoding
Trailer
Body
ContentLength
Header（不规范的键名和它对应的值会导致不可预知的行为）
</code></pre>
<p>Body字段在发送完回复后会被关闭。</p>
<h1 id="type-responsewriter">type ResponseWriter<a hidden class="anchor" aria-hidden="true" href="#type-responsewriter">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ResponseWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Header返回一个Header类型值，该值会被WriteHeader方法发送。
</span><span class="c1"></span>    <span class="c1">// 在调用WriteHeader或Write方法后再改变该对象是没有意义的。
</span><span class="c1"></span>    <span class="nf">Header</span><span class="p">()</span> <span class="nx">Header</span>
    <span class="c1">// WriteHeader该方法发送HTTP回复的头域和状态码。
</span><span class="c1"></span>    <span class="c1">// 如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)
</span><span class="c1"></span>    <span class="c1">// WriterHeader的显式调用主要用于发送错误码。
</span><span class="c1"></span>    <span class="nf">WriteHeader</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="c1">// Write向连接中写入作为HTTP的一部分回复的数据。
</span><span class="c1"></span>    <span class="c1">// 如果被调用时还未调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)
</span><span class="c1"></span>    <span class="c1">// 如果Header中没有&#34;Content-Type&#34;键，
</span><span class="c1"></span>    <span class="c1">// 本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ResponseWriter接口被HTTP处理器用于构造HTTP回复。</p>
<h1 id="type-flusher">type Flusher<a hidden class="anchor" aria-hidden="true" href="#type-flusher">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Flusher</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Flush将缓冲中的所有数据发送到客户端
</span><span class="c1"></span>    <span class="nf">Flush</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP处理器ResponseWriter接口参数的下层如果实现了Flusher接口，可以让HTTP处理器将缓冲中的数据发送到客户端。</p>
<p>注意：即使ResponseWriter接口的下层支持Flush方法，如果客户端是通过HTTP代理连接的，缓冲中的数据也可能直到回复完毕才被传输到客户端。</p>
<h1 id="type-closenotifier">type CloseNotifier<a hidden class="anchor" aria-hidden="true" href="#type-closenotifier">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CloseNotifier</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// CloseNotify返回一个通道，该通道会在客户端连接丢失时接收到唯一的值
</span><span class="c1"></span>    <span class="nf">CloseNotify</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP处理器ResponseWriter接口参数的下层如果实现了CloseNotifier接口，可以让用户检测下层的连接是否停止。如果客户端在回复准备好之前关闭了连接，该机制可以用于取消服务端耗时较长的操作。</p>
<h1 id="type-hijacker">type Hijacker<a hidden class="anchor" aria-hidden="true" href="#type-hijacker">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Hijacker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Hijack让调用者接管连接，返回连接和关联到该连接的一个缓冲读写器。
</span><span class="c1"></span>    <span class="c1">// 调用本方法后，HTTP服务端将不再对连接进行任何操作，
</span><span class="c1"></span>    <span class="c1">// 调用者有责任管理、关闭返回的连接。
</span><span class="c1"></span>    <span class="nf">Hijack</span><span class="p">()</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP处理器ResponseWriter接口参数的下层如果实现了Hijacker接口，可以让HTTP处理器接管该连接。</p>
<h1 id="type-roundtripper">type RoundTripper<a hidden class="anchor" aria-hidden="true" href="#type-roundtripper">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RoundTripper</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// RoundTrip执行单次HTTP事务，接收并发挥请求req的回复。
</span><span class="c1"></span>    <span class="c1">// RoundTrip不应试图解析/修改得到的回复。
</span><span class="c1"></span>    <span class="c1">// 尤其要注意，只要RoundTrip获得了一个回复，不管该回复的HTTP状态码如何，
</span><span class="c1"></span>    <span class="c1">// 它必须将返回值err设置为nil。
</span><span class="c1"></span>    <span class="c1">// 非nil的返回值err应该留给获取回复失败的情况。
</span><span class="c1"></span>    <span class="c1">// 类似的，RoundTrip不能试图管理高层次的细节，如重定向、认证、cookie。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 除了从请求的主体读取并关闭主体之外，RoundTrip不应修改请求，包括（请求的）错误。
</span><span class="c1"></span>    <span class="c1">// RoundTrip函数接收的请求的URL和Header字段可以保证是（被）初始化了的。
</span><span class="c1"></span>    <span class="nf">RoundTrip</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>RoundTripper接口是具有执行单次HTTP事务的能力（接收指定请求的回复）的接口。</p>
<p>RoundTripper接口的类型必须可以安全的被多线程同时使用。</p>
<h1 id="type-transport">type Transport<a hidden class="anchor" aria-hidden="true" href="#type-transport">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Transport</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Proxy指定一个对给定请求返回代理的函数。
</span><span class="c1"></span>    <span class="c1">// 如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。
</span><span class="c1"></span>    <span class="c1">// 如果Proxy为nil或返回nil的*URL置，将不使用代理。
</span><span class="c1"></span>    <span class="nx">Proxy</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// Dial指定创建TCP连接的拨号函数。如果Dial为nil，会使用net.Dial。
</span><span class="c1"></span>    <span class="nx">Dial</span> <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// TLSClientConfig指定用于tls.Client的TLS配置信息。
</span><span class="c1"></span>    <span class="c1">// 如果该字段为nil，会使用默认的配置信息。
</span><span class="c1"></span>    <span class="nx">TLSClientConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>
    <span class="c1">// TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。
</span><span class="c1"></span>    <span class="nx">TLSHandshakeTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="c1">// 如果DisableKeepAlives为真，会禁止不同HTTP请求之间TCP连接的重用。
</span><span class="c1"></span>    <span class="nx">DisableKeepAlives</span> <span class="kt">bool</span>
    <span class="c1">// 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，
</span><span class="c1"></span>    <span class="c1">// 主动添加&#34;Accept-Encoding: gzip&#34;头，以获取压缩数据。
</span><span class="c1"></span>    <span class="c1">// 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。
</span><span class="c1"></span>    <span class="c1">// 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。
</span><span class="c1"></span>    <span class="nx">DisableCompression</span> <span class="kt">bool</span>
    <span class="c1">// 如果MaxIdleConnsPerHost!=0，会控制每个主机下的最大闲置连接。
</span><span class="c1"></span>    <span class="c1">// 如果MaxIdleConnsPerHost==0，会使用DefaultMaxIdleConnsPerHost。
</span><span class="c1"></span>    <span class="nx">MaxIdleConnsPerHost</span> <span class="kt">int</span>
    <span class="c1">// ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，
</span><span class="c1"></span>    <span class="c1">// 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。
</span><span class="c1"></span>    <span class="c1">// 该时间不包括获取回复主体的时间。
</span><span class="c1"></span>    <span class="nx">ResponseHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Transport类型实现了RoundTripper接口，支持http、https和http/https代理。Transport类型可以缓存连接以在未来重用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">DefaultTransport</span> <span class="nx">RoundTripper</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Transport</span><span class="p">{</span>
    <span class="nx">Proxy</span><span class="p">:</span> <span class="nx">ProxyFromEnvironment</span><span class="p">,</span>
    <span class="nx">Dial</span><span class="p">:</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">{</span>
        <span class="nx">Timeout</span><span class="p">:</span>   <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
        <span class="nx">KeepAlive</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="p">}).</span><span class="nx">Dial</span><span class="p">,</span>
    <span class="nx">TLSHandshakeTimeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>DefaultTransport是被包变量DefaultClient使用的默认RoundTripper接口。它会根据需要创建网络连接，并缓存以便在之后的请求中重用这些连接。它使用环境变量$HTTP_PROXY和$NO_PROXY（或$http_proxy和$no_proxy）指定的HTTP代理。</p>
<h2 id="func-transport-registerprotocol">func (*Transport) RegisterProtocol<a hidden class="anchor" aria-hidden="true" href="#func-transport-registerprotocol">#</a></h2>
<pre><code>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)
</code></pre>
<p>RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。</p>
<p>RegisterProtocol可以被其他包用于提供&quot;ftp&quot;或&quot;file&quot;等协议的实现。</p>
<h2 id="func-transport-roundtrip">func (*Transport) RoundTrip<a hidden class="anchor" aria-hidden="true" href="#func-transport-roundtrip">#</a></h2>
<pre><code>func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)
</code></pre>
<p>RoundTrip方法实现了RoundTripper接口。</p>
<p>高层次的HTTP客户端支持（如管理cookie和重定向）请参见Get、Post等函数和Client类型。</p>
<h2 id="func-transport-closeidleconnections">func (*Transport) CloseIdleConnections<a hidden class="anchor" aria-hidden="true" href="#func-transport-closeidleconnections">#</a></h2>
<pre><code>func (t *Transport) CloseIdleConnections()
</code></pre>
<p>CloseIdleConnections关闭所有之前的请求建立但目前处于闲置状态的连接。本方法不会中断正在使用的连接。</p>
<h2 id="func-transport-cancelrequest">func (*Transport) CancelRequest<a hidden class="anchor" aria-hidden="true" href="#func-transport-cancelrequest">#</a></h2>
<pre><code>func (t *Transport) CancelRequest(req *Request)
</code></pre>
<p>CancelRequest通过关闭请求所在的连接取消一个执行中的请求。</p>
<h1 id="type-request">type Request<a hidden class="anchor" aria-hidden="true" href="#type-request">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Method指定HTTP方法（GET、POST、PUT等）。对客户端，&#34;&#34;代表GET。
</span><span class="c1"></span>    <span class="nx">Method</span> <span class="kt">string</span>
    <span class="c1">// URL在服务端表示被请求的URI，在客户端表示要访问的URL。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，
</span><span class="c1"></span>    <span class="c1">// 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。
</span><span class="c1"></span>    <span class="c1">// （参见RFC 2616, Section 5.1.2）
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，URL的Host字段指定了要连接的服务器，
</span><span class="c1"></span>    <span class="c1">// 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。
</span><span class="c1"></span>    <span class="nx">URL</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>
    <span class="c1">// 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1
</span><span class="c1"></span>    <span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// &#34;HTTP/1.0&#34;
</span><span class="c1"></span>    <span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// 1
</span><span class="c1"></span>    <span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// 0
</span><span class="c1"></span>    <span class="c1">// Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：
</span><span class="c1"></span>    <span class="c1">//	accept-encoding: gzip, deflate
</span><span class="c1"></span>    <span class="c1">//	Accept-Language: en-us
</span><span class="c1"></span>    <span class="c1">//	Connection: keep-alive
</span><span class="c1"></span>    <span class="c1">// 则：
</span><span class="c1"></span>    <span class="c1">//	Header = map[string][]string{
</span><span class="c1"></span>    <span class="c1">//		&#34;Accept-Encoding&#34;: {&#34;gzip, deflate&#34;},
</span><span class="c1"></span>    <span class="c1">//		&#34;Accept-Language&#34;: {&#34;en-us&#34;},
</span><span class="c1"></span>    <span class="c1">//		&#34;Connection&#34;: {&#34;keep-alive&#34;},
</span><span class="c1"></span>    <span class="c1">//	}
</span><span class="c1"></span>    <span class="c1">// HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。
</span><span class="c1"></span>    <span class="c1">// 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。
</span><span class="c1"></span>    <span class="nx">Header</span> <span class="nx">Header</span>
    <span class="c1">// Body是请求的主体。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，如果Body是nil表示该请求没有主体买入GET请求。
</span><span class="c1"></span>    <span class="c1">// Client的Transport字段会负责调用Body的Close方法。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。
</span><span class="c1"></span>    <span class="c1">// Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。
</span><span class="c1"></span>    <span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>
    <span class="c1">// ContentLength记录相关内容的长度。
</span><span class="c1"></span>    <span class="c1">// 如果为-1，表示长度未知，如果&gt;=0，表示可以从Body字段读取ContentLength字节数据。
</span><span class="c1"></span>    <span class="c1">// 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。
</span><span class="c1"></span>    <span class="nx">ContentLength</span> <span class="kt">int64</span>
    <span class="c1">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示&#34;identity&#34;编码。
</span><span class="c1"></span>    <span class="c1">// 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除&#34;chunked&#34;传输编码。
</span><span class="c1"></span>    <span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="c1">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。
</span><span class="c1"></span>    <span class="nx">Close</span> <span class="kt">bool</span>
    <span class="c1">// 在服务端，Host指定URL会在其上寻找资源的主机。
</span><span class="c1"></span>    <span class="c1">// 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。
</span><span class="c1"></span>    <span class="c1">// Host的格式可以是&#34;host:port&#34;。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，请求的Host字段（可选地）用来重写请求的Host头。
</span><span class="c1"></span>    <span class="c1">// 如过该字段为&#34;&#34;，Request.Write方法会使用URL字段的Host。
</span><span class="c1"></span>    <span class="nx">Host</span> <span class="kt">string</span>
    <span class="c1">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。
</span><span class="c1"></span>    <span class="c1">// 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
</span><span class="c1"></span>    <span class="nx">Form</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
    <span class="c1">// PostForm是解析好的POST或PUT的表单数据。
</span><span class="c1"></span>    <span class="c1">// 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
</span><span class="c1"></span>    <span class="nx">PostForm</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
    <span class="c1">// MultipartForm是解析好的多部件表单，包括上传的文件。
</span><span class="c1"></span>    <span class="c1">// 本字段只有在调用ParseMultipartForm后才有效。
</span><span class="c1"></span>    <span class="c1">// 在客户端，会忽略请求中的本字段而使用Body替代。
</span><span class="c1"></span>    <span class="nx">MultipartForm</span> <span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">Form</span>
    <span class="c1">// Trailer指定了会在请求主体之后发送的额外的头域。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。
</span><span class="c1"></span>    <span class="c1">// （客户端会声明哪些trailer会发送）
</span><span class="c1"></span>    <span class="c1">// 在处理器从Body读取时，不能使用本字段。
</span><span class="c1"></span>    <span class="c1">// 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。
</span><span class="c1"></span>    <span class="c1">// （如果客户端发送了这些键值对），此时才可以访问本字段。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）
</span><span class="c1"></span>    <span class="c1">// ContentLength字段必须是0或-1，以启用&#34;chunked&#34;传输编码发送请求。
</span><span class="c1"></span>    <span class="c1">// 在开始发送请求后，Trailer可以在读取请求主体期间被修改，
</span><span class="c1"></span>    <span class="c1">// 一旦请求主体返回EOF，调用者就不可再修改Trailer。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 很少有HTTP客户端、服务端或代理支持HTTP trailer。
</span><span class="c1"></span>    <span class="nx">Trailer</span> <span class="nx">Header</span>
    <span class="c1">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。
</span><span class="c1"></span>    <span class="c1">// 本字段不是ReadRequest函数填写的，也没有定义格式。
</span><span class="c1"></span>    <span class="c1">// 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为&#34;IP:port&#34;格式的地址。
</span><span class="c1"></span>    <span class="c1">// 客户端会忽略请求中的RemoteAddr字段。
</span><span class="c1"></span>    <span class="nx">RemoteAddr</span> <span class="kt">string</span>
    <span class="c1">// RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI
</span><span class="c1"></span>    <span class="c1">// （参见RFC 2616, Section 5.1）
</span><span class="c1"></span>    <span class="c1">// 一般应使用URI字段，在客户端设置请求的本字段会导致错误。
</span><span class="c1"></span>    <span class="nx">RequestURI</span> <span class="kt">string</span>
    <span class="c1">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息
</span><span class="c1"></span>    <span class="c1">// 本字段不是ReadRequest函数填写的。
</span><span class="c1"></span>    <span class="c1">// 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。
</span><span class="c1"></span>    <span class="c1">// 客户端会忽略请求中的TLS字段。
</span><span class="c1"></span>    <span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Request类型代表一个服务端接受到的或者客户端发送出去的HTTP请求。</p>
<p>Request各字段的意义和用途在服务端和客户端是不同的。除了字段本身上方文档，还可参见Request.Write方法和RoundTripper接口的文档。</p>
<h2 id="func-newrequest">func NewRequest<a hidden class="anchor" aria-hidden="true" href="#func-newrequest">#</a></h2>
<pre><code>func NewRequest(method, urlStr string, body io.Reader) (*Request, error)
</code></pre>
<p>NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。</p>
<p>如果body参数实现了io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client类型的Do、Post和PostFOrm方法以及Transport.RoundTrip方法关闭。</p>
<h2 id="func-readrequest">func ReadRequest<a hidden class="anchor" aria-hidden="true" href="#func-readrequest">#</a></h2>
<pre><code>func ReadRequest(b *bufio.Reader) (req *Request, err error)
</code></pre>
<p>ReadRequest从b读F取并解析出一个HTTP请求。（本函数主要用在服务端从下层获取请求）</p>
<h2 id="func-request-protoatleast">func (*Request) ProtoAtLeast<a hidden class="anchor" aria-hidden="true" href="#func-request-protoatleast">#</a></h2>
<pre><code>func (r *Request) ProtoAtLeast(major, minor int) bool
</code></pre>
<p>ProtoAtLeast报告该请求使用的HTTP协议版本至少是major.minor。</p>
<h2 id="func-request-useragent">func (*Request) UserAgent<a hidden class="anchor" aria-hidden="true" href="#func-request-useragent">#</a></h2>
<pre><code>func (r *Request) UserAgent() string
</code></pre>
<p>UserAgent返回请求中的客户端用户代理信息（请求的User-Agent头）。</p>
<h2 id="func-request-referer">func (*Request) Referer<a hidden class="anchor" aria-hidden="true" href="#func-request-referer">#</a></h2>
<pre><code>func (r *Request) Referer() string
</code></pre>
<p>Referer返回请求中的访问来路信息。（请求的Referer头）</p>
<p>Referer在请求中就是拼错了的，这是HTTP早期就有的错误。该值也可以从用Header[&ldquo;Referer&rdquo;]获取； 让获取Referer字段变成方法的好处是，编译器可以诊断使用正确单词拼法的req.Referrer()的程序，但却不能诊断使用Header[&ldquo;Referrer&rdquo;]的程序。</p>
<h2 id="func-request-addcookie">func (*Request) AddCookie<a hidden class="anchor" aria-hidden="true" href="#func-request-addcookie">#</a></h2>
<pre><code>func (r *Request) AddCookie(c *Cookie)
</code></pre>
<p>AddCookie向请求中添加一个cookie。按照RFC 6265 section 5.4的跪地，AddCookie不会添加超过一个Cookie头字段。这表示所有的cookie都写在同一行，用分号分隔（cookie内部用逗号分隔属性）。</p>
<h2 id="func-request-setbasicauth">func (*Request) SetBasicAuth<a hidden class="anchor" aria-hidden="true" href="#func-request-setbasicauth">#</a></h2>
<pre><code>func (r *Request) SetBasicAuth(username, password string)
</code></pre>
<p>SetBasicAuth使用提供的用户名和密码，采用HTTP基本认证，设置请求的Authorization头。HTTP基本认证会明码传送用户名和密码。</p>
<h2 id="func-request-write">func (*Request) Write<a hidden class="anchor" aria-hidden="true" href="#func-request-write">#</a></h2>
<pre><code>func (r *Request) Write(w io.Writer) error
</code></pre>
<p>Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：</p>
<pre><code>Host
URL
Method (defaults to &quot;GET&quot;)
Header
ContentLength
TransferEncoding
Body
</code></pre>
<p>如果存在Body，ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为[&ldquo;identity&rdquo;]，Write方法会显式添加&quot;Transfer-Encoding: chunked&quot;到请求的头域。Body字段会在发送完请求后关闭。</p>
<h2 id="func-request-writeproxy">func (*Request) WriteProxy<a hidden class="anchor" aria-hidden="true" href="#func-request-writeproxy">#</a></h2>
<pre><code>func (r *Request) WriteProxy(w io.Writer) error
</code></pre>
<p>WriteProxy类似Write但会将请求以HTTP代理期望的格式发送。</p>
<p>尤其是，按照RFC 2616 Section 5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。</p>
<h2 id="func-request-cookies">func (*Request) Cookies<a hidden class="anchor" aria-hidden="true" href="#func-request-cookies">#</a></h2>
<pre><code>func (r *Request) Cookies() []*Cookie
</code></pre>
<p>Cookies解析并返回该请求的Cookie头设置的cookie。</p>
<h2 id="func-request-cookie">func (*Request) Cookie<a hidden class="anchor" aria-hidden="true" href="#func-request-cookie">#</a></h2>
<pre><code>func (r *Request) Cookie(name string) (*Cookie, error)
</code></pre>
<p>Cookie返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。</p>
<h2 id="func-request-parseform">func (*Request) ParseForm<a hidden class="anchor" aria-hidden="true" href="#func-request-parseform">#</a></h2>
<pre><code>func (r *Request) ParseForm() error
</code></pre>
<p>ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。</p>
<p>对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。</p>
<p>如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。</p>
<p>ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。</p>
<h2 id="func-request-parsemultipartform">func (*Request) ParseMultipartForm<a hidden class="anchor" aria-hidden="true" href="#func-request-parsemultipartform">#</a></h2>
<pre><code>func (r *Request) ParseMultipartForm(maxMemory int64) error
</code></pre>
<p>ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用ParseForm。重复调用本方法是无意义的。</p>
<h2 id="func-request-formvalue">func (*Request) FormValue<a hidden class="anchor" aria-hidden="true" href="#func-request-formvalue">#</a></h2>
<pre><code>func (r *Request) FormValue(key string) string
</code></pre>
<p>FormValue返回查询的命名组件的第一个值。 POST和PUT正文参数优先于URL查询字符串值。 如有必要，FormValue会调用ParseMultipartForm和ParseForm，并忽略这些函数返回的任何错误。 如果key不存在，FormValue将返回空字符串。 要访问同一个键的多个值，请调用ParseForm，然后直接检查Request.Form。</p>
<h2 id="func-request-postformvalue">func (*Request) PostFormValue<a hidden class="anchor" aria-hidden="true" href="#func-request-postformvalue">#</a></h2>
<pre><code>func (r *Request) PostFormValue(key string) string
</code></pre>
<p>PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</p>
<h2 id="func-request-formfile">func (*Request) FormFile<a hidden class="anchor" aria-hidden="true" href="#func-request-formfile">#</a></h2>
<pre><code>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)
</code></pre>
<p>FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。查询失败会返回ErrMissingFile错误。</p>
<h2 id="func-request-multipartreader">func (*Request) MultipartReader<a hidden class="anchor" aria-hidden="true" href="#func-request-multipartreader">#</a></h2>
<pre><code>func (r *Request) MultipartReader() (*multipart.Reader, error)
</code></pre>
<p>如果请求是multipart/form-data POST请求，MultipartReader返回一个multipart.Reader接口，否则返回nil和一个错误。使用本函数代替ParseMultipartForm，可以将r.Body作为流处理。</p>
<h1 id="type-client">type Client<a hidden class="anchor" aria-hidden="true" href="#type-client">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Transport指定执行独立、单次HTTP请求的机制。
</span><span class="c1"></span>    <span class="c1">// 如果Transport为nil，则使用DefaultTransport。
</span><span class="c1"></span>    <span class="nx">Transport</span> <span class="nx">RoundTripper</span>
    <span class="c1">// CheckRedirect指定处理重定向的策略。
</span><span class="c1"></span>    <span class="c1">// 如果CheckRedirect不为nil，客户端会在执行重定向之前调用本函数字段。
</span><span class="c1"></span>    <span class="c1">// 参数req和via是将要执行的请求和已经执行的请求（切片，越新的请求越靠后）。
</span><span class="c1"></span>    <span class="c1">// 如果CheckRedirect返回一个错误，本类型的Get方法不会发送请求req，
</span><span class="c1"></span>    <span class="c1">// 而是返回之前得到的最后一个回复和该错误。（包装进url.Error类型里）
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 如果CheckRedirect为nil，会采用默认策略：连续10此请求后停止。
</span><span class="c1"></span>    <span class="nx">CheckRedirect</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">via</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// Jar指定cookie管理器。
</span><span class="c1"></span>    <span class="c1">// 如果Jar为nil，请求中不会发送cookie，回复中的cookie会被忽略。
</span><span class="c1"></span>    <span class="nx">Jar</span> <span class="nx">CookieJar</span>
    <span class="c1">// Timeout指定本类型的值执行请求的时间限制。
</span><span class="c1"></span>    <span class="c1">// 该超时限制包括连接时间、重定向和读取回复主体的时间。
</span><span class="c1"></span>    <span class="c1">// 计时器会在Head、Get、Post或Do方法返回后继续运作并在超时后中断回复主体的读取。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Timeout为零值表示不设置超时。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Client实例的Transport字段必须支持CancelRequest方法，
</span><span class="c1"></span>    <span class="c1">// 否则Client会在试图用Head、Get、Post或Do方法执行请求时返回错误。
</span><span class="c1"></span>    <span class="c1">// 本类型的Transport字段默认值（DefaultTransport）支持CancelRequest方法。
</span><span class="c1"></span>    <span class="nx">Timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Client类型代表HTTP客户端。它的零值（DefaultClient）是一个可用的使用DefaultTransport的客户端。</p>
<p>Client的Transport字段一般会含有内部状态（缓存TCP连接），因此Client类型值应尽量被重用而不是每次需要都创建新的。Client类型值可以安全的被多个go程同时使用。</p>
<p>Client类型的层次比RoundTripper接口（如Transport）高，还会管理HTTP的cookie和重定向等细节。</p>
<h2 id="func-client-do">func (*Client) Do<a hidden class="anchor" aria-hidden="true" href="#func-client-do">#</a></h2>
<pre><code>func (c *Client) Do(req *Request) (resp *Response, err error)
</code></pre>
<p>Do方法发送请求，返回HTTP回复。它会遵守客户端c设置的策略（如重定向、cookie、认证）。</p>
<p>如果客户端的策略（如重定向）返回错误或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。</p>
<p>如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。如果返回值resp的主体未关闭，c下层的RoundTripper接口（一般为Transport类型）可能无法重用resp主体下层保持的TCP连接去执行之后的请求。</p>
<p>请求的主体，如果非nil，会在执行后被c.Transport关闭，即使出现错误。</p>
<p>一般应使用Get、Post或PostForm方法代替Do方法。</p>
<h2 id="func-client-head">func (*Client) Head<a hidden class="anchor" aria-hidden="true" href="#func-client-head">#</a></h2>
<pre><code>func (c *Client) Head(url string) (resp *Response, err error)
</code></pre>
<p>Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：</p>
<pre><code>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</code></pre>
<h1 id="func-client-get">func (*Client) Get<a hidden class="anchor" aria-hidden="true" href="#func-client-get">#</a></h1>
<pre><code>func (c *Client) Get(url string) (resp *Response, err error)
</code></pre>
<p>Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：</p>
<pre><code>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</code></pre>
<p>如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<h2 id="func-client-post">func (*Client) Post<a hidden class="anchor" aria-hidden="true" href="#func-client-post">#</a></h2>
<pre><code>func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
</code></pre>
<p>Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。</p>
<h2 id="func-client-postform">func (*Client) PostForm<a hidden class="anchor" aria-hidden="true" href="#func-client-postform">#</a></h2>
<pre><code>func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)
</code></pre>
<p>PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。POST数据的类型一般会设为&quot;application/x-www-form-urlencoded&quot;。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<h1 id="type-handler">type Handler<a hidden class="anchor" aria-hidden="true" href="#type-handler">#</a></h1>
<pre><code>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
<p>实现了Handler接口的对象可以注册到HTTP服务端，为特定的路径及其子树提供服务。</p>
<p>ServeHTTP应该将回复的头域和数据写入ResponseWriter接口然后返回。返回标志着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。</p>
<h2 id="func-notfoundhandler">func NotFoundHandler<a hidden class="anchor" aria-hidden="true" href="#func-notfoundhandler">#</a></h2>
<pre><code>func NotFoundHandler() Handler
</code></pre>
<p>NotFoundHandler返回一个简单的请求处理器，该处理器会对每个请求都回复&quot;404 page not found&quot;。</p>
<h2 id="func-redirecthandler">func RedirectHandler<a hidden class="anchor" aria-hidden="true" href="#func-redirecthandler">#</a></h2>
<pre><code>func RedirectHandler(url string, code int) Handler
</code></pre>
<p>RedirectHandler返回一个请求处理器，该处理器会对每个请求都使用状态码code重定向到网址url。</p>
<h2 id="func-timeouthandler">func TimeoutHandler<a hidden class="anchor" aria-hidden="true" href="#func-timeouthandler">#</a></h2>
<pre><code>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler
</code></pre>
<p>TimeoutHandler返回一个采用指定时间限制的请求处理器。</p>
<p>返回的Handler会调用h.ServeHTTP去处理每个请求，但如果某一次调用耗时超过了时间限制，该处理器会回复请求状态码503 Service Unavailable，并将msg作为回复的主体（如果msg为空字符串，将发送一个合理的默认信息）。在超时后，h对它的ResponseWriter接口参数的写入操作会返回ErrHandlerTimeout。</p>
<h2 id="func-stripprefix">func StripPrefix<a hidden class="anchor" aria-hidden="true" href="#func-stripprefix">#</a></h2>
<pre><code>func StripPrefix(prefix string, h Handler) Handler
</code></pre>
<p>StripPrefix返回一个处理器，该处理器会将请求的URL.Path字段中给定前缀prefix去除后再交由h处理。StripPrefix会向URL.Path字段中没有给定前缀的请求回复404 page not found。</p>
<h1 id="type-handlerfunc">type HandlerFunc<a hidden class="anchor" aria-hidden="true" href="#type-handlerfunc">#</a></h1>
<pre><code>type HandlerFunc func(ResponseWriter, *Request)
</code></pre>
<p>HandlerFunc type是一个适配器，通过类型转换让我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。</p>
<h2 id="func-handlerfunc-servehttp">func (HandlerFunc) ServeHTTP<a hidden class="anchor" aria-hidden="true" href="#func-handlerfunc-servehttp">#</a></h2>
<pre><code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
</code></pre>
<p>ServeHTTP方法会调用f(w, r)</p>
<h2 id="type-servemux">type ServeMux<a hidden class="anchor" aria-hidden="true" href="#type-servemux">#</a></h2>
<pre><code>type ServeMux struct {
    // 内含隐藏或非导出字段
}
</code></pre>
<p>ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。</p>
<p>模式是固定的、由根开始的路径，如&quot;/favicon.ico&quot;，或由根开始的子树，如&quot;/images/&quot;（注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式&quot;/images/&ldquo;和&rdquo;/images/thumbnails/&ldquo;都注册了处理器，后一个处理器会用于路径以&rdquo;/images/thumbnails/&ldquo;开始的请求，前一个处理器会接收到其余的路径在&rdquo;/images/&ldquo;子树下的请求。</p>
<p>注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式&rdquo;/&ldquo;会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径&rdquo;/&quot;。</p>
<p>模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式&quot;/codesearch&quot;和&quot;codesearch.google.com/&ldquo;的处理器不会接管目标为&quot;http://www.google.com/&ldquo;的请求。</p>
<p>ServeMux还会注意到请求的URL路径的无害化，将任何路径中包含&rdquo;.&ldquo;或&rdquo;..&ldquo;元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）</p>
<h2 id="func-newservemux">func NewServeMux<a hidden class="anchor" aria-hidden="true" href="#func-newservemux">#</a></h2>
<pre><code>func NewServeMux() *ServeMux
</code></pre>
<p>NewServeMux创建并返回一个新的*ServeMux</p>
<h2 id="func-servemux-handle">func (*ServeMux) Handle<a hidden class="anchor" aria-hidden="true" href="#func-servemux-handle">#</a></h2>
<pre><code>func (mux *ServeMux) Handle(pattern string, handler Handler)
</code></pre>
<p>Handle注册HTTP处理器handler和对应的模式pattern。如果该模式已经注册有一个处理器，Handle会panic。</p>
<h2 id="func-servemux-handlefunc">func (*ServeMux) HandleFunc<a hidden class="anchor" aria-hidden="true" href="#func-servemux-handlefunc">#</a></h2>
<pre><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))
</code></pre>
<p>HandleFunc注册一个处理器函数handler和对应的模式pattern。</p>
<h2 id="func-servemux-handler">func (*ServeMux) Handler<a hidden class="anchor" aria-hidden="true" href="#func-servemux-handler">#</a></h2>
<pre><code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)
</code></pre>
<p>Handler根据r.Method、r.Host和r.URL.Path等数据，返回将用于处理该请求的HTTP处理器。它总是返回一个非nil的处理器。如果路径不是它的规范格式，将返回内建的用于重定向到等价的规范路径的处理器。</p>
<p>Handler也会返回匹配该请求的的已注册模式；在内建重定向处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，本方法将返回一个内建的&quot;404 page not found&quot;处理器和一个空字符串模式。</p>
<h2 id="func-servemux-servehttp">func (*ServeMux) ServeHTTP<a hidden class="anchor" aria-hidden="true" href="#func-servemux-servehttp">#</a></h2>
<pre><code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)
</code></pre>
<p>ServeHTTP将请求派遣到与请求的URL最匹配的模式对应的处理器。</p>
<h1 id="type-server">type Server<a hidden class="anchor" aria-hidden="true" href="#type-server">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Addr</span>           <span class="kt">string</span>        <span class="c1">// 监听的TCP地址，如果为空字符串会使用&#34;:http&#34;
</span><span class="c1"></span>    <span class="nx">Handler</span>        <span class="nx">Handler</span>       <span class="c1">// 调用的处理器，如为nil会调用http.DefaultServeMux
</span><span class="c1"></span>    <span class="nx">ReadTimeout</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// 请求的读取操作在超时前的最大持续时间
</span><span class="c1"></span>    <span class="nx">WriteTimeout</span>   <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// 回复的写入操作在超时前的最大持续时间
</span><span class="c1"></span>    <span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>           <span class="c1">// 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes
</span><span class="c1"></span>    <span class="nx">TLSConfig</span>      <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>   <span class="c1">// 可选的TLS配置，用于ListenAndServeTLS方法
</span><span class="c1"></span>    <span class="c1">// TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。
</span><span class="c1"></span>    <span class="c1">// 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，
</span><span class="c1"></span>    <span class="c1">// 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。
</span><span class="c1"></span>    <span class="c1">// 连接在函数返回时会自动关闭。
</span><span class="c1"></span>    <span class="nx">TLSNextProto</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">)</span>
    <span class="c1">// ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。
</span><span class="c1"></span>    <span class="c1">// 参见ConnState类型和相关常数获取细节。
</span><span class="c1"></span>    <span class="nx">ConnState</span> <span class="kd">func</span><span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ConnState</span><span class="p">)</span>
    <span class="c1">// ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。
</span><span class="c1"></span>    <span class="c1">// 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。
</span><span class="c1"></span>    <span class="nx">ErrorLog</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Server类型定义了运行HTTP服务端的参数。Server的零值是合法的配置。</p>
<h2 id="func-server-setkeepalivesenabled">func (*Server) SetKeepAlivesEnabled<a hidden class="anchor" aria-hidden="true" href="#func-server-setkeepalivesenabled">#</a></h2>
<pre><code>func (s *Server) SetKeepAlivesEnabled(v bool)
</code></pre>
<p>SetKeepAlivesEnabled控制是否允许HTTP闲置连接重用（keep-alive）功能。默认该功能总是被启用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。</p>
<h2 id="func-server-serve">func (*Server) Serve<a hidden class="anchor" aria-hidden="true" href="#func-server-serve">#</a></h2>
<pre><code>func (srv *Server) Serve(l net.Listener) error
</code></pre>
<p>Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用srv.Handler回复请求。</p>
<h2 id="func-server-listenandserve">func (*Server) ListenAndServe<a hidden class="anchor" aria-hidden="true" href="#func-server-listenandserve">#</a></h2>
<pre><code>func (srv *Server) ListenAndServe() error
</code></pre>
<p>ListenAndServe监听srv.Addr指定的TCP地址，并且会调用Serve方法接收到的连接。如果srv.Addr为空字符串，会使用&rdquo;:http&rdquo;。</p>
<h2 id="func-server-listenandservetls">func (*Server) ListenAndServeTLS<a hidden class="anchor" aria-hidden="true" href="#func-server-listenandservetls">#</a></h2>
<pre><code>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error
</code></pre>
<p>ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用&quot;:https&quot;。</p>
<h1 id="type-file">type File<a hidden class="anchor" aria-hidden="true" href="#type-file">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Closer</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
    <span class="nf">Readdir</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">([]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Seek</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">whence</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Stat</span><span class="p">()</span> <span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>File是被FileSystem接口的Open方法返回的接口类型，可以被FileServer等函数用于文件访问服务。</p>
<p>该接口的方法的行为应该和*os.File类型的同名方法相同。</p>
<h1 id="type-filesystem">type FileSystem<a hidden class="anchor" aria-hidden="true" href="#type-filesystem">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FileSystem</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>FileSystem接口实现了对一系列命名文件的访问。文件路径的分隔符为&rsquo;/'，不管主机操作系统的惯例如何。</p>
<h1 id="type-dir">type Dir<a hidden class="anchor" aria-hidden="true" href="#type-dir">#</a></h1>
<pre><code>type Dir string
</code></pre>
<p>Dir使用限制到指定目录树的本地文件系统实现了http.FileSystem接口。空Dir被视为&quot;.&quot;，即代表当前目录。</p>
<h2 id="func-dir-open">func (Dir) Open<a hidden class="anchor" aria-hidden="true" href="#func-dir-open">#</a></h2>
<pre><code>func (d Dir) Open(name string) (File, error)
</code></pre>
<h2 id="func-newfiletransport">func NewFileTransport<a hidden class="anchor" aria-hidden="true" href="#func-newfiletransport">#</a></h2>
<pre><code>func NewFileTransport(fs FileSystem) RoundTripper
</code></pre>
<p>NewFileTransport返回一个RoundTripper接口，使用FileSystem接口fs提供文件访问服务。 返回的RoundTripper接口会忽略接收的请求的URL主机及其他绝大多数属性。</p>
<p>NewFileTransport函数的典型使用情况是给Transport类型的值注册&quot;file&quot;协议，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Transport</span><span class="p">{}</span>
<span class="nx">t</span><span class="p">.</span><span class="nf">RegisterProtocol</span><span class="p">(</span><span class="s">&#34;file&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewFileTransport</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">)))</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Transport</span><span class="p">:</span> <span class="nx">t</span><span class="p">}</span>
<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;file:///etc/passwd&#34;</span><span class="p">)</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-fileserver">func FileServer<a hidden class="anchor" aria-hidden="true" href="#func-fileserver">#</a></h1>
<pre><code>func FileServer(root FileSystem) Handler
</code></pre>
<p>FileServer返回一个使用FileSystem接口root提供文件访问服务的HTTP处理器。要使用操作系统的FileSystem接口实现，可使用http.Dir：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;/tmp&#34;</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-proxyurl">func ProxyURL<a hidden class="anchor" aria-hidden="true" href="#func-proxyurl">#</a></h1>
<pre><code>func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)
</code></pre>
<p>ProxyURL返回一个代理函数（用于Transport类型），该函数总是返回同一个URL。</p>
<h1 id="func-proxyfromenvironment">func ProxyFromEnvironment<a hidden class="anchor" aria-hidden="true" href="#func-proxyfromenvironment">#</a></h1>
<pre><code>func ProxyFromEnvironment(req *Request) (*url.URL, error)
</code></pre>
<p>ProxyFromEnvironment使用环境变量$HTTP_PROXY和$NO_PROXY(或$http_proxy和$no_proxy)的配置返回用于req的代理。如果代理环境不合法将返回错误；如果环境未设定代理或者给定的request不应使用代理时，将返回(nil, nil)；如果req.URL.Host字段是&quot;localhost&quot;（可以有端口号，也可以没有），也会返回(nil, nil)。</p>
<h1 id="func-setcookie">func SetCookie<a hidden class="anchor" aria-hidden="true" href="#func-setcookie">#</a></h1>
<pre><code>func SetCookie(w ResponseWriter, cookie *Cookie)
</code></pre>
<p>SetCookie在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。</p>
<h1 id="func-redirect">func Redirect<a hidden class="anchor" aria-hidden="true" href="#func-redirect">#</a></h1>
<pre><code>func Redirect(w ResponseWriter, r *Request, urlStr string, code int)
</code></pre>
<p>Redirect回复请求一个重定向地址urlStr和状态码code。该重定向地址可以是相对于请求r的相对地址。</p>
<h1 id="func-notfound">func NotFound<a hidden class="anchor" aria-hidden="true" href="#func-notfound">#</a></h1>
<pre><code>func NotFound(w ResponseWriter, r *Request)
</code></pre>
<p>NotFound回复请求404状态码（not found：目标未发现）。</p>
<h1 id="func-error">func Error<a hidden class="anchor" aria-hidden="true" href="#func-error">#</a></h1>
<pre><code>func Error(w ResponseWriter, error string, code int)
</code></pre>
<p>Error使用指定的错误信息和状态码回复请求，将数据写入w。错误信息必须是明文。</p>
<h1 id="func-servecontent">func ServeContent<a hidden class="anchor" aria-hidden="true" href="#func-servecontent">#</a></h1>
<pre><code>func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)
</code></pre>
<p>ServeContent使用提供的ReadSeeker的内容回复请求。ServeContent比起io.Copy函数的主要优点，是可以处理范围类请求（只要一部分内容）、设置MIME类型，处理If-Modified-Since请求。</p>
<p>如果未设定回复的Content-Type头，本函数首先会尝试从name的文件扩展名推断数据类型；如果失败，会用读取content的第1块数据并提供给DetectContentType推断类型；之后会设置Content-Type头。参数name不会用于别的地方，甚至于它可以是空字符串，也永远不会发送到回复里。</p>
<p>如果modtime不是Time零值，函数会在回复的头域里设置Last-Modified头。如果请求的头域包含If-Modified-Since头，本函数会使用modtime参数来确定是否应该发送内容。如果调用者设置了w的ETag头，ServeContent会使用它处理包含If-Range头和If-None-Match头的请求。</p>
<p>参数content的Seek方法必须有效：函数使用Seek来确定它的大小。</p>
<p>注意：本包File接口和*os.File类型都实现了io.ReadSeeker接口。</p>
<h1 id="func-servefile">func ServeFile<a hidden class="anchor" aria-hidden="true" href="#func-servefile">#</a></h1>
<pre><code>func ServeFile(w ResponseWriter, r *Request, name string)
</code></pre>
<p>ServeFile回复请求name指定的文件或者目录的内容。</p>
<h1 id="func-maxbytesreader">func MaxBytesReader<a hidden class="anchor" aria-hidden="true" href="#func-maxbytesreader">#</a></h1>
<pre><code>func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser
</code></pre>
<p>MaxBytesReader类似io.LimitReader，但它是用来限制接收到的请求的Body的大小的。不同于io.LimitReader，本函数返回一个ReadCloser，返回值的Read方法在读取的数据超过大小限制时会返回非EOF错误，其Close方法会关闭下层的io.ReadCloser接口r。</p>
<p>MaxBytesReader预防客户端因为意外或者蓄意发送的“大”请求，以避免尺寸过大的请求浪费服务端资源。</p>
<h1 id="func-head">func Head<a hidden class="anchor" aria-hidden="true" href="#func-head">#</a></h1>
<pre><code>func Head(url string) (resp *Response, err error)
</code></pre>
<p>Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mi">301</span> <span class="p">(</span><span class="nx">Moved</span> <span class="nx">Permanently</span><span class="p">)</span>
<span class="mi">302</span> <span class="p">(</span><span class="nx">Found</span><span class="p">)</span>
<span class="mi">303</span> <span class="p">(</span><span class="nx">See</span> <span class="nx">Other</span><span class="p">)</span>
<span class="mi">307</span> <span class="p">(</span><span class="nx">Temporary</span> <span class="nx">Redirect</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Head是对包变量DefaultClient的Head方法的包装。</p>
<h1 id="func-get">func Get<a hidden class="anchor" aria-hidden="true" href="#func-get">#</a></h1>
<pre><code>func Get(url string) (resp *Response, err error)
</code></pre>
<p>Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mi">301</span> <span class="p">(</span><span class="nx">Moved</span> <span class="nx">Permanently</span><span class="p">)</span>
<span class="mi">302</span> <span class="p">(</span><span class="nx">Found</span><span class="p">)</span>
<span class="mi">303</span> <span class="p">(</span><span class="nx">See</span> <span class="nx">Other</span><span class="p">)</span>
<span class="mi">307</span> <span class="p">(</span><span class="nx">Temporary</span> <span class="nx">Redirect</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<p>Get是对包变量DefaultClient的Get方法的包装。</p>
<h1 id="func-post">func Post<a hidden class="anchor" aria-hidden="true" href="#func-post">#</a></h1>
<pre><code>func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
</code></pre>
<p>Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。</p>
<p>Post是对包变量DefaultClient的Post方法的包装。</p>
<h1 id="func-postform">func PostForm<a hidden class="anchor" aria-hidden="true" href="#func-postform">#</a></h1>
<pre><code>func PostForm(url string, data url.Values) (resp *Response, err error)
</code></pre>
<p>PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<p>PostForm是对包变量DefaultClient的PostForm方法的包装。</p>
<h1 id="func-handle">func Handle<a hidden class="anchor" aria-hidden="true" href="#func-handle">#</a></h1>
<pre><code>func Handle(pattern string, handler Handler)
</code></pre>
<p>Handle注册HTTP处理器handler和对应的模式pattern（注册到DefaultServeMux）。如果该模式已经注册有一个处理器，Handle会panic。ServeMux的文档解释了模式的匹配机制。</p>
<h1 id="func-handlefunc">func HandleFunc<a hidden class="anchor" aria-hidden="true" href="#func-handlefunc">#</a></h1>
<pre><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
</code></pre>
<p>HandleFunc注册一个处理器函数handler和对应的模式pattern（注册到DefaultServeMux）。ServeMux的文档解释了模式的匹配机制。</p>
<h1 id="func-serve">func Serve<a hidden class="anchor" aria-hidden="true" href="#func-serve">#</a></h1>
<pre><code>func Serve(l net.Listener, handler Handler) error
</code></pre>
<p>Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用handler回复请求。handler参数一般会设为nil，此时会使用DefaultServeMux。</p>
<h1 id="func-listenandserve">func ListenAndServe<a hidden class="anchor" aria-hidden="true" href="#func-listenandserve">#</a></h1>
<pre><code>func ListenAndServe(addr string, handler Handler) error
</code></pre>
<p>ListenAndServe监听TCP地址addr，并且会使用handler参数调用Serve函数处理接收到的连接。handler参数一般会设为nil，此时会使用DefaultServeMux。</p>
<p>一个简单的服务端例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;log&#34;</span>
<span class="p">)</span>
<span class="c1">// hello world, the web server
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HelloServer</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;hello, world!\n&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/hello&#34;</span><span class="p">,</span> <span class="nx">HelloServer</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:12345&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;ListenAndServe: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-listenandservetls">func ListenAndServeTLS<a hidden class="anchor" aria-hidden="true" href="#func-listenandservetls">#</a></h1>
<pre><code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error
</code></pre>
<p>ListenAndServeTLS函数和ListenAndServe函数的行为基本一致，除了它期望HTTPS连接之外。此外，必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用&quot;:https&quot;。</p>
<p>一个简单的服务端例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;text/plain&#34;</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;This is an example server.\n&#34;</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;About to listen on 10443. Go to https://127.0.0.1:10443/&#34;</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServeTLS</span><span class="p">(</span><span class="s">&#34;:10443&#34;</span><span class="p">,</span> <span class="s">&#34;cert.pem&#34;</span><span class="p">,</span> <span class="s">&#34;key.pem&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序员可以使用crypto/tls包的generate_cert.go文件来生成cert.pem和key.pem两个文件。</p>
<h1 id="type-cookie">type Cookie<a hidden class="anchor" aria-hidden="true" href="#type-cookie">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cookie</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span>       <span class="kt">string</span>
    <span class="nx">Value</span>      <span class="kt">string</span>
    <span class="nx">Path</span>       <span class="kt">string</span>
    <span class="nx">Domain</span>     <span class="kt">string</span>
    <span class="nx">Expires</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">RawExpires</span> <span class="kt">string</span>
    <span class="c1">// MaxAge=0表示未设置Max-Age属性
</span><span class="c1"></span>    <span class="c1">// MaxAge&lt;0表示立刻删除该cookie，等价于&#34;Max-Age: 0&#34;
</span><span class="c1"></span>    <span class="c1">// MaxAge&gt;0表示存在Max-Age属性，单位是秒
</span><span class="c1"></span>    <span class="nx">MaxAge</span>   <span class="kt">int</span>
    <span class="nx">Secure</span>   <span class="kt">bool</span>
    <span class="nx">HttpOnly</span> <span class="kt">bool</span>
    <span class="nx">Raw</span>      <span class="kt">string</span>
    <span class="nx">Unparsed</span> <span class="p">[]</span><span class="kt">string</span> <span class="c1">// 未解析的“属性-值”对的原始文本
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Cookie代表一个出现在HTTP回复的头域中Set-Cookie头的值里或者HTTP请求的头域中Cookie头的值里的HTTP cookie。</p>
<h2 id="func-cookie-string">func (*Cookie) String<a hidden class="anchor" aria-hidden="true" href="#func-cookie-string">#</a></h2>
<pre><code>func (c *Cookie) String() string
</code></pre>
<p>String返回该cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。</p>
<h1 id="type-cookiejar">type CookieJar<a hidden class="anchor" aria-hidden="true" href="#type-cookiejar">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CookieJar</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// SetCookies管理从u的回复中收到的cookie
</span><span class="c1"></span>    <span class="c1">// 根据其策略和实现，它可以选择是否存储cookie
</span><span class="c1"></span>    <span class="nf">SetCookies</span><span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">cookies</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Cookie</span><span class="p">)</span>
    <span class="c1">// Cookies返回发送请求到u时应使用的cookie
</span><span class="c1"></span>    <span class="c1">// 本方法有责任遵守RFC 6265规定的标准cookie限制
</span><span class="c1"></span>    <span class="nf">Cookies</span><span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Cookie</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CookieJar管理cookie的存储和在HTTP请求中的使用。CookieJar的实现必须能安全的被多个go程同时使用。</p>
<p>net/http/cookiejar包提供了一个CookieJar的实现。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93%E4%BD%BF%E7%94%A8/">Go标准库使用</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
