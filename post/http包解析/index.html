<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>http包解析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.1 with theme even" />


<link rel="canonical" href="/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="http包解析" />
<meta property="og:description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/http%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:28:57+00:00" />
<meta property="article:modified_time" content="2018-11-15T18:28:57+00:00" />

<meta itemprop="name" content="http包解析">
<meta itemprop="description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent"><meta itemprop="datePublished" content="2018-11-15T18:28:57+00:00" />
<meta itemprop="dateModified" content="2018-11-15T18:28:57+00:00" />
<meta itemprop="wordCount" content="19513">
<meta itemprop="keywords" content="Go标准库使用," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="http包解析"/>
<meta name="twitter:description" content="预设值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const ( StatusContinue = 100 StatusSwitchingProtocols = 101 StatusOK = 200 StatusCreated = 201 StatusAccepted = 202 StatusNonAuthoritativeInfo = 203 StatusNoContent = 204 StatusResetContent"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">http包解析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-15 </span>
        <div class="post-category">
            <a href="/categories/go%E6%A0%87%E5%87%86%E5%BA%93%E4%BD%BF%E7%94%A8/"> Go标准库使用 </a>
            </div>
          <span class="more-meta"> 约 19513 字 </span>
          <span class="more-meta"> 预计阅读 39 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#variables">Variables</a></li>
  </ul>

  <ul>
    <li><a href="#func-protocolerror-error">func (*ProtocolError) Error</a></li>
  </ul>

  <ul>
    <li><a href="#func-header-get">func (Header) Get</a></li>
    <li><a href="#func-header-set">func (Header) Set</a></li>
    <li><a href="#func-header-add">func (Header) Add</a></li>
    <li><a href="#func-header-del">func (Header) Del</a></li>
    <li><a href="#func-header-write">func (Header) Write</a></li>
    <li><a href="#func-header-writesubset">func (Header) WriteSubset</a></li>
  </ul>

  <ul>
    <li><a href="#func-readresponse">func ReadResponse</a></li>
    <li><a href="#func-response-protoatleast">func (*Response) ProtoAtLeast</a></li>
    <li><a href="#func-response-cookies">func (*Response) Cookies</a></li>
    <li><a href="#func-response-location">func (*Response) Location</a></li>
    <li><a href="#func-response-write">func (*Response) Write</a></li>
  </ul>

  <ul>
    <li><a href="#func-transport-registerprotocol">func (*Transport) RegisterProtocol</a></li>
    <li><a href="#func-transport-roundtrip">func (*Transport) RoundTrip</a></li>
    <li><a href="#func-transport-closeidleconnections">func (*Transport) CloseIdleConnections</a></li>
    <li><a href="#func-transport-cancelrequest">func (*Transport) CancelRequest</a></li>
  </ul>

  <ul>
    <li><a href="#func-newrequest">func NewRequest</a></li>
    <li><a href="#func-readrequest">func ReadRequest</a></li>
    <li><a href="#func-request-protoatleast">func (*Request) ProtoAtLeast</a></li>
    <li><a href="#func-request-useragent">func (*Request) UserAgent</a></li>
    <li><a href="#func-request-referer">func (*Request) Referer</a></li>
    <li><a href="#func-request-addcookie">func (*Request) AddCookie</a></li>
    <li><a href="#func-request-setbasicauth">func (*Request) SetBasicAuth</a></li>
    <li><a href="#func-request-write">func (*Request) Write</a></li>
    <li><a href="#func-request-writeproxy">func (*Request) WriteProxy</a></li>
    <li><a href="#func-request-cookies">func (*Request) Cookies</a></li>
    <li><a href="#func-request-cookie">func (*Request) Cookie</a></li>
    <li><a href="#func-request-parseform">func (*Request) ParseForm</a></li>
    <li><a href="#func-request-parsemultipartform">func (*Request) ParseMultipartForm</a></li>
    <li><a href="#func-request-formvalue">func (*Request) FormValue</a></li>
    <li><a href="#func-request-postformvalue">func (*Request) PostFormValue</a></li>
    <li><a href="#func-request-formfile">func (*Request) FormFile</a></li>
    <li><a href="#func-request-multipartreader">func (*Request) MultipartReader</a></li>
  </ul>

  <ul>
    <li><a href="#func-client-do">func (*Client) Do</a></li>
    <li><a href="#func-client-head">func (*Client) Head</a></li>
  </ul>

  <ul>
    <li><a href="#func-client-post">func (*Client) Post</a></li>
    <li><a href="#func-client-postform">func (*Client) PostForm</a></li>
  </ul>

  <ul>
    <li><a href="#func-notfoundhandler">func NotFoundHandler</a></li>
    <li><a href="#func-redirecthandler">func RedirectHandler</a></li>
    <li><a href="#func-timeouthandler">func TimeoutHandler</a></li>
    <li><a href="#func-stripprefix">func StripPrefix</a></li>
  </ul>

  <ul>
    <li><a href="#func-handlerfunc-servehttp">func (HandlerFunc) ServeHTTP</a></li>
    <li><a href="#type-servemux">type ServeMux</a></li>
    <li><a href="#func-newservemux">func NewServeMux</a></li>
    <li><a href="#func-servemux-handle">func (*ServeMux) Handle</a></li>
    <li><a href="#func-servemux-handlefunc">func (*ServeMux) HandleFunc</a></li>
    <li><a href="#func-servemux-handler">func (*ServeMux) Handler</a></li>
    <li><a href="#func-servemux-servehttp">func (*ServeMux) ServeHTTP</a></li>
  </ul>

  <ul>
    <li><a href="#func-server-setkeepalivesenabled">func (*Server) SetKeepAlivesEnabled</a></li>
    <li><a href="#func-server-serve">func (*Server) Serve</a></li>
    <li><a href="#func-server-listenandserve">func (*Server) ListenAndServe</a></li>
    <li><a href="#func-server-listenandservetls">func (*Server) ListenAndServeTLS</a></li>
  </ul>

  <ul>
    <li><a href="#func-dir-open">func (Dir) Open</a></li>
    <li><a href="#func-newfiletransport">func NewFileTransport</a></li>
  </ul>

  <ul>
    <li><a href="#func-cookie-string">func (*Cookie) String</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="预设值">预设值</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">StatusContinue</span>           <span class="p">=</span> <span class="mi">100</span>
    <span class="nx">StatusSwitchingProtocols</span> <span class="p">=</span> <span class="mi">101</span>
    <span class="nx">StatusOK</span>                   <span class="p">=</span> <span class="mi">200</span>
    <span class="nx">StatusCreated</span>              <span class="p">=</span> <span class="mi">201</span>
    <span class="nx">StatusAccepted</span>             <span class="p">=</span> <span class="mi">202</span>
    <span class="nx">StatusNonAuthoritativeInfo</span> <span class="p">=</span> <span class="mi">203</span>
    <span class="nx">StatusNoContent</span>            <span class="p">=</span> <span class="mi">204</span>
    <span class="nx">StatusResetContent</span>         <span class="p">=</span> <span class="mi">205</span>
    <span class="nx">StatusPartialContent</span>       <span class="p">=</span> <span class="mi">206</span>
    <span class="nx">StatusMultipleChoices</span>   <span class="p">=</span> <span class="mi">300</span>
    <span class="nx">StatusMovedPermanently</span>  <span class="p">=</span> <span class="mi">301</span>
    <span class="nx">StatusFound</span>             <span class="p">=</span> <span class="mi">302</span>
    <span class="nx">StatusSeeOther</span>          <span class="p">=</span> <span class="mi">303</span>
    <span class="nx">StatusNotModified</span>       <span class="p">=</span> <span class="mi">304</span>
    <span class="nx">StatusUseProxy</span>          <span class="p">=</span> <span class="mi">305</span>
    <span class="nx">StatusTemporaryRedirect</span> <span class="p">=</span> <span class="mi">307</span>
    <span class="nx">StatusBadRequest</span>                   <span class="p">=</span> <span class="mi">400</span>
    <span class="nx">StatusUnauthorized</span>                 <span class="p">=</span> <span class="mi">401</span>
    <span class="nx">StatusPaymentRequired</span>              <span class="p">=</span> <span class="mi">402</span>
    <span class="nx">StatusForbidden</span>                    <span class="p">=</span> <span class="mi">403</span>
    <span class="nx">StatusNotFound</span>                     <span class="p">=</span> <span class="mi">404</span>
    <span class="nx">StatusMethodNotAllowed</span>             <span class="p">=</span> <span class="mi">405</span>
    <span class="nx">StatusNotAcceptable</span>                <span class="p">=</span> <span class="mi">406</span>
    <span class="nx">StatusProxyAuthRequired</span>            <span class="p">=</span> <span class="mi">407</span>
    <span class="nx">StatusRequestTimeout</span>               <span class="p">=</span> <span class="mi">408</span>
    <span class="nx">StatusConflict</span>                     <span class="p">=</span> <span class="mi">409</span>
    <span class="nx">StatusGone</span>                         <span class="p">=</span> <span class="mi">410</span>
    <span class="nx">StatusLengthRequired</span>               <span class="p">=</span> <span class="mi">411</span>
    <span class="nx">StatusPreconditionFailed</span>           <span class="p">=</span> <span class="mi">412</span>
    <span class="nx">StatusRequestEntityTooLarge</span>        <span class="p">=</span> <span class="mi">413</span>
    <span class="nx">StatusRequestURITooLong</span>            <span class="p">=</span> <span class="mi">414</span>
    <span class="nx">StatusUnsupportedMediaType</span>         <span class="p">=</span> <span class="mi">415</span>
    <span class="nx">StatusRequestedRangeNotSatisfiable</span> <span class="p">=</span> <span class="mi">416</span>
    <span class="nx">StatusExpectationFailed</span>            <span class="p">=</span> <span class="mi">417</span>
    <span class="nx">StatusTeapot</span>                       <span class="p">=</span> <span class="mi">418</span>
    <span class="nx">StatusInternalServerError</span>     <span class="p">=</span> <span class="mi">500</span>
    <span class="nx">StatusNotImplemented</span>          <span class="p">=</span> <span class="mi">501</span>
    <span class="nx">StatusBadGateway</span>              <span class="p">=</span> <span class="mi">502</span>
    <span class="nx">StatusServiceUnavailable</span>      <span class="p">=</span> <span class="mi">503</span>
    <span class="nx">StatusGatewayTimeout</span>          <span class="p">=</span> <span class="mi">504</span>
    <span class="nx">StatusHTTPVersionNotSupported</span> <span class="p">=</span> <span class="mi">505</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><pre><code>const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB
</code></pre>
<p>DefaultMaxHeaderBytes是HTTP请求的头域最大允许长度。可以通过设置Server.MaxHeaderBytes字段来覆盖。</p>
<pre><code>const DefaultMaxIdleConnsPerHost = 2
</code></pre>
<p>DefaultMaxIdleConnsPerHost是Transport的MaxIdleConnsPerHost的默认值。</p>
<pre><code>const TimeFormat = &quot;Mon, 02 Jan 2006 15:04:05 GMT&quot;
</code></pre>
<p>TimeFormat是当解析或生产HTTP头域中的时间时，用与time.Parse或time.Format函数的时间格式。这种格式类似time.RFC1123但强制采用GMT时区。</p>
<h2 id="variables">Variables</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrHeaderTooLong</span>        <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;header too long&#34;</span><span class="p">}</span>
    <span class="nx">ErrShortBody</span>            <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;entity body too short&#34;</span><span class="p">}</span>
    <span class="nx">ErrNotSupported</span>         <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;feature not supported&#34;</span><span class="p">}</span>
    <span class="nx">ErrUnexpectedTrailer</span>    <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;trailer header without chunked transfer encoding&#34;</span><span class="p">}</span>
    <span class="nx">ErrMissingContentLength</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;missing ContentLength in HEAD response&#34;</span><span class="p">}</span>
    <span class="nx">ErrNotMultipart</span>         <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;request Content-Type isn&#39;t multipart/form-data&#34;</span><span class="p">}</span>
    <span class="nx">ErrMissingBoundary</span>      <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ProtocolError</span><span class="p">{</span><span class="s">&#34;no multipart boundary param in Content-Type&#34;</span><span class="p">}</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP请求的解析错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrWriteAfterFlush</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Conn.Write called after Flush&#34;</span><span class="p">)</span>
    <span class="nx">ErrBodyNotAllowed</span>  <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: request method or response status code does not allow body&#34;</span><span class="p">)</span>
    <span class="nx">ErrHijacked</span>        <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Conn has been hijacked&#34;</span><span class="p">)</span>
    <span class="nx">ErrContentLength</span>   <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Conn.Write wrote more than the declared Content-Length&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>会被HTTP服务端返回的错误。</p>
<pre><code>var DefaultClient = &amp;Client{}
</code></pre>
<p>DefaultClient是用于包函数Get、Head和Post的默认Client。</p>
<pre><code>var DefaultServeMux = NewServeMux()
</code></pre>
<p>DefaultServeMux是用于Serve的默认ServeMux。</p>
<pre><code>var ErrBodyReadAfterClose = errors.New(&quot;http: invalid Read on closed Body&quot;)
</code></pre>
<p>在Resquest或Response的Body字段已经关闭后，试图从中读取时，就会返回ErrBodyReadAfterClose。这个错误一般发生在：HTTP处理器中调用完ResponseWriter 接口的WriteHeader或Write后从请求中读取数据的时候。</p>
<pre><code>var ErrHandlerTimeout = errors.New(&quot;http: Handler timeout&quot;)
</code></pre>
<p>在处理器超时以后调用ResponseWriter接口的Write方法，就会返回ErrHandlerTimeout。</p>
<pre><code>var ErrLineTooLong = errors.New(&quot;header line too long&quot;)
var ErrMissingFile = errors.New(&quot;http: no such file&quot;)
</code></pre>
<p>当请求中没有提供给FormFile函数的文件字段名，或者该字段名不是文件字段时，该函数就会返回ErrMissingFile。</p>
<pre><code>var ErrNoCookie = errors.New(&quot;http: named cookie not present&quot;)
var ErrNoLocation = errors.New(&quot;http: no Location header in response&quot;)
</code></pre>
<h1 id="type-protocolerror">type ProtocolError</h1>
<p>type ProtocolError struct {
ErrorString string
}</p>
<p>HTTP请求解析错误。</p>
<h2 id="func-protocolerror-error">func (*ProtocolError) Error</h2>
<pre><code>func (err *ProtocolError) Error() string
</code></pre>
<h1 id="func-canonicalheaderkey">func CanonicalHeaderKey</h1>
<pre><code>func CanonicalHeaderKey(s string) string
</code></pre>
<p>CanonicalHeaderKey函数返回头域（表示为Header类型）的键s的规范化格式。规范化过程中让单词首字母和'-&lsquo;后的第一个字母大写，其余字母小写。例如，&ldquo;accept-encoding&quot;规范化为&quot;Accept-Encoding&rdquo;。</p>
<h1 id="func-detectcontenttype">func DetectContentType</h1>
<pre><code>func DetectContentType(data []byte) string
</code></pre>
<p>DetectContentType函数实现了<a href="http://mimesniff.spec.whatwg.org/%E6%8F%8F%E8%BF%B0%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%9A%84Content-Type%E3%80%82%E5%87%BD%E6%95%B0%E6%80%BB%E6%98%AF%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%90%88%E6%B3%95%E7%9A%84MIME">http://mimesniff.spec.whatwg.org/描述的算法，用于确定数据的Content-Type。函数总是返回一个合法的MIME</a>类型；如果它不能确定数据的类型，将返回&quot;application/octet-stream&quot;。它最多检查数据的前512字节。</p>
<h1 id="func-parsehttpversion">func ParseHTTPVersion</h1>
<pre><code>func ParseHTTPVersion(vers string) (major, minor int, ok bool)
</code></pre>
<p>ParseHTTPVersion解析HTTP版本字符串。如&quot;HTTP/1.0&quot;返回(1, 0, true)。</p>
<h1 id="func-parsetime">func ParseTime</h1>
<pre><code>func ParseTime(text string) (t time.Time, err error)
</code></pre>
<p>ParseTime用3种格式TimeFormat,</p>
<p>time.RFC850和time.ANSIC尝试解析一个时间头的值（如Date: header）。</p>
<h1 id="func-statustext">func StatusText</h1>
<p>func StatusText(code int) string
StatusText返回HTTP状态码code对应的文本，如220对应&quot;OK&quot;。如果code是未知的状态码，会返回&quot;&quot;。</p>
<h1 id="type-connstate">type ConnState</h1>
<pre><code>type ConnState int
</code></pre>
<p>ConnState代表一个客户端到服务端的连接的状态。本类型用于可选的Server.ConnState回调函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// StateNew代表一个新的连接，将要立刻发送请求。
</span><span class="c1"></span>    <span class="c1">// 连接从这个状态开始，然后转变为StateAlive或StateClosed。
</span><span class="c1"></span>    <span class="nx">StateNew</span> <span class="nx">ConnState</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="c1">// StateActive代表一个已经读取了请求数据1到多个字节的连接。
</span><span class="c1"></span>    <span class="c1">// 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，
</span><span class="c1"></span>    <span class="c1">// 等到请求被处理完后，Server.ConnState回调函数再次被触发。
</span><span class="c1"></span>    <span class="c1">// 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。
</span><span class="c1"></span>    <span class="nx">StateActive</span>
    <span class="c1">// StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。
</span><span class="c1"></span>    <span class="c1">// 连接状态可以从StateIdle改变为StateActive或StateClosed。
</span><span class="c1"></span>    <span class="nx">StateIdle</span>
    <span class="c1">// 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。
</span><span class="c1"></span>    <span class="nx">StateHijacked</span>
    <span class="c1">// StateClosed代表一个关闭的连接。
</span><span class="c1"></span>    <span class="c1">// 这是一个终止状态。被劫持的连接不会转变为StateClosed。
</span><span class="c1"></span>    <span class="nx">StateClosed</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-connstate-string">func (ConnState) String</h1>
<pre><code>func (c ConnState) String() string
</code></pre>
<h1 id="type-header">type Header</h1>
<pre><code>type Header map[string][]string
</code></pre>
<p>Header代表HTTP头域的键值对。</p>
<h2 id="func-header-get">func (Header) Get</h2>
<pre><code>func (h Header) Get(key string) string
</code></pre>
<p>Get返回键对应的第一个值，如果键不存在会返回&quot;&quot;。如要获取该键对应的值切片，请直接用规范格式的键访问map。</p>
<h2 id="func-header-set">func (Header) Set</h2>
<pre><code>func (h Header) Set(key, value string)
</code></pre>
<p>Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。</p>
<h2 id="func-header-add">func (Header) Add</h2>
<pre><code>func (h Header) Add(key, value string)
</code></pre>
<p>Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。</p>
<h2 id="func-header-del">func (Header) Del</h2>
<pre><code>func (h Header) Del(key string)
</code></pre>
<p>Del删除键值对。</p>
<h2 id="func-header-write">func (Header) Write</h2>
<pre><code>func (h Header) Write(w io.Writer) error
</code></pre>
<p>Write以有线格式将头域写入w。</p>
<h2 id="func-header-writesubset">func (Header) WriteSubset</h2>
<pre><code>func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error
</code></pre>
<p>WriteSubset以有线格式将头域写入w。当exclude不为nil时，如果h的键值对的键在exclude中存在且其对应值为真，该键值对就不会被写入w。</p>
<h1 id="type-response">type Response</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Status</span>     <span class="kt">string</span> <span class="c1">// 例如&#34;200 OK&#34;
</span><span class="c1"></span>    <span class="nx">StatusCode</span> <span class="kt">int</span>    <span class="c1">// 例如200
</span><span class="c1"></span>    <span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// 例如&#34;HTTP/1.0&#34;
</span><span class="c1"></span>    <span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// 例如1
</span><span class="c1"></span>    <span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// 例如0
</span><span class="c1"></span>    <span class="c1">// Header保管头域的键值对。
</span><span class="c1"></span>    <span class="c1">// 如果回复中有多个头的键相同，Header中保存为该键对应用逗号分隔串联起来的这些头的值
</span><span class="c1"></span>    <span class="c1">// （参见RFC 2616 Section 4.2）
</span><span class="c1"></span>    <span class="c1">// 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Header中的键都是规范化的，参见CanonicalHeaderKey函数
</span><span class="c1"></span>    <span class="nx">Header</span> <span class="nx">Header</span>
    <span class="c1">// Body代表回复的主体。
</span><span class="c1"></span>    <span class="c1">// Client类型和Transport类型会保证Body字段总是非nil的，即使回复没有主体或主体长度为0。
</span><span class="c1"></span>    <span class="c1">// 关闭主体是调用者的责任。
</span><span class="c1"></span>    <span class="c1">// 如果服务端采用&#34;chunked&#34;传输编码发送的回复，Body字段会自动进行解码。
</span><span class="c1"></span>    <span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>
    <span class="c1">// ContentLength记录相关内容的长度。
</span><span class="c1"></span>    <span class="c1">// 其值为-1表示长度未知（采用chunked传输编码）
</span><span class="c1"></span>    <span class="c1">// 除非对应的Request.Method是&#34;HEAD&#34;，其值&gt;=0表示可以从Body读取的字节数
</span><span class="c1"></span>    <span class="nx">ContentLength</span> <span class="kt">int64</span>
    <span class="c1">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示&#34;identity&#34;编码。
</span><span class="c1"></span>    <span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="c1">// Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）
</span><span class="c1"></span>    <span class="c1">// 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。
</span><span class="c1"></span>    <span class="nx">Close</span> <span class="kt">bool</span>
    <span class="c1">// Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型
</span><span class="c1"></span>    <span class="nx">Trailer</span> <span class="nx">Header</span>
    <span class="c1">// Request是用来获取此回复的请求
</span><span class="c1"></span>    <span class="c1">// Request的Body字段是nil（因为已经被用掉了）
</span><span class="c1"></span>    <span class="c1">// 这个字段是被Client类型发出请求并获得回复后填充的
</span><span class="c1"></span>    <span class="nx">Request</span> <span class="o">*</span><span class="nx">Request</span>
    <span class="c1">// TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。
</span><span class="c1"></span>    <span class="c1">// 返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。
</span><span class="c1"></span>    <span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Response代表一个HTTP请求的回复。</p>
<h2 id="func-readresponse">func ReadResponse</h2>
<pre><code>func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)
</code></pre>
<p>ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的trailer的键值对。（本函数主要用在客户端从下层获取回复）</p>
<h2 id="func-response-protoatleast">func (*Response) ProtoAtLeast</h2>
<pre><code>func (r *Response) ProtoAtLeast(major, minor int) bool
</code></pre>
<p>ProtoAtLeast报告该回复使用的HTTP协议版本至少是major.minor。</p>
<h2 id="func-response-cookies">func (*Response) Cookies</h2>
<pre><code>func (r *Response) Cookies() []*Cookie
</code></pre>
<p>Cookies解析并返回该回复中的Set-Cookie头设置的cookie。</p>
<h2 id="func-response-location">func (*Response) Location</h2>
<pre><code>func (r *Response) Location() (*url.URL, error)
</code></pre>
<p>Location返回该回复的Location头设置的URL。相对地址的重定向会相对于该回复对应的请求来确定绝对地址。如果回复中没有Location头，会返回nil, ErrNoLocation。</p>
<h2 id="func-response-write">func (*Response) Write</h2>
<pre><code>func (r *Response) Write(w io.Writer) error
</code></pre>
<p>Write以有线格式将回复写入w（用于将回复写入下层TCPConn等）。本方法会考虑如下字段：</p>
<pre><code>StatusCode
ProtoMajor
ProtoMinor
Request.Method
TransferEncoding
Trailer
Body
ContentLength
Header（不规范的键名和它对应的值会导致不可预知的行为）
</code></pre>
<p>Body字段在发送完回复后会被关闭。</p>
<h1 id="type-responsewriter">type ResponseWriter</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ResponseWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Header返回一个Header类型值，该值会被WriteHeader方法发送。
</span><span class="c1"></span>    <span class="c1">// 在调用WriteHeader或Write方法后再改变该对象是没有意义的。
</span><span class="c1"></span>    <span class="nf">Header</span><span class="p">()</span> <span class="nx">Header</span>
    <span class="c1">// WriteHeader该方法发送HTTP回复的头域和状态码。
</span><span class="c1"></span>    <span class="c1">// 如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)
</span><span class="c1"></span>    <span class="c1">// WriterHeader的显式调用主要用于发送错误码。
</span><span class="c1"></span>    <span class="nf">WriteHeader</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="c1">// Write向连接中写入作为HTTP的一部分回复的数据。
</span><span class="c1"></span>    <span class="c1">// 如果被调用时还未调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)
</span><span class="c1"></span>    <span class="c1">// 如果Header中没有&#34;Content-Type&#34;键，
</span><span class="c1"></span>    <span class="c1">// 本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ResponseWriter接口被HTTP处理器用于构造HTTP回复。</p>
<h1 id="type-flusher">type Flusher</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Flusher</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Flush将缓冲中的所有数据发送到客户端
</span><span class="c1"></span>    <span class="nf">Flush</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP处理器ResponseWriter接口参数的下层如果实现了Flusher接口，可以让HTTP处理器将缓冲中的数据发送到客户端。</p>
<p>注意：即使ResponseWriter接口的下层支持Flush方法，如果客户端是通过HTTP代理连接的，缓冲中的数据也可能直到回复完毕才被传输到客户端。</p>
<h1 id="type-closenotifier">type CloseNotifier</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CloseNotifier</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// CloseNotify返回一个通道，该通道会在客户端连接丢失时接收到唯一的值
</span><span class="c1"></span>    <span class="nf">CloseNotify</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP处理器ResponseWriter接口参数的下层如果实现了CloseNotifier接口，可以让用户检测下层的连接是否停止。如果客户端在回复准备好之前关闭了连接，该机制可以用于取消服务端耗时较长的操作。</p>
<h1 id="type-hijacker">type Hijacker</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Hijacker</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Hijack让调用者接管连接，返回连接和关联到该连接的一个缓冲读写器。
</span><span class="c1"></span>    <span class="c1">// 调用本方法后，HTTP服务端将不再对连接进行任何操作，
</span><span class="c1"></span>    <span class="c1">// 调用者有责任管理、关闭返回的连接。
</span><span class="c1"></span>    <span class="nf">Hijack</span><span class="p">()</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTP处理器ResponseWriter接口参数的下层如果实现了Hijacker接口，可以让HTTP处理器接管该连接。</p>
<h1 id="type-roundtripper">type RoundTripper</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RoundTripper</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// RoundTrip执行单次HTTP事务，接收并发挥请求req的回复。
</span><span class="c1"></span>    <span class="c1">// RoundTrip不应试图解析/修改得到的回复。
</span><span class="c1"></span>    <span class="c1">// 尤其要注意，只要RoundTrip获得了一个回复，不管该回复的HTTP状态码如何，
</span><span class="c1"></span>    <span class="c1">// 它必须将返回值err设置为nil。
</span><span class="c1"></span>    <span class="c1">// 非nil的返回值err应该留给获取回复失败的情况。
</span><span class="c1"></span>    <span class="c1">// 类似的，RoundTrip不能试图管理高层次的细节，如重定向、认证、cookie。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 除了从请求的主体读取并关闭主体之外，RoundTrip不应修改请求，包括（请求的）错误。
</span><span class="c1"></span>    <span class="c1">// RoundTrip函数接收的请求的URL和Header字段可以保证是（被）初始化了的。
</span><span class="c1"></span>    <span class="nf">RoundTrip</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>RoundTripper接口是具有执行单次HTTP事务的能力（接收指定请求的回复）的接口。</p>
<p>RoundTripper接口的类型必须可以安全的被多线程同时使用。</p>
<h1 id="type-transport">type Transport</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Transport</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Proxy指定一个对给定请求返回代理的函数。
</span><span class="c1"></span>    <span class="c1">// 如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。
</span><span class="c1"></span>    <span class="c1">// 如果Proxy为nil或返回nil的*URL置，将不使用代理。
</span><span class="c1"></span>    <span class="nx">Proxy</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// Dial指定创建TCP连接的拨号函数。如果Dial为nil，会使用net.Dial。
</span><span class="c1"></span>    <span class="nx">Dial</span> <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// TLSClientConfig指定用于tls.Client的TLS配置信息。
</span><span class="c1"></span>    <span class="c1">// 如果该字段为nil，会使用默认的配置信息。
</span><span class="c1"></span>    <span class="nx">TLSClientConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>
    <span class="c1">// TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。
</span><span class="c1"></span>    <span class="nx">TLSHandshakeTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="c1">// 如果DisableKeepAlives为真，会禁止不同HTTP请求之间TCP连接的重用。
</span><span class="c1"></span>    <span class="nx">DisableKeepAlives</span> <span class="kt">bool</span>
    <span class="c1">// 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，
</span><span class="c1"></span>    <span class="c1">// 主动添加&#34;Accept-Encoding: gzip&#34;头，以获取压缩数据。
</span><span class="c1"></span>    <span class="c1">// 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。
</span><span class="c1"></span>    <span class="c1">// 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。
</span><span class="c1"></span>    <span class="nx">DisableCompression</span> <span class="kt">bool</span>
    <span class="c1">// 如果MaxIdleConnsPerHost!=0，会控制每个主机下的最大闲置连接。
</span><span class="c1"></span>    <span class="c1">// 如果MaxIdleConnsPerHost==0，会使用DefaultMaxIdleConnsPerHost。
</span><span class="c1"></span>    <span class="nx">MaxIdleConnsPerHost</span> <span class="kt">int</span>
    <span class="c1">// ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，
</span><span class="c1"></span>    <span class="c1">// 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。
</span><span class="c1"></span>    <span class="c1">// 该时间不包括获取回复主体的时间。
</span><span class="c1"></span>    <span class="nx">ResponseHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Transport类型实现了RoundTripper接口，支持http、https和http/https代理。Transport类型可以缓存连接以在未来重用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">DefaultTransport</span> <span class="nx">RoundTripper</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Transport</span><span class="p">{</span>
    <span class="nx">Proxy</span><span class="p">:</span> <span class="nx">ProxyFromEnvironment</span><span class="p">,</span>
    <span class="nx">Dial</span><span class="p">:</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">{</span>
        <span class="nx">Timeout</span><span class="p">:</span>   <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
        <span class="nx">KeepAlive</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="p">}).</span><span class="nx">Dial</span><span class="p">,</span>
    <span class="nx">TLSHandshakeTimeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>DefaultTransport是被包变量DefaultClient使用的默认RoundTripper接口。它会根据需要创建网络连接，并缓存以便在之后的请求中重用这些连接。它使用环境变量$HTTP_PROXY和$NO_PROXY（或$http_proxy和$no_proxy）指定的HTTP代理。</p>
<h2 id="func-transport-registerprotocol">func (*Transport) RegisterProtocol</h2>
<pre><code>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)
</code></pre>
<p>RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。</p>
<p>RegisterProtocol可以被其他包用于提供&quot;ftp&quot;或&quot;file&quot;等协议的实现。</p>
<h2 id="func-transport-roundtrip">func (*Transport) RoundTrip</h2>
<pre><code>func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)
</code></pre>
<p>RoundTrip方法实现了RoundTripper接口。</p>
<p>高层次的HTTP客户端支持（如管理cookie和重定向）请参见Get、Post等函数和Client类型。</p>
<h2 id="func-transport-closeidleconnections">func (*Transport) CloseIdleConnections</h2>
<pre><code>func (t *Transport) CloseIdleConnections()
</code></pre>
<p>CloseIdleConnections关闭所有之前的请求建立但目前处于闲置状态的连接。本方法不会中断正在使用的连接。</p>
<h2 id="func-transport-cancelrequest">func (*Transport) CancelRequest</h2>
<pre><code>func (t *Transport) CancelRequest(req *Request)
</code></pre>
<p>CancelRequest通过关闭请求所在的连接取消一个执行中的请求。</p>
<h1 id="type-request">type Request</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Method指定HTTP方法（GET、POST、PUT等）。对客户端，&#34;&#34;代表GET。
</span><span class="c1"></span>    <span class="nx">Method</span> <span class="kt">string</span>
    <span class="c1">// URL在服务端表示被请求的URI，在客户端表示要访问的URL。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，
</span><span class="c1"></span>    <span class="c1">// 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。
</span><span class="c1"></span>    <span class="c1">// （参见RFC 2616, Section 5.1.2）
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，URL的Host字段指定了要连接的服务器，
</span><span class="c1"></span>    <span class="c1">// 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。
</span><span class="c1"></span>    <span class="nx">URL</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>
    <span class="c1">// 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1
</span><span class="c1"></span>    <span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// &#34;HTTP/1.0&#34;
</span><span class="c1"></span>    <span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// 1
</span><span class="c1"></span>    <span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// 0
</span><span class="c1"></span>    <span class="c1">// Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：
</span><span class="c1"></span>    <span class="c1">//	accept-encoding: gzip, deflate
</span><span class="c1"></span>    <span class="c1">//	Accept-Language: en-us
</span><span class="c1"></span>    <span class="c1">//	Connection: keep-alive
</span><span class="c1"></span>    <span class="c1">// 则：
</span><span class="c1"></span>    <span class="c1">//	Header = map[string][]string{
</span><span class="c1"></span>    <span class="c1">//		&#34;Accept-Encoding&#34;: {&#34;gzip, deflate&#34;},
</span><span class="c1"></span>    <span class="c1">//		&#34;Accept-Language&#34;: {&#34;en-us&#34;},
</span><span class="c1"></span>    <span class="c1">//		&#34;Connection&#34;: {&#34;keep-alive&#34;},
</span><span class="c1"></span>    <span class="c1">//	}
</span><span class="c1"></span>    <span class="c1">// HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。
</span><span class="c1"></span>    <span class="c1">// 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。
</span><span class="c1"></span>    <span class="nx">Header</span> <span class="nx">Header</span>
    <span class="c1">// Body是请求的主体。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，如果Body是nil表示该请求没有主体买入GET请求。
</span><span class="c1"></span>    <span class="c1">// Client的Transport字段会负责调用Body的Close方法。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。
</span><span class="c1"></span>    <span class="c1">// Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。
</span><span class="c1"></span>    <span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>
    <span class="c1">// ContentLength记录相关内容的长度。
</span><span class="c1"></span>    <span class="c1">// 如果为-1，表示长度未知，如果&gt;=0，表示可以从Body字段读取ContentLength字节数据。
</span><span class="c1"></span>    <span class="c1">// 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。
</span><span class="c1"></span>    <span class="nx">ContentLength</span> <span class="kt">int64</span>
    <span class="c1">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示&#34;identity&#34;编码。
</span><span class="c1"></span>    <span class="c1">// 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除&#34;chunked&#34;传输编码。
</span><span class="c1"></span>    <span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="c1">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。
</span><span class="c1"></span>    <span class="nx">Close</span> <span class="kt">bool</span>
    <span class="c1">// 在服务端，Host指定URL会在其上寻找资源的主机。
</span><span class="c1"></span>    <span class="c1">// 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。
</span><span class="c1"></span>    <span class="c1">// Host的格式可以是&#34;host:port&#34;。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，请求的Host字段（可选地）用来重写请求的Host头。
</span><span class="c1"></span>    <span class="c1">// 如过该字段为&#34;&#34;，Request.Write方法会使用URL字段的Host。
</span><span class="c1"></span>    <span class="nx">Host</span> <span class="kt">string</span>
    <span class="c1">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。
</span><span class="c1"></span>    <span class="c1">// 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
</span><span class="c1"></span>    <span class="nx">Form</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
    <span class="c1">// PostForm是解析好的POST或PUT的表单数据。
</span><span class="c1"></span>    <span class="c1">// 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
</span><span class="c1"></span>    <span class="nx">PostForm</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>
    <span class="c1">// MultipartForm是解析好的多部件表单，包括上传的文件。
</span><span class="c1"></span>    <span class="c1">// 本字段只有在调用ParseMultipartForm后才有效。
</span><span class="c1"></span>    <span class="c1">// 在客户端，会忽略请求中的本字段而使用Body替代。
</span><span class="c1"></span>    <span class="nx">MultipartForm</span> <span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">Form</span>
    <span class="c1">// Trailer指定了会在请求主体之后发送的额外的头域。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。
</span><span class="c1"></span>    <span class="c1">// （客户端会声明哪些trailer会发送）
</span><span class="c1"></span>    <span class="c1">// 在处理器从Body读取时，不能使用本字段。
</span><span class="c1"></span>    <span class="c1">// 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。
</span><span class="c1"></span>    <span class="c1">// （如果客户端发送了这些键值对），此时才可以访问本字段。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）
</span><span class="c1"></span>    <span class="c1">// ContentLength字段必须是0或-1，以启用&#34;chunked&#34;传输编码发送请求。
</span><span class="c1"></span>    <span class="c1">// 在开始发送请求后，Trailer可以在读取请求主体期间被修改，
</span><span class="c1"></span>    <span class="c1">// 一旦请求主体返回EOF，调用者就不可再修改Trailer。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 很少有HTTP客户端、服务端或代理支持HTTP trailer。
</span><span class="c1"></span>    <span class="nx">Trailer</span> <span class="nx">Header</span>
    <span class="c1">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。
</span><span class="c1"></span>    <span class="c1">// 本字段不是ReadRequest函数填写的，也没有定义格式。
</span><span class="c1"></span>    <span class="c1">// 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为&#34;IP:port&#34;格式的地址。
</span><span class="c1"></span>    <span class="c1">// 客户端会忽略请求中的RemoteAddr字段。
</span><span class="c1"></span>    <span class="nx">RemoteAddr</span> <span class="kt">string</span>
    <span class="c1">// RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI
</span><span class="c1"></span>    <span class="c1">// （参见RFC 2616, Section 5.1）
</span><span class="c1"></span>    <span class="c1">// 一般应使用URI字段，在客户端设置请求的本字段会导致错误。
</span><span class="c1"></span>    <span class="nx">RequestURI</span> <span class="kt">string</span>
    <span class="c1">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息
</span><span class="c1"></span>    <span class="c1">// 本字段不是ReadRequest函数填写的。
</span><span class="c1"></span>    <span class="c1">// 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。
</span><span class="c1"></span>    <span class="c1">// 客户端会忽略请求中的TLS字段。
</span><span class="c1"></span>    <span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Request类型代表一个服务端接受到的或者客户端发送出去的HTTP请求。</p>
<p>Request各字段的意义和用途在服务端和客户端是不同的。除了字段本身上方文档，还可参见Request.Write方法和RoundTripper接口的文档。</p>
<h2 id="func-newrequest">func NewRequest</h2>
<pre><code>func NewRequest(method, urlStr string, body io.Reader) (*Request, error)
</code></pre>
<p>NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。</p>
<p>如果body参数实现了io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client类型的Do、Post和PostFOrm方法以及Transport.RoundTrip方法关闭。</p>
<h2 id="func-readrequest">func ReadRequest</h2>
<pre><code>func ReadRequest(b *bufio.Reader) (req *Request, err error)
</code></pre>
<p>ReadRequest从b读F取并解析出一个HTTP请求。（本函数主要用在服务端从下层获取请求）</p>
<h2 id="func-request-protoatleast">func (*Request) ProtoAtLeast</h2>
<pre><code>func (r *Request) ProtoAtLeast(major, minor int) bool
</code></pre>
<p>ProtoAtLeast报告该请求使用的HTTP协议版本至少是major.minor。</p>
<h2 id="func-request-useragent">func (*Request) UserAgent</h2>
<pre><code>func (r *Request) UserAgent() string
</code></pre>
<p>UserAgent返回请求中的客户端用户代理信息（请求的User-Agent头）。</p>
<h2 id="func-request-referer">func (*Request) Referer</h2>
<pre><code>func (r *Request) Referer() string
</code></pre>
<p>Referer返回请求中的访问来路信息。（请求的Referer头）</p>
<p>Referer在请求中就是拼错了的，这是HTTP早期就有的错误。该值也可以从用Header[&ldquo;Referer&rdquo;]获取； 让获取Referer字段变成方法的好处是，编译器可以诊断使用正确单词拼法的req.Referrer()的程序，但却不能诊断使用Header[&ldquo;Referrer&rdquo;]的程序。</p>
<h2 id="func-request-addcookie">func (*Request) AddCookie</h2>
<pre><code>func (r *Request) AddCookie(c *Cookie)
</code></pre>
<p>AddCookie向请求中添加一个cookie。按照RFC 6265 section 5.4的跪地，AddCookie不会添加超过一个Cookie头字段。这表示所有的cookie都写在同一行，用分号分隔（cookie内部用逗号分隔属性）。</p>
<h2 id="func-request-setbasicauth">func (*Request) SetBasicAuth</h2>
<pre><code>func (r *Request) SetBasicAuth(username, password string)
</code></pre>
<p>SetBasicAuth使用提供的用户名和密码，采用HTTP基本认证，设置请求的Authorization头。HTTP基本认证会明码传送用户名和密码。</p>
<h2 id="func-request-write">func (*Request) Write</h2>
<pre><code>func (r *Request) Write(w io.Writer) error
</code></pre>
<p>Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：</p>
<pre><code>Host
URL
Method (defaults to &quot;GET&quot;)
Header
ContentLength
TransferEncoding
Body
</code></pre>
<p>如果存在Body，ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为[&ldquo;identity&rdquo;]，Write方法会显式添加&quot;Transfer-Encoding: chunked&quot;到请求的头域。Body字段会在发送完请求后关闭。</p>
<h2 id="func-request-writeproxy">func (*Request) WriteProxy</h2>
<pre><code>func (r *Request) WriteProxy(w io.Writer) error
</code></pre>
<p>WriteProxy类似Write但会将请求以HTTP代理期望的格式发送。</p>
<p>尤其是，按照RFC 2616 Section 5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。</p>
<h2 id="func-request-cookies">func (*Request) Cookies</h2>
<pre><code>func (r *Request) Cookies() []*Cookie
</code></pre>
<p>Cookies解析并返回该请求的Cookie头设置的cookie。</p>
<h2 id="func-request-cookie">func (*Request) Cookie</h2>
<pre><code>func (r *Request) Cookie(name string) (*Cookie, error)
</code></pre>
<p>Cookie返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。</p>
<h2 id="func-request-parseform">func (*Request) ParseForm</h2>
<pre><code>func (r *Request) ParseForm() error
</code></pre>
<p>ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。</p>
<p>对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。</p>
<p>如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。</p>
<p>ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。</p>
<h2 id="func-request-parsemultipartform">func (*Request) ParseMultipartForm</h2>
<pre><code>func (r *Request) ParseMultipartForm(maxMemory int64) error
</code></pre>
<p>ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用ParseForm。重复调用本方法是无意义的。</p>
<h2 id="func-request-formvalue">func (*Request) FormValue</h2>
<pre><code>func (r *Request) FormValue(key string) string
</code></pre>
<p>FormValue返回查询的命名组件的第一个值。 POST和PUT正文参数优先于URL查询字符串值。 如有必要，FormValue会调用ParseMultipartForm和ParseForm，并忽略这些函数返回的任何错误。 如果key不存在，FormValue将返回空字符串。 要访问同一个键的多个值，请调用ParseForm，然后直接检查Request.Form。</p>
<h2 id="func-request-postformvalue">func (*Request) PostFormValue</h2>
<pre><code>func (r *Request) PostFormValue(key string) string
</code></pre>
<p>PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</p>
<h2 id="func-request-formfile">func (*Request) FormFile</h2>
<pre><code>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)
</code></pre>
<p>FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。查询失败会返回ErrMissingFile错误。</p>
<h2 id="func-request-multipartreader">func (*Request) MultipartReader</h2>
<pre><code>func (r *Request) MultipartReader() (*multipart.Reader, error)
</code></pre>
<p>如果请求是multipart/form-data POST请求，MultipartReader返回一个multipart.Reader接口，否则返回nil和一个错误。使用本函数代替ParseMultipartForm，可以将r.Body作为流处理。</p>
<h1 id="type-client">type Client</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Transport指定执行独立、单次HTTP请求的机制。
</span><span class="c1"></span>    <span class="c1">// 如果Transport为nil，则使用DefaultTransport。
</span><span class="c1"></span>    <span class="nx">Transport</span> <span class="nx">RoundTripper</span>
    <span class="c1">// CheckRedirect指定处理重定向的策略。
</span><span class="c1"></span>    <span class="c1">// 如果CheckRedirect不为nil，客户端会在执行重定向之前调用本函数字段。
</span><span class="c1"></span>    <span class="c1">// 参数req和via是将要执行的请求和已经执行的请求（切片，越新的请求越靠后）。
</span><span class="c1"></span>    <span class="c1">// 如果CheckRedirect返回一个错误，本类型的Get方法不会发送请求req，
</span><span class="c1"></span>    <span class="c1">// 而是返回之前得到的最后一个回复和该错误。（包装进url.Error类型里）
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// 如果CheckRedirect为nil，会采用默认策略：连续10此请求后停止。
</span><span class="c1"></span>    <span class="nx">CheckRedirect</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">via</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// Jar指定cookie管理器。
</span><span class="c1"></span>    <span class="c1">// 如果Jar为nil，请求中不会发送cookie，回复中的cookie会被忽略。
</span><span class="c1"></span>    <span class="nx">Jar</span> <span class="nx">CookieJar</span>
    <span class="c1">// Timeout指定本类型的值执行请求的时间限制。
</span><span class="c1"></span>    <span class="c1">// 该超时限制包括连接时间、重定向和读取回复主体的时间。
</span><span class="c1"></span>    <span class="c1">// 计时器会在Head、Get、Post或Do方法返回后继续运作并在超时后中断回复主体的读取。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Timeout为零值表示不设置超时。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Client实例的Transport字段必须支持CancelRequest方法，
</span><span class="c1"></span>    <span class="c1">// 否则Client会在试图用Head、Get、Post或Do方法执行请求时返回错误。
</span><span class="c1"></span>    <span class="c1">// 本类型的Transport字段默认值（DefaultTransport）支持CancelRequest方法。
</span><span class="c1"></span>    <span class="nx">Timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Client类型代表HTTP客户端。它的零值（DefaultClient）是一个可用的使用DefaultTransport的客户端。</p>
<p>Client的Transport字段一般会含有内部状态（缓存TCP连接），因此Client类型值应尽量被重用而不是每次需要都创建新的。Client类型值可以安全的被多个go程同时使用。</p>
<p>Client类型的层次比RoundTripper接口（如Transport）高，还会管理HTTP的cookie和重定向等细节。</p>
<h2 id="func-client-do">func (*Client) Do</h2>
<pre><code>func (c *Client) Do(req *Request) (resp *Response, err error)
</code></pre>
<p>Do方法发送请求，返回HTTP回复。它会遵守客户端c设置的策略（如重定向、cookie、认证）。</p>
<p>如果客户端的策略（如重定向）返回错误或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。</p>
<p>如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。如果返回值resp的主体未关闭，c下层的RoundTripper接口（一般为Transport类型）可能无法重用resp主体下层保持的TCP连接去执行之后的请求。</p>
<p>请求的主体，如果非nil，会在执行后被c.Transport关闭，即使出现错误。</p>
<p>一般应使用Get、Post或PostForm方法代替Do方法。</p>
<h2 id="func-client-head">func (*Client) Head</h2>
<pre><code>func (c *Client) Head(url string) (resp *Response, err error)
</code></pre>
<p>Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：</p>
<pre><code>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</code></pre>
<h1 id="func-client-get">func (*Client) Get</h1>
<pre><code>func (c *Client) Get(url string) (resp *Response, err error)
</code></pre>
<p>Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：</p>
<pre><code>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</code></pre>
<p>如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<h2 id="func-client-post">func (*Client) Post</h2>
<pre><code>func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
</code></pre>
<p>Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。</p>
<h2 id="func-client-postform">func (*Client) PostForm</h2>
<pre><code>func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)
</code></pre>
<p>PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。POST数据的类型一般会设为&quot;application/x-www-form-urlencoded&quot;。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<h1 id="type-handler">type Handler</h1>
<pre><code>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
<p>实现了Handler接口的对象可以注册到HTTP服务端，为特定的路径及其子树提供服务。</p>
<p>ServeHTTP应该将回复的头域和数据写入ResponseWriter接口然后返回。返回标志着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。</p>
<h2 id="func-notfoundhandler">func NotFoundHandler</h2>
<pre><code>func NotFoundHandler() Handler
</code></pre>
<p>NotFoundHandler返回一个简单的请求处理器，该处理器会对每个请求都回复&quot;404 page not found&quot;。</p>
<h2 id="func-redirecthandler">func RedirectHandler</h2>
<pre><code>func RedirectHandler(url string, code int) Handler
</code></pre>
<p>RedirectHandler返回一个请求处理器，该处理器会对每个请求都使用状态码code重定向到网址url。</p>
<h2 id="func-timeouthandler">func TimeoutHandler</h2>
<pre><code>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler
</code></pre>
<p>TimeoutHandler返回一个采用指定时间限制的请求处理器。</p>
<p>返回的Handler会调用h.ServeHTTP去处理每个请求，但如果某一次调用耗时超过了时间限制，该处理器会回复请求状态码503 Service Unavailable，并将msg作为回复的主体（如果msg为空字符串，将发送一个合理的默认信息）。在超时后，h对它的ResponseWriter接口参数的写入操作会返回ErrHandlerTimeout。</p>
<h2 id="func-stripprefix">func StripPrefix</h2>
<pre><code>func StripPrefix(prefix string, h Handler) Handler
</code></pre>
<p>StripPrefix返回一个处理器，该处理器会将请求的URL.Path字段中给定前缀prefix去除后再交由h处理。StripPrefix会向URL.Path字段中没有给定前缀的请求回复404 page not found。</p>
<h1 id="type-handlerfunc">type HandlerFunc</h1>
<pre><code>type HandlerFunc func(ResponseWriter, *Request)
</code></pre>
<p>HandlerFunc type是一个适配器，通过类型转换让我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。</p>
<h2 id="func-handlerfunc-servehttp">func (HandlerFunc) ServeHTTP</h2>
<pre><code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
</code></pre>
<p>ServeHTTP方法会调用f(w, r)</p>
<h2 id="type-servemux">type ServeMux</h2>
<pre><code>type ServeMux struct {
    // 内含隐藏或非导出字段
}
</code></pre>
<p>ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。</p>
<p>模式是固定的、由根开始的路径，如&quot;/favicon.ico&quot;，或由根开始的子树，如&quot;/images/&quot;（注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式&quot;/images/&ldquo;和&rdquo;/images/thumbnails/&ldquo;都注册了处理器，后一个处理器会用于路径以&rdquo;/images/thumbnails/&ldquo;开始的请求，前一个处理器会接收到其余的路径在&rdquo;/images/&ldquo;子树下的请求。</p>
<p>注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式&rdquo;/&ldquo;会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径&rdquo;/&quot;。</p>
<p>模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式&quot;/codesearch&quot;和&quot;codesearch.google.com/&ldquo;的处理器不会接管目标为&quot;http://www.google.com/&ldquo;的请求。</p>
<p>ServeMux还会注意到请求的URL路径的无害化，将任何路径中包含&rdquo;.&ldquo;或&rdquo;..&ldquo;元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）</p>
<h2 id="func-newservemux">func NewServeMux</h2>
<pre><code>func NewServeMux() *ServeMux
</code></pre>
<p>NewServeMux创建并返回一个新的*ServeMux</p>
<h2 id="func-servemux-handle">func (*ServeMux) Handle</h2>
<pre><code>func (mux *ServeMux) Handle(pattern string, handler Handler)
</code></pre>
<p>Handle注册HTTP处理器handler和对应的模式pattern。如果该模式已经注册有一个处理器，Handle会panic。</p>
<h2 id="func-servemux-handlefunc">func (*ServeMux) HandleFunc</h2>
<pre><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))
</code></pre>
<p>HandleFunc注册一个处理器函数handler和对应的模式pattern。</p>
<h2 id="func-servemux-handler">func (*ServeMux) Handler</h2>
<pre><code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)
</code></pre>
<p>Handler根据r.Method、r.Host和r.URL.Path等数据，返回将用于处理该请求的HTTP处理器。它总是返回一个非nil的处理器。如果路径不是它的规范格式，将返回内建的用于重定向到等价的规范路径的处理器。</p>
<p>Handler也会返回匹配该请求的的已注册模式；在内建重定向处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，本方法将返回一个内建的&quot;404 page not found&quot;处理器和一个空字符串模式。</p>
<h2 id="func-servemux-servehttp">func (*ServeMux) ServeHTTP</h2>
<pre><code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)
</code></pre>
<p>ServeHTTP将请求派遣到与请求的URL最匹配的模式对应的处理器。</p>
<h1 id="type-server">type Server</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Addr</span>           <span class="kt">string</span>        <span class="c1">// 监听的TCP地址，如果为空字符串会使用&#34;:http&#34;
</span><span class="c1"></span>    <span class="nx">Handler</span>        <span class="nx">Handler</span>       <span class="c1">// 调用的处理器，如为nil会调用http.DefaultServeMux
</span><span class="c1"></span>    <span class="nx">ReadTimeout</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// 请求的读取操作在超时前的最大持续时间
</span><span class="c1"></span>    <span class="nx">WriteTimeout</span>   <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// 回复的写入操作在超时前的最大持续时间
</span><span class="c1"></span>    <span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>           <span class="c1">// 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes
</span><span class="c1"></span>    <span class="nx">TLSConfig</span>      <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>   <span class="c1">// 可选的TLS配置，用于ListenAndServeTLS方法
</span><span class="c1"></span>    <span class="c1">// TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。
</span><span class="c1"></span>    <span class="c1">// 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，
</span><span class="c1"></span>    <span class="c1">// 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。
</span><span class="c1"></span>    <span class="c1">// 连接在函数返回时会自动关闭。
</span><span class="c1"></span>    <span class="nx">TLSNextProto</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">)</span>
    <span class="c1">// ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。
</span><span class="c1"></span>    <span class="c1">// 参见ConnState类型和相关常数获取细节。
</span><span class="c1"></span>    <span class="nx">ConnState</span> <span class="kd">func</span><span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ConnState</span><span class="p">)</span>
    <span class="c1">// ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。
</span><span class="c1"></span>    <span class="c1">// 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。
</span><span class="c1"></span>    <span class="nx">ErrorLog</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
    <span class="c1">// 内含隐藏或非导出字段
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Server类型定义了运行HTTP服务端的参数。Server的零值是合法的配置。</p>
<h2 id="func-server-setkeepalivesenabled">func (*Server) SetKeepAlivesEnabled</h2>
<pre><code>func (s *Server) SetKeepAlivesEnabled(v bool)
</code></pre>
<p>SetKeepAlivesEnabled控制是否允许HTTP闲置连接重用（keep-alive）功能。默认该功能总是被启用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。</p>
<h2 id="func-server-serve">func (*Server) Serve</h2>
<pre><code>func (srv *Server) Serve(l net.Listener) error
</code></pre>
<p>Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用srv.Handler回复请求。</p>
<h2 id="func-server-listenandserve">func (*Server) ListenAndServe</h2>
<pre><code>func (srv *Server) ListenAndServe() error
</code></pre>
<p>ListenAndServe监听srv.Addr指定的TCP地址，并且会调用Serve方法接收到的连接。如果srv.Addr为空字符串，会使用&rdquo;:http&rdquo;。</p>
<h2 id="func-server-listenandservetls">func (*Server) ListenAndServeTLS</h2>
<pre><code>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error
</code></pre>
<p>ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用&quot;:https&quot;。</p>
<h1 id="type-file">type File</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Closer</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
    <span class="nf">Readdir</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">([]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Seek</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">whence</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Stat</span><span class="p">()</span> <span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>File是被FileSystem接口的Open方法返回的接口类型，可以被FileServer等函数用于文件访问服务。</p>
<p>该接口的方法的行为应该和*os.File类型的同名方法相同。</p>
<h1 id="type-filesystem">type FileSystem</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FileSystem</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>FileSystem接口实现了对一系列命名文件的访问。文件路径的分隔符为&rsquo;/'，不管主机操作系统的惯例如何。</p>
<h1 id="type-dir">type Dir</h1>
<pre><code>type Dir string
</code></pre>
<p>Dir使用限制到指定目录树的本地文件系统实现了http.FileSystem接口。空Dir被视为&quot;.&quot;，即代表当前目录。</p>
<h2 id="func-dir-open">func (Dir) Open</h2>
<pre><code>func (d Dir) Open(name string) (File, error)
</code></pre>
<h2 id="func-newfiletransport">func NewFileTransport</h2>
<pre><code>func NewFileTransport(fs FileSystem) RoundTripper
</code></pre>
<p>NewFileTransport返回一个RoundTripper接口，使用FileSystem接口fs提供文件访问服务。 返回的RoundTripper接口会忽略接收的请求的URL主机及其他绝大多数属性。</p>
<p>NewFileTransport函数的典型使用情况是给Transport类型的值注册&quot;file&quot;协议，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Transport</span><span class="p">{}</span>
<span class="nx">t</span><span class="p">.</span><span class="nf">RegisterProtocol</span><span class="p">(</span><span class="s">&#34;file&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewFileTransport</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">)))</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Transport</span><span class="p">:</span> <span class="nx">t</span><span class="p">}</span>
<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;file:///etc/passwd&#34;</span><span class="p">)</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-fileserver">func FileServer</h1>
<pre><code>func FileServer(root FileSystem) Handler
</code></pre>
<p>FileServer返回一个使用FileSystem接口root提供文件访问服务的HTTP处理器。要使用操作系统的FileSystem接口实现，可使用http.Dir：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;/tmp&#34;</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-proxyurl">func ProxyURL</h1>
<pre><code>func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)
</code></pre>
<p>ProxyURL返回一个代理函数（用于Transport类型），该函数总是返回同一个URL。</p>
<h1 id="func-proxyfromenvironment">func ProxyFromEnvironment</h1>
<pre><code>func ProxyFromEnvironment(req *Request) (*url.URL, error)
</code></pre>
<p>ProxyFromEnvironment使用环境变量$HTTP_PROXY和$NO_PROXY(或$http_proxy和$no_proxy)的配置返回用于req的代理。如果代理环境不合法将返回错误；如果环境未设定代理或者给定的request不应使用代理时，将返回(nil, nil)；如果req.URL.Host字段是&quot;localhost&quot;（可以有端口号，也可以没有），也会返回(nil, nil)。</p>
<h1 id="func-setcookie">func SetCookie</h1>
<pre><code>func SetCookie(w ResponseWriter, cookie *Cookie)
</code></pre>
<p>SetCookie在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。</p>
<h1 id="func-redirect">func Redirect</h1>
<pre><code>func Redirect(w ResponseWriter, r *Request, urlStr string, code int)
</code></pre>
<p>Redirect回复请求一个重定向地址urlStr和状态码code。该重定向地址可以是相对于请求r的相对地址。</p>
<h1 id="func-notfound">func NotFound</h1>
<pre><code>func NotFound(w ResponseWriter, r *Request)
</code></pre>
<p>NotFound回复请求404状态码（not found：目标未发现）。</p>
<h1 id="func-error">func Error</h1>
<pre><code>func Error(w ResponseWriter, error string, code int)
</code></pre>
<p>Error使用指定的错误信息和状态码回复请求，将数据写入w。错误信息必须是明文。</p>
<h1 id="func-servecontent">func ServeContent</h1>
<pre><code>func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)
</code></pre>
<p>ServeContent使用提供的ReadSeeker的内容回复请求。ServeContent比起io.Copy函数的主要优点，是可以处理范围类请求（只要一部分内容）、设置MIME类型，处理If-Modified-Since请求。</p>
<p>如果未设定回复的Content-Type头，本函数首先会尝试从name的文件扩展名推断数据类型；如果失败，会用读取content的第1块数据并提供给DetectContentType推断类型；之后会设置Content-Type头。参数name不会用于别的地方，甚至于它可以是空字符串，也永远不会发送到回复里。</p>
<p>如果modtime不是Time零值，函数会在回复的头域里设置Last-Modified头。如果请求的头域包含If-Modified-Since头，本函数会使用modtime参数来确定是否应该发送内容。如果调用者设置了w的ETag头，ServeContent会使用它处理包含If-Range头和If-None-Match头的请求。</p>
<p>参数content的Seek方法必须有效：函数使用Seek来确定它的大小。</p>
<p>注意：本包File接口和*os.File类型都实现了io.ReadSeeker接口。</p>
<h1 id="func-servefile">func ServeFile</h1>
<pre><code>func ServeFile(w ResponseWriter, r *Request, name string)
</code></pre>
<p>ServeFile回复请求name指定的文件或者目录的内容。</p>
<h1 id="func-maxbytesreader">func MaxBytesReader</h1>
<pre><code>func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser
</code></pre>
<p>MaxBytesReader类似io.LimitReader，但它是用来限制接收到的请求的Body的大小的。不同于io.LimitReader，本函数返回一个ReadCloser，返回值的Read方法在读取的数据超过大小限制时会返回非EOF错误，其Close方法会关闭下层的io.ReadCloser接口r。</p>
<p>MaxBytesReader预防客户端因为意外或者蓄意发送的“大”请求，以避免尺寸过大的请求浪费服务端资源。</p>
<h1 id="func-head">func Head</h1>
<pre><code>func Head(url string) (resp *Response, err error)
</code></pre>
<p>Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mi">301</span> <span class="p">(</span><span class="nx">Moved</span> <span class="nx">Permanently</span><span class="p">)</span>
<span class="mi">302</span> <span class="p">(</span><span class="nx">Found</span><span class="p">)</span>
<span class="mi">303</span> <span class="p">(</span><span class="nx">See</span> <span class="nx">Other</span><span class="p">)</span>
<span class="mi">307</span> <span class="p">(</span><span class="nx">Temporary</span> <span class="nx">Redirect</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Head是对包变量DefaultClient的Head方法的包装。</p>
<h1 id="func-get">func Get</h1>
<pre><code>func Get(url string) (resp *Response, err error)
</code></pre>
<p>Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mi">301</span> <span class="p">(</span><span class="nx">Moved</span> <span class="nx">Permanently</span><span class="p">)</span>
<span class="mi">302</span> <span class="p">(</span><span class="nx">Found</span><span class="p">)</span>
<span class="mi">303</span> <span class="p">(</span><span class="nx">See</span> <span class="nx">Other</span><span class="p">)</span>
<span class="mi">307</span> <span class="p">(</span><span class="nx">Temporary</span> <span class="nx">Redirect</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<p>Get是对包变量DefaultClient的Get方法的包装。</p>
<h1 id="func-post">func Post</h1>
<pre><code>func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
</code></pre>
<p>Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。</p>
<p>Post是对包变量DefaultClient的Post方法的包装。</p>
<h1 id="func-postform">func PostForm</h1>
<pre><code>func PostForm(url string, data url.Values) (resp *Response, err error)
</code></pre>
<p>PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。</p>
<p>PostForm是对包变量DefaultClient的PostForm方法的包装。</p>
<h1 id="func-handle">func Handle</h1>
<pre><code>func Handle(pattern string, handler Handler)
</code></pre>
<p>Handle注册HTTP处理器handler和对应的模式pattern（注册到DefaultServeMux）。如果该模式已经注册有一个处理器，Handle会panic。ServeMux的文档解释了模式的匹配机制。</p>
<h1 id="func-handlefunc">func HandleFunc</h1>
<pre><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
</code></pre>
<p>HandleFunc注册一个处理器函数handler和对应的模式pattern（注册到DefaultServeMux）。ServeMux的文档解释了模式的匹配机制。</p>
<h1 id="func-serve">func Serve</h1>
<pre><code>func Serve(l net.Listener, handler Handler) error
</code></pre>
<p>Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用handler回复请求。handler参数一般会设为nil，此时会使用DefaultServeMux。</p>
<h1 id="func-listenandserve">func ListenAndServe</h1>
<pre><code>func ListenAndServe(addr string, handler Handler) error
</code></pre>
<p>ListenAndServe监听TCP地址addr，并且会使用handler参数调用Serve函数处理接收到的连接。handler参数一般会设为nil，此时会使用DefaultServeMux。</p>
<p>一个简单的服务端例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;log&#34;</span>
<span class="p">)</span>
<span class="c1">// hello world, the web server
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HelloServer</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;hello, world!\n&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/hello&#34;</span><span class="p">,</span> <span class="nx">HelloServer</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:12345&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;ListenAndServe: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="func-listenandservetls">func ListenAndServeTLS</h1>
<pre><code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error
</code></pre>
<p>ListenAndServeTLS函数和ListenAndServe函数的行为基本一致，除了它期望HTTPS连接之外。此外，必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用&quot;:https&quot;。</p>
<p>一个简单的服务端例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;text/plain&#34;</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;This is an example server.\n&#34;</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;About to listen on 10443. Go to https://127.0.0.1:10443/&#34;</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServeTLS</span><span class="p">(</span><span class="s">&#34;:10443&#34;</span><span class="p">,</span> <span class="s">&#34;cert.pem&#34;</span><span class="p">,</span> <span class="s">&#34;key.pem&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序员可以使用crypto/tls包的generate_cert.go文件来生成cert.pem和key.pem两个文件。</p>
<h1 id="type-cookie">type Cookie</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cookie</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span>       <span class="kt">string</span>
    <span class="nx">Value</span>      <span class="kt">string</span>
    <span class="nx">Path</span>       <span class="kt">string</span>
    <span class="nx">Domain</span>     <span class="kt">string</span>
    <span class="nx">Expires</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">RawExpires</span> <span class="kt">string</span>
    <span class="c1">// MaxAge=0表示未设置Max-Age属性
</span><span class="c1"></span>    <span class="c1">// MaxAge&lt;0表示立刻删除该cookie，等价于&#34;Max-Age: 0&#34;
</span><span class="c1"></span>    <span class="c1">// MaxAge&gt;0表示存在Max-Age属性，单位是秒
</span><span class="c1"></span>    <span class="nx">MaxAge</span>   <span class="kt">int</span>
    <span class="nx">Secure</span>   <span class="kt">bool</span>
    <span class="nx">HttpOnly</span> <span class="kt">bool</span>
    <span class="nx">Raw</span>      <span class="kt">string</span>
    <span class="nx">Unparsed</span> <span class="p">[]</span><span class="kt">string</span> <span class="c1">// 未解析的“属性-值”对的原始文本
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Cookie代表一个出现在HTTP回复的头域中Set-Cookie头的值里或者HTTP请求的头域中Cookie头的值里的HTTP cookie。</p>
<h2 id="func-cookie-string">func (*Cookie) String</h2>
<pre><code>func (c *Cookie) String() string
</code></pre>
<p>String返回该cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。</p>
<h1 id="type-cookiejar">type CookieJar</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CookieJar</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// SetCookies管理从u的回复中收到的cookie
</span><span class="c1"></span>    <span class="c1">// 根据其策略和实现，它可以选择是否存储cookie
</span><span class="c1"></span>    <span class="nf">SetCookies</span><span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">cookies</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Cookie</span><span class="p">)</span>
    <span class="c1">// Cookies返回发送请求到u时应使用的cookie
</span><span class="c1"></span>    <span class="c1">// 本方法有责任遵守RFC 6265规定的标准cookie限制
</span><span class="c1"></span>    <span class="nf">Cookies</span><span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Cookie</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CookieJar管理cookie的存储和在HTTP请求中的使用。CookieJar的实现必须能安全的被多个go程同时使用。</p>
<p>net/http/cookiejar包提供了一个CookieJar的实现。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-11-15
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93%E4%BD%BF%E7%94%A8/">Go标准库使用</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/ioutil%E5%8C%85%E8%A7%A3%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">ioutil包解析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">
            <span class="next-text nav-default">Go的交叉编译</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
