<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>GCD、扩展GCD和中国剩余定理 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="辗转相除法 辗转相除是求两个数的最大公约数的。 要证这个定理成立，只需要证明 1 gcd(a, b) = gcd(b, a % b) 就行了 证明：令a % b = r, 所以a = k * b &#43; r, 所以r = a" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.55.6 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/gcd%E6%89%A9%E5%B1%95gcd%E5%92%8C%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="GCD、扩展GCD和中国剩余定理" />
<meta property="og:description" content="辗转相除法 辗转相除是求两个数的最大公约数的。 要证这个定理成立，只需要证明 1 gcd(a, b) = gcd(b, a % b) 就行了 证明：令a % b = r, 所以a = k * b &#43; r, 所以r = a" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/gcd%E6%89%A9%E5%B1%95gcd%E5%92%8C%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/" />
<meta property="article:published_time" content="2017-08-02T18:54:00&#43;00:00"/>
<meta property="article:modified_time" content="2017-08-02T18:54:00&#43;00:00"/>

<meta itemprop="name" content="GCD、扩展GCD和中国剩余定理">
<meta itemprop="description" content="辗转相除法 辗转相除是求两个数的最大公约数的。 要证这个定理成立，只需要证明 1 gcd(a, b) = gcd(b, a % b) 就行了 证明：令a % b = r, 所以a = k * b &#43; r, 所以r = a">


<meta itemprop="datePublished" content="2017-08-02T18:54:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-08-02T18:54:00&#43;00:00" />
<meta itemprop="wordCount" content="6164">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GCD、扩展GCD和中国剩余定理"/>
<meta name="twitter:description" content="辗转相除法 辗转相除是求两个数的最大公约数的。 要证这个定理成立，只需要证明 1 gcd(a, b) = gcd(b, a % b) 就行了 证明：令a % b = r, 所以a = k * b &#43; r, 所以r = a"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">GCD、扩展GCD和中国剩余定理</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-08-02 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
          <span class="more-meta"> 约 6164 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#辗转相除法">辗转相除法</a></li>
<li><a href="#扩展欧几里得算法">扩展欧几里得算法</a>
<ul>
<li><a href="#算法思想">算法思想</a></li>
<li><a href="#举例">举例</a></li>
</ul></li>
<li><a href="#乘法逆元">乘法逆元</a>
<ul>
<li><a href="#算法思想-1">算法思想</a></li>
</ul></li>
<li><a href="#中国剩余定理">中国剩余定理</a>
<ul>
<li><a href="#算法思想-2">算法思想</a></li>
<li><a href="#编码">编码</a></li>
<li><a href="#举例-1">举例</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h1 id="辗转相除法">辗转相除法</h1>

<p>辗转相除是求两个数的最大公约数的。</p>

<p>要证这个定理成立，只需要证明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">gcd(a, b) = gcd(b, a % b) 就行了</pre></td></tr></table>
</div>
</div>
<p>证明：令a % b = r, 所以a = k * b + r, 所以r = a - k * b,假设d为a，b的一个公约数，那么 d|a，  d|b,（d|a的意思就是d整除a，也就是a能被d整除），所以a - k * b 也一定能被d整除，即 d|r， 也就是 d|(a % b)， 因此d也是b 和 (a % b)的公约数，因此a,b 的公约数和b, (a%b)的公约数也是一样的，其最大公约数也一定相同，所以gcd(a, b) = gcd(b, a % b);</p>

<p>所以有了这个等式之后，基本上就算完了，还有一步就是怎么到最后求个具体的数，当b等于0时候就可以了，因为最后递归好多还是和原来的那个公约数是相同的，最后有0了，他俩的最大公约数就是他本身了，也就是a了，</p>

<p>代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="kt">long</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span>  <span class="c1">//辗转相除求最大公约数
</span><span class="c1"></span><span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span><span class="o">?</span><span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="扩展欧几里得算法">扩展欧几里得算法</h1>

<h2 id="算法思想">算法思想</h2>

<p>现在我们知道了 a 和 b 的最大公约数是 gcd ，那么，我们一定能够找到这样的 x 和 y ，使得: a*x + b*y = gcd 这是一个不定方程，有多解是一定的，但是只要我们找到一组特殊的解 x0 和 y0 那么，我们就可以用 x0 和 y0 表示出整个不定方程的通解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">x = x0 + (b/gcd)*t
y = y0 – (a/gcd)*t</pre></td></tr></table>
</div>
</div>
<p>可以通过将通解代入原方程来验证正确性.</p>

<p>为什么不是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">x = x0 + b*t
y = y0 – a*t</pre></td></tr></table>
</div>
</div>
<p>那是因为：</p>

<p>b/gcd 是 b 的因子， a/gcd 是 a 的因子是吧？那么，由于 t的取值范围是整数，你说 (b/gcd)*t 取到的值多还是 b*t 取到的值多？同理，(a/gcd)*t 取到的值多还是 a*gcd 取到的值多？那肯定又要问了，那为什么不是更小的数，非得是 b/gcd 和a/gcd ？</p>

<p>注意到：我们令 B = b/gcd ， A = a/gcd ， 那么，A 和 B 一定是互素,若要让两个通解代入原方程后等式成立,A和B必须缩小相同的倍数,即有公约数.所以找不到比A和B更小的数了</p>

<p>现在，我们知道了一定存在 x 和 y 使得 ： a*x + b*y = gcd ， 那么，怎么求出这个特解 x 和 y 呢？只需要在欧几里德算法的基础上加点改动就行了。</p>

<p>我们观察到：欧几里德算法停止的状态是： a= gcd ， b = 0 ，那么，这是否能给我们求解 x y 提供一种思路呢？因为，这时候，只要 a = gcd 的系数是 1 ，那么只要 b 的系数是 0 或者其他值（无所谓是多少，反正任何数乘以 0 都等于 0 但是a 的系数一定要是 1），这时，我们就会有： a*1 + b*0 = gcd</p>

<p>当然这是最终状态，但是我们是否可以从最终状态反推到最初的状态呢？</p>

<p>假设当前我们要处理的是求出 a 和 b的最大公约数，并求出 x 和 y 使得 a*x + b*y= gcd ，而我们已经求出了下一个状态：b 和 a%b 的最大公约数，并且求出了一组x1 和y1 使得： b*x1 + (a%b)*y1 = gcd ， 那么这两个相邻的状态之间是否存在一种关系呢？</p>

<p>我们知道： a%b = a - (a/b)*b（这里的 “/” 指的是整除，例如 <sup>5</sup>&frasl;<sub>2</sub>=2 , <sup>1</sup>&frasl;<sub>3</sub>=0），那么，我们可以进一步得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">gcd = b*x1 + (a-(a/b)*b)*y1
    = b*x1 + a*y1 – (a/b)*b*y1
    = a*y1 + b*(x1 – a/b*y1)</pre></td></tr></table>
</div>
</div>
<p>对比之前我们的状态：求一组 x 和 y 使得：a*x + b*y = gcd ，是否发现了什么？</p>

<p>这里：
        x = y1
        y = x1 – a/b*y1</p>

<p>以上就是扩展欧几里德算法的全部过程</p>

<p>代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">b</span><span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">exgcd</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">t</span><span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">y</span><span class="o">=</span> <span class="n">t</span><span class="o">-</span> <span class="n">a</span><span class="o">/</span> <span class="n">b</span><span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//1、先计算Gcd(a, b)，若n不能被Gcd(a, b)整除，则方程无整数解；否则，在方程两边同时除以Gcd(a, b)，得到新的不定方程a&#39; * x + b&#39; * y = n&#39;，此时Gcd(a&#39;, b&#39;)=1;
</span><span class="c1">//2、求出方程a&#39; * x + b&#39; * y = 1的一组整数解x0, y0，则n&#39; * x0,n&#39; * y0是方程a&#39; * x + b&#39; * y = n&#39;的一组整数解；
</span><span class="c1">//3、根据数论中的相关定理，可得方程a&#39; * x + b&#39; * y = n&#39;的所有整数解为：
</span><span class="c1">//x = n&#39; * x0 + b&#39; * k
</span><span class="c1">//y = n&#39; * y0 - a&#39; * k
</span><span class="c1"></span><span class="o">//</span><span class="p">(</span><span class="n">t为整数</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="举例">举例</h2>

<p>题目描述：</p>

<p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。</p>

<p>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。</p>

<p>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。</p>

<p>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行&rdquo;Impossible&rdquo;</p>

<p>Sample Input:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">1 2 3 4 5</pre></td></tr></table>
</div>
</div>
<p>Sample Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">4 </pre></td></tr></table>
</div>
</div>
<p>题目分析：</p>

<p>构造方程 (x + m * s) - (y + n * s) = k * l(k = 0, 1, 2,&hellip;)
变形为 (n-m) * s + k * l = x - y。即转化为模板题，a * x + b * y = c，是否存在整数解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">long</span> <span class="kt">long</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span>  <span class="c1">//辗转相除求最大公约数
</span><span class="c1"></span><span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span><span class="o">?</span><span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">b</span><span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">exgcd</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">);</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">t</span><span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">y</span><span class="o">=</span> <span class="n">t</span><span class="o">-</span> <span class="n">a</span><span class="o">/</span> <span class="n">b</span><span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//1、先计算Gcd(a, b)，若n不能被Gcd(a, b)整除，则方程无整数解；否则，在方程两边同时除以Gcd(a, b)，得到新的不定方程a&#39; * x + b&#39; * y = n&#39;，此时Gcd(a&#39;, b&#39;)=1;
</span><span class="c1">//2、求出方程a&#39; * x + b&#39; * y = 1的一组整数解x0, y0，则n&#39; * x0,n&#39; * y0是方程a&#39; * x + b&#39; * y = n&#39;的一组整数解；
</span><span class="c1">//3、根据数论中的相关定理，可得方程a&#39; * x + b&#39; * y = n&#39;的所有整数解为：
</span><span class="c1">//x = n&#39; * x0 + b&#39; * k
</span><span class="c1">//y = n&#39; * y0 - a&#39; * k
</span><span class="c1">//(t为整数)
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span>  <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span> <span class="n">scanf</span><span class="p">(</span> <span class="s">&#34;%lld %lld %lld %lld %lld&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span> <span class="p">)</span><span class="o">!=</span> <span class="n">EOF</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span> <span class="n">n</span><span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span> <span class="n">x</span><span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">d</span><span class="o">=</span> <span class="n">gcd</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">c</span><span class="o">%</span> <span class="n">d</span> <span class="p">)</span><span class="c1">//a*x + b*y = c 有解的充要条件：c%gcd(a,b)==0
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">puts</span><span class="p">(</span> <span class="s">&#34;Impossible&#34;</span> <span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">a</span><span class="o">/=</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="o">/=</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="o">/=</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">exgcd</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="p">);</span>  <span class="c1">//
</span><span class="c1">//此时方程的所有解为：x = c*p - b*k,  x与cp关于b同余那么根据最小整数原理，一定存在一个最小的正整数，
</span><span class="c1">//它是 a 关于m 的逆元，而最小的肯定是在（0 , m）之间的，而且只有一个。 当 m 是负数的时候，我们取 m 的绝对值就行了，
</span><span class="c1">//当 x0 是负数的时候，他模上 m 的结果仍然是负数，我们仍然让对b取模，然后结果再加上b就行了
</span><span class="c1"></span>        <span class="n">p</span><span class="o">*=</span> <span class="n">c</span><span class="p">;</span><span class="c1">//将整个方程扩大c倍，让右边为c
</span><span class="c1"></span>        <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span> <span class="n">p</span><span class="o">%</span> <span class="n">b</span><span class="p">;</span><span class="c1">//求最小解
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span> <span class="n">ans</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ans</span><span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ans</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="乘法逆元">乘法逆元</h1>

<h2 id="算法思想-1">算法思想</h2>

<p>扩展欧几里德可以求解形如 a*x +b*y = c 的通解，但是一般没有谁会无聊到让你写出一串通解出来，都是让你在通解中选出一些特殊的解，比如一个数对于另一个数的乘法逆元</p>

<p>什么叫乘法逆元？</p>

<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/1343224026_2157.png" alt="" /></p>

<p>这里，我们称 x 是 a 关于 m 的乘法逆元</p>

<p>这怎么求？可以等价于这样的表达式： a*x + m*y = 1</p>

<p>看出什么来了吗？没错，当gcd(a , m) != 1 的时候是没有解的这也是 a*x + b*y = c 有解的充要条件： c % gcd(a , b) == 0</p>

<p>接着乘法逆元讲，一般，我们能够找到无数组解满足条件，但是一般是让你求解出最小的那组解，怎么做？我们求解出来了一个特殊的解 x0 那么，我们用 x0 % m其实就得到了最小的解了。为什么？</p>

<p>可以这样思考：</p>

<p>x 的通解不是 x0 + m*t 吗？</p>

<p>那么，也就是说， a 关于 m 的逆元是一个关于 m 同余的，那么根据最小整数原理，一定存在一个最小的正整数，它是 a 关于m 的逆元，而最小的肯定是在（0 , m）之间的，而且只有一个，这就好解释了。</p>

<p>可能有人注意到了，这里，我写通解的时候并不是 x0 + (m/gcd)*t ，但是想想一下就明白了，gcd = 1，所以写了跟没写是一样的，但是，由于问题的特殊性，有时候我们得到的特解 x0 是一个负数，还有的时候我们的 m 也是一个负数这怎么办？</p>

<p>当 m 是负数的时候，我们取 m 的绝对值就行了，当 x0 是负数的时候，他模上 m 的结果仍然是负数（在计算机计算的结果上是这样的，虽然定义的时候不是这样的），这时候，我们仍然让 x0 对abs(m) 取模，然后结果再加上abs(m) 就行了，于是，我们不难写出下面的代码求解一个数 a 对于另一个数 m 的乘法逆元：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">extend_gcd</span> <span class="p">(</span><span class="n">ll</span> <span class="n">a</span> <span class="p">,</span> <span class="n">ll</span> <span class="n">b</span> <span class="p">,</span> <span class="n">ll</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="n">ll</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">,</span> <span class="n">ll</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">){</span><span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>
	<span class="k">else</span> <span class="p">{</span><span class="n">extend_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="n">y</span><span class="o">-=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">);}</span>
<span class="p">}</span>
<span class="n">ll</span> <span class="nf">inv</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span> <span class="n">ll</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//计算%m下 a的逆。如果不存在逆return -1;
</span><span class="c1"></span>	<span class="n">ll</span> <span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">m</span><span class="o">=</span><span class="n">abs</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">extend_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">m</span><span class="p">)</span><span class="o">%</span><span class="nl">m</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="中国剩余定理">中国剩余定理</h1>

<h2 id="算法思想-2">算法思想</h2>

<p>问题：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p>

<p>解法：三三数之剩二，置一百四十；五五数之剩三，置六十三；七七数之剩二，置二十三，并之，得二百三十三。以二百一十减之，即得。凡三三数之剩一，则置七十；五五数之剩一，则置二十一；七七数之剩一，则置十五。一百六以上，一百五减之，即得。</p>

<p>说明白一点就是说，存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。上面给出了解法。再明白这个解法的原理之前，需要先知道一下两个定理。</p>

<p>定理1：几个数相加，如果只有一个加数，不能被数a整除，而其他加数均能被数a整除，那么它们的和，就不能被整数a整除。</p>

<p>定理2：二数不能整除，若被除数扩大（或缩小）了几倍，而除数不变，则其余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。</p>

<p>这两个定理浅显易懂就不再赘述了。</p>

<p>先给出求解该问题的具体步骤：</p>

<ol>
<li><p>求出最小公倍数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">lcm=3\*5\*7=105</pre></td></tr></table>
</div>
</div></li>

<li><p>求各个数所对应的基础数</p>

<ol>
<li><p>105÷3=35</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">35÷3=11......2 //基础数35(满足除3余2)</pre></td></tr></table>
</div>
</div></li>

<li><p>105÷5=21</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">21÷5=4......1</pre></td></tr></table>
</div>
</div>
<p>定理2把1扩大3倍得到3，那么被除数也扩大3倍，得到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">21\*3=63//基础数63(满足除5余3)</pre></td></tr></table>
</div>
</div></li>

<li><p>105÷7=15</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">15÷7=2......1</pre></td></tr></table>
</div>
</div>
<p>定理2把1扩大2倍得到2，那么被除数也扩大2倍，得到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">15*2=30//基础数30(满足除7余2)</pre></td></tr></table>
</div>
</div></li>
</ol></li>

<li><p>把得到的基础数加和（注意：基础数不一定就是正数）
35+63+30=128</p></li>

<li><p>减去最小公倍数lcm（在比最小公倍数大的情况下）
x=128-105=23</p></li>
</ol>

<p>那么满足题意得最小的数就是23了。一共有四个步骤。下面详细解释每一步的原因。</p>

<p>（1）最小公倍数就不用解释了，跳过（记住，这里讨论的都是两两互质的情况）</p>

<p>（2）观察求每个数对应的基础数时候的步骤，比如第一个。105÷3=35。显然这个35是除了当前这个数不能整除以外都能够被其他数整除，就是其他数的最小公倍数。相当于找到了最小的开始值，用它去除以3发现正好余2。那么这个基础数就是35。记住35的特征，可以整除其他数但是不能被3整除，并且余数是2。</p>

<p>再看下一个5对应基础数。21是其他数的最小公倍数，但是不能被5整除，用21除以5得到的余数是1，而要求的数除以5应该是余1的。所以余数被扩大，就得到了相应的基础数63。记住这个数的特征，可以被其他数整除但是被5除应该余三。同理，我们得到了第三个基础数23，那么他的特征就是：可以被其他数整除，但是不能被7整除，并且余数为2。</p>

<p>（3）第三步基础数加和，为什么要这样做呢？利用就是上面提到的定理1。</p>

<p>35+63+30=128。对于3来说，可以把63+30的和看作一个整体，应该他们都可以被3整除。看着上面写出的三个数的特征，运用定理1来说，就是在35的基础上加上一个可以被3整除的倍数，那么得到的结果依然还是满足原先的性质的，就是128除以同样还是余2的。同理，对于5还说，这个数被除之后会剩余3；对于7来说，被除之后剩余2。所以说，我们当前得到的这个数是满足题目要求的一个数。但是这个数是不是最小的，那就不一定了。</p>

<p>（4）应该不能确定是不是最小的数，这个时候就要用到他们的最小公倍数了。最小公倍数顾名思义，一定是一个同时被几个数整除的最小的一个数，所以减去它剩余下来的余数还是符合题意要求的。当然也同样可以运用定理1来解释，只不过是加法变成了减法，道理还是一样的。当然具体要不要减还是要看和lcm的大小关系的。</p>

<h2 id="编码">编码</h2>

<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170803-183009@2x.png" alt="" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">CRT</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">m</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//M=m1*m2*m3…………*mn
</span><span class="c1"></span>        <span class="n">M</span> <span class="o">*=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">extend_Euclid</span><span class="p">(</span><span class="n">Mi</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span><span class="c1">//扩展欧几里得求逆元x，因为mi互素，此处直接普通扩展欧几里得就可求得逆元
</span><span class="c1"></span>        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">Mi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">M</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ans</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ans</span> <span class="o">+=</span> <span class="n">M</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>我们能够针对每一个mi都能够求出来一个Mi，但是注意基础数可以是负数呀。同时我们看到函数的语句ans = (ans + Mi * x * a[i]) % M;负数取余难道不会受影响吗？答案是不会的。对于负数取余，不同的语言有不同的标准，举个简单例子：-7%3。在C++语言里面，答案是-1，Java语言里面也是-1，但是在Python里面就是2了。但不管是-1还是2都是对了.</p>

<p>(n+ret%n)%n;这是return语句。加了n之后再取余，得到的就是最小的正余数了，真是机智。同样你要是觉得不够保险，可以把上面的语句改成ans = (ans + Mi * x * a[i]+M) % M;这样足够保险了。同样，在其他题目里面凡是遇到取余的操作都需要去这样做，就可以消除因为编译器不同带来的烦恼了。</p>

<h2 id="举例-1">举例</h2>

<p>问题描述</p>

<p>人自出生起就有体力，情感和智力三个生理周期，分别为23，28和33天。一个周期内有一天为峰值，在这一天，人在对应的方面（体力，情感或智力）表现最好。通常这三个周期的峰值不会是同一天。现在给出三个日期，分别对应于体力，情感，智力出现峰值的日期。然后再给出一个起始日期，要求从这一天开始，算出最少再过多少天后三个峰值同时出现。</p>

<p>问题分析</p>

<p>首先我们要知道，任意两个峰值之间一定相距整数倍的周期。假设一年的第N天达到峰值，则下次达到峰值的时间为N+Tk(T是周期，k是任意正整数)。所以，三个峰值同时出现的那一天(S)应满足</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">  S = N1 + T1*k1 = N2 + T2*k2 = N3 + T3*k3</pre></td></tr></table>
</div>
</div>
<p>N1,N2,N3分别为为体力，情感，智力出现峰值的日期， T1，T2,T3分别为体力，情感，智力周期。 我们需要求出k1,k2,k3三个非负整数使上面的等式成立。</p>

<p>思路:</p>

<p>想直接求出k1,k2,k3貌似很难，但是我们的目的是求出S， 可以考虑从结果逆推。根据上面的等式，S满足三个要求：除以T1余数为N1，除以T2余数为N2，除以T3余数为N3。这样我们就把问题转化为求一个最小数，该数除以T1余N1，除以T2余N2,除以T3余N3。这就是著名的中国剩余定理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">extend_Euclid</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="c1">//扩展欧几里得
</span><span class="c1"></span><span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">extend_Euclid</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">CRT</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">m</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//M=m1*m2*m3…………*mn
</span><span class="c1"></span>        <span class="n">M</span> <span class="o">*=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">extend_Euclid</span><span class="p">(</span><span class="n">Mi</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span><span class="c1">//扩展欧几里得求逆元x，因为mi互素，此处直接普通扩展欧几里得就可求得逆元
</span><span class="c1"></span>        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">Mi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">M</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ans</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ans</span> <span class="o">+=</span> <span class="n">M</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="o">&gt;&gt;</span><span class="n">e</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">e</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">CRT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ans</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="mi">21252</span><span class="p">;</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Case &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">++&lt;&lt;</span><span class="s">&#34;: the next triple peak occurs in &#34;</span><span class="o">&lt;&lt;</span><span class="n">ans</span> <span class="o">-</span> <span class="n">d</span><span class="o">&lt;&lt;</span><span class="s">&#34; days.&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-08-02
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">欧拉函数浅析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%9E%90/">
            <span class="next-text nav-default">矩阵快速幂解析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="forzfuyao@email.com" class="iconfont icon-email" title="email"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
