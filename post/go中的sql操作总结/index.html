<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go中的SQL操作总结 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.55.6 with theme even" />


<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84sql%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go中的SQL操作总结" />
<meta property="og:description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84sql%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/" />
<meta property="article:published_time" content="2018-12-20T15:40:47&#43;00:00"/>
<meta property="article:modified_time" content="2018-12-20T15:40:47&#43;00:00"/>

<meta itemprop="name" content="Go中的SQL操作总结">
<meta itemprop="description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，">


<meta itemprop="datePublished" content="2018-12-20T15:40:47&#43;00:00" />
<meta itemprop="dateModified" content="2018-12-20T15:40:47&#43;00:00" />
<meta itemprop="wordCount" content="20277">



<meta itemprop="keywords" content="Go,Mysql," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的SQL操作总结"/>
<meta name="twitter:description" content="连接与连接池 database/sql database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go中的SQL操作总结</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-12-20 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 20277 字 </span>
          <span class="more-meta"> 预计阅读 41 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#连接与连接池">连接与连接池</a>
<ul>
<li><a href="#database-sql">database/sql</a></li>
<li><a href="#warming-up">warming up</a></li>
<li><a href="#sql-db">sql.DB</a>
<ul>
<li><a href="#连接池">连接池</a></li>
</ul></li>
<li><a href="#连接失败">连接失败</a></li>
<li><a href="#连接池配置">连接池配置</a></li>
</ul></li>
<li><a href="#curd基础">CURD基础</a>
<ul>
<li><a href="#数据库查询">数据库查询</a></li>
<li><a href="#读取数据">读取数据</a></li>
<li><a href="#读取单条记录">读取单条记录</a></li>
<li><a href="#rows-scan原理">rows.Scan原理</a></li>
<li><a href="#空值处理">空值处理</a></li>
<li><a href="#自动匹配字段">自动匹配字段</a></li>
<li><a href="#exec">Exec</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#prepared剖析">Prepared剖析</a>
<ul>
<li><a href="#prepare">prepare</a></li>
<li><a href="#参数占位符语法">参数占位符语法</a></li>
<li><a href="#查询">查询</a>
<ul>
<li><a href="#prepared">prepared</a></li>
<li><a href="#golang的pliantext和prepare查询方式">golang的pliantext和prepare查询方式</a></li>
</ul></li>
<li><a href="#自定义prepare-查询">自定义prepare 查询</a></li>
<li><a href="#总结-1">总结</a></li>
</ul></li>
<li><a href="#transaction-事务">Transaction 事务</a>
<ul>
<li><a href="#tx对象">tx对象</a></li>
<li><a href="#事务与连接">事务与连接</a></li>
<li><a href="#事务并发">事务并发</a></li>
<li><a href="#事务中的准备语句">事务中的准备语句</a></li>
<li><a href="#总结-2">总结</a></li>
</ul></li>
<li><a href="#错误处理">错误处理</a>
<ul>
<li><a href="#遍历结果集的错误">遍历结果集的错误</a></li>
<li><a href="#关闭结果集的错误">关闭结果集的错误</a></li>
<li><a href="#queryrow-的错误">QueryRow()的错误</a></li>
<li><a href="#识别特定的数据库错误">识别特定的数据库错误</a></li>
<li><a href="#处理连接错误">处理连接错误</a></li>
</ul></li>
<li><a href="#惊喜-反模式和限制">惊喜，反模式和限制</a>
<ul>
<li><a href="#资源枯竭">资源枯竭</a></li>
<li><a href="#巨大的uint64值">巨大的uint64值</a></li>
<li><a href="#连接状态不匹配">连接状态不匹配</a></li>
<li><a href="#数据库特定的语法">数据库特定的语法</a></li>
<li><a href="#多个结果集">多个结果集</a></li>
<li><a href="#调用存储过程">调用存储过程</a></li>
<li><a href="#多个声明支持">多个声明支持</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h1 id="连接与连接池">连接与连接池</h1>

<h2 id="database-sql">database/sql</h2>

<p>database/sql是golang的标准库之一，它提供了一系列接口方法，用于访问关系数据库。它并不会提供数据库特有的方法，那些特有的方法交给数据库驱动去实现。</p>

<p>database/sql库提供了一些type。这些类型对掌握它的用法非常重要。</p>

<ul>
<li>DB 数据库对象。 sql.DB类型代表了数据库。和其他语言不一样，它并是数据库连接。golang中的连接来自内部实现的连接池，连接的建立是惰性的，当你需要连接的时候，连接池会自动帮你创建。通常你不需要操作连接池。一切都有go来帮你完成。</li>
<li>Results 结果集。数据库查询的时候，都会有结果集。sql.Rows类型表示查询返回多行数据的结果集。sql.Row则表示单行查询结果的结果集。当然，对于插入更新和删除，返回的结果集类型为sql.Result。</li>
<li>Statements 语句。sql.Stmt类型表示sql查询语句，例如DDL，DML等类似的sql语句。可以把当成prepare语句构造查询，也可以直接使用sql.DB的函数对其操作。</li>
</ul>

<h2 id="warming-up">warming up</h2>

<p>下面就开始我们的sql数据库之旅，我们使用mysql数据库为例子，驱动使用go-sql-driver/mysql。</p>

<p>对于其他语言，查询数据的时候需要创建一个连接，对于go而言则是需要创建一个数据库抽象对象。连接将会在查询需要的时候，由连接池创建并维护。使用sql.Open函数创建数据库对象。它的第一个参数是数据库驱动名，第二个参数是一个连接字串（符合DSN风格，可以是一个tcp连接，一个unix socket等）。</p>

<p>构建连接, 格式是：&rdquo;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&rdquo;</p>

<p>打开数据库,前者是驱动名，所以要导入： _ &ldquo;github.com/go-sql-driver/mysql&rdquo;</p>

<p>设置数据库最大连接数和设置上数据库最大闲置连接数</p>

<p>验证连接：使用Ping()函数</p>

<p>代码参考如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//数据库配置
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">userName</span> <span class="p">=</span> <span class="s">&#34;root&#34;</span>
    <span class="nx">password</span> <span class="p">=</span> <span class="s">&#34;123456&#34;</span>
    <span class="nx">ip</span> <span class="p">=</span> <span class="s">&#34;127.0.0.1&#34;</span>
    <span class="nx">port</span> <span class="p">=</span> <span class="s">&#34;3306&#34;</span>
    <span class="nx">dbName</span> <span class="p">=</span> <span class="s">&#34;loginserver&#34;</span>
<span class="p">)</span>
<span class="c1">//Db数据库连接池
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">DB</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span>

<span class="c1">//注意方法名大写，就是public
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">InitDB</span><span class="p">()</span>  <span class="p">{</span>
    <span class="c1">//构建连接：&#34;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&#34;
</span><span class="c1"></span>    <span class="nx">path</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="nx">userName</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="s">&#34;@tcp(&#34;</span><span class="p">,</span><span class="nx">ip</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">,</span> <span class="s">&#34;)/&#34;</span><span class="p">,</span> <span class="nx">dbName</span><span class="p">,</span> <span class="s">&#34;?charset=utf8&#34;</span><span class="p">},</span> <span class="s">&#34;&#34;</span><span class="p">)</span>

    <span class="c1">//打开数据库,前者是驱动名，所以要导入： _ &#34;github.com/go-sql-driver/mysql&#34;
</span><span class="c1"></span>    <span class="nx">DB</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
    <span class="c1">//设置数据库最大连接数
</span><span class="c1"></span>    <span class="nx">DB</span><span class="p">.</span><span class="nf">SetConnMaxLifetime</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1">//设置上数据库最大闲置连接数
</span><span class="c1"></span>    <span class="nx">DB</span><span class="p">.</span><span class="nf">SetMaxIdleConns</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="c1">//验证连接
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">DB</span><span class="p">.</span><span class="nf">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;opon database fail&#34;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;connnect success&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>创建了数据库对象之后，在函数退出的时候，需要释放连接，即调用sql.Close方法。例子使用了defer语句设置释放连接。
接下来进行一些基本的数据库操作，首先我们使用Exec方法执行一条sql，创建一个数据表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;CREATE TABLE IF NOT EXISTS test.hello(world varchar(50))&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>此时可以看见，数据库生成了一个新的表。接下来再插入一些数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>

    <span class="o">...</span>

    <span class="nx">rs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;INSERT INTO test.hello(world) VALUES (&#39;hello world&#39;)&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rowCount</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rs</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;inserted %d rows&#34;</span><span class="p">,</span> <span class="nx">rowCount</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>同样使用Exec方法即可插入数据，返回的结果集对象是是一个sql.Result类型，它有一个LastInsertId方法，返回插入数据后的id。当然此例的数据表并没有id字段，就返回一个0.</p>

<p>插入了一些数据，接下来再简单的查询一下数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>
    
    <span class="o">...</span> 
    
    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found row containing %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>我们使用了Query方法执行select查询语句，返回的是一个sql.Rows类型的结果集。迭代后者的Next方法，然后使用Scan方法给变量s赋值，以便取出结果。最后再把结果集关闭（释放连接）。</p>

<p>通过上面一个简单的例子，介绍了database/sql的基本数据查询操作。而对于开篇所说的几个结构类型尚未进行详细的介绍。下面我们再针对database/sql库的类型和数据库交互做更深的探究。</p>

<h2 id="sql-db">sql.DB</h2>

<p>正如上文所言，sql.DB是数据库的抽象，虽然通常它容易被误以为是数据库连接。它提供了一些跟数据库交互的函数，同时管理维护一个数据库连接池，帮你处理了单调而重复的管理工作，并且在多个goroutines也是十分安全。</p>

<p>虽然在完成数据库之后Close()数据库是惯用的，但是sql.DB对象被设计为长连接。不要经常Open()和Close()数据库。相反，为你需要访问的每个不同的数据存储创建一个sql.DB对象，并保留它，直到程序访问数据存储完毕。在需要时传递它，或在全局范围内使其可用，但要保持开放。并且不要从短暂的函数中Open()和Close()。相反，通过sql.DB作为参数传递给该短暂的函数。</p>

<p>如果你不把sql.DB视为长期存在的对象，则可能会遇到诸如重复使用和连接共享不足，耗尽可用的网络资源以及由于TIME_WAIT中剩余大量TCP连接而导致的零星故障的状态。这些问题表明你没有像设计的那样使用database/sql的迹象。</p>

<p>创建数据库对象需要引入标准库database/sql，同时还需要引入驱动go-sql-driver/mysql。使用_表示引入驱动的变量，这样做的目的是为了在你的代码中不至于和标注库的函数变量namespace冲突。</p>

<h3 id="连接池">连接池</h3>

<p>只用sql.Open函数创建连接池，可是此时只是初始化了连接池，并没有创建任何连接。连接创建都是惰性的，只有当你真正使用到连接的时候，连接池才会创建连接。连接池很重要，它直接影响着你的程序行为。</p>

<p>连接池的工作原来却相当简单。当你的函数(例如Exec，Query)调用需要访问底层数据库的时候，函数首先会向连接池请求一个连接。如果连接池有空闲的连接，则返回给函数。否则连接池将会创建一个新的连接给函数。一旦连接给了函数，连接则归属于函数。函数执行完毕后，要不把连接所属权归还给连接池，要么传递给下一个需要连接的（Rows）对象，最后使用完连接的对象也会把连接释放回到连接池。</p>

<p>database/sql包中有一个基本的连接池。没有很多的控制或检查能力，但这里有一些你可能会发现有用的知识：</p>

<ul>
<li>连接池意味着在单个数据库上执行两个连续的语句可能会打开两个链接并单独执行它们。对于程序员来说，为什么它们的代码行为不当，这是相当普遍的。例如，后面跟着INSERT的LOCK TABLES可能会被阻塞，因为INSERT位于不具有表锁定的连接上。</li>
<li>连接是在需要时创建的，池中没有空闲连接。</li>
<li>默认情况下，连接数量没有限制。如果你尝试同时执行很多操作，可以创建任意数量的连接。这可能导致数据库返回错误，例如“连接太多”。</li>
<li>在Golang1.1或更新版本中，你可以使用db.SetMaxIdleConns(N)来限制池中的空闲连接数。这并不限制池的大小。</li>
<li>在Golang1.2.1或更新版本中，可以使用db.SetMaxOpenConns(N)来限制于数据库的总打开连接数。不幸的是，一个死锁bug（修复）阻止db.SetMaxOpenConns(N)在1.2中安全使用。</li>
<li>连接回收相当快。使用db.SetMaxIdleConns(N)设置大量空闲连接可以减少此流失，并有助于保持连接以重新使用。</li>
<li>长期保持连接空闲可能会导致问题（例如在微软azure上的这个问题）。尝试db.SetMaxIdleConns(0)如果你连接超时，因为连接空闲时间太长。</li>
</ul>

<p>请求一个连接的函数有好几种，执行完毕处理连接的方式稍有差别，大致如下：</p>

<ul>
<li>db.Ping() 调用完毕后会马上把连接返回给连接池。</li>
<li>db.Exec() 调用完毕后会马上把连接返回给连接池，但是它返回的Result对象还保留这连接的引用，当后面的代码需要处理结果集的时候连接将会被重用。</li>
<li>db.Query() 调用完毕后会将连接传递给sql.Rows类型，当然后者迭代完毕或者显示的调用.Clonse()方法后，连接将会被释放回到连接池。</li>
<li>db.QueryRow()调用完毕后会将连接传递给sql.Row类型，当.Scan()方法调用之后把连接释放回到连接池。</li>
<li>db.Begin() 调用完毕后将连接传递给sql.Tx类型对象，当.Commit()或.Rollback()方法调用后释放连接。</li>
</ul>

<p>因为每一个连接都是惰性创建的，如何验证sql.Open调用之后，sql.DB对象可用呢？通常使用db.Ping()方法初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;driverName&#34;</span><span class="p">,</span> <span class="s">&#34;dataSourceName&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Ping</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>调用了Ping之后，连接池一定会初始化一个数据库连接。当然，实际上对于失败的处理，应该定义一个符合自己需要的方式，现在为了演示，简单的使用log.Fatalln(err)表示了。</p>

<h2 id="连接失败">连接失败</h2>

<p>关于连接池另外一个知识点就是你不必检查或者尝试处理连接失败的情况。当你进行数据库操作的时候，如果连接失败了，database/sql会帮你处理。实际上，当从连接池取出的连接断开的时候，database/sql会自动尝试重连10次。仍然无法重连的情况下会自动从连接池再获取一个或者新建另外一个。好比去买鸡蛋，售货员会从箱子里掏出鸡蛋，如果发现是坏蛋则连续掏10次，仍然找不到合适的就会换一个箱子招，或者从别的库房再拿一个给你。</p>

<h2 id="连接池配置">连接池配置</h2>

<p>无论哪一个版本的go都不会提供很多控制连接池的接口。知道1.2版本以后才有一些简单的配置。可是1.2版本的连接池有一个bug，请升级更高的版本。</p>

<p>配置连接池有两个的方法：</p>

<ul>
<li>db.SetMaxOpenConns(n int) 设置打开数据库的最大连接数。包含正在使用的连接和连接池的连接。如果你的函数调用需要申请一个连接，并且连接池已经没有了连接或者连接数达到了最大连接数。此时的函数调用将会被block，直到有可用的连接才会返回。设置这个值可以避免并发太高导致连接mysql出现too many connections的错误。该函数的默认设置是0，表示无限制。</li>
<li>db.SetMaxIdleConns(n int) 设置连接池中的保持连接的最大连接数。默认也是0，表示连接池不会保持释放会连接池中的连接的连接状态：即当连接释放回到连接池的时候，连接将会被关闭。这会导致连接再连接池中频繁的关闭和创建。</li>
</ul>

<p>对于连接池的使用依赖于你是如何配置连接池，如果使用不当会导致下面问题：</p>

<ul>
<li>大量的连接空闲，导致额外的工作和延迟。</li>
<li>连接数据库的连接过多导致错误。</li>
<li>连接阻塞。</li>
<li>连接池有超过十个或者更多的死连接，限制就是10次重连。</li>
</ul>

<p>大多数时候，如何使用sql.DB对连接的影响大过连接池配置的影响。这些具体问题我们会在使用sql.DB的时候逐一介绍。
掌握了database/sql关于数据库连接池管理内容，下一步则是使用这些连接，进行数据的交互操作啦。</p>

<h1 id="curd基础">CURD基础</h1>

<h2 id="数据库查询">数据库查询</h2>

<p>我们了解了数据库连接与连接池。拿到了连接当然就是为了跟数据库交互。对于数据库交互，无怪乎两类操作，读和写。其中怎么读，怎么写，读和写的过程糅合一起就会遇到复杂的事务。本篇内容主要关注数据库的读写操作，后面再涉及事务的介绍。</p>

<h2 id="读取数据">读取数据</h2>

<p>database/sql提供了Query和QueryRow方法进行查询数据库。对于Query方法的原理，正如前文介绍的主要分为三步：</p>

<ol>
<li>从连接池中请求一个连接</li>
<li>执行查询的sql语句</li>
<li>将数据库连接的所属权传递给Result结果集</li>
</ol>

<p>Query返回的结果集是sql.Rows类型。它有一个Next方法，可以迭代数据库的游标，进而获取每一行的数据，大概使用范式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found row containing %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span></code></pre></td></tr></table>
</div>
</div>
<p>上述代码我们已经见过好多次了，想必大家都轻车熟路啦。rows.Next方法设计用来迭代。当它迭代到最后一行数据之后，会触发一个io.EOF的信号，即引发一个错误，同时go会自动调用rows.Close方法释放连接，然后返回false。此时循环将会结束退出。</p>

<p>通常你会正常迭代完数据然后退出循环。可是如果并没有正常的循环而因其他错误导致退出了循环。此时rows.Next处理结果集的过程并没有完成，归属于rows的连接不会被释放回到连接池。因此十分有必要正确的处理rows.Close事件。如果没有关闭rows连接，将导致大量的连接并且不会被其他函数重用，就像溢出了一样。最终将导致数据库无法使用。</p>

<p>那么如何阻止这样的行为呢？上述代码已经展示，无论循环是否完成或者因为其他原因退出，都显示的调用rows.Close方法，确保连接释放。又或者使用defer指令在函数退出的时候释放连接，即使连接已经释放了，rows.Close仍然可以调用多次，是无害的。</p>

<p>使用defer的时候需要注意，如果一个函数执行很长的逻辑，例如main函数，那么rows的连接释放就会也很长，好的实践方案是尽可能的越早释放连接。</p>

<p>rows.Next循环迭代的时候，因为触发了io.EOF而退出循环。为了检查是否是迭代正常退出还是异常退出，需要检查rows.Err。例如上面的代码应该改成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;found row containing %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>其中的几个部分很容易出错，可能会产生不良后果。
* 你应该总是检查rows.Next()循环结尾处的错误。如果循环中出现错误，则需要了解它。不要仅仅假设循环遍历，直到你已经处理了所有的行。
* 第二，只要有一个打开的结果集(由行代表)，底层连接就很忙，不能用于任何其他查询。这意味着它在连接池中不可用。如果你使用rows.Next()遍历所有行，最终将读取最后一行，rows.Next()将遇到内部EOF错误，并为你调用rows.Close()。但是，如果由于某种原因退出该循环-提前返回，那么行不会关闭，并且连接保持打开状态。(如果rows.Next()由于错误而返回false，则会自动关闭)。这是一种简单耗尽资源的方法。
* rows.Close()是一种无害的操作，如果它已经关闭，所以你可以多次调用它。但是请注意，我们首先检查错误，如果没有错误，则调用rows.Close()，以避免运行时的panic。
* 你应该总是用延迟语句defer推迟rows.Close()，即使你也在循环结束时调用rows.Close()，这不是一个坏主意。
* 不要在循环中用defer推迟。延迟语句在函数退出之前不会执行，所以长时间运行的函数不应该使用它。如果你这样做，你会慢慢积累记忆。如果你在循环中反复查询和使用结果集，则在完成每个结果后应显示的调用rows.Close()，而不用延迟语句defer。</p>

<h2 id="读取单条记录">读取单条记录</h2>

<p>Query方法是读取多行结果集，实际开发中，很多查询只需要单条记录，不需要再通过Next迭代。golang提供了QueryRow方法用于查询单条记录的结果集。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT world FROM test.hello LIMIT 1&#34;</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">ErrNoRows</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;There is not row&#34;</span><span class="p">)</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;found a row&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>QueryRow方法的使用很简单，它要么返回sql.Row类型，要么返回一个error，如果是发送了错误，则会延迟到Scan调用结束后返回，如果没有错误，则Scan正常执行。只有当查询的结果为空的时候，会触发一个sql.ErrNoRows错误。你可以选择先检查错误再调用Scan方法，或者先调用Scan再检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>如果id为1的不存在，err为sql.ErrNoRows，一般应用中不存在的情况都需要单独处理。此外，Query返回的错误都会延迟到Scan被调用，所以应该写成如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">ErrNoRows</span> <span class="p">{</span>
        <span class="c1">// there were no rows, but otherwise no error occurred
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>把空结果当做Error处理是为了强行让程序员处理结果为空的情况</p>

<h2 id="rows-scan原理">rows.Scan原理</h2>

<p>结果集方法Scan可以把数据库取出的字段值赋值给指定的数据结构。它的参数是一个空接口的切片，这就意味着可以传入任何值。通常把需要赋值的目标变量的指针当成参数传入，它能将数据库取出的值赋值到指针值对象上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">var1</span><span class="p">,</span> <span class="nx">var2</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">row</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">var1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">var2</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>在一些特殊案例中，如果你不想把值赋值给指定的目标变量，那么需要使用*sql.RawBytes类型。如何使用*sql.RawBytes需要参考更细的官方文档。大多数情况下我们不必这么做。但是还是需要注意在db.QueryRow().Scan()中不能使用 *sql.RawBytes。</p>

<p>Scan还会帮我们自动推断除数据字段匹配目标变量。比如有个数据库字段的类型是VARCHAR，而他的值是一个数字串，例如&rdquo;1&rdquo;。如果我们定义目标变量是string，则scan赋值后目标变量是数字string。如果声明的目标变量是一个数字类型，那么scan会自动调用strconv.ParseInt()或者strconv.ParseInt()方法将字段转换成和声明的目标变量一致的类型。当然如果有些字段无法转换成功，则会返回错误。因此在调用scan后都需要检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="kt">int</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>此时scan会把字段转变成数字整型的赋值给world变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>此时scan取出的字段就是字串。同样的如果字段是int类型，声明的变量是string类型，scan也会自动将数字转换成字串赋值给目标变量。</p>

<p>但是scan仅支持为某一个变量赋值,不支持对结构体或map赋值,如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="kt">int</span>
    <span class="nx">name</span> <span class="kt">string</span>
    <span class="nx">weight</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="nx">rows</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from test where id = ?&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">line</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">{}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">line</span><span class="p">)</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>运行结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-" data-lang=""><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-" data-lang="">{0 0}</code></pre></td></tr></table>
</div>
</div>
<p>SELECT * 这样做的习惯可不好，一般都是指定字段，这样在scan的时候也相对容易把握变量顺序和个数。scan必须指明所有字段并且顺序要符合查询时候的顺序,正确的做法应该是将line的每个变量分别赋值,而且要保证查询语句里的字段顺序和 struct的字段顺序是一致的，如果sql语句里简单的用＊代替，在sql表字段不变，但顺序改变的时候就会出错。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">line</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">line</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">line</span><span class="p">.</span><span class="nx">weight</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="空值处理">空值处理</h2>

<p>数据库有一个特殊的类型，NULL空值。可是NULL不能通过scan直接跟普遍变量赋值，甚至也不能将null赋值给nil。对于null必须指定特殊的类型，这些类型定义在database/sql库中。例如sql.NullFloat64。如果在标准库中找不到匹配的类型，可以尝试在驱动中寻找。下面是一个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">s1</span> <span class="kt">string</span>
    <span class="nx">s2</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">NullString</span> 
    <span class="nx">i1</span> <span class="kt">int</span>
    <span class="nx">f1</span> <span class="kt">float64</span>
    <span class="nx">f2</span> <span class="kt">float64</span>
<span class="p">)</span>
<span class="c1">// 假设数据库的记录为 [&#34;hello&#34;, NULL, 12345, &#34;12345.6789&#34;, &#34;not-a-float&#34;]
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f2</span><span class="p">)</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>因为最后一个f2字段的值不是float，这会引发一个错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">sql: Scan error on column index 4: converting string &#34;not-a- oat&#34; to a  oat64: strconv.ParseFloat: parsing &#34;not-a- oat&#34;: invalid syntax</pre></td></tr></table>
</div>
</div>
<p>如果忽略err，强行读取目标变量，可以看到最后一个值转换错误会处理，而不是抛出异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f2</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q %#v %d %f %f&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="nx">i1</span><span class="p">,</span> <span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span><span class="p">)</span>

<span class="o">//</span> <span class="nx">输出</span> <span class="s">&#34;hello&#34;</span>  <span class="nx">sql</span><span class="p">.</span><span class="nx">NullString</span><span class="p">{</span><span class="nx">String</span><span class="p">:</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">Valid</span><span class="p">:</span><span class="kc">false</span><span class="p">}</span> <span class="mi">12345</span> <span class="mf">12345.678900</span> <span class="mf">0.000000</span></code></pre></td></tr></table>
</div>
</div>
<p>可以看到，除了最后一个转换失败变成了零值之外，其他都正常的取出了值，尤其是null匹配了NullString类型的目标变量。</p>

<p>对于null的操作，通常仍然需要验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">NullString</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT world FROM hello WHERE id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">if</span> <span class="nx">world</span><span class="p">.</span><span class="nx">Valid</span> <span class="p">{</span>
      <span class="nx">wrold</span><span class="p">.</span><span class="nx">String</span> 
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 数据库的value是不是null的时候，输出 world的字符串值， 空字符串   
</span><span class="c1"></span>    <span class="nx">world</span><span class="p">.</span><span class="nx">String</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>对应的，如果world字段是一个int，那么声明的目标变量类似是sql.NullInt64，读取其值的方法为world.Int64。</p>

<p>但是有时候我们并不关心值是不是Null,我们只需要把他当一个空字符串来对待就行。这时候我们可以使用[]byte（null byte[]可以转化为空string）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">world</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT world FROM hello WHERE id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">world</span><span class="p">)</span>
<span class="o">...</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">real_name</span><span class="p">))</span> <span class="o">//</span> <span class="nx">有值则取出字串值</span><span class="err">，</span><span class="nx">null则转换成</span> <span class="nx">空字串</span><span class="err">。</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="自动匹配字段">自动匹配字段</h2>

<p>在执行查询的时候，我们定义了目标变量，同时查询的时候也写明了字段，如果不指名字段，或者字段的顺序和查询的不一样，都有可能出错。因此如果能够自动匹配查询的字段值，将会十分节省代码，同时也易于维护。</p>

<p>go提供了Columns方法用获取字段名，与大多数函数一样，读取失败将会返回一个err，因此需要检查错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">cols</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">er</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>对于不定字段查询，我们可以定义一个map的key和value用来表示数据库一条记录的row的值。通过rows.Columns得到的col作为map的key值。下面是一个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:@tcp(127.0.0.1:3306)/test?parseTime=true&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = 1&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>


    <span class="nx">cols</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Columns</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cols</span><span class="p">)</span>
    <span class="nx">vals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cols</span><span class="p">))</span>
    <span class="nx">scans</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cols</span><span class="p">))</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span><span class="p">{</span>
        <span class="nx">scans</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">results</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>

    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">(){</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="nx">scans</span><span class="o">...</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">row</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span><span class="p">{</span>
            <span class="nx">key</span> <span class="o">:=</span> <span class="nx">cols</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
            <span class="nx">row</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">results</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span><span class="k">range</span> <span class="nx">results</span><span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>数据表user有三个字段，id（int），gid（int），real_name（varchar）。我们使用*取出所有的字段。使用rows.Columns()获取字段名，是一个string的数组。然后创建一个切片vals，用来存放所取出来的数据结果，类似是byte的切片。接下来还需要定义一个切片，这个切片用来scan，将数据库的值复制到给它。</p>

<p>完成这一步之后，vals则得到了scan复制给他的值，因为是byte的切片，因此在循环一次，将其转换成string即可。</p>

<p>转换后的row即我们取出的数据行值，最后组装到result切片中。</p>

<p>运行结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="p">[</span><span class="nx">id</span> <span class="nx">gid</span> <span class="nx">real_name</span><span class="p">]</span>
<span class="mi">0</span> <span class="kd">map</span><span class="p">[</span><span class="nx">id</span><span class="p">:</span><span class="mi">4</span> <span class="nx">gid</span><span class="p">:</span><span class="mi">1</span> <span class="nx">real_name</span><span class="p">:</span><span class="nx">瑟兰督依</span><span class="p">]</span>
<span class="mi">1</span> <span class="kd">map</span><span class="p">[</span><span class="nx">real_name</span><span class="p">:</span><span class="nx">来格拉斯</span> <span class="nx">id</span><span class="p">:</span><span class="mi">5</span> <span class="nx">gid</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span> <span class="kd">map</span><span class="p">[</span><span class="nx">id</span><span class="p">:</span><span class="mi">15</span> <span class="nx">gid</span><span class="p">:</span><span class="mi">1</span> <span class="nx">real_name</span><span class="p">:]</span></code></pre></td></tr></table>
</div>
</div>
<p>有一条记录的 real_name 值为空字串，因为其数据库存储的是NULL。</p>

<h2 id="exec">Exec</h2>

<p>前面介绍了很多关于查询方面的内容，查询是读方便的内容，对于写，即插入更新和删除。这类操作与query不太一样，写的操作只关系是否写成功了。database/sql提供了Exec方法用于执行写的操作。</p>

<p>我们也见识到了，Eexc返回一个sql.Result类型，它有两个方法LastInsertId和RowsAffected。LastInsertId返回是一个数据库自增的id，这是一个int64类型的值。</p>

<p>Exec执行完毕之后，连接会立即释放回到连接池中，因此不需要像query那样再手动调用row的close方法。</p>

<p>使用Exec()，最好用一个准备好的statement来完成INSERT,UPDATE,DELETE或者其他不返回行的语句。下面的示例演示如何插入行并检查有关操作的元数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT INTO users(name) VALUES(?)&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;Dolly&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">lastId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">LastInsertId</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">rowCnt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">RowsAffected</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;ID = %d, affected = %d\n&#34;</span><span class="p">,</span> <span class="nx">lastId</span><span class="p">,</span> <span class="nx">rowCnt</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>执行该语句将生成一个sql.Result，该语句提供对statement元数据的访问：最后插入的ID和行数受到影响。</p>

<p>如果你不在乎结果怎么办？如果你只想执行一个语句并检查是否有错误，但忽略结果该怎么办？下面两个语句不会做同样的事情吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;DELETE FROM users&#34;</span><span class="p">)</span>  <span class="c1">// OK
</span><span class="c1"></span><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;DELETE FROM users&#34;</span><span class="p">)</span> <span class="o">//</span> <span class="nx">BAD</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>虽然用_忽略了返回值,但文件描述符(磁盘io或网络io)需要手动关闭，GC并不会自动处理</strong></p>

<p>答案是否定的。他们不做同样的事情，你不应该使用Query()。Query()将返回一个sql.Rows，它保留数据库连接，直到sql.Rows关闭。由于可能有未读数据(例如更多的数据行)，所以不能使用连接。在上面的示例中，连接将永远不会被释放。垃圾回收器最终会关闭底层的net.Conn，但这可能需要很长时间。此外，database/sql包将继续跟踪池中的连接，希望在某个时候释放它，以便可以再次使用连接。因此，这种反模式是耗尽资源的好方法(例如连接数太多)。</p>

<h2 id="总结">总结</h2>

<p>目前，我们大致了解了数据库的CURD操作。对于读的操作，需要定义目标变量才能scan数据记录。scan会智能的帮我们转换一些数据，取决于定义的目标变量类型。对于null的处理，可以使用database/sql或驱动提供的类型声明，也可以使用[]byte将其转换成空字串。除了读数据之外，对于写的操作，database/sql也提供了Exec方法，并且对于sql.Result提供了LastInsertId和RowsAffected方法用于获取写后的结果。</p>

<p>在实际应用中，与数据库交互，往往写的sql语句还带有参数，这类sql可以称之为prepare语句。prepare语句有很多好处，可以防止sql注入，可以批量执行等。但是prepare的连接管理有其自己的机制，也有其使用上的陷阱，关于prepare的使用，我们将会在以后讨论。</p>

<h1 id="prepared剖析">Prepared剖析</h1>

<h2 id="prepare">prepare</h2>

<p>前面我们已经学习了sql的基本curd操作。总体而言，有两类操作Query和Exec。前者返回数据库记录，后者返回数据库影响或插入相关的结果。上面两种操作，多数是针对单次操作的查询。如果需要批量插入一堆数据，就可以使用Prepared语句。golang处理prepared语句有其独特的行为，了解其底层的实现，对于用好它十分重要。</p>

<h2 id="参数占位符语法">参数占位符语法</h2>

<p>预处理语句中的占位符参数的语法是特定于数据库的。例如，比较MySql,PostgreSQL,Oracle：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">MySQL</span>               <span class="nx">PostgreSQL</span>            <span class="nx">Oracle</span>
<span class="o">====</span><span class="p">=</span>               <span class="o">==========</span>            <span class="o">======</span>
<span class="nx">WHERE</span> <span class="nx">col</span> <span class="p">=</span> <span class="err">?</span>       <span class="nx">WHERE</span> <span class="nx">col</span> <span class="p">=</span> <span class="err">$</span><span class="mi">1</span>        <span class="nx">WHERE</span> <span class="nx">col</span> <span class="p">=</span> <span class="p">:</span><span class="nx">col</span>
<span class="nf">VALUES</span><span class="p">(</span><span class="err">?</span><span class="p">,</span> <span class="err">?</span><span class="p">,</span> <span class="err">?</span><span class="p">)</span>     <span class="nf">VALUES</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">)</span>    <span class="nf">VALUES</span><span class="p">(:</span><span class="nx">val1</span><span class="p">,</span> <span class="p">:</span><span class="nx">val2</span><span class="p">,</span> <span class="p">:</span><span class="nx">val3</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="查询">查询</h2>

<p>我们可以使用Query方式查询记录，Query函数提供了两种选择，第一种情况下参数是拼接好的sql，另外一种情况，第一参数是带有占位符的sql，第二个参数为sql的实际参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = 1&#34;</span><span class="p">)</span>
 
<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>上面两种方式都能获取数据，那么他们的底层实现是一样的么？实际上，上面两种方式的底层通信不完全一样。一种你
是plaintext方式，另外一种是prepared方式。</p>

<h3 id="prepared">prepared</h3>

<p>所谓prepared，即带有占位符的sql语句，客户端将该语句和参数发给mysql服务器。mysql服务器编译成一个prepared语句，这个语句可以根据不同的参数多次调用。prepared语句执行的方式如下：</p>

<ol>
<li>准备prepare语句</li>
<li>执行prepared语句和参数</li>
<li>关闭prepared语句</li>
</ol>

<p>之所以会出现prepare语句方式，主要因为这样有下面的两个好处：</p>

<ol>
<li>避免通过引号组装拼接sql语句。避免sql注入带来的安全风险</li>
<li>可以多次执行的sql语句。</li>
</ol>

<p>单纯的看prepared语句的好处，会下意识的觉得既然如此，都使用prepared语句查询不就好了么？其实不然。关于prepared语句注意事项，稍后再讨论。</p>

<h3 id="golang的pliantext和prepare查询方式">golang的pliantext和prepare查询方式</h3>

<p>现在我们再回顾上面调用Qeury函数的两个操作。对于第一个操作，执行pliantext的sql语句。先看db.Query方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Query executes a query that returns rows, typically a SELECT.
</span><span class="c1">// The args are for any placeholder parameters in the query.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="nx">rows</span> <span class="o">*</span><span class="nx">Rows</span>
 <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
 <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">maxBadConnRetries</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">cachedOrNewConn</span><span class="p">)</span>    <span class="c1">// 查询
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
   <span class="k">break</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">alwaysNewConn</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Query方法我们很熟悉了，它的内部调用了db.query方法，并且根据连接重连的状况选择是cachedOrNewConn模式还是alwaysNewConn模式。前者会从返回一个cached连接或者等待一个可用连接，甚至也可能建立一个新的连接；后者表示打开连接时的策略为每次建立一个新的连接。这就是前面所说的retry2次连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nx">strategy</span> <span class="nx">connReuseStrategy</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">ci</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">conn</span><span class="p">(</span><span class="nx">strategy</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">queryConn</span><span class="p">(</span><span class="nx">ci</span><span class="p">,</span> <span class="nx">ci</span><span class="p">.</span><span class="nx">releaseConn</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>query方法逻辑很简单，通过db.conn方法返回一个新创建或者缓存的空闲连接。driverConn。随机调用queryConn方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// queryConn executes a query on the given connection.
</span><span class="c1">// The connection gets released by the releaseConn function.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">queryConn</span><span class="p">(</span><span class="nx">dc</span> <span class="o">*</span><span class="nx">driverConn</span><span class="p">,</span> <span class="nx">releaseConn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">),</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

 <span class="c1">// 判断驱动是否实现了Queryer
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">queryer</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">ci</span><span class="p">.(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Queryer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">dargs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">driverArgs</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">dc</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="nx">rowsi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">queryer</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">dargs</span><span class="p">)</span>  <span class="c1">// 调用驱动的查询方法  connection.go 第305行
</span><span class="c1"></span>  <span class="nx">dc</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrSkip</span> <span class="p">{</span>  <span class="c1">// 不带参数的返回
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
   <span class="p">}</span>
   <span class="c1">// Note: ownership of dc passes to the *Rows, to be freed
</span><span class="c1"></span>   <span class="c1">// with releaseConn.
</span><span class="c1"></span>   <span class="nx">rows</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Rows</span><span class="p">{</span>
    <span class="nx">dc</span><span class="p">:</span>          <span class="nx">dc</span><span class="p">,</span>
    <span class="nx">releaseConn</span><span class="p">:</span> <span class="nx">releaseConn</span><span class="p">,</span>
    <span class="nx">rowsi</span><span class="p">:</span>       <span class="nx">rowsi</span><span class="p">,</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="kc">nil</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="nx">dc</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="nx">si</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dc</span><span class="p">.</span><span class="nx">ci</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="nx">query</span><span class="p">)</span>  <span class="c1">// 带参数的返回，创建prepare对象
</span><span class="c1"></span> <span class="nx">dc</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">ds</span> <span class="o">:=</span> <span class="nx">driverStmt</span><span class="p">{</span><span class="nx">dc</span><span class="p">,</span> <span class="nx">si</span><span class="p">}</span>
 <span class="nx">rowsi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">rowsiFromStatement</span><span class="p">(</span><span class="nx">ds</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>   <span class="c1">// 执行语句
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">dc</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="nx">si</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
  <span class="nx">dc</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="nf">releaseConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="c1">// Note: ownership of ci passes to the *Rows, to be freed
</span><span class="c1"></span> <span class="c1">// with releaseConn.
</span><span class="c1"></span> <span class="nx">rows</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Rows</span><span class="p">{</span>
  <span class="nx">dc</span><span class="p">:</span>          <span class="nx">dc</span><span class="p">,</span>
  <span class="nx">releaseConn</span><span class="p">:</span> <span class="nx">releaseConn</span><span class="p">,</span>
  <span class="nx">rowsi</span><span class="p">:</span>       <span class="nx">rowsi</span><span class="p">,</span>
  <span class="nx">closeStmt</span><span class="p">:</span>   <span class="nx">si</span><span class="p">,</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>queryConn函数内容比较多。先判断驱动是否实现了Queryer，如果实现了即调用其Query方法。方法会针对sql查询语句做查询。例如mysql的驱动如下，connection.go 第305行左右，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mc</span> <span class="o">*</span><span class="nx">mysqlConn</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">mc</span><span class="p">.</span><span class="nx">netConn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">errLog</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">ErrInvalidConn</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">mc</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">InterpolateParams</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrSkip</span>
  <span class="p">}</span>
  <span class="c1">// try client-side prepare to reduce roundtrip
</span><span class="c1"></span>  <span class="nx">prepared</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">interpolateParams</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">query</span> <span class="p">=</span> <span class="nx">prepared</span>
  <span class="nx">args</span> <span class="p">=</span> <span class="kc">nil</span>
 <span class="p">}</span>
 <span class="c1">// Send command
</span><span class="c1"></span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">writeCommandPacketStr</span><span class="p">(</span><span class="nx">comQuery</span><span class="p">,</span> <span class="nx">query</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="c1">// Read Result
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">resLen</span> <span class="kt">int</span>
  <span class="nx">resLen</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readResultSetHeaderPacket</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">rows</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">textRows</span><span class="p">)</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nx">mc</span> <span class="p">=</span> <span class="nx">mc</span>

   <span class="k">if</span> <span class="nx">resLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// no columns, no more data
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">emptyRows</span><span class="p">{},</span> <span class="kc">nil</span>
   <span class="p">}</span>
   <span class="c1">// Columns
</span><span class="c1"></span>   <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readColumns</span><span class="p">(</span><span class="nx">resLen</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Query先检查参数是否为0，然后调用writeCommandPacketStr方法执行sql并通过readResultSetHeaderPacket读取数据库服务返回的结果。</p>

<p>如果参数不为0，会先判断是否是prepared语句。这里会返回一个driver.ErrSkip错误。把函数执行权再返回到queryConn函数中。然后再调用si, err := dc.ci.Prepare(query)创建Stmt对象，接下来调用rowsiFromStatement执行查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">rowsiFromStatement</span><span class="p">(</span><span class="nx">ds</span> <span class="nx">driverStmt</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">ds</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="nx">want</span> <span class="o">:=</span> <span class="nx">ds</span><span class="p">.</span><span class="nx">si</span><span class="p">.</span><span class="nf">NumInput</span><span class="p">()</span>
 <span class="nx">ds</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

 <span class="c1">// -1 means the driver doesn&#39;t know how to count the number of
</span><span class="c1"></span> <span class="c1">// placeholders, so we won&#39;t sanity check input here and instead let the
</span><span class="c1"></span> <span class="c1">// driver deal with errors.
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">want</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;sql: statement expects %d inputs; got %d&#34;</span><span class="p">,</span> <span class="nx">want</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">args</span><span class="p">))</span>
 <span class="p">}</span>

 <span class="nx">dargs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">driverArgs</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ds</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">ds</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="nx">rowsi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ds</span><span class="p">.</span><span class="nx">si</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">dargs</span><span class="p">)</span>
 <span class="nx">ds</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">rowsi</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>rowsiFromStatement方法会调用驱动的ds.si.Query(dargs)方法，执行最后的查询。大概在statement.go的第84行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">stmt</span> <span class="o">*</span><span class="nx">mysqlStmt</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">mc</span><span class="p">.</span><span class="nx">netConn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">errLog</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">ErrInvalidConn</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span>
 <span class="p">}</span>

 <span class="c1">// Send command
</span><span class="c1"></span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">writeExecutePacket</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">mc</span> <span class="o">:=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">mc</span>

 <span class="c1">// Read Result
</span><span class="c1"></span> <span class="nx">resLen</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readResultSetHeaderPacket</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">rows</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">binaryRows</span><span class="p">)</span>

 <span class="k">if</span> <span class="nx">resLen</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">rows</span><span class="p">.</span><span class="nx">mc</span> <span class="p">=</span> <span class="nx">mc</span>
  <span class="c1">// Columns
</span><span class="c1"></span>  <span class="c1">// If not cached, read them and cache them
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">columns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readColumns</span><span class="p">(</span><span class="nx">resLen</span><span class="p">)</span>
   <span class="nx">stmt</span><span class="p">.</span><span class="nx">columns</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nx">columns</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">columns</span>
   <span class="nx">err</span> <span class="p">=</span> <span class="nx">mc</span><span class="p">.</span><span class="nf">readUntilEOF</span><span class="p">()</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>调用 stmt和参数执行sql查询。查询完毕之后，返回到queryConn方法中，使用releaseConn释放查询的数据库连接。</p>

<h2 id="自定义prepare-查询">自定义prepare 查询</h2>

<p>在数据库级别，将准备好的语句绑定到单个数据库连接。典型的流程是：客户端向服务器发送带有占位符的SQL语句以进行准备，服务器使用语句ID进行响应，然后客户端通过发送其ID和参数来执行该语句。</p>

<p>然而在Golang中，连接不会直接暴露给database/sql包的用户。你不准备连接上语句。你准备好在一个db或tx。并且database/sql具有一些便捷的行为，如自动重试。由于这些原因，准备好的语句和连接(存在于驱动级别)之间的潜在关联被隐藏在代码中。</p>

<p>下面是它的工作原理：</p>

<ol>
<li>准备一个语句时，它会在池中的连接上准备好。</li>
<li>Stmt对象记住使用哪个连接。</li>
<li>当你执行Stmt时，它试图使用Stmt对象记住的那个连接(后面我们将这里的连接称为原始连接)。如果它不可用，因为它关闭或忙于做其他事情，它从池中获取另一个连接，并在另一个连接上重新准备与数据库的语句。</li>
</ol>

<p>因为在原始连接繁忙时将根据需要重新准备语句，所以数据库的高并发使用可能会使很多连接繁忙，从而创建大量预准备语句。这可能导致语句的明显泄漏，正在准备和重新准备的语句比您想象的更频繁，甚至在语句数量上遇到服务器端限制。</p>

<p>从query查询可以看到，对于占位符的prepare语句，go内部通过的dc.ci.Prepare(query)会自动创建一个 stmt对象。其实我们也可以自定义stmt语句，使用方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"> <span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;SELECT * FROM user WHERE gid = ?&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

 <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span>  <span class="nx">stmt</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
 <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>即通过Prepare方法创建一个stmt对象，然后执行stmt对象的Query（Exec）方法得到sql.Rows结果集。最后关闭stmt.Close。这个过程就和之前所说的prepare三步骤匹配了。</p>

<p>创建stmt的prepare方式是golang的一个设计，其目的是Prepare once, execute many times。为了批量执行sql语句。但是通常会造成所谓的三次网络请求（ three network round-trips）。即preparing executing和closing三次请求。</p>

<p>对于大多数数据库，prepread的过程都是，先发送一个带占位符的sql语句到服务器，服务器返回一个statement id，然后再把这个id和参数发送给服务器执行，最后再发送关闭statement命令。</p>

<p>golang的实现了连接池，处理prepare方式也需要特别注意。调用Prepare方法返回stmt的时候，golang会在某个空闲的连接上进行prepare语句，然后就把连接释放回到连接池，可是golang会记住这个连接，当需要执行参数的时候，就再次找到之前记住的连接进行执行，等到stmt.Close调用的时候，再释放该连接。</p>

<p>在执行参数的时候，如果记住的连接正处于忙碌阶段，此时golang将会从新选一个新的空闲连接进行prepare（re-prepare）。当然，即使是重新reprepare，同样也会遇到刚才的问题。那么将会一而再再而三的进行reprepare。直到找到空闲连接进行查询的时候。</p>

<p>这种情况将会导致leak连接的情况，尤其是再高并发的情景。将会导致大量的prepare过程。因此使用stmt的情况需要仔细考虑应用场景，通常在应用程序中。多次执行同一个sql语句的情况并不多，因此减少prepare语句的使用。</p>

<p>之前有一个疑问，是不是所有sql语句都不能带占位符，因为这是prepare语句。只要看了一遍database/sql和驱动的源码才恍然大悟，对于query(prepare, args)的方式，正如我们前面所分析的，database/sql会使用ds.si.Query(dargs)创建stmt的，然后就立即执行prepare和参数，最后关闭stmt。整个过程都是同一个连接上完成，因此不存在reprepare的情况。当然也无法使用所谓的创建一次，执行多次的方式。</p>

<p>对于prepare的使用方式，基于其好处和缺点，我们将会在后面的最佳实践再讨论。目前需要注意的大致就是：</p>

<ol>
<li><p>单次查询不需要使用prepared，每次使用stmt语句都是三次网络请求次数，prepared execute close</p></li>

<li><p>不要循环中创建prepare语句</p></li>

<li><p>注意关闭 stmt</p></li>
</ol>

<p>尽管会有reprepare过程，这些操作依然是database/sql帮我们所做的，与连接retry2次一样，开发者无需担心。</p>

<p>对于Qeruy操作如此，同理Exec操作也一样。</p>

<h2 id="总结-1">总结</h2>

<p>目前我们学习database/sql提供两类查询操作，Query和Exec方法。他们都可以使用plaintext和preprea方式查询。对于后者，可以有效的避免数据库注入。而prepare方式又可以有显示的声明stmt对象，也有隐藏的方式。显示的创建stmt会有3次网络请求，创建-&gt;执行-&gt;关闭，再批量操作可以考虑这种做法，另外一种方式创建prepare后就执行，因此不会因为reprepare导致高并发下的leak连接问题。</p>

<p>具体使用那种方式，还得基于应用场景，安全过滤和连接管理等考虑。至此，关于查询和执行操作已经介绍了很多。关系型数据库的另外一个特性就是关系和事务处理。下一节，我们将会讨论database/sql的数据库事务功能。</p>

<h1 id="transaction-事务">Transaction 事务</h1>

<p>事务处理是数据的重要特性。尤其是对于一些支付系统，事务保证性对业务逻辑会有重要影响。golang的mysql驱动也封装好了事务相关的操作。我们已经学习了db的Query和Exec方法处理查询和修改数据库。</p>

<h2 id="tx对象">tx对象</h2>

<p>一般查询使用的是db对象的方法，事务则是使用另外一个对象。sql.Tx对象。使用db的Begin方法可以创建tx对象。tx对象也有数据库交互的Query,Exec和Prepare方法。用法和db的相关用法类似。查询或修改的操作完毕之后，需要调用tx对象的Commit提交或者Rollback方法回滚。</p>

<p>一旦创建了tx对象，事务处理都依赖与tx对象，这个对象会从连接池中取出一个空闲的连接，接下来的sql执行都基于这个连接，直到commit或者rollback调用之后，才会把连接释放到连接池。</p>

<p>在事务处理的时候，不能使用db的查询方法，虽然后者可以获取数据，可是这不属于同一个事务处理，将不会接受commit和rollback的改变，一个简单的事务例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query1</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query2</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span></code></pre></td></tr></table>
</div>
</div>
<p>在tx中使用db是错误的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query1</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">query2</span><span class="p">)</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span></code></pre></td></tr></table>
</div>
</div>
<p>上述代码在调用db的Eexc方法的时候，tx会绑定连接到事务中，db则是额外的一个连接，两者不是同一个事务。需要注意，Begin和Commit方法，与sql语句中的BEGIN或COMMIT语句没有关系。</p>

<h2 id="事务与连接">事务与连接</h2>

<p>创建Tx对象的时候，会从连接池中取出连接，然后调用相关的Exec方法的时候，连接仍然会绑定在改事务处理中。在实际的事务处理中，go可能创建不同的连接，但是那些其他连接都不属于该事务。例如上面例子中db创建的连接和tx的连接就不是一回事。</p>

<p>事务的连接生命周期从Beigin函数调用起，直到Commit和Rollback函数的调用结束。事务也提供了prepare语句的使用方式，但是需要使用Tx.Stmt方法创建。prepare设计的初衷是多次执行，对于事务，有可能需要多次执行同一个sql。然而无论是正常的prepare和事务处理，prepare对于连接的管理都有点小复杂。因此私以为尽量避免在事务中使用prepare方式。例如下面例子就容易导致错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
<span class="nx">stmt</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT ...&#34;</span><span class="p">)</span>
<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span></code></pre></td></tr></table>
</div>
</div>
<p>因为stmt.Close使用defer语句，即函数退出的时候再清理stmt，可是实际执行过程的时候，tx.Commit就已经释放了连接。当函数退出的时候，再执行stmt.Close的时候，连接可能有被使用了。</p>

<p>你不应该在SQL代码中混合BEGIN和COMMIT相关的函数(如Begin()和Commit()的SQL语句)，可能会导致悲剧：</p>

<ul>
<li>Tx对象可以保持打开状态，从池中保留连接而不返回。</li>
<li>数据库的状态可能与代表它的Golang变量的状态不同步。</li>
<li>你可能会认为你是在事务内部的单个连接上执行查询，实际上Golang已经为你创建了几个连接，而且一些语句不是事务的一部分。</li>
</ul>

<p>当你在事务中工作时，你应该注意不要对Db变量进行调用。应当使用db.Begin()创建的Tx变量进行所有调用。Db不在一个事务中，只有Tx是。如果你进一步调用db.Exec()或类似的函数，那么这些调用将发生在事务范围之外，是在其他的连接上。</p>

<p>如果你需要处理修改连接状态的多个语句，即使你不希望事务本身，也需要一个Tx。例如：</p>

<ul>
<li>创建仅在一个连接中可见的临时表。</li>
<li>设置变量，如MySql&rsquo;s SET @var := somevalue语法。</li>
<li>更改连接选项，如字符集或超时。</li>
</ul>

<p>如果你需要执行任何这些操作，则需要把你的作业(也可以说Tx操作语句)绑定到单个连接，而在Golang中执行此操作的唯一方法是使用Tx。</p>

<h2 id="事务并发">事务并发</h2>

<p>对于sql.Tx对象，因为事务过程只有一个连接，事务内的操作都是顺序执行的，在开始下一个数据库交互之前，必须先完成上一个数据库交互。例如下面的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT id FROM user&#34;</span><span class="p">)</span> 
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">did</span> <span class="kt">int</span>
    <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mid</span><span class="p">)</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT id FROM detail_user WHERE master = ?&#34;</span><span class="p">,</span> <span class="nx">mid</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">did</span><span class="p">)</span>
    
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>调用了Query方法之后，在Next方法中取结果的时候，rows是维护了一个连接，再次调用QueryRow的时候，db会再从连接池取出一个新的连接。rows和db的连接两者可以并存，并且相互不影响。</p>

<p>可是，这样逻辑在事务处理中将会失效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT id FROM user&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">did</span> <span class="kt">int</span>
   <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mid</span><span class="p">)</span>
   <span class="nx">tx</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT id FROM detail_user WHERE master = ?&#34;</span><span class="p">,</span> <span class="nx">mid</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">did</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>tx执行了Query方法后，连接转移到rows上，在Next方法中，tx.QueryRow将尝试获取该连接进行数据库操作。因为还没有调用rows.Close，因此底层的连接属于busy状态，tx是无法再进行查询的。上面的例子看起来有点傻，毕竟涉及这样的操作，使用query的join语句就能规避这个问题。例子只是为了说明tx的使用问题。</p>

<h2 id="事务中的准备语句">事务中的准备语句</h2>

<p>在Tx中创建的准备语句仅限于它，因此早期关于重新准备的注意事项不适用。当你对Tx对象进行操作时，你的操作直接映射到它下面唯一的一个连接上。</p>

<p>这也意味着在Tx内创建的准备语句不能与之分开使用。同样，在DB中创建的准备语句不能在事务中使用，因为它们将被绑定到不同的连接。</p>

<p>要在Tx中使用事务外的预处理语句，可以使用Tx.Stmt()，它将从事务外部准备一个新的特定于事务的语句。它通过采用现有的预处理语句，设置与事务的连接，并在执行时重新准备所有语句。这个行为及其实现是不可取的，甚至在databse/sql源代码中有一个TODO来改进它；我们建议不要使用这个。</p>

<p>在处理事务中的预处理语句时，必须小心谨慎。请考虑下面的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Prepare</span><span class="p">(</span><span class="s">&#34;INSERT INTO foo VALUES (?)&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// danger!
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">//</span> <span class="nx">stmt</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="nx">runs</span> <span class="nx">here</span><span class="p">!</span></code></pre></td></tr></table>
</div>
</div>
<p>之前Golang1.4关闭*sql.Tx将与之关联的连接返还到池中，但是，在预处理语句结束后，延迟调用时在那之后发生的，这可能导致并发访问底层的连接，使连接状态不一致。如果使用Golang1.4或更高的版本，则应确保在提交事务或回滚之前声明始终关闭。</p>

<h2 id="总结-2">总结</h2>

<p>database/sql提供了事务处理的功能。通过Tx对象实现。db.Begin会创建tx对象，后者的Exec和Query执行事务的数据库操作，最后在tx的Commit和Rollback中完成数据库事务的提交和回滚，同时释放连接。
tx事务环境中，只有一个数据库连接，事务内的Eexc都是依次执行的，事务中也可以使用db进行查询，但是db查询的过程会新建连接，这个连接的操作不属于该事务。
关于database/sql和mysql的驱动，我们已经分三部分内容介绍了。下一节，将会对之前的内容进行梳理总结，包括错误处理和注意事项的补充。</p>

<h1 id="错误处理">错误处理</h1>

<p>几乎所有使用database/sql类型的操作都会返回一个错误作为最后一个值。你应该总是检查这些错误，千万不要忽视它们。有几个地方错误行为是特殊情况，还有一些额外的东西可能需要知道。</p>

<h2 id="遍历结果集的错误">遍历结果集的错误</h2>

<p>请思考下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// handle the error here
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>来自rows.Err()的错误可能是rows.Next()循环中各种错误的结果。除了正常完成循环之外，循环可能会退出，因此你总是需要检查循环是否正常终止。异常终止自动调用rows.Close()，尽管多次调用它是无害的。</p>

<h2 id="关闭结果集的错误">关闭结果集的错误</h2>

<p>如上所述，如果你过早的退出循环，则应该总是显式的关闭sql.Rows。如果循环正常退出或通过错误，它会自动关闭，但你可能会错误的执行此操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">break</span><span class="p">;</span> <span class="c1">// whoops, rows is not closed! memory leak...
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// do the usual &#34;if err = rows.Err()&#34; [omitted here]...
</span><span class="c1">// it&#39;s always safe to [re?]close here:
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// but what should we do if there&#39;s an error?
</span><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>rows.Close()返回的错误是一般规则的唯一例外，最好是捕获并检查所有数据库操作中的错误。如果rows.Close()返回错误，那么你应该怎么做。记录错误信息或panic可能是唯一明智的事情，如果这不明智，那么也许你应该忽略错误。</p>

<h2 id="queryrow-的错误">QueryRow()的错误</h2>

<p>思考下面的代码来获取一行数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>如果没有id = 1的用户怎么办？那么结果中不会有行，而.Scan()不会将值扫描到name中。那会怎么样？</p>

<p>Golang定义了一个特殊的错误常量，称为sql.ErrNoRows，当结果为空时，它将从QueryRow()返回。这在大多数情况下需要作为特殊情况来处理。空的结果通常不被应用程序代码认为是错误的，如果不检查错误是不是这个特殊常量，那么会导致你意想不到的应用程序代码错误。</p>

<p>来自查询的错误被推迟到调用Scan()，然后从中返回。上面的代码可以更好地写成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;select name from users where id = ?&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">ErrNoRows</span> <span class="p">{</span>
        <span class="c1">// there were no rows, but otherwise no error occurred
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>有人可能会问为什么一个空的结果集被认为是一个错误。空集没有什么错误。原因是QueryRow()方法需要使用这种特殊情况才能让调用者区分是否QueryRow()实际上找到一行；没有它，Scan(0)不会做任何事情，你可能不会意识到你的变量毕竟没有从数据库中获取任何值。</p>

<p>当你使用QueryRow()时，你应该只会遇到此错误。如果你在别处遇到这个错误，你就做错了什么。</p>

<h2 id="识别特定的数据库错误">识别特定的数据库错误</h2>

<p>像下面这样编写代码是很有诱惑力的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;SELECT someval FROM sometable&#34;</span><span class="p">)</span>
<span class="c1">// err contains:
</span><span class="c1">// ERROR 1045 (28000): Access denied for user &#39;foo&#39;@&#39;::1&#39; (using password: NO)
</span><span class="c1"></span><span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="s">&#34;Access denied&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle the permission-denied error
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这不是最好的方法。例如，字符串值可能会取决于服务器使用什么语言发送错误消息。比较错误编号以确定具体错误是啥要好得多。
但是，驱动的机制不同，因为这不是database/sql本身的一部分。在本教程重点介绍的MySql驱动中，你可以编写以下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">driverErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">mysql</span><span class="p">.</span><span class="nx">MySQLError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span> <span class="c1">// Now the error number is accessible directly
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">driverErr</span><span class="p">.</span><span class="nx">Number</span> <span class="o">==</span> <span class="mi">1045</span> <span class="p">{</span>
        <span class="c1">// Handle the permission-denied error
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>再次，这里的MySQLError类型由此特定驱动程序提供，并且驱动程序之间的.Number字段可能不同。然而，该值是从MySql的错误消息中提取的，因此是特定于数据库的，而不是特定于驱动的。</p>

<p>这段代码还是很丑相对于1045，一个魔术数字是一种代码气味。一些驱动(虽然不是MySql的驱动程序，因为这里的主题的原因)提供错误标识符的列表。例如Postgres pg驱动程序在error.go中。还有一个由VividCortex维护的MySql错误号的外部包。使用这样的列表，上面的代码写的更漂亮：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">driverErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">mysql</span><span class="p">.</span><span class="nx">MySQLError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">driverErr</span><span class="p">.</span><span class="nx">Number</span> <span class="o">==</span> <span class="nx">mysqlerr</span><span class="p">.</span><span class="nx">ER_ACCESS_DENIED_ERROR</span> <span class="p">{</span>
        <span class="c1">// Handle the permission-denied error
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="处理连接错误">处理连接错误</h2>

<p>如果与数据库的连接被丢弃，杀死或发生错误该怎么办？</p>

<p>当发生这种情况时，你不需要实现任何逻辑来重试失败的语句。作为database/sql连接池的一部分，处理失败的连接是内置的。如果你执行查询或其他语句，底层连接失败，则Golang将重新打开一个新的连接(或从连接池中获取另一个连接)，并重试10次。</p>

<p>然而，可能会产生一些意想不到的后果。当某些类型错误可能会发生其他错误条件。这也可能是驱动程序特定的。MySql驱动程序发生的一个例子是使用KILL取消不需要的语句(例如长时间运行的查询)会导致语句被重试10次。</p>

<h1 id="惊喜-反模式和限制">惊喜，反模式和限制</h1>

<p>虽然database/sql很简单，但一旦你习惯了它，你可能会对它支持的用例的微妙之处感到惊讶。这是Golang的核心库通用的。</p>

<h2 id="资源枯竭">资源枯竭</h2>

<p>如果你不按预期使用database/sql，你一定会为自己造成麻烦，通常是通过消耗一些资源或阻止它们被有效的重用：</p>

<ul>
<li>打开和关闭数据库可能会导致资源耗尽。</li>
<li>没有读取所有行或使用rows.Close()保留来自池的连接。</li>
<li>对于不返回行的语句，使用Query()将从池中预留一个连接。</li>
<li>没有意识到预处理语句如何工作会导致大量额外的数据库活动。</li>
</ul>

<h2 id="巨大的uint64值">巨大的uint64值</h2>

<p>这里有一个令人吃惊的错误。如果设置了高位，就不能将大的无符号整数作为参数传递给语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;INSERT INTO users(id) VALUES&#34;</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxUint64</span><span class="p">)</span> <span class="o">//</span> <span class="nx">Error</span></code></pre></td></tr></table>
</div>
</div>
<p>这将抛出一个错误。如果你使用uint64值要小心，因为它们可能开始小而且无错误的工作，但会随着时间的推移而增加，并开始抛出错误。</p>

<h2 id="连接状态不匹配">连接状态不匹配</h2>

<p>有些事情可以改变连接状态，这可能导致的问题有两个原因：</p>

<ol>
<li>某些连接状态，比如你是否处于事务中，应该通过Golang类型来处理。</li>
<li>你可能假设你的查询在单个连接上运行。</li>
</ol>

<p>例如，使用USE语句设置当前数据库对于很多人来说是一个典型的事情。但是在Golang中，它只会影响你运行的连接。除非你处于事务中，否则你认为在该连接上执行的其他语句实际上可能在从池中获取的不同的连接上运行，因此它们不会看到这些更改的影响。</p>

<p>此外，在更改连接后，它将返回到池，并可能会污染其他代码的状态。这就是为什么你不应该直接将BEGIN或COMMIT语句作为SQL命令发出的原因之一。</p>

<h2 id="数据库特定的语法">数据库特定的语法</h2>

<p>database/sql API提供了面向行的数据库抽象，但是具体的数据库和驱动程序可能会在行为或语法上有差异，例如预处理语句占位符。</p>

<h2 id="多个结果集">多个结果集</h2>

<p>Golang驱动程序不以任何方式支持单个查询中的多个结果集，尽管有一个支持大容量操作（如批量复制）的功能请求似乎没有任何计划。
这意味着，除了别的以外，返回多个结果集的存储过程将无法正常工作。</p>

<h2 id="调用存储过程">调用存储过程</h2>

<p>调用存储过程是特定于驱动程序的，但在MySql驱动程序中，目前无法完成。看来你可以调用一个简单的过程来返回一个单一的结果集，通过执行如下的操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;CALL mydb.myprocedure&#34;</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">)</span> <span class="o">//</span> <span class="nx">Error</span></code></pre></td></tr></table>
</div>
</div>
<p>事实上这行不通。你将收到以下错误1312：PROCEDURE mydb.myprocedure无法返回给定上下文中的结果集。这是因为MySql希望将连接设置为多语句模式，即使单个结果，并且驱动程序当前没有执行此操作（尽管看到这个问题）。</p>

<h2 id="多个声明支持">多个声明支持</h2>

<p>database/sql没有显式的拥有多个语句支持，这意味着这个行为是后端依赖的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;DELETE FROM tbl1; DELETE FROM tbl2&#34;</span><span class="p">)</span> <span class="o">//</span> <span class="nx">Error</span><span class="o">/</span><span class="nx">unpredictable</span> <span class="nx">result</span></code></pre></td></tr></table>
</div>
</div>
<p>服务器可以解释它想要的，它可以包括返回的错误，只执行第一个语句，或执行两者。</p>

<p>同样，在事务中没有办法批处理语句。事务中的每个语句必须连续执行，并且结果中的资源（如行或行）必须被扫描或关闭，以便底层连接可供下一个语句使用。这与通常不在事务中工作时的行为不同。在这种情况下，完全可以执行查询，循环遍历行，并在循环中对数据库进行查询（这将发生在一个新的连接上)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl1&#34;</span><span class="p">)</span> <span class="c1">// Uses connection 1
</span><span class="c1"></span><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">myvariable</span><span class="p">)</span>
    <span class="c1">// The following line will NOT use connection 1, which is already in-use
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl2 where id = ?&#34;</span><span class="p">,</span> <span class="nx">myvariable</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>但是事务只绑定到一个连接，所以事务不可能做到这一点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl1&#34;</span><span class="p">)</span> <span class="c1">// Uses tx&#39;s connection
</span><span class="c1"></span><span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">myvariable</span><span class="p">)</span>
    <span class="c1">// ERROR! tx&#39;s connection is already busy!
</span><span class="c1"></span>    <span class="nx">tx</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;select * from tbl2 where id = ?&#34;</span><span class="p">,</span> <span class="nx">myvariable</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>不过，Golang不会阻止你去尝试。因此，如果你试图在第一个释放资源并自行清理之前尝试执行另一个语句，可能会导致一个损坏的连接。这也意味着事务中的每个语句都会产生一组单独的网络往返数据库。</p>

<p>转载:<br />
<a href="https://www.jianshu.com/p/bc8120bec94e">https://www.jianshu.com/p/bc8120bec94e</a><br />
<a href="http://go-database-sql.org/index.html">http://go-database-sql.org/index.html</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-12-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/mysql/">Mysql</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/gin%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default"> Gin实现自动注册路由</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93too-many-connections%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/">
            <span class="next-text nav-default">Go连接MySql数据库too many connections错误解决</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
