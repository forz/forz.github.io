<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>package:validator.v9 | Forz Blog</title>
<meta name="keywords" content="Go标准库, validator" />
<meta name="description" content="标准库 package validator import &ldquo;gopkg.in/go-playground/validator.v9&rdquo; Package validator 基于标签对结构和单个字段实现值验证. 它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。 查">
<meta name="author" content="">
<link rel="canonical" href="/post/packagevalidator.v9/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="package:validator.v9" />
<meta property="og:description" content="标准库 package validator import &ldquo;gopkg.in/go-playground/validator.v9&rdquo; Package validator 基于标签对结构和单个字段实现值验证. 它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。 查" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/packagevalidator.v9/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-12-12T20:43:20&#43;00:00" />
<meta property="article:modified_time" content="2019-12-14T16:38:52&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="package:validator.v9"/>
<meta name="twitter:description" content="标准库 package validator import &ldquo;gopkg.in/go-playground/validator.v9&rdquo; Package validator 基于标签对结构和单个字段实现值验证. 它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。 查"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "package:validator.v9",
      "item": "/post/packagevalidator.v9/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "package:validator.v9",
  "name": "package:validator.v9",
  "description": "标准库 package validator import \u0026ldquo;gopkg.in/go-playground/validator.v9\u0026rdquo; Package validator 基于标签对结构和单个字段实现值验证. 它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。 查",
  "keywords": [
    "Go标准库", "validator"
  ],
  "articleBody": "标准库 package validator import “gopkg.in/go-playground/validator.v9”\nPackage validator 基于标签对结构和单个字段实现值验证.\n它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。\n查看更多示例 https://github.com/go-playground/validator/tree/master/_examples\n验证函数返回类型错误 Doing things this way is actually the way the standard library does, see the file.Open method here:\nhttps://golang.org/pkg/os/#Open. The authors return type “error” to avoid the issue discussed in the following, where err is always != nil:\nhttp://stackoverflow.com/a/29138676/3158232 https://github.com/go-playground/validator/issues/134\nValidator only InvalidValidationError for bad validation input, nil or ValidationErrors as type error; 因此，在您的代码中，您所需要做的就是检查 err 是否为 nil, 以及检查错误是否为InvalidValidationError（如果有必要，大多数情况下不是），请像这样将其强制转换为ValidationErrors类型错误（validator.ValidationErrors）\n自定义验证功能 可以添加自定义验证功能。\nExample:\n1 2 3 4 5 6 7 8 9 10 11 12 13  // Structure func customFunc(fl validator.FieldLevel) bool { if fl.Field().String() == \"invalid\" { return false } return true } validate.RegisterValidation(\"custom tag name\", customFunc) //注意：使用与现有功能相同的标记名称 //将覆盖现有功能   跨field验证 跨field验证可以通过以下标签完成：\n1 2 3 4 5 6 7 8 9 10 11 12  - eqfield - nefield - gtfield - gtefield - ltfield - ltefield - eqcsfield - necsfield - gtcsfield - gtecsfield - ltcsfield - ltecsfield   如果需要某些自定义跨域验证，则可以使用自定义验证来完成。\n为什么不只具有跨域验证标签（即仅eqcsfield而不是eqfield）？\n原因是效率。如果要检查同一结构中的字段，则“ eqfield”仅需在同一结构（1级）上找到该字段。但是，如果我们使用“ eqcsfield”，则可能会降低多个级别。例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  type Inner struct { StartDate time.Time } type Outer struct { InnerStructField *Inner CreatedAt time.Time `validate:\"ltecsfield=InnerStructField.StartDate\"` } now := time.Now() inner := \u0026Inner{ StartDate: now, } outer := \u0026Outer{ InnerStructField: inner, CreatedAt: now, } errs := validate.Struct(outer) // NOTE: when calling validate.Struct(val) topStruct will be the top level struct passed // into the function // when calling validate.VarWithValue(val, field, tag) val will be // whatever you pass, struct, field... // when calling validate.Field(field, tag) val will be nil   多个validate 字段上的多个validate将按照定义的顺序进行处理。例：\n1 2 3 4 5  type Test struct { Field `validate:\"max=10,min=1\"` } // max will be checked then min   库不处理无效的验证器定义。例：\n1 2 3 4  type Test struct { Field `validate:\"min=10,max=0\"` } // this definition of min max will never succeed   使用验证标签 跨field验证仅比较同一结构上的字段。如果需要跨field+跨struct验证，则应实现自己的自定义validator。\n逗号（“，”）是验证标签的默认分隔符。如果希望在参数中包含逗号（即excludesall =，），则需要使用UTF-8十六进制表示形式0x2C，在代码中将其替换为逗号，因此以上内容将变为excludesall = 0x2C。\n1 2 3 4  type Test struct { Field `validate:\"excludesall=,\"` // BAD! Do not include a comma. \tField `validate:\"excludesall=0x2C\"` // GOOD! Use the UTF-8 hex representation. }   管道（“ |”）是’或’验证标签的分隔符。如果希望在参数中包含管道，即excludesall = | 您将需要使用UTF-8十六进制表示形式0x7C，在代码中将其替换为管道，因此以上内容将变为excludesall = 0x7C\n1 2 3 4  type Test struct { Field `validate:\"excludesall=|\"` // BAD! Do not include a a pipe! \tField `validate:\"excludesall=0x7C\"` // GOOD! Use the UTF-8 hex representation. }   Alias Validators and Tags 注意：返回错误时，在“FieldError”中返回的标签将是别名标签，除非dive标签是别名的一部分。dive标签之后的所有内容均不会报告为别名标签。同样，在前面的情况下，“ ActualTag”将是失败的别名中的实际标签。\n这是当前内置别名标签的列表：\n1 2  \"iscolor\" alias is \"hexcolor|rgb|rgba|hsl|hsla\" (Usage: iscolor)   正则表达式标签 不会添加正则表达式验证器，因为逗号和=符号可能是与验证定义冲突的正则表达式的一部分。 尽管可以采取解决方法，但它们不能使用纯正则表达式。 此外，它既快速又肮脏，正则表达式变得更难维护且不可重用，因此它与任何东西一样，都是编程哲学。\n代替此新的验证器功能，应创建自定义验证函数； regex可以在验证函数中使用，甚至可以在regexes.go中进行预编译以提高效率。最好的原因是，您可以提交请求请求，我们可以继续添加到此程序包的验证库中！\nPanics 当提供错误的输入时，此程序包会panic，这是设计使然，这样的错误代码不应使其投入生产。\n1 2 3 4 5 6 7 8 9  type Test struct { TestField string `validate:\"nonexistantfunction=1\"` } t := \u0026Test{ TestField: \"Test\" } validate.Struct(t) // this will panic   Non standard validators 我们经常需要比在验证器中发现的验证规则更复杂的验证规则的集合。非标准验证器必须使用您喜欢的任何标签手动注册。请参阅下面的注册和使用示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  type Test struct { TestField string `validate:\"yourtag\"` } t := \u0026Test{ TestField: \"Test\" } validate := validator.New() validate.RegisterValidation(\"yourtag\", validations.ValidatorName) NotBlank This validates that the value is not blank or with length zero. For strings ensures they do not contain only spaces. For channels, maps, slices and arrays ensures they don't have zero length. For others, a non empty value is required. Usage: notblank   type CustomTypeFunc 1  type CustomTypeFunc func(field reflect.Value) interface{}   CustomTypeFunc允许重写或添加自定义字段类型处理程序函数field =类型的字段值以返回待验证的值\n示例:\nsql drive中的validator\n请参见https://golang.org/src/database/sql/driver/types.go ？s = 1210：1293＃L29\ntype FieldError 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  type FieldError interface { // returns the validation tag that failed. if the  // validation was an alias, this will return the  // alias name and not the underlying tag that failed.  //  // eg. alias \"iscolor\": \"hexcolor|rgb|rgba|hsl|hsla\"  // will return \"iscolor\"  Tag() string // returns the validation tag that failed, even if an  // alias the actual tag within the alias will be returned.  // If an 'or' validation fails the entire or will be returned.  //  // eg. alias \"iscolor\": \"hexcolor|rgb|rgba|hsl|hsla\"  // will return \"hexcolor|rgb|rgba|hsl|hsla\"  ActualTag() string // returns the namespace for the field error, with the tag  // name taking precedence over the fields actual name.  //  // eg. JSON name \"User.fname\"  //  // See StructNamespace() for a version that returns actual names.  //  // NOTE: this field can be blank when validating a single primitive field  // using validate.Field(...) as there is no way to extract it's name  Namespace() string // returns the namespace for the field error, with the fields  // actual name.  //  // eq. \"User.FirstName\" see Namespace for comparison  //  // NOTE: this field can be blank when validating a single primitive field  // using validate.Field(...) as there is no way to extract it's name  StructNamespace() string // returns the fields name with the tag name taking precedence over the  // fields actual name.  //  // eq. JSON name \"fname\"  // see StructField for comparison  Field() string // returns the fields actual name from the struct, when able to determine.  //  // eq. \"FirstName\"  // see Field for comparison  StructField() string // returns the actual fields value in case needed for creating the error  // message  Value() interface{} // returns the param value, in string form for comparison; this will also  // help with generating an error message  Param() string // Kind returns the Field's reflect Kind  //  // eg. time.Time's kind is a struct  Kind() reflect.Kind // Type returns the Field's reflect Type  //  // // eg. time.Time's type is time.Time  Type() reflect.Type // returns the FieldError's translated error  // from the provided 'ut.Translator' and registered 'TranslationFunc'  //  // NOTE: if no registered translator can be found it returns the same as  // calling fe.Error()  Translate(ut ut.Translator) string }   FieldError包含获取错误详细信息的所有函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  type FieldLevel type FieldLevel interface { // returns the top level struct, if any  Top() reflect.Value // returns the current fields parent struct, if any or  // the comparison value if called 'VarWithValue'  Parent() reflect.Value // returns current field for validation  Field() reflect.Value // returns the field's name with the tag  // name taking precedence over the fields actual name.  FieldName() string // returns the struct field's name  StructFieldName() string // returns param for validation against current field  Param() string // ExtractType gets the actual underlying type of field value.  // It will dive into pointers, customTypes and return you the  // underlying value and it's kind.  ExtractType(field reflect.Value) (value reflect.Value, kind reflect.Kind, nullable bool) // traverses the parent struct to retrieve a specific field denoted by the provided namespace  // in the param and returns the field, field kind and whether is was successful in retrieving  // the field at all.  //  // NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field  // could not be retrieved because it didn't exist.  //  // Deprecated: Use GetStructFieldOK2() instead which also return if the value is nullable.  GetStructFieldOK() (reflect.Value, reflect.Kind, bool) // GetStructFieldOKAdvanced is the same as GetStructFieldOK except that it accepts the parent struct to start looking for  // the field and namespace allowing more extensibility for validators.  //  // Deprecated: Use GetStructFieldOKAdvanced2() instead which also return if the value is nullable.  GetStructFieldOKAdvanced(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool) // traverses the parent struct to retrieve a specific field denoted by the provided namespace  // in the param and returns the field, field kind, if it's a nullable type and whether is was successful in retrieving  // the field at all.  //  // NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field  // could not be retrieved because it didn't exist.  GetStructFieldOK2() (reflect.Value, reflect.Kind, bool, bool) // GetStructFieldOKAdvanced is the same as GetStructFieldOK except that it accepts the parent struct to start looking for  // the field and namespace allowing more extensibility for validators.  GetStructFieldOKAdvanced2(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool, bool) }   FieldLevel包含所有信息和帮助程序功能以验证字段\ntype FilterFunc 1  type FilterFunc func(ns []byte) bool   FilterFunc是用于使用StructFiltered（…）函数过滤字段的类型。从验证中过滤/跳过字段中返回真实结果\ntype Func 1  type Func func(fl FieldLevel) bool   Func接受FieldLevel接口以满足所有验证需求。验证成功时，返回值应为true。\ntype FuncCtx 1  type FuncCtx func(ctx context.Context, fl FieldLevel) bool   FuncCtx接受context.Context和FieldLevel接口来满足所有验证需求。验证成功时，返回值应为true。\ntype InvalidValidationError 1 2 3  type InvalidValidationError struct { Type reflect.Type }   InvaStruct，StructExcept，StructPartial或Field的无效参数。\nfunc (*InvalidValidationError) Error 1  func (e *InvalidValidationError) Error() string   Error返回InvalidValidationError消息\ntype RegisterTranslationsFunc 1  type RegisterTranslationsFunc func(ut ut.Translator) error   RegisterTranslationsFunc允许注册“ ut.Translator”的翻译，以在“TranslationFunc”中使用\ntype StructLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  type StructLevel interface { // returns the main validation object, in case one wants to call validations internally.  // this is so you don't have to use anonymous functions to get access to the validate  // instance.  Validator() *Validate // returns the top level struct, if any  Top() reflect.Value // returns the current fields parent struct, if any  Parent() reflect.Value // returns the current struct.  Current() reflect.Value // ExtractType gets the actual underlying type of field value.  // It will dive into pointers, customTypes and return you the  // underlying value and its kind.  ExtractType(field reflect.Value) (value reflect.Value, kind reflect.Kind, nullable bool) // reports an error just by passing the field and tag information  //  // NOTES:  //  // fieldName and altName get appended to the existing namespace that  // validator is on. e.g. pass 'FirstName' or 'Names[0]' depending  // on the nesting  //  // tag can be an existing validation tag or just something you make up  // and process on the flip side it's up to you.  ReportError(field interface{}, fieldName, structFieldName string, tag, param string) // reports an error just by passing ValidationErrors  //  // NOTES:  //  // relativeNamespace and relativeActualNamespace get appended to the  // existing namespace that validator is on.  // e.g. pass 'User.FirstName' or 'Users[0].FirstName' depending  // on the nesting. most of the time they will be blank, unless you validate  // at a level lower the the current field depth  ReportValidationErrors(relativeNamespace, relativeActualNamespace string, errs ValidationErrors) }   StructLevel包含用于验证结构的所有信息和辅助函数\ntype StructLevelFunc 1  type StructLevelFunc func(sl StructLevel)   StructLevelFunc接受结构级别验证所需的所有值\ntype StructLevelFuncCtx 1  type StructLevelFuncCtx func(ctx context.Context, sl StructLevel)   StructLevelFuncCtx接受结构级别验证所需的所有值，但也允许通过context.Context传递上下文验证信息。\ntype TagNameFunc 1  type TagNameFunc func(field reflect.StructField) string   TagNameFunc允许添加自定义标签名称解析器\ntype TranslationFunc 1  type TranslationFunc func(ut ut.Translator, fe FieldError) string   TranslationFunc是用于注册或覆盖自定义翻译的函数类型\ntype Validate 1 2 3  type Validate struct { // contains filtered or unexported fields }   Validate包含验证器设置和缓存\nfunc New 1  func New() *Validate   New返回一个默认值“validate”的新实例。\nfunc (*Validate) RegisterAlias 1  func (v *Validate) RegisterAlias(alias, tags string)   RegisterAlias注册单个验证标签的映射，该映射定义一组通用或复杂的验证集，以简化向结构添加验证的过程。\n注意：此函数不是线程安全的，因此应在进行任何验证之前先将它们全部注册\nfunc (*Validate) RegisterCustomTypeFunc 1  func (v *Validate) RegisterCustomTypeFunc(fn CustomTypeFunc, types ...interface{})   RegisterCustomTypeFunc针对多种类型注册CustomTypeFunc\n注意：此方法不是线程安全的，因此应在进行任何验证之前先将它们全部注册\nfunc (*Validate) RegisterStructValidation 1  func (v *Validate) RegisterStructValidation(fn StructLevelFunc, types ...interface{})   RegisterStructValidation针对多种类型注册StructLevelFunc。\n注意：-此方法不是线程安全的，因此应在进行任何验证之前先将它们全部注册\nfunc (*Validate) RegisterStructValidationCtx 1  func (v *Validate) RegisterStructValidationCtx(fn StructLevelFuncCtx, types ...interface{})   RegisterStructValidationCtx针对多种类型注册StructLevelFuncCtx，并允许通过context.Context传递上下文验证信息。\n注意：-此方法不是线程安全的，因此应在进行任何验证之前先将它们全部注册\nfunc (*Validate) RegisterTagNameFunc 1  func (v *Validate) RegisterTagNameFunc(fn TagNameFunc)   RegisterTagNameFunc注册一个函数来获取StructFields的备用名称。\n例如。使用为JSON表示结构指定的名称，而不是普通的Go字段名称：\n1 2 3 4 5 6 7  validate.RegisterTagNameFunc(func(fld reflect.StructField) string { name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0] if name == \"-\" { return \"\" } return name })   func (*Validate) RegisterTranslation 1  func (v *Validate) RegisterTranslation(tag string, trans ut.Translator, registerFn,RegisterTranslationsFunc, translationFn TranslationFunc) (err error)   RegisterTranslation根据提供的标签注册翻译。\nfunc (*Validate) RegisterValidation 1 2  func (v *Validate) RegisterValidation(tag string, fn Func, callValidationEvenIfNull ...bool) error   RegisterValidation使用给定标签添加验证\n注意：-如果密钥已经存在，则先前的验证功能将被替换。-此方法不是线程安全的，因此应在进行任何验证之前将其全部注册\nfunc (*Validate) RegisterValidationCtx 1 2  func (v *Validate) RegisterValidationCtx(tag string, fn FuncCtx, callValidationEvenIfNull ...bool) error   RegisterValidationCtx的功能与RegisterValidation相同，它接受FuncCtx验证并允许使用context.Context验证。\nfunc (*Validate) SetTagName 1  func (v *Validate) SetTagName(name string)   SetTagName允许更改默认标签名称“validate”\nfunc (*Validate) Struct 1  func (v *Validate) Struct(s interface{}) error   除非另有说明，否则Struct会验证结构的公开字段，并自动验证嵌套的结构。\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors)访问错误数组。\nfunc (*Validate) StructCtx 1  func (v *Validate) StructCtx(ctx context.Context, s interface{}) (err error)   除非另行指定，否则StructCtx会验证暴露的结构体的结构，并自动验证嵌套的结构体，除非另外指定，并且还允许传递context.Context作为上下文验证信息。\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors)访问错误数组。\nfunc (*Validate) StructExcept 1  func (v *Validate) StructExcept(s interface{}, fields ...string) error   StructExcept会验证除传入字段外的所有其他字段。可以相对于所提供的结构（即NestedStruct.Field或NestedArrayField [0] .Struct.Name）以命名空间的方式提供字段。\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors)访问错误数组。\nfunc (*Validate) StructExceptCtx 1 2  func (v *Validate) StructExceptCtx(ctx context.Context, s interface{}, fields ...string) (err error)   StructExceptCtx会验证除传入字段外的所有字段，并允许通过上下文传递上下文验证验证信息。可以相对于所提供的结构，即NestedStruct.Field或NestedArrayField [0] .Struct.Name，以命名空间的方式提供上下文字段。\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。\nfunc (*Validate) StructFiltered 1  func (v *Validate) StructFiltered(s interface{}, fn FilterFunc) error   除非另有说明，否则StructFiltered会验证结构公开的字段，这些字段通过FilterFunc检查并自动验证嵌套的结构。\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。\nfunc (*Validate) StructFilteredCtx 1 2  func (v *Validate) StructFilteredCtx(ctx context.Context, s interface{}, fn FilterFunc) (err error)   除非另有说明，否则StructFilteredCtx会验证结构公开的字段，这些字段通过FilterFunc检查并自动验证嵌套的结构，除非另有说明，并且还允许通过context传递上下文验证信息。\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。\nfunc (*Validate) StructPartial 1  func (v *Validate) StructPartial(s interface{}, fields ...string) error   StructPartial仅验证传入的字段，而忽略所有其他字段。可以相对于所提供的结构以命名空间的方式提供字段。NestedStruct.Field或NestedArrayField [0] .Struct.Name\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。\nfunc (*Validate) StructPartialCtx 1 2  func (v *Validate) StructPartialCtx(ctx context.Context, s interface{}, fields ...string) (err error)   StructPartialCtx仅验证传入的字段，而忽略所有其他字段，并允许通过context传递上下文验证验证信息。Context字段可以相对于所提供的结构以命名空间的方式提供。NestedStruct.Field或NestedArrayField [0] .Struct.Name\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。\nfunc (*Validate) Var 1  func (v *Validate) Var(field interface{}, tag string) error   Var使用标记样式验证来验证单个变量。例如\n1 2  var i int validate.Var(i, \"gt=1,lt=10\")   警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error\nfunc (*Validate) VarCtx 1  func (v *Validate) VarCtx(ctx context.Context, field interface{}, tag string) (err error)   Var使用标记样式验证来验证单个变量。并允许通过context.Context传递上下文验证验证信息。例如\n1 2  var i int validate.Var(i, \"gt=1,lt=10\")   警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error\nfunc (*Validate) VarWithValue 1  func (v *Validate) VarWithValue(field interface{}, other interface{}, tag string) error   VarWithValue使用标签样式验证（例如）针对另一个变量/字段的值来验证单个变量。\n1 2 3  s1 := \"abcd\" s2 := \"abcd\" validate.VarWithValue(s1, s2, \"eqcsfield\") // returns true   警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error\nfunc (*Validate) VarWithValueCtx 1 2  func (v *Validate) VarWithValueCtx(ctx context.Context, field interface{}, other interface{} , tag string) (err error)   VarWithValue使用标签样式验证（例如）针对另一个变量/字段的值来验证单个变量。并允许通过context.Context传递上下文验证验证信息。\n1 2 3  s1 := \"abcd\" s2 := \"abcd\" validate.VarWithValue(s1, s2, \"eqcsfield\") // returns true   警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证\n对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error\ntype ValidationErrors 1  type ValidationErrors []FieldError   ValidationErrors是FieldError的数组，用于验证后的自定义错误消息。\nfunc (ValidationErrors) Error 1  func (ve ValidationErrors) Error() string   Error 旨在用于开发+调试，而并非旨在作为生产错误消息。它允许ValidationErrors订阅Error接口。在ValidationErrors数组中找到的FieldError中包含创建特定于您的应用程序的错误消息的所有信息。\nfunc (ValidationErrors) Translate 1  func (ve ValidationErrors) Translate(ut ut.Translator) ValidationErrorsTranslations   Translate 会翻译所有ValidationErrors\ntype ValidationErrorsTranslations 1  type ValidationErrorsTranslations map[string]string   ValidationErrorsTranslations是Translate返回类型\n嵌入验证器和标签 这是当前内置验证器的列表：\nSkip Field 告诉验证跳过此struct字段；这在忽略嵌入式结构被验证时特别方便。（用法：-）\n1  Usage: -   Or Operator 这是允许多个验证器使用和接受的“或”运算符。（用法：rbg | rgba）1  Usage: |   StructOnly 当遇到作为嵌套结构的字段并包含此标志时，将对嵌套结构进行任何验证，但不会验证任何嵌套结构字段。如果您在程序内部知道该结构将是有效的，但是需要验证它是否已被分配，则这很有用。注意：在结构本身上只能使用“required”和“ omitempty”。\n1  Usage: structonly   NoStructLevel 与structonly标记相同，除了不会运行任何结构级别的验证。\n1  Usage: nostructlevel   Omit Empty 允许条件验证，例如，如果未为字段设置值（由“required”验证器确定），则其他验证（例如min或max）将不会运行，但是如果设置了值，验证将运行。\n1  Usage: omitempty   Dive This tells the validator to dive into a slice, array or map and validate that level of the slice, array or map with the validation tags that follow. Multidimensional nesting is also supported, each level you wish to dive will require another dive tag. dive has some sub-tags, ‘keys’ \u0026 ‘endkeys’, please see the Keys \u0026 EndKeys section just below.\n这告诉验证者进入slice, array, map ，并使用后面的验证标签验证slice, array, map的级别。还支持多维嵌套，您要Dive的每个级别都将需要另一个Dive标签。潜水有一些子标签，“keys”和“endkeys”，请参阅下面的“ Keys \u0026 EndKeys”部分。\n1  Usage: dive   1 2 3 4 5 6 7 8 9 10 11 12  Example #1 [][]string with validation tag \"gt=0,dive,len=1,dive,required\" // gt=0 will be applied to [] // len=1 will be applied to []string // required will be applied to string Example #2 [][]string with validation tag \"gt=0,dive,dive,required\" // gt=0 will be applied to [] // []string will be spared validation // required will be applied to string   Keys \u0026 EndKeys 它们将在dive标签之后直接一起使用，并告诉验证者“keys”和“endkeys”之间的任何内容都适用于map的keys，而不是values。可以将其视为“ dive”标签，但适用于map keys而不是values。还支持多维嵌套，您要验证的每个级别都将需要另一个“keys”和“endkeys”标签。这些标签仅对map有效。\n1  Usage: dive,keys,othertagvalidation(s),endkeys,valuevalidationtags   1 2 3 4 5 6 7 8 9 10 11 12  Example #1 map[string]string with validation tag \"gt=0,dive,keys,eg=1|eq=2,endkeys,required\" // gt=0 will be applied to the map itself // eg=1|eq=2 will be applied to the map keys // required will be applied to map values Example #2 map[[2]string]string with validation tag \"gt=0,dive,keys,dive,eq=1|eq=2,endkeys,required\" // gt=0 will be applied to the map itself // eg=1|eq=2 will be applied to each array element in the the map keys // required will be applied to map values   Required 这可以验证该值不是数据类型默认的零值。对于数字，请确保值不为零。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为nil。\n1  Usage: required   Required With 仅当存在任何其他指定的字段时，验证下的字段必须存在且不能为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为零。\n1  Usage: required_with   Examples:\n1 2 3 4 5  // require the field if the Field1 is present: Usage: required_with=Field1 // require the field if the Field1 or Field2 is present: Usage: required_with=Field1 Field2   Required With All 仅当所有其他指定的字段都存在时，验证中的字段必须存在且不为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为nil。\n1  Usage: required_with_all   Example:\n1 2  // require the field if the Field1 and Field2 is present: Usage: required_with_all=Field1 Field2   Required Without 仅当不存在任何其他指定字段时，验证下的字段必须存在且不为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为nil.\n1  Usage: required_without   Examples:\n1 2 3 4 5  // require the field if the Field1 is not present: Usage: required_without=Field1 // require the field if the Field1 or Field2 is not present: Usage: required_without=Field1 Field2   Required Without All 仅当所有其他指定字段都不存在时，验证中的字段必须存在且不为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为零。\n1  Usage: required_without_all   Example:\n1 2  // require the field if the Field1 and Field2 is not present: Usage: required_without_all=Field1 Field2   Is Default 这可以验证该值是默认值，并且几乎与Required相反。\n1  Usage: isdefault   Length For numbers, length will ensure that the value is equal to the parameter given. For strings, it checks that the string length is exactly that number of characters. For slices, arrays, and maps, validates the number of items.\n对于数字，长度将确保该值等于给定的参数。对于字符串，它将检查字符串长度是否恰好等于该字符数。对于切片，数组和map，验证项目数。\n1  Usage: len=10   Maximum 对于数字，max将确保该值小于或等于给定的参数。对于字符串，它将检查字符串长度是否最多为该字符数。对于切片，数组和地图，验证项目数。\n1  Usage: max=10   Minimum 对于数字，max将确保该值小于或等于给定的参数。对于字符串，它将检查字符串长度是否最多为该字符数。对于切片，数组和地图，验证项目数。\n1  Usage: min=10   Equals 对于字符串和数字，eq将确保该值等于给定的参数。对于切片，数组和地图，验证项目数。\n1  Usage: eq=10   Not Equal 对于字符串和数字，ne将确保该值不等于给定的参数。对于切片，数组和地图，验证项目数。\n1  Usage: ne=10   One Of 对于字符串，整数和整数，oneof将确保该值是参数中的值之一。该参数应该是由空格分隔的值列表。值可以是字符串或数字。\n1 2  Usage: oneof=red green oneof=5 7 9   Greater Than 对于数字，这将确保该值大于给定的参数。对于字符串，它检查字符串长度是否大于该字符数。对于切片，数组和映射，它会验证项目数。\n1  Usage: gt   1 2 3 4 5 6 7  Example #1 Usage: gt=10 Example #2 (time.Time) For time.Time ensures the time value is greater than time.Now.UTC().   Greater Than or Equal Same as ‘min’ above. Kept both to make terminology with ‘len’ easier.\n1  Usage: gt   1 2 3 4 5 6 7  Example #1 Usage: gte=10 Example #2 (time.Time) For time.Time ensures the time value is greater than or equal to time.Now.UTC().   Less Than 对于数字，这将确保该值小于给定的参数。对于字符串，它检查字符串长度是否小于该字符数。对于切片，数组和映射，它会验证项目数。\n1  Usage: lt   1 2 3 4  Example #1 Usage: lt=10 Example #2 (time.Time) For time.Time ensures the time value is less than time.Now.UTC().   Less Than or Equal 与上面的“最大”相同。两者都保留以使用“ len”表示的术语更容易。\n1 2 3 4 5 6 7 8  Example #1 Usage: lte=10 Example #2 (time.Time) For time.Time ensures the time value is less than or equal to time.Now.UTC(). Usage: lte   Field Equals Another Field 这将针对结构中或传入字段中的另一个字段值来验证该字段值。\nExample #1:\n1 2  // Validation on Password field using: Usage: eqfield=ConfirmPassword   Example #2:\n1 2  // Validating by field: validate.VarWithValue(password, confirmpassword, \"eqfield\")   Field Equals Another Field (relative) 这与nefield相同，除了它会验证相对于顶层结构提供的字段。\n1  Usage: eqcsfield=InnerStructField.Field)   Field Does Not Equal Another Field 这将针对结构中或传入字段中的另一个字段值来验证该字段值。\nExamples:\n1 2 3 4 5 6 7  // Confirm two colors are not the same: // // Validation on Color field: Usage: nefield=Color2 // Validating by field: validate.VarWithValue(color1, color2, \"nefield\")   Field Does Not Equal Another Field (relative) 这与nefield相同，除了它会验证相对于顶层结构提供的字段。\n1  Usage: necsfield=InnerStructField.Field   Field Greater Than Another Field 仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：\n1 2 3 4 5 6 7 8  Example #1: // Validation on End field using: validate.Struct Usage(gtfield=Start) Example #2: // Validating by field: validate.VarWithValue(start, end, \"gtfield\")   Field Greater Than Another Relative Field 这与gtfield相同，除了它会验证相对于顶层结构提供的字段。\n1  Usage: gtcsfield=InnerStructField.Field   Field Greater Than or Equal To Another Field 仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：\n1 2 3 4 5 6 7 8  Example #1: // Validation on End field using: validate.Struct Usage(gtefield=Start) Example #2: // Validating by field: validate.VarWithValue(start, end, \"gtefield\")   Field Greater Than or Equal To Another Relative Field 这与gtefield相同，除了它会验证相对于顶层结构提供的字段。\n1  Usage: gtecsfield=InnerStructField.Field   Less Than Another Field 仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：\n1 2 3 4 5 6 7 8  Example #1: // Validation on End field using: validate.Struct Usage(ltfield=Start) Example #2: // Validating by field: validate.VarWithValue(start, end, \"ltfield\")   Less Than Another Relative Field 这与ltfield相同，除了它会验证相对于顶层结构提供的字段。\n1  Usage: ltcsfield=InnerStructField.Field   Less Than or Equal To Another Field 仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：\n1 2 3 4 5 6 7 8  Example #1: // Validation on End field using: validate.Struct Usage(ltefield=Start) Example #2: // Validating by field: validate.VarWithValue(start, end, \"ltefield\")   Less Than or Equal To Another Relative Field 这与ltefield相同，除了它会验证相对于顶层结构提供的字段。\n1  Usage: ltecsfield=InnerStructField.Field   Field Contains Another Field 除结构字段外，此功能与contains相同。它只能与字符串类型一起使用。有关其他类型的行为，请参见reflect.Value.String（）的行为。\n1  Usage: containsfield=InnerStructField.Field   Field Excludes Another Field 除了结构字段外，这与exclude相同。它只能与字符串类型一起使用。有关其他类型的行为，请参见reflect.Value.String（）的行为。\n1  Usage: excludesfield=InnerStructField.Field   Unique 对于数组和切片，Unique将确保没有重复。对于map，Unique将确保没有重复的值。\n1  Usage: unique   Alpha Only 这可以验证字符串值仅包含ASCII字母字符\n1  Usage: alpha   Alphanumeric 这可以验证字符串值仅包含ASCII字母数字字符\n1  Usage: alphanum   Alpha Unicode 这可以验证字符串值仅包含Unicode字母字符\n1  Usage: alphaunicode   Alphanumeric Unicode 这可以验证字符串值仅包含Unicode字母数字字符\n1  Usage: alphanumunicode   Numeric 这验证了字符串值包含基本数字值。基本不包括指数等…对于整数或浮点数，它返回true。\n1  Usage: numeric   Hexadecimal String 这可以验证字符串值包含有效的十六进制。\n1  Usage: hexadecimal   Hexcolor String 这可以验证字符串值包含有效的十六进制颜色（包括井号（＃））\n1  Usage: hexcolor   RGB String 这可以验证字符串值包含有效的rgb颜色\n1  Usage: rgb   RGBA String 这可以验证字符串值包含有效的rgba颜色\n1  Usage: rgba   HSL String 这可以验证字符串值包含有效的hsl颜色\n1  Usage: hsl   HSLA String 这可以验证字符串值包含有效的hsla颜色\n1  Usage: hsla   E-mail String 这可以验证字符串值包含有效的电子邮件。这可能不符合任何RFC标准的所有可能性，但是任何电子邮件提供商都不接受所有可能性。\n1  Usage: email   File path 这将验证字符串值包含有效的文件路径以及该文件在计算机上是否存在。这是使用os.Stat完成的，它是一个与平台无关的功能。\n1  Usage: file   URL String 这将验证字符串值是否包含有效的网址。该网址将接受uri接受的golang请求的任何网址，但必须包含scheme，例如http：//或rtmp：//\n1  Usage: url   URI String 这将验证字符串值包含有效的uri。它将接受golang请求uri接受的任何uri\n1  Usage: uri   Urn RFC 2141 String 这验证了根据RFC 2141规范，字符串值包含有效的URN 。\n1  Usage: urn_rfc2141   Base64 String 这将验证字符串值包含有效的base64值。尽管空字符串是有效的base64，但这将报告一个空字符串作为错误，但是，如果您希望接受一个空字符串，则可以将其与omitempty标记一起使用。\n1  Usage: base64   Base64URL String 这将验证字符串值是否包含符合RFC4648规范的有效base64 URL安全值。尽管空字符串是有效的base64 URL安全值，但这将报告一个空字符串作为错误，如果您希望接受一个空字符串为有效字符串，则可以将其与omitempty标记一起使用。\n1  Usage: base64url   Bitcoin Address 这可以验证字符串值包含有效的比特币地址。检查字符串的格式以确保它与三种格式P2PKH，P2SH之一匹配并执行校验和验证。\n1  Usage: btc_addr   比特币Bech32地址（隔离见证）\n这可以验证字符串值包含由bip-0173（https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki） 定义的有效比特币Bech32地址。特别感谢Pieter Wuille提供了参考实现。\n1  Usage: btc_addr_bech32   Ethereum Address 这可以验证字符串值包含有效的以太坊地址。检查字符串的格式以确保它与标准的以太坊地址格式匹配完全验证被https://github.com/golang/crypto/pull/28阻止\n1  Usage: eth_addr   Contains 这验证了字符串值包含子字符串值。\n1  Usage: contains=@   Contains Any 这可以验证字符串值在子字符串值中是否包含任何Unicode代码点。\n1  Usage: containsany=!@#?   Contains Rune 这将验证字符串值包含提供的Rune值。\n1  Usage: containsrune=@   Excludes 这验证了字符串值不包含子字符串值。\n1  Usage: excludes=@   Excludes All 这可以验证字符串值在子字符串值中不包含任何Unicode代码点。\n1  Usage: excludesall=!@#?   Excludes Rune 这可以验证字符串值不包含提供的Rune值。\n1  Usage: excludesrune=@   Starts With 这将验证字符串值以提供的字符串值开头\n1  Usage: startswith=hello   Ends With 这可以验证字符串值以提供的字符串值结尾\n1  Usage: endswith=goodbye   International Standard Book Number 这将验证字符串值包含有效的isbn10或isbn13值。\n1  Usage: isbn   International Standard Book Number 10 这验证了字符串值包含有效的isbn10值。\n1  Usage: isbn10   International Standard Book Number 13 这验证了字符串值包含有效的isbn13值。\n1  Usage: isbn13   Universally Unique Identifier UUID 这将验证字符串值包含有效的UUID。大写的UUID值不会通过-改用uuid_rfc4122。\n1  Usage: uuid   Universally Unique Identifier UUID v3 这将验证字符串值包含有效的版本3 UUID。大写的UUID值不会通过-改用uuid3_rfc4122。\n1  Usage: uuid3   Universally Unique Identifier UUID v4 这将验证字符串值包含有效的版本4 UUID。大写的UUID值不会通过-改用uuid4_rfc4122。\n1  Usage: uuid4   Universally Unique Identifier UUID v5 这将验证字符串值包含有效的版本5 UUID。大写的UUID值不会通过-改用uuid5_rfc4122。\n1  Usage: uuid5   ASCII 这可以验证字符串值仅包含ASCII字符。注意：如果字符串为空，则验证为true。\n1  Usage: ascii   Printable ASCII 这可以验证字符串值仅包含可打印的ASCII字符。注意：如果字符串为空，则验证为true。\n1  Usage: printascii   Multi-Byte Characters 这验证了字符串值包含一个或多个多字节字符。注意：如果字符串为空，则验证为true。\n1  Usage: multibyte   Data URL 这将验证字符串值包含有效的DataURI。注意：这还将验证数据部分是有效的base64\n1  Usage: datauri   Latitude 这验证了字符串值包含有效的纬度。\n1  Usage: latitude   Longitude 这可以验证字符串值包含有效的经度。\n1  Usage: longitude   Social Security Number SSN 这将验证字符串值包含有效的美国社会安全号码。\n1  Usage: ssn   Internet Protocol Address IP 这可以验证字符串值包含有效的IP地址。\n1  Usage: ip   Internet Protocol Address IPv4 这将验证字符串值包含有效的v4 IP地址。\n1  Usage: ipv4   Internet Protocol Address IPv6 这将验证字符串值包含有效的v6 IP地址。\n1  Usage: ipv6   Classless Inter-Domain Routing CIDR 这将验证字符串值包含有效的CIDR地址。\n1  Usage: cidr   Classless Inter-Domain Routing CIDRv4 这将验证字符串值包含有效的v4 CIDR地址。\n1  Usage: cidrv4   Classless Inter-Domain Routing CIDRv6 这将验证字符串值包含有效的v6 CIDR地址。\n1  Usage: cidrv6   Transmission Control Protocol Address TCP 这可以验证字符串值包含有效的可解析TCP地址。\n1  Usage: tcp_addr   Transmission Control Protocol Address TCPv4 这将验证字符串值包含有效的可解析v4 TCP地址。\n1  Usage: tcp4_addr   Transmission Control Protocol Address TCPv6 这将验证字符串值包含有效的可解析v6 TCP地址。\n1  Usage: tcp6_addr   User Datagram Protocol Address UDP 这将验证字符串值包含有效的可解析UDP地址。\n1  Usage: udp_addr   User Datagram Protocol Address UDPv4 这将验证字符串值包含有效的可解析v4 UDP地址。\n1  Usage: udp4_addr   User Datagram Protocol Address UDPv6 这将验证字符串值包含有效的可解析v6 UDP地址。\n1  Usage: udp6_addr   Internet Protocol Address IP 这可以验证字符串值包含有效的可解析IP地址。\n1  Usage: ip_addr   Internet Protocol Address IPv4 这将验证字符串值包含有效的可解析v4 IP地址。\n1  Usage: ip4_addr   Internet Protocol Address IPv6 这将验证字符串值包含有效的可解析v6 IP地址。\n1  Usage: ip6_addr   Unix domain socket end point Address 这将验证字符串值包含有效的Unix地址。\n1  Usage: unix_addr   Media Access Control Address MAC 这可以验证字符串值包含有效的MAC地址。\n1  Usage: mac   注意：有关可接受的格式和类型，请参见Go’s ParseMAC：\nhttp://golang.org/src/net/mac.go?s=866:918#L29\nHostname RFC 952 这将根据RFC 952 https://tools.ietf.org/html/rfc952 验证字符串值是有效的主机名\n1  Usage: hostname   Hostname RFC 1123 这会根据RFC 1123 https://tools.ietf.org/html/rfc1123 验证字符串值是有效的主机名\n1  Usage: hostname_rfc1123 or if you want to continue to use 'hostname' in your tags, create an alias.   Full Qualified Domain Name (FQDN) 这将验证字符串值包含有效的FQDN。\n1  Usage: fqdn   HTML Tags 这可以验证字符串值似乎是HTML元素标签，包括https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element中描述的那些\n1  Usage: html   HTML Encoded 这可以验证字符串值是十进制或十六进制格式的正确字符引用\n1  Usage: html_encoded   URL Encoded 这验证了根据 https://tools.ietf.org/html/rfc3986#section-2.1 对字符串值进行百分比编码（URL编码）\n1  Usage: url_encoded   Directory 这将验证字符串值包含有效目录，并且该目录存在于计算机上。这是使用os.Stat完成的，它是一个与平台无关的功能。\n1  Usage: dir   ",
  "wordCount" : "13745",
  "inLanguage": "zh-cn",
  "datePublished": "2019-12-12T20:43:20Z",
  "dateModified": "2019-12-14T16:38:52+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/packagevalidator.v9/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      package:validator.v9
    </h1>
    <div class="post-meta">December 12, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="标准库">标准库<a hidden class="anchor" aria-hidden="true" href="#标准库">#</a></h1>
<h2 id="package-validator">package validator<a hidden class="anchor" aria-hidden="true" href="#package-validator">#</a></h2>
<p>import &ldquo;gopkg.in/go-playground/validator.v9&rdquo;</p>
<p>Package validator 基于标签对结构和单个字段实现值验证.</p>
<p>它还可以处理嵌套结构的跨字段和跨结构验证，并具有深入研究任何类型的数组和映射的能力。</p>
<p>查看更多示例 <a href="https://github.com/go-playground/validator/tree/master/_examples">https://github.com/go-playground/validator/tree/master/_examples</a></p>
<h2 id="验证函数返回类型错误">验证函数返回类型错误<a hidden class="anchor" aria-hidden="true" href="#验证函数返回类型错误">#</a></h2>
<p>Doing things this way is actually the way the standard library does, see the file.Open method here:</p>
<p><a href="https://golang.org/pkg/os/#Open">https://golang.org/pkg/os/#Open</a>.
The authors return type &ldquo;error&rdquo; to avoid the issue discussed in the following, where err is always != nil:</p>
<p><a href="http://stackoverflow.com/a/29138676/3158232">http://stackoverflow.com/a/29138676/3158232</a>
<a href="https://github.com/go-playground/validator/issues/134">https://github.com/go-playground/validator/issues/134</a></p>
<p>Validator only InvalidValidationError for bad validation input, nil or ValidationErrors as type error; 因此，在您的代码中，您所需要做的就是检查 err 是否为 nil, 以及检查错误是否为InvalidValidationError（如果有必要，大多数情况下不是），请像这样将其强制转换为ValidationErrors类型错误（validator.ValidationErrors）</p>
<h2 id="自定义验证功能">自定义验证功能<a hidden class="anchor" aria-hidden="true" href="#自定义验证功能">#</a></h2>
<p>可以添加自定义验证功能。</p>
<p>Example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Structure
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">customFunc</span><span class="p">(</span><span class="nx">fl</span> <span class="nx">validator</span><span class="p">.</span><span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nx">fl</span><span class="p">.</span><span class="nf">Field</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;invalid&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="nx">validate</span><span class="p">.</span><span class="nf">RegisterValidation</span><span class="p">(</span><span class="s">&#34;custom tag name&#34;</span><span class="p">,</span> <span class="nx">customFunc</span><span class="p">)</span>
<span class="c1">//注意：使用与现有功能相同的标记名称
</span><span class="c1">//将覆盖现有功能
</span></code></pre></td></tr></table>
</div>
</div><h2 id="跨field验证">跨field验证<a hidden class="anchor" aria-hidden="true" href="#跨field验证">#</a></h2>
<p>跨field验证可以通过以下标签完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">- eqfield
- nefield
- gtfield
- gtefield
- ltfield
- ltefield
- eqcsfield
- necsfield
- gtcsfield
- gtecsfield
- ltcsfield
- ltecsfield
</code></pre></td></tr></table>
</div>
</div><p>如果需要某些自定义跨域验证，则可以使用自定义验证来完成。</p>
<p>为什么不只具有跨域验证标签（即仅eqcsfield而不是eqfield）？</p>
<p>原因是效率。如果要检查同一结构中的字段，则“ eqfield”仅需在同一结构（1级）上找到该字段。但是，如果我们使用“ eqcsfield”，则可能会降低多个级别。例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Inner</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">StartDate</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Outer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">InnerStructField</span> <span class="o">*</span><span class="nx">Inner</span>
	<span class="nx">CreatedAt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>      <span class="s">`validate:&#34;ltecsfield=InnerStructField.StartDate&#34;`</span>
<span class="p">}</span>

<span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>

<span class="nx">inner</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Inner</span><span class="p">{</span>
	<span class="nx">StartDate</span><span class="p">:</span> <span class="nx">now</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">outer</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Outer</span><span class="p">{</span>
	<span class="nx">InnerStructField</span><span class="p">:</span> <span class="nx">inner</span><span class="p">,</span>
	<span class="nx">CreatedAt</span><span class="p">:</span> <span class="nx">now</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">outer</span><span class="p">)</span>

<span class="c1">// NOTE: when calling validate.Struct(val) topStruct will be the top level struct passed
</span><span class="c1">//       into the function
</span><span class="c1">//       when calling validate.VarWithValue(val, field, tag) val will be
</span><span class="c1">//       whatever you pass, struct, field...
</span><span class="c1">//       when calling validate.Field(field, tag) val will be nil
</span></code></pre></td></tr></table>
</div>
</div><h2 id="多个validate">多个validate<a hidden class="anchor" aria-hidden="true" href="#多个validate">#</a></h2>
<p>字段上的多个validate将按照定义的顺序进行处理。例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Field</span> <span class="s">`validate:&#34;max=10,min=1&#34;`</span>
<span class="p">}</span>

<span class="c1">// max will be checked then min
</span></code></pre></td></tr></table>
</div>
</div><p>库不处理无效的验证器定义。例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Field</span> <span class="s">`validate:&#34;min=10,max=0&#34;`</span>
<span class="p">}</span>
<span class="c1">// this definition of min max will never succeed
</span></code></pre></td></tr></table>
</div>
</div><h2 id="使用验证标签">使用验证标签<a hidden class="anchor" aria-hidden="true" href="#使用验证标签">#</a></h2>
<p>跨field验证仅比较同一结构上的字段。如果需要跨field+跨struct验证，则应实现自己的自定义validator。</p>
<p>逗号（“，”）是验证标签的默认分隔符。如果希望在参数中包含逗号（即excludesall =，），则需要使用UTF-8十六进制表示形式0x2C，在代码中将其替换为逗号，因此以上内容将变为excludesall = 0x2C。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Field</span> <span class="s">`validate:&#34;excludesall=,&#34;`</span>    <span class="c1">// BAD! Do not include a comma.
</span><span class="c1"></span>	<span class="nx">Field</span> <span class="s">`validate:&#34;excludesall=0x2C&#34;`</span> <span class="c1">// GOOD! Use the UTF-8 hex representation.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>管道（“ |”）是&rsquo;或&rsquo;验证标签的分隔符。如果希望在参数中包含管道，即excludesall = | 您将需要使用UTF-8十六进制表示形式0x7C，在代码中将其替换为管道，因此以上内容将变为excludesall = 0x7C</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Field</span> <span class="s">`validate:&#34;excludesall=|&#34;`</span>    <span class="c1">// BAD! Do not include a a pipe!
</span><span class="c1"></span>	<span class="nx">Field</span> <span class="s">`validate:&#34;excludesall=0x7C&#34;`</span> <span class="c1">// GOOD! Use the UTF-8 hex representation.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="alias-validators-and-tags">Alias Validators and Tags<a hidden class="anchor" aria-hidden="true" href="#alias-validators-and-tags">#</a></h2>
<p>注意：返回错误时，在“FieldError”中返回的标签将是别名标签，除非dive标签是别名的一部分。dive标签之后的所有内容均不会报告为别名标签。同样，在前面的情况下，“ ActualTag”将是失败的别名中的实际标签。</p>
<p>这是当前内置别名标签的列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&#34;iscolor&#34;
	alias is &#34;hexcolor|rgb|rgba|hsl|hsla&#34; (Usage: iscolor)
</code></pre></td></tr></table>
</div>
</div><h2 id="正则表达式标签">正则表达式标签<a hidden class="anchor" aria-hidden="true" href="#正则表达式标签">#</a></h2>
<p>不会添加正则表达式验证器，因为逗号和=符号可能是与验证定义冲突的正则表达式的一部分。 尽管可以采取解决方法，但它们不能使用纯正则表达式。 此外，它既快速又肮脏，正则表达式变得更难维护且不可重用，因此它与任何东西一样，都是编程哲学。</p>
<p>代替此新的验证器功能，应创建自定义验证函数； regex可以在验证函数中使用，甚至可以在regexes.go中进行预编译以提高效率。最好的原因是，您可以提交请求请求，我们可以继续添加到此程序包的验证库中！</p>
<h2 id="panics">Panics<a hidden class="anchor" aria-hidden="true" href="#panics">#</a></h2>
<p>当提供错误的输入时，此程序包会panic，这是设计使然，这样的错误代码不应使其投入生产。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">TestField</span> <span class="kt">string</span> <span class="s">`validate:&#34;nonexistantfunction=1&#34;`</span>
<span class="p">}</span>

<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Test</span><span class="p">{</span>
	<span class="nx">TestField</span><span class="p">:</span> <span class="s">&#34;Test&#34;</span>
<span class="p">}</span>

<span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// this will panic
</span></code></pre></td></tr></table>
</div>
</div><h2 id="non-standard-validators">Non standard validators<a hidden class="anchor" aria-hidden="true" href="#non-standard-validators">#</a></h2>
<p>我们经常需要比在验证器中发现的验证规则更复杂的验证规则的集合。非标准验证器必须使用您喜欢的任何标签手动注册。请参阅下面的注册和使用示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">TestField</span> <span class="kt">string</span> <span class="s">`validate:&#34;yourtag&#34;`</span>
<span class="p">}</span>

<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Test</span><span class="p">{</span>
	<span class="nx">TestField</span><span class="p">:</span> <span class="s">&#34;Test&#34;</span>
<span class="p">}</span>

<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">validate</span><span class="p">.</span><span class="nf">RegisterValidation</span><span class="p">(</span><span class="s">&#34;yourtag&#34;</span><span class="p">,</span> <span class="nx">validations</span><span class="p">.</span><span class="nx">ValidatorName</span><span class="p">)</span>

<span class="nx">NotBlank</span>
	<span class="nx">This</span> <span class="nx">validates</span> <span class="nx">that</span> <span class="nx">the</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">blank</span> <span class="nx">or</span> <span class="nx">with</span> <span class="nx">length</span> <span class="nx">zero</span><span class="p">.</span>
	<span class="nx">For</span> <span class="nx">strings</span> <span class="nx">ensures</span> <span class="nx">they</span> <span class="nx">do</span> <span class="nx">not</span> <span class="nx">contain</span> <span class="nx">only</span> <span class="nx">spaces</span><span class="p">.</span> <span class="nx">For</span> <span class="nx">channels</span><span class="p">,</span> <span class="nx">maps</span><span class="p">,</span> <span class="nx">slices</span> <span class="nx">and</span> <span class="nx">arrays</span>
	<span class="nx">ensures</span> <span class="nx">they</span> <span class="nx">don</span><span class="err">&#39;</span><span class="nx">t</span> <span class="nx">have</span> <span class="nx">zero</span> <span class="nx">length</span><span class="p">.</span> <span class="nx">For</span> <span class="nx">others</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">non</span> <span class="nx">empty</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">required</span><span class="p">.</span>

    <span class="nx">Usage</span><span class="p">:</span> <span class="nx">notblank</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-customtypefunc">type CustomTypeFunc<a hidden class="anchor" aria-hidden="true" href="#type-customtypefunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CustomTypeFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">field</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>CustomTypeFunc允许重写或添加自定义字段类型处理程序函数field =类型的字段值以返回待验证的值</p>
<p>示例:</p>
<p>sql drive中的validator</p>
<p>请参见https://golang.org/src/database/sql/driver/types.go ？s = 1210：1293＃L29</p>
<h2 id="type-fielderror">type FieldError<a hidden class="anchor" aria-hidden="true" href="#type-fielderror">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FieldError</span> <span class="kd">interface</span> <span class="p">{</span>

    <span class="c1">// returns the validation tag that failed. if the
</span><span class="c1"></span>    <span class="c1">// validation was an alias, this will return the
</span><span class="c1"></span>    <span class="c1">// alias name and not the underlying tag that failed.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eg. alias &#34;iscolor&#34;: &#34;hexcolor|rgb|rgba|hsl|hsla&#34;
</span><span class="c1"></span>    <span class="c1">// will return &#34;iscolor&#34;
</span><span class="c1"></span>    <span class="nf">Tag</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the validation tag that failed, even if an
</span><span class="c1"></span>    <span class="c1">// alias the actual tag within the alias will be returned.
</span><span class="c1"></span>    <span class="c1">// If an &#39;or&#39; validation fails the entire or will be returned.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eg. alias &#34;iscolor&#34;: &#34;hexcolor|rgb|rgba|hsl|hsla&#34;
</span><span class="c1"></span>    <span class="c1">// will return &#34;hexcolor|rgb|rgba|hsl|hsla&#34;
</span><span class="c1"></span>    <span class="nf">ActualTag</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the namespace for the field error, with the tag
</span><span class="c1"></span>    <span class="c1">// name taking precedence over the fields actual name.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eg. JSON name &#34;User.fname&#34;
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// See StructNamespace() for a version that returns actual names.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTE: this field can be blank when validating a single primitive field
</span><span class="c1"></span>    <span class="c1">// using validate.Field(...) as there is no way to extract it&#39;s name
</span><span class="c1"></span>    <span class="nf">Namespace</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the namespace for the field error, with the fields
</span><span class="c1"></span>    <span class="c1">// actual name.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eq. &#34;User.FirstName&#34; see Namespace for comparison
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTE: this field can be blank when validating a single primitive field
</span><span class="c1"></span>    <span class="c1">// using validate.Field(...) as there is no way to extract it&#39;s name
</span><span class="c1"></span>    <span class="nf">StructNamespace</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the fields name with the tag name taking precedence over the
</span><span class="c1"></span>    <span class="c1">// fields actual name.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eq. JSON name &#34;fname&#34;
</span><span class="c1"></span>    <span class="c1">// see StructField for comparison
</span><span class="c1"></span>    <span class="nf">Field</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the fields actual name from the struct, when able to determine.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eq.  &#34;FirstName&#34;
</span><span class="c1"></span>    <span class="c1">// see Field for comparison
</span><span class="c1"></span>    <span class="nf">StructField</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the actual fields value in case needed for creating the error
</span><span class="c1"></span>    <span class="c1">// message
</span><span class="c1"></span>    <span class="nf">Value</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>

    <span class="c1">// returns the param value, in string form for comparison; this will also
</span><span class="c1"></span>    <span class="c1">// help with generating an error message
</span><span class="c1"></span>    <span class="nf">Param</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// Kind returns the Field&#39;s reflect Kind
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// eg. time.Time&#39;s kind is a struct
</span><span class="c1"></span>    <span class="nf">Kind</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span>

    <span class="c1">// Type returns the Field&#39;s reflect Type
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// // eg. time.Time&#39;s type is time.Time
</span><span class="c1"></span>    <span class="nf">Type</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span>

    <span class="c1">// returns the FieldError&#39;s translated error
</span><span class="c1"></span>    <span class="c1">// from the provided &#39;ut.Translator&#39; and registered &#39;TranslationFunc&#39;
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTE: if no registered translator can be found it returns the same as
</span><span class="c1"></span>    <span class="c1">// calling fe.Error()
</span><span class="c1"></span>    <span class="nf">Translate</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>FieldError包含获取错误详细信息的所有函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FieldLevel</span>
<span class="kd">type</span> <span class="nx">FieldLevel</span> <span class="kd">interface</span> <span class="p">{</span>

    <span class="c1">// returns the top level struct, if any
</span><span class="c1"></span>    <span class="nf">Top</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>

    <span class="c1">// returns the current fields parent struct, if any or
</span><span class="c1"></span>    <span class="c1">// the comparison value if called &#39;VarWithValue&#39;
</span><span class="c1"></span>    <span class="nf">Parent</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>

    <span class="c1">// returns current field for validation
</span><span class="c1"></span>    <span class="nf">Field</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>

    <span class="c1">// returns the field&#39;s name with the tag
</span><span class="c1"></span>    <span class="c1">// name taking precedence over the fields actual name.
</span><span class="c1"></span>    <span class="nf">FieldName</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns the struct field&#39;s name
</span><span class="c1"></span>    <span class="nf">StructFieldName</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// returns param for validation against current field
</span><span class="c1"></span>    <span class="nf">Param</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// ExtractType gets the actual underlying type of field value.
</span><span class="c1"></span>    <span class="c1">// It will dive into pointers, customTypes and return you the
</span><span class="c1"></span>    <span class="c1">// underlying value and it&#39;s kind.
</span><span class="c1"></span>    <span class="nf">ExtractType</span><span class="p">(</span><span class="nx">field</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">kind</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span><span class="p">,</span> <span class="nx">nullable</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// traverses the parent struct to retrieve a specific field denoted by the provided namespace
</span><span class="c1"></span>    <span class="c1">// in the param and returns the field, field kind and whether is was successful in retrieving
</span><span class="c1"></span>    <span class="c1">// the field at all.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field
</span><span class="c1"></span>    <span class="c1">// could not be retrieved because it didn&#39;t exist.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Deprecated: Use GetStructFieldOK2() instead which also return if the value is nullable.
</span><span class="c1"></span>    <span class="nf">GetStructFieldOK</span><span class="p">()</span> <span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// GetStructFieldOKAdvanced is the same as GetStructFieldOK except that it accepts the parent struct to start looking for
</span><span class="c1"></span>    <span class="c1">// the field and namespace allowing more extensibility for validators.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Deprecated: Use GetStructFieldOKAdvanced2() instead which also return if the value is nullable.
</span><span class="c1"></span>    <span class="nf">GetStructFieldOKAdvanced</span><span class="p">(</span><span class="nx">val</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">namespace</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// traverses the parent struct to retrieve a specific field denoted by the provided namespace
</span><span class="c1"></span>    <span class="c1">// in the param and returns the field, field kind, if it&#39;s a nullable type and whether is was successful in retrieving
</span><span class="c1"></span>    <span class="c1">// the field at all.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field
</span><span class="c1"></span>    <span class="c1">// could not be retrieved because it didn&#39;t exist.
</span><span class="c1"></span>    <span class="nf">GetStructFieldOK2</span><span class="p">()</span> <span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// GetStructFieldOKAdvanced is the same as GetStructFieldOK except that it accepts the parent struct to start looking for
</span><span class="c1"></span>    <span class="c1">// the field and namespace allowing more extensibility for validators.
</span><span class="c1"></span>    <span class="nf">GetStructFieldOKAdvanced2</span><span class="p">(</span><span class="nx">val</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">namespace</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>FieldLevel包含所有信息和帮助程序功能以验证字段</p>
<h2 id="type-filterfunc">type FilterFunc<a hidden class="anchor" aria-hidden="true" href="#type-filterfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FilterFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ns</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>FilterFunc是用于使用StructFiltered（&hellip;）函数过滤字段的类型。从验证中过滤/跳过字段中返回真实结果</p>
<h2 id="type-func">type Func<a hidden class="anchor" aria-hidden="true" href="#type-func">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Func</span> <span class="kd">func</span><span class="p">(</span><span class="nx">fl</span> <span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>Func接受FieldLevel接口以满足所有验证需求。验证成功时，返回值应为true。</p>
<h2 id="type-funcctx">type FuncCtx<a hidden class="anchor" aria-hidden="true" href="#type-funcctx">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FuncCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">fl</span> <span class="nx">FieldLevel</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>FuncCtx接受context.Context和FieldLevel接口来满足所有验证需求。验证成功时，返回值应为true。</p>
<h2 id="type-invalidvalidationerror">type InvalidValidationError<a hidden class="anchor" aria-hidden="true" href="#type-invalidvalidationerror">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">InvalidValidationError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>InvaStruct，StructExcept，StructPartial或Field的无效参数。</p>
<h3 id="func-invalidvalidationerror-error">func (*InvalidValidationError) Error<a hidden class="anchor" aria-hidden="true" href="#func-invalidvalidationerror-error">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">InvalidValidationError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>Error返回InvalidValidationError消息</p>
<h2 id="type-registertranslationsfunc">type RegisterTranslationsFunc<a hidden class="anchor" aria-hidden="true" href="#type-registertranslationsfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RegisterTranslationsFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterTranslationsFunc允许注册“ ut.Translator”的翻译，以在“TranslationFunc”中使用</p>
<h2 id="type-structlevel">type StructLevel<a hidden class="anchor" aria-hidden="true" href="#type-structlevel">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StructLevel</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// returns the main validation object, in case one wants to call validations internally.
</span><span class="c1"></span>    <span class="c1">// this is so you don&#39;t have to use anonymous functions to get access to the validate
</span><span class="c1"></span>    <span class="c1">// instance.
</span><span class="c1"></span>    <span class="nf">Validator</span><span class="p">()</span> <span class="o">*</span><span class="nx">Validate</span>

    <span class="c1">// returns the top level struct, if any
</span><span class="c1"></span>    <span class="nf">Top</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>

    <span class="c1">// returns the current fields parent struct, if any
</span><span class="c1"></span>    <span class="nf">Parent</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>

    <span class="c1">// returns the current struct.
</span><span class="c1"></span>    <span class="nf">Current</span><span class="p">()</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>

    <span class="c1">// ExtractType gets the actual underlying type of field value.
</span><span class="c1"></span>    <span class="c1">// It will dive into pointers, customTypes and return you the
</span><span class="c1"></span>    <span class="c1">// underlying value and its kind.
</span><span class="c1"></span>    <span class="nf">ExtractType</span><span class="p">(</span><span class="nx">field</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">kind</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Kind</span><span class="p">,</span> <span class="nx">nullable</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// reports an error just by passing the field and tag information
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTES:
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// fieldName and altName get appended to the existing namespace that
</span><span class="c1"></span>    <span class="c1">// validator is on. e.g. pass &#39;FirstName&#39; or &#39;Names[0]&#39; depending
</span><span class="c1"></span>    <span class="c1">// on the nesting
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// tag can be an existing validation tag or just something you make up
</span><span class="c1"></span>    <span class="c1">// and process on the flip side it&#39;s up to you.
</span><span class="c1"></span>    <span class="nf">ReportError</span><span class="p">(</span><span class="nx">field</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fieldName</span><span class="p">,</span> <span class="nx">structFieldName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">tag</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span>

    <span class="c1">// reports an error just by passing ValidationErrors
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTES:
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// relativeNamespace and relativeActualNamespace get appended to the
</span><span class="c1"></span>    <span class="c1">// existing namespace that validator is on.
</span><span class="c1"></span>    <span class="c1">// e.g. pass &#39;User.FirstName&#39; or &#39;Users[0].FirstName&#39; depending
</span><span class="c1"></span>    <span class="c1">// on the nesting. most of the time they will be blank, unless you validate
</span><span class="c1"></span>    <span class="c1">// at a level lower the the current field depth
</span><span class="c1"></span>    <span class="nf">ReportValidationErrors</span><span class="p">(</span><span class="nx">relativeNamespace</span><span class="p">,</span> <span class="nx">relativeActualNamespace</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">errs</span> <span class="nx">ValidationErrors</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StructLevel包含用于验证结构的所有信息和辅助函数</p>
<h2 id="type-structlevelfunc">type StructLevelFunc<a hidden class="anchor" aria-hidden="true" href="#type-structlevelfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StructLevelFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">sl</span> <span class="nx">StructLevel</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StructLevelFunc接受结构级别验证所需的所有值</p>
<h2 id="type-structlevelfuncctx">type StructLevelFuncCtx<a hidden class="anchor" aria-hidden="true" href="#type-structlevelfuncctx">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StructLevelFuncCtx</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">sl</span> <span class="nx">StructLevel</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StructLevelFuncCtx接受结构级别验证所需的所有值，但也允许通过context.Context传递上下文验证信息。</p>
<h2 id="type-tagnamefunc">type TagNameFunc<a hidden class="anchor" aria-hidden="true" href="#type-tagnamefunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TagNameFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">field</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>TagNameFunc允许添加自定义标签名称解析器</p>
<h2 id="type-translationfunc">type TranslationFunc<a hidden class="anchor" aria-hidden="true" href="#type-translationfunc">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TranslationFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">fe</span> <span class="nx">FieldError</span><span class="p">)</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>TranslationFunc是用于注册或覆盖自定义翻译的函数类型</p>
<h2 id="type-validate">type Validate<a hidden class="anchor" aria-hidden="true" href="#type-validate">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Validate</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Validate包含验证器设置和缓存</p>
<h3 id="func-new">func New<a hidden class="anchor" aria-hidden="true" href="#func-new">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">Validate</span>
</code></pre></td></tr></table>
</div>
</div><p>New返回一个默认值“validate”的新实例。</p>
<h3 id="func-validate-registeralias">func (*Validate) RegisterAlias<a hidden class="anchor" aria-hidden="true" href="#func-validate-registeralias">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterAlias</span><span class="p">(</span><span class="nx">alias</span><span class="p">,</span> <span class="nx">tags</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterAlias注册单个验证标签的映射，该映射定义一组通用或复杂的验证集，以简化向结构添加验证的过程。</p>
<p>注意：此函数不是线程安全的，因此应在进行任何验证之前先将它们全部注册</p>
<h3 id="func-validate-registercustomtypefunc">func (*Validate) RegisterCustomTypeFunc<a hidden class="anchor" aria-hidden="true" href="#func-validate-registercustomtypefunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterCustomTypeFunc</span><span class="p">(</span><span class="nx">fn</span> <span class="nx">CustomTypeFunc</span><span class="p">,</span> <span class="nx">types</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterCustomTypeFunc针对多种类型注册CustomTypeFunc</p>
<p>注意：此方法不是线程安全的，因此应在进行任何验证之前先将它们全部注册</p>
<h3 id="func-validate-registerstructvalidation">func (*Validate) RegisterStructValidation<a hidden class="anchor" aria-hidden="true" href="#func-validate-registerstructvalidation">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterStructValidation</span><span class="p">(</span><span class="nx">fn</span> <span class="nx">StructLevelFunc</span><span class="p">,</span> <span class="nx">types</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterStructValidation针对多种类型注册StructLevelFunc。</p>
<p>注意：-此方法不是线程安全的，因此应在进行任何验证之前先将它们全部注册</p>
<h3 id="func-validate-registerstructvalidationctx">func (*Validate) RegisterStructValidationCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-registerstructvalidationctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterStructValidationCtx</span><span class="p">(</span><span class="nx">fn</span> <span class="nx">StructLevelFuncCtx</span><span class="p">,</span> <span class="nx">types</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterStructValidationCtx针对多种类型注册StructLevelFuncCtx，并允许通过context.Context传递上下文验证信息。</p>
<p>注意：-此方法不是线程安全的，因此应在进行任何验证之前先将它们全部注册</p>
<h3 id="func-validate-registertagnamefunc">func (*Validate) RegisterTagNameFunc<a hidden class="anchor" aria-hidden="true" href="#func-validate-registertagnamefunc">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="nx">fn</span> <span class="nx">TagNameFunc</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterTagNameFunc注册一个函数来获取StructFields的备用名称。</p>
<p>例如。使用为JSON表示结构指定的名称，而不是普通的Go字段名称：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">validate</span><span class="p">.</span><span class="nf">RegisterTagNameFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">fld</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StructField</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">SplitN</span><span class="p">(</span><span class="nx">fld</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;json&#34;</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">name</span> <span class="o">==</span> <span class="s">&#34;-&#34;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">name</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="func-validate-registertranslation">func (*Validate) RegisterTranslation<a hidden class="anchor" aria-hidden="true" href="#func-validate-registertranslation">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterTranslation</span><span class="p">(</span><span class="nx">tag</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">trans</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">registerFn</span><span class="p">,</span><span class="nx">RegisterTranslationsFunc</span><span class="p">,</span> <span class="nx">translationFn</span> <span class="nx">TranslationFunc</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterTranslation根据提供的标签注册翻译。</p>
<h3 id="func-validate-registervalidation">func (*Validate) RegisterValidation<a hidden class="anchor" aria-hidden="true" href="#func-validate-registervalidation">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterValidation</span><span class="p">(</span><span class="nx">tag</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fn</span> <span class="nx">Func</span><span class="p">,</span> <span class="nx">callValidationEvenIfNull</span> <span class="o">...</span><span class="kt">bool</span><span class="p">)</span>
 <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterValidation使用给定标签添加验证</p>
<p>注意：-如果密钥已经存在，则先前的验证功能将被替换。-此方法不是线程安全的，因此应在进行任何验证之前将其全部注册</p>
<h3 id="func-validate-registervalidationctx">func (*Validate) RegisterValidationCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-registervalidationctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">RegisterValidationCtx</span><span class="p">(</span><span class="nx">tag</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fn</span> <span class="nx">FuncCtx</span><span class="p">,</span> <span class="nx">callValidationEvenIfNull</span> 
<span class="o">...</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>RegisterValidationCtx的功能与RegisterValidation相同，它接受FuncCtx验证并允许使用context.Context验证。</p>
<h3 id="func-validate-settagname">func (*Validate) SetTagName<a hidden class="anchor" aria-hidden="true" href="#func-validate-settagname">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">SetTagName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>SetTagName允许更改默认标签名称“validate”</p>
<h3 id="func-validate-struct">func (*Validate) Struct<a hidden class="anchor" aria-hidden="true" href="#func-validate-struct">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">Struct</span><span class="p">(</span><span class="nx">s</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>除非另有说明，否则Struct会验证结构的公开字段，并自动验证嵌套的结构。</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors)访问错误数组。</p>
<h3 id="func-validate-structctx">func (*Validate) StructCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-structctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructCtx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">s</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>除非另行指定，否则StructCtx会验证暴露的结构体的结构，并自动验证嵌套的结构体，除非另外指定，并且还允许传递context.Context作为上下文验证信息。</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors)访问错误数组。</p>
<h3 id="func-validate-structexcept">func (*Validate) StructExcept<a hidden class="anchor" aria-hidden="true" href="#func-validate-structexcept">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructExcept</span><span class="p">(</span><span class="nx">s</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fields</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>StructExcept会验证除传入字段外的所有其他字段。可以相对于所提供的结构（即NestedStruct.Field或NestedArrayField [0] .Struct.Name）以命名空间的方式提供字段。</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors)访问错误数组。</p>
<h3 id="func-validate-structexceptctx">func (*Validate) StructExceptCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-structexceptctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructExceptCtx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">s</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fields</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> 
<span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StructExceptCtx会验证除传入字段外的所有字段，并允许通过上下文传递上下文验证验证信息。可以相对于所提供的结构，即NestedStruct.Field或NestedArrayField [0] .Struct.Name，以命名空间的方式提供上下文字段。</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。</p>
<h3 id="func-validate-structfiltered">func (*Validate) StructFiltered<a hidden class="anchor" aria-hidden="true" href="#func-validate-structfiltered">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructFiltered</span><span class="p">(</span><span class="nx">s</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fn</span> <span class="nx">FilterFunc</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>除非另有说明，否则StructFiltered会验证结构公开的字段，这些字段通过FilterFunc检查并自动验证嵌套的结构。</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。</p>
<h3 id="func-validate-structfilteredctx">func (*Validate) StructFilteredCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-structfilteredctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructFilteredCtx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">s</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fn</span> <span class="nx">FilterFunc</span><span class="p">)</span> 
<span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>除非另有说明，否则StructFilteredCtx会验证结构公开的字段，这些字段通过FilterFunc检查并自动验证嵌套的结构，除非另有说明，并且还允许通过context传递上下文验证信息。</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。</p>
<h3 id="func-validate-structpartial">func (*Validate) StructPartial<a hidden class="anchor" aria-hidden="true" href="#func-validate-structpartial">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructPartial</span><span class="p">(</span><span class="nx">s</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fields</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>StructPartial仅验证传入的字段，而忽略所有其他字段。可以相对于所提供的结构以命名空间的方式提供字段。NestedStruct.Field或NestedArrayField [0] .Struct.Name</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。</p>
<h3 id="func-validate-structpartialctx">func (*Validate) StructPartialCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-structpartialctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">StructPartialCtx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">s</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">fields</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> 
<span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StructPartialCtx仅验证传入的字段，而忽略所有其他字段，并允许通过context传递上下文验证验证信息。Context字段可以相对于所提供的结构以命名空间的方式提供。NestedStruct.Field或NestedArrayField [0] .Struct.Name</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。</p>
<h3 id="func-validate-var">func (*Validate) Var<a hidden class="anchor" aria-hidden="true" href="#func-validate-var">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">Var</span><span class="p">(</span><span class="nx">field</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">tag</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>Var使用标记样式验证来验证单个变量。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span> 
<span class="nx">validate</span><span class="p">.</span><span class="nf">Var</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="s">&#34;gt=1,lt=10&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error</p>
<h3 id="func-validate-varctx">func (*Validate) VarCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-varctx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">VarCtx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">field</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">tag</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Var使用标记样式验证来验证单个变量。并允许通过context.Context传递上下文验证验证信息。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span> 
<span class="nx">validate</span><span class="p">.</span><span class="nf">Var</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="s">&#34;gt=1,lt=10&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error</p>
<h3 id="func-validate-varwithvalue">func (*Validate) VarWithValue<a hidden class="anchor" aria-hidden="true" href="#func-validate-varwithvalue">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">VarWithValue</span><span class="p">(</span><span class="nx">field</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">other</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">tag</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>VarWithValue使用标签样式验证（例如）针对另一个变量/字段的值来验证单个变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span> <span class="o">:=</span> <span class="s">&#34;abcd&#34;</span> 
<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;abcd&#34;</span> 
<span class="nx">validate</span><span class="p">.</span><span class="nf">VarWithValue</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="s">&#34;eqcsfield&#34;</span><span class="p">)</span> <span class="c1">// returns true
</span></code></pre></td></tr></table>
</div>
</div><p>警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error</p>
<h3 id="func-validate-varwithvaluectx">func (*Validate) VarWithValueCtx<a hidden class="anchor" aria-hidden="true" href="#func-validate-varwithvaluectx">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Validate</span><span class="p">)</span> <span class="nf">VarWithValueCtx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">field</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">other</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">,</span> <span class="nx">tag</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>VarWithValue使用标签样式验证（例如）针对另一个变量/字段的值来验证单个变量。并允许通过context.Context传递上下文验证验证信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span> <span class="o">:=</span> <span class="s">&#34;abcd&#34;</span> 
<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;abcd&#34;</span> 
<span class="nx">validate</span><span class="p">.</span><span class="nf">VarWithValue</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="s">&#34;eqcsfield&#34;</span><span class="p">)</span> <span class="c1">// returns true
</span></code></pre></td></tr></table>
</div>
</div><p>警告：可以传递结构进行验证，例如。time.Time是一个结构，或者您具有自定义类型并注册了自定义类型处理程序，因此必须允许它；但是，如果尝试验证要传递给“ validate.Struct”的结构，则会发生无法预料的验证</p>
<p>对于传入的错误值，它返回InvalidValidationError，否则返回nil或ValidationErrors作为错误。如果错误不为零，则需要声明错误。err.(validator.ValidationErrors）访问错误数组。 validate Array, Slice and maps fields which may contain more than one error</p>
<h1 id="type-validationerrors">type ValidationErrors<a hidden class="anchor" aria-hidden="true" href="#type-validationerrors">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ValidationErrors</span> <span class="p">[]</span><span class="nx">FieldError</span>
</code></pre></td></tr></table>
</div>
</div><p>ValidationErrors是FieldError的数组，用于验证后的自定义错误消息。</p>
<h2 id="func-validationerrors-error">func (ValidationErrors) Error<a hidden class="anchor" aria-hidden="true" href="#func-validationerrors-error">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ve</span> <span class="nx">ValidationErrors</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>Error 旨在用于开发+调试，而并非旨在作为生产错误消息。它允许ValidationErrors订阅Error接口。在ValidationErrors数组中找到的FieldError中包含创建特定于您的应用程序的错误消息的所有信息。</p>
<h2 id="func-validationerrors-translate">func (ValidationErrors) Translate<a hidden class="anchor" aria-hidden="true" href="#func-validationerrors-translate">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ve</span> <span class="nx">ValidationErrors</span><span class="p">)</span> <span class="nf">Translate</span><span class="p">(</span><span class="nx">ut</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="nx">ValidationErrorsTranslations</span>
</code></pre></td></tr></table>
</div>
</div><p>Translate 会翻译所有ValidationErrors</p>
<h1 id="type-validationerrorstranslations">type ValidationErrorsTranslations<a hidden class="anchor" aria-hidden="true" href="#type-validationerrorstranslations">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ValidationErrorsTranslations</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>ValidationErrorsTranslations是Translate返回类型</p>
<h1 id="嵌入验证器和标签">嵌入验证器和标签<a hidden class="anchor" aria-hidden="true" href="#嵌入验证器和标签">#</a></h1>
<p>这是当前内置验证器的列表：</p>
<h3 id="skip-field">Skip Field<a hidden class="anchor" aria-hidden="true" href="#skip-field">#</a></h3>
<p>告诉验证跳过此struct字段；这在忽略嵌入式结构被验证时特别方便。（用法：-）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: -
</code></pre></td></tr></table>
</div>
</div><h3 id="or-operator">Or Operator<a hidden class="anchor" aria-hidden="true" href="#or-operator">#</a></h3>
<p>这是允许多个验证器使用和接受的“或”运算符。（用法：rbg | rgba）&lt;-这将允许接受rgb或rgba颜色。例如，也可以将其与&rsquo;and&rsquo;结合使用（用法：omitempty，rgb | rgba）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: |
</code></pre></td></tr></table>
</div>
</div><h3 id="structonly">StructOnly<a hidden class="anchor" aria-hidden="true" href="#structonly">#</a></h3>
<p>当遇到作为嵌套结构的字段并包含此标志时，将对嵌套结构进行任何验证，但不会验证任何嵌套结构字段。如果您在程序内部知道该结构将是有效的，但是需要验证它是否已被分配，则这很有用。注意：在结构本身上只能使用“required”和“ omitempty”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: structonly
</code></pre></td></tr></table>
</div>
</div><h3 id="nostructlevel">NoStructLevel<a hidden class="anchor" aria-hidden="true" href="#nostructlevel">#</a></h3>
<p>与structonly标记相同，除了不会运行任何结构级别的验证。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: nostructlevel
</code></pre></td></tr></table>
</div>
</div><h3 id="omit-empty">Omit Empty<a hidden class="anchor" aria-hidden="true" href="#omit-empty">#</a></h3>
<p>允许条件验证，例如，如果未为字段设置值（由“required”验证器确定），则其他验证（例如min或max）将不会运行，但是如果设置了值，验证将运行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: omitempty
</code></pre></td></tr></table>
</div>
</div><h3 id="dive">Dive<a hidden class="anchor" aria-hidden="true" href="#dive">#</a></h3>
<p>This tells the validator to dive into a slice, array or map and validate that level of the slice, array or map with the validation tags that follow. Multidimensional nesting is also supported, each level you wish to dive will require another dive tag. dive has some sub-tags, &lsquo;keys&rsquo; &amp; &lsquo;endkeys&rsquo;, please see the Keys &amp; EndKeys section just below.</p>
<p>这告诉验证者进入slice, array, map ，并使用后面的验证标签验证slice, array, map的级别。还支持多维嵌套，您要Dive的每个级别都将需要另一个Dive标签。潜水有一些子标签，“keys”和“endkeys”，请参阅下面的“ Keys &amp; EndKeys”部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Usage</span><span class="p">:</span> <span class="nx">dive</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span>

<span class="p">[][]</span><span class="kt">string</span> <span class="nx">with</span> <span class="nx">validation</span> <span class="nx">tag</span> <span class="s">&#34;gt=0,dive,len=1,dive,required&#34;</span>
<span class="c1">// gt=0 will be applied to []
</span><span class="c1">// len=1 will be applied to []string
</span><span class="c1">// required will be applied to string
</span><span class="c1"></span><span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span>

<span class="p">[][]</span><span class="kt">string</span> <span class="nx">with</span> <span class="nx">validation</span> <span class="nx">tag</span> <span class="s">&#34;gt=0,dive,dive,required&#34;</span>
<span class="c1">// gt=0 will be applied to []
</span><span class="c1">// []string will be spared validation
</span><span class="c1">// required will be applied to string
</span></code></pre></td></tr></table>
</div>
</div><h3 id="keys--endkeys">Keys &amp; EndKeys<a hidden class="anchor" aria-hidden="true" href="#keys--endkeys">#</a></h3>
<p>它们将在dive标签之后直接一起使用，并告诉验证者“keys”和“endkeys”之间的任何内容都适用于map的keys，而不是values。可以将其视为“ dive”标签，但适用于map keys而不是values。还支持多维嵌套，您要验证的每个级别都将需要另一个“keys”和“endkeys”标签。这些标签仅对map有效。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: dive,keys,othertagvalidation(s),endkeys,valuevalidationtags
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span>

<span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="nx">with</span> <span class="nx">validation</span> <span class="nx">tag</span> <span class="s">&#34;gt=0,dive,keys,eg=1|eq=2,endkeys,required&#34;</span>
<span class="c1">// gt=0 will be applied to the map itself
</span><span class="c1">// eg=1|eq=2 will be applied to the map keys
</span><span class="c1">// required will be applied to map values
</span><span class="c1"></span><span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span>

<span class="kd">map</span><span class="p">[[</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="nx">with</span> <span class="nx">validation</span> <span class="nx">tag</span> <span class="s">&#34;gt=0,dive,keys,dive,eq=1|eq=2,endkeys,required&#34;</span>
<span class="c1">// gt=0 will be applied to the map itself
</span><span class="c1">// eg=1|eq=2 will be applied to each array element in the the map keys
</span><span class="c1">// required will be applied to map values
</span></code></pre></td></tr></table>
</div>
</div><h3 id="required">Required<a hidden class="anchor" aria-hidden="true" href="#required">#</a></h3>
<p>这可以验证该值不是数据类型默认的零值。对于数字，请确保值不为零。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为nil。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: required
</code></pre></td></tr></table>
</div>
</div><h3 id="required-with">Required With<a hidden class="anchor" aria-hidden="true" href="#required-with">#</a></h3>
<p>仅当存在任何其他指定的字段时，验证下的字段必须存在且不能为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为零。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: required_with
</code></pre></td></tr></table>
</div>
</div><p>Examples:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// require the field if the Field1 is present:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">required_with</span><span class="p">=</span><span class="nx">Field1</span>

<span class="c1">// require the field if the Field1 or Field2 is present:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">required_with</span><span class="p">=</span><span class="nx">Field1</span> <span class="nx">Field2</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="required-with-all">Required With All<a hidden class="anchor" aria-hidden="true" href="#required-with-all">#</a></h3>
<p>仅当所有其他指定的字段都存在时，验证中的字段必须存在且不为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为nil。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: required_with_all
</code></pre></td></tr></table>
</div>
</div><p>Example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// require the field if the Field1 and Field2 is present:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">required_with_all</span><span class="p">=</span><span class="nx">Field1</span> <span class="nx">Field2</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="required-without">Required Without<a hidden class="anchor" aria-hidden="true" href="#required-without">#</a></h3>
<p>仅当不存在任何其他指定字段时，验证下的字段必须存在且不为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为nil.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: required_without
</code></pre></td></tr></table>
</div>
</div><p>Examples:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// require the field if the Field1 is not present:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">required_without</span><span class="p">=</span><span class="nx">Field1</span>

<span class="c1">// require the field if the Field1 or Field2 is not present:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">required_without</span><span class="p">=</span><span class="nx">Field1</span> <span class="nx">Field2</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="required-without-all">Required Without All<a hidden class="anchor" aria-hidden="true" href="#required-without-all">#</a></h3>
<p>仅当所有其他指定字段都不存在时，验证中的字段必须存在且不为空。对于字符串，请确保值不是“”。对于切片，映射，指针，接口，通道和函数，请确保该值不为零。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: required_without_all
</code></pre></td></tr></table>
</div>
</div><p>Example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// require the field if the Field1 and Field2 is not present:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">required_without_all</span><span class="p">=</span><span class="nx">Field1</span> <span class="nx">Field2</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="is-default">Is Default<a hidden class="anchor" aria-hidden="true" href="#is-default">#</a></h3>
<p>这可以验证该值是默认值，并且几乎与Required相反。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: isdefault
</code></pre></td></tr></table>
</div>
</div><h3 id="length">Length<a hidden class="anchor" aria-hidden="true" href="#length">#</a></h3>
<p>For numbers, length will ensure that the value is equal to the parameter given. For strings, it checks that the string length is exactly that number of characters. For slices, arrays, and maps, validates the number of items.</p>
<p>对于数字，长度将确保该值等于给定的参数。对于字符串，它将检查字符串长度是否恰好等于该字符数。对于切片，数组和map，验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: len=10
</code></pre></td></tr></table>
</div>
</div><h3 id="maximum">Maximum<a hidden class="anchor" aria-hidden="true" href="#maximum">#</a></h3>
<p>对于数字，max将确保该值小于或等于给定的参数。对于字符串，它将检查字符串长度是否最多为该字符数。对于切片，数组和地图，验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: max=10
</code></pre></td></tr></table>
</div>
</div><h3 id="minimum">Minimum<a hidden class="anchor" aria-hidden="true" href="#minimum">#</a></h3>
<p>对于数字，max将确保该值小于或等于给定的参数。对于字符串，它将检查字符串长度是否最多为该字符数。对于切片，数组和地图，验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: min=10
</code></pre></td></tr></table>
</div>
</div><h3 id="equals">Equals<a hidden class="anchor" aria-hidden="true" href="#equals">#</a></h3>
<p>对于字符串和数字，eq将确保该值等于给定的参数。对于切片，数组和地图，验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: eq=10
</code></pre></td></tr></table>
</div>
</div><h3 id="not-equal">Not Equal<a hidden class="anchor" aria-hidden="true" href="#not-equal">#</a></h3>
<p>对于字符串和数字，ne将确保该值不等于给定的参数。对于切片，数组和地图，验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ne=10
</code></pre></td></tr></table>
</div>
</div><h3 id="one-of">One Of<a hidden class="anchor" aria-hidden="true" href="#one-of">#</a></h3>
<p>对于字符串，整数和整数，oneof将确保该值是参数中的值之一。该参数应该是由空格分隔的值列表。值可以是字符串或数字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: oneof=red green
       oneof=5 7 9
</code></pre></td></tr></table>
</div>
</div><h3 id="greater-than">Greater Than<a hidden class="anchor" aria-hidden="true" href="#greater-than">#</a></h3>
<p>对于数字，这将确保该值大于给定的参数。对于字符串，它检查字符串长度是否大于该字符数。对于切片，数组和映射，它会验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: gt
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span>

<span class="nx">Usage</span><span class="p">:</span> <span class="nx">gt</span><span class="p">=</span><span class="mi">10</span>

<span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span> <span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>

<span class="nx">For</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="nx">ensures</span> <span class="nx">the</span> <span class="nx">time</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">greater</span> <span class="nx">than</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">.</span><span class="nf">UTC</span><span class="p">().</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="greater-than-or-equal">Greater Than or Equal<a hidden class="anchor" aria-hidden="true" href="#greater-than-or-equal">#</a></h3>
<p>Same as &lsquo;min&rsquo; above. Kept both to make terminology with &lsquo;len&rsquo; easier.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: gt
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span>

<span class="nx">Usage</span><span class="p">:</span> <span class="nx">gte</span><span class="p">=</span><span class="mi">10</span>

<span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span> <span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>

<span class="nx">For</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="nx">ensures</span> <span class="nx">the</span> <span class="nx">time</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">greater</span> <span class="nx">than</span> <span class="nx">or</span> <span class="nx">equal</span> <span class="nx">to</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">.</span><span class="nf">UTC</span><span class="p">().</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="less-than">Less Than<a hidden class="anchor" aria-hidden="true" href="#less-than">#</a></h3>
<p>对于数字，这将确保该值小于给定的参数。对于字符串，它检查字符串长度是否小于该字符数。对于切片，数组和映射，它会验证项目数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: lt
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span>

<span class="nx">Usage</span><span class="p">:</span> <span class="nx">lt</span><span class="p">=</span><span class="mi">10</span>
<span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span> <span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">For</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="nx">ensures</span> <span class="nx">the</span> <span class="nx">time</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">less</span> <span class="nx">than</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">.</span><span class="nf">UTC</span><span class="p">().</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="less-than-or-equal">Less Than or Equal<a hidden class="anchor" aria-hidden="true" href="#less-than-or-equal">#</a></h3>
<p>与上面的“最大”相同。两者都保留以使用“ len”表示的术语更容易。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span>

<span class="nx">Usage</span><span class="p">:</span> <span class="nx">lte</span><span class="p">=</span><span class="mi">10</span>
<span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span> <span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>

<span class="nx">For</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="nx">ensures</span> <span class="nx">the</span> <span class="nx">time</span> <span class="nx">value</span> <span class="nx">is</span> <span class="nx">less</span> <span class="nx">than</span> <span class="nx">or</span> <span class="nx">equal</span> <span class="nx">to</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">.</span><span class="nf">UTC</span><span class="p">().</span>

<span class="nx">Usage</span><span class="p">:</span> <span class="nx">lte</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="field-equals-another-field">Field Equals Another Field<a hidden class="anchor" aria-hidden="true" href="#field-equals-another-field">#</a></h3>
<p>这将针对结构中或传入字段中的另一个字段值来验证该字段值。</p>
<p>Example #1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Validation on Password field using:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">eqfield</span><span class="p">=</span><span class="nx">ConfirmPassword</span>
</code></pre></td></tr></table>
</div>
</div><p>Example #2:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Validating by field:
</span><span class="c1"></span><span class="nx">validate</span><span class="p">.</span><span class="nf">VarWithValue</span><span class="p">(</span><span class="nx">password</span><span class="p">,</span> <span class="nx">confirmpassword</span><span class="p">,</span> <span class="s">&#34;eqfield&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="field-equals-another-field-relative">Field Equals Another Field (relative)<a hidden class="anchor" aria-hidden="true" href="#field-equals-another-field-relative">#</a></h3>
<p>这与nefield相同，除了它会验证相对于顶层结构提供的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: eqcsfield=InnerStructField.Field)
</code></pre></td></tr></table>
</div>
</div><h3 id="field-does-not-equal-another-field">Field Does Not Equal Another Field<a hidden class="anchor" aria-hidden="true" href="#field-does-not-equal-another-field">#</a></h3>
<p>这将针对结构中或传入字段中的另一个字段值来验证该字段值。</p>
<p>Examples:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Confirm two colors are not the same:
</span><span class="c1">//
</span><span class="c1">// Validation on Color field:
</span><span class="c1"></span><span class="nx">Usage</span><span class="p">:</span> <span class="nx">nefield</span><span class="p">=</span><span class="nx">Color2</span>

<span class="c1">// Validating by field:
</span><span class="c1"></span><span class="nx">validate</span><span class="p">.</span><span class="nf">VarWithValue</span><span class="p">(</span><span class="nx">color1</span><span class="p">,</span> <span class="nx">color2</span><span class="p">,</span> <span class="s">&#34;nefield&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="field-does-not-equal-another-field-relative">Field Does Not Equal Another Field (relative)<a hidden class="anchor" aria-hidden="true" href="#field-does-not-equal-another-field-relative">#</a></h3>
<p>这与nefield相同，除了它会验证相对于顶层结构提供的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: necsfield=InnerStructField.Field
</code></pre></td></tr></table>
</div>
</div><h3 id="field-greater-than-another-field">Field Greater Than Another Field<a hidden class="anchor" aria-hidden="true" href="#field-greater-than-another-field">#</a></h3>
<p>仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Example</span> <span class="err">#</span><span class="mi">1</span><span class="p">:</span>

<span class="c1">// Validation on End field using:
</span><span class="c1"></span><span class="nx">validate</span><span class="p">.</span><span class="nx">Struct</span> <span class="nf">Usage</span><span class="p">(</span><span class="nx">gtfield</span><span class="p">=</span><span class="nx">Start</span><span class="p">)</span>
<span class="nx">Example</span> <span class="err">#</span><span class="mi">2</span><span class="p">:</span>

<span class="c1">// Validating by field:
</span><span class="c1"></span><span class="nx">validate</span><span class="p">.</span><span class="nf">VarWithValue</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="s">&#34;gtfield&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="field-greater-than-another-relative-field">Field Greater Than Another Relative Field<a hidden class="anchor" aria-hidden="true" href="#field-greater-than-another-relative-field">#</a></h3>
<p>这与gtfield相同，除了它会验证相对于顶层结构提供的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Usage</span><span class="p">:</span> <span class="nx">gtcsfield</span><span class="p">=</span><span class="nx">InnerStructField</span><span class="p">.</span><span class="nx">Field</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="field-greater-than-or-equal-to-another-field">Field Greater Than or Equal To Another Field<a hidden class="anchor" aria-hidden="true" href="#field-greater-than-or-equal-to-another-field">#</a></h3>
<p>仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Example #1:

// Validation on End field using:
validate.Struct Usage(gtefield=Start)
Example #2:

// Validating by field:
validate.VarWithValue(start, end, &#34;gtefield&#34;)
</code></pre></td></tr></table>
</div>
</div><h3 id="field-greater-than-or-equal-to-another-relative-field">Field Greater Than or Equal To Another Relative Field<a hidden class="anchor" aria-hidden="true" href="#field-greater-than-or-equal-to-another-relative-field">#</a></h3>
<p>这与gtefield相同，除了它会验证相对于顶层结构提供的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: gtecsfield=InnerStructField.Field
</code></pre></td></tr></table>
</div>
</div><h3 id="less-than-another-field">Less Than Another Field<a hidden class="anchor" aria-hidden="true" href="#less-than-another-field">#</a></h3>
<p>仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Example #1:

// Validation on End field using:
validate.Struct Usage(ltfield=Start)
Example #2:

// Validating by field:
validate.VarWithValue(start, end, &#34;ltfield&#34;)
</code></pre></td></tr></table>
</div>
</div><h3 id="less-than-another-relative-field">Less Than Another Relative Field<a hidden class="anchor" aria-hidden="true" href="#less-than-another-relative-field">#</a></h3>
<p>这与ltfield相同，除了它会验证相对于顶层结构提供的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ltcsfield=InnerStructField.Field
</code></pre></td></tr></table>
</div>
</div><h3 id="less-than-or-equal-to-another-field">Less Than or Equal To Another Field<a hidden class="anchor" aria-hidden="true" href="#less-than-or-equal-to-another-field">#</a></h3>
<p>仅对Numbers和time.Time类型有效，这将针对结构中或传入字段中的另一个字段值验证该字段值。使用示例用于验证开始日期和结束日期：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Example #1:

// Validation on End field using:
validate.Struct Usage(ltefield=Start)
Example #2:

// Validating by field:
validate.VarWithValue(start, end, &#34;ltefield&#34;)
</code></pre></td></tr></table>
</div>
</div><h3 id="less-than-or-equal-to-another-relative-field">Less Than or Equal To Another Relative Field<a hidden class="anchor" aria-hidden="true" href="#less-than-or-equal-to-another-relative-field">#</a></h3>
<p>这与ltefield相同，除了它会验证相对于顶层结构提供的字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ltecsfield=InnerStructField.Field
</code></pre></td></tr></table>
</div>
</div><h3 id="field-contains-another-field">Field Contains Another Field<a hidden class="anchor" aria-hidden="true" href="#field-contains-another-field">#</a></h3>
<p>除结构字段外，此功能与contains相同。它只能与字符串类型一起使用。有关其他类型的行为，请参见reflect.Value.String（）的行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: containsfield=InnerStructField.Field
</code></pre></td></tr></table>
</div>
</div><h3 id="field-excludes-another-field">Field Excludes Another Field<a hidden class="anchor" aria-hidden="true" href="#field-excludes-another-field">#</a></h3>
<p>除了结构字段外，这与exclude相同。它只能与字符串类型一起使用。有关其他类型的行为，请参见reflect.Value.String（）的行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: excludesfield=InnerStructField.Field
</code></pre></td></tr></table>
</div>
</div><h3 id="unique">Unique<a hidden class="anchor" aria-hidden="true" href="#unique">#</a></h3>
<p>对于数组和切片，Unique将确保没有重复。对于map，Unique将确保没有重复的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: unique
</code></pre></td></tr></table>
</div>
</div><h3 id="alpha-only">Alpha Only<a hidden class="anchor" aria-hidden="true" href="#alpha-only">#</a></h3>
<p>这可以验证字符串值仅包含ASCII字母字符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: alpha
</code></pre></td></tr></table>
</div>
</div><h3 id="alphanumeric">Alphanumeric<a hidden class="anchor" aria-hidden="true" href="#alphanumeric">#</a></h3>
<p>这可以验证字符串值仅包含ASCII字母数字字符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: alphanum
</code></pre></td></tr></table>
</div>
</div><h3 id="alpha-unicode">Alpha Unicode<a hidden class="anchor" aria-hidden="true" href="#alpha-unicode">#</a></h3>
<p>这可以验证字符串值仅包含Unicode字母字符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: alphaunicode
</code></pre></td></tr></table>
</div>
</div><h3 id="alphanumeric-unicode">Alphanumeric Unicode<a hidden class="anchor" aria-hidden="true" href="#alphanumeric-unicode">#</a></h3>
<p>这可以验证字符串值仅包含Unicode字母数字字符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: alphanumunicode
</code></pre></td></tr></table>
</div>
</div><h3 id="numeric">Numeric<a hidden class="anchor" aria-hidden="true" href="#numeric">#</a></h3>
<p>这验证了字符串值包含基本数字值。基本不包括指数等&hellip;对于整数或浮点数，它返回true。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: numeric
</code></pre></td></tr></table>
</div>
</div><h3 id="hexadecimal-string">Hexadecimal String<a hidden class="anchor" aria-hidden="true" href="#hexadecimal-string">#</a></h3>
<p>这可以验证字符串值包含有效的十六进制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: hexadecimal
</code></pre></td></tr></table>
</div>
</div><h3 id="hexcolor-string">Hexcolor String<a hidden class="anchor" aria-hidden="true" href="#hexcolor-string">#</a></h3>
<p>这可以验证字符串值包含有效的十六进制颜色（包括井号（＃））</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: hexcolor
</code></pre></td></tr></table>
</div>
</div><h3 id="rgb-string">RGB String<a hidden class="anchor" aria-hidden="true" href="#rgb-string">#</a></h3>
<p>这可以验证字符串值包含有效的rgb颜色</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: rgb
</code></pre></td></tr></table>
</div>
</div><h3 id="rgba-string">RGBA String<a hidden class="anchor" aria-hidden="true" href="#rgba-string">#</a></h3>
<p>这可以验证字符串值包含有效的rgba颜色</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: rgba
</code></pre></td></tr></table>
</div>
</div><h3 id="hsl-string">HSL String<a hidden class="anchor" aria-hidden="true" href="#hsl-string">#</a></h3>
<p>这可以验证字符串值包含有效的hsl颜色</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: hsl
</code></pre></td></tr></table>
</div>
</div><h3 id="hsla-string">HSLA String<a hidden class="anchor" aria-hidden="true" href="#hsla-string">#</a></h3>
<p>这可以验证字符串值包含有效的hsla颜色</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: hsla
</code></pre></td></tr></table>
</div>
</div><h3 id="e-mail-string">E-mail String<a hidden class="anchor" aria-hidden="true" href="#e-mail-string">#</a></h3>
<p>这可以验证字符串值包含有效的电子邮件。这可能不符合任何RFC标准的所有可能性，但是任何电子邮件提供商都不接受所有可能性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: email
</code></pre></td></tr></table>
</div>
</div><h3 id="file-path">File path<a hidden class="anchor" aria-hidden="true" href="#file-path">#</a></h3>
<p>这将验证字符串值包含有效的文件路径以及该文件在计算机上是否存在。这是使用os.Stat完成的，它是一个与平台无关的功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: file
</code></pre></td></tr></table>
</div>
</div><h3 id="url-string">URL String<a hidden class="anchor" aria-hidden="true" href="#url-string">#</a></h3>
<p>这将验证字符串值是否包含有效的网址。该网址将接受uri接受的golang请求的任何网址，但必须包含scheme，例如http：//或rtmp：//</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: url
</code></pre></td></tr></table>
</div>
</div><h3 id="uri-string">URI String<a hidden class="anchor" aria-hidden="true" href="#uri-string">#</a></h3>
<p>这将验证字符串值包含有效的uri。它将接受golang请求uri接受的任何uri</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: uri
</code></pre></td></tr></table>
</div>
</div><h3 id="urn-rfc-2141-string">Urn RFC 2141 String<a hidden class="anchor" aria-hidden="true" href="#urn-rfc-2141-string">#</a></h3>
<p>这验证了根据RFC 2141规范，字符串值包含有效的URN 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: urn_rfc2141
</code></pre></td></tr></table>
</div>
</div><h3 id="base64-string">Base64 String<a hidden class="anchor" aria-hidden="true" href="#base64-string">#</a></h3>
<p>这将验证字符串值包含有效的base64值。尽管空字符串是有效的base64，但这将报告一个空字符串作为错误，但是，如果您希望接受一个空字符串，则可以将其与omitempty标记一起使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: base64
</code></pre></td></tr></table>
</div>
</div><h3 id="base64url-string">Base64URL String<a hidden class="anchor" aria-hidden="true" href="#base64url-string">#</a></h3>
<p>这将验证字符串值是否包含符合RFC4648规范的有效base64 URL安全值。尽管空字符串是有效的base64 URL安全值，但这将报告一个空字符串作为错误，如果您希望接受一个空字符串为有效字符串，则可以将其与omitempty标记一起使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: base64url
</code></pre></td></tr></table>
</div>
</div><h3 id="bitcoin-address">Bitcoin Address<a hidden class="anchor" aria-hidden="true" href="#bitcoin-address">#</a></h3>
<p>这可以验证字符串值包含有效的比特币地址。检查字符串的格式以确保它与三种格式P2PKH，P2SH之一匹配并执行校验和验证。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: btc_addr
</code></pre></td></tr></table>
</div>
</div><p>比特币Bech32地址（隔离见证）</p>
<p>这可以验证字符串值包含由bip-0173（https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki） 定义的有效比特币Bech32地址。特别感谢Pieter Wuille提供了参考实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: btc_addr_bech32
</code></pre></td></tr></table>
</div>
</div><h3 id="ethereum-address">Ethereum Address<a hidden class="anchor" aria-hidden="true" href="#ethereum-address">#</a></h3>
<p>这可以验证字符串值包含有效的以太坊地址。检查字符串的格式以确保它与标准的以太坊地址格式匹配完全验证被https://github.com/golang/crypto/pull/28阻止</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: eth_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="contains">Contains<a hidden class="anchor" aria-hidden="true" href="#contains">#</a></h3>
<p>这验证了字符串值包含子字符串值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: contains=@
</code></pre></td></tr></table>
</div>
</div><h3 id="contains-any">Contains Any<a hidden class="anchor" aria-hidden="true" href="#contains-any">#</a></h3>
<p>这可以验证字符串值在子字符串值中是否包含任何Unicode代码点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: containsany=!@#?
</code></pre></td></tr></table>
</div>
</div><h3 id="contains-rune">Contains Rune<a hidden class="anchor" aria-hidden="true" href="#contains-rune">#</a></h3>
<p>这将验证字符串值包含提供的Rune值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: containsrune=@
</code></pre></td></tr></table>
</div>
</div><h3 id="excludes">Excludes<a hidden class="anchor" aria-hidden="true" href="#excludes">#</a></h3>
<p>这验证了字符串值不包含子字符串值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: excludes=@
</code></pre></td></tr></table>
</div>
</div><h3 id="excludes-all">Excludes All<a hidden class="anchor" aria-hidden="true" href="#excludes-all">#</a></h3>
<p>这可以验证字符串值在子字符串值中不包含任何Unicode代码点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: excludesall=!@#?
</code></pre></td></tr></table>
</div>
</div><h3 id="excludes-rune">Excludes Rune<a hidden class="anchor" aria-hidden="true" href="#excludes-rune">#</a></h3>
<p>这可以验证字符串值不包含提供的Rune值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: excludesrune=@
</code></pre></td></tr></table>
</div>
</div><h3 id="starts-with">Starts With<a hidden class="anchor" aria-hidden="true" href="#starts-with">#</a></h3>
<p>这将验证字符串值以提供的字符串值开头</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: startswith=hello
</code></pre></td></tr></table>
</div>
</div><h3 id="ends-with">Ends With<a hidden class="anchor" aria-hidden="true" href="#ends-with">#</a></h3>
<p>这可以验证字符串值以提供的字符串值结尾</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: endswith=goodbye
</code></pre></td></tr></table>
</div>
</div><h3 id="international-standard-book-number">International Standard Book Number<a hidden class="anchor" aria-hidden="true" href="#international-standard-book-number">#</a></h3>
<p>这将验证字符串值包含有效的isbn10或isbn13值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: isbn
</code></pre></td></tr></table>
</div>
</div><h3 id="international-standard-book-number-10">International Standard Book Number 10<a hidden class="anchor" aria-hidden="true" href="#international-standard-book-number-10">#</a></h3>
<p>这验证了字符串值包含有效的isbn10值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: isbn10
</code></pre></td></tr></table>
</div>
</div><h3 id="international-standard-book-number-13">International Standard Book Number 13<a hidden class="anchor" aria-hidden="true" href="#international-standard-book-number-13">#</a></h3>
<p>这验证了字符串值包含有效的isbn13值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: isbn13
</code></pre></td></tr></table>
</div>
</div><h3 id="universally-unique-identifier-uuid">Universally Unique Identifier UUID<a hidden class="anchor" aria-hidden="true" href="#universally-unique-identifier-uuid">#</a></h3>
<p>这将验证字符串值包含有效的UUID。大写的UUID值不会通过-改用<code>uuid_rfc4122</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: uuid
</code></pre></td></tr></table>
</div>
</div><h3 id="universally-unique-identifier-uuid-v3">Universally Unique Identifier UUID v3<a hidden class="anchor" aria-hidden="true" href="#universally-unique-identifier-uuid-v3">#</a></h3>
<p>这将验证字符串值包含有效的版本3 UUID。大写的UUID值不会通过-改用<code>uuid3_rfc4122</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: uuid3
</code></pre></td></tr></table>
</div>
</div><h3 id="universally-unique-identifier-uuid-v4">Universally Unique Identifier UUID v4<a hidden class="anchor" aria-hidden="true" href="#universally-unique-identifier-uuid-v4">#</a></h3>
<p>这将验证字符串值包含有效的版本4 UUID。大写的UUID值不会通过-改用<code>uuid4_rfc4122</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: uuid4
</code></pre></td></tr></table>
</div>
</div><h3 id="universally-unique-identifier-uuid-v5">Universally Unique Identifier UUID v5<a hidden class="anchor" aria-hidden="true" href="#universally-unique-identifier-uuid-v5">#</a></h3>
<p>这将验证字符串值包含有效的版本5 UUID。大写的UUID值不会通过-改用<code>uuid5_rfc4122</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: uuid5
</code></pre></td></tr></table>
</div>
</div><h3 id="ascii">ASCII<a hidden class="anchor" aria-hidden="true" href="#ascii">#</a></h3>
<p>这可以验证字符串值仅包含ASCII字符。注意：如果字符串为空，则验证为true。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ascii
</code></pre></td></tr></table>
</div>
</div><h3 id="printable-ascii">Printable ASCII<a hidden class="anchor" aria-hidden="true" href="#printable-ascii">#</a></h3>
<p>这可以验证字符串值仅包含可打印的ASCII字符。注意：如果字符串为空，则验证为true。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: printascii
</code></pre></td></tr></table>
</div>
</div><h3 id="multi-byte-characters">Multi-Byte Characters<a hidden class="anchor" aria-hidden="true" href="#multi-byte-characters">#</a></h3>
<p>这验证了字符串值包含一个或多个多字节字符。注意：如果字符串为空，则验证为true。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: multibyte
</code></pre></td></tr></table>
</div>
</div><h3 id="data-url">Data URL<a hidden class="anchor" aria-hidden="true" href="#data-url">#</a></h3>
<p>这将验证字符串值包含有效的DataURI。注意：这还将验证数据部分是有效的base64</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: datauri
</code></pre></td></tr></table>
</div>
</div><h3 id="latitude">Latitude<a hidden class="anchor" aria-hidden="true" href="#latitude">#</a></h3>
<p>这验证了字符串值包含有效的纬度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: latitude
</code></pre></td></tr></table>
</div>
</div><h3 id="longitude">Longitude<a hidden class="anchor" aria-hidden="true" href="#longitude">#</a></h3>
<p>这可以验证字符串值包含有效的经度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: longitude
</code></pre></td></tr></table>
</div>
</div><h3 id="social-security-number-ssn">Social Security Number SSN<a hidden class="anchor" aria-hidden="true" href="#social-security-number-ssn">#</a></h3>
<p>这将验证字符串值包含有效的美国社会安全号码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ssn
</code></pre></td></tr></table>
</div>
</div><h3 id="internet-protocol-address-ip">Internet Protocol Address IP<a hidden class="anchor" aria-hidden="true" href="#internet-protocol-address-ip">#</a></h3>
<p>这可以验证字符串值包含有效的IP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ip
</code></pre></td></tr></table>
</div>
</div><h3 id="internet-protocol-address-ipv4">Internet Protocol Address IPv4<a hidden class="anchor" aria-hidden="true" href="#internet-protocol-address-ipv4">#</a></h3>
<p>这将验证字符串值包含有效的v4 IP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ipv4
</code></pre></td></tr></table>
</div>
</div><h3 id="internet-protocol-address-ipv6">Internet Protocol Address IPv6<a hidden class="anchor" aria-hidden="true" href="#internet-protocol-address-ipv6">#</a></h3>
<p>这将验证字符串值包含有效的v6 IP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ipv6
</code></pre></td></tr></table>
</div>
</div><h3 id="classless-inter-domain-routing-cidr">Classless Inter-Domain Routing CIDR<a hidden class="anchor" aria-hidden="true" href="#classless-inter-domain-routing-cidr">#</a></h3>
<p>这将验证字符串值包含有效的CIDR地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: cidr
</code></pre></td></tr></table>
</div>
</div><h3 id="classless-inter-domain-routing-cidrv4">Classless Inter-Domain Routing CIDRv4<a hidden class="anchor" aria-hidden="true" href="#classless-inter-domain-routing-cidrv4">#</a></h3>
<p>这将验证字符串值包含有效的v4 CIDR地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: cidrv4
</code></pre></td></tr></table>
</div>
</div><h3 id="classless-inter-domain-routing-cidrv6">Classless Inter-Domain Routing CIDRv6<a hidden class="anchor" aria-hidden="true" href="#classless-inter-domain-routing-cidrv6">#</a></h3>
<p>这将验证字符串值包含有效的v6 CIDR地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: cidrv6
</code></pre></td></tr></table>
</div>
</div><h3 id="transmission-control-protocol-address-tcp">Transmission Control Protocol Address TCP<a hidden class="anchor" aria-hidden="true" href="#transmission-control-protocol-address-tcp">#</a></h3>
<p>这可以验证字符串值包含有效的可解析TCP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: tcp_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="transmission-control-protocol-address-tcpv4">Transmission Control Protocol Address TCPv4<a hidden class="anchor" aria-hidden="true" href="#transmission-control-protocol-address-tcpv4">#</a></h3>
<p>这将验证字符串值包含有效的可解析v4 TCP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: tcp4_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="transmission-control-protocol-address-tcpv6">Transmission Control Protocol Address TCPv6<a hidden class="anchor" aria-hidden="true" href="#transmission-control-protocol-address-tcpv6">#</a></h3>
<p>这将验证字符串值包含有效的可解析v6 TCP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: tcp6_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="user-datagram-protocol-address-udp">User Datagram Protocol Address UDP<a hidden class="anchor" aria-hidden="true" href="#user-datagram-protocol-address-udp">#</a></h3>
<p>这将验证字符串值包含有效的可解析UDP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: udp_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="user-datagram-protocol-address-udpv4">User Datagram Protocol Address UDPv4<a hidden class="anchor" aria-hidden="true" href="#user-datagram-protocol-address-udpv4">#</a></h3>
<p>这将验证字符串值包含有效的可解析v4 UDP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: udp4_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="user-datagram-protocol-address-udpv6">User Datagram Protocol Address UDPv6<a hidden class="anchor" aria-hidden="true" href="#user-datagram-protocol-address-udpv6">#</a></h3>
<p>这将验证字符串值包含有效的可解析v6 UDP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: udp6_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="internet-protocol-address-ip-1">Internet Protocol Address IP<a hidden class="anchor" aria-hidden="true" href="#internet-protocol-address-ip-1">#</a></h3>
<p>这可以验证字符串值包含有效的可解析IP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ip_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="internet-protocol-address-ipv4-1">Internet Protocol Address IPv4<a hidden class="anchor" aria-hidden="true" href="#internet-protocol-address-ipv4-1">#</a></h3>
<p>这将验证字符串值包含有效的可解析v4 IP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ip4_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="internet-protocol-address-ipv6-1">Internet Protocol Address IPv6<a hidden class="anchor" aria-hidden="true" href="#internet-protocol-address-ipv6-1">#</a></h3>
<p>这将验证字符串值包含有效的可解析v6 IP地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: ip6_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="unix-domain-socket-end-point-address">Unix domain socket end point Address<a hidden class="anchor" aria-hidden="true" href="#unix-domain-socket-end-point-address">#</a></h3>
<p>这将验证字符串值包含有效的Unix地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: unix_addr
</code></pre></td></tr></table>
</div>
</div><h3 id="media-access-control-address-mac">Media Access Control Address MAC<a hidden class="anchor" aria-hidden="true" href="#media-access-control-address-mac">#</a></h3>
<p>这可以验证字符串值包含有效的MAC地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: mac
</code></pre></td></tr></table>
</div>
</div><p>注意：有关可接受的格式和类型，请参见Go&rsquo;s ParseMAC：</p>
<p><a href="http://golang.org/src/net/mac.go?s=866:918#L29">http://golang.org/src/net/mac.go?s=866:918#L29</a></p>
<h3 id="hostname-rfc-952">Hostname RFC 952<a hidden class="anchor" aria-hidden="true" href="#hostname-rfc-952">#</a></h3>
<p>这将根据RFC 952 <a href="https://tools.ietf.org/html/rfc952">https://tools.ietf.org/html/rfc952</a> 验证字符串值是有效的主机名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: hostname
</code></pre></td></tr></table>
</div>
</div><h3 id="hostname-rfc-1123">Hostname RFC 1123<a hidden class="anchor" aria-hidden="true" href="#hostname-rfc-1123">#</a></h3>
<p>这会根据RFC 1123 <a href="https://tools.ietf.org/html/rfc1123">https://tools.ietf.org/html/rfc1123</a> 验证字符串值是有效的主机名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: hostname_rfc1123 or if you want to continue to use &#39;hostname&#39; in your tags, create an alias.
</code></pre></td></tr></table>
</div>
</div><h3 id="full-qualified-domain-name-fqdn">Full Qualified Domain Name (FQDN)<a hidden class="anchor" aria-hidden="true" href="#full-qualified-domain-name-fqdn">#</a></h3>
<p>这将验证字符串值包含有效的FQDN。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: fqdn
</code></pre></td></tr></table>
</div>
</div><h3 id="html-tags">HTML Tags<a hidden class="anchor" aria-hidden="true" href="#html-tags">#</a></h3>
<p>这可以验证字符串值似乎是HTML元素标签，包括https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element中描述的那些</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: html
</code></pre></td></tr></table>
</div>
</div><h3 id="html-encoded">HTML Encoded<a hidden class="anchor" aria-hidden="true" href="#html-encoded">#</a></h3>
<p>这可以验证字符串值是十进制或十六进制格式的正确字符引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: html_encoded
</code></pre></td></tr></table>
</div>
</div><h3 id="url-encoded">URL Encoded<a hidden class="anchor" aria-hidden="true" href="#url-encoded">#</a></h3>
<p>这验证了根据 <a href="https://tools.ietf.org/html/rfc3986#section-2.1">https://tools.ietf.org/html/rfc3986#section-2.1</a> 对字符串值进行百分比编码（URL编码）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: url_encoded
</code></pre></td></tr></table>
</div>
</div><h3 id="directory">Directory<a hidden class="anchor" aria-hidden="true" href="#directory">#</a></h3>
<p>这将验证字符串值包含有效目录，并且该目录存在于计算机上。这是使用os.Stat完成的，它是一个与平台无关的功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Usage: dir
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a></li>
      <li><a href="/tags/validator/">validator</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
