<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的同步原语源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="Mutex Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 1 2 3 4 type Mutex struct { state int32 sema uint32 } 状态 互斥锁的状态比较复" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的同步原语源码剖析" />
<meta property="og:description" content="Mutex Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 1 2 3 4 type Mutex struct { state int32 sema uint32 } 状态 互斥锁的状态比较复" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-14T15:58:21&#43;00:00" />
<meta property="article:modified_time" content="2021-01-14T15:58:21&#43;00:00" />

<meta itemprop="name" content="Go的同步原语源码剖析">
<meta itemprop="description" content="Mutex Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 1 2 3 4 type Mutex struct { state int32 sema uint32 } 状态 互斥锁的状态比较复"><meta itemprop="datePublished" content="2021-01-14T15:58:21&#43;00:00" />
<meta itemprop="dateModified" content="2021-01-14T15:58:21&#43;00:00" />
<meta itemprop="wordCount" content="54429">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的同步原语源码剖析"/>
<meta name="twitter:description" content="Mutex Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。 1 2 3 4 type Mutex struct { state int32 sema uint32 } 状态 互斥锁的状态比较复"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的同步原语源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-01-14 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 54429 字 </span>
          <span class="more-meta"> 预计阅读 109 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#mutex">Mutex</a>
      <ul>
        <li><a href="#状态">状态</a></li>
        <li><a href="#正常模式和饥饿模式">正常模式和饥饿模式</a></li>
        <li><a href="#实现原理">实现原理</a></li>
        <li><a href="#lock">Lock</a></li>
        <li><a href="#自旋">自旋</a></li>
        <li><a href="#unlock">Unlock</a></li>
      </ul>
    </li>
    <li><a href="#rwmutex">RWMutex</a>
      <ul>
        <li><a href="#rlock">RLock</a></li>
        <li><a href="#runlock">RUnlock</a></li>
        <li><a href="#lock-1">Lock</a></li>
        <li><a href="#unlock-1">Unlock</a></li>
      </ul>
    </li>
    <li><a href="#waitgroup">WaitGroup</a>
      <ul>
        <li><a href="#adddone">Add&amp;Done</a></li>
        <li><a href="#wait">Wait</a></li>
        <li><a href="#整体流程">整体流程</a></li>
        <li><a href="#nocopy">noCopy</a></li>
      </ul>
    </li>
    <li><a href="#cond">Cond</a>
      <ul>
        <li><a href="#copychecker">copyChecker</a></li>
        <li><a href="#notifylist">notifyList</a></li>
      </ul>
    </li>
    <li><a href="#once">Once</a></li>
    <li><a href="#map">Map</a>
      <ul>
        <li><a href="#map-1">Map</a></li>
        <li><a href="#read和dirty">read和dirty</a></li>
        <li><a href="#entry">entry</a></li>
        <li><a href="#流程图">流程图</a></li>
        <li><a href="#load">Load</a></li>
        <li><a href="#store">Store</a></li>
        <li><a href="#delete">Delete</a></li>
        <li><a href="#loadorstore">LoadOrStore</a></li>
        <li><a href="#range">Range</a></li>
        <li><a href="#补全len">补全Len</a></li>
        <li><a href="#小结-1">小结</a></li>
        <li><a href="#syncmap的适用场景">sync.Map的适用场景</a></li>
        <li><a href="#警告不要拷贝syncmap">警告:不要拷贝sync.Map</a></li>
      </ul>
    </li>
    <li><a href="#pool">Pool</a>
      <ul>
        <li><a href="#pool-1">Pool</a></li>
        <li><a href="#poolchain">PoolChain</a></li>
        <li><a href="#pooldequeue">poolDequeue</a></li>
        <li><a href="#get">Get</a></li>
        <li><a href="#put">Put</a></li>
        <li><a href="#runtime_procunpin--runtime_procpin">runtime_procUnpin &amp; runtime_procPin</a></li>
        <li><a href="#poolcleanup">PoolCleanup</a></li>
        <li><a href="#小结-2">小结</a></li>
      </ul>
    </li>
    <li><a href="#context">Context</a>
      <ul>
        <li><a href="#emptyctx">emptyCtx</a></li>
        <li><a href="#cancelctx">cancelCtx</a></li>
        <li><a href="#timerctx">timerCtx</a></li>
        <li><a href="#valuectx">valueCtx</a></li>
      </ul>
    </li>
    <li><a href="#atomic">atomic</a>
      <ul>
        <li><a href="#原理">原理</a></li>
        <li><a href="#原子操作">原子操作</a></li>
        <li><a href="#原子值">原子值</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="mutex">Mutex</h2>
<p>Go 语言的 sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">state</span> <span class="kt">int32</span>
	<span class="nx">sema</span>  <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="状态">状态</h3>
<p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210114162303.png" alt=""></p>
<p>在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：</p>
<ul>
<li>mutexLocked — 表示互斥锁的锁定状态；</li>
<li>mutexWoken — 表示从正常模式被从唤醒；</li>
<li>mutexStarving — 当前的互斥锁进入饥饿状态；</li>
<li>waitersCount — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<h3 id="正常模式和饥饿模式">正常模式和饥饿模式</h3>
<p>sync.Mutex 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么以及它们有什么样的关系。</p>
<p>正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要 和新来的 goroutine 进行竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运 行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获 取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫 秒，那么，这个 Mutex 就进入到了饥饿模式。</p>
<p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin，它会乖乖地加 入到等待队列的尾部。</p>
<p>如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p>
<ul>
<li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了;</li>
<li>此 waiter 的等待时间小于 1 毫秒。</li>
</ul>
<p>正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。</p>
<p>饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。</p>
<h3 id="实现原理">实现原理</h3>
<p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 mutexLocked 加锁；</li>
<li>如果互斥锁处于 mutexLocked 状态并且在普通模式下工作，会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 runtime.sync_runtime_SemacquireMutex 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 sync.Mutex.Unlock 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 sync.runtime_Semrelease 唤醒对应的 Goroutine；</li>
</ul>
<h3 id="lock">Lock</h3>
<p>互斥锁的加锁是靠 sync.Mutex.Lock 完成的Lock 对申请锁的情况分为三种：</p>
<ul>
<li>无冲突，通过 CAS 操作把当前状态设置为加锁状态</li>
<li>有冲突，开始自旋，并等待锁释放，如果其他 goroutine 在这段时间内释放该锁，直接获得该锁；如果没有释放则为下一种情况</li>
<li>有冲突，且已经过了自旋阶段，通过调用 semrelease 让 goroutine 进入等待状态</li>
</ul>
<p>最新的 Go 语言源代码中已经将 sync.Mutex.Lock 方法进行了简化，方法的主干只保留最常见、简单的情况 — 当锁的状态是 0 时，将 mutexLocked 位置成 1：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Lock locks m.
</span><span class="c1">// If the lock is already in use, the calling goroutine
</span><span class="c1">// blocks until the mutex is available.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Fast path: grab unlocked mutex.
</span><span class="c1"></span>    <span class="c1">// 快速路径: 抓取并锁上未锁住状态的互斥锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mutexLocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
			<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
    <span class="c1">// Slow path (outlined so that the fast path can be inlined)
</span><span class="c1"></span>    <span class="c1">// 缓慢之路,尝试自旋竞争或饥饿状态下饥饿goroutine竞争
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nf">lockSlow</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果互斥锁的状态不是 0 时就会调用 sync.Mutex.lockSlow 尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p>
<ol>
<li>判断当前 Goroutine 能否进入自旋；</li>
<li>通过自旋等待互斥锁的释放；</li>
<li>计算互斥锁的最新状态；</li>
<li>更新互斥锁的状态并获取锁；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">lockSlow</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">waitStartTime</span> <span class="kt">int64</span>
	<span class="nx">starving</span> <span class="o">:=</span> <span class="kc">false</span> <span class="c1">// 此goroutine的饥饿标记
</span><span class="c1"></span>	<span class="nx">awoke</span> <span class="o">:=</span> <span class="kc">false</span>  <span class="c1">// 唤醒标记
</span><span class="c1"></span>	<span class="nx">iter</span> <span class="o">:=</span> <span class="mi">0</span>   <span class="c1">//自旋次数
</span><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>  <span class="c1">//当前的锁的状态
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// Don&#39;t spin in starvation mode, ownership is handed off to waiters
</span><span class="c1"></span>        <span class="c1">// so we won&#39;t be able to acquire the mutex anyway.
</span><span class="c1"></span>        <span class="c1">// 锁是非饥饿状态,锁还没被释放,尝试自旋
</span><span class="c1"></span>        <span class="c1">// 对正常状态抢夺锁的 goroutine 尝试 spin，在临界区耗时很短的情况提高性能.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="nx">mutexLocked</span> <span class="o">&amp;&amp;</span> <span class="nf">runtime_canSpin</span><span class="p">(</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Active spinning makes sense.
</span><span class="c1"></span>			<span class="c1">// Try to set mutexWoken flag to inform Unlock
</span><span class="c1"></span>			<span class="c1">// to not wake other blocked goroutines.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">awoke</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">old</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="nf">runtime_doSpin</span><span class="p">()</span>
            <span class="nx">iter</span><span class="o">++</span>
            <span class="c1">// 再次获取锁的状态,之后会检查是否锁被释放了
</span><span class="c1"></span>			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span>
        <span class="c1">// Don&#39;t try to acquire starving mutex, new arriving goroutines must queue.
</span><span class="c1"></span>        <span class="c1">//非饥饿状态下抢锁。怎么抢?就是要把 state 的锁的那一位，置为加 锁状态，后续 CAS 如果成功就可能获取到了锁。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexLocked</span>  <span class="c1">// 非饥饿状态,加锁
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">//如果锁已经被持有或者锁处于饥饿状态，我们最好的归宿就是等待， 所以 waiter 的数量加 1。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">mutexWaiterShift</span>    <span class="c1">// waiter数量加1
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// The current goroutine switches mutex to starvation mode.
</span><span class="c1"></span>		<span class="c1">// But if the mutex is currently unlocked, don&#39;t do the switch.
</span><span class="c1"></span>		<span class="c1">// Unlock expects that starving mutex has waiters, which will not
</span><span class="c1"></span>        <span class="c1">// be true in this case.
</span><span class="c1"></span>        <span class="c1">//如果此 goroutine 已经处在饥饿状态，并且锁还被持有，那么，我 们需要把此 Mutex 设置为饥饿状态。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">starving</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexStarving</span>    <span class="c1">// 设置饥饿状态
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">//清除 mutexWoken 标记，因为不管是获得了锁还是进入休眠，我 们都需要清除 mutexWoken 标记。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">awoke</span> <span class="p">{</span>
			<span class="c1">// The goroutine has been woken from sleep,
</span><span class="c1"></span>			<span class="c1">// so we need to reset the flag in either case.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">new</span> <span class="o">&amp;^=</span> <span class="nx">mutexWoken</span>  <span class="c1">// 新状态清除唤醒标记
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// 成功设置新状态
</span><span class="c1"></span>       <span class="c1">// 尝试使用 CAS 设置 state。如果成功，检查原来的锁的 状态是未加锁状态，并且也不是饥饿状态的话就成功获取了锁，返回。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 原来锁的状态已释放,并且不是饥饿状态,正常请求到了锁,返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span> <span class="c1">// locked the mutex with CAS
</span><span class="c1"></span>			<span class="p">}</span>
            <span class="c1">// If we were already waiting before, queue at the front of the queue.
</span><span class="c1"></span>            <span class="c1">// 处理饥饿状态
</span><span class="c1"></span>            <span class="c1">// 如果以前就在队列里面,加入到队列头
</span><span class="c1"></span>            <span class="c1">//判断是否第一次加入到 waiter 队列。
</span><span class="c1"></span>			<span class="nx">queueLifo</span> <span class="o">:=</span> <span class="nx">waitStartTime</span> <span class="o">!=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="nx">waitStartTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">waitStartTime</span> <span class="p">=</span> <span class="nf">runtime_nanotime</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1">// 阻塞等待
</span><span class="c1"></span>            <span class="c1">//将此 waiter 加入到队列，如果是首次，加入到队尾，先进先出。如果不是首次， 那么加入到队首，这样等待最久的 goroutine 优先能够获取到锁。此 goroutine 会进行休眠。
</span><span class="c1"></span>            <span class="c1">//如果没有通过 CAS 获得锁，会调用 runtime.sync_runtime_SemacquireMutex 通过信号量保证资源不会被两个 Goroutine 获取。runtime.sync_runtime_SemacquireMutex 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，sync.Mutex.Lock 的剩余代码也会继续执行
</span><span class="c1"></span>            <span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="nx">queueLifo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1">//判断此 goroutine 是否处于饥饿状态。注意，执行这一句的时候，它已经被唤醒 了。
</span><span class="c1"></span>            <span class="nx">starving</span> <span class="p">=</span> <span class="nx">starving</span> <span class="o">||</span> <span class="nf">runtime_nanotime</span><span class="p">()</span><span class="o">-</span><span class="nx">waitStartTime</span> <span class="p">&gt;</span> <span class="nx">starvationThresholdNs</span>
            <span class="c1">// 唤醒之后检查锁是否应该处于饥饿状态
</span><span class="c1"></span>            <span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
            <span class="c1">// 如果锁已经处于饥饿状态,直接抢到锁,返回
</span><span class="c1"></span>            <span class="c1">//在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// If this goroutine was woken and mutex is in starvation mode,
</span><span class="c1"></span>				<span class="c1">// ownership was handed off to us but mutex is in somewhat
</span><span class="c1"></span>				<span class="c1">// inconsistent state: mutexLocked is not set and we are still
</span><span class="c1"></span>				<span class="c1">// accounted as waiter. Fix that.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="c1">//加锁并且将waiter数减1
</span><span class="c1"></span>                <span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mutexLocked</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span>
                <span class="c1">// 最后一个waiter或者已经不饥饿了,清掉饥饿标记
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">starving</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
					<span class="c1">// Exit starvation mode.
</span><span class="c1"></span>					<span class="c1">// Critical to do it here and consider wait time.
</span><span class="c1"></span>					<span class="c1">// Starvation mode is so inefficient, that two goroutines
</span><span class="c1"></span>					<span class="c1">// can go lock-step infinitely once they switch mutex
</span><span class="c1"></span>                    <span class="c1">// to starvation mode.
</span><span class="c1"></span>					<span class="nx">delta</span> <span class="o">-=</span> <span class="nx">mutexStarving</span>
				<span class="p">}</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">delta</span><span class="p">)</span>
				<span class="k">break</span>
            <span class="p">}</span>
            <span class="c1">//在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；
</span><span class="c1"></span>			<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">iter</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="自旋">自旋</h3>
<p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li>runtime.sync_runtime_canSpin 需要返回 true：
<ol>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ol>
</li>
</ol>
<p>一旦当前 Goroutine 能够进入自旋就会调用runtime.sync_runtime_doSpin 和 runtime.procyield 并执行 30 次的 PAUSE 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sync_runtime_canSpin</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// sync.Mutex is cooperative, so we are conservative with spinning.
</span><span class="c1"></span>	<span class="c1">// Spin only few times and only if running on a multicore machine and
</span><span class="c1"></span>	<span class="c1">// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.
</span><span class="c1"></span>	<span class="c1">// As opposed to runtime mutex we don&#39;t do passive spinning here,
</span><span class="c1"></span>	<span class="c1">// because there can be work on global runq or on other Ps.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">active_spin</span> <span class="o">||</span> <span class="nx">ncpu</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">gomaxprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="o">+</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">();</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>一旦当前 Goroutine 能够进入自旋就会调用runtime.sync_runtime_doSpin 和 runtime.procyield 并执行 30 次的 PAUSE 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sync_runtime_doSpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">procyield</span><span class="p">(</span><span class="nx">active_spin_cnt</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">procyield</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="nx">MOVL</span>	<span class="nx">cycles</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">AX</span>
<span class="nx">again</span><span class="p">:</span>
	<span class="nx">PAUSE</span>
	<span class="nx">SUBL</span>	<span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">AX</span>
	<span class="nx">JNZ</span>	<span class="nx">again</span>
	<span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="unlock">Unlock</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Unlock unlocks m.
</span><span class="c1">// It is a run-time error if m is not locked on entry to Unlock.
</span><span class="c1">//
</span><span class="c1">// A locked Mutex is not associated with a particular goroutine.
</span><span class="c1">// It is allowed for one goroutine to lock a Mutex and then
</span><span class="c1">// arrange for another goroutine to unlock it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
	<span class="p">}</span>
    <span class="c1">//如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；
</span><span class="c1"></span>    <span class="c1">//如果该函数返回的新状态不等于 0，这段代码会调用 sync.Mutex.unlockSlow 开始慢速解锁：
</span><span class="c1"></span>	<span class="c1">// Fast path: drop lock bit.
</span><span class="c1"></span>	<span class="nx">new</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="o">-</span><span class="nx">mutexLocked</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">new</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Outlined slow path to allow inlining the fast path.
</span><span class="c1"></span>		<span class="c1">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁：</p>
<ul>
<li>
<p>在正常模式下，上述代码会使用如下所示的处理过程：</p>
<ul>
<li>如果互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li>
<li>如果互斥锁存在等待者，会通过 sync.runtime_Semrelease 唤醒等待者并移交锁的所有权；</li>
</ul>
</li>
<li>
<p>在饥饿模式下，上述代码会直接调用 sync.runtime_Semrelease 将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//先校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">new</span><span class="o">+</span><span class="nx">mutexLocked</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: unlock of unlocked mutex&#34;</span><span class="p">)</span>
    <span class="p">}</span>

	<span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">old</span> <span class="o">:=</span> <span class="nx">new</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// If there are no waiters or a goroutine has already
</span><span class="c1"></span>			<span class="c1">// been woken or grabbed the lock, no need to wake anyone.
</span><span class="c1"></span>			<span class="c1">// In starvation mode ownership is directly handed off from unlocking
</span><span class="c1"></span>			<span class="c1">// goroutine to the next waiter. We are not part of this chain,
</span><span class="c1"></span>			<span class="c1">// since we did not observe mutexStarving when we unlocked the mutex above.
</span><span class="c1"></span>            <span class="c1">// So get off the way.
</span><span class="c1"></span>            <span class="c1">// 如果 Mutex 处于正常状态，如果没有 waiter，或者已经有在处理的情况了，那么释放就好，不做额外的处理
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
            <span class="c1">// Grab the right to wake someone.
</span><span class="c1"></span>            <span class="c1">//否则，waiter 数减 1，mutexWoken 标志设置上，通过 CAS 更新 state 的值
</span><span class="c1"></span>			<span class="nx">new</span> <span class="p">=</span> <span class="p">(</span><span class="nx">old</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">mutexWoken</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 唤醒一个阻塞的 goroutine，但不是唤醒第一个等待者
</span><span class="c1"></span>				<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Starving mode: handoff mutex ownership to the next waiter, and yield
</span><span class="c1"></span>		<span class="c1">// our time slice so that the next waiter can start to run immediately.
</span><span class="c1"></span>		<span class="c1">// Note: mutexLocked is not set, the waiter will set it after wakeup.
</span><span class="c1"></span>		<span class="c1">// But mutex is still considered locked if mutexStarving is set,
</span><span class="c1"></span>        <span class="c1">// so new coming goroutines won&#39;t acquire it.
</span><span class="c1"></span>        <span class="c1">//如果 Mutex 处于饥饿状态，直接唤醒等待队列中的 waiter。
</span><span class="c1"></span>		<span class="c1">// 饥饿模式: 直接将 mutex 所有权交给等待队列最前端的 goroutine
</span><span class="c1"></span>		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="rwmutex">RWMutex</h2>
<p>RWMutex 是很常见的并发原语,很多编程语言的库都提供了类似的并发类型。RWMutex 一般都是基于互斥锁、条件变量(condition variables)或者信号量(semaphores)等并发原语来实现。Go 标准库中的 RWMutex 是基于 Mutex 实现的。</p>
<p>readers-writers 问题一般有三类,基于对读和写操作的优先级,读写锁的设计和实现也分成三类。</p>
<ul>
<li>
<p>Read-preferring:读优先的设计可以提供很高的并发性,但是,在竞争激烈的情况下可能会导致写饥饿。这是因为,如果有大量的读,这种设计会导致只有所有的读都释放了锁之后,写才可能获取到锁。</p>
</li>
<li>
<p>Write-preferring:写优先的设计意味着,如果已经有一个 writer 在等待请求锁的话,它会阻止新来的请求锁的 reader 获取到锁,所以优先保障 writer。当然,如果有一些 reader 已经请求了锁的话,新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以,写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。</p>
</li>
<li>
<p>不指定优先级:这种设计比较简单,不区分 reader 和 writer 优先级,某些场景下这种不指定优先级的设计反而更有效,因为第一类优先级会导致写饥饿,第二类优先级可能会导致读饥饿,这种不指定优先级的访问不再区分读写,大家都是同一个优先级,解决了饥饿的问题。</p>
</li>
</ul>
<p>Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。</p>
<p>sync.RWMutex 中总共包含以下 5 个字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// There is a modified copy of this file in runtime/rwmutex.go.
</span><span class="c1">// If you make any changes here, see if you should make them there.
</span><span class="c1"></span>
<span class="c1">// A RWMutex is a reader/writer mutual exclusion lock.
</span><span class="c1">// The lock can be held by an arbitrary number of readers or a single writer.
</span><span class="c1">// The zero value for a RWMutex is an unlocked mutex.
</span><span class="c1">//
</span><span class="c1">// A RWMutex must not be copied after first use.
</span><span class="c1">//
</span><span class="c1">// If a goroutine holds a RWMutex for reading and another goroutine might
</span><span class="c1">// call Lock, no goroutine should expect to be able to acquire a read lock
</span><span class="c1">// until the initial read lock is released. In particular, this prohibits
</span><span class="c1">// recursive read locking. This is to ensure that the lock eventually becomes
</span><span class="c1">// available; a blocked Lock call excludes new readers from acquiring the
</span><span class="c1">// lock.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RWMutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">w</span>           <span class="nx">Mutex</span>  <span class="c1">// held if there are pending writers // 互斥锁解决多个writer的竞争
</span><span class="c1"></span>	<span class="nx">writerSem</span>   <span class="kt">uint32</span> <span class="c1">// semaphore for writers to wait for completing readers  // writer信号量
</span><span class="c1"></span>	<span class="nx">readerSem</span>   <span class="kt">uint32</span> <span class="c1">// semaphore for readers to wait for completing writers  // reader信号量
</span><span class="c1"></span>	<span class="nx">readerCount</span> <span class="kt">int32</span>  <span class="c1">// number of pending readers // reader的数量
</span><span class="c1"></span>	<span class="nx">readerWait</span>  <span class="kt">int32</span>  <span class="c1">// number of departing readers   // writer等待完成的reader的数量
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>w:为 writer 的竞争锁而设计;</li>
<li>readerCount:记录当前 reader 的数量(以及是否有 writer 竞争锁);</li>
<li>readerWait:记录 writer 请求锁时需要等待 read 完成的 reader 的数量;</li>
<li>writerSem 和 readerSem:都是为了阻塞设计的信号量。</li>
</ul>
<p>我们会依次分析获取写锁和读锁的实现原理，其中：</p>
<ul>
<li>写操作使用 sync.RWMutex.Lock 和 sync.RWMutex.Unlock 方法；</li>
<li>读操作使用 sync.RWMutex.RLock 和 sync.RWMutex.RUnlock 方法；</li>
</ul>
<p>在 Lock 方法中,是先获取内部互斥锁,才会修改的其他字段;而在 Unlock 方法中,是先修改的其他字段,才会释放内部互斥锁,这样才能保证字段的修改也受到互斥锁的保护。</p>
<h3 id="rlock">RLock</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RLock locks rw for reading.
</span><span class="c1">//
</span><span class="c1">// It should not be used for recursive read locking; a blocked Lock
</span><span class="c1">// call excludes new readers from acquiring the lock. See the
</span><span class="c1">// documentation on the RWMutex type.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RLock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">state</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">//reader 计数加 1。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// A writer is pending, wait for it.
</span><span class="c1"></span>		<span class="c1">// rw.readerCount是负值的时候,意味着此时有writer等待请求锁,因为writer优先
</span><span class="c1"></span>		<span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你可能比较困惑的是,readerCount 怎么还可能为负数呢?其实,这是因为,readerCount 这个字段有双重含义:</p>
<ul>
<li>
<p>没有 writer 竞争或持有锁时,readerCount 和我们正常理解的 reader 的计数是一样的;</p>
</li>
<li>
<p>但是,如果有 writer 竞争锁或者持有锁时,那么,readerCount 不仅仅承担着 reader 的计数功能,还能够标识当前是否有 writer 竞争或持有锁,在这种情况下,请求锁的 reader 的处理会阻塞等待锁的释放。</p>
</li>
</ul>
<h3 id="runlock">RUnlock</h3>
<p>调用 RUnlock 的时候,我们需要将 Reader 的计数减去 1,因为 reader 的数量减少了一个。但是, AddInt32 的返回值还有另外一个含义。如果它是负值, 就表示当前有 writer 竞争锁,在这种情况下,还会调用 rUnlockSlow 方法,检查是不是 reader 都释放读锁了,如果读锁都释放了,那么可以唤醒请求写锁的 writer 了。</p>
<p>当一个或者多个 reader 持有锁的时候,竞争锁的 writer 会等待这些 reader 释放完,才可能持有这把锁。</p>
<p>当 writer 请求锁的时候,是无法改变既有的 reader 持有锁的现实的,也不会强制这些 reader 释放锁,它的优先权只是限定后来的 reader 不要和它抢。</p>
<p>所以,rUnlockSlow 将持有锁的 reader 计数减少 1 的时候,会检查既有的 reader 是不是都已经释放了锁,如果都释放了锁,就会唤醒 writer,让 writer 持有锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// RUnlock undoes a single RLock call;
</span><span class="c1">// it does not affect other simultaneous readers.
</span><span class="c1">// It is a run-time error if rw is not locked for reading
</span><span class="c1">// on entry to RUnlock.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RUnlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">state</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">writerSem</span><span class="p">))</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Outlined slow-path to allow the fast-path to be inlined
</span><span class="c1"></span>		<span class="c1">// 有等待的writer
</span><span class="c1"></span>		<span class="nx">rw</span><span class="p">.</span><span class="nf">rUnlockSlow</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">rUnlockSlow</span><span class="p">(</span><span class="nx">r</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="o">-</span><span class="nx">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: RUnlock of unlocked RWMutex&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// A writer is pending.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerWait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The last reader unblocks the writer.
</span><span class="c1"></span>		<span class="c1">// 最后一个reader了,writer终于有机会获得锁了
</span><span class="c1"></span>		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">writerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="lock-1">Lock</h3>
<p>RWMutex 是一个多 writer 多 reader 的读写锁,所以同时可能有多个 writer 和 reader。</p>
<p>那么,为了避免 writer 之间的竞争,RWMutex 就会使用一个 Mutex 来保证 writer 的互斥。</p>
<p>一旦一个 writer 获得了内部的互斥锁,就会反转 readerCount 字段,把它从原来的正整数 readerCount(&gt;=0) 修改为负数(readerCount-rwmutexMaxReaders),让这个字段保持两个含义(既保存了 reader 的数量,又表示当前有 writer)。</p>
<p>当资源的使用者想要获取写锁时，需要调用 sync.RWMutex.Lock 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Lock locks rw for writing.
</span><span class="c1">// If the lock is already locked for reading or writing,
</span><span class="c1">// Lock blocks until the lock is available.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">state</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// First, resolve competition with other writers.
</span><span class="c1"></span>	<span class="c1">// 首先解决其他writer竞争问题
</span><span class="c1"></span>	<span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// Announce to readers there is a pending writer.
</span><span class="c1"></span>	<span class="c1">// 反转readerCount,告诉reader有writer竞争锁
</span><span class="c1"></span>	<span class="c1">//记录当前活跃的 reader 数量,所谓活跃的 reader,就是指持有读锁还没有释放的那些 reader。
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="o">-</span><span class="nx">rwmutexMaxReaders</span><span class="p">)</span> <span class="o">+</span> <span class="nx">rwmutexMaxReaders</span>
	<span class="c1">// Wait for active readers.
</span><span class="c1"></span>	<span class="c1">// 如果当前有reader持有锁,那么需要等待
</span><span class="c1"></span>	<span class="c1">// 如果 readerCount 不是 0,就说明当前有持有读锁的 reader,RWMutex 需要把这个当前 readerCount 赋值给 readerWait 字段保存下来, 同时,这个 writer 进入阻塞等待状态。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">r</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerWait</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">writerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">))</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">writerSem</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>每当一个 reader 释放读锁的时候(调用 RUnlock 方法时),readerWait 字段就减 1,直到所有的活跃的 reader 都释放了读锁,才会唤醒这个 writer。</p>
<h3 id="unlock-1">Unlock</h3>
<p>当一个 writer 释放锁的时候,它会再次反转 readerCount 字段。可以肯定的是,因为当前锁由 writer 持有,所以,readerCount 字段是反转过的,并且减去了 rwmutexMaxReaders 这个常数,变成了负数。所以,这里的反转方法就是给它增加 rwmutexMaxReaders 这个常数值。</p>
<p>既然 writer 要释放锁了,那么就需要唤醒之后新来的 reader,不必再阻塞它们了,让它们开开心心地继续执行就好了。</p>
<p>在 RWMutex 的 Unlock 返回之前,需要把内部的互斥锁释放。释放完毕后,其他的 writer 才可以继续竞争这把锁。</p>
<p>写锁的释放会调用 sync.RWMutex.Unlock：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Unlock unlocks rw for writing. It is a run-time error if rw is
</span><span class="c1">// not locked for writing on entry to Unlock.
</span><span class="c1">//
</span><span class="c1">// As with Mutexes, a locked RWMutex is not associated with a particular
</span><span class="c1">// goroutine. One goroutine may RLock (Lock) a RWMutex and then
</span><span class="c1">// arrange for another goroutine to RUnlock (Unlock) it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">state</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">))</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 告诉reader没有活跃的writer了
</span><span class="c1"></span>	<span class="c1">// Announce to readers there is no active writer.
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerCount</span><span class="p">,</span> <span class="nx">rwmutexMaxReaders</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">r</span> <span class="o">&gt;=</span> <span class="nx">rwmutexMaxReaders</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: Unlock of unlocked RWMutex&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Unblock blocked readers, if any.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 唤醒阻塞的reader们
</span><span class="c1"></span>		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rw</span><span class="p">.</span><span class="nx">readerSem</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Allow other writers to proceed.
</span><span class="c1"></span>	<span class="c1">// 释放内部的互斥锁
</span><span class="c1"></span>	<span class="nx">rw</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>与加锁的过程正好相反，写锁的释放分以下几个执行：</p>
<ol>
<li>调用 sync/atomic.AddInt32 函数将 readerCount 变回正数，释放读锁；</li>
<li>通过 for 循环释放所有因为获取读锁而陷入等待的 Goroutine：</li>
<li>调用 sync.Mutex.Unlock 释放写锁；</li>
</ol>
<p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』。</p>
<h2 id="waitgroup">WaitGroup</h2>
<p>sync.WaitGroup 可以达到并发 Goroutine 的执行屏障的效果，等待多个 Goroutine 执行完毕。</p>
<p>sync.WaitGroup 结构体中只包含两个成员变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A WaitGroup waits for a collection of goroutines to finish.
</span><span class="c1">// The main goroutine calls Add to set the number of
</span><span class="c1">// goroutines to wait for. Then each of the goroutines
</span><span class="c1">// runs and calls Done when finished. At the same time,
</span><span class="c1">// Wait can be used to block until all goroutines have finished.
</span><span class="c1">//
</span><span class="c1">// A WaitGroup must not be copied after first use.
</span><span class="c1">// WaitGroup 用于等待一组 Goroutine 执行完毕。
</span><span class="c1">// 主 Goroutine 调用 Add 来设置需要等待的 Goroutine 的数量
</span><span class="c1">// 然后每个 Goroutine 运行并调用 Done 来确认已经执行网完毕
</span><span class="c1">// 同时，Wait 可以用于阻塞并等待所有 Goroutine 完成。
</span><span class="c1">//
</span><span class="c1">// WaitGroup 在第一次使用后不能被复制
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 避免复制使用的一个技巧,可以告诉vet工具违反了复制使用的规则
</span><span class="c1"></span>	<span class="nx">noCopy</span> <span class="nx">noCopy</span>

	<span class="c1">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.
</span><span class="c1"></span>	<span class="c1">// 64-bit atomic operations require 64-bit alignment, but 32-bit
</span><span class="c1"></span>	<span class="c1">// compilers do not ensure it. So we allocate 12 bytes and then use
</span><span class="c1"></span>	<span class="c1">// the aligned 8 bytes in them as state, and the other 4 as storage
</span><span class="c1"></span>	<span class="c1">// for the sema.
</span><span class="c1"></span>	<span class="c1">// 64 位值: 高 32 位用于计数，低 32 位用于等待计数
</span><span class="c1"></span>	<span class="c1">// 64 位的原子操作要求 64 位对齐，但 32 位编译器无法保证这个要求
</span><span class="c1"></span>	<span class="c1">// 因此分配 12 字节然后将他们对齐，其中 8 字节作为状态，其他 4 字节用于存储原语
</span><span class="c1"></span>	<span class="c1">// 64bit(8bytes)的值分成两段,高32bit是计数值,低32bit是waiter的计数
</span><span class="c1"></span>	<span class="c1">// 另外32bit是用作信号量的
</span><span class="c1"></span>	<span class="c1">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法
</span><span class="c1"></span>	<span class="c1">// 总之,会找到对齐的那64bit作为state,其余的32bit做信号量
</span><span class="c1"></span>
	<span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，WaitGroup 内部仅仅只是一个 uint32 类型的数组。由于需要考虑 32 位机器的兼容性， 这里采用了 uint32 结构的数组，保证在不同类型的机器上都是 12 个字节。</p>
<ul>
<li>noCopy 的辅助字段,主要就是辅助 vet 工具检查是否通过 copy 赋值这个 WaitGroup 实例</li>
<li>state1,一个具有复合意义的字段,包含 WaitGroup 的计数、阻塞在检查点的 waiter 数和信号量。</li>
</ul>
<p>通过 state() 函数来确定实际的存储情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 得到state的地址和信号量的地址
</span><span class="c1">// state returns pointers to the state and sema fields stored within wg.state1.
</span><span class="c1">// state 返回 wg.state1 中存储的状态和原语字段
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">state</span><span class="p">()</span> <span class="p">(</span><span class="nx">statep</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">))</span><span class="o">%</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果地址是64bit对齐的,数组前两个元素做state,后一个元素做信号量
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果地址是32bit对齐的,数组后两个元素用来做state,它可以用来做64bit的原子操作
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>在 64 位机器上 state1[0] 和 state1[1] 分别用于等待计数和计数，而最后一个 state1[2] 用于存储原语。</li>
<li>在 32 位机器上 state1[0] 作为存储原语，而 state[1] 和 state[2] 用于等待计数和计数</li>
</ul>
<p>因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的,所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。</p>
<p>在 64 位环境下,state1 的第一个元素是 waiter 数,第二个元素是 WaitGroup 的计数值,第三个元素是信号量。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210118113645.png" alt=""></p>
<p>在 32 位环境下,如果 state1 不是 64 位对齐的地址,那么 state1 的第一个元素是信号量,后两个元素分别是 waiter 数和计数值。</p>
<h3 id="adddone">Add&amp;Done</h3>
<p>Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值,内部通过原子操作把这个值加到计数值上。需要注意的是,这个 delta 也可以是个负数,相当于为计数值减去一个值,Done 方法内部其实就是通过 Add(-1) 实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Add adds delta, which may be negative, to the WaitGroup counter.
</span><span class="c1">// If the counter becomes zero, all goroutines blocked on Wait are released.
</span><span class="c1">// If the counter goes negative, Add panics.
</span><span class="c1">//
</span><span class="c1">// Note that calls with a positive delta that occur when the counter is zero
</span><span class="c1">// must happen before a Wait. Calls with a negative delta, or calls with a
</span><span class="c1">// positive delta that start when the counter is greater than zero, may happen
</span><span class="c1">// at any time.
</span><span class="c1">// Typically this means the calls to Add should execute before the statement
</span><span class="c1">// creating the goroutine or other event to be waited for.
</span><span class="c1">// If a WaitGroup is reused to wait for several independent sets of events,
</span><span class="c1">// new Add calls must happen after all previous Wait calls have returned.
</span><span class="c1">// See the WaitGroup example.
</span><span class="c1">// Add 将 delta（可能为负）加到 WaitGroup 的计数器上
</span><span class="c1">// 如果计数器归零，则所有阻塞在 Wait 的 Goroutine 被释放
</span><span class="c1">// 如果计数器为负，则 panic
</span><span class="c1">//
</span><span class="c1">// 请注意，当计数器为 0 时发生的带有正的 delta 的调用必须在 Wait 之前。
</span><span class="c1">// 当计数器大于 0 时，带有负 delta 的调用或带有正 delta 调用可能在任何时候发生。
</span><span class="c1">// 通常，这意味着 Add 调用必须发生在 Goroutine 创建之前或其他被等待事件之前。
</span><span class="c1">// 如果一个 WaitGroup 被复用于等待几个不同的独立事件集合，必须在前一个 Wait 调用返回后才能调用 Add。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 首先获取状态指针和存储指针
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Synchronize decrements with Wait.
</span><span class="c1"></span>			<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 高32bit是计数值v,所以把delta左移32,增加到计数上
</span><span class="c1"></span>	<span class="c1">// 将 delta 加到 statep 的前 32 位上，即加到计数器上
</span><span class="c1"></span>	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
	<span class="c1">// 计数器的值
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span><span class="c1">// 当前计数值
</span><span class="c1"></span>	<span class="c1">// 等待器的值
</span><span class="c1"></span>	<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// The first increment must be synchronized with Wait.
</span><span class="c1"></span>		<span class="c1">// Need to model this as a read, because there can be
</span><span class="c1"></span>		<span class="c1">// several concurrent wg.counter transitions from 0.
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 如果实际计数为负则直接 panic，因此是不允许计数为负值的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">//WaitGroup 的计数器的值必须大于等于 0。我们在更改这个计数值的时候,WaitGroup 会先做检查,如果计数值被设置为负数,就会导致 panic。
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: negative WaitGroup counter&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果等待器不为零，但 delta 是处于增加的状态，而且存储计数与 delta 的值相同，则立即 panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果计数器 &gt; 0 或者等待器为 0 则一切都很好，直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// This goroutine has set counter to 0 when waiters &gt; 0.
</span><span class="c1"></span>	<span class="c1">// Now there can&#39;t be concurrent mutations of state:
</span><span class="c1"></span>	<span class="c1">// - Adds must not happen concurrently with Wait,
</span><span class="c1"></span>	<span class="c1">// - Wait does not increment waiters if it sees counter == 0.
</span><span class="c1"></span>	<span class="c1">// Still do a cheap sanity check to detect WaitGroup misuse.
</span><span class="c1"></span>	<span class="c1">// 这时 Goroutine 已经将计数器清零，且等待器大于零（并发调用导致）
</span><span class="c1"></span>	<span class="c1">// 这时不允许出现并发使用导致的状态突变，否则就应该 panic
</span><span class="c1"></span>	<span class="c1">// - Add 不能与 Wait 并发调用
</span><span class="c1"></span>	<span class="c1">// - Wait 在计数器已经归零的情况下，不能再继续增加等待器了
</span><span class="c1"></span>	<span class="c1">// 仍然检查来保证 WaitGroup 不会被滥用
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="nx">state</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Reset waiters count to 0.
</span><span class="c1"></span>	<span class="c1">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量
</span><span class="c1"></span>    <span class="c1">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter
</span><span class="c1"></span>	<span class="c1">// 结束后将等待器清零
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">statep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 等待器大于零，减少 runtime_Semrelease 产生的阻塞
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span><span class="o">--</span> <span class="p">{</span>
		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="nx">semap</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Done decrements the WaitGroup counter by one.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Done方法实际就是计数器减1
</span><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Add 将 statep 的值作为两段来处理，前 32 位处理为计数器，后 32 位处理为等待器。</p>
<ul>
<li>在初始阶段，等待器为 0 ，计数器随着 Add 正数的调用而增加。</li>
<li>如果 Add 使用错误导致计数器为负，则会立即 panic</li>
<li>由于并发的效果，计数器和等待器的值是分开操作的，因此可能出现计数器已经为零（说明当前 Add 的操作为负，即 Done），但等待器为正的情况，依次调用存储原语释放产生的阻塞（本质上为加 1 操作）</li>
</ul>
<p>我们来考虑一个使用场景，首先刚创建的 WaitGroup 所有值为零：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">statep</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>这时候调用 Add(1)：</p>
<p>注意，有符号数为补码表示，最高位为符号位</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>      <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span>
<span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="m">32</span>  <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">statep</span>            <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">state</span>             <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>那么这时候的 v （计数器）为 1，而 w 等待器为 0。</p>
<p>再来执行一遍减一的操作。再减一之前：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">statep</span>            <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>减一：</p>
<p>注意，有符号数为补码表示，最高位为符号位</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>      <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span>
<span class="nf">int64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="m">32</span>  <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">1111</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">statep</span>            <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0001</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
<span class="n">state</span>            <span class="m">10000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>即计数器归零。</p>
<h3 id="wait">Wait</h3>
<p>Wait 方法的实现逻辑是:不断检查 state 的值。如果其中的计数值变为了 0,那么说明所有的任务已完成,调用者不必再等待,直接返回。如果计数值大于 0,说明此时还有任务没完成,那么调用者就变成了等待者,需要加入 waiter 队列,并且阻塞住自己。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Wait blocks until the WaitGroup counter is zero.
</span><span class="c1">// Wait 会保持阻塞直到 WaitGroup 计数器归零
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 先获得计数器和存储原语
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 一个简单的死循环，只有当计数器归零才会结束
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 原子读
</span><span class="c1"></span>		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">)</span>
		<span class="c1">// 计数
</span><span class="c1"></span>		<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span><span class="c1">// 当前计数值
</span><span class="c1"></span>		<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>	<span class="c1">// waiter的数量
</span><span class="c1"></span>		<span class="c1">// 如果计数器已经归零，则直接退出循环
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Counter is 0, no need to wait.
</span><span class="c1"></span>			<span class="c1">// 如果计数值为0, 调用这个方法的goroutine不必再等待,继续执行它后面的逻辑即可
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// Increment waiters count.
</span><span class="c1"></span>		<span class="c1">// 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环
</span><span class="c1"></span>		<span class="c1">// 增加等待计数，此处的原语会比较 statep 和 state 的值，如果相同则等待计数加 1
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">state</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Wait must be synchronized with the first Add.
</span><span class="c1"></span>				<span class="c1">// Need to model this is as a write to race with the read in Add.
</span><span class="c1"></span>				<span class="c1">// As a consequence, can do the write only for the first waiter,
</span><span class="c1"></span>				<span class="c1">// otherwise concurrent Waits will race with each other.
</span><span class="c1"></span>				<span class="nx">race</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 阻塞休眠等待
</span><span class="c1"></span>			<span class="c1">// 会阻塞到存储原语是否 &gt; 0（即睡眠），如果 *semap &gt; 0 则会减 1，因此最终的 semap 理论为 0
</span><span class="c1"></span>			<span class="nf">runtime_Semacquire</span><span class="p">(</span><span class="nx">semap</span><span class="p">)</span>
			<span class="c1">// 在这种情况下，如果 *semap 不等于 0 ，则说明使用失误，直接 panic
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">//WaitGroup 虽然可以重用,但是是有一个前提的,那就是必须等到上一轮的 Wait 完成之后,才能重用 WaitGroup 执行下一轮的 Add/Wait,如果你在 Wait 还没执行完的时候就调用下一轮 Add 方法,就有可能出现 panic
</span><span class="c1"></span>				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 被唤醒,不再阻塞,返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>可以看到 Wait 使用的是一个简单的死循环来进行操作。在循环体中，每次先读取计数器和等待器的值。 然后增加等待计数，如果增加成功，会调用 runtime_Semacquire 来阻塞当前的死循环， 直到存储原语的值被 runtime_Semrelease 减少后才会解除阻塞状态进入下一个循环。</p>
<h3 id="整体流程">整体流程</h3>
<p>我们来完成考虑一下整个流程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="p">}()</span>
<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>在 wg 创建之初，计数器、等待器、存储原语的值均初始化为零值。不妨假设调用 wg.Add(1)，则计数器加 1 等待器、存储原语保持不变，均为 0。</p>
<p>wg.Done() 和 wg.Wait() 的调用顺序可能成两种情况：</p>
<p>情况 1：先调用 wg.Done() 再调用 wg.Wait()。</p>
<p>这时候 wg.Done() 使计数器减 1 ，这时计数器、等待器、存储原语均为 0，由于等待器为 0 则 runtime_Semrelease 不会被调用。 于是当 wg.Wait() 开始调用时，读取到计数器已经为 0，循环退出，wg.Wait() 调用完毕。</p>
<p>情况 2：先调用 wg.Wait() 再调用 wg.Done()。</p>
<p>这时候 wg.Wait() 开始调用时，读取到计数器为 1，则为等待器加 1，并调用 runtime_Semacquire 开始阻塞在存储原语为 0 的状态。</p>
<p>在阻塞的过程中，Goroutine 被调度器调度，开始执行 wg.Done()，于是计数器清零，但由于等待器为 1 大于零。 这时将等待器也清零，并调用与等待器技术相同次数（此处为 1 次）的 runtime_Semrelease，这导致存储原语的值变为 1，计数器和等待器均为零。 这时，runtime_Semacquire 在存储原语大于零后被唤醒，这时检查计数器和等待器是否为零（如果不为零则说明 Add 与 Wait 产生并发调用，直接 panic），这时他们为 0，因此进入下一个循环，当再次读取计数器时，发现计数器已经清理，于是退出 wg.Wait() 调用，结束阻塞。</p>
<h3 id="nocopy">noCopy</h3>
<p>vet 会对实现 Locker 接口的数据类型做静态检查,一旦代码中有复制使用这种数据类型的情况,就会发出警告。</p>
<p>通过给 WaitGroup 添加一个 noCopy 字段,我们就可以为 WaitGroup 实现 Locker 接口,这样 vet 工具就可以做复制检查了。而且因为 noCopy 字段是未输出类型,所以 WaitGroup 不会暴露 Lock/Unlock 方法。</p>
<p>noCopy 字段的类型是 noCopy,它只是一个辅助的、用来帮助 vet 检查用的类型:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// noCopy may be embedded into structs which must not be copied
</span><span class="c1">// after the first use.
</span><span class="c1">//
</span><span class="c1">// See https://golang.org/issues/8005#issuecomment-190753527
</span><span class="c1">// for details.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">noCopy</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// Lock is a no-op used by -copylocks checker from `go vet`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">noCopy</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span>   <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">noCopy</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{}</span>

</code></pre></td></tr></table>
</div>
</div><p>如果你想要自己定义的数据结构不被复制使用,或者说,不能通过 vet 工具检查出复制使用的报警,就可以通过嵌入 noCopy 这个数据类型来实现。</p>
<h2 id="cond">Cond</h2>
<p>标准库中的 Cond 并发原语初始化的时候,需要关联一个 Locker 接口的实例,一般我们使用 Mutex 或者 RWMutex。</p>
<p>首先,Cond 关联的 Locker 实例可以通过 c.L 访问,它内部维护着一个先入先出的等待队列。</p>
<p>然后,我们分别看下它的三个方法 Broadcast、Signal 和 Wait 方法。</p>
<ul>
<li>Signal 方法,允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine,显然无需通知 waiter;如果 Cond 等待队列中有一个或者多个等待的 goroutine,则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中,比如 Java 语言中,Signal 方法也被叫做 notify 方法。
<ul>
<li>调用 Signal 方法时,不强求你一定要持有 c.L 的锁。</li>
</ul>
</li>
<li>Broadcast 方法,允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine,显然无需通知 waiter;如果 Cond 等待队列中有一个或者多个等待的 goroutine,则清空所有等待的 goroutine,并全部唤醒。在其他编程语言中,比如 Java 语言中,Broadcast 方法也被叫做 notifyAll 方法。
<ul>
<li>同样地,调用 Broadcast 方法时,也不强求你一定持有 c.L 的锁。</li>
</ul>
</li>
<li>Wait 方法,会把调用者 Caller 放入 Cond 的等待队列中并阻塞,直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。
<ul>
<li>调用 Wait 方法时必须要持有 c.L 的锁。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Cond implements a condition variable, a rendezvous point
</span><span class="c1">// for goroutines waiting for or announcing the occurrence
</span><span class="c1">// of an event.
</span><span class="c1">//
</span><span class="c1">// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
</span><span class="c1">// which must be held when changing the condition and
</span><span class="c1">// when calling the Wait method.
</span><span class="c1">//
</span><span class="c1">// A Cond must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Cond</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">noCopy</span> <span class="nx">noCopy</span>

	<span class="c1">// L is held while observing or changing the condition
</span><span class="c1"></span>	<span class="c1">// 当观察或者修改等待条件的时候需要加锁
</span><span class="c1"></span>	<span class="nx">L</span> <span class="nx">Locker</span>
	<span class="c1">// 等待队列
</span><span class="c1"></span>	<span class="nx">notify</span>  <span class="nx">notifyList</span>
	<span class="nx">checker</span> <span class="nx">copyChecker</span>
<span class="p">}</span>

<span class="c1">// NewCond returns a new Cond with Locker l.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewCond</span><span class="p">(</span><span class="nx">l</span> <span class="nx">Locker</span><span class="p">)</span> <span class="o">*</span><span class="nx">Cond</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Cond</span><span class="p">{</span><span class="nx">L</span><span class="p">:</span> <span class="nx">l</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Wait atomically unlocks c.L and suspends execution
</span><span class="c1">// of the calling goroutine. After later resuming execution,
</span><span class="c1">// Wait locks c.L before returning. Unlike in other systems,
</span><span class="c1">// Wait cannot return unless awoken by Broadcast or Signal.
</span><span class="c1">//
</span><span class="c1">// Because c.L is not locked when Wait first resumes, the caller
</span><span class="c1">// typically cannot assume that the condition is true when
</span><span class="c1">// Wait returns. Instead, the caller should Wait in a loop:
</span><span class="c1">//
</span><span class="c1">//    c.L.Lock()
</span><span class="c1">//    for !condition() {
</span><span class="c1">//        c.Wait()
</span><span class="c1">//    }
</span><span class="c1">//    ... make use of condition ...
</span><span class="c1">//    c.L.Unlock()
</span><span class="c1">//
</span><span class="c1">// Wait 把调用者加入到等待队列时会释放锁,在被唤醒之后还会请求锁。在阻塞休眠期间, 调用者是不持有锁的,这样能让其他 goroutine 有机会检查或者更新等待变量。
</span><span class="c1">// Wait 原子式的 unlock c.L， 并暂停执行调用的 goroutine。
</span><span class="c1">// 在稍后执行后，Wait 会在返回前 lock c.L. 与其他系统不同，
</span><span class="c1">// 除非被 Broadcast 或 Signal 唤醒，否则等待无法返回。
</span><span class="c1">//
</span><span class="c1">// 因为等待第一次 resume 时 c.L 没有被锁定，所以当 Wait 返回时，
</span><span class="c1">// 调用者通常不能认为条件为真。相反，调用者应该在循环中使用 Wait()：
</span><span class="c1">//
</span><span class="c1">//    c.L.Lock()
</span><span class="c1">//    for !condition() {
</span><span class="c1">//        c.Wait()
</span><span class="c1">//    }
</span><span class="c1">//    ... make use of condition ...
</span><span class="c1">//    c.L.Unlock()
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 增加到等待队列中
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">runtime_notifyListAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 阻塞休眠直到被唤醒
</span><span class="c1"></span>	<span class="nf">runtime_notifyListWait</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Signal wakes one goroutine waiting on c, if there is any.
</span><span class="c1">//
</span><span class="c1">// It is allowed but not required for the caller to hold c.L
</span><span class="c1">// during the call.
</span><span class="c1">// Signal 和 Broadcast 只涉及到 notifyList 数据结构,不涉及到锁。
</span><span class="c1">// Signal 唤醒一个等待 c 的 goroutine（如果存在）
</span><span class="c1">//
</span><span class="c1">// 在调用时它可以（不必须）持有一个 c.L
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Signal</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nf">runtime_notifyListNotifyOne</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Broadcast wakes all goroutines waiting on c.
</span><span class="c1">//
</span><span class="c1">// It is allowed but not required for the caller to hold c.L
</span><span class="c1">// during the call.
</span><span class="c1">// Broadcast 唤醒等待 c 的所有 goroutine
</span><span class="c1">//
</span><span class="c1">// 调用时它可以（不必须）持久有个 c.L
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Broadcast</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nf">runtime_notifyListNotifyAll</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="copychecker">copyChecker</h3>
<p>copyChecker 非常简单，它实现了一个 check() 方法，这个方法以 copyChecker 的指针作为 reciever， 因为 copyChecker 在一个 Cond 中并非指针，因此当 Cond 发生拷贝行为后，这个 reciever 会 发生变化，从而检测到拷贝行为，使用 panic 以警示用户：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// copyChecker holds back pointer to itself to detect object copying.
</span><span class="c1">// copyChecker 是一个辅助结构,可以在运行时检查 Cond 是否被复制使用。
</span><span class="c1">// copyChecker 保存指向自身的指针来检测对象的复制行为。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">copyChecker</span> <span class="kt">uintptr</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">copyChecker</span><span class="p">)</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">c</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
		<span class="nb">uintptr</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync.Cond is copied&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="notifylist">notifyList</h3>
<p>runtime_notifyListXXX 是运行时实现的方法,实现了一个等待 / 通知的队列。</p>
<p>notifyList 结构本质上是一个队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyList 基于 ticket 实现通知列表
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">notifyList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// wait 为下一个 waiter 的 ticket 编号
</span><span class="c1"></span>	<span class="c1">// 在没有 lock 的情况下原子自增
</span><span class="c1"></span>	<span class="nx">wait</span> <span class="kt">uint32</span>

	<span class="c1">// notify 是下一个被通知的 waiter 的 ticket 编号
</span><span class="c1"></span>	<span class="c1">// 它可以在没有 lock 的情况下进行读取，但只有在持有 lock 的情况下才能进行写
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// wait 和 notify 会产生 wrap around，只要它们 &#34;unwrapped&#34;
</span><span class="c1"></span>	<span class="c1">// 的差别小于 2^31，这种情况可以被正确处理。对于 wrap around 的情况而言，
</span><span class="c1"></span>	<span class="c1">// 我们需要超过 2^31+ 个 goroutine 阻塞在相同的 condvar 上，这是不可能的。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">notify</span> <span class="kt">uint32</span>

	<span class="c1">// waiter 列表.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">tail</span> <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当一个 Cond 调用 Wait 方法时候，向 wait 字段加 1，并返回一个 ticket 编号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListAdd 将调用者添加到通知列表，以便接收通知。
</span><span class="c1">// 调用者最终必须调用 notifyListWait 等待这样的通知，并传递返回的 ticket 编号。
</span><span class="c1">//go:linkname notifyListAdd sync.runtime_notifyListAdd
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListAdd</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="c1">// 这可以并发调用，例如，当在 read 模式下保持 RWMutex 时从 sync.Cond.Wait 调用时。
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而后使用这个 ticket 编号来等待通知，这个过程会将等待通知的 goroutine 进行停泊，进入等待状态， 并将其 M 与 P 解绑，从而将 G 从 M 身上剥离，放入等待队列 sudog 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListWait 等待通知。如果在调用 notifyListAdd 后发送了一个，则立即返回。否则，它会阻塞。
</span><span class="c1">//go:linkname notifyListWait sync.runtime_notifyListWait
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListWait</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 如果 ticket 编号对应的 goroutine 已经被通知到，则立刻返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">less</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">ticket</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">t0</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="p">}</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="c1">// 将 M/P/G 解绑，并将 G 调整为等待状态，放入 sudog 等待队列中
</span><span class="c1"></span>	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonSyncCondWait</span><span class="p">,</span> <span class="nx">traceEvGoBlockCond</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 将当前 goroutine 置于等待状态并解锁 lock。
</span><span class="c1">// 通过调用 goready(gp) 可让 goroutine 再次 runnable
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goparkunlock</span><span class="p">(</span><span class="nx">lock</span> <span class="o">*</span><span class="nx">mutex</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">gopark</span><span class="p">(</span><span class="nx">parkunlock_c</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">reason</span><span class="p">,</span> <span class="nx">traceEv</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当调用 Signal 时，会有一个在等待的 goroutine 被通知到，具体过程就是从 sudog 列表中找到 要通知的 goroutine，而后将其 goready 来等待调度循环将其调度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListNotifyOne 通知列表中的一个条目
</span><span class="c1">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListNotifyOne</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Fast-path: 如果上次通知后没有新的 waiter
</span><span class="c1"></span>	<span class="c1">// 则无需加锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// slow-path 的二次检查
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">notify</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 更新下一个需要唤醒的 ticket 编号
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 尝试找到需要被通知的 g
</span><span class="c1"></span>	<span class="c1">// 如果目前还没来得及入队，是无法找到的
</span><span class="c1"></span>	<span class="c1">// 但是，当它看到通知编号已经发生改变是不会被 park 的
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 这个查找过程看起来是线性复杂度，但实际上很快就停了
</span><span class="c1"></span>	<span class="c1">// 因为 g 的队列与获取编号不同，因而队列中会出现少量重排，但我们希望找到靠前的 g
</span><span class="c1"></span>	<span class="c1">// 而 g 只有在不再 race 后才会排在靠前的位置，因此这个迭代也不会太久，
</span><span class="c1"></span>	<span class="c1">// 同时，即便找不到 g，这个情况也成立：
</span><span class="c1"></span>	<span class="c1">// 它还没有休眠，并且已经失去了我们在队列上找到的（少数）其他 g 的 race。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">sudog</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ticket</span> <span class="o">==</span> <span class="nx">t</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
			<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="p">}</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nf">readyWithTime</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">readyWithTime</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goready</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是全员通知，基本类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// notifyListNotifyAll 通知列表里的所有人
</span><span class="c1">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">notifyListNotifyAll</span><span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">notifyList</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Fast-path: 如果上次通知后没有新的 waiter
</span><span class="c1"></span>	<span class="c1">// 则无需加锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">)</span> <span class="o">==</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 从列表中取一个，保存到局部变量，waiter 则可以在无锁的情况下 ready
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// 更新要通知的下一个 ticket。
</span><span class="c1"></span>	<span class="c1">// 可以将它设置为等待的当前值，因为任何以前的 waiter 已经在列表中，
</span><span class="c1"></span>	<span class="c1">// 或者会他们在尝试将自己添加到列表时已经收到通知。
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">wait</span><span class="p">))</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 遍历整个本地列表，并 ready 所有的 waiter
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nf">readyWithTime</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="once">Once</h2>
<p>很多人认为实现一个 Once 一样的并发原语很简单,只需使用一个 flag 标记是否初始化过即可,最多是用 atomic 原子操作这个 flag,但是,这个实现有一个很大的问题,就是如果参数 f 执行很慢的话,后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了,但是获取某些初始化资源的时候可能会得到空的资源,因为 f 还没有执行完。</p>
<p>所以,一个正确的 Once 实现要使用一个互斥锁,这样初始化的时候如果有并发的 goroutine,就会进入doSlow 方法。互斥锁的机制保证只有一个 goroutine 进行初始化,同时利用双检查的机制(double-checking),再次判断 o.done 是否为 0,如果为 0,则是第一次执行,执行完毕后,就将 o.done 设置为 1,然后释放锁。</p>
<p>即使此时有多个 goroutine 同时进入了 doSlow 方法,因为双检查的机制,后续的 goroutine 会看到 o.done 的值为 1,也不会再次执行 f。</p>
<p>这样既保证了并发的 goroutine 会等待 f 完成,而且还不会多次执行 f。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Once is an object that will perform exactly one action.
</span><span class="c1">// Once 对象可以保证一个动作的绝对一次执行。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// done indicates whether the action has been performed.
</span><span class="c1"></span>	<span class="c1">// It is first in the struct because it is used in the hot path.
</span><span class="c1"></span>	<span class="c1">// The hot path is inlined at every call site.
</span><span class="c1"></span>	<span class="c1">// Placing done first allows more compact instructions on some architectures (amd64/x86),
</span><span class="c1"></span>	<span class="c1">// and fewer instructions (to calculate offset) on other architectures.
</span><span class="c1"></span>	<span class="c1">// done 表明某个动作是否被执行
</span><span class="c1"></span>	<span class="c1">// 由于其使用频繁（热路径），故将其放在结构体的最上方
</span><span class="c1"></span>	<span class="c1">// 热路径在每个调用点进行内嵌
</span><span class="c1"></span>	<span class="c1">// 将 done 放在第一位，在某些架构下（amd64/x86）能获得更加紧凑的指令，
</span><span class="c1"></span>	<span class="c1">// 而在其他架构下能更少的指令（用于计算其偏移量）。
</span><span class="c1"></span>	<span class="nx">done</span> <span class="kt">uint32</span>
	<span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>

<span class="c1">// Do calls the function f if and only if Do is being called for the
</span><span class="c1">// first time for this instance of Once. In other words, given
</span><span class="c1">// 	var once Once
</span><span class="c1">// if once.Do(f) is called multiple times, only the first call will invoke f,
</span><span class="c1">// even if f has a different value in each invocation. A new instance of
</span><span class="c1">// Once is required for each function to execute.
</span><span class="c1">//
</span><span class="c1">// Do is intended for initialization that must be run exactly once. Since f
</span><span class="c1">// is niladic, it may be necessary to use a function literal to capture the
</span><span class="c1">// arguments to a function to be invoked by Do:
</span><span class="c1">// 	config.once.Do(func() { config.init(filename) })
</span><span class="c1">//
</span><span class="c1">// Because no call to Do returns until the one call to f returns, if f causes
</span><span class="c1">// Do to be called, it will deadlock.
</span><span class="c1">//
</span><span class="c1">// If f panics, Do considers it to have returned; future calls of Do return
</span><span class="c1">// without calling f.
</span><span class="c1">//
</span><span class="c1">// Do 当且仅当第一次调用时，f 会被执行。换句话说，给定
</span><span class="c1">// 	var once Once
</span><span class="c1">// 如果 once.Do(f) 被多次调用则只有第一次会调用 f，即使每次提供的 f 不同。
</span><span class="c1">// 每次执行必须新建一个 Once 实例。
</span><span class="c1">//
</span><span class="c1">// Do 用于变量的一次初始化，由于 f 是无参数的，因此有必要使用函数字面量来捕获参数：
</span><span class="c1">// 	config.once.Do(func() { config.init(filename) })
</span><span class="c1">//
</span><span class="c1">// 因为该调用无返回值，因此如果 f 调用了 Do，则会导致死锁。
</span><span class="c1">//
</span><span class="c1">// 如果 f 发生 panic，则 Do 认为 f 已经返回；之后的调用也不会调用 f。
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// Note: Here is an incorrect implementation of Do:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {
</span><span class="c1"></span>	<span class="c1">//		f()
</span><span class="c1"></span>	<span class="c1">//	}
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do guarantees that when it returns, f has finished.
</span><span class="c1"></span>	<span class="c1">// This implementation would not implement that guarantee:
</span><span class="c1"></span>	<span class="c1">// given two simultaneous calls, the winner of the cas would
</span><span class="c1"></span>	<span class="c1">// call f, and the second would return immediately, without
</span><span class="c1"></span>	<span class="c1">// waiting for the first&#39;s call to f to complete.
</span><span class="c1"></span>	<span class="c1">// This is why the slow path falls back to a mutex, and why
</span><span class="c1"></span>	<span class="c1">// the atomic.StoreUint32 must be delayed until after f returns.
</span><span class="c1"></span>	<span class="c1">// 原子读取 Once 内部的 done 属性，是否为 0，是则进入慢速路径，否则直接调用
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Outlined slow-path to allow inlining of the fast-path.
</span><span class="c1"></span>		<span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// 注意，我们只使用原子读读取了 o.done 的值，这是最快速的路径执行原子操作，即 fast-path
</span><span class="c1"></span>	<span class="c1">// 但当我们需要确保在并发状态下，是不是有多个人读到 0，因此必须加锁，这个操作相对昂贵，即 slow-path
</span><span class="c1"></span>	<span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 双检查
</span><span class="c1"></span>	<span class="c1">// 正好我们有一个并发的 goroutine 读到了 0，那么立即执行 f 并在结束时候调用原子写，将 o.done 修改为 1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nf">f</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 当 o.done 为 0 的 goroutine 解锁后，其他人会继续加锁，这时会发现 o.done 已经为了 1 ，于是 f 已经不用在继续执行了
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="map">Map</h2>
<p>Go 内建的 map 类型不是线程安全的,所以 Go 1.9 中增加了一个线程安全的 map,也就是 sync.Map。但是,我们一定要记住,这个 sync.Map 并不是用来替换内建的 map 类型的,它只能被应用在一些特殊的场景里。</p>
<p>那这些特殊的场景是啥呢?官方的文档中指出,在以下两个场景中使用 sync.Map,会比使用 map+RWMutex 的方式,性能要好得多:</p>
<ol>
<li>只会增长的缓存系统中,一个 key 只写入一次而被读很多次;</li>
<li>多个 goroutine 为不相交的键集读、写和重写键值对.</li>
</ol>
<p>这两个场景说得都比较笼统,而且,这些场景中还包含了一些特殊的情况。所以,官方建议你针对自己的场景做性能评测,如果确实能够显著提高性能,再使用 sync.Map。</p>
<p>sync.Map 的实现有几个优化点,这里先列出来,我们后面慢慢分析。</p>
<ul>
<li>空间换时间。通过冗余的两个数据结构(只读的 read 字段、可写的 dirty),来减少加锁对性能的影响。对只读字段(read)的操作不需要加锁。</li>
<li>优先从 read 字段读取、更新、删除,因为对 read 字段的读取不需要锁。</li>
<li>动态调整。miss 次数多了之后,将 dirty 数据提升为 read,避免总是从 dirty 中加锁读取。</li>
<li>double-checking。加锁之后先还要再检查 read 字段,确定真的不存在才操作 dirty 字段。</li>
<li>延迟删除。删除一个键值只是打标记,只有在提升 dirty 字段为 read 字段的时候才清理删除的数据。</li>
</ul>
<p>通过引入两个map将读写分离到不同的map，其中read map提供并发读和已存元素原子写，而dirty map则负责读写。 这样read map就可以在不加锁的情况下进行并发读取,当read map中没有读取到值时,再加锁进行后续读取,并累加未命中数,当未命中数大于等于dirty map长度,将dirty map上升为read map。虽然引入了两个map，但是底层数据存储的是指针，指向的是同一份值。</p>
<p>下面我们介绍sync.Map的重点代码，以便理解它的实现思想。</p>
<h3 id="map-1">Map</h3>
<p>它的数据结构很简单，值包含四个字段：read、mu、dirty、misses。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Map is like a Go map[interface{}]interface{} but is safe for concurrent use
</span><span class="c1">// by multiple goroutines without additional locking or coordination.
</span><span class="c1">// Loads, stores, and deletes run in amortized constant time.
</span><span class="c1">//
</span><span class="c1">// The Map type is specialized. Most code should use a plain Go map instead,
</span><span class="c1">// with separate locking or coordination, for better type safety and to make it
</span><span class="c1">// easier to maintain other invariants along with the map content.
</span><span class="c1">//
</span><span class="c1">// The Map type is optimized for two common use cases: (1) when the entry for a given
</span><span class="c1">// key is only ever written once but read many times, as in caches that only grow,
</span><span class="c1">// or (2) when multiple goroutines read, write, and overwrite entries for disjoint
</span><span class="c1">// sets of keys. In these two cases, use of a Map may significantly reduce lock
</span><span class="c1">// contention compared to a Go map paired with a separate Mutex or RWMutex.
</span><span class="c1">//
</span><span class="c1">// The zero Map is empty and ready for use. A Map must not be copied after first use.
</span><span class="c1">// Map 是一种并发安全的 map[interface{}]interface{}，在多个 goroutine 中没有额外的锁条件
</span><span class="c1">// 读取、存储和删除操作的时间复杂度平均为常量
</span><span class="c1">//
</span><span class="c1">// Map 类型非常特殊，大部分代码应该使用原始的 Go map。它具有单独的锁或协调以获得类型安全且更易维护。
</span><span class="c1">//
</span><span class="c1">// Map 类型针对两种常见的用例进行优化：
</span><span class="c1">// 1. 给定 key 只会产生写一次但是却会多次读，类似于只增的缓存
</span><span class="c1">// 2. 多个 goroutine 读、写以及覆盖不同的 key
</span><span class="c1">// 这两种情况下，与单独使用 Mutex 或 RWMutex 的 map 相比，会显著降低竞争情况
</span><span class="c1">//
</span><span class="c1">// 零值 Map 为空且可以直接使用，Map 使用后不能复制
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 当涉及到dirty数据的操作的时候，需要使用这个锁
</span><span class="c1"></span>	<span class="nx">mu</span> <span class="nx">Mutex</span>

	<span class="c1">// read contains the portion of the map&#39;s contents that are safe for
</span><span class="c1"></span>	<span class="c1">// concurrent access (with or without mu held).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The read field itself is always safe to load, but must only be stored with
</span><span class="c1"></span>	<span class="c1">// mu held.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Entries stored in read may be updated concurrently without mu, but updating
</span><span class="c1"></span>	<span class="c1">// a previously-expunged entry requires that the entry be copied to the dirty
</span><span class="c1"></span>	<span class="c1">// map and unexpunged with mu held.
</span><span class="c1"></span>	<span class="c1">// 基本上你可以把它看成一个安全的只读的map
</span><span class="c1"></span>	<span class="c1">// 它包含的元素其实也是通过原子操作更新的,但是已删除的entry就需要加锁操作了
</span><span class="c1"></span>	<span class="c1">// 一个只读的数据结构，因为只读，所以不会有读写冲突。
</span><span class="c1"></span>	<span class="c1">// 所以从这个数据中读取总是安全的。
</span><span class="c1"></span>	<span class="c1">// 实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。
</span><span class="c1"></span>	<span class="c1">// read 包含 map 内容的一部分，这些内容对于并发访问是安全的（有或不使用 mu）。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// read 字段 load 总是安全的，但是必须使用 mu 进行 store。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 存储在 read 中的 entry 可以在没有 mu 的情况下并发更新，
</span><span class="c1"></span>	<span class="c1">// 但是更新已经删除的 entry 需要将 entry 复制到 dirty map 中，并使用 mu 进行删除。
</span><span class="c1"></span>	<span class="nx">read</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// readOnly
</span><span class="c1"></span>
	<span class="c1">// dirty contains the portion of the map&#39;s contents that require mu to be
</span><span class="c1"></span>	<span class="c1">// held. To ensure that the dirty map can be promoted to the read map quickly,
</span><span class="c1"></span>	<span class="c1">// it also includes all of the non-expunged entries in the read map.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Expunged entries are not stored in the dirty map. An expunged entry in the
</span><span class="c1"></span>	<span class="c1">// clean map must be unexpunged and added to the dirty map before a new value
</span><span class="c1"></span>	<span class="c1">// can be stored to it.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If the dirty map is nil, the next write to the map will initialize it by
</span><span class="c1"></span>	<span class="c1">// making a shallow copy of the clean map, omitting stale entries.
</span><span class="c1"></span>	<span class="c1">// 包含需要加锁才能访问的元素
</span><span class="c1"></span>	<span class="c1">// 包括所有在read字段中但未被expunged(删除)的元素以及新加的元素
</span><span class="c1"></span>	<span class="c1">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。
</span><span class="c1"></span>	<span class="c1">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。
</span><span class="c1"></span>	<span class="c1">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。
</span><span class="c1"></span>	<span class="c1">// dirty 含了需要 mu 的 map 内容的一部分。为了确保将 dirty map 快速地转为 read map，
</span><span class="c1"></span>	<span class="c1">// 它还包括了 read map 中所有未删除的 entry。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 删除的 entry 不会存储在 dirty map 中。在 clean map 中，被删除的 entry 必须被删除并添加到 dirty 中，
</span><span class="c1"></span>	<span class="c1">// 然后才能将新的值存储为它
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 如果 dirty map 为 nil，则下一次的写行为会通过 clean map 的浅拷贝进行初始化
</span><span class="c1"></span>	<span class="nx">dirty</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span>

	<span class="c1">// misses counts the number of loads since the read map was last updated that
</span><span class="c1"></span>	<span class="c1">// needed to lock mu to determine whether the key was present.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Once enough misses have occurred to cover the cost of copying the dirty
</span><span class="c1"></span>	<span class="c1">// map, the dirty map will be promoted to the read map (in the unamended
</span><span class="c1"></span>	<span class="c1">// state) and the next store to the map will make a new dirty copy.
</span><span class="c1"></span>	<span class="c1">// 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空
</span><span class="c1"></span>	<span class="c1">// misses 的作用就是，当从read读取值没有读取到，从dirty中读取到了，自增加1. 当这种情况达到 m.misses &lt; len(m.dirty)的时候，dirty的值就代替为read.m(read是readOnly),然后misses重置为0，dirty置为nil，重新开始计算值.
</span><span class="c1"></span>	<span class="c1">// misses 计算了从 read map 上一次更新开始的 load 数，需要 lock 以确定 key 是否存在。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 一旦发生足够的 misses 足以囊括复制 dirty map 的成本，dirty map 将被提升为 read map（处于未修改状态）
</span><span class="c1"></span>	<span class="c1">// 并且 map 的下一次 store 将生成新的 dirty 副本。
</span><span class="c1"></span>	<span class="nx">misses</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个结构中，可以看到 read 和 dirty 分别对应两个 map，但 read 的结构比较特殊，是一个 atomic.Value 类型。</p>
<p>从 misses 的描述中可以大致看出 sync.Map 的思路是发生足够多的读时，就将 dirty map 复制一份到 read map 上。 从而实现在 read map 上的读操作不再需要昂贵的 Mutex 操作。</p>
<p>使用了两个map，一个叫read，一个叫dirty，两个map存储的都是指针，指向value数据本身，所以两个map是共享value数据的，更新value对两个map同时可见。</p>
<p>dirty可以进行增删查，当时都要进行加互斥锁。</p>
<p>read中存在的key，可以无锁的读，借助CAS进行无锁的更新、删除操作，但是不能新增key，相当于dirty的一个cache，由于value共享，所以能通过read对已存在的value进行更新。</p>
<p>read不能新增key，那么数据怎么来的呢？sync map中会记录miss cache的次数，当miss次数大于等于dirty元素个数时，就会把dirty变成read，原来的dirty清空。</p>
<p>为了方便dirty直接变成read，那么得保证read中存在的数据dirty必须有，所以在dirty是空的时候，如果要新增一个key，那么会把read中的元素复制到dirty中，然后写入新key。</p>
<p>然后删除操作也很有意思，使用的是延迟删除，优先看read中有没有，read中有，就把read中的对应entry指针中的p置为nil，作为一个标记。在read中标记为nil的，只有在dirty提升为read时才会被实际删除。</p>
<p>如果 dirty 字段非 nil 的话,map 的 read 字段和 dirty 字段会包含相同的非 expunged 的项,所以如果通过 read 字段更改了这个项的值,从 dirty 字段中也会读取到这个项的新值,因为本来它们指向的就是同一个地址。</p>
<p>dirty 包含重复项目的好处就是,一旦 miss 数达到阈值需要将 dirty 提升为 read 的话,只需简单地把 dirty 设置为 read 对象即可。不好的一点就是,当创建新的 dirty 对象的时候,需要逐条遍历 read,把非 expunged 的项复制到 dirty 对象中。</p>
<h3 id="read和dirty">read和dirty</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// readOnly is an immutable struct stored atomically in the Map.read field.
</span><span class="c1">// 当dirty中包含read没有的数据时为true,比如新增一条数据
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">readOnly</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span>       <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span>
	<span class="c1">// amended指明Map.dirty中有readOnly.m未包含的数据，所以如果从Map.read找不到数据的话，还要进一步到Map.dirty中查找。
</span><span class="c1"></span>	<span class="c1">// 如果Map.dirty有些数据不在Read中的时候，这个值为true
</span><span class="c1"></span>	<span class="nx">amended</span> <span class="kt">bool</span> <span class="c1">// true if the dirty map contains some key not in m.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>readOnly.m和Map.dirty存储的值类型是*entry,它包含一个指针p, 指向用户存储的value值。read和dirty中存的实际是key=&gt;值的指针的结构,会存在存了两份值的指针,但不是存了两份值.这样,在用空间换时间的情况下,如果map存的key很多,也不会消耗大量内存,会增加消耗的是指针定义读内存的占用,这比值的占用要小很多.</p>
<ul>
<li>read中的key是readOnly的（key的集合不会变，删除也只是打标记），value的操作全都可以原子完成，所以这个结构不用锁</li>
<li>dirty是一个read的拷贝，用锁的操作在这做，如增加元素、删除元素等（dirty上删除是真删除）</li>
</ul>
<p>read并不是只是读操作,也有原子写操作.在读操作的时候,是使用了atomic.Value的Load(),没有用锁,达到了在线程安全的情况下读性能的大大提高,同时也会把dirty中的对应的值给修改了，因为相同key的entry，在read和dirty中存的是entry的指针，两个指针没有变，指针的值改了，所以read和dirty 对应的entry同时改变。 为什么呢？因为当key不在map中，会进行map新建记录操作，相同的key既会在read中新建，也会在dirty中新建，新建的就是相应entry的指针： key=&gt;*(entry)。这样，当进行update操作时，就直接修改read，而不需要再加锁操作dirty，性能好多了。</p>
<p>而将read中的值同步到dirty或对dirty进行读或写操作时,使用了互斥量锁Mutex. 写操作分为新增和更新.新增的时候,需要把这个值指针存到dirty.更新的时候,更新一个没有被标记过expunged的key,直接对read进行atomic.CompareAndSwapPointer操作就可以,如果之前expunged过,将key同步到dirty. 而在Store、Delete操作的时候,都要进行m.read.Load().(readOnly)操作.根据上文中推荐的文章进行的benchmark的结果,sync.Map的写、删除性能不尽如意,这个结果可以预料到.</p>
<ul>
<li>当dirty不存在的时候，read就是全部map的数据</li>
<li>当dirty存在的时候，dirty才是正确的map数据</li>
</ul>
<p>可以把read看成是一个cache，当cache miss到一定数量的时候，dirty中的数据会被提升到read中去。但是决定哪些数据应该过去实在太费时了，倒不如时间换空间，read中的数据我在dirty中也存一份，提升的时候直接整个赋值就好了~</p>
<p>read相当于cache层，dirty是更底层的数据层，当read多次没有命中数据时，达到条件，这个cache层命中率太低了，直接将整个read用dirty替换，然后dirty又重新为nil，不需要马上将read同步到dirty，而是下一次Store一个新的key的时候，再触发进行一次dirty的初始同步,并且初始同步在dirty的一个生存周期内,只会进行一次.</p>
<p>在进行Store和Load的时候,其实都是先操作read,如果read中存在并且对应值没有被expunged过,就执行返回了,如果read中不存在,或者对应值被expunged,就需要对dirty进行操作,将这个key同步到dirty中.</p>
<h3 id="entry">entry</h3>
<p>read和dirty中的map存的元素值是entry,entry的field是p unsafe.Pointer,是指向具体存储值的指针,这个具体值是以interface{}值存在的,所以在Load取出值的时候,要自行做.(type)的转换.</p>
<p>假设read和dirty中的map存在name这个key,当read进行了atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i))操作后,改的是p这个指针所指的值的地址,而entry这个指针没有改变,read和dirty中的map存在name指的是同一个entry.所以,read中对p的写原子操作,如果dirty中有相同的key,也会同样被更改,因为他们的entry是同一个.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// expunged is an arbitrary pointer that marks entries which have been deleted
</span><span class="c1">// from the dirty map.
</span><span class="c1">// expunged是用来标识此项已经删掉的指针
</span><span class="c1">// 当map中的一个项目被删除了,只是把它的值标记为expunged,以后才有机会真正删除此项
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">expunged</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="kd">interface</span><span class="p">{}))</span>

<span class="c1">// An entry is a slot in the map corresponding to a particular key.
</span><span class="c1">// entry代表一个值
</span><span class="c1">// 只是简单的创建一个 entry
</span><span class="c1">// entry 是一个对应于 map 中特殊 key 的 slot
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// p points to the interface{} value stored for the entry.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If p == nil, the entry has been deleted and m.dirty == nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If p == expunged, the entry has been deleted, m.dirty != nil, and the entry
</span><span class="c1"></span>	<span class="c1">// is missing from m.dirty.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty
</span><span class="c1"></span>	<span class="c1">// != nil, in m.dirty[key].
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// An entry can be deleted by atomic replacement with nil: when m.dirty is
</span><span class="c1"></span>	<span class="c1">// next created, it will atomically replace nil with expunged and leave
</span><span class="c1"></span>	<span class="c1">// m.dirty[key] unset.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// An entry&#39;s associated value can be updated by atomic replacement, provided
</span><span class="c1"></span>	<span class="c1">// p != expunged. If p == expunged, an entry&#39;s associated value can be updated
</span><span class="c1"></span>	<span class="c1">// only after first setting m.dirty[key] = e so that lookups using the dirty
</span><span class="c1"></span>	<span class="c1">// map find the entry.
</span><span class="c1"></span>	<span class="c1">// p 指向 interface{} 类型的值，用于保存 entry
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 如果 p == nil，则 entry 已被删除，且 m.dirty == nil
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 如果 p == expunged, 则 entry 已经被删除，m.dirty != nil ，则 entry 不在 m.dirty 中
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 否则，entry 仍然有效，且被记录在 m.read.m[key] ，但如果 m.dirty != nil，则在 m.dirty[key] 中
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 一个 entry 可以被原子替换为 nil 来删除：当 m.dirty 下一次创建时，它会自动将 nil 替换为 expunged 且
</span><span class="c1"></span>	<span class="c1">// 让 m.dirty[key] 成为未设置的状态。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 与一个 entry 关联的值可以被原子替换式的更新，提供的 p != expunged。如果 p == expunged，
</span><span class="c1"></span>	<span class="c1">// 则与 entry 关联的值只能在 m.dirty[key] = e 设置后被更新，因此会使用 dirty map 来查找 entry。
</span><span class="c1"></span>
	<span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// *interface{}
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">newEntry</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">entry</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">entry</span><span class="p">{</span><span class="nx">p</span><span class="p">:</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">)}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>p有三种值：</p>
<ul>
<li>nil: 表示为被删除，调用Delete()可以将read map中的元素置为nil</li>
<li>expunged: 也是表示被删除，但是该键只在read而没有在dirty中，这种情况出现在将read复制到dirty中，即复制的过程会先将nil标记为expunged，然后不将其复制到dirty</li>
<li>其他: 表示存着真正的数据</li>
</ul>
<h3 id="流程图">流程图</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190125125938.png" alt=""></p>
<h3 id="load">Load</h3>
<p>读取时，先去read读取；如果没有，就加锁，然后去dirty读取，同时调用missLocked()，再解锁。在missLocked中，会递增misses变量，如果misses&gt;len(dirty)，那么把dirty提升为read，清空原来的dirty。</p>
<ol>
<li>如果 read map 中已经找到了该值，则不需要去访问 dirty map（慢）。</li>
<li>但如果没找到，且 dirty map 与 read map 没有差异，则也不需要去访问 dirty map。</li>
<li>如果 dirty map 和 read map 有差异，则我们需要锁住整个 Map，然后再读取一次 read map 来防止并发导致的上一次读取失误</li>
<li>如果锁住后，确实 read map 读取不到且 dirty map 和 read map 一致，则不需要去读 dirty map 了，直接解锁返回。</li>
<li>如果锁住后，read map 读不到，且 dirty map 与 read map 不一致，则该 key 可能在 dirty map 中，我们需要从 dirty map 中读取，并记录一次 miss（在 read map 中 miss）。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Load returns the value stored in the map for a key, or nil if no
</span><span class="c1">// value is present.
</span><span class="c1">// The ok result indicates whether value was found in the map.
</span><span class="c1">// Load 返回了存储在 map 中对应于 key 的值 value，如果不存在则返回 nil
</span><span class="c1">// ok 表示了值能否在 map 中找到
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Load</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 首先从read处理
</span><span class="c1"></span>	<span class="c1">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁
</span><span class="c1"></span>	<span class="c1">// 拿到只读 read map
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="c1">// 从只读 map 中读 key 对应的 value
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="c1">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
		<span class="c1">// 如果不存在并且dirty不为nil(有新的元素)
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// Avoid reporting a spurious miss if m.dirty got promoted while we were
</span><span class="c1"></span>		<span class="c1">// blocked on m.mu. (If further loads of the same key will not miss, it&#39;s
</span><span class="c1"></span>		<span class="c1">// not worth copying the dirty map for this key.)
</span><span class="c1"></span>		<span class="c1">// 双检查,看看read中现在是否存在此key
</span><span class="c1"></span>		<span class="c1">// 双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。
</span><span class="c1"></span>		<span class="c1">// 锁住后，再读一次 read map
</span><span class="c1"></span>		<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
		<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
		<span class="c1">// 如果m.read中还是不存在，并且m.dirty中有新数据
</span><span class="c1"></span>		<span class="c1">// 如果这时 read map 确实读不到，且 dirty map 与 read map 不一致
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="c1">//依然不存在,并且dirty不为nil
</span><span class="c1"></span>			<span class="c1">// 从dirty中读取
</span><span class="c1"></span>			<span class="c1">// 则从 dirty map 中读
</span><span class="c1"></span>			<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
			<span class="c1">// Regardless of whether the entry was present, record a miss: this key
</span><span class="c1"></span>			<span class="c1">// will take the slow path until the dirty map is promoted to the read
</span><span class="c1"></span>			<span class="c1">// map.
</span><span class="c1"></span>			<span class="c1">// 不管m.dirty中存不存在，都将misses计数加一
</span><span class="c1"></span>			<span class="c1">// missLocked()中满足条件后就会提升m.dirty
</span><span class="c1"></span>			<span class="c1">// 无论 entry 是否找到，记录一次 miss：该 key 会采取 slow path 进行读取，直到
</span><span class="c1"></span>			<span class="c1">// dirty map 被提升为 read map。
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nf">missLocked</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 如果 read map 或者 dirty map 中找不到 key，则确实没找到，返回 nil 和 false
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">//返回读取的对象,e既可能是从read中获得的,也可能是从dirty中获得的
</span><span class="c1"></span>	<span class="c1">// 如果找到了，则返回读到的值
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 元素不存在或者被删除，则直接返回
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">load</span><span class="p">()</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 读 entry 的值
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="c1">// 如果值为 nil 或者已经删除
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
		<span class="c1">// 则读不到
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 否则读值
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在代码中，我们可以看到一个double check，检查read没有，上锁，再检查read中有没有，是因为有可能在第一次检查之后，上锁之前的间隙，dirty提升为read了，这时如果不double check，可能会导致一个存在的key却返回给调用方说不存在。 在下面的其他操作中，我们经常会看到这个double check。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，如果我们查询的键值正好存在于m.read中，无须加锁，直接返回，理论上性能优异。即使不存在于m.read中，经过miss几次之后，m.dirty会被提升为m.read，又会从m.read中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p>
<p>如果幸运的话,我们从 read 中读取到了这个 key 对应的值,那么就不需要加锁了,性能会非常好。但是,如果请求的 key 不存在或者是新加的,就需要加锁从 dirty 中读取。所以,读取不存在的 key 会因为加锁而导致性能下降,读取还没有提升的新值的情况下也会因为加锁性能下降。</p>
<p>其中,missLocked 增加 miss 的时候,如果 miss 数等于 dirty 长度,会将 dirty 提升为 read,并将 dirty 置空。</p>
<h4 id="misslocked">missLocked</h4>
<p>当记录 miss 时，涉及 missLocked 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 此方法调用时，整个 map 是锁住的
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">missLocked</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 增加一次 miss
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">misses</span><span class="o">++</span><span class="c1">// misses计数加一
</span><span class="c1"></span>	<span class="c1">// 如果 miss 的次数小于 dirty map 的 key 数
</span><span class="c1"></span>	<span class="c1">// 则直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">misses</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 如果没达到阈值(dirty字段的长度),返回
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 否则将 dirty map 同步到 read map 去
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">})</span>
	<span class="c1">//把dirty字段的内存提升为read字段
</span><span class="c1"></span>	<span class="c1">// 清空 dirty map
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="p">=</span> <span class="kc">nil</span>	<span class="c1">// 清空dirty
</span><span class="c1"></span>	<span class="c1">// miss 计数归零
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">misses</span> <span class="p">=</span> <span class="mi">0</span>	<span class="c1">// misses数重置为0
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出，miss 如果大于了 dirty 所存储的 key 数时，会将 dirty map 同步到 read map，并将自身清空，miss 计数归零。</p>
<p>上面的最后三行代码就是提升m.dirty的，很简单的将m.dirty作为readOnly的m字段，原子更新m.read。提升后m.dirty、m.misses重置，并且m.read.amended为false。</p>
<h3 id="store">Store</h3>
<p>我们先来看 Store 方法,它是用来设置一个键值对,或者更新一个键值对的。</p>
<p>这个方法是更新或者新增一个entry。</p>
<p>read和dirty的相同key指向同一个value</p>
<p>写入的时候，先看read中能否查到key，在read中存在的话，直接通过read中的entry来更新值；在read中不存在，那么就上锁，然后double check。这里需要留意，分几种情况：</p>
<ol>
<li>double check发现read中存在key，如果不是expunged,直接写入值。如果entry.p==expunged,那么就先把expunged替换成nil,并且把e复制到dirty中，再在read中写入值.</li>
<li>read中不存在key,dirty中存在key，直接更新</li>
<li>dirty中不存在key，如果此时dirty为空，那么需要将read复制到dirty中，最后再把新值写入到dirty中。复制的时候调用的是dirtyLocked()，在复制到dirty的时候，read中为nil的元素，会更新为expunged，并且不复制到dirty中</li>
</ol>
<p>我们可以看到，在更新read中的数据时，使用的是tryStore，通过CAS来解决冲突，在CAS出现冲突后，如果发现数据被置为expunge，tryStore那么就不会写入数据，而是会返回false，在Store流程中，就是接着往下走，在dirty中写入。</p>
<p>再看下情况1的时候，为啥要那么做。double check的时候，在read中存在，那么就是说在加锁之前，有并发线程先写入了key，然后由Load触发了dirty提升为read，这时dirty可能为空，也可能不为空，但无论dirty状态如何，都是可以直接更新entry.p。如果是expunged的话，那么要先替换成nil，再复制entry到dirty中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// unexpungeLocked ensures that the entry is not marked as expunged.
</span><span class="c1">//
</span><span class="c1">// If the entry was previously expunged, it must be added to the dirty map
</span><span class="c1">// before m.mu is unlocked.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">unexpungeLocked</span><span class="p">()</span> <span class="p">(</span><span class="nx">wasExpunged</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">expunged</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Store sets the value for a key.
</span><span class="c1">// Store 存储 key 对应的 value
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。
</span><span class="c1"></span>	<span class="c1">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。
</span><span class="c1"></span>	<span class="c1">// 获得 read map
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="c1">// 如果read字段包含这个项,说明是更新,cas更新项目的值即可
</span><span class="c1"></span>	<span class="c1">// 首先发生的是更新已经存在值的情况： 更新操作直接更新 read map 中的值，如果成功则不需要进行任何操作，如果没有成功才继续处理。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryStore</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// read中不存在,或者cas更新失败,就需要加锁访问dirty了
</span><span class="c1"></span>	<span class="c1">// 如果`m.read`不存在或者已经被标记删除(设置为空标记)
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// 经过刚才的一系列操作，read map 可能已经更新了
</span><span class="c1"></span>	<span class="c1">// 因此需要再读一次
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="c1">// 修改一个已经存在的值
</span><span class="c1"></span>	<span class="c1">// 读取 read map 中的值
</span><span class="c1"></span>	<span class="c1">// 如果读到了，则尝试更新 read map 的值，如果更新成功，则直接返回，否则还要继续处理（当且仅当要更新的值被标记为删除）
</span><span class="c1"></span>	<span class="c1">// 如果没读到，则还要继续处理（read map 中不存在）
</span><span class="c1"></span>	<span class="c1">// 双检查,看看read是否已经存在了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 这种情况下，本质上还分两种情况：
</span><span class="c1"></span>		<span class="c1">// 1. 可能因为是一个已经删除的值（之前的 tryStore 失败）
</span><span class="c1"></span>		<span class="c1">// 2. 可能先前仅保存在 dirty map 然后同步到了 read map（这是可能的，我们后面读 Load 时再来分析 dirty map 是如何同步到 read map 的）
</span><span class="c1"></span>		<span class="c1">// 对于第一种而言，我们需要重新将这个已经删除的值标记为没有删除，然后将这个值同步回 dirty map（删除操作只删除 dirty map，之后再说） 对于第二种状态，我们直接更新 read map，不需要打扰 dirty map。
</span><span class="c1"></span>		<span class="c1">//read中存在该key,e为值,也就是说可以确定该key是被标记清除了
</span><span class="c1"></span>		<span class="c1">// unexpungeLocked确保条目标记为未清除。
</span><span class="c1"></span>		<span class="c1">// 修改一个已经存在的值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nf">unexpungeLocked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 此项目先前已经被删除了,通过将它的值设置为nil,标记为unexpunged
</span><span class="c1"></span>			<span class="c1">// 说明 entry 先前是被标记为删除了的，现在我们又要存储它，只能向 dirty map 进行更新了
</span><span class="c1"></span>			<span class="c1">// The entry was previously expunged, which implies that there is a
</span><span class="c1"></span>			<span class="c1">// non-nil dirty map and this entry is not in it.
</span><span class="c1"></span>			<span class="c1">// 更新 dirty map 的值即可
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
			<span class="c1">//m.dirty中不存在这个value，所以加入m.dirty,因为read是只读,不能进行操作
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 更新
</span><span class="c1"></span>		<span class="c1">// 无论先前删除与否，都要更新 read map
</span><span class="c1"></span>		<span class="nx">e</span><span class="p">.</span><span class="nf">storeLocked</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果dirty中有此项
</span><span class="c1"></span>		<span class="c1">// 直接更新
</span><span class="c1"></span>		<span class="c1">// 此时read map没有该元素，但是dirty map有该元素，必须修改dirty map元素值为最新值
</span><span class="c1"></span>		<span class="nx">e</span><span class="p">.</span><span class="nf">storeLocked</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 否则就是一个新的key
</span><span class="c1"></span>		<span class="c1">// 如果m.dirty中没有新的数据
</span><span class="c1"></span>		<span class="c1">// 如果 dirty map 里没有 read map 没有的值（两者相同）
</span><span class="c1"></span>		<span class="c1">// 如果 read map 和 dirty map 中存储的内容是相同的，那么我们这次存储新的数据 只会存储在 dirty map 中，因此会造成 read map 和 dirty map 的不一致。
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="c1">// 首次添加一个新的值到 dirty map 中
</span><span class="c1"></span>			<span class="c1">// 确保已被分配并标记为 read map 是不完备的(dirty map 有 read map 没有的)
</span><span class="c1"></span>			<span class="c1">//从m.read中复制未删除的数据
</span><span class="c1"></span>			<span class="c1">//如果dirty为nil
</span><span class="c1"></span>			<span class="c1">// We&#39;re adding the first new key to the dirty map.
</span><span class="c1"></span>			<span class="c1">// Make sure it is allocated and mark the read-only map as incomplete.
</span><span class="c1"></span>			<span class="c1">// 需要创建dirty对象,并且标记read的amended为true,
</span><span class="c1"></span>			<span class="c1">// 说明有元素它不包含而dirty包含
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nf">dirtyLocked</span><span class="p">()</span>
			<span class="c1">// 更新 amended，标记 read map 中缺少了值（标记为两者不同）
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">amended</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
		<span class="p">}</span>
		<span class="c1">//将新值增加到dirty对象中
</span><span class="c1"></span>		<span class="c1">//m.dirty中没有新的数据，往m.dirty中增加第一个新键
</span><span class="c1"></span>		<span class="c1">//将这个entry加入到m.dirty中
</span><span class="c1"></span>		<span class="c1">// 不管 read map 和 dirty map 相同与否，正式保存新的值
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newEntry</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 解锁，有人认为锁的范围有点大，假设read map数据很大，那么执行m.dirtyLocked()会耗费花时间较多，完全可以在操作dirty map时才加锁，这样的想法是不对的，因为m.dirtyLocked()中有写入操作
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="trystore">tryStore</h4>
<p>我们来看一下 tryStore。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// tryStore 在 entry 还没有被删除的情况下存储其值
</span><span class="c1">//
</span><span class="c1">// 如果 entry 被删除了，则 tryStore 返回 false 且不修改 entry
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">tryStore</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 获取对应Key的元素，判断是否标识为删除,因为并发问题,这里也需要二次检查确认
</span><span class="c1"></span>	<span class="c1">// 读取 entry
</span><span class="c1"></span>    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="c1">// 如果 entry 已经删除，则无法存储，返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// cas尝试写入新元素值
</span><span class="c1"></span>		<span class="c1">// 交换 p 和 i 的值，如果成功则立即返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="c1">// 判断是否标识为删除
</span><span class="c1"></span>        <span class="nx">p</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从 tryStore 可以看出，在更新操作中只要没有发生 key 的删除情况，即值已经在 dirty map 中标记为删除， 更新操作一定只更新到 read map 中，不涉及与 dirty map 之间的数据同步。</p>
<h4 id="dirtylocked">dirtyLocked</h4>
<p>read map 和 dirty map 相同的情况，首先调用 dirtyLocked()。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">//新加的元素需要放入到 dirty 中,如果 dirty 为 nil,那么需要从 read 字段中复制出来一个 dirty 对象
</span><span class="c1">//从m.read中复制未删除的数据(如此做的原因在于删除的时候如果read map存在该元素且read的amended==false：直接将read中的元素置为nil。还有一种情况是read map和dirty map同时存在该元素：将read map中的元素置为nil，因为read map和dirty map 使用的均为元素地址，所以均被置为nil。)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">dirtyLocked</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 如果 dirty map 为空，则一切都很好，返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// 如果dirty字段已经存在,不需要创建了
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 获得 read map
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="c1">// 创建一个与 read map 大小一样的 dirty map
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">))</span>
	<span class="c1">// 依次将 read map 的值复制到 dirty map 中。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">e</span><span class="p">.</span><span class="nf">tryExpungeLocked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 把非punged的键值对复制到dirty中
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//尝试将已经删除的标记设置为nil标记
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">tryExpungeLocked</span><span class="p">()</span> <span class="p">(</span><span class="nx">isExpunged</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 获取 entry 的值
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="c1">// 如果 entry 值是 nil
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 将已经删除标记为nil的数据标记为expunged
</span><span class="c1"></span>		<span class="c1">// 检查是否被标记为已经删除
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">expunged</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 成功交换，说明被标记为删除
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="c1">// 删除操作失败，说明 expunged 是 nil，则重新读取一下
</span><span class="c1"></span>		<span class="nx">p</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 直到读到的 p不为 nil 时，则判断是否是标记为删除的对象
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span>
<span class="p">}</span>

<span class="c1">// expunged是一个任意指针，用于标记已删除的条目
</span><span class="c1">//来自dirty map
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">expunged</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="kd">interface</span><span class="p">{}))</span>
<span class="c1">// unexpungeLocked确保条目标记为未清除。
</span><span class="c1">//如果该条目先前已被清除，则必须将其添加到dirty map中
</span><span class="c1">//在m.mu解锁之前
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">unexpungeLocked</span><span class="p">()</span> <span class="p">(</span><span class="nx">wasExpunged</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">expunged</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// storeLocked无条件地将值存储到条目中。
</span><span class="c1">//必须知道该条目不被删除。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">storeLocked</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="p">}</span>


</code></pre></td></tr></table>
</div>
</div><h4 id="小结">小结</h4>
<p>小结一下：</p>
<ul>
<li>存储过程遵循互不影响的原则，如果在 read map 中读到，则只更新 read map，如果在 dirty map 中读到，则只更新 dirty map。</li>
<li>优先从 read map 中读，更新失败才读 dirty map。</li>
<li>存储新值的时候，如果 dirty map 中没有 read map 中的值，那么直接将整个 read map 同步到 dirty map。这时原来的 dirty map 被彻底覆盖（一些值依赖 GC 进行清理）。</li>
</ul>
<p>可以看出,Store 既可以是新增元素,也可以是更新元素。如果运气好的话,更新的是已存在的未被删除的元素,直接更新即可,不会用到锁。如果运气不好,需要更新(重用) 删除的对象、更新还未提升的 dirty 中的对象,或者新增加元素的时候就会使用到了锁,这个时候,性能就会下降。</p>
<p>所以从这一点来看,sync.Map 适合那些只会增长的缓存系统,可以进行更新,但是不要删除,并且不要频繁地增加新元素。</p>
<p>你可以看到，以上操作都是先从操作m.read开始的，不满足条件再加锁，然后操作m.dirty。</p>
<p>Store可能会在某种情况下(初始化或者m.dirty刚被提升后)从m.read中复制数据(函数dirtyLocked)，如果这个时候m.read中数据量非常大，可能会影响性能。</p>
<h3 id="delete">Delete</h3>
<p>sync.map 的第 3 个核心方法是 Delete 方法。在 Go 1.15 中欧长坤提供了一个 LoadAndDelete 的实现,所以 Delete 方法的核心改在了对 LoadAndDelete 中实现了。</p>
<p>删除元素,采用延迟删除，当read map存在元素时，将元素置为nil，只有在提升dirty的时候才清理删除的数,延迟删除可以避免后续获取删除的元素时候需要加锁。当read map不存在元素时，直接删除dirty map中的元素</p>
<p>同样，删除操作还是从m.read中开始，如果这个entry不存在于m.read中，并且m.dirty中有新数据，则加锁尝试从m.dirty中删除。注意，还是要双检查的。 从m.dirty中直接删除即可，就当它没存在过.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Delete deletes the value for a key.
</span><span class="c1">// Delete 删除 key 对应的 value
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">LoadAndDelete</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// LoadAndDelete deletes the value for a key, returning the previous value if any.
</span><span class="c1">// The loaded result reports whether the key was present.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadAndDelete</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 1. 从read map中查找，如果存在，则置为nil
</span><span class="c1"></span>	<span class="c1">// 获得 read map
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="c1">// 从 read map 中读取需要删除的 key
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="c1">// 如果 read map 中没找到，且 read map 与 dirty map 不一致
</span><span class="c1"></span>	<span class="c1">// 说明要删除的值在 dirty map 中
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
		<span class="c1">// 在 dirty map 中需要加锁
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// 第二次检测
</span><span class="c1"></span>		<span class="c1">// 再次读 read map
</span><span class="c1"></span>		<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
		<span class="c1">// 从 read map 中取值
</span><span class="c1"></span>		<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
		<span class="c1">// 没取到，read map 和 dirty map 不一致
</span><span class="c1"></span>		<span class="c1">// 2. 如果read map中不存在，但dirty map中存在，则直接从dirty map删除
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
			<span class="c1">// 这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收
</span><span class="c1"></span>			<span class="c1">// 删除 dierty map 的值
</span><span class="c1"></span>			<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="c1">// Regardless of whether the entry was present, record a miss: this key
</span><span class="c1"></span>			<span class="c1">// will take the slow path until the dirty map is promoted to the read
</span><span class="c1"></span>			<span class="c1">// map.
</span><span class="c1"></span>			<span class="c1">// miss数加1
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nf">missLocked</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nb">delete</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="c1">// 但是如果是从m.read中删除，并不会直接删除，而是打标记,因为read map和dirty map 使用的均为元素地址，所以均被置为nil
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nb">delete</span><span class="p">()</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 读取 entry 的值
</span><span class="c1"></span>		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
		<span class="c1">// 已标记为删除
</span><span class="c1"></span>		<span class="c1">// 如果 p 等于 nil，或者 p 已经标记删除
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
			<span class="c1">// 则不需要删除
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 原子操作，e.p标记为nil
</span><span class="c1"></span>		<span class="c1">// 否则，将 p 的值与 nil 进行原子换
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 删除成功（本质只是解除引用，实际上是留给 GC 清理）
</span><span class="c1"></span>			<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从实现上来看，删除操作相对简单，当需要删除一个值时，移除 read map 中的值，本质上仅仅只是解除对变量的引用。 实际的回收是由 GC 进行处理。 如果 read map 中并未找到要删除的值，才会去尝试删除 dirty map 中的值。</p>
<p>如果 read 中不存在,那么就需要从 dirty 中寻找这个项目。最终,如果项目存在就删除(将它的值标记为 nil)。如果项目不为 nil 或者没有被标记为 expunged,那么还可以把它的值返回。</p>
<h3 id="loadorstore">LoadOrStore</h3>
<p>如果对应的元素存在，则返回该元素的值，如果不存在，则将元素写入到sync.Map。如果已加载值，则加载结果为true;如果已存储，则为false。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// LoadOrStore 在 key 已经存在时，返回存在的值，否则存储当前给定的值
</span><span class="c1">// loaded 为 true 表示 actual 读取成功，否则为 false 表示 value 存储成功
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">actual</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 不加锁的情况下读取read map
</span><span class="c1"></span>    <span class="c1">// 第一次检测
</span><span class="c1"></span>	<span class="c1">// 读 read map
</span><span class="c1"></span>    <span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="c1">// 如果 read map 中已经读到
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="c1">// 如果元素存在（是否标识为删除由tryLoadOrStore执行处理），尝试获取该元素已存在的值或者将元素写入
</span><span class="c1"></span>		<span class="c1">// 尝试存储（可能 key 是一个已删除的 key）
</span><span class="c1"></span>        <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="c1">// 如果存储成功，则直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="c1">// 否则，涉及 dirty map，加锁
</span><span class="c1"></span>    <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="c1">// 第二次检测
</span><span class="c1"></span>    <span class="c1">// 以下逻辑参看Store
</span><span class="c1"></span>	<span class="c1">// 再读一次 read map
</span><span class="c1"></span>    <span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果 read map 中已经读到，则看该值是否被删除
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nf">unexpungeLocked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 没有被删除，则通过 dirty map 存
</span><span class="c1"></span>            <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
        <span class="p">}</span>
        <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果 read map 没找到, dirty map 找到了
</span><span class="c1"></span>		<span class="c1">// 尝试 laod or store，并记录 miss
</span><span class="c1"></span>        <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
        <span class="nx">m</span><span class="p">.</span><span class="nf">missLocked</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 否则就是存一个新的值
</span><span class="c1"></span>		<span class="c1">// 如果 read map 和 dirty map 相同，则开始标记不同
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
            <span class="nx">m</span><span class="p">.</span><span class="nf">dirtyLocked</span><span class="p">()</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">amended</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
        <span class="p">}</span>
		<span class="c1">// 存到 dirty map 中去
</span><span class="c1"></span>        <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newEntry</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
        <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span> <span class="p">=</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 返回存取状态
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有删除元素，tryLoadOrStore将自动加载或存储一个值。如果删除元素，tryLoadOrStore保持条目不变并返回ok= false。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">actual</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
    <span class="c1">// 元素标识删除，直接返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// 存在该元素真实值，则直接返回原来的元素值
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="c1">// 如果p为nil(此处的nil，并是不是指元素的值为nil，而是atomic.LoadPointer(&amp;e.p)为nil，元素的nil在unsafe.Pointer是有值的)，则更新该元素值
</span><span class="c1"></span>    <span class="nx">ic</span> <span class="o">:=</span> <span class="nx">i</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ic</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">i</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="nx">p</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="range">Range</h3>
<p>因为for &hellip; range map是内建的语言特性，所以没有办法使用for range遍历sync.Map, 但是可以使用它的Range方法，通过回调的方式遍历。</p>
<p>遍历获取sync.Map中所有的元素，使用的为快照方式，所以不一定是准确的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Range 为每个 key 顺序的调用 f。如果 f 返回 false，则 range 会停止迭代。
</span><span class="c1">//
</span><span class="c1">// Range 的时间复杂度可能会是 O(N) 即便是 f 返回 false。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 第一检测
</span><span class="c1"></span>	<span class="c1">// 读取 read map
</span><span class="c1"></span>    <span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
    <span class="c1">// read.amended=true,说明dirty map包含所有有效的元素（含新加，不含被删除的），使用dirty map
</span><span class="c1"></span>	<span class="c1">// 如果 read map 和 dirty map 不一致，则需要进一步操作
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
        <span class="c1">// 第二检测
</span><span class="c1"></span>        <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// 再读一次，如果还是不一致，则将 dirty map 提升为 read map
</span><span class="c1"></span>        <span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
            <span class="c1">// 使用dirty map并且升级为read map
</span><span class="c1"></span>            <span class="nx">read</span> <span class="p">=</span> <span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">}</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">read</span><span class="p">)</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="p">=</span> <span class="kc">nil</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">misses</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="p">}</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 一贯原则，使用read map作为读
</span><span class="c1"></span>	<span class="c1">// 在 read 变量中读（可能是 read map ，也可能是 dirty map 同步过来的 map）
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="c1">// 读 readOnly，load 会检查该值是否被标记为删除
</span><span class="c1"></span>        <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span>
		<span class="c1">// 如果已经删除，则跳过
</span><span class="c1"></span>        <span class="c1">// 被删除的不计入
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 函数返回false，终止
</span><span class="c1"></span>		<span class="c1">// 如果 f 返回 false，则停止迭代
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">f</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>既然要 Range 整个 map，则需要考虑 dirty map 与 read map 不一致的问题，如果不一致，则直接将 dirty map 同步到 read map 中。</p>
<p>Range方法调用前可能会做一个m.dirty的提升，不过提升m.dirty不是一个耗时的操作。</p>
<h3 id="补全len">补全Len</h3>
<p>sync.Map没有提供获取元素个数的Len()方法，不过可以通过Range()实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Len</span><span class="p">(</span><span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">lengh</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="nx">lengh</span><span class="o">++</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="nx">one</span><span class="o">:=</span><span class="nx">lengh</span>
    <span class="nx">lengh</span><span class="p">=</span><span class="mi">0</span>
    <span class="nx">sm</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">one</span> <span class="o">!=</span> <span class="nx">lengh</span> <span class="p">{</span>
        <span class="nx">one</span> <span class="p">=</span> <span class="nx">lengh</span>
        <span class="nx">lengh</span><span class="p">=</span><span class="mi">0</span>
        <span class="nx">sm</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">one</span> <span class="p">&lt;</span><span class="nx">lengh</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">lengh</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">one</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="小结-1">小结</h3>
<p>我们来回顾一下 sync.Map 中 read map 和 dirty map 的同步过程：</p>
<ol>
<li>当 Store 一个新值会发生：read map –&gt; dirty map</li>
<li>dirty map –&gt; read map：当 read map 进行 Load 失败 len(dirty map) 次之后发生</li>
</ol>
<p>因此，无论是存储还是读取，read map 中的值一定能在 dirty map 中找到。无论两者如何同步，sync.Map 通过 entry 指针操作， 保证数据永远只有一份，一旦 read map 中的值修改，dirty map 中保存的指针就能直接读到修改后的值。</p>
<p>当存储新值时，一定发生在 dirty map 中。当读取旧值时，如果 read map 读到则直接返回，如果没有读到，则尝试加锁去 dirty map 中取。 这也就是官方宣称的 sync.Map 适用于一次写入多次读取的情景。</p>
<h3 id="syncmap的适用场景">sync.Map的适用场景</h3>
<p>sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>
<p>总结一下，sync.Map像是一个不够完善的容器，比起已有的map主要存在以下不足：</p>
<ol>
<li>低并发情况下的性能不足</li>
<li>冗余数据</li>
<li>缺少类型安全控制</li>
<li>有限的api。比如不支持len操作</li>
</ol>
<p>它针对keys长时间没有变化且只有很少的稳态存储的，或者每一个Goroutine中有一个本地存储的key的并发循环使用做了优化。</p>
<p>对于不共享这些属性的使用场景，使用它同与使用sys.RWMutex保护的内置map相比可能有更差的性能表现，以及更差的类型安全。</p>
<p>经过了上面的分析可以得到,sync.Map并不适合同时存在大量读写的场景(这里的写是指新增和删除key, 修改key还是用的原子性操作),大量的写会导致read map读取不到数据从而加锁进行进一步读取,同时dirty map不断升级为read map。 从而导致整体性能较低,特别是针对cache场景.针对append-only以及大量读,少量写场景使用sync.Map则相对比较合适。</p>
<p>所以如我在前面理解的，如果我使用内置map显示出了数据竞争迹象同时map的key在整个应用程序的生命周期内不会经常变换，我可能会考虑使用sync.Map。对我来说，通俗的讲这个就是一个只有少量更新的高并发读取场景，或者只在一些突发情况下会发生大规模更新的场景。对我来说，通俗的讲这个就是一个只有少量更新的高并发读取场景，或者只在一些突发情况下会发生大规模更新的场景。</p>
<p>第一个benchmark显示了使用与sync.RWMutex一起的常规map与sync.Map之间写数据的比较：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">ind</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">i</span> <span class="p">{</span>
        <span class="nx">i</span><span class="p">[</span><span class="nx">ind</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkStoreRegular</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="nx">rm</span> <span class="o">:=</span> <span class="nf">NewRegularIntMap</span><span class="p">()</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">rm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkStoreSync</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">sm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">BenchmarkStoreRegular-32                     5000000           319 ns/op
</span><span class="cm">BenchmarkStoreSync-32                        1000000          1146 ns/op
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是删除操作的benchmark：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkDeleteRegular</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="nx">rm</span> <span class="o">:=</span> <span class="nf">NewRegularIntMap</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">rm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">rm</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkDeleteSync</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">sm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">sm</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">BenchmarkDeleteRegular-32                   10000000           238 ns/op
</span><span class="cm">BenchmarkDeleteSync-32                       5000000           393 ns/op
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是读数据的benchmark，其中叫Found用例总是能够从map中读取到数据，叫NotFound的用例则几乎总是读取不到数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkLoadRegularFound</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="nx">rm</span> <span class="o">:=</span> <span class="nf">NewRegularIntMap</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">rm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">currentResult</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">rm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="nx">globalResult</span> <span class="p">=</span> <span class="nx">currentResult</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkLoadRegularNotFound</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="nx">rm</span> <span class="o">:=</span> <span class="nf">NewRegularIntMap</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">rm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">currentResult</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">rm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">globalResult</span> <span class="p">=</span> <span class="nx">currentResult</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkLoadSyncFound</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">sm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">currentResult</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">globalResult</span> <span class="p">=</span> <span class="nx">currentResult</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkLoadSyncNotFound</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span> <span class="o">:=</span> <span class="nf">nrand</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
        <span class="nx">sm</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">currentResult</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">globalResult</span> <span class="p">=</span> <span class="nx">currentResult</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">BenchmarkLoadRegularFound-32                10000000           180 ns/op
</span><span class="cm">BenchmarkLoadRegularNotFound-32             20000000           107 ns/op
</span><span class="cm">BenchmarkLoadSyncFound-32                   10000000           200 ns/op
</span><span class="cm">BenchmarkLoadSyncNotFound-32                20000000           291 ns/op
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>正如你所看到的，这些benchmark中的所有用例中使用sync.RWMutex保护的常规map的性能都远胜于sync.Map。并且到目前为止，我们还没有将benchmark引入到多个goroutines中。让我们继续讨论这个问题，让我们看看夸核扩展成为一个因子后设计的benchmark性能如何。</p>
<p>让我们来使用Digital Ocean上的一个32核的虚拟机看看趋势是怎么样的。</p>
<p>对于这个benchmark，我想在当前的理想场景下测量基于两种map的实现的性能。在这个场景下，我将构建存储一组随机数据的两中map，并且我将在每个benchmark中使用不同的<em>GOMAXPROCS</em>并且创建与GOMAXPROCS数量相同的goroutines来执行。</p>
<p>再次，我将运行这些测试来模拟一个高读取场景，所以在benchmark时钟开始之前map内容就已经被构建并固定了。在这篇的文章的下一次更新中，我可能会创建一个benchmark来模拟固定数量的写入，但是现在让我们考虑这个有点人造的但是理想的用例。</p>
<p>接下来是我将如何定义这些并发的benmarks，但是首先概要的说明下代码：</p>
<p>这些benchmarks实际是一些被其他函数调用的函数，在调用函数中我们写死了workerCount。这样我们就能为每个benchmark配置GOMAXPROCS和workers的数量。</p>
<p>确保我们不会遇到Go编译器的优化，我们捕获了Load方法的输出。我们并不关心Load的结果，只是确保编译器不会因为我们未使用输出结果而将代码判断为死代码并将这段代码移除。</p>
<p>代码的主要部分将启动一个goroutine作为worker，它将通过使用b.N值来尽可能的的迭代满足Go benchmark的条件。随着每个goroutines的运行，我们执行我们的Load操作，最后使用sync.WaitGroup来通知goroutine的结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">benchmarkRegularStableKeys</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">workerCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="nx">rm</span> <span class="o">:=</span> <span class="nf">NewRegularIntMap</span><span class="p">()</span>
    <span class="nf">populateMap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">,</span> <span class="nx">rm</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="c1">// Holds our final results, to prevent compiler optimizations.
</span><span class="c1"></span>    <span class="nx">globalResultChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workerCount</span><span class="p">)</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">wc</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">wc</span> <span class="p">&lt;</span> <span class="nx">workerCount</span><span class="p">;</span> <span class="nx">wc</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">currentResult</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">rm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">globalResultChan</span> <span class="o">&lt;-</span> <span class="nx">currentResult</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">benchmarkSyncStableKeys</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">workerCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
    <span class="nf">populateSyncMap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sm</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="c1">// Holds our final results, to prevent compiler optimizations.
</span><span class="c1"></span>    <span class="nx">globalResultChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workerCount</span><span class="p">)</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">wc</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">wc</span> <span class="p">&lt;</span> <span class="nx">workerCount</span><span class="p">;</span> <span class="nx">wc</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
                    <span class="nx">currentResult</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">globalResultChan</span> <span class="o">&lt;-</span> <span class="nx">currentResult</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">benchmarkRegularStableKeysFound</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">workerCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="nx">rm</span> <span class="o">:=</span> <span class="nf">NewRegularIntMap</span><span class="p">()</span>
    <span class="nx">values</span> <span class="o">:=</span> <span class="nf">populateMap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">,</span> <span class="nx">rm</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="c1">// Holds our final results, to prevent compiler optimizations.
</span><span class="c1"></span>    <span class="nx">globalResultChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workerCount</span><span class="p">)</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">wc</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">wc</span> <span class="p">&lt;</span> <span class="nx">workerCount</span><span class="p">;</span> <span class="nx">wc</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">currentResult</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">rm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
            <span class="p">}</span>
            <span class="nx">globalResultChan</span> <span class="o">&lt;-</span> <span class="nx">currentResult</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">benchmarkSyncStableKeysFound</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">workerCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">sm</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
    <span class="nx">values</span> <span class="o">:=</span> <span class="nf">populateSyncMap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sm</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">workerCount</span><span class="p">)</span>

    <span class="c1">// Holds our final results, to prevent compiler optimizations.
</span><span class="c1"></span>    <span class="nx">globalResultChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">workerCount</span><span class="p">)</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">wc</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">wc</span> <span class="p">&lt;</span> <span class="nx">workerCount</span><span class="p">;</span> <span class="nx">wc</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">currentResult</span> <span class="o">:=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">r</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
                    <span class="nx">currentResult</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">globalResultChan</span> <span class="o">&lt;-</span> <span class="nx">currentResult</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">// These tests do a lookup using a literal value.
</span><span class="cm">// Regular Map backed by RWMutex
</span><span class="cm">BenchmarkRegularStableKeys1-32              50000000            30.5 ns/op
</span><span class="cm">BenchmarkRegularStableKeys2-32              10000000           157 ns/op
</span><span class="cm">BenchmarkRegularStableKeys4-32               5000000           377 ns/op
</span><span class="cm">BenchmarkRegularStableKeys8-32               2000000           701 ns/op
</span><span class="cm">BenchmarkRegularStableKeys16-32              1000000          1446 ns/op
</span><span class="cm">BenchmarkRegularStableKeys32-32               500000          2825 ns/op
</span><span class="cm">BenchmarkRegularStableKeys64-32               200000          5699 ns/op
</span><span class="cm">// Sync Map
</span><span class="cm">BenchmarkSyncStableKeys1-32                 20000000            89.3 ns/op
</span><span class="cm">BenchmarkSyncStableKeys2-32                 20000000           101 ns/op
</span><span class="cm">BenchmarkSyncStableKeys4-32                  5000000           247 ns/op
</span><span class="cm">BenchmarkSyncStableKeys8-32                  5000000           330 ns/op
</span><span class="cm">BenchmarkSyncStableKeys16-32                 5000000           295 ns/op
</span><span class="cm">BenchmarkSyncStableKeys32-32                 5000000           269 ns/op
</span><span class="cm">BenchmarkSyncStableKeys64-32                 5000000           249 ns/op
</span><span class="cm">// These tests do a lookup of keys already defined in the map per iteration.
</span><span class="cm">// Regular Map backed by RWMutex
</span><span class="cm">BenchmarkRegularStableKeysFound1-32         20000000           114 ns/op
</span><span class="cm">BenchmarkRegularStableKeysFound2-32         10000000           203 ns/op
</span><span class="cm">BenchmarkRegularStableKeysFound4-32          3000000           460 ns/op
</span><span class="cm">BenchmarkRegularStableKeysFound8-32          2000000           976 ns/op
</span><span class="cm">BenchmarkRegularStableKeysFound16-32         1000000          1895 ns/op
</span><span class="cm">BenchmarkRegularStableKeysFound32-32          300000          3620 ns/op
</span><span class="cm">BenchmarkRegularStableKeysFound64-32          200000          6762 ns/op
</span><span class="cm">// Sync Map
</span><span class="cm">BenchmarkSyncStableKeysFound1-32             5000000           357 ns/op
</span><span class="cm">BenchmarkSyncStableKeysFound2-32             3000000           446 ns/op
</span><span class="cm">BenchmarkSyncStableKeysFound4-32             3000000           501 ns/op
</span><span class="cm">BenchmarkSyncStableKeysFound8-32             3000000           576 ns/op
</span><span class="cm">BenchmarkSyncStableKeysFound16-32            2000000           566 ns/op
</span><span class="cm">BenchmarkSyncStableKeysFound32-32            3000000           527 ns/op
</span><span class="cm">BenchmarkSyncStableKeysFound64-32            2000000           873 ns/op
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190125125715.png" alt=""></p>
<p>正如你所看到的，在使用sync.RWMutex保护的常规map上我们有很好的性能表现。事情一直沿着很好的方向在发展，但是到我们开始使用4核时情况就变了。在4核时，不仅数据竞争开始变成问题，就连我们夸核的扩展因子也是一个问题了。如果你是看的红线，当我们的CPU到8核的时候，你就可以忘了这根线了。在这个点上使用RWMutex我们有太多的读竞争，以至于到32核时性能受到很大影响。</p>
<p>蓝线表现的是sync.Map则展示了一个可预测的行为，因为我们持续的在扩展我们的核数。至此，我可以说基于我的初步测试和分析我们知道了sync.Map的发光点在哪儿。这个理想场景就是为它而建的。</p>
<h3 id="警告不要拷贝syncmap">警告:不要拷贝sync.Map</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">m</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">key</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
			<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">n</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">key</span> <span class="o">==</span> <span class="nx">value</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码会报panic,原因在于创建完成的 sync.Map 是线程安全的，但是经过拷贝之后，两个 sync.Map 里面存储的是同一个 map（就是那个原生的，线程不安全的 map）， mutex 无法起到保护作用，就线程不安全了。</p>
<p>但是如果真的要拷贝这个 sync.Map 应该怎么办呢？ 那就只能再创建一个，然后 Range 老的 Map 一个个把 KV 拷进去了。</p>
<h2 id="pool">Pool</h2>
<p>sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里加粗的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且,如果没有别的对象引用这个被移除的对象的话,这个被移除的对象就会被垃圾回收掉.</p>
<p>因为 Pool 可以有效地减少新对象的申请,从而提高程序性能,所以 Go 内部库也用到了 sync.Pool,比如 fmt 包,它会使用一个动态大小的 buffer 池做输出缓存,当大量的 goroutine 并发输出的时候,就会创建比较多的 buffer,并且在不需要的时候回收掉。</p>
<p>有两个知识点你需要记住:</p>
<ol>
<li>sync.Pool 本身就是线程安全的,多个 goroutine 可以并发地调用它的方法存取对象;</li>
<li>sync.Pool 不可在使用之后再复制使用。</li>
</ol>
<h3 id="pool-1">Pool</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210126160150.png" alt=""></p>
<p>Pool 最重要的两个字段是 local 和 victim,因为它们两个主要用来存储空闲的元素。弄清楚这两个字段的处理逻辑,你就能完全掌握 sync.Pool 的实现了。下面我们来看看这两个字段的关系。</p>
<p>每次垃圾回收的时候,Pool 会把 victim 中的对象移除,然后把 local 的数据给 victim, 这样的话,local 就会被清空,而 victim 就像一个垃圾分拣站,里面的东西可能会被当做垃圾丢弃了,但是里面有用的东西也可能被捡回来重新使用。</p>
<p>victim 中的元素如果被 Get 取走,那么这个元素就很幸运,因为它又“活”过来了。但是,如果这个时候 Get 的并发不是很大,元素没有被 Get 取走,那么就会被移除掉,因为没有别人引用它的话,就会被垃圾回收掉。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A Pool is a set of temporary objects that may be individually saved and
</span><span class="c1">// retrieved.
</span><span class="c1">//
</span><span class="c1">// Any item stored in the Pool may be removed automatically at any time without
</span><span class="c1">// notification. If the Pool holds the only reference when this happens, the
</span><span class="c1">// item might be deallocated.
</span><span class="c1">//
</span><span class="c1">// A Pool is safe for use by multiple goroutines simultaneously.
</span><span class="c1">//
</span><span class="c1">// Pool&#39;s purpose is to cache allocated but unused items for later reuse,
</span><span class="c1">// relieving pressure on the garbage collector. That is, it makes it easy to
</span><span class="c1">// build efficient, thread-safe free lists. However, it is not suitable for all
</span><span class="c1">// free lists.
</span><span class="c1">//
</span><span class="c1">// An appropriate use of a Pool is to manage a group of temporary items
</span><span class="c1">// silently shared among and potentially reused by concurrent independent
</span><span class="c1">// clients of a package. Pool provides a way to amortize allocation overhead
</span><span class="c1">// across many clients.
</span><span class="c1">//
</span><span class="c1">// An example of good use of a Pool is in the fmt package, which maintains a
</span><span class="c1">// dynamically-sized store of temporary output buffers. The store scales under
</span><span class="c1">// load (when many goroutines are actively printing) and shrinks when
</span><span class="c1">// quiescent.
</span><span class="c1">//
</span><span class="c1">// On the other hand, a free list maintained as part of a short-lived object is
</span><span class="c1">// not a suitable use for a Pool, since the overhead does not amortize well in
</span><span class="c1">// that scenario. It is more efficient to have such objects implement their own
</span><span class="c1">// free list.
</span><span class="c1">//
</span><span class="c1">// A Pool must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 用来标记，当前的 struct 是不能够被 copy 的
</span><span class="c1"></span>	<span class="nx">noCopy</span> <span class="nx">noCopy</span>
	<span class="c1">// local字段存储的是一个poolLocal数组的指针，poolLocal数组大小是goroutine中P的数量，访问时，P的id对应poolLocal数组下标索引，所以Pool的最大个数runtime.GOMAXPROCS()
</span><span class="c1"></span>	<span class="c1">// 通过这样的设计，每个P都有了自己的本地空间，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。
</span><span class="c1"></span>	<span class="c1">//有当前主要的空闲可用的元素都存放在 local 字段中,请求元素时也是优先从 local 字段中查找可用的元素。
</span><span class="c1"></span>	<span class="nx">local</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local fixed-size per-P pool, actual type is [P]poolLocal
</span><span class="c1"></span>	<span class="c1">// 上面数组的大小，即 P 的个数
</span><span class="c1"></span>	<span class="nx">localSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of the local array
</span><span class="c1"></span>	<span class="c1">// 同 local 和 localSize，只是在 gc 的过程中保留一次
</span><span class="c1"></span>	<span class="nx">victim</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local from previous cycle
</span><span class="c1"></span>	<span class="nx">victimSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of victims array
</span><span class="c1"></span>
	<span class="c1">// New optionally specifies a function to generate
</span><span class="c1"></span>	<span class="c1">// a value when Get would otherwise return nil.
</span><span class="c1"></span>	<span class="c1">// It may not be changed concurrently with calls to Get.
</span><span class="c1"></span>	<span class="c1">// New函数是在创建pool的时候设置的，当pool没有缓存对象的时候，会调用New方法生成一个新的对象
</span><span class="c1"></span>	<span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 sync.Pool 只需要指定 sync.Pool 对象的创建方法 New， 则在使用 sync.Pool.Get 失败的情况下，会池的内部会选择性的创建一个新的值。 因此获取到的对象可能是刚被使用完毕放回池中的对象、亦或者是由 New 创建的新对象。</p>
<p>其内部本质上保存了一个 poolLocal 元素的数组，即 local，每个 poolLocal 都只被一个 P 拥有， 而 victim 则缓存了上一个垃圾回收周期的 local。</p>
<p>poolLocal是每个调度器(P)存Object的结构体</p>
<p>而 poolLocal 则由 private 和 shared 两个字段组成：</p>
<p>private是每个调度器私有的，shared是所有调度器公有的，每个调度器pop时的逻辑是: 先看private，没有再看自己的shared，再没有就去其他调度器的shared偷，再没有才是空.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolLocal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolLocalInternal</span>

	<span class="c1">// Prevents false sharing on widespread platforms with
</span><span class="c1"></span>	<span class="c1">// 128 mod (cache line size) = 0 .
</span><span class="c1"></span>	<span class="c1">// poolLocal里面有一个pad数组用来占位用，防止在 cache line 上分配多个 poolLocalInternal从而造成false sharing
</span><span class="c1"></span>	<span class="c1">// pad是防止伪共享
</span><span class="c1"></span>	<span class="nx">pad</span> <span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocalInternal</span><span class="p">{})</span><span class="o">%</span><span class="mi">128</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="c1">// Local per-P Pool appendix.
</span><span class="c1">// 当前调度器的内部资源
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolLocalInternal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// private,代表一个缓存的元素,而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine,所以不会有并发的问题。
</span><span class="c1"></span>	<span class="c1">// 当前调度器的私有资源
</span><span class="c1"></span>	<span class="nx">private</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// Can be used only by the respective P.
</span><span class="c1"></span>	<span class="c1">// shared,可以由任意的 P 访问,但是只有本地的 P 才能 pushHead/popHead,其它 P 可以 popTail,相当于只有一个本地的 P 作为生产者(Producer),多个 P 作为消费者(Consumer),它是使用一个 local-free 的 queue 列表实现的。
</span><span class="c1"></span>	<span class="c1">// 所有调度器的公有资源
</span><span class="c1"></span>	<span class="nx">shared</span>  <span class="nx">poolChain</span>   <span class="c1">// Local P can pushHead/popHead; any P can popTail.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从前面结构体的字段不难猜测，private 是一个仅用于当前 P 进行读写的字段（即没有并发读写的问题）， 而 shared 则遵循字面意思，可以在多个 P 之间进行共享读写，是一个 poolChain 链式队列结构， 我们先记住这个结构在局部 P 上可以进行 pushHead 和 popHead 操作（队头读写）， 在所有 P 上都可以进行 popTail （队尾出队）操作，之后再来详细看它的实现细节。</p>
<h3 id="poolchain">PoolChain</h3>
<p>poolChain是一个双端队列，里面的head和tail分别指向队列头尾；poolDequeue里面存放真正的数据，是一个单生产者、多消费者的固定大小的无锁的环状队列，headTail是环状队列的首位位置的指针，可以通过位运算解析出首尾的位置.</p>
<p>poolChain 实际上是多个生产者消费者模型的链表。 对于一个局部 P 而言，充当了多个队头的单一生产者，它可以安全的 在整个链表中所串联的队列的队头进行操作。 而其他的多个 P 而言，则充当了多个队尾的消费者， 可以在所串联的队列的队尾进行消费（偷取）。</p>
<p>popHead 操作发生在从本地 shared 队列中消费并获取对象（消费者）。 pushHead 操作发生在向本地 shared 队列中放置对象（生产者）。 popTail 操作则发生在从其他 P 的 shared 队列中偷取的过程。</p>
<p>这个双端队列的模型大概是这个样子：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210126155840.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// poolChain is a dynamically-sized version of poolDequeue.
</span><span class="c1">//
</span><span class="c1">// This is implemented as a doubly-linked list queue of poolDequeues
</span><span class="c1">// where each dequeue is double the size of the previous one. Once a
</span><span class="c1">// dequeue fills up, this allocates a new one and only ever pushes to
</span><span class="c1">// the latest dequeue. Pops happen from the other end of the list and
</span><span class="c1">// once a dequeue is exhausted, it gets removed from the list.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolChain</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// head is the poolDequeue to push to. This is only accessed
</span><span class="c1"></span>	<span class="c1">// by the producer, so doesn&#39;t need to be synchronized.
</span><span class="c1"></span>	<span class="c1">// 头指针，只能单一producer操作(push, pop)
</span><span class="c1"></span>	<span class="nx">head</span> <span class="o">*</span><span class="nx">poolChainElt</span>

	<span class="c1">// tail is the poolDequeue to popTail from. This is accessed
</span><span class="c1"></span>	<span class="c1">// by consumers, so reads and writes must be atomic.
</span><span class="c1"></span>	<span class="c1">// 尾指针，可以被多个consumer pop，必须是原子操作
</span><span class="c1"></span>	<span class="nx">tail</span> <span class="o">*</span><span class="nx">poolChainElt</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从 poolChainElt 的结构我们可以看出，这是一个双向队列，包含 next 和 prev 指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolChainElt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolDequeue</span>

	<span class="c1">// next and prev link to the adjacent poolChainElts in this
</span><span class="c1"></span>	<span class="c1">// poolChain.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// next is written atomically by the producer and read
</span><span class="c1"></span>	<span class="c1">// atomically by the consumer. It only transitions from nil to
</span><span class="c1"></span>	<span class="c1">// non-nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// prev is written atomically by the consumer and read
</span><span class="c1"></span>	<span class="c1">// atomically by the producer. It only transitions from
</span><span class="c1"></span>	<span class="c1">// non-nil to nil.
</span><span class="c1"></span>	<span class="nx">next</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">poolChainElt</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">storePoolChainElt</span><span class="p">(</span><span class="nx">pp</span> <span class="o">**</span><span class="nx">poolChainElt</span><span class="p">,</span> <span class="nx">v</span> <span class="o">*</span><span class="nx">poolChainElt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">)),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="nx">pp</span> <span class="o">**</span><span class="nx">poolChainElt</span><span class="p">)</span> <span class="o">*</span><span class="nx">poolChainElt</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolChainElt</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pushhead">pushHead</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">poolChain</span><span class="p">)</span> <span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">head</span>
	<span class="c1">// 如果head为nil，说明队列现在是空的，那么新建一个节点，将head和tail都指向这个节点
</span><span class="c1"></span>	<span class="c1">// 如果链表空，则创建一个新的链表
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Initialize the chain.
</span><span class="c1"></span>		<span class="c1">// 固定长度为 8，必须为 2 的指数
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">initSize</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// Must be a power of 2
</span><span class="c1"></span>		<span class="nx">d</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">poolChainElt</span><span class="p">)</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">vals</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">eface</span><span class="p">,</span> <span class="nx">initSize</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">d</span>
		<span class="c1">// 设置尾指针
</span><span class="c1"></span>		<span class="nf">storePoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 将val push到head的环形队列中，如果push成功了，可以返回了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// The current dequeue is full. Allocate a new one of twice
</span><span class="c1"></span>	<span class="c1">// the size.
</span><span class="c1"></span>	<span class="c1">// 如果没push成功，则说明head的环形队列满了，就再创建一个两倍head大小的节点[最大(1 &lt;&lt; 32) / 4]，
</span><span class="c1"></span>	<span class="nx">newSize</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
	<span class="k">if</span> <span class="nx">newSize</span> <span class="o">&gt;=</span> <span class="nx">dequeueLimit</span> <span class="p">{</span>
		<span class="c1">// Can&#39;t make it any bigger.
</span><span class="c1"></span>		<span class="nx">newSize</span> <span class="p">=</span> <span class="nx">dequeueLimit</span>
	<span class="p">}</span>
	<span class="c1">// 创建一个新的poolChainElt并在链表头部插入
</span><span class="c1"></span>	<span class="nx">d2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">poolChainElt</span><span class="p">{</span><span class="nx">prev</span><span class="p">:</span> <span class="nx">d</span><span class="p">}</span>
	<span class="nx">d2</span><span class="p">.</span><span class="nx">vals</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">eface</span><span class="p">,</span> <span class="nx">newSize</span><span class="p">)</span>
	<span class="c1">// 将新节点作为head，并且处理好新head和旧head的next，prev关系
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">d2</span>
	<span class="nf">storePoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">d2</span><span class="p">)</span>
	<span class="c1">// 将val push到head的环形队列中
</span><span class="c1"></span>	<span class="nx">d2</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pophead">popHead</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">poolChain</span><span class="p">)</span> <span class="nf">popHead</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 先在head环形队列中popHead试试
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 能取到就返回，取不到说明队列空了
</span><span class="c1"></span>		<span class="c1">// d 是一个 poolDequeue，如果 d.popHead 是并发安全的，
</span><span class="c1"></span>		<span class="c1">// 那么这里取 val 也是并发安全的。若 d.popHead 失败，则
</span><span class="c1"></span>		<span class="c1">// 说明需要重新尝试。这个过程会持续到整个链表为空。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">popHead</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span>
		<span class="p">}</span>
		<span class="c1">// There may still be unconsumed elements in the
</span><span class="c1"></span>		<span class="c1">// previous dequeue, so try backing up.
</span><span class="c1"></span>		<span class="c1">// 如果空了，当前节点就没用了，就删掉当前节点，去prev节点并且把prev节点作为新head再取一值递归下去，
</span><span class="c1"></span>		<span class="nx">d</span> <span class="p">=</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">prev</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="poptail">popTail</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">poolChain</span><span class="p">)</span> <span class="nf">popTail</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span>
	<span class="c1">// 如果tail为nil，说明队列是空的，直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 如果tail非nil，就取取试试，有东西就返回
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// It&#39;s important that we load the next pointer
</span><span class="c1"></span>		<span class="c1">// *before* popping the tail. In general, d may be
</span><span class="c1"></span>		<span class="c1">// transiently empty, but if next is non-nil before
</span><span class="c1"></span>		<span class="c1">// the pop and the pop fails, then d is permanently
</span><span class="c1"></span>		<span class="c1">// empty, which is the only condition under which it&#39;s
</span><span class="c1"></span>		<span class="c1">// safe to drop d from the chain.
</span><span class="c1"></span>		<span class="nx">d2</span> <span class="o">:=</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
		<span class="c1">// 尝试从当前poolChainElt的队列尾部取，成功则直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span>
		<span class="p">}</span>
		<span class="c1">// 如果没取出来东西，那么说明tail节点没存东西了，递归去prev节点环形队列中popTail，并且把prev节点作为tail，能取到就返回，取不到就是空了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// This is the only dequeue. It&#39;s empty right
</span><span class="c1"></span>			<span class="c1">// now, but could be pushed to in the future.
</span><span class="c1"></span>			<span class="c1">// d2为空表明链表只有一个节点，而从该节点取对象已失败，则返回
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="c1">// The tail of the chain has been drained, so move on
</span><span class="c1"></span>		<span class="c1">// to the next dequeue. Try to drop it from the chain
</span><span class="c1"></span>		<span class="c1">// so the next pop doesn&#39;t have to look at the empty
</span><span class="c1"></span>		<span class="c1">// dequeue again.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">tail</span><span class="p">)),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d2</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// We won the race. Clear the prev pointer so
</span><span class="c1"></span>			<span class="c1">// the garbage collector can collect the empty
</span><span class="c1"></span>			<span class="c1">// dequeue and so popHead doesn&#39;t back up
</span><span class="c1"></span>			<span class="c1">// further than necessary.
</span><span class="c1"></span>			<span class="nf">storePoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d2</span><span class="p">.</span><span class="nx">prev</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">d</span> <span class="p">=</span> <span class="nx">d2</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="pooldequeue">poolDequeue</h3>
<p>poolDequeue 是一个无锁、固定大小的单生产端多消费端的环形队列，单一 producer 可以在头部 push 和 pop(可能和传统队列头部只能 push 的定义不同)，多 consumer 可以在尾部 pop.</p>
<p>eface 数组存储了实际的对象，其 eface 依赖运行时对 interface{} 的实现，即一个 interface{} 由 typ 和 val 两段数据组成</p>
<p>poolDequeue里面的环状队列大小是固定的，当环状队列满了的时候会创建一个size是原来两倍大小的环状队列。最大扩展到 dequeueLimit = (1 &laquo; 32) / 4 = (1 &laquo; 30)，之后就不会扩展了.</p>
<p>为什么vals长度必须是2的幂?这是因为go的内存管理策略是将内存分为2的幂大小的链表，申请2的幂大小的内存可以有效减小分配内存的开销</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// poolDequeue is a lock-free fixed-size single-producer,
</span><span class="c1">// multi-consumer queue. The single producer can both push and pop
</span><span class="c1">// from the head, and consumers can pop from the tail.
</span><span class="c1">//
</span><span class="c1">// It has the added feature that it nils out unused slots to avoid
</span><span class="c1">// unnecessary retention of objects. This is important for sync.Pool,
</span><span class="c1">// but not typically a property considered in the literature.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolDequeue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// headTail packs together a 32-bit head index and a 32-bit
</span><span class="c1"></span>	<span class="c1">// tail index. Both are indexes into vals modulo len(vals)-1.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// tail = index of oldest data in queue
</span><span class="c1"></span>	<span class="c1">// head = index of next slot to fill
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Slots in the range [tail, head) are owned by consumers.
</span><span class="c1"></span>	<span class="c1">// A consumer continues to own a slot outside this range until
</span><span class="c1"></span>	<span class="c1">// it nils the slot, at which point ownership passes to the
</span><span class="c1"></span>	<span class="c1">// producer.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The head index is stored in the most-significant bits so
</span><span class="c1"></span>	<span class="c1">// that we can atomically add to it and the overflow is
</span><span class="c1"></span>	<span class="c1">// harmless.
</span><span class="c1"></span>	<span class="nx">headTail</span> <span class="kt">uint64</span>

	<span class="c1">// vals is a ring buffer of interface{} values stored in this
</span><span class="c1"></span>	<span class="c1">// dequeue. The size of this must be a power of 2.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// vals[i].typ is nil if the slot is empty and non-nil
</span><span class="c1"></span>	<span class="c1">// otherwise. A slot is still in use until *both* the tail
</span><span class="c1"></span>	<span class="c1">// index has moved beyond it and typ has been set to nil. This
</span><span class="c1"></span>	<span class="c1">// is set to nil atomically by the consumer and read
</span><span class="c1"></span>	<span class="c1">// atomically by the producer.
</span><span class="c1"></span>	<span class="nx">vals</span> <span class="p">[]</span><span class="nx">eface</span>
<span class="p">}</span>
<span class="c1">// 存储元素的结构体，类型指针和值指针
</span><span class="c1">// Pool 底层用 eface 来存储单个 Object, 包括 typ 指针: Object 的类型，val 指针: Object 的值
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>



<span class="c1">// dequeueLimit is the maximum size of a poolDequeue.
</span><span class="c1">//
</span><span class="c1">// This must be at most (1&lt;&lt;dequeueBits)/2 because detecting fullness
</span><span class="c1">// depends on wrapping around the ring buffer without wrapping around
</span><span class="c1">// the index. We divide by 4 so this fits in an int on 32-bit.
</span><span class="c1"></span>
<span class="c1">// 为什么dequeueLimit是(1 &lt;&lt; 32) / 4 = 1 &lt;&lt; 30 ?
</span><span class="c1">// dequeueLimit 必须是2的幂(上边解释过)
</span><span class="c1">// head和tail都是32位，最大是1 &lt;&lt; 31，如果都用的话，head和tail就是无符号整型，无符号整型使用的时候会有很多上溢的错误，这类错误是不容易检测的，所以相比之下还不如用31位有符号整型，有错就报出来
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">dequeueLimit</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">dequeueBits</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>

<span class="c1">// dequeueNil is used in poolDeqeue to represent interface{}(nil).
</span><span class="c1">// Since we use nil to represent empty slots, we need a sentinel value
</span><span class="c1">// to represent nil.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">dequeueNil</span> <span class="o">*</span><span class="kd">struct</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>headTail 字段的前 32 位 表示了下一个需要被填充的对象槽的索引，而后 32 位则表示了队列中最先被插入的数据的索引</p>
<p>headTail:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">[hhhhhhhh</span> <span class="n">hhhhhhhh</span> <span class="n">hhhhhhhh</span> <span class="n">hhhhhhhh</span> <span class="n">tttttttt</span> <span class="n">tttttttt</span> <span class="n">tttttttt</span> <span class="n">tttttttt]</span>
<span class="m">1</span><span class="n">. headTail表示下标</span>，高<span class="m">32</span>位表示头下标，低<span class="m">32</span>位表示尾下标，<span class="n">poolDequeue定义了</span>，<span class="n">head</span> <span class="n">tail的pack和unpack函数方便转化</span>，
实际用的时候都会<span class="nf">mod </span><span class="p">(</span> <span class="nf">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span> <span class="p">)</span> 来防止溢出
<span class="m">2</span><span class="n">. head和tail永远只用32位表示</span>，溢出后会从<span class="m">0</span>开始，这也满足循环队列的设计
<span class="m">3</span><span class="n">. 队列为空的条件</span>  <span class="n">tail</span> <span class="o">==</span> <span class="n">head</span>
<span class="m">4</span><span class="nf">. 队列满的条件    </span><span class="p">(</span><span class="n">tail</span><span class="o">+</span><span class="nf">uint32</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">d.vals</span><span class="p">)))</span><span class="o">&amp;</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">dequeueBits</span><span class="m">-1</span><span class="p">)</span> <span class="o">==</span> <span class="n">head</span> <span class="nf">tail加上队列长度和head相等</span><span class="p">(</span>实际上就是队列已有的空间都有值了<span class="p">,</span>满了<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>正如前面所说 poolDequeue 是一个单生产者、多消费者的固定长度的环状队列， popHead、pushHead 由局部的 P 操作队首，而 popTail 由其他并行的 P 操作队尾。 其中 headTail 字段的前 32 位表示了下一个需要被填充的对象槽的索引， 而后 32 位则表示了队列中最先被插入的数据的索引。</p>
<p>通过 pack和unpack方法来实现对head和tail的读写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">dequeueBits</span> <span class="p">=</span> <span class="mi">32</span>

<span class="c1">// 将headTail分解为head和tail
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">mask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">head</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">((</span><span class="nx">ptrs</span> <span class="o">&gt;&gt;</span> <span class="nx">dequeueBits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">mask</span><span class="p">)</span>
	<span class="nx">tail</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">ptrs</span> <span class="o">&amp;</span> <span class="nx">mask</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 将head和tail组合成headTail
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">pack</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">mask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">dequeueBits</span><span class="p">)</span> <span class="p">|</span>
		<span class="nb">uint64</span><span class="p">(</span><span class="nx">tail</span><span class="o">&amp;</span><span class="nx">mask</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从 poolChain 的实现中我们可以看到，每个 poolDequeue 的 vals 长度为 8。 但由于是循环队列，实现中并不关心队列的长度，只要收尾元素的索引相等，则说明队列已满。 因此通过 CAS 原语实现单一生产者的对队头的读 popHead 和写 pushHead：</p>
<h4 id="pophead-1">popHead</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// popHead removes and returns the element at the head of the queue.
</span><span class="c1">// It returns false if the queue is empty. It must only be called by a
</span><span class="c1">// single producer.
</span><span class="c1">// 获取并删除队首元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">popHead</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">slot</span> <span class="o">*</span><span class="nx">eface</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">)</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
			<span class="c1">// Queue is empty.
</span><span class="c1"></span>			<span class="c1">// 队列为空，获取对象失败
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="c1">// Confirm tail and decrement head. We do this before
</span><span class="c1"></span>		<span class="c1">// reading the value to take back ownership of this
</span><span class="c1"></span>		<span class="c1">// slot.
</span><span class="c1"></span>		<span class="c1">// 因为head是下一个对象存储的位置，因此从队列头部获取对象需先将head-1
</span><span class="c1"></span>		<span class="nx">head</span><span class="o">--</span>
		<span class="nx">ptrs2</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="nx">ptrs</span><span class="p">,</span> <span class="nx">ptrs2</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// We successfully took back slot.
</span><span class="c1"></span>			<span class="nx">slot</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">head</span><span class="o">&amp;</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">val</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">val</span> <span class="o">==</span> <span class="nf">dequeueNil</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// Zero the slot. Unlike popTail, this isn&#39;t racing with
</span><span class="c1"></span>	<span class="c1">// pushHead, so we don&#39;t need to be careful here.
</span><span class="c1"></span>	<span class="c1">// 重置slot
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">eface</span><span class="p">{}</span>
	<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pushhead-1">pushHead</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pushHead adds val at the head of the queue. It returns false if the
</span><span class="c1">// queue is full. It must only be called by a single producer.
</span><span class="c1">// 添加元素到队首
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">)</span>
	<span class="c1">// 解析出head、tail的索引
</span><span class="c1"></span>	<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">tail</span><span class="o">+</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)))</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
		<span class="c1">// 队列已满，插入失败
</span><span class="c1"></span>		<span class="c1">// Queue is full.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 找到head的槽位
</span><span class="c1"></span>	<span class="nx">slot</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">head</span><span class="o">&amp;</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

	<span class="c1">// Check if the head slot has been released by popTail.
</span><span class="c1"></span>	<span class="c1">// 此处可能与 popTail 发生竞争，参见 popTail
</span><span class="c1"></span>	<span class="c1">// 检测这个槽位有没被popTail释放
</span><span class="c1"></span>	<span class="nx">typ</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">slot</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">typ</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Another goroutine is still cleaning up the tail, so
</span><span class="c1"></span>		<span class="c1">// the queue is actually still full.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// The head slot is free, so we own it.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">val</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="nf">dequeueNil</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span> <span class="p">=</span> <span class="nx">val</span>

	<span class="c1">// Increment head. This passes ownership of slot to popTail
</span><span class="c1"></span>	<span class="c1">// and acts as a store barrier for writing the slot.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>以及多个消费者读的处理手段非常巧妙，通过 interface{} 的 typ 和 val 两段式 结构的读写先后顺序，在 popTail 和 pushHead 之间消除了竞争</p>
<h4 id="poptail-1">popTail</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// popTail removes and returns the element at the tail of the queue.
</span><span class="c1">// It returns false if the queue is empty. It may be called by any
</span><span class="c1">// number of consumers.
</span><span class="c1">// 获取并删除队尾元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">popTail</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">slot</span> <span class="o">*</span><span class="nx">eface</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">)</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
			<span class="c1">// Queue is empty.
</span><span class="c1"></span>			<span class="c1">// 队列为空，直接返回
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="c1">// Confirm head and tail (for our speculative check
</span><span class="c1"></span>		<span class="c1">// above) and increment tail. If this succeeds, then
</span><span class="c1"></span>		<span class="c1">// we own the slot at tail.
</span><span class="c1"></span>		<span class="c1">// tail+1，表明尾部的对象已被获取
</span><span class="c1"></span>		<span class="nx">ptrs2</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="nx">ptrs</span><span class="p">,</span> <span class="nx">ptrs2</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Success.
</span><span class="c1"></span>			<span class="nx">slot</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">tail</span><span class="o">&amp;</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// We now own slot.
</span><span class="c1"></span>	<span class="nx">val</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">val</span> <span class="o">==</span> <span class="nf">dequeueNil</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Tell pushHead that we&#39;re done with this slot. Zeroing the
</span><span class="c1"></span>	<span class="c1">// slot is also important so we don&#39;t leave behind references
</span><span class="c1"></span>	<span class="c1">// that could keep this object live longer than necessary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We write to val first and then publish that we&#39;re done with
</span><span class="c1"></span>	<span class="c1">// this slot by atomically writing to typ.
</span><span class="c1"></span>	<span class="c1">// 注意：此处可能与 pushHead 发生竞争，解决方案是：
</span><span class="c1"></span>	<span class="c1">// 1. 让 pushHead 先读取 typ 的值，如果 typ 值不为 nil，则说明 popTail 尚未清理完 slot
</span><span class="c1"></span>	<span class="c1">// 2. 让 popTail 先清理掉 val 中的内容，在清理掉 typ，从而确保不会与 pushHead 对 slot 的写行为发生竞争
</span><span class="c1"></span>	<span class="c1">// 将slot置空
</span><span class="c1"></span>	<span class="nx">slot</span><span class="p">.</span><span class="nx">val</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">slot</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="c1">// At this point pushHead owns the slot.
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="get">Get</h3>
<p>我们来看看 Get 方法的具体实现原理。</p>
<p>当从池中获取对象时，会先从 per-P 的 poolLocal slice 中选取一个 poolLocal，选择策略遵循：</p>
<ul>
<li>尝试从当前P的private取，成功则直接返回</li>
<li>private获取失败，则从当前P的share链表的头部节点取，成功则返回
<ul>
<li>从头部节点的队头获取成功，则直接返回</li>
<li>从头部节点获取失败，则从下一节点获取，直至获取成功或遍历完所有节点</li>
</ul>
</li>
<li>当前P的share获取失败，则从其他P的share获取，成功则返回
<ul>
<li>遍历其他P的share链表直至获取对象成功，返回</li>
<li>从其他P的share链表的尾部的队尾获取对象，若成功则直接返回</li>
<li>若尾部节点的队尾获取对象失败，则表明该节点为空，删除该节点并遍历下一节点，直至获取对象成功或遍历完所有节点</li>
</ul>
</li>
<li>其他P的share获取失败，则尝试从victim cache获取，成功则返回
<ul>
<li>优先尝试从private获取，成功则返回</li>
<li>若从private获取失败，则遍历victim的poolLocal，尝试从每一个poolLocal的链表尾部获取对象，成功则返回</li>
</ul>
</li>
<li>vitcim获取失败，则创建一个新对象返回</li>
</ul>
<p>首先,从本地的 private 字段中获取可用元素,因为没有锁, 获取元素的过程会非常快,如果没有获取到,就尝试从本地的 shared 获取一个,如果还没有,会使用 getSlow 方法去其它的 shared 中“偷”一个。最后,如果没有获取到,就尝试使用 New 函数创建一个新的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get selects an arbitrary item from the Pool, removes it from the
</span><span class="c1">// Pool, and returns it to the caller.
</span><span class="c1">// Get may choose to ignore the pool and treat it as empty.
</span><span class="c1">// Callers should not assume any relation between values passed to Put and
</span><span class="c1">// the values returned by Get.
</span><span class="c1">//
</span><span class="c1">// If Get would otherwise return nil and p.New is non-nil, Get returns
</span><span class="c1">// the result of calling p.New.
</span><span class="c1">// Get 从 Pool 中选择一个任意的对象，将其移出 Pool, 并返回给调用方。
</span><span class="c1">// Get 可能会返回一个非零值对象（被其他人使用过），因此调用方不应假设
</span><span class="c1">// 返回的对象具有任何形式的状态。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 把当前goroutine固定在当前的P上
</span><span class="c1"></span>	<span class="c1">// 获取一个 poolLocal
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
	<span class="c1">// 优先从local的private字段取,快速
</span><span class="c1"></span>	<span class="c1">// 先从 private 获取对象
</span><span class="c1"></span>	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Try to pop the head of the local shard. We prefer
</span><span class="c1"></span>		<span class="c1">// the head over the tail for temporal locality of
</span><span class="c1"></span>		<span class="c1">// reuse.
</span><span class="c1"></span>		<span class="c1">// 从当前的local.shared弹出一个,注意是从head读取并移除
</span><span class="c1"></span>		<span class="c1">// 尝试从 localPool 的 shared 队列队头读取，
</span><span class="c1"></span>		<span class="c1">// 因为队头的内存局部性比队尾更好。
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popHead</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 当前P的private和share都取不到，则去其他P的share读取
</span><span class="c1"></span>			<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nf">poolRaceAddr</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果没有获取到,尝试使用New函数生成一个新的
</span><span class="c1"></span>	<span class="c1">// 如果 getSlow 还是获取不到，则 New 一个
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">New</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实我们不难看出：</p>
<ol>
<li>private 只保存了一个对象;</li>
<li>第一次从 shared 中取对象时，还未涉及跨 P 读写，因此 popHead 是可用的；</li>
<li>当 shared 读取不到对象时，说明当前局部 P 所持有的 localPool 不包含任何对象，这时尝试从其他的 localPool 进行偷取。</li>
<li>实在是偷不到，才考虑新创建一个对象。</li>
</ol>
<h4 id="pin">pin</h4>
<p>pin 方法会将此 goroutine 固定在当前的 P 上,避免查找元素期间被其它的 P 执行。固定的好处就是查找元素期间直接得到跟这个 P 相关的 local。有一点需要注意的是,pin 方法在执行的时候,如果跟这个 P 相关的 local 还没有创建,或者运行时 P 的数量被修改了的话,就会新创建 local。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pin pins the current goroutine to P, disables preemption and
</span><span class="c1">// returns poolLocal pool for the P and the P&#39;s id.
</span><span class="c1">// Caller must call runtime_procUnpin() when done with the pool.
</span><span class="c1">// 将当前goroutine和P绑定，禁止抢占，并返回对应的poolLocal和P的id
</span><span class="c1">// 调用方在调用完成后必须调用runtime_procUnpin方法取消抢占
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">pin</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// 返回当前 P.id
</span><span class="c1"></span>	<span class="nx">pid</span> <span class="o">:=</span> <span class="nf">runtime_procPin</span><span class="p">()</span>
	<span class="c1">// In pinSlow we store to local and then to localSize, here we load in opposite order.
</span><span class="c1"></span>	<span class="c1">// Since we&#39;ve disabled preemption, GC cannot happen in between.
</span><span class="c1"></span>	<span class="c1">// Thus here we must observe local at least as large localSize.
</span><span class="c1"></span>	<span class="c1">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).
</span><span class="c1"></span>	<span class="c1">// 在 pinSlow 中会存储 localSize 后再存储 local，因此这里反过来读取
</span><span class="c1"></span>	<span class="c1">// 因为我们已经禁用了抢占，这时不会发生 GC
</span><span class="c1"></span>	<span class="c1">// 因此，我们必须观察 local 和 localSize 是否对应
</span><span class="c1"></span>	<span class="c1">// 观察到一个全新或很大的的 local 是正常行为
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">)</span> <span class="c1">// load-acquire
</span><span class="c1"></span>	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>                          <span class="c1">// load-consume
</span><span class="c1"></span>	<span class="c1">// 因为可能存在动态的 P（运行时调整 P 的个数）procresize/GOMAXPROCS
</span><span class="c1"></span>	<span class="c1">// 如果 P.id 没有越界，则直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// 对应的poolLocal已创建，调用indexLocal取出对应的poolLocal返回
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span><span class="p">),</span> <span class="nx">pid</span>
	<span class="p">}</span>
	<span class="c1">// 没有结果时，涉及全局加锁
</span><span class="c1"></span>	<span class="c1">// 例如重新分配数组内存，添加到全局列表
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pinSlow</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>pin() 首先会调用运行时实现获得当前 P 的 id，将 P 设置为禁止抢占，达到固定当前 goroutine 的目的。 然后检查 pid 与 p.localSize 的值来确保从 p.local 中取值不会发生越界。 如果不会发生，则调用 indexLocal() 完成取值。否则还需要继续调用 pinSlow()。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">poolLocal</span> <span class="p">{</span>
	<span class="c1">// 简单的通过 p.local 的头指针与索引来第 i 个 pooLocal
</span><span class="c1"></span>	<span class="nx">lp</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocal</span><span class="p">{}))</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">)(</span><span class="nx">lp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个过程中我们可以看到在运行时调整 P 的大小的代价。如果此时 P 被调大，而没有对应的 poolLocal 时， 必须在取之前创建好，从而必须依赖全局加锁，这对于以性能著称的池化概念是比较致命的。</p>
<p>既然需要对全局进行加锁，pinSlow() 会首先取消 P 的禁止抢占，这是因为使用 mutex 时 P 必须为可抢占的状态。 然后使用 allPoolsMu 进行加锁。 当完成加锁后，再重新固定 P ，取其 pid。注意，因为中途可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查。 如果 pid 在 p.local 大小范围内，则不再此时创建，直接返回。</p>
<p>如果 p.local 为空，则将 p 扔给 allPools 并在垃圾回收阶段回收所有 Pool 实例。 最后再完成对 p.local 的创建（彻底丢弃旧数组）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">allPoolsMu</span> <span class="nx">Mutex</span>
	<span class="c1">// allPools 是一组 pool 的集合，具有非空主缓存。
</span><span class="c1"></span>	<span class="c1">// 有两种形式来保护它的读写：1. allPoolsMu 锁; 2. STW.
</span><span class="c1"></span>	<span class="nx">allPools</span>   <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span>
<span class="p">)</span>
<span class="c1">// 对应的poolLocal不存在，则创建
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">pinSlow</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Retry under the mutex.
</span><span class="c1"></span>	<span class="c1">// Can not lock the mutex while pinned.
</span><span class="c1"></span>	<span class="c1">// 这时取消 P 的禁止抢占，因为使用 mutex 时候 P 必须可抢占
</span><span class="c1"></span>	<span class="c1">// 加锁期间须先取消抢占
</span><span class="c1"></span>	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nx">allPoolsMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">allPoolsMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 当锁住后，再次固定 P 取其 id
</span><span class="c1"></span>	<span class="nx">pid</span> <span class="o">:=</span> <span class="nf">runtime_procPin</span><span class="p">()</span>
	<span class="c1">// poolCleanup won&#39;t be called while we are pinned.
</span><span class="c1"></span>	<span class="c1">// 并再次检查是否符合条件，因为可能中途已被其他线程调用
</span><span class="c1"></span>	<span class="c1">// 当再次固定 P 时 poolCleanup 不会被调用
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
	<span class="c1">// 第二次检测，因为在加锁过程中可能别的goroutine调用创建了poolLocal
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span><span class="p">),</span> <span class="nx">pid</span>
	<span class="p">}</span>
	<span class="c1">// 如果数组为空，新建
</span><span class="c1"></span>	<span class="c1">// 将其添加到 allPools，垃圾回收器从这里获取所有 Pool 实例
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">allPools</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">allPools</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 根据 P 数量创建 slice，如果 GOMAXPROCS 在 GC 间发生变化
</span><span class="c1"></span>	<span class="c1">// 我们重新分配此数组并丢弃旧的
</span><span class="c1"></span>	<span class="c1">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.
</span><span class="c1"></span>	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">local</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="c1">// 将底层数组起始指针保存到 p.local，并设置 p.localSize
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">local</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">local</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">// store-release
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>         <span class="c1">// store-release
</span><span class="c1"></span>	<span class="c1">// 返回所需的 pollLocal
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">local</span><span class="p">[</span><span class="nx">pid</span><span class="p">],</span> <span class="nx">pid</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="getslow">getSlow</h4>
<p>终于，我们获取到了 poolLocal，现在回到我们 Get 的取值过程。在取对象的过程中，我们仍然会面临 既不能从 private 取、也不能从 shared 中取得尴尬境地。这时候就来到了 getSlow()。</p>
<p>试想，如果我们在本地的 P 中取不到值，是不是可以考虑从别人那里偷一点过来？总会比创建一个新的要快。 因此，我们再次固定 P，并取得当前的 P.id 来从其他 P 中偷值，那么我们需要先获取到其他 P 对应的 poolLocal。假设 size 为数组的大小，local 为 p.local，那么尝试遍历其他所有 P</p>
<p>它首先要遍历所有的 local,尝试从它们的 shared 弹出一个元素。如果还没找到一个,那么,就开始对 victim 下手了。</p>
<p>在 vintim 中查询可用元素的逻辑还是一样的,先从对应的 victim 的 private 查找,如果查不到,就再从其它 victim 的 shared 中查找。</p>
<p>下面的代码是 getSlow 方法的主要逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="c1">// See the comment in pin regarding ordering of the loads.
</span><span class="c1"></span>	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">)</span> <span class="c1">// load-acquire
</span><span class="c1"></span>	<span class="nx">locals</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>                        <span class="c1">// load-consume
</span><span class="c1"></span>	<span class="c1">// Try to steal one element from other procs.
</span><span class="c1"></span>	<span class="c1">// 尝试从其他P获取对象，成功则直接返回
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 获取目标 poolLocal, 引入 pid 保证不是自身
</span><span class="c1"></span>		<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
		<span class="c1">// 从其他的 P 中固定的 localPool 的 share 队列的队尾偷一个缓存对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">x</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Try the victim cache. We do this after attempting to steal
</span><span class="c1"></span>	<span class="c1">// from all primary caches because we want objects in the
</span><span class="c1"></span>	<span class="c1">// victim cache to age out if at all possible.
</span><span class="c1"></span>	<span class="c1">// 如果其它proc也没有可用元素,那么尝试从vintim中获取
</span><span class="c1"></span>	<span class="c1">// 当 local 失败后，尝试再尝试从上一个垃圾回收周期遗留下来的 victim。
</span><span class="c1"></span>	<span class="c1">// 如果 pid 比 victim 遗留的 localPool 还大，则说明从根据此 pid 从
</span><span class="c1"></span>	<span class="c1">// victim 获取 localPool 会发生越界（同时也表明此时 P 的数量已经发生变化）
</span><span class="c1"></span>	<span class="c1">// 这时无法继续读取，直接返回 nil
</span><span class="c1"></span>	<span class="c1">// 尝试从victim cache中获取对象
</span><span class="c1"></span>	<span class="nx">size</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 获取 localPool，并优先读取 private
</span><span class="c1"></span>	<span class="nx">locals</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">victim</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="nx">pid</span><span class="p">)</span>
	<span class="c1">// 同样的逻辑,先从vintim中的local private获取
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span><span class="p">;</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 从vintim其它proc尝试偷取
</span><span class="c1"></span>		<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
		<span class="c1">// 从其他的 P 中固定的 localPool 的 share 队列的队尾偷一个缓存对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">x</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Mark the victim cache as empty for future gets don&#39;t bother
</span><span class="c1"></span>	<span class="c1">// with it.
</span><span class="c1"></span>	<span class="c1">// 如果victim中都没有,则把这个victim标记为空,以后的查找可以快速跳过了
</span><span class="c1"></span>	<span class="c1">// 将 victim 缓存置空，从而确保之后的 get 操作不再读取此处的值
</span><span class="c1"></span>	<span class="c1">// 清空 victim cache。下次就不用再从这里找了
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们来证明一下此处确实不会发生取到自身的情况，不妨设：<code>pid = (pid+i+1)%size</code> 则 <code>pid+i+1 = a*size+pid</code>。 即：<code>a*size = i+1</code>，其中 a 为整数。由于 <code>i&lt;size</code>，于是 <code>a*size = i+1 &lt; size+1</code>，则： <code>(a-1)*size &lt; 1 ==&gt; size &lt; 1 / (a-1)</code>，由于 size 为非负整数，这是不可能的。</p>
<h3 id="put">Put</h3>
<p>Put 的过程则相对简单，只需要将对象放回到池中。 与 Get 取出一样，放回遵循策略：</p>
<ol>
<li>尝试将对象存储在当前P的private，成功则直接返回</li>
<li>存入private失败，则尝试存入当前P的share链表的头部节点的队头，成功则返回</li>
<li>若链表头部节点的队列已满存入失败，则创建一个新节点，节点队列大小为原来的两倍，将对象存入新节点， 并将该节点设置为新的头部节点</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Put adds x to the pool.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// 如果存入对象为nil直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Randomly drop x on floor.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nf">poolRaceAddr</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 获得一个 localPool
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
	<span class="c1">// 优先放入 private
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 如果不能放入 private 则放入 shared
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="runtime_procunpin--runtime_procpin">runtime_procUnpin &amp; runtime_procPin</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname sync_runtime_procPin sync.runtime_procPin
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_procPin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">procPin</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_procUnpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">procUnpin</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procPin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>

	<span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procUnpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="poolcleanup">PoolCleanup</h3>
<p>sync.Pool 的垃圾回收发生在运行时 GC 开始之前。</p>
<p>在 src/sync/pool.go 中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 将缓存清理函数注册到运行时 GC 时间段
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">runtime_registerPoolCleanup</span><span class="p">(</span><span class="nx">poolCleanup</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 由运行时实现
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_registerPoolCleanup</span><span class="p">(</span><span class="nx">cleanup</span> <span class="kd">func</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>在 src/runtime/mgc.go 中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 开始 GC
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">clearpools</span><span class="p">()</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="c1">// 实现缓存清理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">clearpools</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// clear sync.Pools
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">poolcleanup</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">poolcleanup</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">poolcleanup</span> <span class="kd">func</span><span class="p">()</span>

<span class="c1">// 利用编译器标志将 sync 包中的清理注册到运行时
</span><span class="c1">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_registerPoolCleanup</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="nx">poolcleanup</span> <span class="p">=</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再来看实际的清理函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">allPoolsMu</span> <span class="nx">Mutex</span>

	<span class="c1">// allPools is the set of pools that have non-empty primary
</span><span class="c1"></span>	<span class="c1">// caches. Protected by either 1) allPoolsMu and pinning or 2)
</span><span class="c1"></span>	<span class="c1">// STW.
</span><span class="c1"></span>	<span class="nx">allPools</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span>

	<span class="c1">// oldPools is the set of pools that may have non-empty victim
</span><span class="c1"></span>	<span class="c1">// caches. Protected by STW.
</span><span class="c1"></span>	<span class="c1">// oldPools 是一组 pool 的集合，具有非空 victim 缓存。由 STW 保护
</span><span class="c1"></span>	<span class="nx">oldPools</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">poolCleanup</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 该函数会注册到运行时 GC 阶段(前)，此时为 STW 状态，不需要加锁
</span><span class="c1"></span>	<span class="c1">// 它必须不处理分配且不调用任何运行时函数。
</span><span class="c1"></span>
	<span class="c1">// 由于此时是 STW，不存在用户态代码能尝试读取 localPool，进而所有的 P 都已固定（与 goroutine 绑定）
</span><span class="c1"></span>
	<span class="c1">// 从所有的 oldPools 中删除 victim
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 将主缓存移动到 victim 缓存
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>

		<span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 具有非空主缓存的池现在具有非空的 victim 缓存，并且没有任何 pool 具有主缓存。
</span><span class="c1"></span>	<span class="nx">oldPools</span><span class="p">,</span> <span class="nx">allPools</span> <span class="p">=</span> <span class="nx">allPools</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，即便是最后 p.local 已经被置换到 oldPools 的 p.victim，其中的缓存对象仍然有可能被偷取放回到 allPools 中，从而延缓了 victim 中缓存对象被回收的速度。</p>
<h3 id="小结-2">小结</h3>
<p>至此，我们完整分析了 sync.Pool 的所有代码。总结：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s">        <span class="n">goroutine</span>      <span class="n">goroutine</span>       <span class="n">goroutine</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
           <span class="n">P</span>               <span class="n">P</span>               <span class="n">P</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
         <span class="n">private</span>        <span class="n">private</span>          <span class="n">private</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
    <span class="n">[</span>   <span class="n">poolLocal</span>      <span class="n">poolLocal</span>        <span class="n">poolLocal</span>  <span class="n">]</span>    <span class="n">sync.Pool</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
         <span class="n">shared</span>          <span class="n">shared</span>          <span class="n">shared</span>
</code></pre></td></tr></table>
</div>
</div><p>一个 goroutine 固定在 P 上，从当前 P 对应的 private 取值， shared 字段作为一个优化过的链式无锁变长队列，当在 private 取不到值的情况下， 从对应的 shared 队列的队首取，若还是取不到，则尝试从其他 P 的 shared 队列队尾中偷取。 若偷不到，则尝试从上一个 GC 周期遗留到 victim 缓存中取，否则调用 New 创建一个新的对象。</p>
<p>对于回收而言，池中所有临时对象在一次 GC 后会被放入 victim 缓存中， 而前一个周期被放入 victim 的缓存则会被清理掉。</p>
<p>对于调用方而言，当 Get 到临时对象后，便脱离了池本身不受控制。 用方有责任将使用完的对象放回池中。</p>
<p>本文中介绍的 sync.Pool 实现为 Go 1.13 优化过后的版本，相较于之前的版本，主要有以下几点优化：</p>
<ol>
<li>引入了 victim （二级）缓存，每次 GC 周期不再清理所有的缓存对象，而是将 locals 中的对象暂时放入 victim ，从而延迟到下一个 GC 周期进行回收；</li>
<li>在下一个周期到来前，victim 中的缓存对象可能会被偷取，在 Put 操作后又重新回到 locals 中，这个过程发生在从其他 P 的 shared 队列中偷取不到、以及 New 一个新对象之前，进而是在牺牲了 New 新对象的速度的情况下换取的；</li>
<li>poolLocal 不再使用 Mutex 这类昂贵的锁来保证并发安全，取而代之的是使用了 CAS 算法优化实现的 poolChain 变长无锁双向链式队列。</li>
</ol>
<p>这种两级缓存的优化的优势在于：</p>
<ol>
<li>显著降低了 GC 发生前清理当前周期中产生的大量缓存对象的影响：因为回收被推迟到了下个 GC 周期；</li>
<li>显著降低了 GC 发生后 New 对象的成本：因为密集的缓存对象读写可能从上个周期中未清理的对象中偷取。</li>
</ol>
<h2 id="context">Context</h2>
<p>上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p>
<p>context.Context 是 Go 语言在 1.7 版本中引入标准库的接口1，该接口定义了四个需要实现的方法，其中包括：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>
	<span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Deadline 方法会返回这个 Context 被取消的截止日期。如果没有设置截止日期,ok 的值是 false。后续每次调用这个对象的 Deadline 方法时,都会返回和第一次调用相同的结果。</p>
<p>Done 方法返回一个 Channel 对象。在 Context 被取消时,此 Channel 会被 close,如果没被取消,可能会返回 nil。后续的 Done 调用总是返回相同的结果。当 Done 被 close 的时候,你可以通过 ctx.Err 获取错误信息。Done 这个方法名其实起得并不好,因为名字太过笼统,不能明确反映 Done 被 close 的原因,因为 cancel、timeout、deadline 都可能导致 Done 被 close,不过,目前还没有一个更合适的方法名称。</p>
<p>关于 Done 方法,你必须要记住的知识点就是:如果 Done 没有被 close,Err 方法返回 nil;如果 Done 被 close,Err 方法会返回 Done 被 close 的原因。</p>
<p>Value 返回此 ctx 中和指定的 key 相关联的 value。返回绑定在该 Context 链上的给定的 Key 的值，如果没有，则返回 nil。注意，不要用于在函数中传参，其本意在于共享一些横跨整个 Context 生命周期范围的值。Key 可以是任何可比较的类型。为了防止 Key 冲突，最好将 Key 的类型定义为非导出类型，然后为其定义访问器。</p>
<p>Err 在上述 channel 被 close 前会返回 nil，在被 close 后会返回该 Context 被关闭的信息，error 类型，只有两种，被取消或者超时：</p>
<ol>
<li>
<p>如果 context.Context 被取消，会返回 Canceled 错误；</p>
</li>
<li>
<p>如果 context.Context 超时，会返回 DeadlineExceeded 错误；</p>
</li>
</ol>
<p>context 包中提供的 context.Background、context.TODO、context.WithDeadline 和 context.WithValue 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们的工作原理。</p>
<p>Value举例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">user</span>

<span class="kn">import</span> <span class="s">&#34;context&#34;</span>

<span class="c1">// User 是要存于 Context 中的 Value 类型.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="c1">// key 定义为了非导出类型，以避免和其他 package 中的 key 冲突
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">key</span> <span class="kt">int</span>

<span class="c1">// userKey 是 Context 中用来关联 user.User 的 key，是非导出变量
</span><span class="c1">// 客户端需要用 user.NewContext 和 user.FromContext 构建包含
</span><span class="c1">// user 的 Context 和从 Context 中提取相应 user
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">userKey</span> <span class="nx">key</span>

<span class="c1">// NewContext 返回一个带有用户值 u 的 Context.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">u</span> <span class="o">*</span><span class="nx">User</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">userKey</span><span class="p">,</span> <span class="nx">u</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// FromContext 从 Context 中提取 user，如果有的话.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">FromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">User</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">userKey</span><span class="p">).(</span><span class="o">*</span><span class="nx">User</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="emptyctx">emptyCtx</h3>
<p>emptyCtx经常被用作在跟节点或者说是最上层的context，因为context是可以嵌套的。在上面的Withvalue的例子中已经看到，先用emptyCtx创建一个context，然后再使用withValue把之前创建的context传入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">emptyCtx</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为了减轻gc压力，emptyCtx其实是一个int，并且通过空方法实现了 context.Context 接口中的所有方法，它没有任何功能。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210519124926.png" alt=""></p>
<p>context 包中最常用的方法还是 context.Background、context.TODO，这两个方法都会返回预先初始化好的私有变量 background 和 todo，它们会在同一个 Go 程序中被复用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">background</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
	<span class="nx">todo</span>       <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Background</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">background</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TODO</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">todo</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这两个私有变量都是通过 new(emptyCtx) 语句初始化的，它们是指向私有结构体 context.emptyCtx 的指针，</p>
<p>从源代码来看，context.Background 和 context.TODO 也只是互为别名，没有太大的差别，只是在使用和语义上稍有不同：</p>
<ul>
<li>context.Background():返回一个非 nil 的、空的 Context,没有任何值,不会被 cancel,不会超时,没有截止日期。一般用在主函数、初始化、测试以及创建根 Context 的时候。</li>
<li>context.TODO():返回一个非 nil 的、空的 Context,没有任何值,不会被 cancel,不会超时,没有截止日期。当你不清楚是否该用 Context,或者目前还不知道要传递一些什么上下文信息的时候,就可以使用这个方法。</li>
</ul>
<p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 context.Background 作为起始的上下文向下传递。</p>
<p>所以千万不要用nil作为context，并且从易于理解的角度出发，未考虑清楚是否传递、如何传递context时用TODO，其他情况都用Background()，如请求入口初始化context</p>
<h3 id="cancelctx">cancelCtx</h3>
<p>cancelCtx是context实现里最重要的一环，context的取消几乎都是使用了这个对象。WithDeadline WithTimeout其实最终都是调用的cancel的cancel函数来实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A cancelCtx can be canceled. When canceled, it also cancels any children
</span><span class="c1">// that implement canceler.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">cancelCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Context</span>

	<span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>            <span class="c1">// protects following fields
</span><span class="c1"></span>	<span class="nx">done</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>         <span class="c1">// created lazily, closed by first cancel call
</span><span class="c1"></span>	<span class="nx">children</span> <span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// set to nil by the first cancel call
</span><span class="c1"></span>	<span class="nx">err</span>      <span class="kt">error</span>                 <span class="c1">// set to non-nil by the first cancel call
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="c1">// 用了一个特殊的 key：cancelCtxKey，遇到该 key 时，cancelCtx 会返回自身。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// c.done 是“懒汉式”创建，只有调用了 Done() 方法的时候才会被创建。再次说明，函数返回的是一个只读的 channel，而且没有地方向这个 channel 里面写数据。所以，直接调用读这个 channel，协程会被 block 住。一般通过搭配 select 来使用。一旦关闭，就会立即读出零值。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="p">}</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的mu是context并发安全的关键、done是通知的关键、children存储结构是内部最常用传导context的方式。</p>
<p>记住,不是只有你想中途放弃,才去调用 cancel,只要你的任务正常完成了,就需要调用 cancel,这样,这个 Context 才能释放它的资源(通知它的 children 处理 cancel,从它的 parent 中把自己移除,甚至释放相关的 goroutine)。很多同学在使用这个方法的时候,都会忘记调用 cancel,切记切记,而且一定尽早释放。</p>
<h4 id="canceler">canceler</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A canceler is a context type that can be canceled directly. The
</span><span class="c1">// implementations are *cancelCtx and *timerCtx.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">canceler</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实现了上面定义的两个方法的 Context，就表明该 Context 是可取消的。源码中有两个类型实现了 canceler 接口：<code>*cancelCtx</code> 和 <code>*timerCtx</code>。注意是加了 * 号的，是这两个结构体的指针实现了 canceler 接口。</p>
<p>Context 接口设计成这个样子的原因：</p>
<ul>
<li>“取消”操作应该是建议性，而非强制性
caller 不应该去关心、干涉 callee 的情况，决定如何以及何时 return 是 callee 的责任。caller 只需发送“取消”信息，callee 根据收到的信息来做进一步的决策，因此接口并没有定义 cancel 方法。</li>
<li>“取消”操作应该可传递
“取消”某个函数时，和它相关联的其他函数也应该“取消”。因此，Done() 方法返回一个只读的 channel，所有相关函数监听此 channel。一旦 channel 关闭，通过 channel 的“广播机制”，所有监听者都能收到。</li>
</ul>
<h4 id="cancel">cancel</h4>
<p>总体来看，cancel() 方法的功能就是关闭 channel：c.done；递归地取消它的所有子节点；从父节点从删除自己。达到的效果是通过关闭 channel，将取消信号传递给了它的所有子节点。goroutine 接收到取消信号的方式就是 select 语句中的读 c.done 被选中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 已经被其他 goroutine 取消
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 记下错误，并关闭 done
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="nx">closedchan</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 遍历它的所有子节点
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="c1">// 递归地取消所有子节点
</span><span class="c1"></span>		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 将子节点置空
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
		<span class="c1">// 从父节点中移除自己
</span><span class="c1"></span>		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>cancel 是向下传递的,如果一个 WithCancel 生成的 Context 被 cancel 时,如果它的子 Context(也有可能是孙,或者更低,依赖子的类型)也是 cancelCtx 类型的,就会被 cancel,但是不会向上传递。parent Context 不会因为子 Context 被 cancel 而 cancel。</p>
<h4 id="propagatecancel">propagateCancel</h4>
<p>context.propagateCancel 会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// propagateCancel arranges for child to be canceled when parent is.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">child</span> <span class="nx">canceler</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="c1">// 如果parent.Done是nil，则不做任何处理，因为parent context永远不会取消，比如TODO()、Background()、WithValue等
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 父上下文不会触发取消信号
</span><span class="c1"></span>		<span class="k">return</span> <span class="c1">// parent is never canceled
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 当 child 的继承链包含可以取消的上下文时，会判断 parent 是否已经触发了取消信号；
</span><span class="c1"></span>	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
		<span class="c1">// 如果已经被取消，child 会立刻被取消；
</span><span class="c1"></span>		<span class="c1">// parent is already canceled
</span><span class="c1"></span>		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
		<span class="c1">// 父上下文已经被取消
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>
	<span class="c1">// 如果没有被取消，child 会被加入 parent 的 children 列表中，等待 parent 释放取消信号；
</span><span class="c1"></span>	<span class="c1">// context包内部可以直接识别、处理的类型
</span><span class="c1"></span>	<span class="c1">// parentCancelCtx根据parent context的类型，返回bool型ok
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// ok为真时需要建立parent对应的children，并保存parent-&gt;child映射关系
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// parent has already been canceled
</span><span class="c1"></span>			<span class="c1">// 父节点已经被取消了，本节点（子节点）也要取消
</span><span class="c1"></span>			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
			<span class="p">}</span>
			<span class="c1">// 父节点未取消
</span><span class="c1"></span>			<span class="c1">// &#34;挂到&#34;父节点上
</span><span class="c1"></span>			<span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">goroutines</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1">// 当父上下文是开发者自定义的类型、实现了 context.Context 接口并在 Done() 方法中返回了非空的管道时；
</span><span class="c1"></span>		<span class="c1">// 运行一个新的 Goroutine 同时监听 parent.Done() 和 child.Done() 两个 Channel；
</span><span class="c1"></span>		<span class="c1">// 这里children的key是canceler接口，并不能处理所有的外部类型，所以会有else,对于其他外部类型，不建立直接的传递关系。
</span><span class="c1"></span>		<span class="c1">// 如果没有找到可取消的父 context。新启动一个协程监控父节点或子节点取消信号
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="c1">// 在 parent.Done() 关闭时调用 child.cancel 取消子上下文；
</span><span class="c1"></span>				<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">child</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法的作用就是向上寻找可以“挂靠”的“可取消”的 context，并且“挂靠”上去。这样，调用上层 cancel 方法的时候，就可以层层传递，将那些挂靠的子 context 同时“取消”。</p>
<p>这里着重解释下为什么会有 else 描述的情况发生。else 是指当前节点 context 没有向上找到可以取消的父节点，那么就要再启动一个协程监控父节点或者子节点的取消动作。</p>
<p>这里就有疑问了，既然没找到可以取消的父节点，那 case &lt;-parent.Done() 这个 case 就永远不会发生，所以可以忽略这个 case；而 case &lt;-child.Done() 这个 case 又啥事不干。那这个 else 不就多余了吗？</p>
<p>其实不然。我们来看 parentCancelCtx 的代码：</p>
<p>parentCancelCtx定义如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">cancelCtxKey</span> <span class="kt">int</span>

<span class="c1">// parentCancelCtx returns the underlying *cancelCtx for parent.
</span><span class="c1">// It does this by looking up parent.Value(&amp;cancelCtxKey) to find
</span><span class="c1">// the innermost enclosing *cancelCtx and then checking whether
</span><span class="c1">// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx
</span><span class="c1">// has been wrapped in a custom implementation providing a
</span><span class="c1">// different done channel, in which case we should not bypass it.)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">cancelCtx</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">done</span> <span class="o">==</span> <span class="nx">closedchan</span> <span class="o">||</span> <span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cancelCtxKey</span><span class="p">).(</span><span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">ok</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="nx">done</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="withcancel">WithCancel</h4>
<p>当 WithCancel 函数返回的 CancelFunc 被调用或者是父节点的 done channel 被关闭（父节点的 CancelFunc 被调用），此 context（子节点） 的 done channel 也会被关闭。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>cancelCtx.cancel 是非导出函数，不能在 context 包外调用，因此持有 Context 的内层过程不能自己取消自己，须由返回的 CancelFunc （简单的包裹了 cancelCtx.cancel ）来取消，其句柄一般为外层过程所持有。</p>
<p>注意传给 WithCancel 方法的参数，前者是 true，也就是说取消的时候，需要将自己从父节点里删除。第二个参数则是一个固定的取消错误类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">Canceled</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;context canceled&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>还注意到一点，调用子节点 cancel 方法的时候，传入的第一个参数 removeFromParent 是 false。</p>
<p>两个问题需要回答：</p>
<ol>
<li>什么时候会传 true？</li>
<li>为什么有时传 true，有时传 false？</li>
</ol>
<p>当 removeFromParent 为 true 时，会将当前节点的 context 从父节点 context 中删除：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">removeChild</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">child</span> <span class="nx">canceler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">delete</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最关键的一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">delete</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>什么时候会传 true 呢？答案是调用 WithCancel() 方法的时候，也就是新创建一个可取消的 context 节点时，返回的 cancelFunc 函数会传入 true。这样做的结果是：当调用返回的 cancelFunc 时，会将这个 context 从它的父节点里“除名”，因为父节点可能有很多子节点，你自己取消了，所以我要和你断绝关系，对其他人没影响。</p>
<p>在取消函数内部，我知道，我所有的子节点都会因为我的：<code>c.children = nil</code> 而化为灰烬。我自然就没有必要再多做这一步，最后我所有的子节点都会和我断绝关系，没必要一个个做。另外，如果遍历子节点的时候，调用 child.cancel 函数传了 true，还会造成同时遍历和删除一个 map 的境地，会有问题的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210519231733.png" alt=""></p>
<p>如上左图，代表一棵 context 树。当调用左图中标红 context 的 cancel 方法后，该 context 从它的父 context 中去除掉了：实线箭头变成了虚线。且虚线圈框出来的 context 都被取消了，圈内的 context 间的父子关系都荡然无存了。</p>
<h4 id="newcancelctx">newCancelCtx</h4>
<p>context.newCancelCtx 将传入的上下文包装成私有结构体 context.cancelCtx；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// newCancelCtx returns an initialized cancelCtx.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="nx">cancelCtx</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">cancelCtx</span><span class="p">{</span><span class="nx">Context</span><span class="p">:</span> <span class="nx">parent</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="timerctx">timerCtx</h3>
<p>timerCtx内部包含了cancelCtx，然后通过定时器，实现了到时取消的功能，定义如下:</p>
<p>context.timerCtx 内部不仅通过嵌入 context.cancelCtx 结构体继承了相关的变量和方法，还通过持有的定时器 timer 和截止时间 deadline 实现了定时取消的功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">timerCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cancelCtx</span>
	<span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// Under cancelCtx.mu.
</span><span class="c1"></span>
	<span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">deadline</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了 context.WithCancel 之外，context 包中的另外两个函数 context.WithDeadline 和 context.WithTimeout 也都能创建可以被取消的计时器上下文 context.timerCtx：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="withdeadline">WithDeadline</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 如果父节点 context 的 deadline 早于指定时间。直接构建一个可取消的 context。
</span><span class="c1"></span>        <span class="c1">// 原因是一旦父节点超时，自动调用 cancel 函数，子节点也会随之取消。
</span><span class="c1"></span>        <span class="c1">// 所以不用单独处理子节点的计时器时间到了之后，自动调用 cancel 函数
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 构建 timerCtx
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
		<span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
		<span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="c1">// 挂靠到父节点上
</span><span class="c1"></span>	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="c1">// 计算当前距离 deadline 的时间
</span><span class="c1"></span>	<span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 直接取消
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span> <span class="c1">// 已经过了截止日期
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// d 时间后，timer 会自动调用 cancel 函数。自动取消
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>context.WithDeadline 在创建 context.timerCtx 的过程中判断了父上下文的截止日期与当前日期，并通过 time.AfterFunc 创建定时器，当时间超过了截止日期后会调用 context.timerCtx.cancel 同步取消信号。</p>
<p>也就是说仍然要把子节点挂靠到父节点，一旦父节点取消了，会把取消信号向下传递到子节点，子节点随之取消。</p>
<p>有一个特殊情况是，如果要创建的这个子节点的 deadline 比父节点要晚，也就是说如果父节点是时间到自动取消，那么一定会取消这个子节点，导致子节点的 deadline 根本不起作用，因为子节点在 deadline 到来之前就已经被父节点取消了。</p>
<p>这个函数的最核心的一句是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>c.timer 会在 d 时间间隔后，自动调用 cancel 函数，并且传入的错误就是 DeadlineExceeded：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">DeadlineExceeded</span> <span class="kt">error</span> <span class="p">=</span> <span class="nx">deadlineExceededError</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">deadlineExceededError</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">deadlineExceededError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>   <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;context deadline exceeded&#34;</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是超时错误。</p>
<h4 id="cancel-1">cancel</h4>
<p>context.timerCtx.cancel 方法不仅调用了 context.cancelCtx.cancel，还会停止持有的定时器减少不必要的资源浪费。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="valuectx">valueCtx</h3>
<p>valueCtx只用来传值，当然也可以传递，所有context都可以传递，定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A valueCtx carries a key-value pair. It implements Value for that key and
</span><span class="c1">// delegates all other calls to the embedded Context.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">valueCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Context</span>
	<span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>context.valueCtx 结构体会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，它只会响应 context.valueCtx.Value 方法，该方法的实现也很简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它会顺着链路一直往上找，比较当前节点的 key 是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</p>
<p>因为查找方向是往上走的，所以，父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p>
<p>在最后我们需要了解如何使用上下文传值，context 包中的 context.WithValue 能从父上下文中创建一个子上下文，传值的子上下文使用 context.valueCtx 类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="c1">// key必须为非空
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 对 key 的要求是可比较，因为之后需要通过 key 取出 context 中的值，可比较是必须的。
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">reflectlite</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>valueCtx的key、val都是接口类型，在调用WithValue的时候，内部会首先通过反射确定key是否可比较类型(同map中的key)，然后赋值key</p>
<p>WithValue 创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。查找的时候，会向上查找到最后一个挂载的 context 节点，也就是离得比较近的一个父节点 context。所以，整体上而言，用 WithValue 构造的其实是一个低效率的链表。</p>
<h2 id="atomic">atomic</h2>
<h3 id="原理">原理</h3>
<p>在现在的系统中,write 的地址基本上都是对齐的(aligned)。 比如,32 位的操作系统、CPU 以及编译器,write 的地址总是 4 的倍数,64 位的系统总是 8 的倍数(还记得 WaitGroup 针对 64 位系统和 32 位系统对 state1 的字段不同的处理吗)。对齐地址的写,不会导致其他人看到只写了一半的数据,因为它通过一个指令就可以实现对地址的操作。如果地址不是对齐的话,那么,处理器就需要分成两个指令去处理,如果执行了一个指令,其它人就会看到更新了一半的错误的数据,这被称做撕裂写(torn write) 。所以,你可以认为赋值操作是一个原子操作,这个“原子操作”可以认为是保证数据的完整性。</p>
<p>但是,对于现代的多处理多核的系统来说,由于 cache、指令重排,可见性等问题,我们对原子操作的意义有了更多的追求。在多核系统中,一个核对地址的值的更改,在更新到主内存中之前,是在多级缓存中存放的。这时,多个核看到的数据可能是不一样的,其它的核可能还没有看到更新的数据,还在使用旧的数据。</p>
<p>多处理器多核心系统为了处理这类问题,使用了一种叫做内存屏障(memory fence 或 memory barrier)的方式。一个写内存屏障会告诉处理器,必须要等到它管道中的未完成的操作(特别是写操作)都被刷新到内存中,再进行操作。此操作还会让相关的处理器的 CPU 缓存失效,以便让它们从主存中拉取最新的值。</p>
<p>atomic 包提供的方法会提供内存屏障的功能,所以,atomic 不仅仅可以保证赋值的数据完整性,还能保证数据的可见性,一旦一个核更新了该地址的值,其它处理器总是能读取到它的最新值。但是,需要注意的是,因为需要处理器之间保证数据的一致性,atomic 的操作也是会降低性能的。</p>
<h3 id="原子操作">原子操作</h3>
<p>原子操作依赖硬件指令的支持，但同时还需要运行时调度器的配合。我们以 atomic.CompareAndSwapPointer 为例，介绍 sync/atomic 包提供的同步模式。</p>
<p>CompareAndSwapPointer 它在包中只有函数定义，没有函数体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">swapped</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>其本身由运行时实现。</p>
<p>我们简单看过了两个属于公共包的方法 atomic.Value 和 atomic.CompareAndSwapPointer， 我们来看一下运行时实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname sync_atomic_CompareAndSwapUintptr sync/atomic.CompareAndSwapUintptr
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_atomic_CompareAndSwapUintptr</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="kt">uintptr</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span>

<span class="c1">//go:linkname sync_atomic_CompareAndSwapPointer sync/atomic.CompareAndSwapPointer
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_atomic_CompareAndSwapPointer</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">atomicwb</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">sync_atomic_CompareAndSwapUintptr</span><span class="p">((</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ptr</span><span class="p">))),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">new</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 sync_atomic_CompareAndSwapUintptr 函数在运行时中也是没有方法本体的， 说明其实现由编译器完成。那么我们来看一下编译器究竟干了什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">newP</span> <span class="o">:=</span> <span class="mi">42</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newP</span><span class="p">))</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="n">sync</span><span class="o">/</span><span class="nf">atomic.CompareAndSwapUintptr</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="m">1.11</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">sync</span><span class="o">/</span><span class="n">atomic</span><span class="o">/</span><span class="n">asm.s</span>
  <span class="n">asm.s</span><span class="o">:</span><span class="m">31</span>		<span class="mh">0x1001070</span>		<span class="n">e91b0b0000</span>		<span class="n">JMP</span> <span class="n">runtime</span><span class="o">/</span><span class="n">internal</span><span class="o">/</span><span class="nf">atomic.Casuintptr</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="o">:</span><span class="m">-1</span>			<span class="mh">0x1001075</span>		<span class="n">cc</span>			<span class="n">INT</span> <span class="o">$</span><span class="mh">0x3</span>
  <span class="p">(</span><span class="kc">...</span><span class="p">)</span>

<span class="n">TEXT</span> <span class="n">runtime</span><span class="o">/</span><span class="n">internal</span><span class="o">/</span><span class="nf">atomic.Casuintptr</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="m">1.11</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">internal</span><span class="o">/</span><span class="n">atomic</span><span class="o">/</span><span class="n">asm_amd64.s</span>
  <span class="n">asm_amd64.s</span><span class="o">:</span><span class="m">44</span>	<span class="mh">0x1001b90</span>		<span class="n">e9dbffffff</span>		<span class="n">JMP</span> <span class="n">runtime</span><span class="o">/</span><span class="n">internal</span><span class="o">/</span><span class="nf">atomic.Cas64</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="o">:</span><span class="m">-1</span>			<span class="mh">0x1001b95</span>		<span class="n">cc</span>			<span class="n">INT</span> <span class="o">$</span><span class="mh">0x3</span>
  <span class="p">(</span><span class="kc">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 atomic.CompareAndSwapUintptr 本质上转到了 runtime/internal/atomic.Cas64，我们来看一下它的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-s" data-lang="s"><span class="o">//</span> <span class="n">bool</span>	<span class="n">runtime</span>∕<span class="n">internal</span>∕<span class="n">atomic</span>·<span class="nf">Cas64</span><span class="p">(</span><span class="n">uint64</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">old</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">new</span><span class="p">)</span>
<span class="o">//</span> <span class="n">Atomically</span><span class="o">:</span>
<span class="o">//</span>	<span class="nf">if</span><span class="p">(</span><span class="o">*</span><span class="n">val</span> <span class="o">==</span> <span class="o">*</span><span class="n">old</span><span class="p">){</span>
<span class="o">//</span>		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
<span class="o">//</span>		<span class="n">return</span> <span class="m">1</span><span class="p">;</span>
<span class="o">//</span>	<span class="p">}</span> <span class="n">else</span> <span class="p">{</span>
<span class="o">//</span>		<span class="n">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">//</span>	<span class="p">}</span>
<span class="n">TEXT</span> <span class="n">runtime</span>∕<span class="n">internal</span>∕<span class="n">atomic</span>·<span class="nf">Cas64</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">NOSPLIT</span><span class="p">,</span> <span class="o">$</span><span class="m">0-25</span>
	<span class="n">MOVQ</span>	<span class="n">ptr</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">BX</span>
	<span class="n">MOVQ</span>	<span class="n">old</span><span class="m">+8</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">AX</span>
	<span class="n">MOVQ</span>	<span class="n">new</span><span class="m">+16</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">CX</span>
	<span class="n">LOCK</span>
	<span class="n">CMPXCHGQ</span>	<span class="n">CX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">BX</span><span class="p">)</span>
	<span class="n">SETEQ</span>	<span class="n">ret</span><span class="m">+24</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span>
	<span class="n">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，实现的本质是使用 CPU 的 LOCK<code>+CMPXCHGQ</code> 指令：首先将 ptr 的值放入 BX，将假设的旧值放入 AX， 要比较的新值放入 CX。然后 LOCK CMPXCHGQ 与累加器 AX 比较并交换 CX 和 BX。</p>
<p>因此原子操作本质上均为使用 CPU 指令进行实现（理所当然）。由于原子操作的方式比较单一，很容易举一反三， 其他操作不再穷举。</p>
<h3 id="原子值">原子值</h3>
<p>原子值需要运行时的支持，在原子值进行修改时，Goroutine 不应该被抢占，因此需要锁定 MP 之间的绑定关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname sync_runtime_procPin sync.runtime_procPin
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_procPin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">procPin</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procPin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">_g_</span><span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
<span class="nx">mp</span> <span class="o">:=</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>

	<span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//go:linkname sync_atomic_runtime_procUnpin sync/atomic.runtime_procUnpin
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_atomic_runtime_procUnpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">procUnpin</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procUnpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span><span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>原子值 atomic.Value 提供了一种具备原子存取的结构。其自身的结构非常简单， 只包含一个存放数据的 interface{}：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它仅仅只是对要存储的值进行了一层封装。要对这个值进行原子的读取，依赖 Load 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// LoadPointer atomically loads *addr.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">LoadPointer</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">val</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Value</span><span class="p">)</span> <span class="nf">Load</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// 获得 interface 结构的指针
</span><span class="c1"></span>	<span class="c1">// 在 go 中，interface 的内存布局有类型指针和数据指针两部分表示
</span><span class="c1"></span>	<span class="nx">vp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">ifaceWords</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
	<span class="c1">// 获得存储值的类型指针
</span><span class="c1"></span>	<span class="nx">typ</span> <span class="o">:=</span> <span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">typ</span><span class="p">)</span> <span class="o">==</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 获得存储值的实际数据
</span><span class="c1"></span>	<span class="nx">data</span> <span class="o">:=</span> <span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>

	<span class="c1">// 将复制得到的 typ 和 data 给到 x
</span><span class="c1"></span>	<span class="nx">xp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">ifaceWords</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span>
	<span class="nx">xp</span><span class="p">.</span><span class="nx">typ</span> <span class="p">=</span> <span class="nx">typ</span>
	<span class="nx">xp</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">data</span>
	<span class="k">return</span>
<span class="p">}</span>
<span class="c1">// ifaceWords 定义了 interface{} 的内部表示。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ifaceWords</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">data</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从这个 Load 方法实际上使用了 Go 运行时类型系统中的 interface{} 这一类型本质上由 两段内容组成，一个是类型 typ 区域，另一个是实际数据 data 区域。 这个 Load 方法的实现，本质上就是将内部存储的类型和数据都复制一份并返回。</p>
<p>再来看 Store。存储的思路与读取其实是类似的，但由于类型系统的两段式表示（typ 和 data） 的存在，存储操作比读取操作的实现要更加小心，要考虑当两个不同的 Goroutine 对两段值进行写入时， 如何才能避免写竞争：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// StorePointer atomically stores val into *addr.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">StorePointer</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Value</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync/atomic: store of nil value into Value&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Value 存储值的指针和要存储的 x 的指针
</span><span class="c1"></span>	<span class="nx">vp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">ifaceWords</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
	<span class="nx">xp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">ifaceWords</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">typ</span> <span class="o">:=</span> <span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>

		<span class="c1">// v 还未被写入过任何数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 禁止抢占当前 Goroutine 来确保存储顺利完成
</span><span class="c1"></span>			<span class="nf">runtime_procPin</span><span class="p">()</span>
			<span class="c1">// 先存一个标志位，宣告正在有人操作此值
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
				<span class="c1">// 如果没有成功，取消不可抢占，下次再试
</span><span class="c1"></span>				<span class="nf">runtime_procUnpin</span><span class="p">()</span>
				<span class="k">continue</span>
			<span class="p">}</span>

			<span class="c1">// 如果标志位设置成功，说明其他人都不会向 interface{} 中写入数据
</span><span class="c1"></span>			<span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">xp</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
			<span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="nx">xp</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
			<span class="c1">// 存储成功，再标志位可抢占，直接返回
</span><span class="c1"></span>			<span class="nf">runtime_procUnpin</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// 有其他 Goroutine 正在对 v 进行写操作
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">typ</span><span class="p">)</span> <span class="o">==</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// 如果本次存入的类型与前次存储的类型不同
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">typ</span> <span class="o">!=</span> <span class="nx">xp</span><span class="p">.</span><span class="nx">typ</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync/atomic: store of inconsistently typed value into Value&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 类型已经写入，直接保存数据
</span><span class="c1"></span>		<span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">vp</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">xp</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 atomic.Value 的存取通过 unsafe.Pointer(^uintptr(0)) 作为第一次存取的标志位， 当 atomic.Value 第一次写入数据时，会将当前 Goroutine 设置为不可抢占， 并将要存储类型进行标记，再存入实际的数据与类型。当存储完毕后，即可解除不可抢占，返回。</p>
<p>在不可抢占期间，且有并发的 Goroutine 再此存储时，如果标记没有被类型替换掉， 则说明第一次存储还未完成，形成 CompareAndSwap 循环进行等待。</p>
<h2 id="参考">参考</h2>
<p><a href="https://colobu.com/2017/07/11/dive-into-sync-Map">https://colobu.com/2017/07/11/dive-into-sync-Map</a></p>
<p><a href="https://segmentfault.com/a/1190000015242373">https://segmentfault.com/a/1190000015242373</a></p>
<p><a href="https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/">https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/</a></p>
<p><a href="http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html">http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html</a></p>
<p><a href="http://www.gogodjzhu.com/index.php/code/basic/397/">http://www.gogodjzhu.com/index.php/code/basic/397/</a></p>
<p><a href="http://russellluo.com/2017/06/go-sync-map-diagram.html">http://russellluo.com/2017/06/go-sync-map-diagram.html</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/cond/">5.4 条件变量</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/waitgroup/">5.5 同步组</a></p>
<p><a href="https://blog.csdn.net/sinat_41790904/article/details/115416237">Go 标准库源码分析 - sync 包的Pool</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/map/">5.7 并发安全散列表</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">6.1 上下文 Context</a></p>
<p><a href="https://juejin.cn/post/6844903741842259975">go context剖析之源码分析</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/atomic/">5.3 原子操作</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-01-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go实现分片锁</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E4%BD%BF%E7%94%A8commitizen%E8%A7%84%E8%8C%83git%E6%8F%90%E4%BA%A4%E8%AF%B4%E6%98%8E/">
            <span class="next-text nav-default">使用commitizen规范Git提交说明</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
