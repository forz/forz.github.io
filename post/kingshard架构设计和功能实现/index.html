<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kingshard架构设计和功能实现 | Forz Blog</title>
<meta name="keywords" content="Kingshard" />
<meta name="description" content="kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力">
<meta name="author" content="">
<link rel="canonical" href="/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Kingshard架构设计和功能实现" />
<meta property="og:description" content="kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-24T17:13:47&#43;00:00" />
<meta property="article:modified_time" content="2020-03-24T17:13:47&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kingshard架构设计和功能实现"/>
<meta name="twitter:description" content="kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Kingshard架构设计和功能实现",
      "item": "/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kingshard架构设计和功能实现",
  "name": "Kingshard架构设计和功能实现",
  "description": "kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力",
  "keywords": [
    "Kingshard"
  ],
  "articleBody": "kingshard简介 kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力于简化MySQL分库分表操作；能够让DBA通过kingshard轻松平滑地实现MySQL数据库扩容。 kingshard的性能是直连MySQL性能的80%以上。\n主要功能： 1. 基础功能  支持SQL读写分离。 支持透明的MySQL连接池，不必每次新建连接。 支持平滑上线DB或下线DB，前端应用无感知。 支持多个slave，slave之间通过权值进行负载均衡。 支持强制读主库。 支持主流语言（java,php,python,C/C++,Go)SDK的mysql的prepare特性。 支持到后端DB的最大连接数限制。 支持SQL日志及慢日志输出。 支持SQL黑名单机制。 支持客户端IP访问白名单机制，只有白名单中的IP才能访问kingshard（支持IP 段）。 支持字符集设置。 支持last_insert_id功能。 支持热加载配置文件，动态修改kingshard配置项（具体参考管理端命令）。 支持以Web API调用的方式管理kingshard。 支持多用户模式，不同用户之间的表是权限隔离的，互不感知。  2. sharding功能  支持按整数的hash和range分表方式。 支持按年、月、日维度的时间分表方式。 支持跨节点分表，子表可以分布在不同的节点。 支持跨节点的count,sum,max和min等聚合函数。 支持单个分表的join操作，即支持分表和另一张不分表的join操作。 支持跨节点的order by,group by,limit等操作。 支持将sql发送到特定的节点执行。 支持在单个节点上执行事务，不支持跨多节点的分布式事务。 支持非事务方式更新（insert,delete,update,replace）多个node上的子表。  kingshard架构设计和功能实现 1. 整体架构 kingshard采用Go开发，充分地利用了Go语言的并发特性。Go语言在并发方面，做了很好的封装，这大大简化了kingshard的开发工作。kingshard的整体工作流程如下所述：\n 读取配置文件并启动，在配置文件中设置的监听端口监听客户端请求。 收到客户端连接请求后，启动一个goroutine单独处理该请求。 首选进行登录验证，验证过程完全兼容MySQL认证协议，由于用户名和密码在配置文件中已经设置好，所以可以利用该信息验证连接请求是否合法。当用户名和密码都正确时，转入下面的步骤，否则返回出错信息给客户端。 认证通过后，客户端发送SQL语句。 kingshard对客户端发送过来的SQL语句，进行词法和语义分析，识别出SQL的类型和生成SQL的路由计划。如果有必要还会改写SQL，然后转发到相应的DB。也有可能不做词法和语义分析直接转发到相应的后端DB。如果转发SQL是分表且跨多个DB，则每个DB对应启动一个goroutine发送SQL和接收该DB返回的结果。 接收并合并结果，然后转发给客户端。  kingshard工作整体流程可参考下面这幅图。\nkingshard整体架构图如下所示\n2. 词法和语义分析 要将kingshard的功能做的足够强大，就不得不进行SQL的词法和语义分析。SQL语句的词法分析指的是将SQL语句切分成一个一个的关键字。例如对SQL语句：select name from stu where id 进行词法分析，得到的结果是：{\"select\",\"name\",\"from\",\"stu\",\"where\",\"id\",\"。这样做的目的主要为了生成一棵抽象语法树，也就是大家常说的AST(abstract syntax tree),语义分析就是基于这棵语法树来操作的。语义分析的目的主要有以下几个方面：\n 读写分离，只有识别出SQL语句的类型，才能进行正确的读写分离操作。 数据分片，解析出表名和查询条件，将SQL路由到正确的DB。 SQL黑名单，通过词法和语义分析，也可以快速识别出需要屏蔽的SQL语句。例如，检测到delete语句不带where操作，就可以直接阻断该SQL的转发。  kingshard并没有考虑完全兼容MySQL所有语法，因为完全兼容MySQL语法会使得词法和语义分析模块变得异常复杂，而且低效。对于DDL语句其实没必要解析，只要能正确转发到后端相应的DB上就可以。\nkingshard只对部分DML语句（select,update,insert,delete,replace)进行了解析，这样可以满足绝大部分的分表操作。对于其他语句，kingshard会将其发送到一个默认的DB，或者通过kingshard特有的方式将其发送到指定的DB上，例如：/*node2*/insert into stu（id,name) values(12,'xiaoming'),对于这种带有注释的的sql语句，kingshard能够识别出，然后将这条sql语句发送到node2节点的Master DB上。\n3. 负载均衡 用户使用Mysql Proxy目的很大一部分就是为了降低单台DB的负载，将读压力分担到多台DB上。kingshard支持多个slave，不同的slave可以配置不同的读权重，权重越大分担的读请求越多。kingshard读请求负载均衡采用的是权重轮询调度算法。\n大部分系统采用该算法时，都是转发SQL语句时，动态地计算出本次选取DB的序号。然后将读请求的SQL语句发送到该DB。仔细分析一下，这样做其实是没有必要的。因为DB的权重是相对固定的，不会经常变动，所以完全可以计算出一个固定的轮询序列，然后将这个序列保存在一个数组中。这样不需要动态计算，每次读取数组就可以。举个例子来说，在kingshard的node配置项中配置slave选项：\nslave:192.168.0.12@2,192.168.0.13@3\nkingshard在读取配置信息初始化系统的时候，就生成了一个轮询数组:[0,0,1,1,1]。在kingshard中会将这个数组打乱顺序，变成：[0,1,1,0,1]。这样就避免了动态计算DB下标的问题，对性能提升有一定帮助。\n4.sharding实现 首选需要介绍两个概念：\n  子表，在kingshard中一张逻辑上的大表由若干张小的子表组成。例如：将stu表分成stu_0000,stu_0001,stu_0002,stu_0003。 在数据库中stu表是不存在的，它只是一张逻辑上的表。数据库中只存在四张子表（stu_0000,stu_0001,stu_0002,stu_0003）。 发送SQL语句时，kingshard会识别出需要分表的SQL语句，并改写该SQL。例如，客户端发送过来的SQL语句是：select name from stu where id =10; kingshard收到该SQL语句后，从配置信息中识别出该表是一个Hash类型的分表。根据分表规则，将该SQL改写成：select name from stu_2 where id =10; 然后发送给对应的DB。\n  Node，子表分布在各个node上，每个node包含一个maser server和若干个slave server（slave个数可以为0）。写请求会发往该node中master server，读请求会发往该node中的slave server。\n  kingshard的sharding采用了两级映射的思想，首选根据SQL语句的分表条件计算出这条SQL语句落在哪个子表上，然后再根据配置信息找到该子表落在哪个node上。采用两级映射的思想，对于MySQL的扩容和缩容都能很方便地支持。目前kingshard sharding支持insert, delete, select, update和replace语句, 所有这五类操作都支持跨子表。但写操作仅支持单node上的跨子表，select操作则可以跨node，跨子表。\n对于有些表没有分表，操作该表的SQL语句会发往default node。或者用户可以选择在SQL语句前面加上注释，指定该SQL要发往的node，kingshard接收到语句后，识别出注释中指定的node，然后将该SQL发往对应node中合适的DB。例如用户发送/*node1*/select * from member where id=100,kingshard接收到该SQL后会将其发送到node1的salve上。这样kingshard就能很好地兼容分表和不分表的各种应用场景了。\n5. 事务的实现 所有proxy支持shard后都会面临一个问题：支不支持分布式事务？出于性能和可用性考虑， kingshard只支持单台DB上的事务，不允许跨DB的事务。kingshard处理单DB上的事务流程如下：\n 用户发送begin语句。 kingshard接收到SQL语句后，将该连接的状态设置为事务。 用户发送DML语句，kingshard识别出语句需要发送到的DB，然后kingshard新建一个与后端DB的连接，利用该连接发送语句。 收取SQL语句的结果后，将连接放回。 kingshard收到下一条SQL语句，判断该SQL是不是发往同一个DB，如果不是则报错。如果是发往同一个DB，则利用该连接发送语句。 收到用户发送的commit语句，将该连接的状态设置为非事务，事务结束。  6. 后端DB存活检测 kingshard每个node启动了一个goroutine用于检测后端master和slave的状态。当goroutine持续一段时间（由配置文件中down_after_noalive参数设置）ping不通后端的DB后，会将该DB的状态设置为down，后续kingshard就不会将sql语句发往该DB了。\n7. 客户端白名单机制 有时候用户为了安全考虑，希望只只允许某几台server连接kingshard。在kingshard的配置文件中有一个参数：allow_ips，用于实现客户端白名单机制。当管理员设置了该参数，则意味着只有allow_ips指定的IP能够连接kingshard，其他IP都会被kingshard拒绝连接。如果不设置该参数，则连接kingshard的客户端不受限制。\n8. 管理端设计和实现 kingshard的管理端口复用了工作端口，通过特定的关键字(admin)来标示。kingshard是通过对管理端特定的SQL进行词法和语义分析，将SQL语句解析为一条kingshard可以识别的命令。目前支持平滑上下线master和slave，和查看kingshard配置和后端DB状态。后续打算将web页面集成到管理端，这样用户就可以不用输入命令行操作，而是在网页上操作。大大降低用户使用kingshard的门槛。\nkingshard性能优化网络篇 1. 发现kingshard的性能瓶颈 首选，对kingshard进行性能优化，我们必须要找到kingshard的性能瓶颈在哪里。Go语言在性能优化支持方面做的非常好，借助于go语言的pprof工具，我们可以通过简单的几个步骤，就能得到kingshard在转发SQL请求时的各个函数耗时情况。\n1.1 环境搭建 根据kingshard使用指南搭建一个kingshard代理环境。我是用macbook搭建的环境，硬件参数如下所示：\n1 2 3 4  CPU： 2.2GHZ * 4 内存：16GB 硬盘: 256GB   1.2 性能测试步骤 具体步骤如下所述：\n1.获取一个性能分析的封装库\n1  go get github.com/pkg/profile   2.在工程内import这个组件\n3.在kingshard/cmd/kingshard/main.go的main函数开始部分添加CPU监控的启动和停止入口\n1 2 3 4 5 6 7  func main() { defer profile.Start(profile.CPUProfile).Stop() fmt.Print(banner) runtime.GOMAXPROCS(runtime.NumCPU()) flag.Parse() .... }   4.重新编译工程, 运行kingshard\n1  ./bin/kingshard -config=etc/ks.yaml   5.kingshard启动后会在终端输出下面一段提示：\n1  2015/10/31 10:28:06 profile: cpu profiling enabled, /var/folders/4q/zzb55sfj377b6vdyz2brt6sc0000gn/T/profile205276958/cpu.pprof   后面的路径就是pprof性能分析文件的位置，Ctrl+C中断服务器\n6.这时候用sysbench对kingshard进行压力测试，得到QPS（有关sysbench的安装和使用，请自行Google解决）。具体的代码如下所示：\n1 2  sysbench --test=oltp --num-threads=16 --max-requests=160000 --oltp-test-mode=nontrx --db-driver=mysql --mysql-db=kingshard --mysql-host=127.0.0.1 --mysql-port=9696 --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-user=kingshard --mysql-password=kingshard --oltp-nontrx-mode=select --db-ps-mode=disable run   得到如下结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  OLTP test statistics: queries performed: read: 160071 write: 0 other: 0 total: 160071 transactions: 160071 (16552.58 per sec.) deadlocks: 0 (0.00 per sec.) read/write requests: 160071 (16552.58 per sec.) other operations: 0 (0.00 per sec.) Test execution summary: total time: 9.6705s total number of events: 160071 total time taken by event execution: 154.4474 per-request statistics: min: 0.29ms avg: 0.96ms max: 14.17ms approx. 95 percentile: 1.37ms Threads fairness: events (avg/stddev): 10004.4375/24.95 execution time (avg/stddev): 9.6530/0.00     按照上述步骤测试三次（16552.58,16769.72,16550.16）取平均值，得到优化前kingshard的QPS是：16624.15\n  按照上述步骤，直连MySQL。测试直连MySQL的QPS，同样测试三次QPS（27730.90，28499.05，27119.20），得到直连MySQL的QPS是：27783.05。\n  从上述数据可以计算出kingshard转发SQL的性能是直连MySQL的59%左右。\n  7.将cpu.prof拷贝到bin/kingshard所在位置\n8.调用go tool工具制作CPU耗时的PDF文档\n1  go tool pprof -pdf ./kingshard cpu.pprof  report.pdf   2. 性能测试报告分析 通过上述命令，可以生成压测期间主要函数耗时情况。从report来看，主要的耗时在TCP层数据包的收发上面。那我们应该主要考虑如何优化TCP层数据的收发方面。优化TCP传输效率，我首先想到了减少系统调用，每个数据包传输尽量多的数据。\n在通过 TCP socket 进行通信时，数据都拆分成了数据块，这样它们就可以封装到给定连接的 TCP payload（指 TCP 数据包中的有效负荷）中了。TCP payload 的大小取决于几个因素（例如最大报文长度和路径），但是这些因素在连接发起时都是已知的。为了达到最好的性能，我们的目标是使用尽可能多的可用数据来填充每个报文。当没有足够的数据来填充 payload 时（也称为最大报文段长度（maximum segment size） 或 MSS），TCP 就会采用 Nagle 算法自动将一些小的缓冲区连接到一个报文段中。这样可以通过最小化所发送的报文的数量来提高应用程序的效率，并减轻整体的网络拥塞问题。\n由于这种算法对数据进行合并，试图构成一个完整的 TCP 报文段，因此它会引入一些延时。但是这种算法可以最小化在线路上发送的报文的数量，因此可以最小化网络拥塞的问题。但是在需要最小化传输延时的情况中，GO语言中Sockets API 可以提供一种解决方案。就是通过：\n1  func (c *TCPConn) SetNoDelay(noDelay bool) error   这个函数在Go中默认情况下，是设置为true，也就是未开启延迟选项。我们需要将其设置为false选项，来达到每个数据包传输尽量多的数据，减少系统调用的目的。\n2.1 代码修改和性能测试 发现了性能瓶颈以后，修改proxy/server/server.go文件中的newClientConn函数和backend/backend_conn.go中的ReConnect函数，分别设置client与kingshard之间的连接和kingshard到MySQL之间的连接为最小化传输延时。具体的代码修改可以查看这个\n修改后我们利用sysbench重新测试，测试命令和上述测试一致。得到的结果如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  OLTP test statistics: queries performed: read: 160174 write: 0 other: 0 total: 160174 transactions: 160174 (21291.68 per sec.) deadlocks: 0 (0.00 per sec.) read/write requests: 160174 (21291.68 per sec.) other operations: 0 (0.00 per sec.) Test execution summary: total time: 7.5228s total number of events: 160174 total time taken by event execution: 119.9655 per-request statistics: min: 0.26ms avg: 0.75ms max: 10.78ms approx. 95 percentile: 1.13ms Threads fairness: events (avg/stddev): 10010.8750/38.65 execution time (avg/stddev): 7.4978/0.00   测试三次得到的QPS为：21291.68,21670.85,21463.44。 相当于直连MySQL性能的77%左右，通过这个优化性能提升了18%左右。\n总结 通过这篇文章，介绍了通过Go语言提供的pprof对kingshard进行性能分析的详细步骤。对于其他Go语言项目也可以通过类似步骤生成性能报告文档。性能优化的关键是发现性能瓶颈，再去找优化方案。有时候简单的优化，就可以达到预想不到的效果，希望本文能给Go开发者在性能优化方面提供一个思路。\nkingshard的性能测试报告 1.测试环境 1.1服务器配置    类别 名称     OS 云主机 Ubuntu 14.04 LTS   CPU Common KVM CPU @ 2.40GHz *4   RAM 8GB   DISK 500GB   kingshard master分支   Mysql v5.6.25   Sysbench v0.5    2.性能需求  测试通过kingshard转发SQL请求与直连DB发送SQL请求这两种情形下的性能差距。 测试配置文件中max_conns_limit参数对kingshard的影响，并找出最优值。  3.测试准备工作 3.1 kingshard性能测试环境搭建 利用上述配置的4台服务器搭建了一个kingshard性能测试环境：\n 服务器A运行着sysbench 服务器B运行着kingshard系统 服务器C运行着主库 服务器D运行着从库  四台服务器处在同一个网段中。具体的拓扑图如下所示：\n有关kingshard系统安装与配置，请参考文档安装kingshard 有关sysbench v0.5的安装与命令选项，请参考sysbench\n4.测试过程 执行下面的命令准备测试数据\n1 2 3 4 5 6 7 8 9 10 11 12  time sysbench --test=/data/home/test_user/software/sysbench/sysbench/tests/db/oltp.lua \\  --mysql-host=host \\  --mysql-port=9696 \\  --mysql-user=kingshard \\  --mysql-password=kingshard \\  --mysql-db=kingshard \\  --oltp-tables-count=1 \\  --oltp-table-size=1000000 \\  --num-threads=50 \\  --max-requests=1000000 \\  --report-interval=1 \\  prepare   上述命令会创建表sbtest1，数据量为100w，建表语句如下:\n1 2 3 4 5 6 7 8  CREATETABLE`sbtest1`(`id`int(10)unsignedNOTNULLAUTO_INCREMENT,`k`int(10)unsignedNOTNULLDEFAULT'0',`c`char(120)NOTNULLDEFAULT'',`pad`char(60)NOTNULLDEFAULT'',KEY`xid`(`id`),KEY`k_1`(`k`))ENGINE=InnoDBAUTO_INCREMENT=1000001DEFAULTCHARSET=utf8MAX_ROWS=1000000;  4.1 kingshard与直连DB性能比较 利用sysbench测试通过kingshard转发SQL请求和直连DB发送SQL请求这两种情况下，kingshard和Mysql系统的两项数据指标：QPS和每条SQL请求平均处理时间。\n通过sysbench发送四类SQL请求：select、update、insert和delete，场景分别为只读、读写4比1和只写。\n4.1.1 kingshard与直连DB只读比较 通过修改host、port执行下面的命令分别测试kingshard转发SQL或直连DB：\n1 2 3 4 5 6 7 8 9 10 11 12 13  time sysbench --test=/data/home/test_user/software/sysbench/sysbench/tests/db/select.lua \\  --mysql-host=host \\  --mysql-port=9696 \\  --mysql-user=kingshard \\  --mysql-password=kingshard \\  --mysql-db=kingshard \\  --oltp-tables-count=1 \\  --oltp-table-size=1000000 \\  --num-threads=16 \\  --max-requests=1000000 \\  --report-interval=1 \\  --max-time=20 \\  run   利用sysbench测试了并发线程个数不同的情况下，分别执行最大请求次数为100w的 select操作,通过修改–num-threads可以获得不同并发线程数。\n测试连接 kingshard 和直连 DB 这两种情况下的 QPS（QPS越大，系统性能越好）， 测试连接 kingshard 和直连 DB 这两种情况下的 执行sql平均时延（时延越小，系统性能越好）， 每组数据重复测试三次后取平均值，具体数据对比如下表所示：\n上表对应的QPS折线图如下所示：\n上表对应的时延折线图如下所示：\n4.1.2 kingshard与直连DB读写4:1比较 通过修改host、port执行下面的命令分别测试kingshard转发SQL或直连DB：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ysbench --test=/data/home/test_user/software/sysbench/sysbench/tests/db/oltp.lua \\  --mysql-host=host \\  --mysql-port=3306 \\  --mysql-user=kingshard \\  --mysql-password=ks \\  --mysql-db=kingshard \\  --oltp-tables-count=1 \\  --oltp-table-size=1000000 \\  --num-threads=16 \\  --max-requests=1000000 \\  --report-interval=1 \\  --max-time=20 \\  run   利用sysbench测试了并发线程个数不同的情况下，分别执行最大请求次数为100w的 select、update、insert、delete等混合操作,通过修改–num-threads可以获得不同并发线程数。\n测试连接 kingshard 和直连 DB 这两种情况下的 QPS（QPS越大，系统性能越好）， 测试连接 kingshard 和直连 DB 这两种情况下的 执行sql平均时延（时延越小，系统性能越好）， 每组数据重复测试三次后取平均值，具体数据对比如下表所示：\n上表对应的QPS折线图如下所示：\n上表对应的时延折线图如下所示：\n4.1.3 kingshard与直连DB只写比较 通过修改host、port执行下面的命令分别测试kingshard转发SQL或直连DB：\n1 2 3 4 5 6 7 8 9 10 11 12 13  time sysbench --test=/data/home/test_user/software/sysbench/sysbench/tests/db/insert.lua \\  --mysql-host=host \\  --mysql-port=3306 \\  --mysql-user=kingshard \\  --mysql-password=ks \\  --mysql-db=kingshard \\  --oltp-tables-count=1 \\  --oltp-table-size=1000000 \\  --num-threads=16 \\  --max-requests=1000000 \\  --report-interval=1 \\  --max-time=20 \\  run   利用sysbench测试了并发线程个数不同的情况下，分别执行最大请求次数为100w的insert操作,通过修改–num-threads可以获得不同并发线程数。\n测试连接 kingshard 和直连 DB 这两种情况下的 QPS（QPS越大，系统性能越好）， 测试连接 kingshard 和直连 DB 这两种情况下的 执行sql平均时延（时延越小，系统性能越好）， 每组数据重复测试三次后取平均值，具体数据对比如下表所示：\n上表对应的QPS折线图如下所示：\n上表对应的时延折线图如下所示：\n从QPS折线图可以看出，当sysbench的并发测试线程较少时，连接kingshard和直连DB的QPS差距较大。 这主要是因为当sysbench并发线程少时，kingshard的性能没有得到充分的发挥， sysbench只有很少的线程向kingshard发送请求，此时网络延迟对QPS的影响是最主要的。\n当sysbench的并发测试线程较大时，此时kingshard的性能就得到了充分的发挥， QPS的对比是连接kingshard与直连DB性能对比的真实的反应，网络延迟对QPS的影响作用就显得很小了。\n从以上几个表个的比例数据来看，通过kingshard转发select请求时的QPS是直连DB时80%左右， 而update和insert请求对应的QPS则更高一些，相当于直连DB时的85%左右,甚至在并发更高的情况下直连mysql的性能低于通过kingshards转发的性能。 由此看来利用kingshard转发SQL请求带来的性能下降虽有下降，但完全可以接受，甚至高并发场景下kingshard的性能优于直连DB的性能。这也是得益于kingshard在高并发的时候，充分利用了连接池的作用，降低了高并发带来的竞争消耗。\nsysbench并发线程高于512的数据并没有给出，因为直连DB已经不能正常完成测试，但是kingshard可以完成。\n4.2 max_conns_limit参数对kingshard性能影响 max_conns_limit 是 kingshard 初始化时创建的与后端mysql长连接个数，这个值设置的不同对 kingshard 性能也有比较明显的影响。\n我们猜测max_conns_limit除了与kingshard所在主机CPU核心数有关外还与后端mysql能接纳的连接数有关。 我们分别测试将 max_conns_limit 设置为16、32、64、128、256、512时，kingshard转发select，update和insert三类操作请求时的 QPS， SQL的混合情况为读写4比1，且sysbench的不同sql分别处于不同的事务中，具体对比结果如下所述：\n上数测试对应的QPS折线图如下所示：\n从kingshard处理三类SQL操作的QPS对比来看，将max_conns_limit参数设置为128左右较为合理, 高于128后通过提高max_conns_limit值并没有显著效果。\nmax_conns_limit参数值与kingshard所在主机核心数并没有必然的联系，与后端mysql主机可承受连接数关系密切。\n5.测试结论 本文主要测试了通过kingshard转发SQL请求与直连DB发送SQL请求这两种情形下的性能差距，和max_conns_limit值对kingshard的性能影响。\nks的读写性能平均可以达到原生mysql性能的80%，一定条件下可以达到90%，随着并发数的增加甚至能超越mysql本身。\nks可以对mysql形成保护，增加了ks后，db层对外表现出可以接收更高的并发数，且执行时间长短不同的sql使用各自的资源，形成了资源隔离，mysql不会出现性能毛刺。\n综合以上测试结果来看，kingshard性能表现较为优秀，并没有明显的性能下降。同时在测试中发现kingshard系统属于CPU密集型任务，相对于磁盘IO和内存占用率而言，kingshard对CPU消耗显得最为明显，所以建议在部署kingshard的时候需要优先考虑服务器的CPU性能。\n转载:https://github.com/flike/kingshard/blob/master/README_ZH.md\n",
  "wordCount" : "9449",
  "inLanguage": "zh-cn",
  "datePublished": "2020-03-24T17:13:47Z",
  "dateModified": "2020-03-24T17:13:47Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/kingshard%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Kingshard架构设计和功能实现
    </h1>
    <div class="post-meta">March 24, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="kingshard简介">kingshard简介<a hidden class="anchor" aria-hidden="true" href="#kingshard简介">#</a></h1>
<p>kingshard是一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力于简化MySQL分库分表操作；能够让DBA通过kingshard轻松平滑地实现MySQL数据库扩容。 <strong>kingshard的性能是直连MySQL性能的80%以上</strong>。</p>
<h2 id="主要功能">主要功能：<a hidden class="anchor" aria-hidden="true" href="#主要功能">#</a></h2>
<h3 id="1-基础功能">1. 基础功能<a hidden class="anchor" aria-hidden="true" href="#1-基础功能">#</a></h3>
<ul>
<li>支持SQL读写分离。</li>
<li>支持透明的MySQL连接池，不必每次新建连接。</li>
<li>支持平滑上线DB或下线DB，前端应用无感知。</li>
<li>支持多个slave，slave之间通过权值进行负载均衡。</li>
<li>支持强制读主库。</li>
<li>支持主流语言（java,php,python,C/C++,Go)SDK的mysql的prepare特性。</li>
<li>支持到后端DB的最大连接数限制。</li>
<li>支持SQL日志及慢日志输出。</li>
<li>支持SQL黑名单机制。</li>
<li>支持客户端IP访问白名单机制，只有白名单中的IP才能访问kingshard（支持IP 段）。</li>
<li>支持字符集设置。</li>
<li>支持last_insert_id功能。</li>
<li>支持热加载配置文件，动态修改kingshard配置项（具体参考管理端命令）。</li>
<li>支持以Web API调用的方式管理kingshard。</li>
<li>支持多用户模式，不同用户之间的表是权限隔离的，互不感知。</li>
</ul>
<h3 id="2-sharding功能">2. sharding功能<a hidden class="anchor" aria-hidden="true" href="#2-sharding功能">#</a></h3>
<ul>
<li>支持按整数的hash和range分表方式。</li>
<li>支持按年、月、日维度的时间分表方式。</li>
<li>支持跨节点分表，子表可以分布在不同的节点。</li>
<li>支持跨节点的count,sum,max和min等聚合函数。</li>
<li>支持单个分表的join操作，即支持分表和另一张不分表的join操作。</li>
<li>支持跨节点的order by,group by,limit等操作。</li>
<li>支持将sql发送到特定的节点执行。</li>
<li>支持在单个节点上执行事务，不支持跨多节点的分布式事务。</li>
<li>支持非事务方式更新（insert,delete,update,replace）多个node上的子表。</li>
</ul>
<h1 id="kingshard架构设计和功能实现">kingshard架构设计和功能实现<a hidden class="anchor" aria-hidden="true" href="#kingshard架构设计和功能实现">#</a></h1>
<h2 id="1-整体架构">1. 整体架构<a hidden class="anchor" aria-hidden="true" href="#1-整体架构">#</a></h2>
<p>kingshard采用Go开发，充分地利用了Go语言的并发特性。Go语言在并发方面，做了很好的封装，这大大简化了kingshard的开发工作。kingshard的整体工作流程如下所述：</p>
<ol>
<li>读取配置文件并启动，在配置文件中设置的监听端口监听客户端请求。</li>
<li>收到客户端连接请求后，启动一个goroutine单独处理该请求。</li>
<li>首选进行登录验证，验证过程完全兼容MySQL认证协议，由于用户名和密码在配置文件中已经设置好，所以可以利用该信息验证连接请求是否合法。当用户名和密码都正确时，转入下面的步骤，否则返回出错信息给客户端。</li>
<li>认证通过后，客户端发送SQL语句。</li>
<li>kingshard对客户端发送过来的SQL语句，进行词法和语义分析，识别出SQL的类型和生成SQL的路由计划。如果有必要还会改写SQL，然后转发到相应的DB。也有可能不做词法和语义分析直接转发到相应的后端DB。如果转发SQL是分表且跨多个DB，则每个DB对应启动一个goroutine发送SQL和接收该DB返回的结果。</li>
<li>接收并合并结果，然后转发给客户端。</li>
</ol>
<p>kingshard工作整体流程可参考下面这幅图。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324173047.png" alt=""  />
</p>
<p>kingshard整体架构图如下所示</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324173107.png" alt=""  />
</p>
<h2 id="2-词法和语义分析">2. 词法和语义分析<a hidden class="anchor" aria-hidden="true" href="#2-词法和语义分析">#</a></h2>
<p>要将kingshard的功能做的足够强大，就不得不进行SQL的词法和语义分析。SQL语句的词法分析指的是将SQL语句切分成一个一个的关键字。例如对SQL语句：<code>select name from stu where id &lt; 13</code>进行词法分析，得到的结果是：<code>{&quot;select&quot;,&quot;name&quot;,&quot;from&quot;,&quot;stu&quot;,&quot;where&quot;,&quot;id&quot;,&quot;&lt;&quot;,&quot;13&quot;}</code>。这样做的目的主要为了生成一棵抽象语法树，也就是大家常说的AST(abstract syntax tree),语义分析就是基于这棵语法树来操作的。语义分析的目的主要有以下几个方面：</p>
<ol>
<li>读写分离，只有识别出SQL语句的类型，才能进行正确的读写分离操作。</li>
<li>数据分片，解析出表名和查询条件，将SQL路由到正确的DB。</li>
<li>SQL黑名单，通过词法和语义分析，也可以快速识别出需要屏蔽的SQL语句。例如，检测到delete语句不带where操作，就可以直接阻断该SQL的转发。</li>
</ol>
<p>kingshard并没有考虑完全兼容MySQL所有语法，因为完全兼容MySQL语法会使得词法和语义分析模块变得异常复杂，而且低效。对于DDL语句其实没必要解析，只要能正确转发到后端相应的DB上就可以。</p>
<p>kingshard只对部分DML语句<code>（select,update,insert,delete,replace)</code>进行了解析，这样可以满足绝大部分的分表操作。对于其他语句，kingshard会将其发送到一个默认的DB，或者通过kingshard特有的方式将其发送到指定的DB上，例如：<code>/*node2*/insert into stu（id,name) values(12,'xiaoming')</code>,对于这种带有注释的的sql语句，kingshard能够识别出，然后将这条sql语句发送到node2节点的Master DB上。</p>
<h2 id="3-负载均衡">3. 负载均衡<a hidden class="anchor" aria-hidden="true" href="#3-负载均衡">#</a></h2>
<p>用户使用Mysql Proxy目的很大一部分就是为了降低单台DB的负载，将读压力分担到多台DB上。kingshard支持多个slave，不同的slave可以配置不同的读权重，权重越大分担的读请求越多。kingshard读请求负载均衡采用的是权重轮询调度算法。</p>
<p>大部分系统采用该算法时，都是转发SQL语句时，动态地计算出本次选取DB的序号。然后将读请求的SQL语句发送到该DB。仔细分析一下，这样做其实是没有必要的。因为DB的权重是相对固定的，不会经常变动，所以完全可以计算出一个固定的轮询序列，然后将这个序列保存在一个数组中。这样不需要动态计算，每次读取数组就可以。举个例子来说，在kingshard的node配置项中配置slave选项：</p>
<p><code>slave:192.168.0.12@2,192.168.0.13@3</code></p>
<p>kingshard在读取配置信息初始化系统的时候，就生成了一个轮询数组:[0,0,1,1,1]。在kingshard中会将这个数组打乱顺序，变成：[0,1,1,0,1]。这样就避免了动态计算DB下标的问题，对性能提升有一定帮助。</p>
<h2 id="4sharding实现">4.sharding实现<a hidden class="anchor" aria-hidden="true" href="#4sharding实现">#</a></h2>
<p>首选需要介绍两个概念：</p>
<ol>
<li>
<p><strong>子表</strong>，在kingshard中一张逻辑上的大表由若干张小的子表组成。例如：将stu表分成stu_0000,stu_0001,stu_0002,stu_0003。
在数据库中stu表是不存在的，它只是一张逻辑上的表。数据库中只存在四张子表（stu_0000,stu_0001,stu_0002,stu_0003）。
发送SQL语句时，kingshard会识别出需要分表的SQL语句，并改写该SQL。例如，客户端发送过来的SQL语句是<code>：select name from stu where id =10;</code>
kingshard收到该SQL语句后，从配置信息中识别出该表是一个Hash类型的分表。根据分表规则，将该SQL改写成：<code>select name from stu_2 where id =10;</code>
然后发送给对应的DB。</p>
</li>
<li>
<p><strong>Node</strong>，子表分布在各个node上，每个node包含一个maser server和若干个slave server（slave个数可以为0）。写请求会发往该node中master server，读请求会发往该node中的slave server。</p>
</li>
</ol>
<p>kingshard的sharding采用了两级映射的思想，首选根据SQL语句的分表条件计算出这条SQL语句落在哪个子表上，然后再根据配置信息找到该子表落在哪个node上。采用两级映射的思想，对于MySQL的扩容和缩容都能很方便地支持。目前kingshard sharding支持insert, delete, select, update和replace语句, 所有这五类操作都支持跨子表。但写操作仅支持单node上的跨子表，select操作则可以跨node，跨子表。</p>
<p>对于有些表没有分表，操作该表的SQL语句会发往default node。或者用户可以选择在SQL语句前面加上注释，指定该SQL要发往的node，kingshard接收到语句后，识别出注释中指定的node，然后将该SQL发往对应node中合适的DB。例如用户发送<code>/*node1*/select * from member where id=100</code>,kingshard接收到该SQL后会将其发送到node1的salve上。这样kingshard就能很好地兼容分表和不分表的各种应用场景了。</p>
<h2 id="5-事务的实现">5. 事务的实现<a hidden class="anchor" aria-hidden="true" href="#5-事务的实现">#</a></h2>
<p>所有proxy支持shard后都会面临一个问题：支不支持分布式事务？出于性能和可用性考虑，
kingshard只支持单台DB上的事务，不允许跨DB的事务。kingshard处理单DB上的事务流程如下：</p>
<ol>
<li>用户发送begin语句。</li>
<li>kingshard接收到SQL语句后，将该连接的状态设置为事务。</li>
<li>用户发送DML语句，kingshard识别出语句需要发送到的DB，然后kingshard新建一个与后端DB的连接，利用该连接发送语句。</li>
<li>收取SQL语句的结果后，将连接放回。</li>
<li>kingshard收到下一条SQL语句，判断该SQL是不是发往同一个DB，如果不是则报错。如果是发往同一个DB，则利用该连接发送语句。</li>
<li>收到用户发送的commit语句，将该连接的状态设置为非事务，事务结束。</li>
</ol>
<h2 id="6-后端db存活检测">6. 后端DB存活检测<a hidden class="anchor" aria-hidden="true" href="#6-后端db存活检测">#</a></h2>
<p>kingshard每个node启动了一个goroutine用于检测后端master和slave的状态。当goroutine持续一段时间（由配置文件中down_after_noalive参数设置）ping不通后端的DB后，会将该DB的状态设置为down，后续kingshard就不会将sql语句发往该DB了。</p>
<h2 id="7-客户端白名单机制">7. 客户端白名单机制<a hidden class="anchor" aria-hidden="true" href="#7-客户端白名单机制">#</a></h2>
<p>有时候用户为了安全考虑，希望只只允许某几台server连接kingshard。在kingshard的配置文件中有一个参数：allow_ips，用于实现客户端白名单机制。当管理员设置了该参数，则意味着只有allow_ips指定的IP能够连接kingshard，其他IP都会被kingshard拒绝连接。如果不设置该参数，则连接kingshard的客户端不受限制。</p>
<h2 id="8-管理端设计和实现">8. 管理端设计和实现<a hidden class="anchor" aria-hidden="true" href="#8-管理端设计和实现">#</a></h2>
<p>kingshard的管理端口复用了工作端口，通过特定的关键字(admin)来标示。kingshard是通过对管理端特定的SQL进行词法和语义分析，将SQL语句解析为一条kingshard可以识别的命令。目前支持平滑上下线master和slave，和查看kingshard配置和后端DB状态。后续打算将web页面集成到管理端，这样用户就可以不用输入命令行操作，而是在网页上操作。大大降低用户使用kingshard的门槛。</p>
<h1 id="kingshard性能优化网络篇">kingshard性能优化网络篇<a hidden class="anchor" aria-hidden="true" href="#kingshard性能优化网络篇">#</a></h1>
<h2 id="1-发现kingshard的性能瓶颈">1. 发现kingshard的性能瓶颈<a hidden class="anchor" aria-hidden="true" href="#1-发现kingshard的性能瓶颈">#</a></h2>
<p>首选，对kingshard进行性能优化，我们必须要找到kingshard的性能瓶颈在哪里。Go语言在性能优化支持方面做的非常好，借助于go语言的pprof工具，我们可以通过简单的几个步骤，就能得到kingshard在转发SQL请求时的各个函数耗时情况。</p>
<h3 id="11-环境搭建">1.1 环境搭建<a hidden class="anchor" aria-hidden="true" href="#11-环境搭建">#</a></h3>
<p>根据kingshard使用指南搭建一个kingshard代理环境。我是用macbook搭建的环境，硬件参数如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">CPU： 2.2GHZ * 4
内存：16GB
硬盘: 256GB

</code></pre></td></tr></table>
</div>
</div><h3 id="12-性能测试步骤">1.2 性能测试步骤<a hidden class="anchor" aria-hidden="true" href="#12-性能测试步骤">#</a></h3>
<p>具体步骤如下所述：</p>
<p>1.获取一个性能分析的封装库</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go get github.com/pkg/profile
</code></pre></td></tr></table>
</div>
</div><p>2.在工程内import这个组件</p>
<p>3.在kingshard/cmd/kingshard/main.go的main函数开始部分添加CPU监控的启动和停止入口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func main() {
	defer profile.Start(profile.CPUProfile).Stop()
	fmt.Print(banner)
	runtime.GOMAXPROCS(runtime.NumCPU())
	flag.Parse()
	....
}
</code></pre></td></tr></table>
</div>
</div><p>4.重新编译工程, 运行kingshard</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">./bin/kingshard -config=etc/ks.yaml
</code></pre></td></tr></table>
</div>
</div><p>5.kingshard启动后会在终端输出下面一段提示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">2015/10/31 10:28:06 profile: cpu profiling enabled, /var/folders/4q/zzb55sfj377b6vdyz2brt6sc0000gn/T/profile205276958/cpu.pprof
</code></pre></td></tr></table>
</div>
</div><p>后面的路径就是pprof性能分析文件的位置，Ctrl+C中断服务器</p>
<p>6.这时候用sysbench对kingshard进行压力测试，得到QPS（有关sysbench的安装和使用，请自行Google解决）。具体的代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">sysbench --test=oltp --num-threads=16 --max-requests=160000 --oltp-test-mode=nontrx --db-driver=mysql --mysql-db=kingshard --mysql-host=127.0.0.1 --mysql-port=9696 --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-user=kingshard --mysql-password=kingshard --oltp-nontrx-mode=select --db-ps-mode=disable run

</code></pre></td></tr></table>
</div>
</div><p>得到如下结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">OLTP test statistics:
    queries performed:
        read:                            160071
        write:                           0
        other:                           0
        total:                           160071
    transactions:                        160071 (16552.58 per sec.)
    deadlocks:                           0      (0.00 per sec.)
    read/write requests:                 160071 (16552.58 per sec.)
    other operations:                    0      (0.00 per sec.)

Test execution summary:
    total time:                          9.6705s
    total number of events:              160071
    total time taken by event execution: 154.4474
    per-request statistics:
         min:                                  0.29ms
         avg:                                  0.96ms
         max:                                 14.17ms
         approx.  95 percentile:               1.37ms

Threads fairness:
    events (avg/stddev):           10004.4375/24.95
    execution time (avg/stddev):   9.6530/0.00

</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>按照上述步骤测试三次（16552.58,16769.72,16550.16）取平均值，得到优化前kingshard的QPS是：16624.15</p>
</li>
<li>
<p>按照上述步骤，直连MySQL。测试直连MySQL的QPS，同样测试三次QPS（27730.90，28499.05，27119.20），得到直连MySQL的QPS是：27783.05。</p>
</li>
<li>
<p>从上述数据可以计算出kingshard转发SQL的性能是直连MySQL的59%左右。</p>
</li>
</ul>
<p>7.将cpu.prof拷贝到bin/kingshard所在位置</p>
<p>8.调用go tool工具制作CPU耗时的PDF文档</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go tool pprof -pdf ./kingshard cpu.pprof &gt; report.pdf
</code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324232658.png" alt=""  />
</p>
<h2 id="2-性能测试报告分析">2. 性能测试报告分析<a hidden class="anchor" aria-hidden="true" href="#2-性能测试报告分析">#</a></h2>
<p>通过上述命令，可以生成压测期间主要函数耗时情况。从report来看，主要的耗时在TCP层数据包的收发上面。那我们应该主要考虑如何优化TCP层数据的收发方面。优化TCP传输效率，我首先想到了减少系统调用，每个数据包传输尽量多的数据。</p>
<p>在通过 TCP socket 进行通信时，数据都拆分成了数据块，这样它们就可以封装到给定连接的 TCP payload（指 TCP 数据包中的有效负荷）中了。TCP payload 的大小取决于几个因素（例如最大报文长度和路径），但是这些因素在连接发起时都是已知的。为了达到最好的性能，我们的目标是使用尽可能多的可用数据来填充每个报文。当没有足够的数据来填充 payload 时（也称为最大报文段长度（maximum segment size） 或 MSS），TCP 就会采用 Nagle 算法自动将一些小的缓冲区连接到一个报文段中。这样可以通过最小化所发送的报文的数量来提高应用程序的效率，并减轻整体的网络拥塞问题。</p>
<p>由于这种算法对数据进行合并，试图构成一个完整的 TCP 报文段，因此它会引入一些延时。但是这种算法可以最小化在线路上发送的报文的数量，因此可以最小化网络拥塞的问题。但是在需要最小化传输延时的情况中，GO语言中Sockets API 可以提供一种解决方案。就是通过：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">TCPConn</span><span class="p">)</span> <span class="nf">SetNoDelay</span><span class="p">(</span><span class="nx">noDelay</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数在Go中默认情况下，是设置为true，也就是未开启延迟选项。我们需要将其设置为false选项，来达到每个数据包传输尽量多的数据，减少系统调用的目的。</p>
<h2 id="21-代码修改和性能测试">2.1 代码修改和性能测试<a hidden class="anchor" aria-hidden="true" href="#21-代码修改和性能测试">#</a></h2>
<p>发现了性能瓶颈以后，修改proxy/server/server.go文件中的newClientConn函数和backend/backend_conn.go中的ReConnect函数，分别设置client与kingshard之间的连接和kingshard到MySQL之间的连接为最小化传输延时。具体的代码修改可以查看这个</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324233404.png" alt=""  />
</p>
<p>修改后我们利用sysbench重新测试，测试命令和上述测试一致。得到的结果如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">OLTP test statistics:
    queries performed:
        read:                            160174
        write:                           0
        other:                           0
        total:                           160174
    transactions:                        160174 (21291.68 per sec.)
    deadlocks:                           0      (0.00 per sec.)
    read/write requests:                 160174 (21291.68 per sec.)
    other operations:                    0      (0.00 per sec.)

Test execution summary:
    total time:                          7.5228s
    total number of events:              160174
    total time taken by event execution: 119.9655
    per-request statistics:
         min:                                  0.26ms
         avg:                                  0.75ms
         max:                                 10.78ms
         approx.  95 percentile:               1.13ms

Threads fairness:
    events (avg/stddev):           10010.8750/38.65
    execution time (avg/stddev):   7.4978/0.00
</code></pre></td></tr></table>
</div>
</div><p>测试三次得到的QPS为：21291.68,21670.85,21463.44。 <strong>相当于直连MySQL性能的77%左右，通过这个优化性能提升了18%左右</strong>。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>通过这篇文章，介绍了通过Go语言提供的pprof对kingshard进行性能分析的详细步骤。对于其他Go语言项目也可以通过类似步骤生成性能报告文档。性能优化的关键是发现性能瓶颈，再去找优化方案。有时候简单的优化，就可以达到预想不到的效果，希望本文能给Go开发者在性能优化方面提供一个思路。</p>
<h1 id="kingshard的性能测试报告">kingshard的性能测试报告<a hidden class="anchor" aria-hidden="true" href="#kingshard的性能测试报告">#</a></h1>
<h2 id="1测试环境">1.测试环境<a hidden class="anchor" aria-hidden="true" href="#1测试环境">#</a></h2>
<h3 id="11服务器配置">1.1服务器配置<a hidden class="anchor" aria-hidden="true" href="#11服务器配置">#</a></h3>
<table>
<thead>
<tr>
<th>类别</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>OS</td>
<td>云主机 Ubuntu 14.04 LTS</td>
</tr>
<tr>
<td>CPU</td>
<td>Common KVM CPU @ 2.40GHz *4</td>
</tr>
<tr>
<td>RAM</td>
<td>8GB</td>
</tr>
<tr>
<td>DISK</td>
<td>500GB</td>
</tr>
<tr>
<td>kingshard</td>
<td>master分支</td>
</tr>
<tr>
<td>Mysql</td>
<td>v5.6.25</td>
</tr>
<tr>
<td>Sysbench</td>
<td>v0.5</td>
</tr>
</tbody>
</table>
<h2 id="2性能需求">2.性能需求<a hidden class="anchor" aria-hidden="true" href="#2性能需求">#</a></h2>
<ol>
<li>测试通过kingshard转发SQL请求与直连DB发送SQL请求这两种情形下的性能差距。</li>
<li>测试配置文件中max_conns_limit参数对kingshard的影响，并找出最优值。</li>
</ol>
<h2 id="3测试准备工作">3.测试准备工作<a hidden class="anchor" aria-hidden="true" href="#3测试准备工作">#</a></h2>
<h3 id="31-kingshard性能测试环境搭建">3.1 kingshard性能测试环境搭建<a hidden class="anchor" aria-hidden="true" href="#31-kingshard性能测试环境搭建">#</a></h3>
<p>利用上述配置的4台服务器搭建了一个kingshard性能测试环境：</p>
<ul>
<li>服务器A运行着sysbench</li>
<li>服务器B运行着kingshard系统</li>
<li>服务器C运行着主库</li>
<li>服务器D运行着从库</li>
</ul>
<p>四台服务器处在同一个网段中。具体的拓扑图如下所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324233803.png" alt=""  />
</p>
<p>有关kingshard系统安装与配置，请参考文档安装kingshard
有关sysbench v0.5的安装与命令选项，请参考sysbench</p>
<h2 id="4测试过程">4.测试过程<a hidden class="anchor" aria-hidden="true" href="#4测试过程">#</a></h2>
<p>执行下面的命令准备测试数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">time</span> sysbench --test<span class="o">=</span>/data/home/test_user/software/sysbench/sysbench/tests/db/oltp.lua <span class="se">\
</span><span class="se"></span>              --mysql-host<span class="o">=</span>host <span class="se">\
</span><span class="se"></span>              --mysql-port<span class="o">=</span><span class="m">9696</span> <span class="se">\
</span><span class="se"></span>              --mysql-user<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --mysql-password<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --mysql-db<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --oltp-tables-count<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --oltp-table-size<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --num-threads<span class="o">=</span><span class="m">50</span> <span class="se">\
</span><span class="se"></span>              --max-requests<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --report-interval<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              prepare
</code></pre></td></tr></table>
</div>
</div><p>上述命令会创建表sbtest1，数据量为100w，建表语句如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">sbtest1</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="n">k</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="nb">char</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="k">pad</span><span class="o">`</span><span class="w"> </span><span class="nb">char</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">xid</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">k_1</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">k</span><span class="o">`</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1000001</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="w"> </span><span class="n">MAX_ROWS</span><span class="o">=</span><span class="mi">1000000</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="41-kingshard与直连db性能比较">4.1 kingshard与直连DB性能比较<a hidden class="anchor" aria-hidden="true" href="#41-kingshard与直连db性能比较">#</a></h3>
<p>利用sysbench测试通过kingshard转发SQL请求和直连DB发送SQL请求这两种情况下，kingshard和Mysql系统的两项数据指标：<strong>QPS</strong>和每条<strong>SQL请求平均处理时间</strong>。</p>
<p>通过sysbench发送四类SQL请求：select、update、insert和delete，场景分别为只读、读写4比1和只写。</p>
<h4 id="411-kingshard与直连db只读比较">4.1.1 kingshard与直连DB只读比较<a hidden class="anchor" aria-hidden="true" href="#411-kingshard与直连db只读比较">#</a></h4>
<p>通过修改host、port执行下面的命令分别测试kingshard转发SQL或直连DB：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">time</span> sysbench --test<span class="o">=</span>/data/home/test_user/software/sysbench/sysbench/tests/db/select.lua <span class="se">\
</span><span class="se"></span>              --mysql-host<span class="o">=</span>host <span class="se">\
</span><span class="se"></span>              --mysql-port<span class="o">=</span><span class="m">9696</span> <span class="se">\
</span><span class="se"></span>              --mysql-user<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --mysql-password<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --mysql-db<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --oltp-tables-count<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --oltp-table-size<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --num-threads<span class="o">=</span><span class="m">16</span> <span class="se">\
</span><span class="se"></span>              --max-requests<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --report-interval<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --max-time<span class="o">=</span><span class="m">20</span> <span class="se">\
</span><span class="se"></span>              run
</code></pre></td></tr></table>
</div>
</div><p>利用sysbench测试了并发线程个数不同的情况下，分别执行最大请求次数为100w的 select操作,通过修改&ndash;num-threads可以获得不同并发线程数。</p>
<p>测试连接 kingshard 和直连 DB 这两种情况下的 QPS（<strong>QPS越大，系统性能越好</strong>），
测试连接 kingshard 和直连 DB 这两种情况下的 执行sql平均时延（<strong>时延越小，系统性能越好</strong>），
每组数据重复测试三次后取平均值，具体数据对比如下表所示：</p>
<p><img loading="lazy" src="./kingshard_performance_test_resources/%e5%8f%aa%e8%af%bb-table.png" alt="数据对比"  />
</p>
<p>上表对应的QPS折线图如下所示：</p>
<p><img loading="lazy" src="./kingshard_performance_test_resources/qps-%e5%8f%aa%e8%af%bb.png" alt="QPS折线图"  />
</p>
<p>上表对应的时延折线图如下所示：</p>
<p><img loading="lazy" src="./kingshard_performance_test_resources/%e6%97%b6%e5%bb%b6-%e5%8f%aa%e8%af%bb.png" alt="时延折线图"  />
</p>
<h4 id="412-kingshard与直连db读写41比较">4.1.2 kingshard与直连DB读写4:1比较<a hidden class="anchor" aria-hidden="true" href="#412-kingshard与直连db读写41比较">#</a></h4>
<p>通过修改host、port执行下面的命令分别测试kingshard转发SQL或直连DB：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">ysbench --test<span class="o">=</span>/data/home/test_user/software/sysbench/sysbench/tests/db/oltp.lua <span class="se">\
</span><span class="se"></span>              --mysql-host<span class="o">=</span>host <span class="se">\
</span><span class="se"></span>              --mysql-port<span class="o">=</span><span class="m">3306</span> <span class="se">\
</span><span class="se"></span>              --mysql-user<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --mysql-password<span class="o">=</span>ks <span class="se">\
</span><span class="se"></span>              --mysql-db<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --oltp-tables-count<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --oltp-table-size<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --num-threads<span class="o">=</span><span class="m">16</span> <span class="se">\
</span><span class="se"></span>              --max-requests<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --report-interval<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --max-time<span class="o">=</span><span class="m">20</span> <span class="se">\
</span><span class="se"></span>              run
</code></pre></td></tr></table>
</div>
</div><p>利用sysbench测试了并发线程个数不同的情况下，分别执行最大请求次数为100w的 select、update、insert、delete等混合操作,通过修改&ndash;num-threads可以获得不同并发线程数。<br>
测试连接 kingshard 和直连 DB 这两种情况下的 QPS（<strong>QPS越大，系统性能越好</strong>），
测试连接 kingshard 和直连 DB 这两种情况下的 执行sql平均时延（<strong>时延越小，系统性能越好</strong>），
每组数据重复测试三次后取平均值，具体数据对比如下表所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324234215.png" alt=""  />
</p>
<p>上表对应的QPS折线图如下所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324234238.png" alt=""  />
</p>
<p>上表对应的时延折线图如下所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324234249.png" alt=""  />
</p>
<h4 id="413-kingshard与直连db只写比较">4.1.3 kingshard与直连DB只写比较<a hidden class="anchor" aria-hidden="true" href="#413-kingshard与直连db只写比较">#</a></h4>
<p>通过修改host、port执行下面的命令分别测试kingshard转发SQL或直连DB：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">time</span> sysbench --test<span class="o">=</span>/data/home/test_user/software/sysbench/sysbench/tests/db/insert.lua <span class="se">\
</span><span class="se"></span>              --mysql-host<span class="o">=</span>host <span class="se">\
</span><span class="se"></span>              --mysql-port<span class="o">=</span><span class="m">3306</span> <span class="se">\
</span><span class="se"></span>              --mysql-user<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --mysql-password<span class="o">=</span>ks <span class="se">\
</span><span class="se"></span>              --mysql-db<span class="o">=</span>kingshard <span class="se">\
</span><span class="se"></span>              --oltp-tables-count<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --oltp-table-size<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --num-threads<span class="o">=</span><span class="m">16</span> <span class="se">\
</span><span class="se"></span>              --max-requests<span class="o">=</span><span class="m">1000000</span> <span class="se">\
</span><span class="se"></span>              --report-interval<span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>              --max-time<span class="o">=</span><span class="m">20</span> <span class="se">\
</span><span class="se"></span>              run
</code></pre></td></tr></table>
</div>
</div><p>利用sysbench测试了并发线程个数不同的情况下，分别执行最大请求次数为100w的insert操作,通过修改&ndash;num-threads可以获得不同并发线程数。<br>
测试连接 kingshard 和直连 DB 这两种情况下的 QPS（<strong>QPS越大，系统性能越好</strong>），
测试连接 kingshard 和直连 DB 这两种情况下的 执行sql平均时延（<strong>时延越小，系统性能越好</strong>），
每组数据重复测试三次后取平均值，具体数据对比如下表所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324234320.png" alt=""  />
</p>
<p>上表对应的QPS折线图如下所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324234329.png" alt=""  />
</p>
<p>上表对应的时延折线图如下所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200324234335.png" alt=""  />
</p>
<p><strong>从QPS折线图可以看出，当sysbench的并发测试线程较少时，连接kingshard和直连DB的QPS差距较大。
这主要是因为当sysbench并发线程少时，kingshard的性能没有得到充分的发挥，
sysbench只有很少的线程向kingshard发送请求，此时网络延迟对QPS的影响是最主要的。</strong></p>
<p><strong>当sysbench的并发测试线程较大时，此时kingshard的性能就得到了充分的发挥，
QPS的对比是连接kingshard与直连DB性能对比的真实的反应，网络延迟对QPS的影响作用就显得很小了。</strong></p>
<p><strong>从以上几个表个的比例数据来看，通过kingshard转发select请求时的QPS是直连DB时80%左右，
而update和insert请求对应的QPS则更高一些，相当于直连DB时的85%左右,甚至在并发更高的情况下直连mysql的性能低于通过kingshards转发的性能。
由此看来利用kingshard转发SQL请求带来的性能下降虽有下降，但完全可以接受，甚至高并发场景下kingshard的性能优于直连DB的性能。这也是得益于kingshard在高并发的时候，充分利用了连接池的作用，降低了高并发带来的竞争消耗。</strong></p>
<p><strong>sysbench并发线程高于512的数据并没有给出，因为直连DB已经不能正常完成测试，但是kingshard可以完成。</strong></p>
<h3 id="42-max_conns_limit参数对kingshard性能影响">4.2 max_conns_limit参数对kingshard性能影响<a hidden class="anchor" aria-hidden="true" href="#42-max_conns_limit参数对kingshard性能影响">#</a></h3>
<p>max_conns_limit 是 kingshard 初始化时创建的与后端mysql长连接个数，这个值设置的不同对 kingshard 性能也有比较明显的影响。</p>
<p>我们猜测max_conns_limit除了与<strong>kingshard所在主机CPU核心数</strong>有关外还与<strong>后端mysql能接纳的连接数</strong>有关。
我们分别测试将 max_conns_limit 设置为16、32、64、128、256、512时，kingshard转发select，update和insert三类操作请求时的 QPS，
SQL的混合情况为读写4比1，且sysbench的不同sql分别处于不同的事务中，具体对比结果如下所述：</p>
<p>上数测试对应的QPS折线图如下所示：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200325000122.png" alt=""  />
</p>
<p><strong>从kingshard处理三类SQL操作的QPS对比来看，将max_conns_limit参数设置为128左右较为合理, 高于128后通过提高max_conns_limit值并没有显著效果。</strong></p>
<p><strong>max_conns_limit参数值与kingshard所在主机核心数并没有必然的联系，与后端mysql主机可承受连接数关系密切。</strong></p>
<h2 id="5测试结论">5.测试结论<a hidden class="anchor" aria-hidden="true" href="#5测试结论">#</a></h2>
<p>本文主要测试了通过kingshard转发SQL请求与直连DB发送SQL请求这两种情形下的性能差距，和max_conns_limit值对kingshard的性能影响。<br>
ks的读写性能平均可以达到原生mysql性能的80%，一定条件下可以达到90%，随着并发数的增加甚至能超越mysql本身。<br>
ks可以对mysql形成保护，增加了ks后，db层对外表现出可以接收更高的并发数，且执行时间长短不同的sql使用各自的资源，形成了资源隔离，mysql不会出现性能毛刺。<br>
综合以上测试结果来看，kingshard性能表现较为优秀，并没有明显的性能下降。<strong>同时在测试中发现kingshard系统属于CPU密集型任务，相对于磁盘IO和内存占用率而言，kingshard对CPU消耗显得最为明显，所以建议在部署kingshard的时候需要优先考虑服务器的CPU性能。</strong></p>
<p>转载:<a href="https://github.com/flike/kingshard/blob/master/README_ZH.md">https://github.com/flike/kingshard/blob/master/README_ZH.md</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/kingshard/">Kingshard</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
