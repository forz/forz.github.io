<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>new和malloc的区别 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区">
<meta name="author" content="">
<link rel="canonical" href="/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="new和malloc的区别" />
<meta property="og:description" content="1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T13:15:15&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T13:15:15&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="new和malloc的区别"/>
<meta name="twitter:description" content="1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "new和malloc的区别",
      "item": "/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "new和malloc的区别",
  "name": "new和malloc的区别",
  "description": "1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区",
  "keywords": [
    
  ],
  "articleBody": "1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。\n那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。\n特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：\nnew (place_address) type  place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：\nvoid * operator new (size_t,void *) //不允许重定义这个版本的operator new  这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。\n2.返回类型安全性 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成我们需要的类型。\n类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。\n3.内存分配失败时的返回值 new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。 在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：\n1 2 3 4 5 6 7 8 9  int *a = (int *)malloc ( sizeof (int )); if(NULL == a) { ... } else { ... }   从C语言走入C++阵营的新手可能会把这个习惯带入C++：\n1 2 3 4 5 6 7 8 9  int * a = new int(); if(NULL == a) { ... } else { ... }   实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：\n1 2 3 4 5 6 7 8  try { int *a = new int(); } catch (bad_alloc) { ... }   4.是否需要指定内存大小 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。\n1 2 3  class A{...} A * ptr = new A; A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A);   当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。\n5.是否调用构造函数/析构函数 使用new操作符来分配对象内存时会经历三个步骤：\n  调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。\n  编译器运行相应的构造函数以构造对象，并为其传入初值。\n  对象构造完成后，返回一个指向该对象的指针。\n  使用delete操作符来释放对象内存时会经历两个步骤：\n  调用对象的析构函数。\n  编译器调用operator delete(或operator delete[])函数释放内存空间。\n  总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。\n6.对数组的处理 C++提供了new[]与delete[]来专门处理数组类型:\nA * ptr = new A[10];//分配10个A对象  使用new[]分配的内存必须使用delete[]进行释放：\ndelete [] ptr;  new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。\n至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：\nint * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组  7.是否可以被重载 opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：\n1 2 3 4 5 6 7 8 9 10  //这些版本可能抛出异常 void * operator new(size_t); void * operator new[](size_t); void * operator delete (void * )noexcept; void * operator delete[](void *0）noexcept; //这些版本承诺不抛出异常 void * operator new(size_t ,nothrow_t\u0026) noexcept; void * operator new[](size_t, nothrow_t\u0026 ); void * operator delete (void *,nothrow_t\u0026 )noexcept; void * operator delete[](void *0,nothrow_t\u0026 ）noexcept;   我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。\n而malloc/free并不允许重载。\n8. 能够直观地重新分配内存 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。\nnew没有这样直观的配套设施来扩充内存。\n9. 客户处理内存分配不足 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：\n1 2 3 4  namespace std { typedef void (*new_handler)(); }   指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:\n1 2 3 4  namespace std { new_handler set_new_handler(new_handler p ) throw(); }   set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。\n对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。\nmalloc和new的联系 operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：\n1 2 3 4 5 6 7 8 9 10 11  void * operator new (sieze_t size) { if(void * mem = malloc(size) return mem; else throw bad_alloc(); } void operator delete(void *mem) noexcept { free(mem); }   ",
  "wordCount" : "2762",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T13:15:15Z",
  "dateModified": "2017-06-24T13:15:15Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      new和malloc的区别
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="1-申请的内存所在位置">1. 申请的内存所在位置<a hidden class="anchor" aria-hidden="true" href="#1-申请的内存所在位置">#</a></h1>
<p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>
<p>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
<p>特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：</p>
<pre><code>new (place_address) type
</code></pre>
<p>place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：</p>
<pre><code>void * operator new (size_t,void *) //不允许重定义这个版本的operator new
</code></pre>
<p>这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。</p>
<h1 id="2返回类型安全性">2.返回类型安全性<a hidden class="anchor" aria-hidden="true" href="#2返回类型安全性">#</a></h1>
<p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成我们需要的类型。</p>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p>
<h1 id="3内存分配失败时的返回值">3.内存分配失败时的返回值<a hidden class="anchor" aria-hidden="true" href="#3内存分配失败时的返回值">#</a></h1>
<p>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="o">*</span><span class="n">a</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span> <span class="p">(</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span> <span class="p">));</span>
<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从C语言走入C++阵营的新手可能会把这个习惯带入C++：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">();</span>
<span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">try</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">catch</span> <span class="p">(</span><span class="n">bad_alloc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="4是否需要指定内存大小">4.是否需要指定内存大小<a hidden class="anchor" aria-hidden="true" href="#4是否需要指定内存大小">#</a></h1>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">A</span><span class="p">{...}</span>
<span class="n">A</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">new</span> <span class="n">A</span><span class="p">;</span>
<span class="n">A</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span> <span class="c1">//需要显式指定所需内存大小sizeof(A);
</span></code></pre></td></tr></table>
</div>
</div><p>当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。</p>
<h1 id="5是否调用构造函数析构函数">5.是否调用构造函数/析构函数<a hidden class="anchor" aria-hidden="true" href="#5是否调用构造函数析构函数">#</a></h1>
<p>使用new操作符来分配对象内存时会经历三个步骤：</p>
<ol>
<li>
<p>调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</p>
</li>
<li>
<p>编译器运行相应的构造函数以构造对象，并为其传入初值。</p>
</li>
<li>
<p>对象构造完成后，返回一个指向该对象的指针。</p>
</li>
</ol>
<p>使用delete操作符来释放对象内存时会经历两个步骤：</p>
<ol>
<li>
<p>调用对象的析构函数。</p>
</li>
<li>
<p>编译器调用operator delete(或operator delete[])函数释放内存空间。</p>
</li>
</ol>
<p>总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。</p>
<h1 id="6对数组的处理">6.对数组的处理<a hidden class="anchor" aria-hidden="true" href="#6对数组的处理">#</a></h1>
<p>C++提供了new[]与delete[]来专门处理数组类型:</p>
<pre><code>A * ptr = new A[10];//分配10个A对象
</code></pre>
<p>使用new[]分配的内存必须使用delete[]进行释放：</p>
<pre><code>delete [] ptr;
</code></pre>
<p>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>
<p>至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>
<pre><code>int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
</code></pre>
<h1 id="7是否可以被重载">7.是否可以被重载<a hidden class="anchor" aria-hidden="true" href="#7是否可以被重载">#</a></h1>
<p>opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//这些版本可能抛出异常
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="n">new</span><span class="p">[](</span><span class="n">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="nf">delete</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="p">)</span><span class="n">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="n">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="mi">0</span><span class="err">）</span><span class="n">noexcept</span><span class="p">;</span>
<span class="c1">//这些版本承诺不抛出异常
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">size_t</span> <span class="p">,</span><span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="n">new</span><span class="p">[](</span><span class="n">size_t</span><span class="p">,</span> <span class="n">nothrow_t</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="nf">delete</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="n">nothrow_t</span><span class="o">&amp;</span> <span class="p">)</span><span class="n">noexcept</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="n">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="mi">0</span><span class="p">,</span><span class="n">nothrow_t</span><span class="o">&amp;</span> <span class="err">）</span><span class="n">noexcept</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p>
<p>而malloc/free并不允许重载。</p>
<h1 id="8-能够直观地重新分配内存">8. 能够直观地重新分配内存<a hidden class="anchor" aria-hidden="true" href="#8-能够直观地重新分配内存">#</a></h1>
<p>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>
<p>new没有这样直观的配套设施来扩充内存。</p>
<h1 id="9-客户处理内存分配不足">9. 客户处理内存分配不足<a hidden class="anchor" aria-hidden="true" href="#9-客户处理内存分配不足">#</a></h1>
<p>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">new_handler</span><span class="p">)();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="n">new_handler</span> <span class="n">set_new_handler</span><span class="p">(</span><span class="n">new_handler</span> <span class="n">p</span> <span class="p">)</span> <span class="n">throw</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p>
<p>对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>
<h1 id="malloc和new的联系">malloc和new的联系<a hidden class="anchor" aria-hidden="true" href="#malloc和new的联系">#</a></h1>
<p>operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span> <span class="n">operator</span> <span class="nf">new</span> <span class="p">(</span><span class="n">sieze_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">throw</span> <span class="n">bad_alloc</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span> <span class="n">noexcept</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
