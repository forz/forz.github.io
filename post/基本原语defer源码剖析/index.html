<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>基本原语defer源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="前言 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADdefer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="基本原语defer源码剖析" />
<meta property="og:description" content="前言 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADdefer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-18T16:15:12&#43;00:00" />
<meta property="article:modified_time" content="2021-06-18T16:15:12&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="基本原语defer源码剖析"/>
<meta name="twitter:description" content="前言 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "基本原语defer源码剖析",
      "item": "/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADdefer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基本原语defer源码剖析",
  "name": "基本原语defer源码剖析",
  "description": "前言 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "前言 很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。这一节会深入 Go 语言的源代码介绍 defer 关键字的实现原理，相信读者读完这一节会对 defer 的数据结构、实现以及调用过程有着更清晰的理解。\n作为一个编程语言中的关键字，defer 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 defer 关键字的常见使用场景以及使用时的注意事项。\n使用 defer 的最常见场景是在函数调用结束后完成一些收尾工作，例如在 defer 中回滚数据库的事务：\n1 2 3 4 5 6 7 8 9 10  func createPost(db *gorm.DB) error { tx := db.Begin() defer tx.Rollback() if err := tx.Create(\u0026Post{Author: \"Draveness\"}).Error; err != nil { return err } return tx.Commit().Error }   在使用数据库事务时，我们可以使用上面的代码在创建事务后就立刻调用 Rollback 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 tx.Commit() 之后再执行 tx.Rollback() 也不会影响已经提交的事务。\n现象 我们在 Go 语言中使用 defer 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：\n defer 关键字的调用时机以及多次调用 defer 时执行顺序是如何确定的； defer 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；  作用域 向 defer 关键字传入的函数会在函数返回之前运行。假设我们在 for 循环中多次调用 defer 关键字：\n1 2 3 4 5  func main() { for i := 0; i  5; i++ { defer fmt.Println(i) } }   1 2 3 4 5 6  $ go run main.go 4 3 2 1 0   运行上述代码会倒序执行传入 defer 关键字的所有表达式，因为最后一次调用 defer 时传入了 fmt.Println(4)，所以这段代码会优先打印 4。我们可以通过下面这个简单例子强化对 defer 执行时机的理解：\n1 2 3 4 5 6 7 8  func main() { { defer fmt.Println(\"defer runs\") fmt.Println(\"block ends\") } fmt.Println(\"main ends\") }   1 2 3 4 5  $ go run main.go block ends main ends defer runs Go   从上述代码的输出我们会发现，defer 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。\n预计算参数 Go 语言中所有的函数调用都是传值的，虽然 defer 是关键字，但是也继承了这个特性。假设我们想要计算 main 函数运行的时间，可能会写出以下的代码：\n1 2 3 4 5 6  func main() { startedAt := time.Now() defer fmt.Println(time.Since(startedAt)) time.Sleep(time.Second) }   1 2 3  $ go run main.go 0s Go   然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？经过分析，我们会发现调用 defer 关键字会立刻拷贝函数中引用的外部参数，所以 time.Since(startedAt) 的结果不是在 main 函数退出之前计算的，而是在 defer 关键字调用时计算的，最终导致上述代码输出 0s。\n想要解决这个问题的方法非常简单，我们只需要向 defer 关键字传入匿名函数：\n1 2 3 4 5 6  func main() { startedAt := time.Now() defer func() { fmt.Println(time.Since(startedAt)) }() time.Sleep(time.Second) }   1 2  $ go run main.go 1s   虽然调用 defer 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 time.Since(startedAt) 会在 main 函数返回前调用并打印出符合预期的结果。\n数据结构 一个函数中的延迟语句会被保存为一个 _defer 记录的链表，附着在一个 Goroutine 上。_defer 记录的具体结构也非常简单，主要包含了参与调用的参数大小、 当前 defer 语句所在函数的 PC 和 SP 寄存器、被 defer 的函数的入口地址以及串联 多个 defer 的 link 链表，该链表指向下一个需要执行的 defer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // A _defer holds an entry on the list of deferred calls. // If you add a field here, add code to clear it in freedefer and deferProcStack // This struct must match the code in cmd/compile/internal/gc/reflect.go:deferstruct // and cmd/compile/internal/gc/ssa.go:(*state).call. // Some defers will be allocated on the stack and some on the heap. // All defers are logically part of the stack, so write barriers to // initialize them are not required. All defers must be manually scanned, // and for heap defers, marked. type _defer struct { // 参数和结果的内存大小 \tsiz int32 // includes both arguments and results \tstarted bool heap bool // openDefer indicates that this _defer is for a frame with open-coded \t// defers. We have only one defer record for the entire frame (which may \t// currently have 0, 1, or more defers active). \t// 表示当前 defer 是否经过开放编码的优化； \topenDefer bool // sp 和 pc 分别代表栈指针和调用方的程序计数器； \tsp uintptr // sp at time of defer \tpc uintptr // pc at time of defer \t//fn 是 defer 关键字中传入的函数； \tfn *funcval // can be nil for open-coded defers \t// _panic 是触发延迟调用的结构体，可能为空； \t_panic *_panic // panic that is running defer \tlink *_defer // If openDefer is true, the fields below record values about the stack \t// frame and associated function that has the open-coded defer(s). sp \t// above will be the sp for the frame, and pc will be address of the \t// deferreturn call in the function. \tfd unsafe.Pointer // funcdata for the function associated with the frame \tvarp uintptr // value of varp for the stack frame \t// framepc is the current pc associated with the stack frame. Together, \t// with sp above (which is the sp associated with the stack frame), \t// framepc/sp can be used as pc/sp pair to continue a stack trace via \t// gentraceback(). \tframepc uintptr }   runtime._defer 结构体是延迟调用链表上的一个元素，所有的结构体都会通过 link 字段串联成链表。\n执行机制 延迟语句的文法产生式 DeferStmt - \"defer\" Expression 的描述非常的简单，因而也 很容易将其处理为语法树的形式，但我们这里更关心的其实是它语义背后的中间和目标代码的形式。\n在进行中间代码生成阶段时，会通过 compileSSA 先调用 buildssa 为函数体生成 SSA 形式的函数， 并而后调用 genssa 将函数的 SSA 中间表示转换为具体的指令。\nGo 语言的语句在执行 buildssa 阶段中，会由 state.stmt 完成函数中各个语句 SSA 处理。\n中间代码生成阶段的 cmd/compile/internal/gc.state.stmt 会负责处理程序中的 defer，该函数会根据条件的不同，使用三种不同的机制处理该关键字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func (s *state) stmt(n*Node) { ... switch n.Op { case ODEFER: if Debug_defer  0 { var defertype string if s.hasOpenDefers { defertype = \"open-coded\" } else if n.Esc == EscNever { defertype = \"stack-allocated\" } else { defertype = \"heap-allocated\" } Warnl(n.Pos, \"%s defer\", defertype) } // 开放编码式 defer \tif s.hasOpenDefers { s.openDeferRecord(n.Left) } else { // 堆上分配的 defer \td := callDefer if n.Esc == EscNever { // 栈上分配的 defer \td = callDeferStack } s.callResult(n.Left, d) } ... } }   对于延迟语句而言，其中间表示会产生三种不同的延迟形式，第一种是最一般情况下的在堆上分配的延迟语句，第二种是允许在栈上分配的延迟语句， 最后一种则是开放编码式（Open-coded）的延迟语句。\n堆分配、栈分配和开放编码是处理 defer 关键字的三种方法，早期的 Go 语言会在堆上分配 runtime._defer 结构体，不过该实现的性能较差，Go 语言在 1.13 中引入栈上分配的结构体，减少了 30% 的额外开销，并在 1.14 中引入了基于开放编码的 defer，使得该关键字的额外开销可以忽略不计，我们在一节中会分别介绍三种不同类型 defer 的设计与实现原理。\n堆上分配 我们先来讨论最简单的在堆上分配的 defer 这种形式。在堆上分配的原因是 defer 语句出现 在了循环语句里，或者无法执行更高阶的编译器优化导致的。如果一个与 defer 出现在循环语句中， 则可执行的次数可能无法在编译期决定；如果一个调用中 defer 由于数量过多等原因， 不能被编译器进行开放编码，则也会在堆上分配 defer。\n总之，由于这种不确定性的存在，在堆上分配的 defer 需要最多的运行时支持， 因而产生的运行时开销也最大。\n编译阶段 为了使延迟语句的功能满足语言规范，该语句在编译的 SSA 阶段会被翻译为两个主体， 其中第一个主体是被延迟的函数本身，另一个主体则是函数结束时需要执行所记录 defer 的代码块。\nstate.call 调用会生成用于记录延迟调用参数的指令，并创建一个 deferproc 的调用指令； 而后在 state.exit 调用在函数返回前插入 deferreturn 调用的指令。\n根据 cmd/compile/internal/gc.state.stmt 方法对 defer 的处理我们可以看出，堆上分配的 runtime._defer 结构体是默认的兜底方案，当该方案被启用时，编译器会调用 cmd/compile/internal/gc.state.callResult 和 cmd/compile/internal/gc.state.call，这表示 defer 在编译器看来也是函数调用。\ncmd/compile/internal/gc.state.call 会负责为所有函数和方法调用生成中间代码，它的工作包括以下内容：\n 获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方； 获取栈地址并将函数或者方法的参数写入栈中； 使用 cmd/compile/internal/gc.state.newValue1A 以及相关函数生成函数调用的中间代码； 如果当前调用的函数是 defer，那么会单独生成相关的结束代码块； 获取函数的返回值地址并结束当前调用；  编译器不仅将 defer 关键字都转换成 runtime.deferproc 函数，它还会通过以下三个步骤为所有调用 defer 的函数末尾插入 runtime.deferreturn 的函数调用：\n cmd/compile/internal/gc.walkstmt 在遇到 ODEFER 节点时会执行 Curfn.Func.SetHasDefer(true) 设置当前函数的 hasdefer 属性； cmd/compile/internal/gc.buildssa 会执行 s.hasdefer = fn.Func.HasDefer() 更新 state 的 hasdefer； cmd/compile/internal/gc.state.exit 会根据 state 的 hasdefer 在函数返回之前插入 runtime.deferreturn 的函数调用；  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // src/cmd/compile/internal/gc/ssa.go func (s *state) call(n *Node, k callKind) *ssa.Value { ... var call *ssa.Value if k == callDeferStack { ... } else { // 在堆上创建 defer \targStart := Ctxt.FixedFrameSize() // Defer 参数 \tif k != callNormal { // 记录 deferproc 的参数 \targsize := s.constInt32(types.Types[TUINT32], int32(stksize)) addr := s.constOffPtrSP(s.f.Config.Types.UInt32Ptr, argStart) s.store(types.Types[TUINT32], addr, argsize)\t// 保存参数大小 siz \taddr = s.constOffPtrSP(s.f.Config.Types.UintptrPtr, argStart+int64(Widthptr)) s.store(types.Types[TUINTPTR], addr, closure)\t// 保存函数地址 fn \tstksize += 2 * int64(Widthptr) argStart += 2 * int64(Widthptr) } ... // 创建 deferproc 调用 \tswitch { case k == callDefer: call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, deferproc, s.mem()) ... } ... } ... // 结束 defer 块 \tif k == callDefer || k == callDeferStack { s.exit() ... } ... } func (s *state) exit() *ssa.Block { if s.hasdefer { if s.hasOpenDefers { ... } else { // 调用 deferreturn \ts.rtcall(Deferreturn, true, nil) } } ... }   从上述代码中我们能看到，defer 关键字在运行期间会调用 runtime.deferproc，这个函数接收了参数的大小和闭包所在的地址两个参数。\n当运行时将 runtime._defer 分配到堆上时，Go 语言的编译器不仅将 defer 转换成了 runtime.deferproc，还在所有调用 defer 的函数结尾插入了 runtime.deferreturn。上述两个运行时函数是 defer 关键字运行时机制的入口，它们分别承担了不同的工作：\n runtime.deferproc 负责创建新的延迟调用； runtime.deferreturn 负责在函数调用结束时执行所有的延迟调用；  我们以上述两个函数为入口介绍 defer 关键字在运行时的执行过程与工作原理。\n例如，对于一个纯粹的 defer 调用而言：\n1 2 3 4 5 6 7 8 9 10  package main func foo() { return } func main() { defer foo() return }   如果我们将其强制编译为在堆上分配的形式，可以观察到如下的汇编代码。其中 defer foo() 被转化为了 deferproc 调用，并在函数返回前，调用了 deferreturn：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  TEXT main.foo(SB) /Users/changkun/Desktop/defer/ssa/main.go return 0x104ea20\tc3\tRET TEXT main.main(SB) /Users/changkun/Desktop/defer/ssa/main.go func main() { ... // 将 defer foo() { ... }() 转化为一个 deferproc 调用 // 在调用 deferproc 前完成参数的准备工作，这个例子中没有参数 0x104ea4d\tc7042400000000\tMOVL $0x0, 0(SP) 0x104ea54\t488d0585290200\tLEAQ go.func.*+60(SB), AX 0x104ea5b\t4889442408\tMOVQ AX, 0x8(SP) 0x104ea60\te8bb31fdff\tCALL runtime.deferproc(SB) ... // 函数返回指令 RET 前插入的 deferreturn 语句 0x104ea7b\t90\tNOPL 0x104ea7c\te82f3afdff\tCALL runtime.deferreturn(SB) 0x104ea81\t488b6c2410\tMOVQ 0x10(SP), BP 0x104ea86\t4883c418\tADDQ $0x18, SP 0x104ea8a\tc3\tRET // 函数的尾声 0x104ea8b\te8d084ffff\tCALL runtime.morestack_noctxt(SB) 0x104ea90\teb9e\tJMP main.main(SB)   deferproc runtime.deferproc 会为 defer 创建一个新的 runtime._defer 结构体、设置它的函数指针 fn、程序计数器 pc 和栈指针 sp 并将相关的参数拷贝到相邻的内存空间中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func deferproc(siz int32, fn *funcval) { sp := getcallersp() argp := uintptr(unsafe.Pointer(\u0026fn)) + unsafe.Sizeof(fn) callerpc := getcallerpc() d := newdefer(siz) if d._panic != nil { throw(\"deferproc: d.panic != nil after newdefer\") } d.fn = fn d.pc = callerpc d.sp = sp // 将参数保存到 _defer 记录中 \tswitch siz { case 0:\t// 什么也不做 \tcase sys.PtrSize: *(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp)) default: memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz)) } return0() }   最后调用的 runtime.return0 是唯一一个不会触发延迟调用的函数，它可以避免递归 runtime.deferreturn 的递归调用。\n这段代码中，本质上只是在做一些简单参数处理， 比如 fn 保存了 defer 所调用函数的调用地址，siz 确定了其参数的大小。 并且通过 newdefer 来创建一个新的 _defer 实例， 然后由 fn、callerpc 和 sp 来保存调用该 defer 的 Goroutine 上下文。\n注意，在这里我们看到了一个对参数进行拷贝的操作。这个操作也是我们在实践过程中经历过的， defer 调用被记录时，并不会对参数进行求值，而是会对参数完成一次拷贝。 这么做原因是由于语义上的考虑。直觉上讲，defer 的参数应当在它所写的位置对传入的参数 进行求值，而不是将求值步骤推迟，因为延后的参数可能发生变化，导致 defer 的语义发生意料之外的错误。 例如，f, _ := os.Open(\"file.txt\") 后立刻指定 defer f.Close()，倘若随后的语句修改了 f 的值，那么将导致 f 无法被正常关闭。\n出于性能考虑，newdefer 通过 P 或者调度器 sched 上的本地或全局 defer 池来 复用已经在堆上分配的内存。defer 的资源池会根据被延迟的调用所需的参数来决定 defer 记录 的大小等级，每 16 个字节分一个等级。\nruntime.deferproc 中 runtime.newdefer 的作用是想尽办法获得 runtime._defer 结构体，这里包含三种路径：\n 从调度器的延迟调用缓存池 sched.deferpool 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中； 从 Goroutine 的延迟调用缓存池 pp.deferpool 中取出结构体； 通过 runtime.mallocgc 在堆上创建一个新的结构体；  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  // src/runtime/runtime2.go type p struct { ... // 不同大小的本地 defer 池 \tdeferpool [5][]*_defer deferpoolbuf [5][32]*_defer ... } type schedt struct { ... // 不同大小的全局 defer 池 \tdeferlock mutex deferpool [5]*_defer ... } // Allocate a Defer, usually using per-P pool. // Each defer must be released with freedefer. The defer is not // added to any defer chain yet. // // This must not grow the stack because there may be a frame without // stack map information when this is called. // //go:nosplit func newdefer(siz int32) *_defer { var d *_defer sc := deferclass(uintptr(siz)) gp := getg() // 检查 defer 参数的大小是否从 p 的 deferpool 直接分配 \tif sc  uintptr(len(p{}.deferpool)) { pp := gp.m.p.ptr() // 如果 p 本地无法分配，则从全局池中获取一半 defer，来填充 P 的本地资源池 \tif len(pp.deferpool[sc]) == 0 \u0026\u0026 sched.deferpool[sc] != nil { // Take the slow path on the system stack so \t// we don't grow newdefer's stack. \t// 出于性能考虑，如果发生栈的增长，则会调用 morestack， \t// 进一步降低 defer 的性能。因此切换到系统栈上执行，进而不会发生栈的增长。 \tsystemstack(func() { lock(\u0026sched.deferlock) for len(pp.deferpool[sc])  cap(pp.deferpool[sc])/2 \u0026\u0026 sched.deferpool[sc] != nil { d := sched.deferpool[sc] sched.deferpool[sc] = d.link d.link = nil pp.deferpool[sc] = append(pp.deferpool[sc], d) } unlock(\u0026sched.deferlock) }) } // 从 P 本地进行分配 \tif n := len(pp.deferpool[sc]); n  0 { d = pp.deferpool[sc][n-1] pp.deferpool[sc][n-1] = nil pp.deferpool[sc] = pp.deferpool[sc][:n-1] } } // 没有可用的缓存，直接从堆上分配新的 defer 和 args \tif d == nil { // Allocate new defer+args. \tsystemstack(func() { total := roundupsize(totaldefersize(uintptr(siz))) d = (*_defer)(mallocgc(total, deferType, true)) }) } // 将 _defer 实例添加到 Goroutine 的 _defer 链表上。 \td.siz = siz d.heap = true return d }   无论使用哪种方式，只要获取到 runtime._defer 结构体，它都会被追加到所在 Goroutine_defer 链表的最前面。\ndefer 关键字的插入顺序是从后向前的，而 defer 关键字执行是从前向后的，这也是为什么后调用的 defer 会优先执行。\ndeferreturn deferreturn 被编译器插入到函数末尾，当跳转到它时，会将需要被 defer 的入口地址取出， 然后跳转并执行：\nruntime.deferreturn 会从 Goroutine 的 _defer 链表中取出最前面的 runtime._defer 并调用 runtime.jmpdefer 传入需要执行的函数和参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  // Run a deferred function if there is one. // The compiler inserts a call to this at the end of any // function which calls defer. // If there is a deferred function, this will call runtime·jmpdefer, // which will jump to the deferred function such that it appears // to have been called by the caller of deferreturn at the point // just before deferreturn was called. The effect is that deferreturn // is called again and again until there are no more deferred functions. // // Declared as nosplit, because the function should not be preempted once we start // modifying the caller's frame in order to reuse the frame to call the deferred // function. // // The single argument isn't actually used - it just has its address // taken so it can be matched against pending defers. //go:nosplit func deferreturn(arg0 uintptr) { gp := getg() d := gp._defer if d == nil { return } // 确定 defer 的调用方是不是当前 deferreturn 的调用方 \tsp := getcallersp() if d.sp != sp { return } if d.openDefer { done := runOpenDeferFrame(gp, d) if !done { throw(\"unfinished open-coded defers in deferreturn\") } gp._defer = d.link freedefer(d) return } // Moving arguments around. \t// \t// Everything called after this point must be recursively \t// nosplit because the garbage collector won't know the form \t// of the arguments until the jmpdefer can flip the PC over to \t// fn. \t// 将参数复制出 _defer 记录外 \tswitch d.siz { case 0:\t// 什么也不做 \t// Do nothing. \tcase sys.PtrSize: *(*uintptr)(unsafe.Pointer(\u0026arg0)) = *(*uintptr)(deferArgs(d)) default: memmove(unsafe.Pointer(\u0026arg0), deferArgs(d), uintptr(d.siz)) } // 获得被延迟的调用 fn 的入口地址，并随后立即将 _defer 释放掉 \tfn := d.fn d.fn = nil gp._defer = d.link freedefer(d) // If the defer function pointer is nil, force the seg fault to happen \t// here rather than in jmpdefer. gentraceback() throws an error if it is \t// called with a callback on an LR architecture and jmpdefer is on the \t// stack, because the stack trace can be incorrect in that case - see \t// issue #8153). \t_ = fn.fn // 调用，并跳转到下一个 defer \tjmpdefer(fn, uintptr(unsafe.Pointer(\u0026arg0))) }   在这个函数中，会在需要时对 defer 的参数再次进行拷贝，多个 defer 函数以 jmpdefer 尾调用形式被实现。 在跳转到 fn 之前，_defer 实例被释放归还，jmpdefer 真正需要的仅仅只是函数的入口地址和参数， 以及它的调用方 deferreturn 的 SP：\nruntime.jmpdefer 是一个用汇编语言实现的运行时函数，它的主要工作是跳转到 defer 所在的代码段并在执行结束之后跳转回 runtime.deferreturn。\n1 2 3 4 5 6 7 8 9 10 11  // src/runtime/asm_amd64.s // func jmpdefer(fv *funcval, argp uintptr) TEXT runtime·jmpdefer(SB), NOSPLIT, $0-16 MOVQ\tfv+0(FP), DX\t// DX = fn MOVQ\targp+8(FP), BX\t// 调用方 SP LEAQ\t-8(BX), SP\t// CALL 后的调用方 SP MOVQ\t-8(SP), BP\t// 恢复 BP，好像 deferreturn 返回 SUBQ\t$5, (SP)\t// 再次返回到 CALL MOVQ\t0(DX), BX\t// BX = DX JMP\tBX\t// 最后才运行被 defer 的函数   这个 jmpdefer 巧妙的地方在于，它通过调用方 SP 来推算了 deferreturn 的入口地址， 从而在完成某个 defer 调用后，由于被 defer 的函数返回时会出栈， 会再次回到 deferreturn 的初始位置，进而继续反复调用，从而模拟 deferreturn 不断的对自己进行尾递归的假象。\nruntime.deferreturn 会多次判断当前 Goroutine 的_defer 链表中是否有未执行的结构体，该函数只有在所有延迟函数都执行后才会返回。\nfreedefer 释放操作非常普通，只是简单的将其归还到 P 的 deferpool 中， 并在本地池已满时将其归还到全局资源池:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  // Free the given defer. // The defer cannot be used after this call. // // This must not grow the stack because there may be a frame without a // stack map when this is called. // //go:nosplit func freedefer(d *_defer) { if d._panic != nil { freedeferpanic() } if d.fn != nil { freedeferfn() } if !d.heap { return } sc := deferclass(uintptr(d.siz)) if sc = uintptr(len(p{}.deferpool)) { return } pp := getg().m.p.ptr() // 如果 P 本地池已满，则将一半资源放入全局池，同样也是出于性能考虑 \t// 操作会切换到系统栈上执行。 \tif len(pp.deferpool[sc]) == cap(pp.deferpool[sc]) { // Transfer half of local cache to the central cache. \t// \t// Take this slow path on the system stack so \t// we don't grow freedefer's stack. \tsystemstack(func() { var first, last *_defer for len(pp.deferpool[sc])  cap(pp.deferpool[sc])/2 { n := len(pp.deferpool[sc]) d := pp.deferpool[sc][n-1] pp.deferpool[sc][n-1] = nil pp.deferpool[sc] = pp.deferpool[sc][:n-1] if first == nil { first = d } else { last.link = d } last = d } lock(\u0026sched.deferlock) last.link = sched.deferpool[sc] sched.deferpool[sc] = first unlock(\u0026sched.deferlock) }) } // These lines used to be simply `*d = _defer{}` but that \t// started causing a nosplit stack overflow via typedmemmove. \t// 恢复 _defer 的零值，即 *d = _defer{} \td.siz = 0 d.started = false d.openDefer = false d.sp = 0 d.pc = 0 d.framepc = 0 d.varp = 0 d.fd = nil // d._panic and d.fn must be nil already. \t// If not, we would have called freedeferpanic or freedeferfn above, \t// both of which throw. \td.link = nil // 放入 P 本地资源池 \tpp.deferpool[sc] = append(pp.deferpool[sc], d) }   栈上分配 Go 语言团队在 1.13 中对 defer 关键字进行了优化，当该关键字在函数体中最多执行一次时，编译期间的 cmd/compile/internal/gc.state.call 会将结构体分配到栈上并调用 runtime.deferprocStack：\ndefer 还可以直接在栈上进行分配，也就是第二种记录 defer 的形式 deferprocStack。 在栈上分配 defer 的好处在于函数返回后 _defer 便已得到释放， 不再需要考虑内存分配时产生的性能开销，只需要适当的维护_defer 的链表即可。\n在 SSA 阶段与在堆上分配的区别在于，在栈上创建 defer， 需要直接在函数调用帧上使用编译器来初始化 _defer 记录，并作为参数传递给 deferprocStack：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // src/cmd/compile/internal/gc/ssa.go func (s *state) call(n *Node, k callKind) *ssa.Value { ... var call *ssa.Value if k == callDeferStack { // 直接在栈上创建 defer 记录 \tt := deferstruct(stksize) // 从编译器角度构造 _defer 结构 \td := tempAt(n.Pos, s.curfn, t) s.vars[\u0026memVar] = s.newValue1A(ssa.OpVarDef, types.TypeMem, d, s.mem()) addr := s.addr(d, false) // 在栈上预留记录 _defer 的各个字段的空间 \ts.store(types.Types[TUINT32], s.newValue1I(ssa.OpOffPtr, types.Types[TUINT32].PtrTo(), t.FieldOff(0), addr), s.constInt32(types.Types[TUINT32], int32(stksize))) s.store(closure.Type, s.newValue1I(ssa.OpOffPtr, closure.Type.PtrTo(), t.FieldOff(6), addr), closure) // 记录参与 defer 调用的函数参数 \tft := fn.Type off := t.FieldOff(12) args := n.Rlist.Slice() // 调用 deferprocStack，以 _defer 记录的指针作为参数传递 \targ0 := s.constOffPtrSP(types.Types[TUINTPTR], Ctxt.FixedFrameSize()) s.store(types.Types[TUINTPTR], arg0, addr) call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, deferprocStack, s.mem()) ... } else { ... } // 函数尾声与堆上分配的栈一样，调用 deferreturn \tif k == callDefer || k == callDeferStack { ... s.exit() } ... }   可见，在编译阶段，一个 _defer 记录的空间已经在栈上得到保留，deferprocStack 的作用 就仅仅承担了运行时对该记录的初始化这一功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // src/runtime/panic.go  //go:nosplit func deferprocStack(d *_defer) { gp := getg() // 注意，siz 和 fn 已经在编译阶段完成设置，这里只初始化了其他字段 \td.started = false d.heap = false\t// 可见此时 defer 被标记为不在堆上分配 \td.openDefer = false d.sp = getcallersp() d.pc = getcallerpc() ... // 尽管在栈上进行分配，仍然需要将多个 _defer 记录通过链表进行串联， \t// 以便在 deferreturn 中找到被延迟的函数的入口地址： \t// d.link = gp._defer \t// gp._defer = d \t*(*uintptr)(unsafe.Pointer(\u0026d.link)) = uintptr(unsafe.Pointer(gp._defer)) *(*uintptr)(unsafe.Pointer(\u0026gp._defer)) = uintptr(unsafe.Pointer(d)) return0() }   至于函数尾声的行为，与在堆上进行分配的操作同样是调用 deferreturn，我们就不再重复说明了。 当然，里面涉及的 freedefer 调用由于不需要释放任何内存，也就早早返回了：\n1 2 3 4 5  // src/runtime/panic.go func freedefer(d *_defer) { if !d.heap { return } ... }   除了分配位置的不同，栈上分配和堆上分配的 runtime._defer 并没有本质的不同，而该方法可以适用于绝大多数的场景，与堆上分配的 runtime._defer 相比，该方法可以将 defer 关键字的额外开销降低 ~30%。\n开放编码 defer 给我们的第一感觉其实是一个编译期特性。前面我们讨论了 为什么 defer 会需要运行时的支持，以及需要运行时的 defer 是如何工作的。现在我们来 探究一下什么情况下能够让 defer 进化为一个仅编译期特性，即在函数末尾直接对延迟函数进行调用， 做到几乎不需要额外的开销。这类几乎不需要额外运行时性能开销的 defer，正是开放编码式 defer。 这类 defer 与直接调用产生的性能差异有多大呢？我们不妨编写两个性能测试：\n1 2 3 4 5 6 7  func call() { func() {}() } func callDefer() { defer func() {}() } func BenchmarkDefer(b *testing.B) { for i := 0; i  b.N; i++ { call() // 第二次运行时替换为 callDefer \t} }   在 Go 1.14 版本下，读者可以获得类似下方的性能估计，其中使用 callDefer 后， 性能损耗大约为 1 ns。这种纳秒级的性能损耗不到一个 CPU 时钟周期， 我们已经可以认为开放编码式 defer 几乎没有了性能开销：\n1 2  name old time/op new time/op delta Defer-12 1.24ns ± 1% 2.23ns ± 1% +80.06% (p=0.000 n=10+9)   我们再来观察一下开放编码式 defer 最终被编译的形式：\n1 2  go build -gcflags \"-l\" -ldflags=-compressdwarf=false -o main.out main.go go tool objdump -S main.out  main.s   对于如下形式的函数调用：\n1 2 3 4 5  var mu sync.Mutex func callDefer() { mu.Lock() defer mu.Unlock() }   整个调用最终编译结果既没有 deferproc 或者 deferprocStack，也没有了 deferreturn。 延迟语句被直接插入到了函数的末尾：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  TEXT main.callDefer(SB) /Users/changkun/Desktop/defer/main.go func callDefer() { ... mu.Lock() 0x105794a\t488d05071f0a00\tLEAQ main.mu(SB), AX 0x1057951\t48890424\tMOVQ AX, 0(SP) 0x1057955\te8f6f8ffff\tCALL sync.(*Mutex).Lock(SB) defer mu.Unlock() 0x105795a\t488d057f110200\tLEAQ go.func.*+1064(SB), AX 0x1057961\t4889442418\tMOVQ AX, 0x18(SP) 0x1057966\t488d05eb1e0a00\tLEAQ main.mu(SB), AX 0x105796d\t4889442410\tMOVQ AX, 0x10(SP) } 0x1057972\tc644240f00\tMOVB $0x0, 0xf(SP) 0x1057977\t488b442410\tMOVQ 0x10(SP), AX 0x105797c\t48890424\tMOVQ AX, 0(SP) 0x1057980\te8ebfbffff\tCALL sync.(*Mutex).Unlock(SB) 0x1057985\t488b6c2420\tMOVQ 0x20(SP), BP 0x105798a\t4883c428\tADDQ $0x28, SP 0x105798e\tc3\tRET ...   那么开放编码式 defer 是怎么实现的？所有的 defer 都是开放编码式的吗？ 什么情况下，开放编码式 defer 会退化为一个依赖运行时的特性？\nGo 语言在 1.14 中通过开放编码（Open Coded）实现 defer 关键字，该设计使用代码内联优化 defer 关键的额外开销并引入函数数据 funcdata 管理 panic 的调用，该优化可以将 defer 的调用开销从 1.13 版本的 ~35ns 降低至 ~6ns 左右：\n1 2 3  With normal (stack-allocated) defers only: 35.4 ns/op With open-coded defers: 5.6 ns/op Cost of function call alone (remove defer keyword): 4.4 ns/op   启动条件 我们先来看开放编码式 defer 的启动条件。在 SSA 的构建阶段 buildssa，我们有：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // src/cmd/compile/internal/gc/ssa.go const maxOpenDefers = 8 func walkstmt(n *Node) *Node { ... switch n.Op { case ODEFER: Curfn.Func.SetHasDefer(true) Curfn.Func.numDefers++ // 超过 8 个 defer 时，禁用对 defer 进行开放编码 \tif Curfn.Func.numDefers  maxOpenDefers { Curfn.Func.SetOpenCodedDeferDisallowed(true) } // 存在循环语句中的 defer，禁用对 defer 进行开放编码。 \t// 是否有 defer 发生在循环语句内，会在 SSA 之前的逃逸分析中进行判断， \t// 逃逸分析会检查是否存在循环（loopDepth）： \t// if where.Op == ODEFER \u0026\u0026 e.loopDepth == 1 { \t// where.Esc = EscNever \t// ... \t// } \tif n.Esc != EscNever { Curfn.Func.SetOpenCodedDeferDisallowed(true) } case ... } ... } func buildssa(fn *Node, worker int) *ssa.Func { ... var s state ... s.hasdefer = fn.Func.HasDefer() ... // 可以对 defer 进行开放编码的条件 \ts.hasOpenDefers = Debug['N'] == 0 \u0026\u0026 s.hasdefer \u0026\u0026 !s.curfn.Func.OpenCodedDeferDisallowed() if s.hasOpenDefers \u0026\u0026 s.curfn.Func.numReturns*s.curfn.Func.numDefers  15 { s.hasOpenDefers = false } ... }   这样，我们得到了允许进行 defer 的开放编码的主要条件 （此处略去了一些常见生产环境无关的条件，例如启用竞争检查时也不能对 defer 进行开放编码）：\n 没有禁用编译器优化，即没有设置 -gcflags \"-N\" 存在 defer 调用 函数内 defer 的数量不超过 8 个、且返回语句与延迟语句个数的乘积不超过 15 没有与 defer 发生在循环语句中  延迟比特 当然，正常编写的 defer 可以直接被编译器分析得出，但是如本节开头提到的，如果一个 defer 发生在一个条件语句中，而这个条件必须等到运行时才能确定：\n1 2 3  if rand.Intn(100)  42 { defer fmt.Println(\"meaning-of-life\") }   那么如何才能使用最小的成本，让插入到函数末尾的延迟语句，在条件成立时候被正确执行呢？ 这便需要一种机制，能够记录存在延迟语句的条件分支是否被执行， 这种机制在 Go 中利用了延迟比特（defer bit）。这种做法非常巧妙，但原理却非常简单。\n对于下面的代码而言：\n1 2 3 4 5  defer f1(a1) if cond { defer f2(a2) } ...   使用延迟比特的核心思想可以用下面的伪代码来概括。 在创建延迟调用的阶段，首先通过延迟比特的特定位置记录哪些带条件的 defer 被触发。 这个延迟比特是一个长度为 8 位的二进制码（也是硬件架构里最小、最通用的情况）， 以每一位是否被设置为 1，来判断延迟语句是否在运行时被设置，如果设置，则发生调用。 否则则不调用：\n1 2 3 4 5 6 7 8 9 10  deferBits = 0 // 初始值 00000000 deferBits |= 1  0 // 遇到第一个 defer，设置为 00000001 _f1 = f1 _a1 = a1 if cond { // 如果第二个 defer 被设置，则设置为 00000011，否则依然为 00000001 \tdeferBits |= 1  1 _f2 = f2 _a2 = a2 }   在退出位置，再重新根据被标记的延迟比特，反向推导哪些位置的 defer 需要被触发，从而 执行延迟调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  exit: // 按顺序倒序检查延迟比特。如果第二个 defer 被设置，则 // 00000011 \u0026 00000010 == 00000010，即延迟比特不为零，应该调用 f2。 // 如果第二个 defer 没有被设置，则 // 00000001 \u0026 00000010 == 00000000，即延迟比特为零，不应该调用 f2。 if deferBits \u0026 1  1 != 0 { // 00000011 \u0026 00000010 != 0 \tdeferBits \u0026^= 11 // 00000001 \t_f2(_a2) } // 同理，由于 00000001 \u0026 00000001 == 00000001，因此延迟比特不为零，应该调用 f1 if deferBits \u0026\u0026 1  0 != 0 { deferBits \u0026^= 10 _f1(_a1) }   在实际的实现中，可以看到，当可以设置开放编码式 defer 时，buildssa 会首先创建一个 长度位 8 位的临时变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // src/cmd/compile/internal/gc/ssa.go func buildssa(fn *Node, worker int) *ssa.Func { ... if s.hasOpenDefers { // 创建 deferBits 临时变量 \tdeferBitsTemp := tempAt(src.NoXPos, s.curfn, types.Types[TUINT8]) s.deferBitsTemp = deferBitsTemp // deferBits 被设计为 8 位二进制，因此可以被开放编码的 defer 数量不能超过 8 个 \t// 此处还将起始 deferBits 设置为零 \tstartDeferBits := s.entryNewValue0(ssa.OpConst8, types.Types[TUINT8]) s.vars[\u0026deferBitsVar] = startDeferBits s.deferBitsAddr = s.addr(deferBitsTemp, false) s.store(types.Types[TUINT8], s.deferBitsAddr, startDeferBits) ... } ... s.stmtList(fn.Nbody) // 调用 s.stmt \t... }   随后针对出现 defer 的语句，进行编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // src/cmd/compile/internal/gc/ssa.go func (s *state) stmt(n *Node) { ... switch n.Op { case ODEFER: // 开放编码式 defer \tif s.hasOpenDefers { s.openDeferRecord(n.Left) } else { ... } case ... } ... } // 存储一个 defer 调用的相关信息，例如所在的语法树结点、被延迟的调用、参数等等 type openDeferInfo struct { n *Node closure *ssa.Value closureNode *Node ... argVals []*ssa.Value argNodes []*Node } func (s *state) openDeferRecord(n *Node) { ... var args []*ssa.Value var argNodes []*Node // 记录与 defer 相关的入口地址与参数信息 \topendefer := \u0026openDeferInfo{n: n} fn := n.Left // 记录函数入口地址 \tif n.Op == OCALLFUNC { closureVal := s.expr(fn) closure := s.openDeferSave(nil, fn.Type, closureVal) opendefer.closureNode = closure.Aux.(*Node) if !(fn.Op == ONAME \u0026\u0026 fn.Class() == PFUNC) { opendefer.closure = closure } } else { ... } // 记录需要立即求值的的参数 \tfor _, argn := range n.Rlist.Slice() { var v *ssa.Value if canSSAType(argn.Type) { v = s.openDeferSave(nil, argn.Type, s.expr(argn)) } else { v = s.openDeferSave(argn, argn.Type, nil) } args = append(args, v) argNodes = append(argNodes, v.Aux.(*Node)) } opendefer.argVals = args opendefer.argNodes = argNodes // 每多出现一个 defer，len(defers) 会增加，进而 \t// 延迟比特 deferBits |= 1\tindex := len(s.openDefers) s.openDefers = append(s.openDefers, opendefer) bitvalue := s.constInt8(types.Types[TUINT8], 1uint(index)) newDeferBits := s.newValue2(ssa.OpOr8, types.Types[TUINT8], s.variable(\u0026deferBitsVar, types.Types[TUINT8]), bitvalue) s.vars[\u0026deferBitsVar] = newDeferBits s.store(types.Types[TUINT8], s.deferBitsAddr, newDeferBits) }   在函数返回退出前，state 的 exit 函数会依次倒序创建对延迟比特的检查代码， 从而顺序调用被延迟的函数调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  // src/cmd/compile/internal/gc/ssa.go func (s *state) exit() *ssa.Block { if s.hasdefer { if s.hasOpenDefers { ... s.openDeferExit() } else { ... } } ... } func (s *state) openDeferExit() { deferExit := s.f.NewBlock(ssa.BlockPlain) s.endBlock().AddEdgeTo(deferExit) s.startBlock(deferExit) s.lastDeferExit = deferExit s.lastDeferCount = len(s.openDefers) zeroval := s.constInt8(types.Types[TUINT8], 0) // 倒序检查 defer \tfor i := len(s.openDefers) - 1; i = 0; i-- { r := s.openDefers[i] bCond := s.f.NewBlock(ssa.BlockPlain) bEnd := s.f.NewBlock(ssa.BlockPlain) // 检查 deferBits \tdeferBits := s.variable(\u0026deferBitsVar, types.Types[TUINT8]) // 创建 if deferBits \u0026 1 \tbitval := s.constInt8(types.Types[TUINT8], 1uint(i)) andval := s.newValue2(ssa.OpAnd8, types.Types[TUINT8], deferBits, bitval) eqVal := s.newValue2(ssa.OpEq8, types.Types[TBOOL], andval, zeroval) b := s.endBlock() b.Kind = ssa.BlockIf b.SetControl(eqVal) b.AddEdgeTo(bEnd) b.AddEdgeTo(bCond) bCond.AddEdgeTo(bEnd) s.startBlock(bCond) // 如果创建的条件分支被触发，则清空当前的延迟比特: deferBits \u0026^= 1 \tnbitval := s.newValue1(ssa.OpCom8, types.Types[TUINT8], bitval) maskedval := s.newValue2(ssa.OpAnd8, types.Types[TUINT8], deferBits, nbitval) s.store(types.Types[TUINT8], s.deferBitsAddr, maskedval) s.vars[\u0026deferBitsVar] = maskedval // 处理被延迟的函数调用，取出保存的入口地址、参数信息 \targStart := Ctxt.FixedFrameSize() fn := r.n.Left stksize := fn.Type.ArgWidth() ... for j, argAddrVal := range r.argVals { f := getParam(r.n, j) pt := types.NewPtr(f.Type) addr := s.constOffPtrSP(pt, argStart+f.Offset) if !canSSAType(f.Type) { s.move(f.Type, addr, argAddrVal) } else { argVal := s.load(f.Type, argAddrVal) s.storeType(f.Type, addr, argVal, 0, false) } } // 调用 \tvar call *ssa.Value ... call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, fn.Sym.Linksym(), s.mem()) call.AuxInt = stksize s.vars[\u0026memVar] = call ... s.endBlock() s.startBlock(bEnd) } }   很多 defer 语句都可以在编译期间判断是否被执行，如果函数中的 defer 语句都会在编译期间确定，中间代码生成阶段就会直接调用 cmd/compile/internal/gc.state.openDeferExit 在函数返回前生成判断 deferBits 的代码。\n不过当程序遇到运行时才能判断的条件语句时，我们仍然需要由运行时的 runtime.deferreturn 决定是否执行 defer 关键字：\n1 2 3 4 5 6 7 8 9 10 11 12  func deferreturn(arg0 uintptr) { gp := getg() d := gp._defer sp := getcallersp() if d.openDefer { runOpenDeferFrame(gp, d) gp._defer = d.link freedefer(d) return } ... }   该函数为开放编码做了特殊的优化，运行时会调用 runtime.runOpenDeferFrame 执行活跃的开放编码延迟函数，该函数会执行以下的工作：\n 从 runtime._defer 结构体中读取 deferBits、函数 defer 数量等信息； 在循环中依次读取函数的地址和参数信息并通过 deferBits 判断该函数是否需要被执行； 调用 runtime.reflectcallSave 调用需要执行的 defer 函数；  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  func runOpenDeferFrame(gp *g, d *_defer) bool { fd := d.fd ... deferBitsOffset, fd := readvarintUnsafe(fd) nDefers, fd := readvarintUnsafe(fd) deferBits := *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) for i := int(nDefers) - 1; i = 0; i-- { var argWidth, closureOffset, nArgs uint32 // 读取函数的地址和参数信息 \targWidth, fd = readvarintUnsafe(fd) closureOffset, fd = readvarintUnsafe(fd) nArgs, fd = readvarintUnsafe(fd) if deferBits\u0026(1i) == 0 { ... continue } closure := *(**funcval)(unsafe.Pointer(d.varp - uintptr(closureOffset))) d.fn = closure ... deferBits = deferBits \u0026^ (1  i) *(*uint8)(unsafe.Pointer(d.varp - uintptr(deferBitsOffset))) = deferBits p := d._panic reflectcallSave(p, unsafe.Pointer(closure), deferArgs, argWidth) if p != nil \u0026\u0026 p.aborted { break } d.fn = nil memclrNoHeapPointers(deferArgs, uintptr(argWidth)) ... } return done }   从整个过程中我们可以看到，开放编码式 defer 并不是绝对的零成本，尽管编译器能够做到将 延迟调用直接插入返回语句之前，但出于语义的考虑，需要在栈上对参与延迟调用的参数进行一次求值； 同时出于条件语句中可能存在的 defer，还额外需要通过延迟比特来记录一个延迟语句是否在运行时 被设置。 因此，开放编码式 defer 的成本体现在非常少量的指令和位运算来配合在运行时判断 是否存在需要被延迟调用的 defer。\n小结 我们在本节前面提到的两个现象在这里也可以解释清楚了：\n 后调用的 defer 函数会先执行：  后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面； 运行 runtime._defer 时是从前到后依次执行；   函数的参数会被预先计算；  调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；    我们最后来总结一下 defer 的基本工作原理以及三种 defer 的性能取舍\n 对于开放编码式 defer 而言(1.14)：  编译器会直接将所需的参数进行存储，并在返回语句的末尾插入被延迟的调用； 通过 deferBits 和 cmd/compile/internal/gc.openDeferInfo 存储 defer 关键字的相关信息； 编译期间判断 defer 关键字、return 语句的个数确定是否开启开放编码优化；当整个调用中逻辑上会执行的 defer 不超过 15 个（例如七个 defer 作用在两个返回语句）、总 defer 数量不超过 8 个、且没有出现在循环语句中时，会激活使用此类 defer； 如果 defer 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的 runtime.deferreturn 处理； 此类 defer 的唯一的运行时成本就是存储参与延迟调用的相关信息，运行时性能最好。   对于栈上分配的 defer 而言(1.13)：  当该关键字在函数体中最多执行一次时，编译期间的 cmd/compile/internal/gc.state.call 会将结构体分配到栈上并调用 runtime.deferprocStack； 编译器会直接在栈上记录一个 _defer 记录，该记录不涉及内存分配，并将其作为参数，传入被翻译为 deferprocStack 的延迟语句，在延迟调用的位置将_defer 压入 Goroutine 对应的延迟调用链表中； 在函数末尾处，通过编译器的配合，在调用被 defer 的函数前，调用 deferreturn，将被延迟的调用出栈并执行； 此类 defer 的唯一运行时成本是从 _defer 记录中将参数复制出，以及从延迟调用记录链表出栈的成本，运行时性能其次。   对于堆上分配的 defer 而言：  编译期将 defer 关键字转换成 runtime.deferproc 并在调用 defer 关键字的函数返回之前插入 runtime.deferreturn； 运行时调用 runtime.deferproc 会将一个新的 runtime._defer 结构体追加到当前 Goroutine 的链表头；编译器首先会将延迟语句翻译为一个 deferproc 调用，进而从运行时分配一个用于记录被延迟调用的_defer 记录，并将被延迟的调用的入口地址及其参数复制保存，入栈到 Goroutine 对应的延迟调用链表中； 运行时调用 runtime.deferreturn 会从 Goroutine 的链表中取出 runtime._defer 结构并依次执行；在函数末尾处，通过编译器的配合，在调用被 defer 的函数前，调用 deferreturn，从而将_defer 实例归还到资源池，而后通过模拟尾递归的方式来对需要 defer 的函数进行调用。 此类 defer 的主要性能问题存在于每个 defer 语句产生记录时的内存分配，记录参数和完成调用时的参数移动时的系统调用，运行时性能最差。    参考 5.3 defer\n9.2 延迟语句\n",
  "wordCount" : "11584",
  "inLanguage": "zh-cn",
  "datePublished": "2021-06-18T16:15:12Z",
  "dateModified": "2021-06-18T16:15:12Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADdefer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      基本原语defer源码剖析
    </h1>
    <div class="post-meta">June 18, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。这一节会深入 Go 语言的源代码介绍 defer 关键字的实现原理，相信读者读完这一节会对 defer 的数据结构、实现以及调用过程有着更清晰的理解。</p>
<p>作为一个编程语言中的关键字，defer 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 defer 关键字的常见使用场景以及使用时的注意事项。</p>
<p>使用 defer 的最常见场景是在函数调用结束后完成一些收尾工作，例如在 defer 中回滚数据库的事务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">createPost</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Post</span><span class="p">{</span><span class="nx">Author</span><span class="p">:</span> <span class="s">&#34;Draveness&#34;</span><span class="p">}).</span><span class="nx">Error</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">().</span><span class="nx">Error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在使用数据库事务时，我们可以使用上面的代码在创建事务后就立刻调用 Rollback 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 tx.Commit() 之后再执行 tx.Rollback() 也不会影响已经提交的事务。</p>
<h2 id="现象">现象<a hidden class="anchor" aria-hidden="true" href="#现象">#</a></h2>
<p>我们在 Go 语言中使用 defer 时会遇到两个常见问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：</p>
<ul>
<li>defer 关键字的调用时机以及多次调用 defer 时执行顺序是如何确定的；</li>
<li>defer 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；</li>
</ul>
<h3 id="作用域">作用域<a hidden class="anchor" aria-hidden="true" href="#作用域">#</a></h3>
<p>向 defer 关键字传入的函数会在函数返回之前运行。假设我们在 for 循环中多次调用 defer 关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">4</span>
<span class="m">3</span>
<span class="m">2</span>
<span class="m">1</span>
<span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><p>运行上述代码会倒序执行传入 defer 关键字的所有表达式，因为最后一次调用 defer 时传入了 fmt.Println(4)，所以这段代码会优先打印 4。我们可以通过下面这个简单例子强化对 defer 执行时机的理解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer runs&#34;</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;block ends&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main ends&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="n">block</span> <span class="n">ends</span>
<span class="n">main</span> <span class="n">ends</span>
<span class="n">defer</span> <span class="n">runs</span>
<span class="n">Go</span>
</code></pre></td></tr></table>
</div>
</div><p>从上述代码的输出我们会发现，defer 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p>
<h3 id="预计算参数">预计算参数<a hidden class="anchor" aria-hidden="true" href="#预计算参数">#</a></h3>
<p>Go 语言中所有的函数调用都是传值的，虽然 defer 是关键字，但是也继承了这个特性。假设我们想要计算 main 函数运行的时间，可能会写出以下的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">startedAt</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startedAt</span><span class="p">))</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">0</span><span class="n">s</span>
<span class="n">Go</span>
</code></pre></td></tr></table>
</div>
</div><p>然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？经过分析，我们会发现调用 defer 关键字会立刻拷贝函数中引用的外部参数，所以 <code>time.Since(startedAt)</code> 的结果不是在 main 函数退出之前计算的，而是在 defer 关键字调用时计算的，最终导致上述代码输出 0s。</p>
<p>想要解决这个问题的方法非常简单，我们只需要向 defer 关键字传入匿名函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">startedAt</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startedAt</span><span class="p">))</span> <span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">main.go</span>
<span class="m">1</span><span class="n">s</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然调用 defer 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 time.Since(startedAt) 会在 main 函数返回前调用并打印出符合预期的结果。</p>
<h2 id="数据结构">数据结构<a hidden class="anchor" aria-hidden="true" href="#数据结构">#</a></h2>
<p>一个函数中的延迟语句会被保存为一个 _defer 记录的链表，附着在一个 Goroutine 上。_defer 记录的具体结构也非常简单，主要包含了参与调用的参数大小、 当前 defer 语句所在函数的 PC 和 SP 寄存器、被 defer 的函数的入口地址以及串联 多个 defer 的 link 链表，该链表指向下一个需要执行的 defer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A _defer holds an entry on the list of deferred calls.
</span><span class="c1">// If you add a field here, add code to clear it in freedefer and deferProcStack
</span><span class="c1">// This struct must match the code in cmd/compile/internal/gc/reflect.go:deferstruct
</span><span class="c1">// and cmd/compile/internal/gc/ssa.go:(*state).call.
</span><span class="c1">// Some defers will be allocated on the stack and some on the heap.
</span><span class="c1">// All defers are logically part of the stack, so write barriers to
</span><span class="c1">// initialize them are not required. All defers must be manually scanned,
</span><span class="c1">// and for heap defers, marked.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">_defer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 参数和结果的内存大小
</span><span class="c1"></span>	<span class="nx">siz</span>     <span class="kt">int32</span> <span class="c1">// includes both arguments and results
</span><span class="c1"></span>	<span class="nx">started</span> <span class="kt">bool</span>
	<span class="nx">heap</span>    <span class="kt">bool</span>
	<span class="c1">// openDefer indicates that this _defer is for a frame with open-coded
</span><span class="c1"></span>	<span class="c1">// defers. We have only one defer record for the entire frame (which may
</span><span class="c1"></span>	<span class="c1">// currently have 0, 1, or more defers active).
</span><span class="c1"></span>	<span class="c1">// 表示当前 defer 是否经过开放编码的优化；
</span><span class="c1"></span>	<span class="nx">openDefer</span> <span class="kt">bool</span>
	<span class="c1">// sp 和 pc 分别代表栈指针和调用方的程序计数器；
</span><span class="c1"></span>	<span class="nx">sp</span>        <span class="kt">uintptr</span>  <span class="c1">// sp at time of defer
</span><span class="c1"></span>	<span class="nx">pc</span>        <span class="kt">uintptr</span>  <span class="c1">// pc at time of defer
</span><span class="c1"></span>	<span class="c1">//fn 是 defer 关键字中传入的函数；
</span><span class="c1"></span>	<span class="nx">fn</span>        <span class="o">*</span><span class="nx">funcval</span> <span class="c1">// can be nil for open-coded defers
</span><span class="c1"></span>	<span class="c1">// _panic 是触发延迟调用的结构体，可能为空；
</span><span class="c1"></span>	<span class="nx">_panic</span>    <span class="o">*</span><span class="nx">_panic</span>  <span class="c1">// panic that is running defer
</span><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_defer</span>

	<span class="c1">// If openDefer is true, the fields below record values about the stack
</span><span class="c1"></span>	<span class="c1">// frame and associated function that has the open-coded defer(s). sp
</span><span class="c1"></span>	<span class="c1">// above will be the sp for the frame, and pc will be address of the
</span><span class="c1"></span>	<span class="c1">// deferreturn call in the function.
</span><span class="c1"></span>	<span class="nx">fd</span>   <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// funcdata for the function associated with the frame
</span><span class="c1"></span>	<span class="nx">varp</span> <span class="kt">uintptr</span>        <span class="c1">// value of varp for the stack frame
</span><span class="c1"></span>	<span class="c1">// framepc is the current pc associated with the stack frame. Together,
</span><span class="c1"></span>	<span class="c1">// with sp above (which is the sp associated with the stack frame),
</span><span class="c1"></span>	<span class="c1">// framepc/sp can be used as pc/sp pair to continue a stack trace via
</span><span class="c1"></span>	<span class="c1">// gentraceback().
</span><span class="c1"></span>	<span class="nx">framepc</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime._defer 结构体是延迟调用链表上的一个元素，所有的结构体都会通过 link 字段串联成链表。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210620182243.png" alt=""  />
</p>
<h2 id="执行机制">执行机制<a hidden class="anchor" aria-hidden="true" href="#执行机制">#</a></h2>
<p>延迟语句的文法产生式 <code>DeferStmt -&gt; &quot;defer&quot; Expression</code> 的描述非常的简单，因而也 很容易将其处理为语法树的形式，但我们这里更关心的其实是它语义背后的中间和目标代码的形式。</p>
<p>在进行中间代码生成阶段时，会通过 compileSSA 先调用 buildssa 为函数体生成 SSA 形式的函数， 并而后调用 genssa 将函数的 SSA 中间表示转换为具体的指令。</p>
<p>Go 语言的语句在执行 buildssa 阶段中，会由 state.stmt 完成函数中各个语句 SSA 处理。</p>
<p>中间代码生成阶段的 <code>cmd/compile/internal/gc.state.stmt</code> 会负责处理程序中的 defer，该函数会根据条件的不同，使用三种不同的机制处理该关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">stmt</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">ODEFER</span><span class="p">:</span>
		<span class="k">if</span> <span class="nx">Debug_defer</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">defertype</span> <span class="kt">string</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
				<span class="nx">defertype</span> <span class="p">=</span> <span class="s">&#34;open-coded&#34;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNever</span> <span class="p">{</span>
				<span class="nx">defertype</span> <span class="p">=</span> <span class="s">&#34;stack-allocated&#34;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">defertype</span> <span class="p">=</span> <span class="s">&#34;heap-allocated&#34;</span>
			<span class="p">}</span>
			<span class="nf">Warnl</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Pos</span><span class="p">,</span> <span class="s">&#34;%s defer&#34;</span><span class="p">,</span> <span class="nx">defertype</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 开放编码式 defer
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">openDeferRecord</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 堆上分配的 defer
</span><span class="c1"></span>			<span class="nx">d</span> <span class="o">:=</span> <span class="nx">callDefer</span>
			<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNever</span> <span class="p">{</span>
				<span class="c1">// 栈上分配的 defer
</span><span class="c1"></span>				<span class="nx">d</span> <span class="p">=</span> <span class="nx">callDeferStack</span>
			<span class="p">}</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">callResult</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="o">...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于延迟语句而言，其中间表示会产生三种不同的延迟形式，第一种是最一般情况下的在堆上分配的延迟语句，第二种是允许在栈上分配的延迟语句， 最后一种则是开放编码式（Open-coded）的延迟语句。</p>
<p>堆分配、栈分配和开放编码是处理 defer 关键字的三种方法，早期的 Go 语言会在堆上分配 runtime._defer 结构体，不过该实现的性能较差，Go 语言在 1.13 中引入栈上分配的结构体，减少了 30% 的额外开销，并在 1.14 中引入了基于开放编码的 defer，使得该关键字的额外开销可以忽略不计，我们在一节中会分别介绍三种不同类型 defer 的设计与实现原理。</p>
<h2 id="堆上分配">堆上分配<a hidden class="anchor" aria-hidden="true" href="#堆上分配">#</a></h2>
<p>我们先来讨论最简单的在堆上分配的 defer 这种形式。在堆上分配的原因是 defer 语句出现 在了循环语句里，或者无法执行更高阶的编译器优化导致的。如果一个与 defer 出现在循环语句中， 则可执行的次数可能无法在编译期决定；如果一个调用中 defer 由于数量过多等原因， 不能被编译器进行开放编码，则也会在堆上分配 defer。</p>
<p>总之，由于这种不确定性的存在，在堆上分配的 defer 需要最多的运行时支持， 因而产生的运行时开销也最大。</p>
<h3 id="编译阶段">编译阶段<a hidden class="anchor" aria-hidden="true" href="#编译阶段">#</a></h3>
<p>为了使延迟语句的功能满足语言规范，该语句在编译的 SSA 阶段会被翻译为两个主体， 其中第一个主体是被延迟的函数本身，另一个主体则是函数结束时需要执行所记录 defer 的代码块。</p>
<p>state.call 调用会生成用于记录延迟调用参数的指令，并创建一个 deferproc 的调用指令； 而后在 state.exit 调用在函数返回前插入 deferreturn 调用的指令。</p>
<p>根据 <code>cmd/compile/internal/gc.state.stmt</code> 方法对 defer 的处理我们可以看出，堆上分配的 <code>runtime._defer</code> 结构体是默认的兜底方案，当该方案被启用时，编译器会调用 <code>cmd/compile/internal/gc.state.callResult</code> 和 <code>cmd/compile/internal/gc.state.call</code>，这表示 defer 在编译器看来也是函数调用。</p>
<p><code>cmd/compile/internal/gc.state.call</code> 会负责为所有函数和方法调用生成中间代码，它的工作包括以下内容：</p>
<ol>
<li>获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方；</li>
<li>获取栈地址并将函数或者方法的参数写入栈中；</li>
<li>使用 <code>cmd/compile/internal/gc.state.newValue1A</code> 以及相关函数生成函数调用的中间代码；</li>
<li>如果当前调用的函数是 defer，那么会单独生成相关的结束代码块；</li>
<li>获取函数的返回值地址并结束当前调用；</li>
</ol>
<p>编译器不仅将 defer 关键字都转换成 runtime.deferproc 函数，它还会通过以下三个步骤为所有调用 defer 的函数末尾插入 <code>runtime.deferreturn</code> 的函数调用：</p>
<ol>
<li><code>cmd/compile/internal/gc.walkstmt</code> 在遇到 <code>ODEFER</code> 节点时会执行 <code>Curfn.Func.SetHasDefer(true)</code> 设置当前函数的 <code>hasdefer</code> 属性；</li>
<li><code>cmd/compile/internal/gc.buildssa</code> 会执行 <code>s.hasdefer = fn.Func.HasDefer()</code> 更新 <code>state</code> 的 <code>hasdefer</code>；</li>
<li><code>cmd/compile/internal/gc.state.exit</code> 会根据 <code>state</code> 的 <code>hasdefer</code> 在函数返回之前插入 <code>runtime.deferreturn</code> 的函数调用；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/cmd/compile/internal/gc/ssa.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">k</span> <span class="nx">callKind</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">call</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 在堆上创建 defer
</span><span class="c1"></span>		<span class="nx">argStart</span> <span class="o">:=</span> <span class="nx">Ctxt</span><span class="p">.</span><span class="nf">FixedFrameSize</span><span class="p">()</span>
		<span class="c1">// Defer 参数
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">k</span> <span class="o">!=</span> <span class="nx">callNormal</span> <span class="p">{</span>
			<span class="c1">// 记录 deferproc 的参数
</span><span class="c1"></span>			<span class="nx">argsize</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constInt32</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT32</span><span class="p">],</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">stksize</span><span class="p">))</span>
			<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constOffPtrSP</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">Types</span><span class="p">.</span><span class="nx">UInt32Ptr</span><span class="p">,</span> <span class="nx">argStart</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT32</span><span class="p">],</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">argsize</span><span class="p">)</span>	<span class="c1">// 保存参数大小 siz
</span><span class="c1"></span>			<span class="nx">addr</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constOffPtrSP</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">Types</span><span class="p">.</span><span class="nx">UintptrPtr</span><span class="p">,</span> <span class="nx">argStart</span><span class="o">+</span><span class="nb">int64</span><span class="p">(</span><span class="nx">Widthptr</span><span class="p">))</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINTPTR</span><span class="p">],</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">closure</span><span class="p">)</span>	<span class="c1">// 保存函数地址 fn
</span><span class="c1"></span>			<span class="nx">stksize</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">Widthptr</span><span class="p">)</span>
			<span class="nx">argStart</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">Widthptr</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="o">...</span>

		<span class="c1">// 创建 deferproc 调用
</span><span class="c1"></span>		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDefer</span><span class="p">:</span>
			<span class="nx">call</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStaticCall</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">deferproc</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
		<span class="o">...</span>
		<span class="p">}</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>

	<span class="c1">// 结束 defer 块
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDefer</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">exit</span><span class="p">()</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">exit</span><span class="p">()</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Block</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasdefer</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 调用 deferreturn
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">rtcall</span><span class="p">(</span><span class="nx">Deferreturn</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从上述代码中我们能看到，defer 关键字在运行期间会调用 <code>runtime.deferproc</code>，这个函数接收了参数的大小和闭包所在的地址两个参数。</p>
<p>当运行时将 runtime._defer 分配到堆上时，Go 语言的编译器不仅将 defer 转换成了 runtime.deferproc，还在所有调用 defer 的函数结尾插入了 runtime.deferreturn。上述两个运行时函数是 defer 关键字运行时机制的入口，它们分别承担了不同的工作：</p>
<ul>
<li><code>runtime.deferproc</code> 负责创建新的延迟调用；</li>
<li><code>runtime.deferreturn</code> 负责在函数调用结束时执行所有的延迟调用；</li>
</ul>
<p>我们以上述两个函数为入口介绍 defer 关键字在运行时的执行过程与工作原理。</p>
<p>例如，对于一个纯粹的 defer 调用而言：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nf">foo</span><span class="p">()</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们将其强制编译为在堆上分配的形式，可以观察到如下的汇编代码。其中 defer foo() 被转化为了 deferproc 调用，并在函数返回前，调用了 deferreturn：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main.foo</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">changkun</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">defer</span><span class="o">/</span><span class="n">ssa</span><span class="o">/</span><span class="n">main.go</span>
	<span class="n">return</span>
  <span class="mh">0x104ea20</span>		<span class="n">c3</span>			<span class="n">RET</span>

<span class="n">TEXT</span> <span class="nf">main.main</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">changkun</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">defer</span><span class="o">/</span><span class="n">ssa</span><span class="o">/</span><span class="n">main.go</span>
<span class="n">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kc">...</span>
  <span class="o">//</span> 将 <span class="n">defer</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="kc">...</span> <span class="p">}()</span> 转化为一个 <span class="n">deferproc</span> 调用
  <span class="o">//</span> 在调用 <span class="n">deferproc</span> 前完成参数的准备工作，这个例子中没有参数
  <span class="mh">0x104ea4d</span>		<span class="n">c7042400000000</span>		<span class="n">MOVL</span> <span class="o">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="mh">0x104ea54</span>		<span class="m">488</span><span class="n">d0585290200</span>		<span class="n">LEAQ</span> <span class="n">go.func.</span><span class="o">*</span><span class="m">+60</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
  <span class="mh">0x104ea5b</span>		<span class="m">4889442408</span>		<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="mh">0x104ea60</span>		<span class="n">e8bb31fdff</span>		<span class="n">CALL</span> <span class="nf">runtime.deferproc</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="kc">...</span>
  <span class="o">//</span> 函数返回指令 <span class="n">RET</span> 前插入的 <span class="n">deferreturn</span> 语句
  <span class="mh">0x104ea7b</span>		<span class="m">90</span>			<span class="n">NOPL</span>
  <span class="mh">0x104ea7c</span>		<span class="n">e82f3afdff</span>		<span class="n">CALL</span> <span class="nf">runtime.deferreturn</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="mh">0x104ea81</span>		<span class="m">488</span><span class="n">b6c2410</span>		<span class="n">MOVQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BP</span>
  <span class="mh">0x104ea86</span>		<span class="m">4883</span><span class="n">c418</span>		<span class="n">ADDQ</span> <span class="o">$</span><span class="mh">0x18</span><span class="p">,</span> <span class="n">SP</span>
  <span class="mh">0x104ea8a</span>		<span class="n">c3</span>			<span class="n">RET</span>
  <span class="o">//</span> 函数的尾声
  <span class="mh">0x104ea8b</span>		<span class="n">e8d084ffff</span>		<span class="n">CALL</span> <span class="nf">runtime.morestack_noctxt</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="mh">0x104ea90</span>		<span class="n">eb9e</span>			<span class="n">JMP</span> <span class="nf">main.main</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="deferproc">deferproc<a hidden class="anchor" aria-hidden="true" href="#deferproc">#</a></h3>
<p>runtime.deferproc 会为 defer 创建一个新的 <code>runtime._defer</code> 结构体、设置它的函数指针 fn、程序计数器 pc 和栈指针 sp 并将相关的参数拷贝到相邻的内存空间中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">argp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>

	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;deferproc: d.panic != nil after newdefer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="c1">// 将参数保存到 _defer 记录中
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>		<span class="c1">// 什么也不做
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nf">return0</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后调用的 <code>runtime.return0</code> 是唯一一个不会触发延迟调用的函数，它可以避免递归 runtime.deferreturn 的递归调用。</p>
<p>这段代码中，本质上只是在做一些简单参数处理， 比如 fn 保存了 defer 所调用函数的调用地址，siz 确定了其参数的大小。 并且通过 newdefer 来创建一个新的 _defer 实例， 然后由 fn、callerpc 和 sp 来保存调用该 defer 的 Goroutine 上下文。</p>
<p>注意，在这里我们看到了一个对参数进行拷贝的操作。这个操作也是我们在实践过程中经历过的， defer 调用被记录时，并不会对参数进行求值，而是会对参数完成一次拷贝。 这么做原因是由于语义上的考虑。直觉上讲，defer 的参数应当在它所写的位置对传入的参数 进行求值，而不是将求值步骤推迟，因为延后的参数可能发生变化，导致 defer 的语义发生意料之外的错误。 例如，<code>f, _ := os.Open(&quot;file.txt&quot;)</code> 后立刻指定 <code>defer f.Close()</code>，倘若随后的语句修改了 f 的值，那么将导致 f 无法被正常关闭。</p>
<p>出于性能考虑，newdefer 通过 P 或者调度器 sched 上的本地或全局 defer 池来 复用已经在堆上分配的内存。defer 的资源池会根据被延迟的调用所需的参数来决定 defer 记录 的大小等级，每 16 个字节分一个等级。</p>
<p><code>runtime.deferproc</code> 中 <code>runtime.newdefer</code> 的作用是想尽办法获得 <code>runtime._defer</code> 结构体，这里包含三种路径：</p>
<ol>
<li>从调度器的延迟调用缓存池 sched.deferpool 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；</li>
<li>从 Goroutine 的延迟调用缓存池 pp.deferpool 中取出结构体；</li>
<li>通过 runtime.mallocgc 在堆上创建一个新的结构体；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">// 不同大小的本地 defer 池
</span><span class="c1"></span>	<span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">// 不同大小的全局 defer 池
</span><span class="c1"></span>	<span class="nx">deferlock</span> <span class="nx">mutex</span>
	<span class="nx">deferpool</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="c1">// Allocate a Defer, usually using per-P pool.
</span><span class="c1">// Each defer must be released with freedefer.  The defer is not
</span><span class="c1">// added to any defer chain yet.
</span><span class="c1">//
</span><span class="c1">// This must not grow the stack because there may be a frame without
</span><span class="c1">// stack map information when this is called.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">_defer</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 检查 defer 参数的大小是否从 p 的 deferpool 直接分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sc</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="c1">// 如果 p 本地无法分配，则从全局池中获取一半 defer，来填充 P 的本地资源池
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Take the slow path on the system stack so
</span><span class="c1"></span>			<span class="c1">// we don&#39;t grow newdefer&#39;s stack.
</span><span class="c1"></span>			<span class="c1">// 出于性能考虑，如果发生栈的增长，则会调用 morestack，
</span><span class="c1"></span>			<span class="c1">// 进一步降低 defer 的性能。因此切换到系统栈上执行，进而不会发生栈的增长。
</span><span class="c1"></span>			<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
				<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">&lt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">d</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
					<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
					<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="kc">nil</span>
					<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">],</span> <span class="nx">d</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
			<span class="p">})</span>
		<span class="p">}</span>
		<span class="c1">// 从 P 本地进行分配
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]);</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 没有可用的缓存，直接从堆上分配新的 defer 和 args
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Allocate new defer+args.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nf">totaldefersize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)))</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_defer</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">total</span><span class="p">,</span> <span class="nx">deferType</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="c1">// 将 _defer 实例添加到 Goroutine 的 _defer 链表上。
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>无论使用哪种方式，只要获取到 runtime._defer 结构体，它都会被追加到所在 Goroutine_defer 链表的最前面。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210620171238.png" alt=""  />
</p>
<p>defer 关键字的插入顺序是从后向前的，而 defer 关键字执行是从前向后的，这也是为什么后调用的 defer 会优先执行。</p>
<h3 id="deferreturn">deferreturn<a hidden class="anchor" aria-hidden="true" href="#deferreturn">#</a></h3>
<p>deferreturn 被编译器插入到函数末尾，当跳转到它时，会将需要被 defer 的入口地址取出， 然后跳转并执行：</p>
<p><code>runtime.deferreturn</code> 会从 Goroutine 的 _defer 链表中取出最前面的 <code>runtime._defer</code> 并调用 <code>runtime.jmpdefer</code> 传入需要执行的函数和参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Run a deferred function if there is one.
</span><span class="c1">// The compiler inserts a call to this at the end of any
</span><span class="c1">// function which calls defer.
</span><span class="c1">// If there is a deferred function, this will call runtime·jmpdefer,
</span><span class="c1">// which will jump to the deferred function such that it appears
</span><span class="c1">// to have been called by the caller of deferreturn at the point
</span><span class="c1">// just before deferreturn was called. The effect is that deferreturn
</span><span class="c1">// is called again and again until there are no more deferred functions.
</span><span class="c1">//
</span><span class="c1">// Declared as nosplit, because the function should not be preempted once we start
</span><span class="c1">// modifying the caller&#39;s frame in order to reuse the frame to call the deferred
</span><span class="c1">// function.
</span><span class="c1">//
</span><span class="c1">// The single argument isn&#39;t actually used - it just has its address
</span><span class="c1">// taken so it can be matched against pending defers.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 确定 defer 的调用方是不是当前 deferreturn 的调用方
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="o">!=</span> <span class="nx">sp</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
		<span class="nx">done</span> <span class="o">:=</span> <span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">done</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unfinished open-coded defers in deferreturn&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
		<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Moving arguments around.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Everything called after this point must be recursively
</span><span class="c1"></span>	<span class="c1">// nosplit because the garbage collector won&#39;t know the form
</span><span class="c1"></span>	<span class="c1">// of the arguments until the jmpdefer can flip the PC over to
</span><span class="c1"></span>	<span class="c1">// fn.
</span><span class="c1"></span>	<span class="c1">// 将参数复制出 _defer 记录外
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>	<span class="c1">// 什么也不做
</span><span class="c1"></span>		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 获得被延迟的调用 fn 的入口地址，并随后立即将 _defer 释放掉
</span><span class="c1"></span>	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
	<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="c1">// If the defer function pointer is nil, force the seg fault to happen
</span><span class="c1"></span>	<span class="c1">// here rather than in jmpdefer. gentraceback() throws an error if it is
</span><span class="c1"></span>	<span class="c1">// called with a callback on an LR architecture and jmpdefer is on the
</span><span class="c1"></span>	<span class="c1">// stack, because the stack trace can be incorrect in that case - see
</span><span class="c1"></span>	<span class="c1">// issue #8153).
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
	<span class="c1">// 调用，并跳转到下一个 defer
</span><span class="c1"></span>	<span class="nf">jmpdefer</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个函数中，会在需要时对 defer 的参数再次进行拷贝，多个 defer 函数以 jmpdefer 尾调用形式被实现。 在跳转到 fn 之前，_defer 实例被释放归还，jmpdefer 真正需要的仅仅只是函数的入口地址和参数， 以及它的调用方 deferreturn 的 SP：</p>
<p>runtime.jmpdefer 是一个用汇编语言实现的运行时函数，它的主要工作是跳转到 defer 所在的代码段并在执行结束之后跳转回 runtime.deferreturn。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">//</span> <span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">asm_amd64.s</span>

<span class="o">//</span> <span class="n">func</span> <span class="nf">jmpdefer</span><span class="p">(</span><span class="n">fv</span> <span class="o">*</span><span class="n">funcval</span><span class="p">,</span> <span class="n">argp</span> <span class="n">uintptr</span><span class="p">)</span>
<span class="n">TEXT</span> <span class="n">runtime</span>·<span class="nf">jmpdefer</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">NOSPLIT</span><span class="p">,</span> <span class="o">$</span><span class="m">0-16</span>
	<span class="n">MOVQ</span>	<span class="n">fv</span><span class="m">+0</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">DX</span>	<span class="o">//</span> <span class="n">DX</span> <span class="o">=</span> <span class="n">fn</span>
	<span class="n">MOVQ</span>	<span class="n">argp</span><span class="m">+8</span><span class="p">(</span><span class="n">FP</span><span class="p">),</span> <span class="n">BX</span>	<span class="o">//</span> 调用方 <span class="n">SP</span>
	<span class="n">LEAQ</span>	<span class="m">-8</span><span class="p">(</span><span class="n">BX</span><span class="p">),</span> <span class="n">SP</span>		<span class="o">//</span> <span class="n">CALL</span> 后的调用方 <span class="n">SP</span>
	<span class="n">MOVQ</span>	<span class="m">-8</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BP</span>		<span class="o">//</span> 恢复 <span class="n">BP</span>，好像 <span class="n">deferreturn</span> 返回
	<span class="n">SUBQ</span>	<span class="o">$</span><span class="m">5</span><span class="p">,</span> <span class="p">(</span><span class="n">SP</span><span class="p">)</span>		<span class="o">//</span> 再次返回到 <span class="n">CALL</span>
	<span class="n">MOVQ</span>	<span class="m">0</span><span class="p">(</span><span class="n">DX</span><span class="p">),</span> <span class="n">BX</span>		<span class="o">//</span> <span class="n">BX</span> <span class="o">=</span> <span class="n">DX</span>
	<span class="n">JMP</span>	<span class="n">BX</span>					<span class="o">//</span> 最后才运行被 <span class="n">defer</span> 的函数
</code></pre></td></tr></table>
</div>
</div><p>这个 jmpdefer 巧妙的地方在于，它通过调用方 SP 来推算了 deferreturn 的入口地址， 从而在完成某个 defer 调用后，由于被 defer 的函数返回时会出栈， 会再次回到 deferreturn 的初始位置，进而继续反复调用，从而模拟 deferreturn 不断的对自己进行尾递归的假象。</p>
<p>runtime.deferreturn 会多次判断当前 Goroutine 的_defer 链表中是否有未执行的结构体，该函数只有在所有延迟函数都执行后才会返回。</p>
<h3 id="freedefer">freedefer<a hidden class="anchor" aria-hidden="true" href="#freedefer">#</a></h3>
<p>释放操作非常普通，只是简单的将其归还到 P 的 deferpool 中， 并在本地池已满时将其归还到全局资源池:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Free the given defer.
</span><span class="c1">// The defer cannot be used after this call.
</span><span class="c1">//
</span><span class="c1">// This must not grow the stack because there may be a frame without a
</span><span class="c1">// stack map when this is called.
</span><span class="c1">//
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">freedeferpanic</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">freedeferfn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">sc</span> <span class="o">&gt;=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">// 如果 P 本地池已满，则将一半资源放入全局池，同样也是出于性能考虑
</span><span class="c1"></span>	<span class="c1">// 操作会切换到系统栈上执行。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">{</span>
		<span class="c1">// Transfer half of local cache to the central cache.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Take this slow path on the system stack so
</span><span class="c1"></span>		<span class="c1">// we don&#39;t grow freedefer&#39;s stack.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span> <span class="o">*</span><span class="nx">_defer</span>
			<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
				<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span>
				<span class="nx">d</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">if</span> <span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">first</span> <span class="p">=</span> <span class="nx">d</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">last</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">d</span>
				<span class="p">}</span>
				<span class="nx">last</span> <span class="p">=</span> <span class="nx">d</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
			<span class="nx">last</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">first</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="c1">// These lines used to be simply `*d = _defer{}` but that
</span><span class="c1"></span>	<span class="c1">// started causing a nosplit stack overflow via typedmemmove.
</span><span class="c1"></span>	<span class="c1">// 恢复 _defer 的零值，即 *d = _defer{}
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">framepc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fd</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// d._panic and d.fn must be nil already.
</span><span class="c1"></span>	<span class="c1">// If not, we would have called freedeferpanic or freedeferfn above,
</span><span class="c1"></span>	<span class="c1">// both of which throw.
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// 放入 P 本地资源池
</span><span class="c1"></span>	<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">],</span> <span class="nx">d</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="栈上分配">栈上分配<a hidden class="anchor" aria-hidden="true" href="#栈上分配">#</a></h2>
<p>Go 语言团队在 1.13 中对 defer 关键字进行了优化，当该关键字在函数体中最多执行一次时，编译期间的 <code>cmd/compile/internal/gc.state.call</code> 会将结构体分配到栈上并调用 runtime.deferprocStack：</p>
<p>defer 还可以直接在栈上进行分配，也就是第二种记录 defer 的形式 deferprocStack。 在栈上分配 defer 的好处在于函数返回后 _defer 便已得到释放， 不再需要考虑内存分配时产生的性能开销，只需要适当的维护_defer 的链表即可。</p>
<p>在 SSA 阶段与在堆上分配的区别在于，在栈上创建 defer， 需要直接在函数调用帧上使用编译器来初始化 _defer 记录，并作为参数传递给 deferprocStack：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/cmd/compile/internal/gc/ssa.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">k</span> <span class="nx">callKind</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">call</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
		<span class="c1">// 直接在栈上创建 defer 记录
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nf">deferstruct</span><span class="p">(</span><span class="nx">stksize</span><span class="p">)</span> <span class="c1">// 从编译器角度构造 _defer 结构
</span><span class="c1"></span>		<span class="nx">d</span> <span class="o">:=</span> <span class="nf">tempAt</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Pos</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">memVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpVarDef</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
		<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">addr</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

		<span class="c1">// 在栈上预留记录 _defer 的各个字段的空间
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT32</span><span class="p">],</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">newValue1I</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpOffPtr</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT32</span><span class="p">].</span><span class="nf">PtrTo</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">FieldOff</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">addr</span><span class="p">),</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">constInt32</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT32</span><span class="p">],</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">stksize</span><span class="p">)))</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">closure</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">newValue1I</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpOffPtr</span><span class="p">,</span> <span class="nx">closure</span><span class="p">.</span><span class="nx">Type</span><span class="p">.</span><span class="nf">PtrTo</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">FieldOff</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="nx">addr</span><span class="p">),</span>
			<span class="nx">closure</span><span class="p">)</span>

		<span class="c1">// 记录参与 defer 调用的函数参数
</span><span class="c1"></span>		<span class="nx">ft</span> <span class="o">:=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">Type</span>
		<span class="nx">off</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">FieldOff</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
		<span class="nx">args</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Rlist</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span>

		<span class="c1">// 调用 deferprocStack，以 _defer 记录的指针作为参数传递
</span><span class="c1"></span>		<span class="nx">arg0</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constOffPtrSP</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINTPTR</span><span class="p">],</span> <span class="nx">Ctxt</span><span class="p">.</span><span class="nf">FixedFrameSize</span><span class="p">())</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINTPTR</span><span class="p">],</span> <span class="nx">arg0</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
		<span class="nx">call</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStaticCall</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">deferprocStack</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
		<span class="o">...</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

	<span class="c1">// 函数尾声与堆上分配的栈一样，调用 deferreturn
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDefer</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">exit</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可见，在编译阶段，一个 _defer 记录的空间已经在栈上得到保留，deferprocStack 的作用 就仅仅承担了运行时对该记录的初始化这一功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/panic.go
</span><span class="c1"></span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deferprocStack</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 注意，siz 和 fn 已经在编译阶段完成设置，这里只初始化了其他字段
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">=</span> <span class="kc">false</span>		<span class="c1">// 可见此时 defer 被标记为不在堆上分配
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
	<span class="o">...</span>
	<span class="c1">// 尽管在栈上进行分配，仍然需要将多个 _defer 记录通过链表进行串联，
</span><span class="c1"></span>	<span class="c1">// 以便在 deferreturn 中找到被延迟的函数的入口地址：
</span><span class="c1"></span>	<span class="c1">//   d.link = gp._defer
</span><span class="c1"></span>	<span class="c1">//   gp._defer = d
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">link</span><span class="p">))</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">))</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">))</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
	<span class="nf">return0</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至于函数尾声的行为，与在堆上进行分配的操作同样是调用 deferreturn，我们就不再重复说明了。 当然，里面涉及的 freedefer 调用由于不需要释放任何内存，也就早早返回了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/panic.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除了分配位置的不同，栈上分配和堆上分配的 runtime._defer 并没有本质的不同，而该方法可以适用于绝大多数的场景，与堆上分配的 runtime._defer 相比，该方法可以将 defer 关键字的额外开销降低 ~30%。</p>
<h2 id="开放编码">开放编码<a hidden class="anchor" aria-hidden="true" href="#开放编码">#</a></h2>
<p>defer 给我们的第一感觉其实是一个编译期特性。前面我们讨论了 为什么 defer 会需要运行时的支持，以及需要运行时的 defer 是如何工作的。现在我们来 探究一下什么情况下能够让 defer 进化为一个仅编译期特性，即在函数末尾直接对延迟函数进行调用， 做到几乎不需要额外的开销。这类几乎不需要额外运行时性能开销的 defer，正是开放编码式 defer。 这类 defer 与直接调用产生的性能差异有多大呢？我们不妨编写两个性能测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">call</span><span class="p">()</span>      <span class="p">{</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{}()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">callDefer</span><span class="p">()</span> <span class="p">{</span> <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{}()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">BenchmarkDefer</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">call</span><span class="p">()</span> <span class="c1">// 第二次运行时替换为 callDefer
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Go 1.14 版本下，读者可以获得类似下方的性能估计，其中使用 callDefer 后， 性能损耗大约为 1 ns。这种纳秒级的性能损耗不到一个 CPU 时钟周期， 我们已经可以认为开放编码式 defer 几乎没有了性能开销：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">name</span>      <span class="n">old</span> <span class="n">time</span><span class="o">/</span><span class="n">op</span>  <span class="n">new</span> <span class="n">time</span><span class="o">/</span><span class="n">op</span>  <span class="n">delta</span>
<span class="n">Defer</span><span class="m">-12</span>  <span class="m">1.24</span><span class="n">ns</span> ± <span class="m">1</span><span class="o">%  2.23ns ± 1%</span>  <span class="m">+80.06</span>%  <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="m">0.000</span> <span class="n">n</span><span class="o">=</span><span class="m">10+9</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们再来观察一下开放编码式 defer 最终被编译的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">gcflags</span> <span class="s">&#34;-l&#34;</span> <span class="o">-</span><span class="n">ldflags</span><span class="o">=-</span><span class="n">compressdwarf</span><span class="o">=</span><span class="n">false</span> <span class="o">-</span><span class="n">o</span> <span class="n">main.out</span> <span class="n">main.go</span>
<span class="n">go</span> <span class="n">tool</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">S</span> <span class="n">main.out</span> <span class="o">&gt;</span> <span class="n">main.s</span>
</code></pre></td></tr></table>
</div>
</div><p>对于如下形式的函数调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">func</span> <span class="nf">callDefer</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>整个调用最终编译结果既没有 deferproc 或者 deferprocStack，也没有了 deferreturn。 延迟语句被直接插入到了函数的末尾：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">TEXT</span> <span class="nf">main.callDefer</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">changkun</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">defer</span><span class="o">/</span><span class="n">main.go</span>
<span class="n">func</span> <span class="nf">callDefer</span><span class="p">()</span> <span class="p">{</span>
  <span class="kc">...</span>
	<span class="nf">mu.Lock</span><span class="p">()</span>
  <span class="mh">0x105794a</span>		<span class="m">488</span><span class="n">d05071f0a00</span>		<span class="n">LEAQ</span> <span class="nf">main.mu</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
  <span class="mh">0x1057951</span>		<span class="m">48890424</span>		<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="mh">0x1057955</span>		<span class="n">e8f6f8ffff</span>		<span class="n">CALL</span> <span class="nf">sync.</span><span class="p">(</span><span class="o">*</span><span class="n">Mutex</span><span class="p">)</span><span class="nf">.Lock</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
	<span class="n">defer</span> <span class="nf">mu.Unlock</span><span class="p">()</span>
  <span class="mh">0x105795a</span>		<span class="m">488</span><span class="n">d057f110200</span>		<span class="n">LEAQ</span> <span class="n">go.func.</span><span class="o">*</span><span class="m">+1064</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
  <span class="mh">0x1057961</span>		<span class="m">4889442418</span>		<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="mh">0x1057966</span>		<span class="m">488</span><span class="n">d05eb1e0a00</span>		<span class="n">LEAQ</span> <span class="nf">main.mu</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>
  <span class="mh">0x105796d</span>		<span class="m">4889442410</span>		<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
<span class="p">}</span>
  <span class="mh">0x1057972</span>		<span class="n">c644240f00</span>		<span class="n">MOVB</span> <span class="o">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="mh">0x1057977</span>		<span class="m">488</span><span class="n">b442410</span>		<span class="n">MOVQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
  <span class="mh">0x105797c</span>		<span class="m">48890424</span>		<span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="m">0</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
  <span class="mh">0x1057980</span>		<span class="n">e8ebfbffff</span>		<span class="n">CALL</span> <span class="nf">sync.</span><span class="p">(</span><span class="o">*</span><span class="n">Mutex</span><span class="p">)</span><span class="nf">.Unlock</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
  <span class="mh">0x1057985</span>		<span class="m">488</span><span class="n">b6c2420</span>		<span class="n">MOVQ</span> <span class="mh">0x20</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">BP</span>
  <span class="mh">0x105798a</span>		<span class="m">4883</span><span class="n">c428</span>		<span class="n">ADDQ</span> <span class="o">$</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">SP</span>
  <span class="mh">0x105798e</span>		<span class="n">c3</span>			<span class="n">RET</span>
  <span class="kc">...</span>
</code></pre></td></tr></table>
</div>
</div><p>那么开放编码式 defer 是怎么实现的？所有的 defer 都是开放编码式的吗？ 什么情况下，开放编码式 defer 会退化为一个依赖运行时的特性？</p>
<p>Go 语言在 1.14 中通过开放编码（Open Coded）实现 defer 关键字，该设计使用代码内联优化 defer 关键的额外开销并引入函数数据 funcdata 管理 panic 的调用，该优化可以将 defer 的调用开销从 1.13 版本的 ~35ns 降低至 ~6ns 左右：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">With</span> <span class="nf">normal </span><span class="p">(</span><span class="n">stack</span><span class="o">-</span><span class="n">allocated</span><span class="p">)</span> <span class="n">defers</span> <span class="n">only</span><span class="o">:</span>         <span class="m">35.4</span>  <span class="n">ns</span><span class="o">/</span><span class="n">op</span>
<span class="n">With</span> <span class="n">open</span><span class="o">-</span><span class="n">coded</span> <span class="n">defers</span><span class="o">:</span>                             <span class="m">5.6</span>  <span class="n">ns</span><span class="o">/</span><span class="n">op</span>
<span class="n">Cost</span> <span class="n">of</span> <span class="n">function</span> <span class="n">call</span> <span class="nf">alone </span><span class="p">(</span><span class="n">remove</span> <span class="n">defer</span> <span class="n">keyword</span><span class="p">)</span><span class="o">:</span> <span class="m">4.4</span>  <span class="n">ns</span><span class="o">/</span><span class="n">op</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="启动条件">启动条件<a hidden class="anchor" aria-hidden="true" href="#启动条件">#</a></h3>
<p>我们先来看开放编码式 defer 的启动条件。在 SSA 的构建阶段 buildssa，我们有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/cmd/compile/internal/gc/ssa.go
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">maxOpenDefers</span> <span class="p">=</span> <span class="mi">8</span>
<span class="kd">func</span> <span class="nf">walkstmt</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">ODEFER</span><span class="p">:</span>
		<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">SetHasDefer</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numDefers</span><span class="o">++</span>
		<span class="c1">// 超过 8 个 defer 时，禁用对 defer 进行开放编码
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numDefers</span> <span class="p">&gt;</span> <span class="nx">maxOpenDefers</span> <span class="p">{</span>
			<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">SetOpenCodedDeferDisallowed</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 存在循环语句中的 defer，禁用对 defer 进行开放编码。
</span><span class="c1"></span>		<span class="c1">// 是否有 defer 发生在循环语句内，会在 SSA 之前的逃逸分析中进行判断，
</span><span class="c1"></span>		<span class="c1">// 逃逸分析会检查是否存在循环（loopDepth）：
</span><span class="c1"></span>		<span class="c1">// if where.Op == ODEFER &amp;&amp; e.loopDepth == 1 {
</span><span class="c1"></span>		<span class="c1">// 	where.Esc = EscNever
</span><span class="c1"></span>		<span class="c1">// 	...
</span><span class="c1"></span>		<span class="c1">// }
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">!=</span> <span class="nx">EscNever</span> <span class="p">{</span>
			<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">SetOpenCodedDeferDisallowed</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">buildssa</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">worker</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Func</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="nx">state</span>
	<span class="o">...</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">hasdefer</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">HasDefer</span><span class="p">()</span>
	<span class="o">...</span>
	<span class="c1">// 可以对 defer 进行开放编码的条件
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">=</span> <span class="nx">Debug</span><span class="p">[</span><span class="sc">&#39;N&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasdefer</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">OpenCodedDeferDisallowed</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="o">&amp;&amp;</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numReturns</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numDefers</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，我们得到了允许进行 defer 的开放编码的主要条件 （此处略去了一些常见生产环境无关的条件，例如启用竞争检查时也不能对 defer 进行开放编码）：</p>
<ol>
<li>没有禁用编译器优化，即没有设置 <code>-gcflags &quot;-N&quot;</code></li>
<li>存在 defer 调用</li>
<li>函数内 defer 的数量不超过 8 个、且返回语句与延迟语句个数的乘积不超过 15</li>
<li>没有与 defer 发生在循环语句中</li>
</ol>
<h3 id="延迟比特">延迟比特<a hidden class="anchor" aria-hidden="true" href="#延迟比特">#</a></h3>
<p>当然，正常编写的 defer 可以直接被编译器分析得出，但是如本节开头提到的，如果一个 defer 发生在一个条件语句中，而这个条件必须等到运行时才能确定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">42</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;meaning-of-life&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那么如何才能使用最小的成本，让插入到函数末尾的延迟语句，在条件成立时候被正确执行呢？ 这便需要一种机制，能够记录存在延迟语句的条件分支是否被执行， 这种机制在 Go 中利用了延迟比特（defer bit）。这种做法非常巧妙，但原理却非常简单。</p>
<p>对于下面的代码而言：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="nf">f1</span><span class="p">(</span><span class="nx">a1</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">cond</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nf">f2</span><span class="p">(</span><span class="nx">a2</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>使用延迟比特的核心思想可以用下面的伪代码来概括。 在创建延迟调用的阶段，首先通过延迟比特的特定位置记录哪些带条件的 defer 被触发。 这个延迟比特是一个长度为 8 位的二进制码（也是硬件架构里最小、最通用的情况）， 以每一位是否被设置为 1，来判断延迟语句是否在运行时被设置，如果设置，则发生调用。 否则则不调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">deferBits</span> <span class="p">=</span> <span class="mi">0</span>           <span class="c1">// 初始值 00000000
</span><span class="c1"></span><span class="nx">deferBits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>     <span class="c1">// 遇到第一个 defer，设置为 00000001
</span><span class="c1"></span><span class="nx">_f1</span> <span class="p">=</span> <span class="nx">f1</span>
<span class="nx">_a1</span> <span class="p">=</span> <span class="nx">a1</span>
<span class="k">if</span> <span class="nx">cond</span> <span class="p">{</span>
	<span class="c1">// 如果第二个 defer 被设置，则设置为 00000011，否则依然为 00000001
</span><span class="c1"></span>	<span class="nx">deferBits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
	<span class="nx">_f2</span> <span class="p">=</span> <span class="nx">f2</span>
	<span class="nx">_a2</span> <span class="p">=</span> <span class="nx">a2</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在退出位置，再重新根据被标记的延迟比特，反向推导哪些位置的 defer 需要被触发，从而 执行延迟调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">exit</span><span class="p">:</span>
<span class="c1">// 按顺序倒序检查延迟比特。如果第二个 defer 被设置，则
</span><span class="c1">//   00000011 &amp; 00000010 == 00000010，即延迟比特不为零，应该调用 f2。
</span><span class="c1">// 如果第二个 defer 没有被设置，则
</span><span class="c1">//   00000001 &amp; 00000010 == 00000000，即延迟比特为零，不应该调用 f2。
</span><span class="c1"></span><span class="k">if</span> <span class="nx">deferBits</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 00000011 &amp; 00000010 != 0
</span><span class="c1"></span>	<span class="nx">deferBits</span> <span class="o">&amp;^=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span>       <span class="c1">// 00000001
</span><span class="c1"></span>	<span class="nf">_f2</span><span class="p">(</span><span class="nx">_a2</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 同理，由于 00000001 &amp; 00000001 == 00000001，因此延迟比特不为零，应该调用 f1
</span><span class="c1"></span><span class="k">if</span> <span class="nx">deferBits</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">deferBits</span> <span class="o">&amp;^=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span>
	<span class="nf">_f1</span><span class="p">(</span><span class="nx">_a1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在实际的实现中，可以看到，当可以设置开放编码式 defer 时，buildssa 会首先创建一个 长度位 8 位的临时变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/cmd/compile/internal/gc/ssa.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">buildssa</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">worker</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Func</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
		<span class="c1">// 创建 deferBits 临时变量
</span><span class="c1"></span>		<span class="nx">deferBitsTemp</span> <span class="o">:=</span> <span class="nf">tempAt</span><span class="p">(</span><span class="nx">src</span><span class="p">.</span><span class="nx">NoXPos</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">])</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsTemp</span> <span class="p">=</span> <span class="nx">deferBitsTemp</span>
		<span class="c1">// deferBits 被设计为 8 位二进制，因此可以被开放编码的 defer 数量不能超过 8 个
</span><span class="c1"></span>		<span class="c1">// 此处还将起始 deferBits 设置为零
</span><span class="c1"></span>		<span class="nx">startDeferBits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">entryNewValue0</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpConst8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">])</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">deferBitsVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">startDeferBits</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsAddr</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">addr</span><span class="p">(</span><span class="nx">deferBitsTemp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsAddr</span><span class="p">,</span> <span class="nx">startDeferBits</span><span class="p">)</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">stmtList</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">Nbody</span><span class="p">)</span> <span class="c1">// 调用 s.stmt
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>随后针对出现 defer 的语句，进行编码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/cmd/compile/internal/gc/ssa.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">stmt</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">ODEFER</span><span class="p">:</span>
		<span class="c1">// 开放编码式 defer
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">openDeferRecord</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
	<span class="k">case</span> <span class="o">...</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="c1">// 存储一个 defer 调用的相关信息，例如所在的语法树结点、被延迟的调用、参数等等
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">openDeferInfo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">n</span>           <span class="o">*</span><span class="nx">Node</span>
	<span class="nx">closure</span>     <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
	<span class="nx">closureNode</span> <span class="o">*</span><span class="nx">Node</span>
	<span class="o">...</span>
	<span class="nx">argVals</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
	<span class="nx">argNodes</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">openDeferRecord</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">args</span> <span class="p">[]</span><span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
	<span class="kd">var</span> <span class="nx">argNodes</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>

	<span class="c1">// 记录与 defer 相关的入口地址与参数信息
</span><span class="c1"></span>	<span class="nx">opendefer</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">openDeferInfo</span><span class="p">{</span><span class="nx">n</span><span class="p">:</span> <span class="nx">n</span><span class="p">}</span>
	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Left</span>
	<span class="c1">// 记录函数入口地址
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">OCALLFUNC</span> <span class="p">{</span>
		<span class="nx">closureVal</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">expr</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
		<span class="nx">closure</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">openDeferSave</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">closureVal</span><span class="p">)</span>
		<span class="nx">opendefer</span><span class="p">.</span><span class="nx">closureNode</span> <span class="p">=</span> <span class="nx">closure</span><span class="p">.</span><span class="nx">Aux</span><span class="p">.(</span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">ONAME</span> <span class="o">&amp;&amp;</span> <span class="nx">fn</span><span class="p">.</span><span class="nf">Class</span><span class="p">()</span> <span class="o">==</span> <span class="nx">PFUNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">opendefer</span><span class="p">.</span><span class="nx">closure</span> <span class="p">=</span> <span class="nx">closure</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="c1">// 记录需要立即求值的的参数
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">argn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Rlist</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">v</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
		<span class="k">if</span> <span class="nf">canSSAType</span><span class="p">(</span><span class="nx">argn</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">openDeferSave</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">argn</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">expr</span><span class="p">(</span><span class="nx">argn</span><span class="p">))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">v</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">openDeferSave</span><span class="p">(</span><span class="nx">argn</span><span class="p">,</span> <span class="nx">argn</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">args</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="nx">argNodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">argNodes</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Aux</span><span class="p">.(</span><span class="o">*</span><span class="nx">Node</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">opendefer</span><span class="p">.</span><span class="nx">argVals</span> <span class="p">=</span> <span class="nx">args</span>
	<span class="nx">opendefer</span><span class="p">.</span><span class="nx">argNodes</span> <span class="p">=</span> <span class="nx">argNodes</span>

	<span class="c1">// 每多出现一个 defer，len(defers) 会增加，进而
</span><span class="c1"></span>	<span class="c1">// 延迟比特 deferBits |= 1&lt;&lt;len(defers) 被设置在不同的位上
</span><span class="c1"></span>	<span class="nx">index</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">openDefers</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">openDefers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">openDefers</span><span class="p">,</span> <span class="nx">opendefer</span><span class="p">)</span>
	<span class="nx">bitvalue</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constInt8</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">index</span><span class="p">))</span>
	<span class="nx">newDeferBits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue2</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpOr8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nf">variable</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deferBitsVar</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">]),</span> <span class="nx">bitvalue</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">deferBitsVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newDeferBits</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsAddr</span><span class="p">,</span> <span class="nx">newDeferBits</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在函数返回退出前，state 的 exit 函数会依次倒序创建对延迟比特的检查代码， 从而顺序调用被延迟的函数调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/cmd/compile/internal/gc/ssa.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">exit</span><span class="p">()</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Block</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasdefer</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">openDeferExit</span><span class="p">()</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">openDeferExit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">deferExit</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nf">NewBlock</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockPlain</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">endBlock</span><span class="p">().</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">deferExit</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">deferExit</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">lastDeferExit</span> <span class="p">=</span> <span class="nx">deferExit</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">lastDeferCount</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">openDefers</span><span class="p">)</span>
	<span class="nx">zeroval</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constInt8</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 倒序检查 defer
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">openDefers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">openDefers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">bCond</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nf">NewBlock</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockPlain</span><span class="p">)</span>
		<span class="nx">bEnd</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nf">NewBlock</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockPlain</span><span class="p">)</span>

		<span class="c1">// 检查 deferBits
</span><span class="c1"></span>		<span class="nx">deferBits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">variable</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deferBitsVar</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">])</span>
		<span class="c1">// 创建 if deferBits &amp; 1 &lt;&lt; len(defer) != 0 { ... }
</span><span class="c1"></span>		<span class="nx">bitval</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constInt8</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
		<span class="nx">andval</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue2</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpAnd8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">deferBits</span><span class="p">,</span> <span class="nx">bitval</span><span class="p">)</span>
		<span class="nx">eqVal</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue2</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpEq8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TBOOL</span><span class="p">],</span> <span class="nx">andval</span><span class="p">,</span> <span class="nx">zeroval</span><span class="p">)</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">endBlock</span><span class="p">()</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">Kind</span> <span class="p">=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nx">BlockIf</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">SetControl</span><span class="p">(</span><span class="nx">eqVal</span><span class="p">)</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">bEnd</span><span class="p">)</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">bCond</span><span class="p">)</span>
		<span class="nx">bCond</span><span class="p">.</span><span class="nf">AddEdgeTo</span><span class="p">(</span><span class="nx">bEnd</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">bCond</span><span class="p">)</span>

		<span class="c1">// 如果创建的条件分支被触发，则清空当前的延迟比特: deferBits &amp;^= 1 &lt;&lt; len(defers)
</span><span class="c1"></span>		<span class="nx">nbitval</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpCom8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">bitval</span><span class="p">)</span>
		<span class="nx">maskedval</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue2</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpAnd8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">deferBits</span><span class="p">,</span> <span class="nx">nbitval</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsAddr</span><span class="p">,</span> <span class="nx">maskedval</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">deferBitsVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">maskedval</span>

		<span class="c1">// 处理被延迟的函数调用，取出保存的入口地址、参数信息
</span><span class="c1"></span>		<span class="nx">argStart</span> <span class="o">:=</span> <span class="nx">Ctxt</span><span class="p">.</span><span class="nf">FixedFrameSize</span><span class="p">()</span>
		<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span>
		<span class="nx">stksize</span> <span class="o">:=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">Type</span><span class="p">.</span><span class="nf">ArgWidth</span><span class="p">()</span>
		<span class="o">...</span>
		<span class="k">for</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">argAddrVal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">argVals</span> <span class="p">{</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="nf">getParam</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">n</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
			<span class="nx">pt</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewPtr</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>
			<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constOffPtrSP</span><span class="p">(</span><span class="nx">pt</span><span class="p">,</span> <span class="nx">argStart</span><span class="o">+</span><span class="nx">f</span><span class="p">.</span><span class="nx">Offset</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">!</span><span class="nf">canSSAType</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">move</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">argAddrVal</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">argVal</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">argAddrVal</span><span class="p">)</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">storeType</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">argVal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 调用
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">call</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
		<span class="o">...</span>
		<span class="nx">call</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStaticCall</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">Sym</span><span class="p">.</span><span class="nf">Linksym</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
		<span class="nx">call</span><span class="p">.</span><span class="nx">AuxInt</span> <span class="p">=</span> <span class="nx">stksize</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">memVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">call</span>
		<span class="o">...</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">endBlock</span><span class="p">()</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">startBlock</span><span class="p">(</span><span class="nx">bEnd</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很多 defer 语句都可以在编译期间判断是否被执行，如果函数中的 defer 语句都会在编译期间确定，中间代码生成阶段就会直接调用 cmd/compile/internal/gc.state.openDeferExit 在函数返回前生成判断 deferBits 的代码。</p>
<p>不过当程序遇到运行时才能判断的条件语句时，我们仍然需要由运行时的 runtime.deferreturn 决定是否执行 defer 关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
		<span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
		<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数为开放编码做了特殊的优化，运行时会调用 runtime.runOpenDeferFrame 执行活跃的开放编码延迟函数，该函数会执行以下的工作：</p>
<ol>
<li>从 runtime._defer 结构体中读取 deferBits、函数 defer 数量等信息；</li>
<li>在循环中依次读取函数的地址和参数信息并通过 deferBits 判断该函数是否需要被执行；</li>
<li>调用 runtime.reflectcallSave 调用需要执行的 defer 函数；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">fd</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fd</span>

	<span class="o">...</span>
	<span class="nx">deferBitsOffset</span><span class="p">,</span> <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
	<span class="nx">nDefers</span><span class="p">,</span> <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
	<span class="nx">deferBits</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">deferBitsOffset</span><span class="p">)))</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nDefers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">argWidth</span><span class="p">,</span> <span class="nx">closureOffset</span><span class="p">,</span> <span class="nx">nArgs</span> <span class="kt">uint32</span> <span class="c1">// 读取函数的地址和参数信息
</span><span class="c1"></span>		<span class="nx">argWidth</span><span class="p">,</span> <span class="nx">fd</span> <span class="p">=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
		<span class="nx">closureOffset</span><span class="p">,</span> <span class="nx">fd</span> <span class="p">=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
		<span class="nx">nArgs</span><span class="p">,</span> <span class="nx">fd</span> <span class="p">=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">deferBits</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">closure</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">funcval</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">closureOffset</span><span class="p">)))</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">closure</span>

		<span class="o">...</span>

		<span class="nx">deferBits</span> <span class="p">=</span> <span class="nx">deferBits</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">deferBitsOffset</span><span class="p">)))</span> <span class="p">=</span> <span class="nx">deferBits</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span>
		<span class="nf">reflectcallSave</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">closure</span><span class="p">),</span> <span class="nx">deferArgs</span><span class="p">,</span> <span class="nx">argWidth</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">deferArgs</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">argWidth</span><span class="p">))</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">done</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从整个过程中我们可以看到，开放编码式 defer 并不是绝对的零成本，尽管编译器能够做到将 延迟调用直接插入返回语句之前，但出于语义的考虑，需要在栈上对参与延迟调用的参数进行一次求值； 同时出于条件语句中可能存在的 defer，还额外需要通过延迟比特来记录一个延迟语句是否在运行时 被设置。 因此，开放编码式 defer 的成本体现在非常少量的指令和位运算来配合在运行时判断 是否存在需要被延迟调用的 defer。</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>我们在本节前面提到的两个现象在这里也可以解释清楚了：</p>
<ul>
<li>后调用的 defer 函数会先执行：
<ul>
<li>后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面；</li>
<li>运行 runtime._defer 时是从前到后依次执行；</li>
</ul>
</li>
<li>函数的参数会被预先计算；
<ul>
<li>调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li>
</ul>
</li>
</ul>
<p>我们最后来总结一下 defer 的基本工作原理以及三种 defer 的性能取舍</p>
<ul>
<li>对于开放编码式 defer 而言(1.14)：
<ul>
<li>编译器会直接将所需的参数进行存储，并在返回语句的末尾插入被延迟的调用；</li>
<li>通过 deferBits 和 cmd/compile/internal/gc.openDeferInfo 存储 defer 关键字的相关信息；</li>
<li>编译期间判断 defer 关键字、return 语句的个数确定是否开启开放编码优化；当整个调用中逻辑上会执行的 defer 不超过 15 个（例如七个 defer 作用在两个返回语句）、总 defer 数量不超过 8 个、且没有出现在循环语句中时，会激活使用此类 defer；</li>
<li>如果 defer 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的 runtime.deferreturn 处理；</li>
<li>此类 defer 的唯一的运行时成本就是存储参与延迟调用的相关信息，运行时性能最好。</li>
</ul>
</li>
<li>对于栈上分配的 defer 而言(1.13)：
<ul>
<li>当该关键字在函数体中最多执行一次时，编译期间的 cmd/compile/internal/gc.state.call 会将结构体分配到栈上并调用 runtime.deferprocStack；</li>
<li>编译器会直接在栈上记录一个 _defer 记录，该记录不涉及内存分配，并将其作为参数，传入被翻译为 deferprocStack 的延迟语句，在延迟调用的位置将_defer 压入 Goroutine 对应的延迟调用链表中；</li>
<li>在函数末尾处，通过编译器的配合，在调用被 defer 的函数前，调用 deferreturn，将被延迟的调用出栈并执行；</li>
<li>此类 defer 的唯一运行时成本是从 _defer 记录中将参数复制出，以及从延迟调用记录链表出栈的成本，运行时性能其次。</li>
</ul>
</li>
<li>对于堆上分配的 defer 而言：
<ul>
<li>编译期将 defer 关键字转换成 runtime.deferproc 并在调用 defer 关键字的函数返回之前插入 runtime.deferreturn；</li>
<li>运行时调用 runtime.deferproc 会将一个新的 runtime._defer 结构体追加到当前 Goroutine 的链表头；编译器首先会将延迟语句翻译为一个 deferproc 调用，进而从运行时分配一个用于记录被延迟调用的_defer 记录，并将被延迟的调用的入口地址及其参数复制保存，入栈到 Goroutine 对应的延迟调用链表中；</li>
<li>运行时调用 runtime.deferreturn 会从 Goroutine 的链表中取出 runtime._defer 结构并依次执行；在函数末尾处，通过编译器的配合，在调用被 defer 的函数前，调用 deferreturn，从而将_defer 实例归还到资源池，而后通过模拟尾递归的方式来对需要 defer 的函数进行调用。</li>
<li>此类 defer 的主要性能问题存在于每个 defer 语句产生记录时的内存分配，记录参数和完成调用时的参数移动时的系统调用，运行时性能最差。</li>
</ul>
</li>
</ul>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#533-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6">5.3 defer</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch09lang/defer/#heading2">9.2 延迟语句</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
