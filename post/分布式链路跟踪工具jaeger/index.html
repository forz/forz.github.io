<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>分布式链路跟踪工具:Jaeger | Forz Blog</title>
<meta name="keywords" content="Jaeger" />
<meta name="description" content="架构 如上图所示，Jaeger 主要由以下几部分组成。 Agent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="分布式链路跟踪工具:Jaeger" />
<meta property="og:description" content="架构 如上图所示，Jaeger 主要由以下几部分组成。 Agent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-08-19T15:30:54&#43;00:00" />
<meta property="article:modified_time" content="2020-08-19T15:30:54&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="分布式链路跟踪工具:Jaeger"/>
<meta name="twitter:description" content="架构 如上图所示，Jaeger 主要由以下几部分组成。 Agent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "分布式链路跟踪工具:Jaeger",
      "item": "/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式链路跟踪工具:Jaeger",
  "name": "分布式链路跟踪工具:Jaeger",
  "description": "架构 如上图所示，Jaeger 主要由以下几部分组成。 Agent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护",
  "keywords": [
    "Jaeger"
  ],
  "articleBody": "架构 如上图所示，Jaeger 主要由以下几部分组成。\nAgent（客户端代理） jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护进程。 如同大多数分布式系统都拥有一个Agent一样，Jaeger的Agent有以下几类特点：\nagent收集并汇聚这些span信息到collector；\nagent的被设计成一个基础组件，旨在作为基础架构组件部署到所有宿主机；\nagent将client library 和 collector 解耦，为 client library 屏蔽了路由和发现 collector 的细节；\nCollector（数据收集处理） collector，顾名思义，从agent收集traces信息，并通过处理管道处理他们，再写入后端存储（backends）。\n当前的collector工作主要是管理trace，建立索引，执行相关转换，并最终存储它们。\nCollector中运行着sampling逻辑，根据我们设定的sampling方式对数据进行收集和处理。\nData Store（数据存储） jaeger的data store是组件的方式。\n当前可以支持 Cassandra和ElasticSearch（当然也支持纯内存方式，但是不适用于生产环境）.\nQuery \u0026 UI（数据查询与前端界面展示） Query查询是一种从存储中检索trace，并提供UI以显示它们的服务。上图中就展示了一次Trace的数据流向，作为一次系统作用的数据传播/执行图，即可以在Jaeger UI上展示出来。\n部署 Jaeger的部署由于方案的不同，会依赖不同的服务，这些第三方基础服务的部署安装不再该文范围内，如docker、Elasticsearch、Cassandra等\nAll in one 为了方便大家快速使用，Jaeger直接提供一个All in one的docker镜像，通过All in one的image，我们可以通过以下命令直接启动一套完整的Jaeger tracing系统：\n1 2 3 4 5 6 7 8 9 10  $ docker run -d -e \\ COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 9411:9411 \\ jaegertracing/all-in-one:latest   一旦启动成功后，就可以去http://localhost:16686看到Jaeger UI了，如下所示。\n注：在All in one模式下，Data Store使用的是内存，因此若重启dockre容器后就看不到之前的数据了。所以，该模式仅可用于前期demo或者验证，不可在生产环境中这样部署。\n独立部署 当然我们更推荐的方式是独立部署，独立部署也可以分为docker镜像方式和binary 方式，官网有详细的docker镜像方式启动命令介绍，在这儿就不再粘贴复制了。\n关于binary方式部署，可以参看github上的Jaeger的二进制包。地址提供了mac、linux和windows的三大操作系统的binary包。以linux为例，解压后我们可以发现有以下几个bin包，分别清晰地对应了我们之前说的几个模块：\n1 2 3 4 5  drwxrwxr-x 3 2000 2000 4.0K May 28 23:29 jaeger-ui-build -rwxrwxr-x 1 2000 2000 27M May 28 23:29 jaeger-standalone -rwxrwxr-x 1 2000 2000 22M May 28 23:29 jaeger-query -rwxrwxr-x 1 2000 2000 25M May 28 23:29 jaeger-collector -rwxrwxr-x 1 2000 2000 16M May 28 23:29 jaeger-agent   注：Jaeger同时也提供可Kubernetes and OpenShift的模板。可参考github地址有详细介绍\n端口说明 通过上述All in one启动方式，我们直接发现了Jaeger启动时占据了很多端口，当然，并不是所有的端口都是必需的，这儿简单列出这些端口的说明如下：\n   端口 协议 所属模块 功能     5775 UDP agent 通过兼容性Thrift协议，接收Zipkin thrift类型数据   6831 UDP agent 通过兼容性Thrift协议，接收Jaeger thrift类型数据   6832 UDP agent 通过二进制Thrift协议，接收Jaeger thrift类型数据   5778 HTTP agent 配置控制服务接口   16686 HTTP query 客户端前端界面展示端口   14268 HTTP collector 接收客户端Zipkin thrift类型数据   14267 HTTP collector 接收客户端Jaeger thrift类型数据   9411 HTTP collector Zipkin兼容endpoint    采样率 支持设置采样率是 Jaeger 的一个亮点，在生产环境中，如果对每个请求都开启 Trace，必然会对系统性能带来一定压力，除此之外，数量庞大的 Span 也会占用大量的存储空间。为了尽量消除分布式追踪采样对系统带来的影响，设置采样率是一个很好的办法。Jaeger 支持四种采样类别，分别是 const、probabilistic、rateLimiting 和 remote。const 意为常量，采样率的可设置的值为 0 和 1，分别表示关闭采样和全部采样。probabilistic 是按照概率采样，取值可在 0 至 1 之间，例如设置为 0.5 的话意为只对 50% 的请求采样。rateLimiting 则是设置每秒的采样次数上限。remote 是遵循远程设置，取值的含义和 probabilistic 相同，都意为采样的概率，只不过设置为 remote 后，Client 会从 Jaeger Agent 中动态获取采样率设置。\n关于Jaeger系统中的采样方式，我们可以通过一个例子来解释。\n假设有三个服务A，B，C，且存在一个简单的调用方式：A-B-C, 当服务A收到请求时，Jaeger检查该请求有没有trace信息，如果没有，将为其生成新的trace（TraceId为随机生成的），并基于当前的取样策略进行sampling。该取样策略会随着请求一路广播到服务B和C，因此这些服务将必须再做采样的策略选择。这种采样方式确保了当一个trace被采用后，它的所有后续spans都会被存储起来（若每层服务都再做一次采样策略选择的话，我们就会很难获取到完整的一个trace了）。\nJaeger使用 当我们正是使用jager后，可以通过两种方式来进行查看：\n根据TraceId搜索 通过Web UI左上方，可以直接键入TraceId进行某次trace的搜索\n根据服务节点查看 通过Web UI左边栏Find Traces，可以详细地进行高级搜索功能，支持服务名，操作，Tag信息（Jaeger中的tag功能，可以在context中加入tag，进行更过的标识）等。当我们确定搜索条件后，就可以查出符合条件的trace信息了，下图为我们一个腾讯云cos代理业务程序的简单请求示例：\nGo-SDK config设定\n1 2 3 4 5 6 7 8 9  cfg := \u0026config.Configuration{ Sampler: \u0026config.SamplerConfig{ Type: samplerType, Param: samplerParam, }, Reporter: \u0026config.ReporterConfig{ LogSpans: true, }, }   其中关于SamplerConfig的Type可以选择\n const，全量采集。param采样率设置0,1 分别对应打开和关闭 probabilistic ，概率采集。param默认万份之一，0~1之间取值， rateLimiting ，限速采集。param每秒采样的个数 remote 动态采集策略。param值于probabilistic的参数一样。在收到实际值之前的初始采样率。改值可以通过环境变量的JAEGER_SAMPLER_PARAM设定  生成jaeger tracer\n1  func (c Configuration) NewTracer(options ...Option) (opentracing.Tracer, io.Closer, error)   设置为全局的单例tracer\n1  func SetGlobalTracer(tracer Tracer)   生成开始一个Span\n1  StartSpan(operationName string, opts ...StartSpanOption) Span   返回span的SpanContext的reference\n1  func ContextWithSpan(ctx context.Context, span Span) context.Context   生成子Span\n1  func StartSpanFromContext(ctx context.Context, operationName string, opts ...StartSpanOption) (Span, context.Context)   记录关于Span相关的key：value数据\n1  LogFields(fields ...log.Field)   到此如果只需要追踪在同一process的链路就已经可以了。如果希望能够追踪不同进程中的链路例如，客户端通过http请求服务端，服务端回应整个链路的追踪需要用到以下的处理。\n使用Inject和Extract通过RPC calls传递span context\nClient端\n添加import\n1 2 3  import ( \"github.com/opentracing/opentracing-go/ext\" )   添加Inject\n1 2 3 4 5 6 7 8  ext.SpanKindRPCClient.Set(reqSpan) ext.HTTPUrl.Set(reqSpan, reqURL) ext.HTTPMethod.Set(reqSpan, \"GET\") span.Tracer().Inject( span.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header), )   Server端\n添加import\n1 2 3 4 5 6  import ( opentracing \"github.com/opentracing/opentracing-go\" \"github.com/opentracing/opentracing-go/ext\" otlog \"github.com/opentracing/opentracing-go/log\" \"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing\" )   从request抽取出span context\n1  spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))   通过引用从Client端传来的span context生成新的child span\n1 2  span := tracer.StartSpan(\"format\", ext.RPCServerOption(spanCtx)) defer span.Finish()   HTTP Middleware 对于每个 HTTP 请求，可以在 HTTP Server 中增加 Middleware，为每个请求都记录一个 Span，并且在生成 Trace ID 后，将其作为 Request ID 使用。\n代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  package middleware import ( \"context\" \"net/http\" \"github.com/opentracing/opentracing-go\" \"github.com/opentracing/opentracing-go/ext\" \"github.com/jaegertracing/jaeger-client-go\" \"github.com/pengsrc/go-shared/buffer\" \"example/constants\" ) // TraceSpan is a middleware that initialize a tracing span and injects span // context to r.Context(). In one word, this middleware kept an eye on the // whole HTTP request that the server receives. func TraceSpan(next http.Handler) http.Handler { fn := func(w http.ResponseWriter, r *http.Request) { tracer := opentracing.GlobalTracer() if tracer == nil { // Tracer not found, just skip.  next.ServeHTTP(w, r) } buf := buffer.GlobalBytesPool().Get() buf.AppendString(\"HTTP \") buf.AppendString(r.Method) // Start span.  span := opentracing.StartSpan(buf.String()) rc := opentracing.ContextWithSpan(r.Context(), span) // Set request ID for context.  if sc, ok := span.Context().(jaeger.SpanContext); ok { rc = context.WithValue(rc, constants.RequestID, sc.TraceID().String()) } next.ServeHTTP(w, r.WithContext(rc)) // Finish span.  wrapper, ok := w.(WrapResponseWriter) if ok { ext.HTTPStatusCode.Set(span, uint16(wrapper.Status())) } span.Finish() } return http.HandlerFunc(fn) }   gRPC UnaryServerInterceptor 对于每个 gRPC 请求，也可以增加一个 UnaryServerInterceptor，为每个请求都记录一个 Span，这里用到了 gRPC 的 metadata 来传递 Trace ID 等信息。同样，这里生成 Trace ID 后，也将其作为 Request ID 使用。\n代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144  package rpc import ( \"context\" \"encoding/base64\" \"fmt\" \"strings\" \"github.com/opentracing/opentracing-go\" \"github.com/opentracing/opentracing-go/ext\" \"github.com/jaegertracing/jaeger-client-go\" \"github.com/pengsrc/go-shared/buffer\" \"google.golang.org/grpc\" \"google.golang.org/grpc/metadata\" \"example/constants\" ) // TraceSpanClientInterceptor returns a grpc.UnaryServerInterceptor suitable // for use in a grpc.Dial() call. // // For example: // // conn, err := grpc.Dial( // address, // ..., // (existing DialOptions) // grpc.WithUnaryInterceptor(rpc.TraceSpanClientInterceptor()), // ) // // It writes current trace span to request metadata. func TraceSpanClientInterceptor() grpc.UnaryClientInterceptor { return func( ctx context.Context, method string, req, resp interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption, ) (err error) { span, ctx := opentracing.StartSpanFromContext(ctx, \"RPC Client \"+method) defer span.Finish() // Save current span context.  md, ok := metadata.FromOutgoingContext(ctx) if !ok { md = metadata.Pairs() } if err = opentracing.GlobalTracer().Inject( span.Context(), opentracing.HTTPHeaders, metadataTextMap(md), ); err != nil { log.Errorf(ctx, \"Failed to inject trace span: %v\", err) } return invoker(metadata.NewOutgoingContext(ctx, md), method, req, resp, cc, opts...) } } // TraceSpanServerInterceptor returns a grpc.UnaryServerInterceptor suitable // for use in a grpc.NewServer call. // // For example: // // s := grpc.NewServer( // ..., // (existing ServerOptions) // grpc.UnaryInterceptor(rpc.TraceSpanServerInterceptor()), // ) // // It reads current trace span from request metadata. func TraceSpanServerInterceptor() grpc.UnaryServerInterceptor { return func( ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler, ) (resp interface{}, err error) { // Extract parent trace span.  md, ok := metadata.FromIncomingContext(ctx) if !ok { md = metadata.Pairs() } parentSpanContext, err := opentracing.GlobalTracer().Extract( opentracing.HTTPHeaders, metadataTextMap(md), ) switch err { case nil: case opentracing.ErrSpanContextNotFound: log.Info(ctx, \"Parent span not found, will start new one.\") default: log.Errorf(ctx, \"Failed to extract trace span: %v\", err) } // Start new trace span.  span := opentracing.StartSpan( \"RPC Server \"+info.FullMethod, ext.RPCServerOption(parentSpanContext), ) defer span.Finish() ctx = opentracing.ContextWithSpan(ctx, span) // Set request ID for context.  if sc, ok := span.Context().(jaeger.SpanContext); ok { ctx = context.WithValue(ctx, constants.RequestID, sc.TraceID().String()) } return handler(ctx, req) } } const ( binHeaderSuffix = \"_bin\" ) // metadataTextMap extends a metadata.MD to be an opentracing textmap type metadataTextMap metadata.MD // Set is a opentracing.TextMapReader interface that extracts values. func (m metadataTextMap) Set(key, val string) { // gRPC allows for complex binary values to be written.  encodedKey, encodedVal := encodeKeyValue(key, val) // The metadata object is a multimap, and previous values may exist, but for opentracing headers, we do not append  // we just override.  m[encodedKey] = []string{encodedVal} } // ForeachKey is a opentracing.TextMapReader interface that extracts values. func (m metadataTextMap) ForeachKey(callback func(key, val string) error) error { for k, vv := range m { for _, v := range vv { if decodedKey, decodedVal, err := metadata.DecodeKeyValue(k, v); err == nil { if err = callback(decodedKey, decodedVal); err != nil { return err } } else { return fmt.Errorf(\"failed decoding opentracing from gRPC metadata: %v\", err) } } } return nil } // encodeKeyValue encodes key and value qualified for transmission via gRPC. // note: copy pasted from private values of grpc.metadata func encodeKeyValue(k, v string) (string, string) { k = strings.ToLower(k) if strings.HasSuffix(k, binHeaderSuffix) { val := base64.StdEncoding.EncodeToString([]byte(v)) v = string(val) } return k, v }   参考:\nJaeger-分布式调用链跟踪系统理论与实战 Jaeger 教程\n",
  "wordCount" : "4024",
  "inLanguage": "zh-cn",
  "datePublished": "2020-08-19T15:30:54Z",
  "dateModified": "2020-08-19T15:30:54Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7jaeger/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      分布式链路跟踪工具:Jaeger
    </h1>
    <div class="post-meta">August 19, 2020
</div>
  </header> 
  <div class="post-content"><h2 id="架构">架构<a hidden class="anchor" aria-hidden="true" href="#架构">#</a></h2>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200819160146.png" alt=""  />
</p>
<p>如上图所示，Jaeger 主要由以下几部分组成。</p>
<h3 id="agent客户端代理">Agent（客户端代理）<a hidden class="anchor" aria-hidden="true" href="#agent客户端代理">#</a></h3>
<p>jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护进程。 如同大多数分布式系统都拥有一个Agent一样，Jaeger的Agent有以下几类特点：</p>
<p>agent收集并汇聚这些span信息到collector；</p>
<p>agent的被设计成一个基础组件，旨在作为基础架构组件部署到所有宿主机；</p>
<p>agent将client library 和 collector 解耦，为 client library 屏蔽了路由和发现 collector 的细节；</p>
<h3 id="collector数据收集处理">Collector（数据收集处理）<a hidden class="anchor" aria-hidden="true" href="#collector数据收集处理">#</a></h3>
<p>collector，顾名思义，从agent收集traces信息，并通过处理管道处理他们，再写入后端存储（backends）。</p>
<p>当前的collector工作主要是管理trace，建立索引，执行相关转换，并最终存储它们。</p>
<p>Collector中运行着sampling逻辑，根据我们设定的sampling方式对数据进行收集和处理。</p>
<h3 id="data-store数据存储">Data Store（数据存储）<a hidden class="anchor" aria-hidden="true" href="#data-store数据存储">#</a></h3>
<p>jaeger的data store是组件的方式。</p>
<p>当前可以支持 Cassandra和ElasticSearch（当然也支持纯内存方式，但是不适用于生产环境）.</p>
<h3 id="query--ui数据查询与前端界面展示">Query &amp; UI（数据查询与前端界面展示）<a hidden class="anchor" aria-hidden="true" href="#query--ui数据查询与前端界面展示">#</a></h3>
<p>Query查询是一种从存储中检索trace，并提供UI以显示它们的服务。上图中就展示了一次Trace的数据流向，作为一次系统作用的数据传播/执行图，即可以在Jaeger UI上展示出来。</p>
<h2 id="部署">部署<a hidden class="anchor" aria-hidden="true" href="#部署">#</a></h2>
<p>Jaeger的部署由于方案的不同，会依赖不同的服务，这些第三方基础服务的部署安装不再该文范围内，如docker、Elasticsearch、Cassandra等</p>
<h3 id="all-in-one">All in one<a hidden class="anchor" aria-hidden="true" href="#all-in-one">#</a></h3>
<p>为了方便大家快速使用，Jaeger直接提供一个All in one的docker镜像，通过All in one的image，我们可以通过以下命令直接启动一套完整的Jaeger tracing系统：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">e</span> <span class="n">\</span>
  <span class="n">COLLECTOR_ZIPKIN_HTTP_PORT</span><span class="o">=</span><span class="m">9411</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">5775</span><span class="o">:</span><span class="m">5775</span><span class="o">/</span><span class="n">udp</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">6831</span><span class="o">:</span><span class="m">6831</span><span class="o">/</span><span class="n">udp</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">6832</span><span class="o">:</span><span class="m">6832</span><span class="o">/</span><span class="n">udp</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">5778</span><span class="o">:</span><span class="m">5778</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">16686</span><span class="o">:</span><span class="m">16686</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">14268</span><span class="o">:</span><span class="m">14268</span> <span class="n">\</span>
  <span class="o">-</span><span class="n">p</span> <span class="m">9411</span><span class="o">:</span><span class="m">9411</span> <span class="n">\</span>
  <span class="n">jaegertracing</span><span class="o">/</span><span class="n">all</span><span class="o">-</span><span class="n">in</span><span class="o">-</span><span class="n">one</span><span class="o">:</span><span class="n">latest</span>
</code></pre></td></tr></table>
</div>
</div><p>一旦启动成功后，就可以去<code>http://localhost:16686</code>看到Jaeger UI了，如下所示。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200819175032.png" alt=""  />
</p>
<p>注：在All in one模式下，Data Store使用的是内存，因此若重启dockre容器后就看不到之前的数据了。所以，该模式仅可用于前期demo或者验证，不可在生产环境中这样部署。</p>
<h3 id="独立部署">独立部署<a hidden class="anchor" aria-hidden="true" href="#独立部署">#</a></h3>
<p>当然我们更推荐的方式是独立部署，独立部署也可以分为docker镜像方式和binary 方式，官网有详细的docker镜像方式启动命令介绍，在这儿就不再粘贴复制了。</p>
<p>关于binary方式部署，可以参看github上的Jaeger的二进制包。地址提供了mac、linux和windows的三大操作系统的binary包。以linux为例，解压后我们可以发现有以下几个bin包，分别清晰地对应了我们之前说的几个模块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">drwxrwxr</span><span class="o">-</span><span class="n">x</span> <span class="m">3</span> <span class="m">2000</span> <span class="m">2000</span> <span class="m">4.0</span><span class="n">K</span> <span class="n">May</span> <span class="m">28</span> <span class="m">23</span><span class="o">:</span><span class="m">29</span> <span class="n">jaeger</span><span class="o">-</span><span class="n">ui</span><span class="o">-</span><span class="n">build</span>
<span class="o">-</span><span class="n">rwxrwxr</span><span class="o">-</span><span class="n">x</span> <span class="m">1</span> <span class="m">2000</span> <span class="m">2000</span>  <span class="m">27</span><span class="n">M</span> <span class="n">May</span> <span class="m">28</span> <span class="m">23</span><span class="o">:</span><span class="m">29</span> <span class="n">jaeger</span><span class="o">-</span><span class="n">standalone</span>
<span class="o">-</span><span class="n">rwxrwxr</span><span class="o">-</span><span class="n">x</span> <span class="m">1</span> <span class="m">2000</span> <span class="m">2000</span>  <span class="m">22</span><span class="n">M</span> <span class="n">May</span> <span class="m">28</span> <span class="m">23</span><span class="o">:</span><span class="m">29</span> <span class="n">jaeger</span><span class="o">-</span><span class="n">query</span>
<span class="o">-</span><span class="n">rwxrwxr</span><span class="o">-</span><span class="n">x</span> <span class="m">1</span> <span class="m">2000</span> <span class="m">2000</span>  <span class="m">25</span><span class="n">M</span> <span class="n">May</span> <span class="m">28</span> <span class="m">23</span><span class="o">:</span><span class="m">29</span> <span class="n">jaeger</span><span class="o">-</span><span class="n">collector</span>
<span class="o">-</span><span class="n">rwxrwxr</span><span class="o">-</span><span class="n">x</span> <span class="m">1</span> <span class="m">2000</span> <span class="m">2000</span>  <span class="m">16</span><span class="n">M</span> <span class="n">May</span> <span class="m">28</span> <span class="m">23</span><span class="o">:</span><span class="m">29</span> <span class="n">jaeger</span><span class="o">-</span><span class="n">agent</span>
</code></pre></td></tr></table>
</div>
</div><p>注：Jaeger同时也提供可Kubernetes and OpenShift的模板。可参考github地址有详细介绍</p>
<h2 id="端口说明">端口说明<a hidden class="anchor" aria-hidden="true" href="#端口说明">#</a></h2>
<p>通过上述All in one启动方式，我们直接发现了Jaeger启动时占据了很多端口，当然，并不是所有的端口都是必需的，这儿简单列出这些端口的说明如下：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>协议</th>
<th>所属模块</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>5775</td>
<td>UDP</td>
<td>agent</td>
<td>通过兼容性Thrift协议，接收Zipkin thrift类型数据</td>
</tr>
<tr>
<td>6831</td>
<td>UDP</td>
<td>agent</td>
<td>通过兼容性Thrift协议，接收Jaeger thrift类型数据</td>
</tr>
<tr>
<td>6832</td>
<td>UDP</td>
<td>agent</td>
<td>通过二进制Thrift协议，接收Jaeger thrift类型数据</td>
</tr>
<tr>
<td>5778</td>
<td>HTTP</td>
<td>agent</td>
<td>配置控制服务接口</td>
</tr>
<tr>
<td>16686</td>
<td>HTTP</td>
<td>query</td>
<td>客户端前端界面展示端口</td>
</tr>
<tr>
<td>14268</td>
<td>HTTP</td>
<td>collector</td>
<td>接收客户端Zipkin thrift类型数据</td>
</tr>
<tr>
<td>14267</td>
<td>HTTP</td>
<td>collector</td>
<td>接收客户端Jaeger thrift类型数据</td>
</tr>
<tr>
<td>9411</td>
<td>HTTP</td>
<td>collector</td>
<td>Zipkin兼容endpoint</td>
</tr>
</tbody>
</table>
<h2 id="采样率">采样率<a hidden class="anchor" aria-hidden="true" href="#采样率">#</a></h2>
<p>支持设置采样率是 Jaeger 的一个亮点，在生产环境中，如果对每个请求都开启 Trace，必然会对系统性能带来一定压力，除此之外，数量庞大的 Span 也会占用大量的存储空间。为了尽量消除分布式追踪采样对系统带来的影响，设置采样率是一个很好的办法。Jaeger 支持四种采样类别，分别是 const、probabilistic、rateLimiting 和 remote。const 意为常量，采样率的可设置的值为 0 和 1，分别表示关闭采样和全部采样。probabilistic 是按照概率采样，取值可在 0 至 1 之间，例如设置为 0.5 的话意为只对 50% 的请求采样。rateLimiting 则是设置每秒的采样次数上限。remote 是遵循远程设置，取值的含义和 probabilistic 相同，都意为采样的概率，只不过设置为 remote 后，Client 会从 Jaeger Agent 中动态获取采样率设置。</p>
<p>关于Jaeger系统中的采样方式，我们可以通过一个例子来解释。</p>
<p>假设有三个服务A，B，C，且存在一个简单的调用方式：A-&gt;B-&gt;C, 当服务A收到请求时，Jaeger检查该请求有没有trace信息，如果没有，将为其生成新的trace（TraceId为随机生成的），并基于当前的取样策略进行sampling。该取样策略会随着请求一路广播到服务B和C，因此这些服务将必须再做采样的策略选择。这种采样方式确保了当一个trace被采用后，它的所有后续spans都会被存储起来（若每层服务都再做一次采样策略选择的话，我们就会很难获取到完整的一个trace了）。</p>
<h2 id="jaeger使用">Jaeger使用<a hidden class="anchor" aria-hidden="true" href="#jaeger使用">#</a></h2>
<p>当我们正是使用jager后，可以通过两种方式来进行查看：</p>
<h3 id="根据traceid搜索">根据TraceId搜索<a hidden class="anchor" aria-hidden="true" href="#根据traceid搜索">#</a></h3>
<p>通过Web UI左上方，可以直接键入TraceId进行某次trace的搜索</p>
<h3 id="根据服务节点查看">根据服务节点查看<a hidden class="anchor" aria-hidden="true" href="#根据服务节点查看">#</a></h3>
<p>通过Web UI左边栏Find Traces，可以详细地进行高级搜索功能，支持服务名，操作，Tag信息（Jaeger中的tag功能，可以在context中加入tag，进行更过的标识）等。当我们确定搜索条件后，就可以查出符合条件的trace信息了，下图为我们一个腾讯云cos代理业务程序的简单请求示例：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/mjhipa3ono.png" alt=""  />
</p>
<h2 id="go-sdk">Go-SDK<a hidden class="anchor" aria-hidden="true" href="#go-sdk">#</a></h2>
<p>config设定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">cfg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">.</span><span class="nx">Configuration</span><span class="p">{</span>
    <span class="nx">Sampler</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">.</span><span class="nx">SamplerConfig</span><span class="p">{</span>
        <span class="nx">Type</span><span class="p">:</span>  <span class="nx">samplerType</span><span class="p">,</span>
        <span class="nx">Param</span><span class="p">:</span> <span class="nx">samplerParam</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">Reporter</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">.</span><span class="nx">ReporterConfig</span><span class="p">{</span>
        <span class="nx">LogSpans</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中关于SamplerConfig的Type可以选择</p>
<ul>
<li>const，全量采集。param采样率设置0,1 分别对应打开和关闭</li>
<li>probabilistic ，概率采集。param默认万份之一，0~1之间取值，</li>
<li>rateLimiting ，限速采集。param每秒采样的个数</li>
<li>remote 动态采集策略。param值于probabilistic的参数一样。在收到实际值之前的初始采样率。改值可以通过环境变量的JAEGER_SAMPLER_PARAM设定</li>
</ul>
<p>生成jaeger tracer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Configuration</span><span class="p">)</span> <span class="nf">NewTracer</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">Tracer</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Closer</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>设置为全局的单例tracer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SetGlobalTracer</span><span class="p">(</span><span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>生成开始一个Span</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>返回span的SpanContext的reference</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">span</span> <span class="nx">Span</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
</code></pre></td></tr></table>
</div>
</div><p>生成子Span</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpanFromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Span</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>记录关于Span相关的key：value数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">LogFields</span><span class="p">(</span><span class="nx">fields</span> <span class="o">...</span><span class="nx">log</span><span class="p">.</span><span class="nx">Field</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>到此如果只需要追踪在同一process的链路就已经可以了。如果希望能够追踪不同进程中的链路例如，客户端通过http请求服务端，服务端回应整个链路的追踪需要用到以下的处理。</p>
<p>使用Inject和Extract通过RPC calls传递span context</p>
<p>Client端</p>
<p>添加import</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/opentracing/opentracing-go/ext&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>添加Inject</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ext</span><span class="p">.</span><span class="nx">SpanKindRPCClient</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">reqSpan</span><span class="p">)</span>
<span class="nx">ext</span><span class="p">.</span><span class="nx">HTTPUrl</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">reqSpan</span><span class="p">,</span> <span class="nx">reqURL</span><span class="p">)</span>
<span class="nx">ext</span><span class="p">.</span><span class="nx">HTTPMethod</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">reqSpan</span><span class="p">,</span> <span class="s">&#34;GET&#34;</span><span class="p">)</span>
<span class="nx">span</span><span class="p">.</span><span class="nf">Tracer</span><span class="p">().</span><span class="nf">Inject</span><span class="p">(</span>
    <span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span>
    <span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span>
    <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Server端</p>
<p>添加import</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="nx">opentracing</span> <span class="s">&#34;github.com/opentracing/opentracing-go&#34;</span>
    <span class="s">&#34;github.com/opentracing/opentracing-go/ext&#34;</span>
    <span class="nx">otlog</span> <span class="s">&#34;github.com/opentracing/opentracing-go/log&#34;</span>
    <span class="s">&#34;github.com/yurishkuro/opentracing-tutorial/go/lib/tracing&#34;</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>从request抽取出span context</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">spanCtx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>通过引用从Client端传来的span context生成新的child span</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;format&#34;</span><span class="p">,</span> <span class="nx">ext</span><span class="p">.</span><span class="nf">RPCServerOption</span><span class="p">(</span><span class="nx">spanCtx</span><span class="p">))</span>
<span class="k">defer</span> <span class="nx">span</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="http-middleware">HTTP Middleware<a hidden class="anchor" aria-hidden="true" href="#http-middleware">#</a></h2>
<p>对于每个 HTTP 请求，可以在 HTTP Server 中增加 Middleware，为每个请求都记录一个 Span，并且在生成 Trace ID 后，将其作为 Request ID 使用。</p>
<p>代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">middleware</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;context&#34;</span>
 <span class="s">&#34;net/http&#34;</span>

 <span class="s">&#34;github.com/opentracing/opentracing-go&#34;</span>
 <span class="s">&#34;github.com/opentracing/opentracing-go/ext&#34;</span>
 <span class="s">&#34;github.com/jaegertracing/jaeger-client-go&#34;</span>
 <span class="s">&#34;github.com/pengsrc/go-shared/buffer&#34;</span>

 <span class="s">&#34;example/constants&#34;</span>
<span class="p">)</span>

<span class="c1">// TraceSpan is a middleware that initialize a tracing span and injects span
</span><span class="c1">// context to r.Context(). In one word, this middleware kept an eye on the
</span><span class="c1">// whole HTTP request that the server receives.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TraceSpan</span><span class="p">(</span><span class="nx">next</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Handler</span> <span class="p">{</span>
 <span class="nx">fn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tracer</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">tracer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="c1">// Tracer not found, just skip.
</span><span class="c1"></span>   <span class="nx">next</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">buf</span> <span class="o">:=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">GlobalBytesPool</span><span class="p">().</span><span class="nf">Get</span><span class="p">()</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nf">AppendString</span><span class="p">(</span><span class="s">&#34;HTTP &#34;</span><span class="p">)</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nf">AppendString</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>

  <span class="c1">// Start span.
</span><span class="c1"></span>  <span class="nx">span</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
  <span class="nx">rc</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">span</span><span class="p">)</span>

  <span class="c1">// Set request ID for context.
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">sc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">().(</span><span class="nx">jaeger</span><span class="p">.</span><span class="nx">SpanContext</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
   <span class="nx">rc</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">rc</span><span class="p">,</span> <span class="nx">constants</span><span class="p">.</span><span class="nx">RequestID</span><span class="p">,</span> <span class="nx">sc</span><span class="p">.</span><span class="nf">TraceID</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="nx">next</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">rc</span><span class="p">))</span>

  <span class="c1">// Finish span.
</span><span class="c1"></span>  <span class="nx">wrapper</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">WrapResponseWriter</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
   <span class="nx">ext</span><span class="p">.</span><span class="nx">HTTPStatusCode</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">wrapper</span><span class="p">.</span><span class="nf">Status</span><span class="p">()))</span>
  <span class="p">}</span>
  <span class="nx">span</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">http</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="grpc-unaryserverinterceptor">gRPC UnaryServerInterceptor<a hidden class="anchor" aria-hidden="true" href="#grpc-unaryserverinterceptor">#</a></h2>
<p>对于每个 gRPC 请求，也可以增加一个 UnaryServerInterceptor，为每个请求都记录一个 Span，这里用到了 gRPC 的 metadata 来传递 Trace ID 等信息。同样，这里生成 Trace ID 后，也将其作为 Request ID 使用。</p>
<p>代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">rpc</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;context&#34;</span>
 <span class="s">&#34;encoding/base64&#34;</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;strings&#34;</span>

 <span class="s">&#34;github.com/opentracing/opentracing-go&#34;</span>
 <span class="s">&#34;github.com/opentracing/opentracing-go/ext&#34;</span>
 <span class="s">&#34;github.com/jaegertracing/jaeger-client-go&#34;</span>
 <span class="s">&#34;github.com/pengsrc/go-shared/buffer&#34;</span>
 <span class="s">&#34;google.golang.org/grpc&#34;</span>
 <span class="s">&#34;google.golang.org/grpc/metadata&#34;</span>

 <span class="s">&#34;example/constants&#34;</span>
<span class="p">)</span>

<span class="c1">// TraceSpanClientInterceptor returns a grpc.UnaryServerInterceptor suitable
</span><span class="c1">// for use in a grpc.Dial() call.
</span><span class="c1">//
</span><span class="c1">// For example:
</span><span class="c1">//
</span><span class="c1">//     conn, err := grpc.Dial(
</span><span class="c1">//         address,
</span><span class="c1">//         ...,  // (existing DialOptions)
</span><span class="c1">//         grpc.WithUnaryInterceptor(rpc.TraceSpanClientInterceptor()),
</span><span class="c1">//     )
</span><span class="c1">//
</span><span class="c1">// It writes current trace span to request metadata.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TraceSpanClientInterceptor</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryClientInterceptor</span> <span class="p">{</span>
 <span class="k">return</span> <span class="kd">func</span><span class="p">(</span>
  <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
  <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span>
  <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">,</span>
 <span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">span</span><span class="p">,</span> <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartSpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;RPC Client &#34;</span><span class="o">+</span><span class="nx">method</span><span class="p">)</span>
  <span class="k">defer</span> <span class="nx">span</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>

  <span class="c1">// Save current span context.
</span><span class="c1"></span>  <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromOutgoingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
   <span class="nx">md</span> <span class="p">=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">Pairs</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">().</span><span class="nf">Inject</span><span class="p">(</span>
   <span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nf">metadataTextMap</span><span class="p">(</span><span class="nx">md</span><span class="p">),</span>
  <span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;Failed to inject trace span: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">invoker</span><span class="p">(</span><span class="nx">metadata</span><span class="p">.</span><span class="nf">NewOutgoingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">md</span><span class="p">),</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// TraceSpanServerInterceptor returns a grpc.UnaryServerInterceptor suitable
</span><span class="c1">// for use in a grpc.NewServer call.
</span><span class="c1">//
</span><span class="c1">// For example:
</span><span class="c1">//
</span><span class="c1">//     s := grpc.NewServer(
</span><span class="c1">//         ...,  // (existing ServerOptions)
</span><span class="c1">//         grpc.UnaryInterceptor(rpc.TraceSpanServerInterceptor()),
</span><span class="c1">//     )
</span><span class="c1">//
</span><span class="c1">// It reads current trace span from request metadata.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TraceSpanServerInterceptor</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span> <span class="p">{</span>
 <span class="k">return</span> <span class="kd">func</span><span class="p">(</span>
  <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span>
  <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryHandler</span><span class="p">,</span>
 <span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Extract parent trace span.
</span><span class="c1"></span>  <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromIncomingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
   <span class="nx">md</span> <span class="p">=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">Pairs</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nx">parentSpanContext</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">GlobalTracer</span><span class="p">().</span><span class="nf">Extract</span><span class="p">(</span>
   <span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nf">metadataTextMap</span><span class="p">(</span><span class="nx">md</span><span class="p">),</span>
  <span class="p">)</span>
  <span class="k">switch</span> <span class="nx">err</span> <span class="p">{</span>
  <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
  <span class="k">case</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">ErrSpanContextNotFound</span><span class="p">:</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;Parent span not found, will start new one.&#34;</span><span class="p">)</span>
  <span class="k">default</span><span class="p">:</span>
   <span class="nx">log</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;Failed to extract trace span: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Start new trace span.
</span><span class="c1"></span>  <span class="nx">span</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span>
   <span class="s">&#34;RPC Server &#34;</span><span class="o">+</span><span class="nx">info</span><span class="p">.</span><span class="nx">FullMethod</span><span class="p">,</span>
   <span class="nx">ext</span><span class="p">.</span><span class="nf">RPCServerOption</span><span class="p">(</span><span class="nx">parentSpanContext</span><span class="p">),</span>
  <span class="p">)</span>
  <span class="k">defer</span> <span class="nx">span</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
  <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">span</span><span class="p">)</span>

  <span class="c1">// Set request ID for context.
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">sc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">().(</span><span class="nx">jaeger</span><span class="p">.</span><span class="nx">SpanContext</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
   <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">constants</span><span class="p">.</span><span class="nx">RequestID</span><span class="p">,</span> <span class="nx">sc</span><span class="p">.</span><span class="nf">TraceID</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
 <span class="nx">binHeaderSuffix</span> <span class="p">=</span> <span class="s">&#34;_bin&#34;</span>
<span class="p">)</span>

<span class="c1">// metadataTextMap extends a metadata.MD to be an opentracing textmap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">metadataTextMap</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>

<span class="c1">// Set is a opentracing.TextMapReader interface that extracts values.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">metadataTextMap</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// gRPC allows for complex binary values to be written.
</span><span class="c1"></span> <span class="nx">encodedKey</span><span class="p">,</span> <span class="nx">encodedVal</span> <span class="o">:=</span> <span class="nf">encodeKeyValue</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
 <span class="c1">// The metadata object is a multimap, and previous values may exist, but for opentracing headers, we do not append
</span><span class="c1"></span> <span class="c1">// we just override.
</span><span class="c1"></span> <span class="nx">m</span><span class="p">[</span><span class="nx">encodedKey</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">encodedVal</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ForeachKey is a opentracing.TextMapReader interface that extracts values.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">metadataTextMap</span><span class="p">)</span> <span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">callback</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">decodedKey</span><span class="p">,</span> <span class="nx">decodedVal</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">DecodeKeyValue</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">callback</span><span class="p">(</span><span class="nx">decodedKey</span><span class="p">,</span> <span class="nx">decodedVal</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed decoding opentracing from gRPC metadata: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="p">}</span>
  <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// encodeKeyValue encodes key and value qualified for transmission via gRPC.
</span><span class="c1">// note: copy pasted from private values of grpc.metadata
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">encodeKeyValue</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">k</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToLower</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasSuffix</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">binHeaderSuffix</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">val</span> <span class="o">:=</span> <span class="nx">base64</span><span class="p">.</span><span class="nx">StdEncoding</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
  <span class="nx">v</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参考:</p>
<p><a href="https://cloud.tencent.com/developer/article/1160850">Jaeger-分布式调用链跟踪系统理论与实战</a>
<a href="https://pjw.io/articles/2018/05/18/jaeger-tutorial/">Jaeger 教程</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/jaeger/">Jaeger</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
