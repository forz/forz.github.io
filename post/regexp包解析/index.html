<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>regexp包解析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="正则表达式 正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是 它却更灵活。按照它的语法规则" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.55.6 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/regexp%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="http://localhost:1313/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="regexp包解析" />
<meta property="og:description" content="正则表达式 正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是 它却更灵活。按照它的语法规则" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/regexp%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<meta property="article:published_time" content="2018-11-15T18:41:39&#43;00:00"/>
<meta property="article:modified_time" content="2018-11-15T18:41:39&#43;00:00"/>

<meta itemprop="name" content="regexp包解析">
<meta itemprop="description" content="正则表达式 正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是 它却更灵活。按照它的语法规则">


<meta itemprop="datePublished" content="2018-11-15T18:41:39&#43;00:00" />
<meta itemprop="dateModified" content="2018-11-15T18:41:39&#43;00:00" />
<meta itemprop="wordCount" content="10833">



<meta itemprop="keywords" content="Go标准库," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="regexp包解析"/>
<meta name="twitter:description" content="正则表达式 正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是 它却更灵活。按照它的语法规则"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                console.log(suggestion, '<a href="http://' + document.domain + suggestion.uri + '">', "http:\/\/localhost:1313");
                setTimeout(() => {
                    console.log(document.getElementsByClassName('aa-dropdown-menu')[0].innerHTML)
                }, 3000);
                return '<span class="search-item">' + '<a href="http:\/\/localhost:1313' + suggestion.uri + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">regexp包解析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-15 </span>
        <div class="post-category">
            <a href="/categories/Go%E6%A0%87%E5%87%86%E5%BA%93/"> Go标准库 </a>
            </div>
          <span class="more-meta"> 约 10833 字 </span>
          <span class="more-meta"> 预计阅读 22 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#正则表达式">正则表达式</a></li>
<li><a href="#re2语法-syntax包">RE2语法(Syntax包)</a>
<ul>
<li><a href="#语法">语法</a></li>
<li><a href="#实例">实例</a></li>
</ul></li>
<li><a href="#regexp">regexp</a>
<ul>
<li><a href="#regexp的设计原则">regexp的设计原则</a></li>
<li><a href="#判断在-b-s-r-中能否找到-pattern-所匹配的字符串">判断在 b（s、r）中能否找到 pattern 所匹配的字符串</a>
<ul>
<li><a href="#func-match">func Match</a></li>
<li><a href="#func-matchreader">func MatchReader</a></li>
<li><a href="#func-matchstring">func MatchString</a></li>
</ul></li>
<li><a href="#func-quotemeta">func QuoteMeta</a></li>
<li><a href="#type-regexp">type Regexp</a></li>
<li><a href="#匹配">匹配</a>
<ul>
<li><a href="#func-compile">func Compile</a></li>
<li><a href="#func-compileposix">func CompilePOSIX</a></li>
<li><a href="#func-mustcompile">func MustCompile</a></li>
<li><a href="#func-mustcompileposix">func MustCompilePOSIX</a></li>
<li><a href="#示例-第一匹配和最长匹配">示例:第一匹配和最长匹配</a></li>
</ul></li>
<li><a href="#获取正则表达式信息">获取正则表达式信息</a>
<ul>
<li><a href="#func-regexp-longest">func (*Regexp) Longest</a></li>
<li><a href="#func-regexp-string">func (*Regexp) String</a></li>
<li><a href="#func-regexp-subexpnames">func (*Regexp) SubexpNames</a></li>
<li><a href="#func-regexp-literalprefix">func (*Regexp) LiteralPrefix</a></li>
<li><a href="#示例-获取正则表达式信息">示例：获取正则表达式信息</a></li>
</ul></li>
<li><a href="#查找-find-findsubmatch">查找:Find、FindSubmatch</a>
<ul>
<li><a href="#func-regexp-find">func (*Regexp) Find</a></li>
<li><a href="#func-regexp-findstring">func (*Regexp) FindString</a></li>
<li><a href="#func-regexp-findsubmatch">func (*Regexp) FindSubmatch</a></li>
<li><a href="#func-regexp-findstringsubmatch">func (*Regexp) FindStringSubmatch</a></li>
<li><a href="#示例-find-findsubmatch">示例：Find、FindSubmatch</a></li>
</ul></li>
<li><a href="#查找-findindex-findsubmatchindex">查找：FindIndex、FindSubmatchIndex</a>
<ul>
<li><a href="#func-regexp-findindex">func (*Regexp) FindIndex</a></li>
<li><a href="#func-regexp-findstringindex">func (*Regexp) FindStringIndex</a></li>
<li><a href="#func-regexp-findreaderindex">func (*Regexp) FindReaderIndex</a></li>
<li><a href="#func-regexp-findsubmatchindex">func (*Regexp) FindSubmatchIndex</a></li>
<li><a href="#func-regexp-findstringsubmatchindex">func (*Regexp) FindStringSubmatchIndex</a></li>
<li><a href="#func-regexp-findreadersubmatchindex">func (*Regexp) FindReaderSubmatchIndex</a></li>
<li><a href="#示例-findindex-findsubmatchindex">示例：FindIndex、FindSubmatchIndex</a></li>
</ul></li>
<li><a href="#查找-findall-findallsubmatch">查找:FindAll、FindAllSubmatch</a>
<ul>
<li><a href="#func-regexp-findall">func (*Regexp) FindAll</a></li>
<li><a href="#func-regexp-findallstring">func (*Regexp) FindAllString</a></li>
<li><a href="#func-regexp-findallindex">func (*Regexp) FindAllIndex</a></li>
<li><a href="#func-regexp-findallstringindex">func (*Regexp) FindAllStringIndex</a></li>
<li><a href="#func-regexp-findallsubmatch">func (*Regexp) FindAllSubmatch</a></li>
<li><a href="#func-regexp-findallstringsubmatch">func (*Regexp) FindAllStringSubmatch</a></li>
<li><a href="#示例-findall-findallsubmatch">示例：FindAll、FindAllSubmatch</a></li>
</ul></li>
<li><a href="#替换">替换</a>
<ul>
<li><a href="#func-regexp-replaceall">func (*Regexp) ReplaceAll</a></li>
<li><a href="#func-regexp-replaceallfunc">func (*Regexp) ReplaceAllFunc</a></li>
<li><a href="#func-regexp-replaceallliteral">func (*Regexp) ReplaceAllLiteral</a></li>
<li><a href="#func-regexp-replaceallstring">func (*Regexp) ReplaceAllString</a></li>
<li><a href="#func-regexp-replaceallstringfunc">func (*Regexp) ReplaceAllStringFunc</a></li>
<li><a href="#func-regexp-replaceallliteralstring">func (*Regexp) ReplaceAllLiteralString</a></li>
</ul></li>
<li><a href="#一次替换-expand">一次替换:Expand</a>
<ul>
<li><a href="#func-regexp-expand">func (*Regexp) Expand</a></li>
<li><a href="#func-regexp-expandstring">func (*Regexp) ExpandString</a></li>
</ul></li>
<li><a href="#示例-expand">示例：Expand</a></li>
<li><a href="#func-regexp-split">func (*Regexp) Split</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h1 id="正则表达式">正则表达式</h1>

<p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是
它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何想你要得到的字符组
合。如果你在Web开发中需要从一些文本数据源中获取数据,那么你只需要按照它的语法规则，随需构造出正确的模式
字符串就能够从原数据源提取出有意义的文本信息。</p>

<p>其实字符串处理我们可以使用strings包来进行搜索(Contains、Index)、替换(Replace)和解析(Split、Join)等操 作，但是这些都是简单的字符串操作，他们的搜索都是大小写敏感，而且固定的字符串，如果我们需要匹配可变的那 种就没办法实现了，当然如果strings包能解决你的问题，那么就尽量使用它来解决。因为他们足够简单、而且性能 和可读性都会比正则好。</p>

<p>本包的正则表达式保证搜索复杂度为O(n)，其中n为输入的长度。这一点很多其他开源实现是无法保证的。</p>

<h1 id="re2语法-syntax包">RE2语法(Syntax包)</h1>

<h2 id="语法">语法</h2>

<p>本包采用的正则表达式语法，默认采用perl标志。某些语法可以通过切换解析时的标志来关闭。</p>

<p>单字符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></pre></td>
<td class="lntd">
<pre class="chroma">    .                  匹配任意一个字符，如果设置 s = true，则可以匹配换行符

    [字符类]            匹配“字符类”中的一个字符，“字符类”见后面的说明
    [^字符类]           匹配“字符类”外的一个字符，“字符类”见后面的说明

    \小写Perl标记       匹配“Perl类”中的一个字符，“Perl类”见后面的说明
    \大写Perl标记       匹配“Perl类”外的一个字符，“Perl类”见后面的说明

    [:ASCII类名:]       匹配“ASCII类”中的一个字符，“ASCII类”见后面的说明
    [:^ASCII类名:]      匹配“ASCII类”外的一个字符，“ASCII类”见后面的说明

    \pUnicode普通类名   匹配“Unicode类”中的一个字符(仅普通类)，“Unicode类”见后面的说明
    \PUnicode普通类名   匹配“Unicode类”外的一个字符(仅普通类)，“Unicode类”见后面的说明

    \p{Unicode类名}     匹配“Unicode类”中的一个字符，“Unicode类”见后面的说明
    \P{Unicode类名}     匹配“Unicode类”外的一个字符，“Unicode类”见后面的说明</pre></td></tr></table>
</div>
</div>
<p>结合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">    xy             匹配x后接着匹配y
    x|y            匹配x或y（优先匹配x）</pre></td></tr></table>
</div>
</div>
<p>重复：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></pre></td>
<td class="lntd">
<pre class="chroma">    x*             重复&gt;=0次匹配x，越多越好（优先重复匹配x）
    x+             重复&gt;=1次匹配x，越多越好（优先重复匹配x）
    x?             0或1次匹配x，优先1次
    x{n,m}         n到m次匹配x，越多越好（优先重复匹配x）
    x{n,}          重复&gt;=n次匹配x，越多越好（优先重复匹配x）
    x{n}           重复n次匹配x
    x*?            重复&gt;=0次匹配x，越少越好（优先跳出重复）
    x+?            重复&gt;=1次匹配x，越少越好（优先跳出重复）
    x??            0或1次匹配x，优先0次
    x{n,m}?        n到m次匹配x，越少越好（优先跳出重复）
    x{n,}?         重复&gt;=n次匹配x，越少越好（优先跳出重复）
    x{n}?          重复n次匹配x</pre></td></tr></table>
</div>
</div>
<p>实现的限制：计数格式x{n}等（不包括x*等格式）中n最大值1000。负数或者显式出现的过大的值会导致解析错误，返回ErrInvalidRepeatSize。</p>

<p>分组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></pre></td>
<td class="lntd">
<pre class="chroma">    (子表达式)            被捕获的组，该组被编号 (子匹配)
    (?P&lt;命名&gt;子表达式)    被捕获的组，该组被编号且被命名 (子匹配)
    (?:子表达式)          非捕获的组 (子匹配)
    (?标记)               在组内设置标记，非捕获，标记影响当前组后的正则表达式
    (?标记:子表达式)      在组内设置标记，非捕获，标记影响当前组内的子表达式

    标记的语法是：
    xyz  (设置 xyz 标记)
    -xyz (清除 xyz 标记)
    xy-z (设置 xy 标记, 清除 z 标记)

    可以设置的标记有：
    i              不区分大小写 (默认为 false)
    m              多行模式：让 ^ 和 $ 匹配整个文本的开头和结尾，而非行首和行尾(默认为 false)
    s              让 . 匹配 \n (默认为 false)
    U              非贪婪模式：交换 x* 和 x*? 等的含义 (默认为 false)</pre></td></tr></table>
</div>
</div>
<p>边界匹配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">    ^              如果标记 m=true 则匹配行首，否则匹配整个文本的开头（m 默认为 false）
    $              如果标记 m=true 则匹配行尾，否则匹配整个文本的结尾（m 默认为 false）
    \A             匹配整个文本的开头，忽略 m 标记
    \b             匹配单词边界
    \B             匹配非单词边界
    \z             匹配整个文本的结尾，忽略 m 标记</pre></td></tr></table>
</div>
</div>
<p>转义序列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></pre></td>
<td class="lntd">
<pre class="chroma">    \a             匹配响铃符    （相当于 \x07）
                   注意：正则表达式中不能使用 \b 匹配退格符，因为 \b 被用来匹配单词边界，
                   可以使用 \x08 表示退格符。
    \f             匹配换页符    （相当于 \x0C）
    \t             匹配横向制表符（相当于 \x09）
    \n             匹配换行符    （相当于 \x0A）
    \r             匹配回车符    （相当于 \x0D）
    \v             匹配纵向制表符（相当于 \x0B）
    \123           匹配 8  進制编码所代表的字符（必须是 3 位数字）
    \x7F           匹配 16 進制编码所代表的字符（必须是 3 位数字）
    \x{10FFFF}     匹配 16 進制编码所代表的字符（最大值 10FFFF  ）
    \Q...\E        匹配 \Q 和 \E 之间的文本，忽略文本中的正则语法

    \\             匹配字符 \
    \^             匹配字符 ^
    \$             匹配字符 $
    \.             匹配字符 .
    \*             匹配字符 *
    \+             匹配字符 +
    \?             匹配字符 ?
    \{             匹配字符 {
    \}             匹配字符 }
    \(             匹配字符 (
    \)             匹配字符 )
    \[             匹配字符 [
    \]             匹配字符 ]
    \|             匹配字符 |</pre></td></tr></table>
</div>
</div>
<p>“字符类”取值如下（“字符类”包含“Perl类”、“ASCII类”、“Unicode类”）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">x                    单个字符
A-Z                  字符范围(包含首尾字符)
\小写字母            Perl类
[:ASCII类名:]        ASCII类
\p{Unicode脚本类名}  Unicode类 (脚本类)
\pUnicode普通类名    Unicode类 (普通类)</pre></td></tr></table>
</div>
</div>
<p>可以将“命名字符类”作为“字符类”的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></pre></td>
<td class="lntd">
<pre class="chroma">    [\d]           匹配数字 (相当于 \d)
    [^\d]          匹配非数字 (相当于 \D)
    [\D]           匹配非数字 (相当于 \D)
    [^\D]          匹配数字 (相当于 \d)
    [[:name:]]     命名的“ASCII 类”包含在“字符类”中 (相当于 [:name:])
    [^[:name:]]    命名的“ASCII 类”不包含在“字符类”中 (相当于 [:^name:])
    [\p{Name}]     命名的“Unicode 类”包含在“字符类”中 (相当于 \p{Name})
    [^\p{Name}]    命名的“Unicode 类”不包含在“字符类”中 (相当于 \P{Name})</pre></td></tr></table>
</div>
</div>
<p>“字符类”取值如下（“字符类”包含“Perl类”、“ASCII类”、“Unicode类”）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">x                    单个字符
A-Z                  字符范围(包含首尾字符)
\小写字母            Perl类
[:ASCII类名:]        ASCII类
\p{Unicode脚本类名}  Unicode类 (脚本类)
\pUnicode普通类名    Unicode类 (普通类)</pre></td></tr></table>
</div>
</div>
<p>“Perl 类”取值如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">\d             数字 (相当于 [0-9])
\D             非数字 (相当于 [^0-9])
\s             空白 (相当于 [\t\n\f\r ])
\S             非空白 (相当于[^\t\n\f\r ])
\w             单词字符 (相当于 [0-9A-Za-z_])
\W             非单词字符 (相当于 [^0-9A-Za-z_])</pre></td></tr></table>
</div>
</div>
<p>“ASCII 类”取值如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></pre></td>
<td class="lntd">
<pre class="chroma">[:alnum:]      字母数字 (相当于 [0-9A-Za-z])
[:alpha:]      字母 (相当于 [A-Za-z])
[:ascii:]      ASCII 字符集 (相当于 [\x00-\x7F])
[:blank:]      空白占位符 (相当于 [\t ])
[:cntrl:]      控制字符 (相当于 [\x00-\x1F\x7F])
[:digit:]      数字 (相当于 [0-9])
[:graph:]      图形字符 (相当于 [!-~])
[:lower:]      小写字母 (相当于 [a-z])
[:print:]      可打印字符 (相当于 [ -~] 相当于 [ [:graph:]])
[:punct:]      标点符号 (相当于 [!-/:-@[-反引号{-~])
[:space:]      空白字符(相当于 [\t\n\v\f\r ])
[:upper:]      大写字母(相当于 [A-Z])
[:word:]       单词字符(相当于 [0-9A-Za-z_])
[:xdigit:]     16 進制字符集(相当于 [0-9A-Fa-f])</pre></td></tr></table>
</div>
</div>
<p>“Unicode 类”取值如下&mdash;普通类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></pre></td>
<td class="lntd">
<pre class="chroma">C                 -其他-          (other)
Cc                控制字符        (control)
Cf                格式            (format)
Co                私人使用区      (private use)
Cs                代理区          (surrogate)
L                 -字母-          (letter)
Ll                小写字母        (lowercase letter)
Lm                修饰字母        (modifier letter)
Lo                其它字母        (other letter)
Lt                首字母大写字母  (titlecase letter)
Lu                大写字母        (uppercase letter)
M                 -标记-          (mark)
Mc                间距标记        (spacing mark)
Me                关闭标记        (enclosing mark)
Mn                非间距标记      (non-spacing mark)
N                 -数字-          (number)
Nd                十進制数字      (decimal number)
Nl                字母数字        (letter number)
No                其它数字        (other number)
P                 -标点-          (punctuation)
Pc                连接符标点      (connector punctuation)
Pd                破折号标点符号  (dash punctuation)
Pe                关闭的标点符号  (close punctuation)
Pf                最后的标点符号  (final punctuation)
Pi                最初的标点符号  (initial punctuation)
Po                其他标点符号    (other punctuation)
Ps                开放的标点符号  (open punctuation)
S                 -符号-          (symbol)
Sc                货币符号        (currency symbol)
Sk                修饰符号        (modifier symbol)
Sm                数学符号        (math symbol)
So                其他符号        (other symbol)
Z                 -分隔符-        (separator)
Zl                行分隔符        (line separator)
Zp                段落分隔符      (paragraph separator)
Zs                空白分隔符      (space separator)</pre></td></tr></table>
</div>
</div>
<p>“Unicode 类”取值如下&mdash;脚本类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></pre></td>
<td class="lntd">
<pre class="chroma">Arabic                  阿拉伯文
Armenian                亚美尼亚文
Balinese                巴厘岛文
Bengali                 孟加拉文
Bopomofo                汉语拼音字母
Braille                 盲文
Buginese                布吉文
Buhid                   布希德文
Canadian_Aboriginal     加拿大土著文
Carian                  卡里亚文
Cham                    占族文
Cherokee                切诺基文
Common                  普通的，字符不是特定于一个脚本
Coptic                  科普特文
Cuneiform               楔形文字
Cypriot                 塞浦路斯文
Cyrillic                斯拉夫文
Deseret                 犹他州文
Devanagari              梵文
Ethiopic                衣索比亚文
Georgian                格鲁吉亚文
Glagolitic              格拉哥里文
Gothic                  哥特文
Greek                   希腊
Gujarati                古吉拉特文
Gurmukhi                果鲁穆奇文
Han                     汉文
Hangul                  韩文
Hanunoo                 哈鲁喏文
Hebrew                  希伯来文
Hiragana                平假名（日语）
Inherited               继承前一个字符的脚本
Kannada                 坎那达文
Katakana                片假名（日语）
Kayah_Li                克耶字母
Kharoshthi              卡罗须提文
Khmer                   高棉文
Lao                     老挝文
Latin                   拉丁文
Lepcha                  雷布查文
Limbu                   林布文
Linear_B                B类线形文字（古希腊）
Lycian                  利西亚文
Lydian                  吕底亚文
Malayalam               马拉雅拉姆文
Mongolian               蒙古文
Myanmar                 缅甸文
New_Tai_Lue             新傣仂文
Nko                     Nko文
Ogham                   欧甘文
Ol_Chiki                桑塔利文
Old_Italic              古意大利文
Old_Persian             古波斯文
Oriya                   奥里亚文
Osmanya                 奥斯曼亚文
Phags_Pa                八思巴文
Phoenician              腓尼基文
Rejang                  拉让文
Runic                   古代北欧文字
Saurashtra              索拉什特拉文（印度县城）
Shavian                 萧伯纳文
Sinhala                 僧伽罗文
Sundanese               巽他文
Syloti_Nagri            锡尔赫特文
Syriac                  叙利亚文
Tagalog                 塔加拉文
Tagbanwa                塔格巴努亚文
Tai_Le                  德宏傣文
Tamil                   泰米尔文
Telugu                  泰卢固文
Thaana                  塔安那文
Thai                    泰文
Tibetan                 藏文
Tifinagh                提非纳文
Ugaritic                乌加里特文
Vai                     瓦伊文
Yi                      彝文</pre></td></tr></table>
</div>
</div>
<p>注意：</p>

<p>　　对于 [a-z] 这样的正则表达式，如果要在 [] 中匹配 - ，可以将 - 放在 [] 的开头或结尾，例如 [-a-z] 或 [a-z-]</p>

<p>　　可以在 [] 中使用转义字符：\f、\t、\n、\r、\v、\377、\xFF、\x{10FFFF}、\、\^、\$、.、*、+、\?、{、}、(、)、[、]、|（具体含义见上面的说明）</p>

<p>　　如果在正则表达式中使用了分组，则在执行正则替换的时候，“替换内容”中可以使用 \$1、\${1}、\$name、\${name} 这样的“分组引用符”获取相应的分组内容。其中 \$0 代表整个匹配项，\$1 代表第 1 个分组，\$2 代表第 2 个分组，……。</p>

<p>　　如果“分组引用符”是 \$name 的形式，则在解析的时候，name 是取尽可能长的字符串，比如：\$1x 相当于 \${1x}，而不是\${1}x，再比如：\$10 相当于 \${10}，而不是 \${1}0。</p>

<p>　　由于 \$ 字符会被转义，所以要在“替换内容”中使用 \$ 字符，可以用 \$ 代替。</p>

<p>　　上面介绍的正则表达式语法是“Perl 语法”，除了“Perl 语法”外，Go 语言中还有另一种“POSIX 语法”，“POSIX 语法”除了不能使用“Perl 类”之外，其它都一样。</p>

<h2 id="实例">实例</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;regexp&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">text</span> <span class="o">:=</span> <span class="s">`Hello 世界！123 Go.`</span>

    <span class="c1">// 查找连续的小写字母
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[a-z]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;ello&#34; &#34;o&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的非小写字母
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[^a-z]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;H&#34; &#34; 世界！123 G&#34; &#34;.&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的单词字母
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[\w]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello&#34; &#34;123&#34; &#34;Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的非单词字母、非空白字符
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[^\w\s]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;世界！&#34; &#34;.&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的大写字母
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[[:upper:]]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;H&#34; &#34;G&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的非 ASCII 字符
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[[:^ascii:]]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;世界！&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的标点符号
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[\pP]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;！&#34; &#34;.&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的非标点符号字符
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[\PP]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello 世界&#34; &#34;123 Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的汉字
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[\p{Han}]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;世界&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续的非汉字字符
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[\P{Han}]+`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello &#34; &#34;！123 Go.&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找 Hello 或 Go
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`Hello|Go`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello&#34; &#34;Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找行首以 H 开头，以空格结尾的字符串
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`^H.*\s`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello 世界！123 &#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找行首以 H 开头，以空白结尾的字符串（非贪婪模式）
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(?U)^H.*\s`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello &#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找以 hello 开头（忽略大小写），以 Go 结尾的字符串
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(?i:^hello).*Go`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello 世界！123 Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找 Go.
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`\QGo.\E`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Go.&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找从行首开始，以空格结尾的字符串（非贪婪模式）
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(?U)^.* `</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello &#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找以空格开头，到行尾结束，中间不包含空格字符串
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">` [^ ]*$`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34; Go.&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找“单词边界”之间的字符串
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(?U)\b.+\b`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello&#34; &#34; 世界！&#34; &#34;123&#34; &#34; &#34; &#34;Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找连续 1 次到 4 次的非空格字符，并以 o 结尾的字符串
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[^ ]{1,4}o`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello&#34; &#34;Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找 Hello 或 Go
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(?:Hell|G)o`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">// [&#34;Hello&#34; &#34;Go&#34;]
</span><span class="c1"></span>
    <span class="c1">// 查找 Hello 或 Go，替换为 Hellooo、Gooo
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(?:Hell|G)o`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="s">&#34;${n}ooo&#34;</span><span class="p">))</span>
    <span class="c1">// &#34;Hellooo 世界！123 Gooo.&#34;
</span><span class="c1"></span>
    <span class="c1">// 交换 Hello 和 Go
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`(Hello)(.*)(Go)`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="s">&#34;$3$2$1&#34;</span><span class="p">))</span>
    <span class="c1">// &#34;Go 世界！123 Hello.&#34;
</span><span class="c1"></span>
    <span class="c1">// 特殊字符的查找
</span><span class="c1"></span>    <span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`[\f\t\n\r\v\123\x7F\x{10FFFF}\\\^\$\.\*\+\?\{\}\(\)\[\]\|]`</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="s">&#34;\f\t\n\r\v\123\x7F\U0010FFFF\\^$.*+?{}()[]|&#34;</span><span class="p">,</span> <span class="s">&#34;-&#34;</span><span class="p">))</span>
    <span class="c1">// &#34;----------------------&#34;
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="regexp">regexp</h1>

<h2 id="regexp的设计原则">regexp的设计原则</h2>

<p>regexp包的方法命名规则如下：</p>

<p>Find(All)?(String)?(Submatch)?(Index)?</p>

<p>包含All的方法捕获所有match, 返回值是一个slice. 同时一般会提供一个参数n作为最大匹配次数。</p>

<p>包含String的方法对string类型进行匹配，反之对[]byte进行匹配。</p>

<p>包含Submatch的方法返回所有子匹配，返回值是一个slice. 位置0是对应整个正则表达式匹配结果，位置n(n&gt;0)是第n个子表达式(group) 匹配结果。</p>

<p>包含Index的方法返回匹配的位置。例如，返回loc []int, 则与之对应的匹配字符为src[loc[0]:loc[1]].</p>

<h2 id="判断在-b-s-r-中能否找到-pattern-所匹配的字符串">判断在 b（s、r）中能否找到 pattern 所匹配的字符串</h2>

<h3 id="func-match">func Match</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func Match(pattern string, b []byte) (matched bool, err error)</pre></td></tr></table>
</div>
</div>
<p>匹配检查文本正则表达式是否与字节片匹配。更复杂的用法请使用Compile函数和Regexp对象。</p>

<h3 id="func-matchreader">func MatchReader</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</pre></td></tr></table>
</div>
</div>
<p>MatchReader 检查文本正则表达式是否与 RuneReader 读取的文本匹配。更复杂的用法请使用Compile函数和Regexp对象。</p>

<h3 id="func-matchstring">func MatchString</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func MatchString(pattern string, s string) (matched bool, err error)</pre></td></tr></table>
</div>
</div>
<p>MatchString 检查文本正则表达式是否匹配字符串。更复杂的用法请使用Compile函数和Regexp对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;regexp&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">&#34;foo.*&#34;</span><span class="p">,</span> <span class="s">&#34;seafood&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">&#34;bar.*&#34;</span><span class="p">,</span> <span class="s">&#34;seafood&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">&#34;a(b&#34;</span><span class="p">,</span> <span class="s">&#34;seafood&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="func-quotemeta">func QuoteMeta</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func QuoteMeta(s string) string</pre></td></tr></table>
</div>
</div>
<p>QuoteMeta 返回一个字符串，它引用参数文本中的所有正则表达式元字符； 返回的字符串是一个匹配文本文本的正则表达式。例如，QuoteMeta（[foo]）返回[foo]。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`(((abc.)def.)ghi)`</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">regexp</span><span class="p">.</span><span class="nf">QuoteMeta</span><span class="p">(</span><span class="nx">pat</span><span class="p">))</span>
	<span class="c1">// \(\(\(abc\.\)def\.\)ghi\)
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="type-regexp">type Regexp</h2>

<p>正则表达式是已编译正则表达式的表示形式。除了配置方法（如Longest）之外，Regexp 可以安全地用于多个 goroutine 的并发使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Regexp</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="匹配">匹配</h2>

<h3 id="func-compile">func Compile</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func Compile(expr string) (*Regexp, error)</pre></td></tr></table>
</div>
</div>
<p>编译解析一个正则表达式，并且如果成功返回一个可以用来匹配文本的 Regexp 对象。</p>

<p>当匹配文本时，正则表达式会返回一个尽可能早在输入中开始的匹配（最左边），并在其中选择回溯搜索首先找到的匹配。这种所谓的最左边第一匹配与 Perl，Python 和其他实现使用的语义相同，尽管这个包实现它而没有回溯的代价。对于 POSIX 最左边最长的匹配，请参阅 CompilePOSIX 。</p>

<h3 id="func-compileposix">func CompilePOSIX</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func CompilePOSIX(expr string) (*Regexp, error)</pre></td></tr></table>
</div>
</div>
<p>CompilePOSIX 就像 Compile，但将正则表达式限制为 POSIX ERE（egrep） 语法，并将匹配语义更改为最长。</p>

<p>也就是说，当匹配文本时，正则表达式会返回一个尽可能早在输入中开始的匹配（最左边），并且在它们之间选择尽可能长的匹配。这种所谓的最左边最长匹配与早期正则表达式实现使用和 POSIX 指定的语义相同。</p>

<p>但是，可以有多个最左边最长的匹配，具有不同的匹配选项，并且此包与 POSIX 不同。在可能的最左边最长的匹配中，这个包选择一个回溯搜索首先找到的那个，而 POSIX 指定匹配被选择为最大化第一个子表达的长度，然后第二个等等从左到右。POSIX 规则在计算上是禁止的，甚至没有明确定义。</p>

<p>POSIX 语法不支持 Perl 的语法格式：\d、\D、\s、\S、\w、\W.如果正则表达式语法错误，则返回错误信息。</p>

<h3 id="func-mustcompile">func MustCompile</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func MustCompile(str string) *Regexp</pre></td></tr></table>
</div>
</div>
<p>MustCompile 就像compile，但如果表达式不能被解析就会发生panic。它简化了保存已编译正则表达式的全局变量的安全初始化。</p>

<h3 id="func-mustcompileposix">func MustCompilePOSIX</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func MustCompilePOSIX(str string) *Regexp</pre></td></tr></table>
</div>
</div>
<p>MustCompilePOSIX 与 CompilePOSIX 类似，但如果表达式无法解析，则会发生panic。它简化了保存已编译正则表达式的全局变量的安全初始化。</p>

<h3 id="示例-第一匹配和最长匹配">示例:第一匹配和最长匹配</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;abc1def1&#34;</span><span class="p">)</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`abc1|abc1def1`</span>
	<span class="nx">reg1</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>      <span class="c1">// 第一匹配
</span><span class="c1"></span>	<span class="nx">reg2</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompilePOSIX</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span> <span class="c1">// 最长匹配
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">reg1</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>     <span class="c1">// abc1
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">reg2</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>     <span class="c1">// abc1def1
</span><span class="c1"></span>
	<span class="nx">b</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;abc1def1&#34;</span><span class="p">)</span>
	<span class="nx">pat</span> <span class="p">=</span> <span class="s">`(abc|abc1def)*1`</span>
	<span class="nx">reg1</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>      <span class="c1">// 第一匹配
</span><span class="c1"></span>	<span class="nx">reg2</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompilePOSIX</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span> <span class="c1">// 最长匹配
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">reg1</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>    <span class="c1">// abc1
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">reg2</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>    <span class="c1">// abc1def1
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="获取正则表达式信息">获取正则表达式信息</h2>

<h3 id="func-regexp-longest">func (*Regexp) Longest</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) Longest()</pre></td></tr></table>
</div>
</div>
<p>让正则表达式在之后的搜索中都采用“leftmost-longest”模式。</p>

<h3 id="func-regexp-string">func (*Regexp) String</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) String() string</pre></td></tr></table>
</div>
</div>
<p>// 返回编译时使用的正则表达式字符串</p>

<h3 id="func-regexp-subexpnames">func (*Regexp) SubexpNames</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) SubexpNames() []string</pre></td></tr></table>
</div>
</div>
<p>SubexpNames 返回此 Regexp 中带括号的子表达式的名称。第一个子表达式的名称是 names1 ，因此如果 m 是匹配片，则 mi 的名称是 SubexpNames（）i 。由于整个正则表达式不能被命名，names0 总是空字符串。slice 不应该被修改。</p>

<h3 id="func-regexp-literalprefix">func (*Regexp) LiteralPrefix</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</pre></td></tr></table>
</div>
</div>
<p>LiteralPrefix返回一个字符串字面值prefix，任何匹配本正则表达式的字符串都会以prefix起始。 如果该字符串字面值包含整个正则表达式，返回值complete会设为真。</p>

<h3 id="示例-获取正则表达式信息">示例：获取正则表达式信息</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`(abc)(def)(ghi)`</span>
	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>

	<span class="c1">// 获取正则表达式字符串
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reg</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>    <span class="c1">// (abc)(def)(ghi)
</span><span class="c1"></span>
	<span class="c1">// 获取分组数量
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reg</span><span class="p">.</span><span class="nf">NumSubexp</span><span class="p">())</span> <span class="c1">// 3
</span><span class="c1"></span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>

	<span class="c1">// 获取分组名称
</span><span class="c1"></span>	<span class="nx">pat</span> <span class="p">=</span> <span class="s">`(?P&lt;Name1&gt;abc)(def)(?P&lt;Name3&gt;ghi)`</span>
	<span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">NumSubexp</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d: %q\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">SubexpNames</span><span class="p">()[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="c1">// 0: &#34;&#34;
</span><span class="c1"></span>	<span class="c1">// 1: &#34;Name1&#34;
</span><span class="c1"></span>	<span class="c1">// 2: &#34;&#34;
</span><span class="c1"></span>	<span class="c1">// 3: &#34;Name3&#34;
</span><span class="c1"></span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>

	<span class="c1">// 获取字面前缀
</span><span class="c1"></span>	<span class="nx">pat</span> <span class="p">=</span> <span class="s">`(abc1)(abc2)(abc3)`</span>
	<span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reg</span><span class="p">.</span><span class="nf">LiteralPrefix</span><span class="p">())</span> <span class="c1">// abc1abc2abc3 true
</span><span class="c1"></span>
	<span class="nx">pat</span> <span class="p">=</span> <span class="s">`(abc1)|(abc2)|(abc3)`</span>
	<span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reg</span><span class="p">.</span><span class="nf">LiteralPrefix</span><span class="p">())</span> <span class="c1">//  false
</span><span class="c1"></span>
	<span class="nx">pat</span> <span class="p">=</span> <span class="s">`abc1|abc2|abc3`</span>
	<span class="nx">reg</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">reg</span><span class="p">.</span><span class="nf">LiteralPrefix</span><span class="p">())</span> <span class="c1">// abc false
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="查找-find-findsubmatch">查找:Find、FindSubmatch</h2>

<h3 id="func-regexp-find">func (*Regexp) Find</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) Find(b []byte) []byte</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的最左侧的一个匹配结果的[]byte切片。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findstring">func (*Regexp) FindString</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindString(s string) string</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的最左侧的一个匹配结果的字符串。如果没有匹配到，会返回&rdquo;&ldquo;；但如果正则表达式成功匹配了一个空字符串，也会返回&rdquo;&ldquo;。如果需要区分这种情况，请使用FindStringIndex 或FindStringSubmatch。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">re := regexp.MustCompile(&#34;fo.?&#34;)
fmt.Printf(&#34;%q\n&#34;, re.FindString(&#34;seafood&#34;))
fmt.Printf(&#34;%q\n&#34;, re.FindString(&#34;meat&#34;))

&#34;foo&#34;
&#34;&#34;</pre></td></tr></table>
</div>
</div>
<h3 id="func-regexp-findsubmatch">func (*Regexp) FindSubmatch</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindSubmatch(b []byte) [][]byte</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的[][]byte切片。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findstringsubmatch">func (*Regexp) FindStringSubmatch</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindStringSubmatch(s string) []string</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的[]string切片。如果没有匹配到，会返回nil。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">re</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">&#34;a(x*)b(y|z)c&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nf">FindStringSubmatch</span><span class="p">(</span><span class="s">&#34;-axxxbyc-&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nf">FindStringSubmatch</span><span class="p">(</span><span class="s">&#34;-abzc-&#34;</span><span class="p">))</span>
<span class="nx">Output</span><span class="p">:</span>

<span class="p">[</span><span class="s">&#34;axxxbyc&#34;</span> <span class="s">&#34;xxx&#34;</span> <span class="s">&#34;y&#34;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&#34;abzc&#34;</span> <span class="s">&#34;&#34;</span> <span class="s">&#34;z&#34;</span><span class="p">]</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="示例-find-findsubmatch">示例：Find、FindSubmatch</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`(((abc.)def.)ghi)`</span>
	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>

	<span class="nx">src</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`abc-def-ghi abc+def+ghi`</span><span class="p">)</span>

	<span class="c1">// 查找第一个匹配结果
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">src</span><span class="p">))</span> <span class="c1">// abc-def-ghi
</span><span class="c1"></span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>

	<span class="c1">// 查找第一个匹配结果及其分组字符串
</span><span class="c1"></span>	<span class="nx">first</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindSubmatch</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">first</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">first</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="c1">// 0: abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// 1: abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// 2: abc-def-
</span><span class="c1"></span>	<span class="c1">// 3: abc-
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="查找-findindex-findsubmatchindex">查找：FindIndex、FindSubmatchIndex</h2>

<h3 id="func-regexp-findindex">func (*Regexp) FindIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindIndex(b []byte) (loc []int)</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的最左侧的一个匹配结果的起止位置的切片（显然len(loc)==2）。匹配结果可以通过起止位置对b做切片操作得到：b[loc[0]:loc[1]]。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findstringindex">func (*Regexp) FindStringIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindStringIndex(s string) (loc []int)</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的最左侧的一个匹配结果的起止位置的切片（显然len(loc)==2）。匹配结果可以通过起止位置对b做切片操作得到：b[loc[0]:loc[1]]。如果没有匹配到，会返回nil。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">re</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">&#34;ab?&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">FindStringIndex</span><span class="p">(</span><span class="s">&#34;tablett&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">FindStringIndex</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

<span class="p">[</span><span class="mi">1</span> <span class="mi">3</span><span class="p">]</span>
<span class="kc">true</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="func-regexp-findreaderindex">func (*Regexp) FindReaderIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的最左侧的一个匹配结果的起止位置的切片（显然len(loc)==2）。匹配结果可以在输入流r的字节偏移量loc[0]到loc[1]-1（包括二者）位置找到。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findsubmatchindex">func (*Regexp) FindSubmatchIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindSubmatchIndex(b []byte) []int</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的起止位置的切片。匹配结果和分组匹配结果可以通过起止位置对b做切片操作得到：b[loc[2*n]:loc[2*n+1]]。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findstringsubmatchindex">func (*Regexp) FindStringSubmatchIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindStringSubmatchIndex(s string) []int</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的起止位置的切片。匹配结果和分组匹配结果可以通过起止位置对b做切片操作得到：b[loc[2*n]:loc[2*n+1]]。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findreadersubmatchindex">func (*Regexp) FindReaderSubmatchIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的起止位置的切片。匹配结果和分组匹配结果可以在输入流r的字节偏移量loc[0]到loc[1]-1（包括二者）位置找到。如果没有匹配到，会返回nil。</p>

<h3 id="示例-findindex-findsubmatchindex">示例：FindIndex、FindSubmatchIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`(((abc.)def.)ghi)`</span>
	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>

	<span class="nx">src</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`abc-def-ghi abc+def+ghi`</span><span class="p">)</span>

	<span class="c1">// 查找第一个匹配结果
</span><span class="c1"></span>	<span class="nx">matched</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindIndex</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">matched</span><span class="p">)</span> <span class="c1">// [0 11]
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">matched</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">matched</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n\n&#34;</span><span class="p">,</span> <span class="nx">src</span><span class="p">[</span><span class="nx">m</span><span class="p">:</span><span class="nx">n</span><span class="p">])</span> <span class="c1">// abc-def-ghi
</span><span class="c1"></span>
	<span class="c1">// 查找第一个匹配结果及其分组字符串
</span><span class="c1"></span>	<span class="nx">matched</span> <span class="p">=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindSubmatchIndex</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">matched</span><span class="p">)</span> <span class="c1">// [0 11 0 11 0 8 0 4]
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">matched</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span> <span class="o">:=</span> <span class="nx">matched</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">matched</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">src</span><span class="p">[</span><span class="nx">m</span><span class="p">:</span><span class="nx">n</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="c1">// abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// abc-def-
</span><span class="c1"></span>	<span class="c1">// abc-
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="查找-findall-findallsubmatch">查找:FindAll、FindAllSubmatch</h2>

<h3 id="func-regexp-findall">func (*Regexp) FindAll</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindAll(b []byte, n int) [][]byte</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[][]byte切片。 n 是查找次数，负数表示不限次数。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findallstring">func (*Regexp) FindAllString</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindAllString(s string, n int) []string</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[]string切片。 n 是查找次数，负数表示不限次数。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findallindex">func (*Regexp) FindAllIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的起止位置的切片。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findallstringindex">func (*Regexp) FindAllStringIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</pre></td></tr></table>
</div>
</div>
<p>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的起止位置的切片。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findallsubmatch">func (*Regexp) FindAllSubmatch</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][][]byte切片。如果没有匹配到，会返回nil。</p>

<h3 id="func-regexp-findallstringsubmatch">func (*Regexp) FindAllStringSubmatch</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</pre></td></tr></table>
</div>
</div>
<p>Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][]string切片。如果没有匹配到，会返回nil。</p>

<h3 id="示例-findall-findallsubmatch">示例：FindAll、FindAllSubmatch</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`(((abc.)def.)ghi)`</span>
	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`abc-def-ghi abc+def+ghi`</span><span class="p">)</span>

	<span class="c1">// 查找所有匹配结果
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">one</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAll</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">one</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// abc+def+ghi
</span><span class="c1"></span>
	<span class="c1">// 查找所有匹配结果及其分组字符串
</span><span class="c1"></span>	<span class="nx">all</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllSubmatch</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">all</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
		<span class="nx">one</span> <span class="o">:=</span> <span class="nx">all</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">one</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">one</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 0: abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// 1: abc-def-ghi
</span><span class="c1"></span>	<span class="c1">// 2: abc-def-
</span><span class="c1"></span>	<span class="c1">// 3: abc-
</span><span class="c1"></span>
	<span class="c1">// 0: abc+def+ghi
</span><span class="c1"></span>	<span class="c1">// 1: abc+def+ghi
</span><span class="c1"></span>	<span class="c1">// 2: abc+def+
</span><span class="c1"></span>	<span class="c1">// 3: abc+
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="替换">替换</h2>

<h3 id="func-regexp-replaceall">func (*Regexp) ReplaceAll</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ReplaceAll(src, repl []byte) []byte</pre></td></tr></table>
</div>
</div>
<p>ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。在替换时，repl中的&rsquo;\$&lsquo;符号会按照Expand方法的规则进行解释和替换，例如\$1会被替换为第一个分组匹配结果。</p>

<h3 id="func-regexp-replaceallfunc">func (*Regexp) ReplaceAllFunc</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</pre></td></tr></table>
</div>
</div>
<p>ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果（设为matched）都替换为repl(matched)。repl返回的切片被直接使用，不会使用Expand进行扩展。</p>

<h3 id="func-regexp-replaceallliteral">func (*Regexp) ReplaceAllLiteral</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte</pre></td></tr></table>
</div>
</div>
<p>ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。repl参数被直接使用，不会使用Expand进行扩展。</p>

<h3 id="func-regexp-replaceallstring">func (*Regexp) ReplaceAllString</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ReplaceAllString(src, repl string) string</pre></td></tr></table>
</div>
</div>
<p>ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。在替换时，repl中的&rsquo;\$&lsquo;符号会按照Expand方法的规则进行解释和替换，例如\$1会被替换为第一个分组匹配结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">re</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">&#34;a(x*)b&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;T&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;$1&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;$1W&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;${1}W&#34;</span><span class="p">))</span>


<span class="o">-</span><span class="nx">T</span><span class="o">-</span><span class="nx">T</span><span class="o">-</span>
<span class="o">--</span><span class="nx">xx</span><span class="o">-</span>
<span class="o">---</span>
<span class="o">-</span><span class="nx">W</span><span class="o">-</span><span class="nx">xxW</span><span class="o">-</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="func-regexp-replaceallstringfunc">func (*Regexp) ReplaceAllStringFunc</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</pre></td></tr></table>
</div>
</div>
<p>ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果（设为matched）都替换为repl(matched)。repl返回的字符串被直接使用，不会使用Expand进行扩展。</p>

<h3 id="func-regexp-replaceallliteralstring">func (*Regexp) ReplaceAllLiteralString</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</pre></td></tr></table>
</div>
</div>
<p>ReplaceAllLiteralString返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。repl参数被直接使用，不会使用Expand进行扩展。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">re</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">&#34;a(x*)b&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllLiteralString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;T&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllLiteralString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;$1&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nf">ReplaceAllLiteralString</span><span class="p">(</span><span class="s">&#34;-ab-axxb-&#34;</span><span class="p">,</span> <span class="s">&#34;${1}&#34;</span><span class="p">))</span>


<span class="o">-</span><span class="nx">T</span><span class="o">-</span><span class="nx">T</span><span class="o">-</span>
<span class="o">-</span><span class="err">$</span><span class="mi">1</span><span class="o">-</span><span class="err">$</span><span class="mi">1</span><span class="o">-</span>
<span class="o">-</span><span class="err">$</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">-</span><span class="err">$</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">-</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="一次替换-expand">一次替换:Expand</h2>

<h3 id="func-regexp-expand">func (*Regexp) Expand</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</pre></td></tr></table>
</div>
</div>
<p>Expand返回新生成的将template添加到dst后面的切片。在添加时，Expand会将template中的变量替换为从src匹配的结果。match应该是被FindSubmatchIndex返回的匹配结果起止位置索引。（通常就是匹配src，除非你要将匹配得到的位置用于另一个[]byte）</p>

<p>在template参数里，一个变量表示为格式如：\$name或\${name}的字符串，其中name是长度&gt;0的字母、数字和下划线的序列。一个单纯的数字字符名如\$1会作为捕获分组的数字索引；其他的名字对应(?P<name>&hellip;)语法产生的命名捕获分组的名字。超出范围的数字索引、索引对应的分组未匹配到文本、正则表达式中未出现的分组名，都会被替换为空切片。</p>

<p>\$name格式的变量名，name会尽可能取最长序列：\$1x等价于\${1x}而非\${1}x，\$10等价于\${10}而非\${1}0。因此\$name适用在后跟空格/换行等字符的情况，\${name}适用所有情况。</p>

<p>如果要在输出中插入一个字面值&rsquo;\$&lsquo;，在template里可以使用\$\$。</p>

<p>Expand 要配合 FindSubmatchIndex 一起使用。FindSubmatchIndex 在 src 中进行查找，将结果存入 match 中。这样就可以通过 src 和 match 得到匹配的字符串。</p>

<p>template 是替换内容，可以使用分组引用符 \$1、\$2、\$name 等。Expane 将其中的分组引用符替换为前面匹配到的字符串。然后追加到 dst 的尾部（dst 可以为空）。</p>

<p>说白了 Expand 就是一次替换过程，只不过需要 FindSubmatchIndex 的配合。</p>

<h3 id="func-regexp-expandstring">func (*Regexp) ExpandString</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte</pre></td></tr></table>
</div>
</div>
<p>ExpandString类似Expand，但template和src参数为字符串。它将替换结果添加到切片并返回切片，以便让调用代码控制内存申请。</p>

<h2 id="示例-expand">示例：Expand</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pat</span> <span class="o">:=</span> <span class="s">`(((abc.)def.)ghi)`</span>
	<span class="nx">reg</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="nx">pat</span><span class="p">)</span>

	<span class="nx">src</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`abc-def-ghi abc+def+ghi`</span><span class="p">)</span>
	<span class="nx">template</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`$0   $1   $2   $3`</span><span class="p">)</span>

	<span class="c1">// 替换第一次匹配结果
</span><span class="c1"></span>	<span class="nx">match</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindSubmatchIndex</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">match</span><span class="p">)</span> <span class="c1">// [0 11 0 11 0 8 0 4]
</span><span class="c1"></span>	<span class="nx">dst</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">Expand</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">template</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">match</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n\n&#34;</span><span class="p">,</span> <span class="nx">dst</span><span class="p">)</span>

	<span class="c1">// 替换所有匹配结果
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">match</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">FindAllSubmatchIndex</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">match</span><span class="p">)</span>
		<span class="nx">dst</span> <span class="o">:=</span> <span class="nx">reg</span><span class="p">.</span><span class="nf">Expand</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">template</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">match</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">dst</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// [0 11 0 11 0 8 0 4]
</span><span class="c1"></span>	<span class="c1">// abc-def-ghi   abc-def-ghi   abc-def-   abc-
</span><span class="c1"></span>	<span class="c1">// [12 23 12 23 12 20 12 16]
</span><span class="c1"></span>	<span class="c1">// abc+def+ghi   abc+def+ghi   abc+def+   abc+
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="func-regexp-split">func (*Regexp) Split</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">func (re *Regexp) Split(s string, n int) []string</pre></td></tr></table>
</div>
</div>
<p>Split将re在s中匹配到的结果作为分隔符将s分割成多个字符串，并返回这些正则匹配结果之间的字符串的切片。</p>

<p>返回的切片不会包含正则匹配的结果，只包含匹配结果之间的片段。当正则表达式re中不含正则元字符时，本方法等价于strings.SplitN。</p>

<p>举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">s := regexp.MustCompile(&#34;a*&#34;).Split(&#34;abaabaccadaaae&#34;, 5)
// s: [&#34;&#34;, &#34;b&#34;, &#34;b&#34;, &#34;c&#34;, &#34;cadaaae&#34;]</pre></td></tr></table>
</div>
</div>
<p>参数n绝对返回的子字符串的数量：</p>

<p>n &gt; 0 : 返回最多n个子字符串，最后一个子字符串是剩余未进行分割的部分。</p>

<p>n == 0: 返回nil (zero substrings)</p>

<p>n &lt; 0 : 返回所有子字符串</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-11-15
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/Go%E6%A0%87%E5%87%86%E5%BA%93/">Go标准库</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/scp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">scp命令详解</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/os%E5%8C%85%E8%A7%A3%E6%9E%90/">
            <span class="next-text nav-default">os包解析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
