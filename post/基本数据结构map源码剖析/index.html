<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ | Forz Blog</title>
<meta name="keywords" content="Goæºç " />
<meta name="description" content="å‰è¨€ æœ¬èŠ‚ä¼šä»‹ç» Go è¯­è¨€çš„å“ˆå¸Œçš„å®ç°åŸç†ï¼Œå“ˆå¸Œæ˜¯é™¤äº†æ•°ç»„ä¹‹å¤–ï¼Œæœ€å¸¸è§çš„æ•°æ®ç»“æ„ã€‚å‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½ä¼šæœ‰æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸¤ç§é›†åˆå…ƒç´ ï¼Œæœ‰çš„è¯­è¨€å°†æ•°ç»„å®ç°">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ" />
<meta property="og:description" content="å‰è¨€ æœ¬èŠ‚ä¼šä»‹ç» Go è¯­è¨€çš„å“ˆå¸Œçš„å®ç°åŸç†ï¼Œå“ˆå¸Œæ˜¯é™¤äº†æ•°ç»„ä¹‹å¤–ï¼Œæœ€å¸¸è§çš„æ•°æ®ç»“æ„ã€‚å‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½ä¼šæœ‰æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸¤ç§é›†åˆå…ƒç´ ï¼Œæœ‰çš„è¯­è¨€å°†æ•°ç»„å®ç°" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-01T20:22:12&#43;00:00" />
<meta property="article:modified_time" content="2021-07-01T20:22:12&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ"/>
<meta name="twitter:description" content="å‰è¨€ æœ¬èŠ‚ä¼šä»‹ç» Go è¯­è¨€çš„å“ˆå¸Œçš„å®ç°åŸç†ï¼Œå“ˆå¸Œæ˜¯é™¤äº†æ•°ç»„ä¹‹å¤–ï¼Œæœ€å¸¸è§çš„æ•°æ®ç»“æ„ã€‚å‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½ä¼šæœ‰æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸¤ç§é›†åˆå…ƒç´ ï¼Œæœ‰çš„è¯­è¨€å°†æ•°ç»„å®ç°"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ",
      "item": "/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ",
  "name": "åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ",
  "description": "å‰è¨€ æœ¬èŠ‚ä¼šä»‹ç» Go è¯­è¨€çš„å“ˆå¸Œçš„å®ç°åŸç†ï¼Œå“ˆå¸Œæ˜¯é™¤äº†æ•°ç»„ä¹‹å¤–ï¼Œæœ€å¸¸è§çš„æ•°æ®ç»“æ„ã€‚å‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½ä¼šæœ‰æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸¤ç§é›†åˆå…ƒç´ ï¼Œæœ‰çš„è¯­è¨€å°†æ•°ç»„å®ç°",
  "keywords": [
    "Goæºç "
  ],
  "articleBody": "å‰è¨€ æœ¬èŠ‚ä¼šä»‹ç» Go è¯­è¨€çš„å“ˆå¸Œçš„å®ç°åŸç†ï¼Œå“ˆå¸Œæ˜¯é™¤äº†æ•°ç»„ä¹‹å¤–ï¼Œæœ€å¸¸è§çš„æ•°æ®ç»“æ„ã€‚å‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½ä¼šæœ‰æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸¤ç§é›†åˆå…ƒç´ ï¼Œæœ‰çš„è¯­è¨€å°†æ•°ç»„å®ç°æˆåˆ—è¡¨ï¼Œè€Œæœ‰çš„è¯­è¨€å°†å“ˆå¸Œç§°ä½œå­—å…¸æˆ–è€…æ˜ å°„ã€‚æ— è®ºå¦‚ä½•å‘½åæˆ–è€…å¦‚ä½•å®ç°ï¼Œæ•°ç»„å’Œå“ˆå¸Œæ˜¯ä¸¤ç§è®¾è®¡é›†åˆå…ƒç´ çš„æ€è·¯ï¼Œæ•°ç»„ç”¨äºè¡¨ç¤ºå…ƒç´ çš„åºåˆ—ï¼Œè€Œå“ˆå¸Œè¡¨ç¤ºçš„æ˜¯é”®å€¼å¯¹ä¹‹é—´æ˜ å°„å…³ç³»ã€‚\nå“ˆå¸Œè¡¨æ˜¯ä¸€ç§å¤è€çš„æ•°æ®ç»“æ„ï¼Œåœ¨ 1953 å¹´å°±æœ‰äººä½¿ç”¨æ‹‰é“¾æ³•å®ç°äº†å“ˆå¸Œè¡¨ï¼Œå®ƒèƒ½å¤Ÿé€šè¿‡é”®ç›´æ¥è·å–è¯¥é”®å¯¹åº”çš„å€¼ã€‚\nè®¾è®¡åŸç† å“ˆå¸Œè¡¨æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„æœ€é‡è¦æ•°æ®ç»“æ„ä¹‹ä¸€ï¼Œè¿™ä¸ä»…å› ä¸ºå®ƒ ğ‘‚(1) çš„è¯»å†™æ€§èƒ½éå¸¸ä¼˜ç§€ï¼Œè¿˜å› ä¸ºå®ƒæä¾›äº†é”®å€¼ä¹‹é—´çš„æ˜ å°„ã€‚æƒ³è¦å®ç°ä¸€ä¸ªæ€§èƒ½ä¼˜å¼‚çš„å“ˆå¸Œè¡¨ï¼Œéœ€è¦æ³¨æ„ä¸¤ä¸ªå…³é”®ç‚¹ â€”â€” å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³æ–¹æ³•ã€‚\nå“ˆå¸Œå‡½æ•° å®ç°å“ˆå¸Œè¡¨çš„å…³é”®ç‚¹åœ¨äºå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©ï¼Œå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šèƒ½å¤Ÿå†³å®šå“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°åº”è¯¥èƒ½å¤Ÿå°†ä¸åŒé”®æ˜ å°„åˆ°ä¸åŒçš„ç´¢å¼•ä¸Šï¼Œè¿™è¦æ±‚å“ˆå¸Œå‡½æ•°çš„è¾“å‡ºèŒƒå›´å¤§äºè¾“å…¥èŒƒå›´ï¼Œä½†æ˜¯ç”±äºé”®çš„æ•°é‡ä¼šè¿œè¿œå¤§äºæ˜ å°„çš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œè¿™ä¸ªç†æƒ³çš„æ•ˆæœæ˜¯ä¸å¯èƒ½å®ç°çš„ã€‚\næ¯”è¾ƒå®é™…çš„æ–¹å¼æ˜¯è®©å“ˆå¸Œå‡½æ•°çš„ç»“æœèƒ½å¤Ÿå°½å¯èƒ½çš„å‡åŒ€åˆ†å¸ƒï¼Œç„¶åé€šè¿‡å·¥ç¨‹ä¸Šçš„æ‰‹æ®µè§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜ã€‚å“ˆå¸Œå‡½æ•°æ˜ å°„çš„ç»“æœä¸€å®šè¦å°½å¯èƒ½å‡åŒ€ï¼Œç»“æœä¸å‡åŒ€çš„å“ˆå¸Œå‡½æ•°ä¼šå¸¦æ¥æ›´å¤šçš„å“ˆå¸Œå†²çªä»¥åŠæ›´å·®çš„è¯»å†™æ€§èƒ½ã€‚\nå¦‚æœä½¿ç”¨ç»“æœåˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„å“ˆå¸Œå‡½æ•°ï¼Œé‚£ä¹ˆå“ˆå¸Œçš„å¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(1)ï¼›ä½†æ˜¯å¦‚æœå“ˆå¸Œå‡½æ•°çš„ç»“æœåˆ†å¸ƒä¸å‡åŒ€ï¼Œé‚£ä¹ˆæ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å¯èƒ½ä¼šè¾¾åˆ° ğ‘‚(ğ‘›)ï¼Œç”±æ­¤çœ‹æ¥ï¼Œä½¿ç”¨å¥½çš„å“ˆå¸Œå‡½æ•°æ˜¯è‡³å…³é‡è¦çš„ã€‚\nå†²çªè§£å†³ å°±åƒæˆ‘ä»¬ä¹‹å‰æ‰€æåˆ°çš„ï¼Œåœ¨é€šå¸¸æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°è¾“å…¥çš„èŒƒå›´ä¸€å®šä¼šè¿œè¿œå¤§äºè¾“å‡ºçš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨å“ˆå¸Œè¡¨æ—¶ä¸€å®šä¼šé‡åˆ°å†²çªï¼Œå“ªæ€•æˆ‘ä»¬ä½¿ç”¨äº†å®Œç¾çš„å“ˆå¸Œå‡½æ•°ï¼Œå½“è¾“å…¥çš„é”®è¶³å¤Ÿå¤šä¹Ÿä¼šäº§ç”Ÿå†²çªã€‚ç„¶è€Œå¤šæ•°çš„å“ˆå¸Œå‡½æ•°éƒ½æ˜¯ä¸å¤Ÿå®Œç¾çš„ï¼Œæ‰€ä»¥ä»ç„¶å­˜åœ¨å‘ç”Ÿå“ˆå¸Œç¢°æ’çš„å¯èƒ½ï¼Œè¿™æ—¶å°±éœ€è¦ä¸€äº›æ–¹æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜ï¼Œå¸¸è§æ–¹æ³•çš„å°±æ˜¯å¼€æ”¾å¯»å€æ³•å’Œæ‹‰é“¾æ³•ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæåˆ°çš„å“ˆå¸Œç¢°æ’ä¸æ˜¯å¤šä¸ªé”®å¯¹åº”çš„å“ˆå¸Œå®Œå…¨ç›¸ç­‰ï¼Œå¯èƒ½æ˜¯å¤šä¸ªå“ˆå¸Œçš„éƒ¨åˆ†ç›¸ç­‰ï¼Œä¾‹å¦‚ï¼šä¸¤ä¸ªé”®å¯¹åº”å“ˆå¸Œçš„å‰å››ä¸ªå­—èŠ‚ç›¸åŒã€‚\nå¼€æ”¾å¯»å€æ³• å¼€æ”¾å¯»å€æ³•æ˜¯ä¸€ç§åœ¨å“ˆå¸Œè¡¨ä¸­è§£å†³å“ˆå¸Œç¢°æ’çš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä¾æ¬¡æ¢æµ‹å’Œæ¯”è¾ƒæ•°ç»„ä¸­çš„å…ƒç´ ä»¥åˆ¤æ–­ç›®æ ‡é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨å¼€æ”¾å¯»å€æ³•æ¥å®ç°å“ˆå¸Œè¡¨ï¼Œé‚£ä¹ˆå®ç°å“ˆå¸Œè¡¨åº•å±‚çš„æ•°æ®ç»“æ„å°±æ˜¯æ•°ç»„ï¼Œä¸è¿‡å› ä¸ºæ•°ç»„çš„é•¿åº¦æœ‰é™ï¼Œå‘å“ˆå¸Œè¡¨å†™å…¥ (author, draven) è¿™ä¸ªé”®å€¼å¯¹æ—¶ä¼šä»å¦‚ä¸‹çš„ç´¢å¼•å¼€å§‹éå†ï¼š\n1  index := hash(\"author\") % array.len   å½“æˆ‘ä»¬å‘å½“å‰å“ˆå¸Œè¡¨å†™å…¥æ–°çš„æ•°æ®æ—¶ï¼Œå¦‚æœå‘ç”Ÿäº†å†²çªï¼Œå°±ä¼šå°†é”®å€¼å¯¹å†™å…¥åˆ°ä¸‹ä¸€ä¸ªç´¢å¼•ä¸ä¸ºç©ºçš„ä½ç½®ï¼š\nå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå½“ Key3 ä¸å·²ç»å­˜å…¥å“ˆå¸Œè¡¨ä¸­çš„ä¸¤ä¸ªé”®å€¼å¯¹ Key1 å’Œ Key2 å‘ç”Ÿå†²çªæ—¶ï¼ŒKey3 ä¼šè¢«å†™å…¥ Key2 åé¢çš„ç©ºé—²ä½ç½®ã€‚å½“æˆ‘ä»¬å†å»è¯»å– Key3 å¯¹åº”çš„å€¼æ—¶å°±ä¼šå…ˆè·å–é”®çš„å“ˆå¸Œå¹¶å–æ¨¡ï¼Œè¿™ä¼šå…ˆå¸®åŠ©æˆ‘ä»¬æ‰¾åˆ° Key1ï¼Œæ‰¾åˆ° Key1 åå‘ç°å®ƒä¸ Key 3 ä¸ç›¸ç­‰ï¼Œæ‰€ä»¥ä¼šç»§ç»­æŸ¥æ‰¾åé¢çš„å…ƒç´ ï¼Œç›´åˆ°å†…å­˜ä¸ºç©ºæˆ–è€…æ‰¾åˆ°ç›®æ ‡å…ƒç´ ã€‚\nå½“éœ€è¦æŸ¥æ‰¾æŸä¸ªé”®å¯¹åº”çš„å€¼æ—¶ï¼Œä¼šä»ç´¢å¼•çš„ä½ç½®å¼€å§‹çº¿æ€§æ¢æµ‹æ•°ç»„ï¼Œæ‰¾åˆ°ç›®æ ‡é”®å€¼å¯¹æˆ–è€…ç©ºå†…å­˜å°±æ„å‘³ç€è¿™ä¸€æ¬¡æŸ¥è¯¢æ“ä½œçš„ç»“æŸã€‚\nå¼€æ”¾å¯»å€æ³•ä¸­å¯¹æ€§èƒ½å½±å“æœ€å¤§çš„æ˜¯è£…è½½å› å­ï¼Œå®ƒæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ä¸æ•°ç»„å¤§å°çš„æ¯”å€¼ã€‚éšç€è£…è½½å› å­çš„å¢åŠ ï¼Œçº¿æ€§æ¢æµ‹çš„å¹³å‡ç”¨æ—¶å°±ä¼šé€æ¸å¢åŠ ï¼Œè¿™ä¼šå½±å“å“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚å½“è£…è½½ç‡è¶…è¿‡ 70% ä¹‹åï¼Œå“ˆå¸Œè¡¨çš„æ€§èƒ½å°±ä¼šæ€¥å‰§ä¸‹é™ï¼Œè€Œä¸€æ—¦è£…è½½ç‡è¾¾åˆ° 100%ï¼Œæ•´ä¸ªå“ˆå¸Œè¡¨å°±ä¼šå®Œå…¨å¤±æ•ˆï¼Œè¿™æ—¶æŸ¥æ‰¾å’Œæ’å…¥ä»»æ„å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ ğ‘‚(ğ‘›) çš„ï¼Œè¿™æ—¶éœ€è¦éå†æ•°ç»„ä¸­çš„å…¨éƒ¨å…ƒç´ ï¼Œæ‰€ä»¥åœ¨å®ç°å“ˆå¸Œè¡¨æ—¶ä¸€å®šè¦å…³æ³¨è£…è½½å› å­çš„å˜åŒ–ã€‚\næ‹‰é“¾æ³• ä¸å¼€æ”¾åœ°å€æ³•ç›¸æ¯”ï¼Œæ‹‰é“¾æ³•æ˜¯å“ˆå¸Œè¡¨æœ€å¸¸è§çš„å®ç°æ–¹æ³•ï¼Œå¤§å¤šæ•°çš„ç¼–ç¨‹è¯­è¨€éƒ½ç”¨æ‹‰é“¾æ³•å®ç°å“ˆå¸Œè¡¨ï¼Œå®ƒçš„å®ç°æ¯”è¾ƒå¼€æ”¾åœ°å€æ³•ç¨å¾®å¤æ‚ä¸€äº›ï¼Œä½†æ˜¯å¹³å‡æŸ¥æ‰¾çš„é•¿åº¦ä¹Ÿæ¯”è¾ƒçŸ­ï¼Œå„ä¸ªç”¨äºå­˜å‚¨èŠ‚ç‚¹çš„å†…å­˜éƒ½æ˜¯åŠ¨æ€ç”³è¯·çš„ï¼Œå¯ä»¥èŠ‚çœæ¯”è¾ƒå¤šçš„å­˜å‚¨ç©ºé—´ã€‚\nå®ç°æ‹‰é“¾æ³•ä¸€èˆ¬ä¼šä½¿ç”¨æ•°ç»„åŠ ä¸Šé“¾è¡¨ï¼Œä¸è¿‡ä¸€äº›ç¼–ç¨‹è¯­è¨€ä¼šåœ¨æ‹‰é“¾æ³•çš„å“ˆå¸Œä¸­å¼•å…¥çº¢é»‘æ ‘ä»¥ä¼˜åŒ–æ€§èƒ½ï¼Œæ‹‰é“¾æ³•ä¼šä½¿ç”¨é“¾è¡¨æ•°ç»„ä½œä¸ºå“ˆå¸Œåº•å±‚çš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒçœ‹æˆå¯ä»¥æ‰©å±•çš„äºŒç»´æ•°ç»„ï¼š\nå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå½“æˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªé”®å€¼å¯¹ (Key6, Value6) å†™å…¥å“ˆå¸Œè¡¨æ—¶ï¼Œé”®å€¼å¯¹ä¸­çš„é”® Key6 éƒ½ä¼šå…ˆç»è¿‡ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼Œå“ˆå¸Œå‡½æ•°è¿”å›çš„å“ˆå¸Œä¼šå¸®åŠ©æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæ¡¶ï¼Œå’Œå¼€æ”¾åœ°å€æ³•ä¸€æ ·ï¼Œé€‰æ‹©æ¡¶çš„æ–¹å¼æ˜¯ç›´æ¥å¯¹å“ˆå¸Œè¿”å›çš„ç»“æœå–æ¨¡ï¼š\n1  index := hash(\"Key6\") % array.len   é€‰æ‹©äº† 2 å·æ¡¶åå°±å¯ä»¥éå†å½“å‰æ¡¶ä¸­çš„é“¾è¡¨äº†ï¼Œåœ¨éå†é“¾è¡¨çš„è¿‡ç¨‹ä¸­ä¼šé‡åˆ°ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š\n æ‰¾åˆ°é”®ç›¸åŒçš„é”®å€¼å¯¹ â€” æ›´æ–°é”®å¯¹åº”çš„å€¼ï¼› æ²¡æœ‰æ‰¾åˆ°é”®ç›¸åŒçš„é”®å€¼å¯¹ â€” åœ¨é“¾è¡¨çš„æœ«å°¾è¿½åŠ æ–°çš„é”®å€¼å¯¹ï¼›  å¦‚æœè¦åœ¨å“ˆå¸Œè¡¨ä¸­è·å–æŸä¸ªé”®å¯¹åº”çš„å€¼ï¼Œä¼šç»å†å¦‚ä¸‹çš„è¿‡ç¨‹ï¼š\nKey11 å±•ç¤ºäº†ä¸€ä¸ªé”®åœ¨å“ˆå¸Œè¡¨ä¸­ä¸å­˜åœ¨çš„ä¾‹å­ï¼Œå½“å“ˆå¸Œè¡¨å‘ç°å®ƒå‘½ä¸­ 4 å·æ¡¶æ—¶ï¼Œå®ƒä¼šä¾æ¬¡éå†æ¡¶ä¸­çš„é“¾è¡¨ï¼Œç„¶è€Œéå†åˆ°é“¾è¡¨çš„æœ«å°¾ä¹Ÿæ²¡æœ‰æ‰¾åˆ°æœŸæœ›çš„é”®ï¼Œæ‰€ä»¥å“ˆå¸Œè¡¨ä¸­æ²¡æœ‰è¯¥é”®å¯¹åº”çš„å€¼ã€‚\nåœ¨ä¸€ä¸ªæ€§èƒ½æ¯”è¾ƒå¥½çš„å“ˆå¸Œè¡¨ä¸­ï¼Œæ¯ä¸€ä¸ªæ¡¶ä¸­éƒ½åº”è¯¥æœ‰ 0~1 ä¸ªå…ƒç´ ï¼Œæœ‰æ—¶ä¼šæœ‰ 2~3 ä¸ªï¼Œå¾ˆå°‘ä¼šè¶…è¿‡è¿™ä¸ªæ•°é‡ã€‚è®¡ç®—å“ˆå¸Œã€å®šä½æ¡¶å’Œéå†é“¾è¡¨ä¸‰ä¸ªè¿‡ç¨‹æ˜¯å“ˆå¸Œè¡¨è¯»å†™æ“ä½œçš„ä¸»è¦å¼€é”€ï¼Œä½¿ç”¨æ‹‰é“¾æ³•å®ç°çš„å“ˆå¸Œä¹Ÿæœ‰è£…è½½å› å­è¿™ä¸€æ¦‚å¿µï¼š\n1  è£…è½½å› å­:=å…ƒç´ æ•°é‡Ã·æ¡¶æ•°é‡   ä¸å¼€æ”¾åœ°å€æ³•ä¸€æ ·ï¼Œæ‹‰é“¾æ³•çš„è£…è½½å› å­è¶Šå¤§ï¼Œå“ˆå¸Œçš„è¯»å†™æ€§èƒ½å°±è¶Šå·®ã€‚åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ä½¿ç”¨æ‹‰é“¾æ³•çš„å“ˆå¸Œè¡¨è£…è½½å› å­éƒ½ä¸ä¼šè¶…è¿‡ 1ï¼Œå½“å“ˆå¸Œè¡¨çš„è£…è½½å› å­è¾ƒå¤§æ—¶ä¼šè§¦å‘å“ˆå¸Œçš„æ‰©å®¹ï¼Œåˆ›å»ºæ›´å¤šçš„æ¡¶æ¥å­˜å‚¨å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œä¿è¯æ€§èƒ½ä¸ä¼šå‡ºç°ä¸¥é‡çš„ä¸‹é™ã€‚å¦‚æœæœ‰ 1000 ä¸ªæ¡¶çš„å“ˆå¸Œè¡¨å­˜å‚¨äº† 10000 ä¸ªé”®å€¼å¯¹ï¼Œå®ƒçš„æ€§èƒ½æ˜¯ä¿å­˜ 1000 ä¸ªé”®å€¼å¯¹çš„ 1/10ï¼Œä½†æ˜¯ä»ç„¶æ¯”åœ¨é“¾è¡¨ä¸­ç›´æ¥è¯»å†™å¥½ 1000 å€ã€‚\nhmap Go è¯­è¨€è¿è¡Œæ—¶åŒæ—¶ä½¿ç”¨äº†å¤šä¸ªæ•°æ®ç»“æ„ç»„åˆè¡¨ç¤ºå“ˆå¸Œè¡¨ï¼Œå…¶ä¸­ runtime.hmap æ˜¯æœ€æ ¸å¿ƒçš„ç»“æ„ä½“ï¼Œå®ƒæ˜¯ hashmap çš„â€œç¼©å†™â€,æˆ‘ä»¬å…ˆæ¥äº†è§£ä¸€ä¸‹è¯¥ç»“æ„ä½“çš„å†…éƒ¨å­—æ®µï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. \t// Make sure this stays in sync with the compiler's definition. \t// å…ƒç´ ä¸ªæ•°ï¼Œè°ƒç”¨ len(map) æ—¶ï¼Œç›´æ¥è¿”å›æ­¤å€¼ \tcount int // # live cells == size of map. Must be first (used by len() builtin) \t//æ ‡å¿—ä½ \t// iterator = 1 // å¯èƒ½æœ‰éå†ç”¨buckets \t// oldIterator = 2 // å¯èƒ½æœ‰éå†ç”¨oldbucketsï¼Œç”¨äºæ‰©å®¹æœŸé—´ \t// hashWriting = 4 // æ ‡è®°å†™ï¼Œç”¨äºå¹¶å‘è¯»å†™æ£€æµ‹ \t// sameSizeGrow = 8 // ç”¨äºç­‰å¤§å°bucketsæ‰©å®¹ï¼Œå‡å°‘overflowæ¡¶ \tflags uint8 // buckets çš„å¯¹æ•° log_2 \t// B è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨æŒæœ‰çš„ buckets æ•°é‡ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼Œæ‰€ä»¥è¯¥å­—æ®µä¼šå­˜å‚¨å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯ `len(buckets) == 2^B`ï¼› \tB uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) \t// overflow çš„ bucket è¿‘ä¼¼æ•° \tnoverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details \t// è®¡ç®— key çš„å“ˆå¸Œçš„æ—¶å€™ä¼šä¼ å…¥å“ˆå¸Œå‡½æ•° \t// hash0 æ˜¯å“ˆå¸Œçš„ç§å­ï¼Œå®ƒèƒ½ä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ï¼Œè¿™ä¸ªå€¼åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥ï¼› \thash0 uint32 // hash seed \t// æŒ‡å‘ buckets æ•°ç»„ï¼Œå¤§å°ä¸º 2^B  // å¦‚æœå…ƒç´ ä¸ªæ•°ä¸º0ï¼Œå°±ä¸º nil \t// æŒ‡å‘ç¬¬ä¸€ä¸ªæ¡¶çš„æŒ‡é’ˆ æ˜¯ä¸€ä¸ªè¿ç»­çš„åœ°å€ å› ä¸ºæ˜¯ä¸ªæ•°ç»„  // è¿™é‡Œé¢å­˜çš„æ˜¯ *bmap \tbuckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. \t// æ‰©å®¹çš„æ—¶å€™ï¼Œbuckets é•¿åº¦ä¼šæ˜¯ oldbuckets çš„ä¸¤å€ \t// oldbuckets æ˜¯å“ˆå¸Œåœ¨æ‰©å®¹æ—¶ç”¨äºä¿å­˜ä¹‹å‰ buckets çš„å­—æ®µï¼Œå®ƒçš„å¤§å°æ˜¯å½“å‰ buckets çš„ä¸€åŠ \t// æ—§æ¡¶ç¬¬ä¸€ä¸ªæ¡¶çš„æŒ‡é’ˆï¼Œç”¨äºåœ¨æ‰©å®¹æ¬è¿çš„æ—¶å€™æœªå®Œæˆæ¬è¿æ—¶ä¿å­˜ä¹‹å‰çš„æ—§æ¡¶ \toldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing \t// æŒ‡ç¤ºæ‰©å®¹è¿›åº¦ï¼Œå°äºæ­¤åœ°å€çš„ buckets è¿ç§»å®Œæˆ \t// æ¬è¿æ¡¶çš„è¿›åº¦ å°±æ˜¯å¤„äºæ‰©å®¹æ¬è¿æ—¶ï¼Œç›®å‰æ¬åˆ°å“ªäº† \tnevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) \t// æº¢å‡ºæ¡¶ å½“bmapä¸­å­˜å‚¨çš„æ•°æ®è¿‡å¤š  // å•ä¸ªbmapå·²ç»è£…æ»¡æ—¶å°±ä¼šä½¿ç”¨ extra.nextOverflow ä¸­æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ã€‚  // æº¢å‡ºæ¡¶ä¸ä¸€å®šä¼šä½¿ç”¨ï¼Œå› ä¸ºä»–æ˜¯ä¸ªå¯é€‰å­—æ®µ \textra *mapextra // optional fields }   Mapçš„æœ€å¤§æ¡¶çš„æ•°é‡ä¸º2^255ä¸ªï¼Œå› ä¸ºhmap.Bä¸ºuint8ç±»å‹ï¼Œæœ€å¤§å€¼ä¸º255.\næ¡¶çš„æ•°é‡æ˜¯2^Bä¸ª\nbmap å“ˆå¸Œè¡¨ runtime.hmap çš„æ¡¶æ˜¯ runtime.bmapã€‚æ¯ä¸€ä¸ª runtime.bmap éƒ½èƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œå½“å“ˆå¸Œè¡¨ä¸­å­˜å‚¨çš„æ•°æ®è¿‡å¤šï¼Œå•ä¸ªæ¡¶å·²ç»è£…æ»¡æ—¶å°±ä¼šä½¿ç”¨ extra.nextOverflow ä¸­æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ã€‚\nä¸Šè¿°ä¸¤ç§ä¸åŒçš„æ¡¶åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°†å®ƒä»¬åˆ†åˆ«ç§°ä¸ºæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œä¸Šå›¾ä¸­é»„è‰²çš„ runtime.bmap å°±æ˜¯æ­£å¸¸æ¡¶ï¼Œç»¿è‰²çš„ runtime.bmap æ˜¯æº¢å‡ºæ¡¶ï¼Œæº¢å‡ºæ¡¶æ˜¯åœ¨ Go è¯­è¨€è¿˜ä½¿ç”¨ C è¯­è¨€å®ç°æ—¶ä½¿ç”¨çš„è®¾è®¡ï¼Œç”±äºå®ƒèƒ½å¤Ÿå‡å°‘æ‰©å®¹çš„é¢‘ç‡æ‰€ä»¥ä¸€ç›´ä½¿ç”¨è‡³ä»Šã€‚\næ¡¶çš„ç»“æ„ä½“ runtime.bmap åœ¨ Go è¯­è¨€æºä»£ç ä¸­çš„å®šä¹‰åªåŒ…å«ä¸€ä¸ªç®€å•çš„ tophash å­—æ®µï¼Œtophash å­˜å‚¨äº†é”®çš„å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œé€šè¿‡æ¯”è¾ƒä¸åŒé”®çš„å“ˆå¸Œçš„é«˜ 8 ä½å¯ä»¥å‡å°‘è®¿é—®é”®å€¼å¯¹æ¬¡æ•°ä»¥æé«˜æ€§èƒ½ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Maximum number of key/elem pairs a bucket can hold. bucketCntBits = 3 bucketCnt = 1  bucketCntBits // A bucket for a Go map. type bmap struct { // è®°å½•æ¡¶å†…8ä¸ªå•å…ƒçš„é«˜8ä½hashå€¼ï¼Œæˆ–æ ‡è®°ç©ºæ¡¶çŠ¶æ€ï¼Œç”¨äºå¿«é€Ÿå®šä½key \t// emptyRest = 0 // æ­¤å•å…ƒä¸ºç©ºï¼Œä¸”æ›´é«˜ç´¢å¼•çš„å•å…ƒä¹Ÿä¸ºç©º \t// emptyOne = 1 // æ­¤å•å…ƒä¸ºç©º \t// evacuatedX = 2 // ç”¨äºè¡¨ç¤ºæ‰©å®¹è¿ç§»åˆ°æ–°æ¡¶å‰åŠæ®µåŒºé—´ \t// evacuatedY = 3 // ç”¨äºè¡¨ç¤ºæ‰©å®¹è¿ç§»åˆ°æ–°æ¡¶ååŠæ®µåŒºé—´ \t// evacuatedEmpty = 4 // ç”¨äºè¡¨ç¤ºæ­¤å•å…ƒå·²è¿ç§» \t// minTopHash = 5 // æœ€å°çš„ç©ºæ¡¶æ ‡è®°å€¼ï¼Œå°äºå…¶åˆ™æ˜¯ç©ºæ¡¶æ ‡å¿— \t// tophash generally contains the top byte of the hash value \t// for each key in this bucket. If tophash[0] \t// tophash[0] is a bucket evacuation state instead. \ttophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. \t// NOTE: packing all the keys together and then all the elems together makes the \t// code a bit more complicated than alternating key/elem/key/elem/... but it allows \t// us to eliminate padding which would be needed for, e.g., map[int64]int8. \t// Followed by an overflow pointer. }   åœ¨è¿è¡ŒæœŸé—´ï¼Œruntime.bmap ç»“æ„ä½“å…¶å®ä¸æ­¢åŒ…å« tophash å­—æ®µï¼Œå› ä¸ºå“ˆå¸Œè¡¨ä¸­å¯èƒ½å­˜å‚¨ä¸åŒç±»å‹çš„é”®å€¼å¯¹ï¼Œè€Œä¸” Go è¯­è¨€ä¹Ÿä¸æ”¯æŒæ³›å‹ï¼Œæ‰€ä»¥é”®å€¼å¯¹å æ®çš„å†…å­˜ç©ºé—´å¤§å°åªèƒ½åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ¨å¯¼ã€‚runtime.bmap ä¸­çš„å…¶ä»–å­—æ®µåœ¨è¿è¡Œæ—¶ä¹Ÿéƒ½æ˜¯é€šè¿‡è®¡ç®—å†…å­˜åœ°å€çš„æ–¹å¼è®¿é—®çš„ï¼Œæ‰€ä»¥å®ƒçš„å®šä¹‰ä¸­å°±ä¸åŒ…å«è¿™äº›å­—æ®µï¼Œä¸è¿‡æˆ‘ä»¬èƒ½æ ¹æ®ç¼–è¯‘æœŸé—´çš„ cmd/compile/internal/gc.bmap å‡½æ•°é‡å»ºå®ƒçš„ç»“æ„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // å®é™…å­˜å‚¨kï¼Œvæ•°æ®çš„æ¡¶ // è¯¥ç»“æ„ä½“è¿˜æœ‰ä¸€äº›å­—æ®µä¼šåœ¨ç¼–è¯‘æœŸæ·»åŠ  // æ¯”å¦‚ ä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶çš„åœ°å€ // keyï¼Œvalueæ‰€å¤„çš„åœ°å€ç­‰ type bmap struct { // è¿™é‡Œå­˜å‚¨å¯ Keyçš„å“ˆå¸Œå€¼çš„é«˜8ä½ ä¾‹å­ 11111111 00000000  // ç”¨äºåœ¨æŸ¥æ‰¾æ—¶å¿«é€Ÿçš„å»åˆ¤æ–­å½“å‰Keyæ˜¯å¦å­˜åœ¨è¿™ä¸ªæ¡¶é‡Œ  // å› æ­¤å¾—å‡ºï¼Œæ¯ä¸ªæ¡¶åªèƒ½å­˜æ”¾8ä¸ªKey-Valueæ˜ å°„  topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr // overflow æ¡¶  // otyp ç±»å‹ä¸ºæŒ‡é’ˆ*Type,  // è‹¥keytypeåŠelemtypeä¸å«æŒ‡é’ˆï¼Œåˆ™ä¸ºuintptr  // ä½¿bmapæ•´ä½“ä¸å«æŒ‡é’ˆ,é¿å…gcå»scanæ­¤ç±»map  overflow uintptr }   éšç€å“ˆå¸Œè¡¨å­˜å‚¨çš„æ•°æ®é€æ¸å¢å¤šï¼Œæˆ‘ä»¬ä¼šæ‰©å®¹å“ˆå¸Œè¡¨æˆ–è€…ä½¿ç”¨é¢å¤–çš„æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ï¼Œä¸ä¼šè®©å•ä¸ªæ¡¶ä¸­çš„æ•°æ®è¶…è¿‡ 8 ä¸ªï¼Œä¸è¿‡æº¢å‡ºæ¡¶åªæ˜¯ä¸´æ—¶çš„è§£å†³æ–¹æ¡ˆï¼Œåˆ›å»ºè¿‡å¤šçš„æº¢å‡ºæ¡¶æœ€ç»ˆä¹Ÿä¼šå¯¼è‡´å“ˆå¸Œçš„æ‰©å®¹ã€‚\nbmap æ˜¯å­˜æ”¾ k-v çš„åœ°æ–¹ï¼Œæˆ‘ä»¬æŠŠè§†è§’æ‹‰è¿‘ï¼Œä»”ç»†çœ‹ bmap çš„å†…éƒ¨ç»„æˆã€‚\nä¸Šå›¾å°±æ˜¯ bucket çš„å†…å­˜æ¨¡å‹ï¼ŒHOB Hash æŒ‡çš„å°±æ˜¯ top hashã€‚ æ³¨æ„åˆ° key å’Œ value æ˜¯å„è‡ªæ”¾åœ¨ä¸€èµ·çš„ï¼Œå¹¶ä¸æ˜¯ key/value/key/value/â€¦ è¿™æ ·çš„å½¢å¼ã€‚æºç é‡Œè¯´æ˜è¿™æ ·çš„å¥½å¤„æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥çœç•¥æ‰ padding å­—æ®µï¼ŒèŠ‚çœå†…å­˜ç©ºé—´ã€‚\nä¾‹å¦‚ï¼Œæœ‰è¿™æ ·ä¸€ä¸ªç±»å‹çš„ mapï¼š\n1  map[int64]int8   å¦‚æœæŒ‰ç…§ key/value/key/value/... è¿™æ ·çš„æ¨¡å¼å­˜å‚¨ï¼Œé‚£åœ¨æ¯ä¸€ä¸ª key/value å¯¹ä¹‹åéƒ½è¦é¢å¤– padding 7 ä¸ªå­—èŠ‚ï¼›è€Œå°†æ‰€æœ‰çš„ keyï¼Œvalue åˆ†åˆ«ç»‘å®šåˆ°ä¸€èµ·ï¼Œè¿™ç§å½¢å¼ key/key/.../value/value/...ï¼Œåˆ™åªéœ€è¦åœ¨æœ€åæ·»åŠ  paddingã€‚\næ¯ä¸ª bucket è®¾è®¡æˆæœ€å¤šåªèƒ½æ”¾ 8 ä¸ª key-value å¯¹ï¼Œå¦‚æœæœ‰ç¬¬ 9 ä¸ª key-value è½å…¥å½“å‰çš„ bucketï¼Œé‚£å°±éœ€è¦å†æ„å»ºä¸€ä¸ª bucket ï¼Œé€šè¿‡ overflow æŒ‡é’ˆè¿æ¥èµ·æ¥ã€‚\næ­£å¸¸æƒ…å†µkeyå’Œelemç›´æ¥ä½¿ç”¨ç”¨æˆ·å£°æ˜çš„ç±»å‹ï¼Œä½†å½“å…¶sizeå¤§äº128(MAXKEYSIZE/MAXELEMSIZE)æ—¶ï¼Œåˆ™ä¼šè½¬ä¸ºæŒ‡é’ˆå»å­˜å‚¨ã€‚ï¼ˆä¹Ÿå°±æ˜¯indirectkeyã€indirectelemï¼‰\nmapextra å½“ map çš„ key å’Œ value éƒ½ä¸æ˜¯æŒ‡é’ˆï¼Œå¹¶ä¸” size éƒ½å°äº 128 å­—èŠ‚çš„æƒ…å†µä¸‹ï¼Œä¼šæŠŠ bmap æ ‡è®°ä¸ºä¸å«æŒ‡é’ˆï¼Œè¿™æ ·å¯ä»¥é¿å… gc æ—¶æ‰«ææ•´ä¸ª hmapã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬çœ‹ bmap å…¶å®æœ‰ä¸€ä¸ª overflow çš„å­—æ®µï¼Œæ˜¯æŒ‡é’ˆç±»å‹çš„ï¼Œç ´åäº† bmap ä¸å«æŒ‡é’ˆçš„è®¾æƒ³ï¼Œè¿™æ—¶ä¼šæŠŠ overflow ç§»åŠ¨åˆ° extra å­—æ®µæ¥ã€‚\nhmap.extraå…·ä½“æ˜¯ä¸ºè§£å†³è®©gcä¸éœ€è¦æ‰«ææ­¤ç±»bucketã€‚åªè¦bmapå†…ä¸å«æŒ‡é’ˆå°±ä¸éœ€gcæ‰«æã€‚\nå½“mapçš„keyå’Œelemç±»å‹éƒ½ä¸åŒ…å«æŒ‡é’ˆæ—¶ï¼Œä½†å…¶ä¸­çš„overflowæ˜¯æŒ‡é’ˆã€‚æ­¤æ—¶bmapçš„ç”Ÿæˆå‡½æ•°ä¼šå°†overflowçš„ç±»å‹è½¬åŒ–ä¸ºuintptrã€‚è€Œuintptrè™½ç„¶æ˜¯åœ°å€ï¼Œä½†ä¸ä¼šè¢«gcè®¤ä¸ºæ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘çš„æ•°æ®æœ‰è¢«å›æ”¶çš„é£é™©ã€‚\næ­¤æ—¶ä¸ºä¿è¯å…¶ä¸­çš„overflowæŒ‡é’ˆæŒ‡å‘çš„æ•°æ®å­˜æ´»ï¼Œå°±ç”¨mapextraç»“æ„æŒ‡å‘äº†è¿™äº›bucketsï¼Œè¿™æ ·bmapæœ‰è¢«å¼•ç”¨å°±ä¸ä¼šè¢«å›æ”¶äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // mapextra holds fields that are not present on all maps. type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket \t// type as containing no pointers. This avoids scanning such maps. \t// However, bmap.overflow is a pointer. In order to keep overflow buckets \t// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. \t// overflow and oldoverflow are only used if key and elem do not contain pointers. \t// overflow contains overflow buckets for hmap.buckets. \t// oldoverflow contains overflow buckets for hmap.oldbuckets. \t// The indirection allows to store a pointer to the slice in hiter. \t// å¦‚æœkeyå’Œvalueéƒ½ä¸åŒ…å«æŒ‡é’ˆï¼Œè€Œä¸”æ˜¯å†…è”çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†bucketç±»å‹æ ‡è®°ä¸ºä¸åŒ…å«æŒ‡é’ˆã€‚  // è¿™æ ·å°±é¿å…äº†å¯¹è¿™ç±»åœ°å›¾çš„æ‰«æã€‚  // ç„¶è€Œï¼Œbmap.overflow æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚ä¸ºäº†é˜²æ­¢æº¢å‡ºæ¡¶è¢«gcå¤„ç†  // æˆ‘ä»¬åœ¨hmap.extra.overflowå’Œhmap.extra.oldoverflowä¸­å­˜å‚¨æ‰€æœ‰æº¢å‡ºæ¡¶çš„æŒ‡é’ˆã€‚  // overflowå’Œoldoverflowåªåœ¨keyå’Œvalueä¸åŒ…å«æŒ‡é’ˆçš„æƒ…å†µä¸‹ä½¿ç”¨ \t// å­˜å‚¨ä¸€ä¸ªå·²ç»åˆ›å»ºå¥½äº†ä½†æ˜¯æš‚æœªä½¿ç”¨çš„ç©ºbmapæº¢å‡ºæ¡¶ \toverflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. \tnextOverflow *bmap }   maptype 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // map.goé‡Œå¾ˆå¤šå‡½æ•°çš„ç¬¬1ä¸ªå…¥å‚æ˜¯è¿™ä¸ªç»“æ„ï¼Œä»æˆå‘˜æ¥çœ‹å¾ˆæ˜æ˜¾ï¼Œæ­¤ç»“æ„æ ‡ç¤ºäº†é”®å€¼å¯¹å’Œæ¡¶çš„å¤§å°ç­‰å¿…è¦ä¿¡æ¯ // æœ‰äº†è¿™ä¸ªç»“æ„çš„ä¿¡æ¯ï¼Œmap.goçš„ä»£ç å°±å¯ä»¥ä¸é”®å€¼å¯¹çš„å…·ä½“æ•°æ®ç±»å‹è§£è€¦ // æ‰€ä»¥map.goç”¨å†…å­˜åç§»é‡å’Œunsafe.PointeræŒ‡é’ˆæ¥ç›´æ¥å¯¹å†…å­˜è¿›è¡Œå­˜å–ï¼Œè€Œæ— éœ€å…³å¿ƒkeyæˆ–valueçš„å…·ä½“ç±»å‹ type maptype struct { typ _type key *_type elem *_type bucket *_type // internal type representing a hash bucket \t// function for hashing keys (ptr to key, seed) - hash \thasher func(unsafe.Pointer, uintptr) uintptr keysize uint8 // size of key slot \telemsize uint8 // size of elem slot \tbucketsize uint16 // size of bucket \tflags uint32 }   makemap æ—¢ç„¶å·²ç»ä»‹ç»äº†å“ˆå¸Œè¡¨çš„åŸºæœ¬åŸç†å’Œå®ç°æ–¹æ³•ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¼€å§‹åˆ†æ Go è¯­è¨€ä¸­å“ˆå¸Œè¡¨çš„å®ç°äº†ï¼Œé¦–å…ˆè¦åˆ†æçš„æ˜¯ Go è¯­è¨€åˆå§‹åŒ–å“ˆå¸Œçš„ä¸¤ç§æ–¹æ³• â€” é€šè¿‡å­—é¢é‡å’Œè¿è¡Œæ—¶ã€‚\nç›®å‰çš„ç°ä»£ç¼–ç¨‹è¯­è¨€åŸºæœ¬éƒ½æ”¯æŒä½¿ç”¨å­—é¢é‡çš„æ–¹å¼åˆå§‹åŒ–å“ˆå¸Œï¼Œä¸€èˆ¬éƒ½ä¼šä½¿ç”¨ key: value çš„è¯­æ³•æ¥è¡¨ç¤ºé”®å€¼å¯¹ï¼ŒGo è¯­è¨€ä¸­ä¹Ÿä¸ä¾‹å¤–ï¼š\n1 2 3 4 5  hash := map[string]int{ \"1\": 2, \"3\": 4, \"5\": 6, }   æˆ‘ä»¬éœ€è¦åœ¨åˆå§‹åŒ–å“ˆå¸Œæ—¶å£°æ˜é”®å€¼å¯¹çš„ç±»å‹ï¼Œè¿™ç§ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–çš„æ–¹å¼æœ€ç»ˆéƒ½ä¼šé€šè¿‡ cmd/compile/internal/gc.maplit åˆå§‹åŒ–ï¼Œæˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹è¯¥å‡½æ•°åˆå§‹åŒ–å“ˆå¸Œçš„è¿‡ç¨‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func maplit(n *Node, m*Node, init *Nodes) { a := nod(OMAKE, nil, nil) a.Esc = n.Esc a.List.Set2(typenod(n.Type), nodintconst(int64(n.List.Len()))) litas(m, a, init) entries := n.List.Slice() if len(entries)  25 { ... return } // Build list of var[c] = expr. \t// Use temporaries so that mapassign1 can have addressable key, elem. \t... }   å½“å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡å°‘äºæˆ–è€…ç­‰äº 25 ä¸ªæ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°†å­—é¢é‡åˆå§‹åŒ–çš„ç»“æ„ä½“è½¬æ¢æˆä»¥ä¸‹çš„ä»£ç ï¼Œå°†æ‰€æœ‰çš„é”®å€¼å¯¹ä¸€æ¬¡åŠ å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ï¼š\n1 2 3 4  hash := make(map[string]int, 3) hash[\"1\"] = 2 hash[\"3\"] = 4 hash[\"5\"] = 6   è¿™ç§åˆå§‹åŒ–çš„æ–¹å¼ä¸çš„æ•°ç»„å’Œåˆ‡ç‰‡å‡ ä¹å®Œå…¨ç›¸åŒï¼Œç”±æ­¤çœ‹æ¥é›†åˆç±»å‹çš„åˆå§‹åŒ–åœ¨ Go è¯­è¨€ä¸­æœ‰ç€ç›¸åŒçš„å¤„ç†é€»è¾‘ã€‚\nä¸€æ—¦å“ˆå¸Œè¡¨ä¸­å…ƒç´ çš„æ•°é‡è¶…è¿‡äº† 25 ä¸ªï¼Œç¼–è¯‘å™¨ä¼šåˆ›å»ºä¸¤ä¸ªæ•°ç»„åˆ†åˆ«å­˜å‚¨é”®å’Œå€¼ï¼Œè¿™äº›é”®å€¼å¯¹ä¼šé€šè¿‡å¦‚ä¸‹æ‰€ç¤ºçš„ for å¾ªç¯åŠ å…¥å“ˆå¸Œï¼š\n1 2 3 4 5 6  hash := make(map[string]int, 26) vstatk := []string{\"1\", \"2\", \"3\", ... ï¼Œ \"26\"} vstatv := []int{1, 2, 3, ... , 26} for i := 0; i  len(vstak); i++ { hash[vstatk[i]] = vstatv[i] }   è¿™é‡Œå±•å¼€çš„ä¸¤ä¸ªåˆ‡ç‰‡ vstatk å’Œ vstatv è¿˜ä¼šè¢«ç¼–è¾‘å™¨ç»§ç»­å±•å¼€ï¼Œå…·ä½“çš„å±•å¼€æ–¹å¼å¯ä»¥é˜…è¯»ä¸Šä¸€èŠ‚äº†è§£åˆ‡ç‰‡çš„åˆå§‹åŒ–ï¼Œä¸è¿‡æ— è®ºä½¿ç”¨å“ªç§æ–¹æ³•ï¼Œä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–çš„è¿‡ç¨‹éƒ½ä¼šä½¿ç”¨ Go è¯­è¨€ä¸­çš„å…³é”®å­— make æ¥åˆ›å»ºæ–°çš„å“ˆå¸Œå¹¶é€šè¿‡æœ€åŸå§‹çš„ [] è¯­æ³•å‘å“ˆå¸Œè¿½åŠ å…ƒç´ ã€‚\nä»è¯­æ³•å±‚é¢ä¸Šæ¥è¯´ï¼Œåˆ›å»º map å¾ˆç®€å•ï¼š\n1 2 3 4 5 6  ageMp := make(map[string]int) // æŒ‡å®š map é•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int   å½“åˆ›å»ºçš„å“ˆå¸Œè¢«åˆ†é…åˆ°å †ä¸Šå¹¶ä¸”å…¶å®¹é‡å°äº BUCKETSIZE = 8 æ—¶ï¼ŒGo è¯­è¨€åœ¨ç¼–è¯‘é˜¶æ®µä¼šä½¿ç”¨å¦‚ä¸‹æ–¹å¼å¿«é€Ÿåˆå§‹åŒ–å“ˆå¸Œï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨å¯¹å°å®¹é‡çš„å“ˆå¸Œåšçš„ä¼˜åŒ–ï¼š\n1 2 3 4 5 6 7 8  // makemap_small implements Go map creation for make(map[k]v) and // make(map[k]v, hint) when hint is known to be at most bucketCnt // at compile time and the map needs to be allocated on the heap. func makemap_small() *hmap { h := new(hmap) h.hash0 = fastrand() return h }   é™¤äº†ä¸Šè¿°ç‰¹å®šçš„ä¼˜åŒ–ä¹‹å¤–ï¼Œæ— è®º make æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Œåªè¦æˆ‘ä»¬ä½¿ç”¨ make åˆ›å»ºå“ˆå¸Œï¼ŒGo è¯­è¨€ç¼–è¯‘å™¨éƒ½ä¼šåœ¨ç±»å‹æ£€æŸ¥æœŸé—´å°†å®ƒä»¬è½¬æ¢æˆ runtime.makemapï¼Œä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–å“ˆå¸Œä¹Ÿåªæ˜¯è¯­è¨€æä¾›çš„è¾…åŠ©å·¥å…·ï¼Œæœ€åè°ƒç”¨çš„éƒ½æ˜¯ runtime.makemap,ä¸»è¦åšçš„å·¥ä½œå°±æ˜¯åˆå§‹åŒ– hmap ç»“æ„ä½“çš„å„ç§å­—æ®µï¼Œä¾‹å¦‚è®¡ç®— B çš„å¤§å°ï¼Œè®¾ç½®å“ˆå¸Œç§å­ hash0 ç­‰ç­‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  // makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // ä¼ å…¥çš„ä¸‰ä¸ªå‚æ•°åˆ†åˆ«ä¸º // 1.mapçš„ç±»å‹å³ keyå’Œvalueçš„ç±»å‹ä¿¡æ¯ç­‰å…¶ä»–æ•°æ® // 2.é•¿åº¦ å³ make ä¼ å…¥çš„len // 3.hmapç»“æ„ä½“ å¯ä»¥ä¸ºnil // è¿”å›å€¼ä¸ºç»è¿‡å¤„ç†çš„ *hmap func makemap(t *maptype, hint int, h *hmap) *hmap { // æ ¡éªŒä¸€ä¸‹éœ€æ±‚çš„é•¿åº¦å’Œç±»å‹å ç”¨å­—èŠ‚æ•°çš„ä¹˜ç§¯  // æ˜¯å¦è¶…è¿‡å†…å­˜é™åˆ¶ \tmem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem  maxAlloc { hint = 0 } // initialize Hmap \t// åˆ›å»ºä¸€ä¸ªæ–°çš„ hmapç»“æ„ä½“ \tif h == nil { h = new(hmap) } // è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­ \th.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. \t// For hint \t// æ‰¾åˆ°ä¸€ä¸ª Bï¼Œä½¿å¾— map çš„è£…è½½å› å­åœ¨æ­£å¸¸èŒƒå›´å†… \tB := uint8(0) // é€šè¿‡è¾“å…¥çš„é•¿åº¦ ç®—å‡ºä¸€ä¸ªåˆé€‚çš„Bå€¼ \tfor overLoadFactor(hint, B) { B++ } h.B = B // åˆå§‹åŒ– hash table \t// å¦‚æœ B ç­‰äº 0ï¼Œé‚£ä¹ˆ buckets å°±ä¼šåœ¨èµ‹å€¼çš„æ—¶å€™å†åˆ†é… \t// å¦‚æœé•¿åº¦æ¯”è¾ƒå¤§ï¼Œåˆ†é…å†…å­˜ä¼šèŠ±è´¹é•¿ä¸€ç‚¹ \t// allocate initial hash table \t// if B == 0, the buckets field is allocated lazily later (in mapassign) \t// If hint is large zeroing this memory could take a while. \t// å¦‚æœBä¸ä¸º0 \tif h.B != 0 { var nextOverflow *bmap // è°ƒç”¨makeBucketArray è¿”å›ä¸€ä¸ªæº¢å‡ºbmapå’Œå¼€è¾Ÿå®Œå†…å­˜çš„æ¡¶çš„é¦–åœ°å€æŒ‡é’ˆ \th.buckets, nextOverflow = makeBucketArray(t, h.B, nil) // å¦‚æœæœ‰æº¢å‡ºbmap \tif nextOverflow != nil { h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow } } return h }   è¿™ä¸ªå‡½æ•°ä¼šæŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤æ‰§è¡Œï¼š\n è®¡ç®—å“ˆå¸Œå ç”¨çš„å†…å­˜æ˜¯å¦æº¢å‡ºæˆ–è€…è¶…å‡ºèƒ½åˆ†é…çš„æœ€å¤§å€¼ï¼› è°ƒç”¨ runtime.fastrand è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­ï¼› æ ¹æ®ä¼ å…¥çš„ hint è®¡ç®—å‡ºéœ€è¦çš„æœ€å°éœ€è¦çš„æ¡¶çš„æ•°é‡ï¼› ä½¿ç”¨ runtime.makeBucketArray åˆ›å»ºç”¨äºä¿å­˜æ¡¶çš„æ•°ç»„ï¼›  makeBucketArray runtime.makeBucketArray ä¼šæ ¹æ®ä¼ å…¥çš„ B è®¡ç®—å‡ºçš„éœ€è¦åˆ›å»ºçš„æ¡¶æ•°é‡å¹¶åœ¨å†…å­˜ä¸­åˆ†é…ä¸€ç‰‡è¿ç»­çš„ç©ºé—´ç”¨äºå­˜å‚¨æ•°æ®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow*bmap) { // æ±‚å‡ºéœ€è¦æ¡¶çš„ä¸ªæ•° å³è¿”å› 1\tbase := bucketShift(b) nbuckets := base // å¦‚æœéœ€è¦çš„æ¡¶çš„ä¸ªæ•°å°äº4ä¸ª é‚£ä¹ˆå°±ä¸éœ€è¦åˆ›å»ºæº¢å‡ºbmap  // ä¸ºçš„æ˜¯é˜²æ­¢æœ‰å¯èƒ½ä¸éœ€è¦bmapçš„æ—¶å€™å´åˆ›å»ºäº†bmap  // ä½¿å…¶é™ä½èµ„æºå¼€é”€ \tif b = 4 { // åˆ›å»ºçš„æº¢å‡ºbmapçš„æ•°é‡æ˜¯1 // è·å¾—æ‰€éœ€çš„æ¡¶ä¸æº¢å‡ºbmapçš„æ•°é‡ \tnbuckets += bucketShift(b - 4) // è®¡ç®—ç±»å‹ å ç”¨å­—èŠ‚æ•° * æ‰€éœ€çš„æ¡¶ä¸æº¢å‡ºbmapçš„æ•°é‡çš„ä¹˜ç§¯ \tsz := t.bucket.size * nbuckets // è·å–å¯¹åº”é•¿åº¦çš„å†…å­˜å—çš„å¤§å° \tup := roundupsize(sz) if up != sz { nbuckets = up / t.bucket.size } } // åˆ†é…ä¸€ä¸ªnbuckets é•¿åº¦çš„bmapæ•°ç»„ è¿”å›é¦–æŒ‡é’ˆ  // æ­£å¸¸æƒ…å†µä¸‹æ¡¶å’Œæº¢å‡ºbmapæ˜¯è¿ç»­çš„  // ä½†æ˜¯å½“æº¢å‡ºbmapè¿‡å¤šçš„æ—¶å€™æ¯æ¬¡é€šè¿‡runtime.newobjectç”³è¯·çš„bmap  // ä¸æœ€åˆåˆ›å»ºçš„ä¸ä¸€å®šæ˜¯è¿ç»­çš„äº† \tbuckets = newarray(t.bucket, int(nbuckets)) // å¦‚æœåˆ›å»ºäº†æº¢å‡ºbmap \tif base != nbuckets { // è¿™é‡Œå–å·§äº†ä¸€ç‚¹ï¼Œé¢„å…ˆåˆ†é…çš„æº¢å‡ºæ¡¶çš„overflowéƒ½æ˜¯nil,æˆ‘ä»¬è¦æƒ³çŸ¥é“å“ªä¸ªæº¢å‡ºæ¡¶æ˜¯  // æœ€åä¸€ä¸ªï¼Œå¿…é¡»å¾—ç»™ä¸ªæ ‡è®°ï¼Œè¿™é‡Œå°†last.overflow = bucketsè¿›è¡Œèµ‹å€¼ï¼Œæ–¹ä¾¿  // åœ¨åˆ†é…overflowçš„æ—¶å€™èƒ½å¤Ÿé«˜æ•ˆçš„çŸ¥é“å·²ç»åˆ°äº†æº¢å‡ºæ¡¶çš„å°¾éƒ¨ã€‚ \t// å¦‚æœæœ‰æº¢å‡ºæ¡¶  // å°±æŠŠæº¢å‡ºbmapè®¾ç½®ä¸ºç”³è¯·çš„bmapæ•°ç»„çš„ nbuckets-baseå¤„çš„é‚£ä¸ªå½“ä½œç©ºé—²æº¢å‡ºbmap \tnextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) last.setoverflow(t, (*bmap)(buckets)) } return buckets, nextOverflow }    å½“æ¡¶çš„æ•°é‡å°äº 2^4 æ—¶ï¼Œç”±äºæ•°æ®è¾ƒå°‘ã€ä½¿ç”¨æº¢å‡ºæ¡¶çš„å¯èƒ½æ€§è¾ƒä½ï¼Œä¼šçœç•¥åˆ›å»ºçš„è¿‡ç¨‹ä»¥å‡å°‘é¢å¤–å¼€é”€ï¼› å½“æ¡¶çš„æ•°é‡å¤šäº 2^4 æ—¶ï¼Œä¼šé¢å¤–åˆ›å»º 2^(ğµâˆ’4) ä¸ªæº¢å‡ºæ¡¶ï¼›  æ ¹æ®ä¸Šè¿°ä»£ç ï¼Œæˆ‘ä»¬èƒ½ç¡®å®šåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ç©ºé—´æ˜¯è¿ç»­çš„ï¼Œåªæ˜¯è¢« runtime.hmap ä¸­çš„ä¸åŒå­—æ®µå¼•ç”¨ï¼Œå½“æº¢å‡ºæ¡¶æ•°é‡è¾ƒå¤šæ—¶ä¼šé€šè¿‡ runtime.newobject åˆ›å»ºæ–°çš„æº¢å‡ºæ¡¶ã€‚\nå“ˆå¸Œå®šä½ map çš„ä¸€ä¸ªå…³é”®ç‚¹åœ¨äºï¼Œå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©ã€‚åœ¨ç¨‹åºå¯åŠ¨æ—¶ï¼Œä¼šæ£€æµ‹ cpu æ˜¯å¦æ”¯æŒ aesï¼Œå¦‚æœæ”¯æŒï¼Œåˆ™ä½¿ç”¨ aes hashï¼Œå¦åˆ™ä½¿ç”¨ memhashã€‚è¿™æ˜¯åœ¨å‡½æ•° alginit() ä¸­å®Œæˆï¼Œä½äºè·¯å¾„ï¼šsrc/runtime/alg.go ä¸‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func alginit() { // Install AES hash algorithms if the instructions needed are present. \tif (GOARCH == \"386\" || GOARCH == \"amd64\") \u0026\u0026 cpu.X86.HasAES \u0026\u0026 // AESENC \tcpu.X86.HasSSSE3 \u0026\u0026 // PSHUFB \tcpu.X86.HasSSE41 { // PINSR{D,Q} \tinitAlgAES() return } if GOARCH == \"arm64\" \u0026\u0026 cpu.ARM64.HasAES { initAlgAES() return } getRandomData((*[len(hashkey) * sys.PtrSize]byte)(unsafe.Pointer(\u0026hashkey))[:]) hashkey[0] |= 1 // make sure these numbers are odd \thashkey[1] |= 1 hashkey[2] |= 1 hashkey[3] |= 1 } func initAlgAES() { useAeshash = true // Initialize with random data so hash collisions will be hard to engineer. \tgetRandomData(aeskeysched[:]) }   key ç»è¿‡å“ˆå¸Œè®¡ç®—åå¾—åˆ°å“ˆå¸Œå€¼ï¼Œå…± 64 ä¸ª bit ä½ï¼ˆ64ä½æœºï¼Œ32ä½æœºå°±ä¸è®¨è®ºäº†ï¼Œç°åœ¨ä¸»æµéƒ½æ˜¯64ä½æœºï¼‰ï¼Œè®¡ç®—å®ƒåˆ°åº•è¦è½åœ¨å“ªä¸ªæ¡¶æ—¶ï¼Œåªä¼šç”¨åˆ°æœ€å B ä¸ª bit ä½ã€‚è¿˜è®°å¾—å‰é¢æåˆ°è¿‡çš„ B å—ï¼Ÿå¦‚æœ B = 5ï¼Œé‚£ä¹ˆæ¡¶çš„æ•°é‡ï¼Œä¹Ÿå°±æ˜¯ buckets æ•°ç»„çš„é•¿åº¦æ˜¯ 2^5 = 32ã€‚\nä¾‹å¦‚ï¼Œç°åœ¨æœ‰ä¸€ä¸ª key ç»è¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—åï¼Œå¾—åˆ°çš„å“ˆå¸Œç»“æœæ˜¯ï¼š\n1  10010111 | 000011110110110010001111001010100010010110010101010 â”‚ 01010   ç”¨æœ€åçš„ 5 ä¸ª bit ä½ï¼Œä¹Ÿå°±æ˜¯ 01010ï¼Œå€¼ä¸º 10ï¼Œä¹Ÿå°±æ˜¯ 10 å·æ¡¶ã€‚è¿™ä¸ªæ“ä½œå®é™…ä¸Šå°±æ˜¯å–ä½™æ“ä½œï¼Œä½†æ˜¯å–ä½™å¼€é”€å¤ªå¤§ï¼Œæ‰€ä»¥ä»£ç å®ç°ä¸Šç”¨çš„ä½æ“ä½œä»£æ›¿ã€‚\nå†ç”¨å“ˆå¸Œå€¼çš„é«˜ 8 ä½ï¼Œæ‰¾åˆ°æ­¤ key åœ¨ bucket ä¸­çš„ä½ç½®ï¼Œè¿™æ˜¯åœ¨å¯»æ‰¾å·²æœ‰çš„ keyã€‚æœ€å¼€å§‹æ¡¶å†…è¿˜æ²¡æœ‰ keyï¼Œæ–°åŠ å…¥çš„ key ä¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºä½ï¼Œæ”¾å…¥ã€‚\nbuckets ç¼–å·å°±æ˜¯æ¡¶ç¼–å·ï¼Œå½“ä¸¤ä¸ªä¸åŒçš„ key è½åœ¨åŒä¸€ä¸ªæ¡¶ä¸­ï¼Œä¹Ÿå°±æ˜¯å‘ç”Ÿäº†å“ˆå¸Œå†²çªã€‚å†²çªçš„è§£å†³æ‰‹æ®µæ˜¯ç”¨é“¾è¡¨æ³•ï¼šåœ¨ bucket ä¸­ï¼Œä»å‰å¾€åæ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºä½ã€‚è¿™æ ·ï¼Œåœ¨æŸ¥æ‰¾æŸä¸ª key æ—¶ï¼Œå…ˆæ‰¾åˆ°å¯¹åº”çš„æ¡¶ï¼Œå†å»éå† bucket ä¸­çš„ keyã€‚\nä¸Šå›¾ä¸­ï¼Œå‡å®š B = 5ï¼Œæ‰€ä»¥ bucket æ€»æ•°å°±æ˜¯ 2^5 = 32ã€‚é¦–å…ˆè®¡ç®—å‡ºå¾…æŸ¥æ‰¾ key çš„å“ˆå¸Œï¼Œä½¿ç”¨ä½ 5 ä½ 00110ï¼Œæ‰¾åˆ°å¯¹åº”çš„ 6 å· bucketï¼Œä½¿ç”¨é«˜ 8 ä½ 10010111ï¼Œå¯¹åº”åè¿›åˆ¶ 151ï¼Œåœ¨ 6 å· bucket ä¸­å¯»æ‰¾ tophash å€¼ï¼ˆHOB hashï¼‰ä¸º 151 çš„ keyï¼Œæ‰¾åˆ°äº† 2 å·æ§½ä½ï¼Œè¿™æ ·æ•´ä¸ªæŸ¥æ‰¾è¿‡ç¨‹å°±ç»“æŸäº†ã€‚\nå¦‚æœåœ¨ bucket ä¸­æ²¡æ‰¾åˆ°ï¼Œå¹¶ä¸” overflow ä¸ä¸ºç©ºï¼Œè¿˜è¦ç»§ç»­å» overflow bucket ä¸­å¯»æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æˆ–æ˜¯æ‰€æœ‰çš„ key æ§½ä½éƒ½æ‰¾éäº†ï¼ŒåŒ…æ‹¬æ‰€æœ‰çš„ overflow bucketã€‚\nmapaccess åœ¨ç¼–è¯‘çš„ç±»å‹æ£€æŸ¥æœŸé—´ï¼Œhash[key] ä»¥åŠç±»ä¼¼çš„æ“ä½œéƒ½ä¼šè¢«è½¬æ¢æˆå“ˆå¸Œçš„ OINDEXMAP æ“ä½œï¼Œä¸­é—´ä»£ç ç”Ÿæˆé˜¶æ®µä¼šåœ¨ cmd/compile/internal/gc.walkexpr å‡½æ•°ä¸­å°†è¿™äº› OINDEXMAP æ“ä½œè½¬æ¢æˆå¦‚ä¸‹çš„ä»£ç ï¼š\n1 2  v := hash[key] // = v := *mapaccess1(maptype, hash, \u0026key) v, ok := hash[key] // = v, ok := mapaccess2(maptype, hash, \u0026key)   èµ‹å€¼è¯­å¥å·¦ä¾§æ¥å—å‚æ•°çš„ä¸ªæ•°ä¼šå†³å®šä½¿ç”¨çš„è¿è¡Œæ—¶æ–¹æ³•ï¼š\n å½“æ¥å—ä¸€ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ runtime.mapaccess1ï¼Œè¯¥å‡½æ•°ä»…ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ç›®æ ‡å€¼çš„æŒ‡é’ˆï¼› å½“æ¥å—ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ runtime.mapaccess2ï¼Œé™¤äº†è¿”å›ç›®æ ‡å€¼ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šè¿”å›ä¸€ä¸ªç”¨äºè¡¨ç¤ºå½“å‰é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨çš„ bool å€¼ï¼š  å¦å¤–ï¼Œæ ¹æ® key çš„ä¸åŒç±»å‹ï¼Œç¼–è¯‘å™¨è¿˜ä¼šå°†æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„å‡½æ•°ç”¨æ›´å…·ä½“çš„å‡½æ•°æ›¿æ¢ï¼Œä»¥ä¼˜åŒ–æ•ˆç‡ï¼š\n   key ç±»å‹ æŸ¥æ‰¾     uint32 mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer   uint32 mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)   uint64 mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer   uint64 mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)   string mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer   string mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)    è¿™äº›å‡½æ•°çš„å‚æ•°ç±»å‹ç›´æ¥æ˜¯å…·ä½“çš„ uint32ã€unt64ã€stringï¼Œåœ¨å‡½æ•°å†…éƒ¨ç”±äºæå‰çŸ¥æ™“äº† key çš„ç±»å‹ï¼Œæ‰€ä»¥å†…å­˜å¸ƒå±€æ˜¯å¾ˆæ¸…æ¥šçš„ï¼Œå› æ­¤èƒ½èŠ‚çœå¾ˆå¤šæ“ä½œï¼Œæé«˜æ•ˆç‡ã€‚\nä¸Šé¢è¿™äº›å‡½æ•°éƒ½æ˜¯åœ¨æ–‡ä»¶ src/runtime/hashmap_fast.go é‡Œã€‚\nmapaccess1 runtime.mapaccess1 ä¼šå…ˆé€šè¿‡å“ˆå¸Œè¡¨è®¾ç½®çš„å“ˆå¸Œå‡½æ•°ã€ç§å­è·å–å½“å‰é”®å¯¹åº”çš„å“ˆå¸Œï¼Œå†é€šè¿‡ runtime.bucketMask å’Œ runtime.add æ‹¿åˆ°è¯¥é”®å€¼å¯¹æ‰€åœ¨çš„æ¡¶åºå·å’Œå“ˆå¸Œé«˜ä½çš„ 8 ä½æ•°å­—ã€‚\nmapçš„è¯»å–å¤§æ¦‚å°±æ˜¯ä»¥ä¸‹å‡ æ­¥ï¼š\n nilçš„Mapæˆ–è€…len==0çš„Mapç›´æ¥è¿”å›å¯¹åº”ç±»å‹é›¶å€¼ å¦‚æœå½“å‰å¤„äºç¿»å€æ‰©å®¹çŠ¶æ€ä¸”å½“å‰keyçš„hashå¯¹åº”çš„æ¡¶è¿˜æ²¡æ¬è¿å®Œï¼Œé‚£ä¹ˆå°±åœ¨æ—§æ¡¶é‡Œæ‰¾å¯¹åº”çš„é‚£ä¸ªæ¡¶å»æ‰¾å¯¹åº”çš„key-value è·Ÿå†™å…¥ä¸€æ · éå†æ¡¶åŠå…¶æº¢å‡ºæ¡¶ æ‰¾åˆ°äº†è¿”å›å€¼ï¼Œæ²¡æ‰¾åˆ°è¿”å›è¿”å›å¯¹åº”ç±»å‹é›¶å€¼  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  // mapaccess1 returns a pointer to h[key]. Never returns nil, instead // it will return a reference to the zero object for the elem type if // the key is not in the map. // NOTE: The returned pointer may keep the whole map live, so don't // hold onto it for very long. func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { if raceenabled \u0026\u0026 h != nil { callerpc := getcallerpc() pc := funcPC(mapaccess1) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled \u0026\u0026 h != nil { msanread(key, t.key.size) } // mapä¸ºç©ºæˆ–è€…å…ƒç´ æ•°é‡ä¸º0æ—¶å¿«é€Ÿè¿”å› \t// å¦‚æœ h ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œè¿”å›é›¶å€¼ \tif h == nil || h.count == 0 { // åŒå†™å…¥ \tif t.hashMightPanic() { t.hasher(key, 0) // see issue 23734 \t} return unsafe.Pointer(\u0026zeroVal[0]) } // å†™å’Œè¯»å†²çª \t// åœ¨è¿™é‡Œåšå¹¶å‘åˆ¤æ–­ï¼Œæ£€æµ‹åˆ°å¹¶å‘å†™æ—¶ï¼ŒæŠ›å¼‚å¸¸ \t// æ³¨æ„ï¼šgo mapçš„å¹¶å‘æ£€æµ‹æ˜¯ä¼ªæ£€æµ‹ï¼Œå¹¶ä¸ä¿è¯æ‰€æœ‰çš„å¹¶å‘éƒ½ä¼šè¢«æ£€æµ‹å‡ºæ¥ã€‚è€Œä¸”è¿™ç©æ„æ˜¯åœ¨è¿è¡ŒæœŸæ£€æµ‹ã€‚ \t// æ‰€ä»¥å¯¹mapæœ‰å¹¶å‘è¦æ±‚æ—¶ï¼Œåº”ä½¿ç”¨sync.mapæ¥ä»£æ›¿æ™®é€šmapï¼Œé€šè¿‡åŠ é”æ¥é˜»æ–­å¹¶å‘å†²çª \tif h.flags\u0026hashWriting != 0 { throw(\"concurrent map read and map write\") } // è®¡ç®—å“ˆå¸Œå€¼ï¼Œå¹¶ä¸”åŠ å…¥ hash0 å¼•å…¥éšæœºæ€§ \thash := t.hasher(key, uintptr(h.hash0)) // æ¯”å¦‚ B=5ï¼Œé‚£ m å°±æ˜¯31ï¼ŒäºŒè¿›åˆ¶æ˜¯å…¨ 1 \t// æ±‚ bucket num æ—¶ï¼Œå°† hash ä¸ m ç›¸ä¸ï¼Œ \t// è¾¾åˆ° bucket num ç”± hash çš„ä½ 8 ä½å†³å®šçš„æ•ˆæœ \tm := bucketMask(h.B) // b å°±æ˜¯ bucket çš„åœ°å€ \tb := (*bmap)(add(h.buckets, (hash\u0026m)*uintptr(t.bucketsize))) // oldbuckets ä¸ä¸º nilï¼Œè¯´æ˜å‘ç”Ÿäº†æ‰©å®¹ \tif c := h.oldbuckets; c != nil { // å¦‚æœä¸æ˜¯åŒ size æ‰©å®¹ï¼ˆçœ‹åé¢æ‰©å®¹çš„å†…å®¹ï¼‰ \t// å¯¹åº”æ¡ä»¶ 1 çš„è§£å†³æ–¹æ¡ˆ \tif !h.sameSizeGrow() { // There used to be half as many buckets; mask down one more power of two. \t// æ–° bucket æ•°é‡æ˜¯è€çš„ 2 å€ \tm = 1 } // æ±‚å‡º key åœ¨è€çš„ map ä¸­çš„ bucket ä½ç½® \toldb := (*bmap)(add(c, (hash\u0026m)*uintptr(t.bucketsize))) // å¦‚æœ oldb æ²¡æœ‰æ¬è¿åˆ°æ–°çš„ bucket \t// é‚£å°±åœ¨è€çš„ bucket ä¸­å¯»æ‰¾ \tif !evacuated(oldb) { // å¤„äºæ‰©å®¹è¿‡ç¨‹ä¸­ï¼Œåº”è¯¥ä»oldbucketsä¸­å»è·å–æ•°æ® \tb = oldb } } // è®¡ç®—å‡ºé«˜ 8 ä½çš„ hash \t// ç›¸å½“äºå³ç§» 56 ä½ï¼Œåªå–é«˜8ä½ \ttop := tophash(hash) bucketloop: // éå†æ¡¶å’Œå…¶æº¢å‡ºæ¡¶ \tfor ; b != nil; b = b.overflow(t) { //éå†æ¡¶çš„tophash \tfor i := uintptr(0); i  bucketCnt; i++ { // tophash ä¸åŒ¹é…ï¼Œç»§ç»­ \tif b.tophash[i] != top { if b.tophash[i] == emptyRest { // æå‰è¿”å›ï¼ŒemptyRestè¡¨ç¤ºåœ¨å®ƒä¹‹åä¸ä¼šå­˜åœ¨éç©ºå€¼ \t// å½“å‰bucketå†…æ‰¾å®Œï¼ˆè¿˜æ²¡æ‰¾åˆ°ï¼‰ï¼Œç»§ç»­åˆ° overflow bucket é‡Œæ‰¾ \tbreak bucketloop } continue } // tophash åŒ¹é…ï¼Œå®šä½åˆ° key çš„ä½ç½® \tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) // key æ˜¯æŒ‡é’ˆ \tif t.indirectkey() { // è§£å¼•ç”¨ \tk = *((*unsafe.Pointer)(k)) } // å¦‚æœ key ç›¸ç­‰ \t// é˜²æ­¢ä»…topä½ç›¸åŒçš„hashå†²çª \tif t.key.equal(key, k) { // å®šä½åˆ° value çš„ä½ç½® \te := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) // value è§£å¼•ç”¨ \tif t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return e } } } // overflow bucket ä¹Ÿæ‰¾å®Œäº†ï¼Œè¯´æ˜æ²¡æœ‰ç›®æ ‡ key \t// è¿”å›é›¶å€¼ \treturn unsafe.Pointer(\u0026zeroVal[0]) } // bucketMask returns 1func bucketMask(b uint8) uintptr { return bucketShift(b) - 1 } // bucketShift returns 1func bucketShift(b uint8) uintptr { // Masking the shift amount allows overflow checks to be elided. \treturn uintptr(1)  (b \u0026 (sys.PtrSize*8 - 1)) } func (b *bmap) overflow(t *maptype) *bmap { return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) }   åœ¨ bucketloop å¾ªç¯ä¸­ï¼Œå“ˆå¸Œä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­çš„æ•°æ®ï¼Œå®ƒä¼šå…ˆæ¯”è¾ƒå“ˆå¸Œçš„é«˜ 8 ä½å’Œæ¡¶ä¸­å­˜å‚¨çš„ tophashï¼Œåæ¯”è¾ƒä¼ å…¥çš„å’Œæ¡¶ä¸­çš„å€¼ä»¥åŠ é€Ÿæ•°æ®çš„è¯»å†™ã€‚ç”¨äºé€‰æ‹©æ¡¶åºå·çš„æ˜¯å“ˆå¸Œçš„æœ€ä½å‡ ä½ï¼Œè€Œç”¨äºåŠ é€Ÿè®¿é—®çš„æ˜¯å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œè¿™ç§è®¾è®¡èƒ½å¤Ÿå‡å°‘åŒä¸€ä¸ªæ¡¶ä¸­æœ‰å¤§é‡ç›¸ç­‰ tophash çš„æ¦‚ç‡å½±å“æ€§èƒ½ã€‚\nå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¯ä¸€ä¸ªæ¡¶éƒ½æ˜¯ä¸€æ•´ç‰‡çš„å†…å­˜ç©ºé—´ï¼Œå½“å‘ç°æ¡¶ä¸­çš„ tophash ä¸ä¼ å…¥é”®çš„ tophash åŒ¹é…ä¹‹åï¼Œæˆ‘ä»¬ä¼šé€šè¿‡æŒ‡é’ˆå’Œåç§»é‡è·å–å“ˆå¸Œä¸­å­˜å‚¨çš„é”® keys[0] å¹¶ä¸ key æ¯”è¾ƒï¼Œå¦‚æœä¸¤è€…ç›¸åŒå°±ä¼šè·å–ç›®æ ‡å€¼çš„æŒ‡é’ˆ values[0] å¹¶è¿”å›ã€‚\nå¦‚æœ h ä¸­æ²¡æœ‰æ­¤ keyï¼Œé‚£å°±ä¼šè¿”å›ä¸€ä¸ª key ç›¸åº”ç±»å‹çš„é›¶å€¼ï¼Œä¸ä¼šè¿”å› nilã€‚\nè¿™é‡Œï¼Œè¯´ä¸€ä¸‹å®šä½ key å’Œ value çš„æ–¹æ³•ä»¥åŠæ•´ä¸ªå¾ªç¯çš„å†™æ³•ã€‚\n1 2 3 4 5  // key å®šä½å…¬å¼ k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) // value å®šä½å…¬å¼ v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))   b æ˜¯ bmap çš„åœ°å€ï¼Œè¿™é‡Œ bmap è¿˜æ˜¯æºç é‡Œå®šä¹‰çš„ç»“æ„ä½“ï¼ŒåªåŒ…å«ä¸€ä¸ª tophash æ•°ç»„ï¼Œç»ç¼–è¯‘å™¨æ‰©å……ä¹‹åçš„ç»“æ„ä½“æ‰åŒ…å« keyï¼Œvalueï¼Œoverflow è¿™äº›å­—æ®µã€‚dataOffset æ˜¯ key ç›¸å¯¹äº bmap èµ·å§‹åœ°å€çš„åç§»ï¼š\n1 2 3 4  dataOffset = unsafe.Offsetof(struct { b bmap v int64 }{}.v)   å› æ­¤ bucket é‡Œ key çš„èµ·å§‹åœ°å€å°±æ˜¯ unsafe.Pointer(b)+dataOffsetã€‚ç¬¬ i ä¸ª key çš„åœ°å€å°±è¦åœ¨æ­¤åŸºç¡€ä¸Šè·¨è¿‡ i ä¸ª key çš„å¤§å°ï¼›è€Œæˆ‘ä»¬åˆçŸ¥é“ï¼Œvalue çš„åœ°å€æ˜¯åœ¨æ‰€æœ‰ key ä¹‹åï¼Œå› æ­¤ç¬¬ i ä¸ª value çš„åœ°å€è¿˜éœ€è¦åŠ ä¸Šæ‰€æœ‰ key çš„åç§»ã€‚ç†è§£äº†è¿™äº›ï¼Œä¸Šé¢ key å’Œ value çš„å®šä½å…¬å¼å°±å¾ˆå¥½ç†è§£äº†ã€‚\nå†è¯´æ•´ä¸ªå¤§å¾ªç¯çš„å†™æ³•ï¼Œæœ€å¤–å±‚æ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œé€šè¿‡\n1  b = b.overflow(t)   éå†æ‰€æœ‰çš„ bucketï¼Œè¿™ç›¸å½“äºæ˜¯ä¸€ä¸ª bucket é“¾è¡¨ã€‚\nå½“å®šä½åˆ°ä¸€ä¸ªå…·ä½“çš„ bucket æ—¶ï¼Œé‡Œå±‚å¾ªç¯å°±æ˜¯éå†è¿™ä¸ª bucket é‡Œæ‰€æœ‰çš„ cellï¼Œæˆ–è€…è¯´æ‰€æœ‰çš„æ§½ä½ï¼Œä¹Ÿå°±æ˜¯ bucketCnt=8 ä¸ªæ§½ä½ã€‚æ•´ä¸ªå¾ªç¯è¿‡ç¨‹ï¼š\ntophash 1 2 3 4 5 6 7 8  // tophash calculates the tophash value for hash. func tophash(hash uintptr) uint8 { top := uint8(hash  (sys.PtrSize*8 - 8)) if top  minTopHash { top += minTopHash } return top }   å½“ä¸€ä¸ª cell çš„ tophash å€¼å°äº minTopHash æ—¶ï¼Œæ ‡å¿—è¿™ä¸ª cell çš„è¿ç§»çŠ¶æ€ã€‚å› ä¸ºè¿™ä¸ªçŠ¶æ€å€¼æ˜¯æ”¾åœ¨ tophash æ•°ç»„é‡Œï¼Œä¸ºäº†å’Œæ­£å¸¸çš„å“ˆå¸Œå€¼åŒºåˆ†å¼€ï¼Œä¼šç»™ key è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ä¸€ä¸ªå¢é‡ï¼šminTopHashã€‚è¿™æ ·å°±èƒ½åŒºåˆ†æ­£å¸¸çš„ top hash å€¼å’Œè¡¨ç¤ºçŠ¶æ€çš„å“ˆå¸Œå€¼ã€‚\nä¸‹é¢çš„è¿™å‡ ç§çŠ¶æ€å°±è¡¨å¾äº† bucket çš„æƒ…å†µï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Possible tophash values. We reserve a few possibilities for special marks. \t// Each bucket (including its overflow buckets, if any) will have either all or none of its \t// entries in the evacuated* states (except during the evacuate() method, which only happens \t// during map writes and thus no one else can observe the map during that time). \t// tophashå¯¹åº”çš„ä½ç½®ä¸ºç©ºï¼Œå¹¶ä¸”åç»­æ²¡æœ‰éç©ºçš„å€¼ \temptyRest = 0 // this cell is empty, and there are no more non-empty cells at higher indexes or overflows. \t// tophashå¯¹åº”çš„ä½ç½®ä¸ºç©ºï¼Œå…ƒç´ è¢«åˆ é™¤åå¯èƒ½çš„æ ‡è®°å€¼ \temptyOne = 1 // this cell is empty \t// key/valueæ˜¯æ— æ•ˆçš„ï¼Œå€¼è¢«è¿ç§»åˆ°æ–°tableçš„å‰åŠæ®µ \tevacuatedX = 2 // key/elem is valid. Entry has been evacuated to first half of larger table. \t// key/valueæ˜¯æ— æ•ˆçš„ï¼Œå€¼è¢«è¿ç§»åˆ°æ–°tableçš„ååŠæ®µ \tevacuatedY = 3 // same as above, but evacuated to second half of larger table. \t// tophashå¯¹åº”çš„å€¼ä¸ºç©ºï¼Œä½†æ˜¯è¡¨ç¤ºæ­£åœ¨è¿ç§»ä¸­ \tevacuatedEmpty = 4 // cell is empty, bucket is evacuated. \t// ä¸€ä¸ªä¸´ç•Œå€¼ï¼Œå‰é¢æ‰€æœ‰çš„å€¼éƒ½ä»£è¡¨ä¸€ä¸ªç‰¹æ®Šçš„å«ä¹‰ï¼Œæ‰€ä»¥å½“top\tminTopHash = 5 // minimum tophash for a normal filled cell.   æºç é‡Œåˆ¤æ–­è¿™ä¸ª bucket æ˜¯å¦å·²ç»æ¬è¿å®Œæ¯•ï¼Œç”¨åˆ°çš„å‡½æ•°ï¼š\n1 2 3 4  func evacuated(b *bmap) bool { h := b.tophash[0] return h  emptyOne \u0026\u0026 h  minTopHash }   åªå–äº† tophash æ•°ç»„çš„ç¬¬ä¸€ä¸ªå€¼ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦åœ¨ 2-4 ä¹‹é—´ã€‚å¯¹æ¯”ä¸Šé¢çš„å¸¸é‡ï¼Œå½“ top hash æ˜¯ evacuatedEmptyã€evacuatedXã€evacuatedY è¿™ä¸‰ä¸ªå€¼ä¹‹ä¸€ï¼Œè¯´æ˜æ­¤ bucket ä¸­çš„ key å…¨éƒ¨è¢«æ¬è¿åˆ°äº†æ–° bucketã€‚\nmapaccess2 å¦ä¸€ä¸ªåŒæ ·ç”¨äºè®¿é—®å“ˆå¸Œè¡¨ä¸­æ•°æ®çš„ runtime.mapaccess2 åªæ˜¯åœ¨ runtime.mapaccess1 çš„åŸºç¡€ä¸Šå¤šè¿”å›äº†ä¸€ä¸ªæ ‡è¯†é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨çš„ bool å€¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) { if raceenabled \u0026\u0026 h != nil { callerpc := getcallerpc() pc := funcPC(mapaccess2) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled \u0026\u0026 h != nil { msanread(key, t.key.size) } if h == nil || h.count == 0 { if t.hashMightPanic() { t.hasher(key, 0) // see issue 23734 \t} return unsafe.Pointer(\u0026zeroVal[0]), false } if h.flags\u0026hashWriting != 0 { throw(\"concurrent map read and map write\") } hash := t.hasher(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash\u0026m)*uintptr(t.bucketsize))) if c := h.oldbuckets; c != nil { if !h.sameSizeGrow() { // There used to be half as many buckets; mask down one more power of two. \tm = 1 } oldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash\u0026m)*uintptr(t.bucketsize))) if !evacuated(oldb) { b = oldb } } top := tophash(hash) bucketloop: for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i  bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { break bucketloop } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } if t.key.equal(key, k) { e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } return e, true } } } return unsafe.Pointer(\u0026zeroVal[0]), false }   ä½¿ç”¨ v, ok := hash[k] çš„å½¢å¼è®¿é—®å“ˆå¸Œè¡¨ä¸­å…ƒç´ æ—¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡è¿™ä¸ªå¸ƒå°”å€¼æ›´å‡†ç¡®åœ°çŸ¥é“å½“ v == nil æ—¶ï¼Œv åˆ°åº•æ˜¯å“ˆå¸Œä¸­å­˜å‚¨çš„å…ƒç´ è¿˜æ˜¯è¡¨ç¤ºè¯¥é”®å¯¹åº”çš„å…ƒç´ ä¸å­˜åœ¨ï¼Œæ‰€ä»¥åœ¨è®¿é—®å“ˆå¸Œæ—¶ï¼Œæ›´æ¨èä½¿ç”¨è¿™ç§æ–¹å¼åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨ã€‚\nmapassign é€šè¿‡æ±‡ç¼–è¯­è¨€å¯ä»¥çœ‹åˆ°ï¼Œå‘ map ä¸­æ’å…¥æˆ–è€…ä¿®æ”¹ keyï¼Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯ mapassign å‡½æ•°ã€‚\nå®é™…ä¸Šæ’å…¥æˆ–ä¿®æ”¹ key çš„è¯­æ³•æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡å‰è€…æ“ä½œçš„ key åœ¨ map ä¸­ä¸å­˜åœ¨ï¼Œè€Œåè€…æ“ä½œçš„ key å­˜åœ¨ map ä¸­ã€‚\nmapassign æœ‰ä¸€ä¸ªç³»åˆ—çš„å‡½æ•°ï¼Œæ ¹æ® key ç±»å‹çš„ä¸åŒï¼Œç¼–è¯‘å™¨ä¼šå°†å…¶ä¼˜åŒ–ä¸ºç›¸åº”çš„â€œå¿«é€Ÿå‡½æ•°â€ã€‚\n   key ç±»å‹ æ’å…¥     uint32 mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer    uint64 mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer    string mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer     æˆ‘ä»¬åªç”¨ç ”ç©¶æœ€ä¸€èˆ¬çš„èµ‹å€¼å‡½æ•° mapassignã€‚\nMapå†™å…¥æ“ä½œè¿‡ç¨‹:\n é¦–å…ˆä¼šè®¡ç®—å‡ºä¼ å…¥Keyçš„å“ˆå¸Œï¼Œå…¶ä½Bä½ç”¨äºé€‰æ‹©å¯¹åº”çš„bmapï¼Œå…¶å“ˆå¸Œå€¼çš„é«˜8ä½ç”¨äºåœ¨å¯¹åº”çš„bmapä¸­å¿«é€Ÿçš„æŸ¥æ‰¾æ˜¯å¦æœ‰æ­¤keyçš„å­˜åœ¨ï¼Œå¹¶ä¸”å¯¹è¯¥mapæ‰“ä¸Šå†™æ ‡è®°ï¼Œé˜²æ­¢å¹¶å‘è¯»å†™ã€‚ éå†æ‰¾åˆ°çš„bmapåŠå…¶æº¢å‡ºbmapï¼Œå¹¶æŒ‰ç…§ä¸‹é¢çš„æ¡ä»¶æ‰§è¡Œ  å¦‚æœæ¯”è¾ƒåˆ°å½“å‰çš„tophashä¸ç­‰äºä¼ å…¥keyçš„tophashï¼Œä¸”æœªæ‰¾åˆ°å¯ç”¨tophashåœ°å€æ—¶ï¼Œå¦‚æœå½“å‰tophashæ— å·²å­˜æ”¾çš„keyï¼Œé‚£ä¹ˆè®°å½•ä¸‹è¿™ä¸ªtophashçš„åœ°å€å’Œå…¶å¯¹åº”çš„kï¼Œvçš„åœ°å€ï¼Œæ­¤æ¡ä»¶ä¸ºæ’å…¥æ“ä½œã€‚ å¦‚æœå½“å‰tophashæ˜¯emptyRestï¼Œåˆ™ä»£è¡¨åç»­æ²¡æœ‰æº¢å‡ºbmapæˆ–è€…å¯éå†çš„tophashäº† å¦‚æœå½“å‰çš„tophash==ä¼ å…¥keyçš„tophashï¼Œåˆ™ä¼šå¯¹æ¯”ä¼ å…¥çš„Keyä»¥åŠtophashå¯¹åº”çš„Keyçš„åœ°å€çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰åˆ™ä»£è¡¨å·²ç»å­˜åœ¨äº†å½“å‰ä¼ å…¥çš„Keyï¼Œåˆ™æ­¤æ“ä½œä¸ºæ›´æ–°æ“ä½œï¼Œæ­¤æ—¶è®¡ç®—å‡ºå¯¹åº”valueçš„å­˜æ”¾åœ°å€ å¦‚æœä¸Šè¿°æ¡ä»¶éƒ½ä¸æ»¡è¶³åˆ™éå†æº¢å‡ºbmapï¼ˆå¦‚æœæœ‰ï¼‰   å¦‚æœåœ¨bmapåŠå…¶æº¢å‡ºbmapä¸­éƒ½æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å­˜æ”¾åœ°å€ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„æº¢å‡ºbmapï¼Œå› ä¸ºæ²¡æ‰¾åˆ°è¯´æ˜æ²¡æœ‰å¯ç”¨çš„tophashä½ç½®äº†ï¼Œå³æ‰€æœ‰çš„bmapéƒ½æ»¡äº†ã€‚ å¦‚æœç¬¦åˆä¸‹åˆ—æ‰©å®¹æ¡ä»¶å°±ä¼šäº§ç”Ÿæ‰©å®¹ï¼Œæ‰©å®¹å®Œæ¯•åé‡æ–°å¼€å§‹ åºå·2 çš„è¿‡ç¨‹ã€‚  å½“è£…è½½å› å­=6.5 æº¢å‡ºbmapè¿‡å¤šï¼Œè¯¥æƒ…å†µåªä¼šå‡ºç°åœ¨å…ˆå¤§é‡çš„å†™ç„¶åå†å¤§é‡åˆ é™¤ä½†è£…è½½å› å­å¹¶æ²¡æœ‰=6.5çš„æƒ…å†µ   å¦‚æœä¸éœ€è¦æ‰©å®¹åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„bmapï¼Œç»™ä¼ å…¥Keyçš„å“ˆå¸Œï¼Œå…¶ä½Bä½ç”¨äºé€‰æ‹©å¯¹åº”çš„bmapçš„æº¢å‡ºbmapé“¾è¡¨å°¾éƒ¨ï¼Œç„¶åè·å¾—å¯ç”¨çš„tophashï¼Œkeyï¼Œvalueåœ°å€ã€‚ç„¶åå–æ¶ˆå†™æ ‡è®°ï¼Œè¿”å›å¯ç”¨çš„value å­˜æ”¾åœ°å€ ï¼Œ éšåçš„èµ‹å€¼æ“ä½œä¼šåœ¨æ±‡ç¼–ä¸­è¿›è¡Œ  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211  // Like mapaccess, but allocates a slot for the key if it is not present in the map. // è¯¥å‡½æ•°ä¼ å…¥çš„å‚æ•°åˆ†åˆ«ä¸º // 1.mapçš„ç±»å‹å³ keyå’Œvalueçš„ç±»å‹ä¿¡æ¯ç­‰å…¶ä»–æ•°æ® // 2.é‚£ä¸ªmap // 3.keyæ‰€åœ¨å†…å­˜çš„åœ°å€ // è¿”å›çš„å‚æ•°ä¸º // 1.æ‰¾åˆ°çš„å¯ç”¨çš„å¯å­˜å‚¨valueçš„å†…å­˜åœ°å€ // è¿”å›åå…·ä½“çš„èµ‹å€¼æ“ä½œç”±æ±‡ç¼–å®Œæˆ func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { //åˆ¤æ–­ hmap æ˜¯å¦å·²ç»åˆå§‹åŒ–ï¼ˆæ˜¯å¦ä¸º nilï¼‰ \tif h == nil { panic(plainError(\"assignment to entry in nil map\")) } if raceenabled { callerpc := getcallerpc() pc := funcPC(mapassign) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled { msanread(key, t.key.size) } //åˆ¤æ–­æ˜¯å¦å¹¶å‘è¯»å†™ mapï¼Œè‹¥æ˜¯åˆ™æŠ›å‡ºå¼‚å¸¸ \tif h.flags\u0026hashWriting != 0 { throw(\"concurrent map writes\") } // æ±‚å‡ºè¿™ä¸ªkeyçš„å“ˆå¸Œå€¼ \thash := t.hasher(key, uintptr(h.hash0)) // å‡½æ•°é¦–å…ˆä¼šæ£€æŸ¥ map çš„æ ‡å¿—ä½ flagsã€‚å¦‚æœ flags çš„å†™æ ‡å¿—ä½æ­¤æ—¶è¢«ç½® 1 äº†ï¼Œè¯´æ˜æœ‰å…¶ä»–åç¨‹åœ¨æ‰§è¡Œâ€œå†™â€æ“ä½œï¼Œè¿›è€Œå¯¼è‡´ç¨‹åº panicã€‚è¿™ä¹Ÿè¯´æ˜äº† map å¯¹åç¨‹æ˜¯ä¸å®‰å…¨çš„ã€‚ \t// Set hashWriting after calling t.hasher, since t.hasher may panic, \t// in which case we have not actually done a write. \t// è®¾ç½® flags æ ‡å¿—ä½ï¼Œè¡¨ç¤ºæœ‰ä¸€ä¸ª goroutine æ­£åœ¨å†™å…¥æ•°æ®ã€‚å› ä¸º alg.hash æœ‰å¯èƒ½å‡ºç° panic å¯¼è‡´å¼‚å¸¸ \th.flags ^= hashWriting // åˆ¤æ–­ buckets æ˜¯å¦ä¸º nilï¼Œè‹¥æ˜¯åˆ™è°ƒç”¨ newobject æ ¹æ®å½“å‰ bucket å¤§å°è¿›è¡Œåˆ†é…  // åˆå§‹åŒ–æ—¶æ²¡æœ‰åˆå§‹ bucketsï¼Œé‚£ä¹ˆå®ƒåœ¨ç¬¬ä¸€æ¬¡èµ‹å€¼æ—¶å°±ä¼šå¯¹ buckets åˆ†é… \t// æ‡’åˆå§‹åŒ–ï¼Œåœ¨å‰é¢åˆå§‹åŒ–mapæ—¶ï¼ŒBä¸º0ï¼Œæ¡¶æ•°ç»„æ”¾åˆ°è¿™é‡Œæ¥è¿›è¡Œåˆå§‹åŒ– \tif h.buckets == nil { h.buckets = newobject(t.bucket) // newarray(t.bucket, 1) \t} // é¦–å…ˆæ˜¯å‡½æ•°ä¼šæ ¹æ®ä¼ å…¥çš„é”®æ‹¿åˆ°å¯¹åº”çš„å“ˆå¸Œå’Œæ¡¶ï¼š again: // æ ¹æ®ä½å…«ä½è®¡ç®—å¾—åˆ° bucket çš„å†…å­˜åœ°å€ \t// ç®—å‡ºè¿™ä¸ªkeyåº”è¯¥è½åˆ°å“ªä¸ªbmapé‡Œ \tbucket := hash \u0026 bucketMask(h.B) // å¦‚æœ map å¤„åœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œé‚£ä¹ˆå½“ key å®šä½åˆ°äº†æŸä¸ª bucket åï¼Œéœ€è¦ç¡®ä¿è¿™ä¸ª bucket å¯¹åº”çš„è€ bucket å®Œæˆäº†è¿ç§»è¿‡ç¨‹ã€‚å³è€ bucket é‡Œçš„ key éƒ½è¦è¿ç§»åˆ°æ–°çš„ bucket ä¸­æ¥ï¼ˆåˆ†è£‚åˆ° 2 ä¸ªæ–° bucketï¼‰ï¼Œæ‰èƒ½åœ¨æ–°çš„ bucket ä¸­è¿›è¡Œæ’å…¥æˆ–è€…æ›´æ–°çš„æ“ä½œã€‚ \t// åªæœ‰è¿›è¡Œå®Œäº†è¿™ä¸ªæ¬è¿æ“ä½œåï¼Œæˆ‘ä»¬æ‰èƒ½æ”¾å¿ƒåœ°åœ¨æ–° bucket é‡Œå®šä½ key è¦å®‰ç½®çš„åœ°å€ï¼Œå†è¿›è¡Œä¹‹åçš„æ“ä½œã€‚ \t// åˆ¤æ–­æ˜¯å¦å¤„äºæ¬è¿æ¡¶çš„çŠ¶æ€  // å¦‚æœå¤„äºè¯¥çŠ¶æ€åˆ™è¿›è¡Œæ—§æ¡¶ - æ–°æ¡¶çš„æ¬è¿ \tif h.growing() { growWork(t, h, bucket) } // é€šè¿‡ä½ç§»æ“ä½œè·å¾— bucket := hash \u0026 bucketMask(h.B) è¿™ä¸ªæ¡¶çš„å¯¹è±¡ \tb := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) // è®¡ç®—å‡ºkeyçš„å“ˆå¸Œå€¼ä¹‹åçš„é«˜8ä½å“ˆå¸Œå€¼ \ttop := tophash(hash) // ç„¶åé€šè¿‡éå†æ¯”è¾ƒæ¡¶ä¸­å­˜å‚¨çš„ tophash å’Œé”®çš„å“ˆå¸Œï¼Œå¦‚æœæ‰¾åˆ°äº†ç›¸åŒç»“æœå°±ä¼šè¿”å›ç›®æ ‡ä½ç½®çš„åœ°å€ã€‚ \t// å‡†å¤‡ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªï¼ˆinsertiï¼‰æŒ‡å‘ key çš„ hash å€¼åœ¨ tophash æ•°ç»„æ‰€å¤„çš„ä½ç½®ï¼Œå¦ä¸€ä¸ª(insertk)æŒ‡å‘ cell çš„ä½ç½®ï¼ˆä¹Ÿå°±æ˜¯ key æœ€ç»ˆæ”¾ç½®çš„åœ°å€ï¼‰ï¼Œå½“ç„¶ï¼Œå¯¹åº” value çš„ä½ç½®å°±å¾ˆå®¹æ˜“å®šä½å‡ºæ¥äº†ã€‚è¿™ä¸‰è€…å®é™…ä¸Šéƒ½æ˜¯å…³è”çš„ï¼Œåœ¨ tophash æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®å†³å®šäº† key åœ¨æ•´ä¸ª bucket ä¸­çš„ä½ç½®ï¼ˆå…± 8 ä¸ª keyï¼‰ï¼Œè€Œ value çš„ä½ç½®éœ€è¦â€œè·¨è¿‡â€ 8 ä¸ª key çš„é•¿åº¦ã€‚ \t// å…ƒç´ åœ¨bmapä¸­tophashæ•°ç»„çš„åœ°å€ \tvar inserti *uint8 // keyçš„åœ°å€ \tvar insertk unsafe.Pointer // value çš„åœ°å€ \tvar elem unsafe.Pointer bucketloop: // for å¾ªç¯ä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­å­˜å‚¨çš„æ•°æ®ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¼šåˆ†åˆ«åˆ¤æ–­ tophash æ˜¯å¦ç›¸ç­‰ã€key æ˜¯å¦ç›¸ç­‰ï¼Œéå†ç»“æŸåä¼šä»å¾ªç¯ä¸­è·³å‡ºã€‚ \tfor { // éå†å½“å‰é€‰ä¸­çš„bmap \t// è¿­ä»£ buckets ä¸­çš„æ¯ä¸€ä¸ª bucketï¼ˆå…± 8 ä¸ªï¼‰ \tfor i := uintptr(0); i  bucketCnt; i++ { // å¯¹æ¯” bucket.tophash ä¸ topï¼ˆé«˜å…«ä½ï¼‰æ˜¯å¦ä¸€è‡´ \tif b.tophash[i] != top { // åœ¨å¾ªç¯çš„è¿‡ç¨‹ä¸­ï¼Œinserti å’Œ insertk åˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ç©ºé—²çš„ cellã€‚å¦‚æœä¹‹ååœ¨ map æ²¡æœ‰æ‰¾åˆ° key çš„å­˜åœ¨ï¼Œä¹Ÿå°±æ˜¯è¯´åŸæ¥ map ä¸­æ²¡æœ‰æ­¤ keyï¼Œè¿™æ„å‘³ç€æ’å…¥æ–° keyã€‚é‚£æœ€ç»ˆ key çš„å®‰ç½®åœ°å€å°±æ˜¯ç¬¬ä¸€æ¬¡å‘ç°çš„â€œç©ºä½â€ï¼ˆtophash æ˜¯ emptyï¼‰ã€‚ \t// è‹¥ä¸ä¸€è‡´ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºç©ºæ§½ \tif isEmpty(b.tophash[i]) \u0026\u0026 inserti == nil { // è®°å½•tophashä¸­æœ€æ—©ä¸€æ¬¡å‡ºç°emptyçš„æƒ…å†µï¼Œè¿™é‡Œä¸ä¸€å®šæ˜¯emptyRestï¼Œæœ‰å¯èƒ½æ˜¯åˆ é™¤æ•°æ®æ—¶çš„emptyOneçŠ¶æ€ \tinserti = \u0026b.tophash[i] insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) // æŠŠè¯¥ä½ç½®æ ‡è¯†ä¸ºå¯æ’å…¥ tophash ä½ç½®,è¿™é‡Œå°±æ˜¯ç¬¬ä¸€ä¸ªå¯ä»¥æ’å…¥æ•°æ®çš„åœ°æ–¹ \telem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) } // å¦‚æœ b.tophash[i] == emptyRest  // ä»£è¡¨åç»­çš„b.tophashæ²¡æœ‰ æº¢å‡ºbmapæˆ–è€…å¯éå†çš„b.tophashäº† \tif b.tophash[i] == emptyRest { // è·³å‡ºå¾ªç¯ \tbreak bucketloop } continue } // è‹¥æ˜¯åŒ¹é…ï¼ˆä¹Ÿå°±æ˜¯åŸæœ¬å·²ç»å­˜åœ¨ï¼‰ï¼Œåˆ™è¿›è¡Œæ›´æ–°ã€‚æœ€åè·³å‡ºå¹¶è¿”å› value çš„å†…å­˜åœ°å€ \tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } // è®¡ç®—å½“å‰kä¸ä¼ è¿›æ¥çš„keyæ˜¯å¦ç›¸ç­‰ï¼Œæœ‰å¯èƒ½åªæ˜¯é«˜ä½ç›¸ç­‰ï¼Œåˆ™éœ€è¦ç»§ç»­å¾ªç¯ \tif !t.key.equal(key, k) { continue } // already have a mapping for key. Update it. \t// å¦‚æœç›¸ç­‰é‚£ä¹ˆå°±ä»£è¡¨æ˜¯æ›´æ–°æ“ä½œ  // å…ˆæŠŠä¼ å…¥çš„keyçš„èµ‹å€¼åˆ°kå¤„ \tif t.needkeyupdate() { typedmemmove(t.key, k, key) } // è®¡ç®—å‡ºkå¯¹åº”valueçš„åœ°å€ \telem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) // ç›´æ¥è·³è½¬åˆ°ç»“æŸ \tgoto done } // åˆ¤æ–­æ˜¯å¦è¿­ä»£å®Œæ¯•ï¼Œè‹¥æ˜¯åˆ™ç»“æŸè¿­ä»£ buckets å¹¶æ›´æ–°å½“å‰æ¡¶ä½ç½® \t// å½“å‰æ¡¶å·²ç»æ²¡æœ‰å­˜å‚¨æ•°æ®çš„ä½ç½®äº†ï¼Œåˆ™éœ€è¦ä»overflowæº¢å‡ºæ¡¶ä¸­æŸ¥è¯¢ä½ç½® \t// è·å–æº¢å‡ºbmap  // ä»£è¡¨åœ¨å½“å‰bmapé‡Œé¢ä¹ˆå¾—æ‰¾åˆ°å¯ç”¨çš„åœ°å€ \tovf := b.overflow(t) // æ²¡æœ‰æº¢å‡ºbmapå°±è·³å‡º \tif ovf == nil { break } // ç»§ç»­å¾ªç¯ \tb = ovf } // å¦‚æœæ²¡æ‰¾åˆ°å¯ç”¨çš„æ’æ§½ï¼Œé‚£ä¹ˆå°±åˆ›å»ºä¸€ä¸ª  // åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹  // æ‰©å®¹æ¡ä»¶ä¸ºï¼š  // 1.å½“è£…è½½å› å­=6.5  // 2.æº¢å‡ºbmapè¿‡å¤š  // ç¬¬äºŒç§æƒ…å†µåªä¼šå‡ºç°åœ¨å…ˆå¤§é‡çš„å†™ç„¶åå†å¤§é‡åˆ é™¤çš„æƒ…å†µ \t// Did not find mapping for key. Allocate new cell \u0026 add entry.  // If we hit the max load factor or we have too many overflow buckets, \t// and we're not already in the middle of growing, start growing. \t// åœ¨æ­£å¼å®‰ç½® key ä¹‹å‰ï¼Œè¿˜è¦æ£€æŸ¥ map çš„çŠ¶æ€ï¼Œçœ‹å®ƒæ˜¯å¦éœ€è¦è¿›è¡Œæ‰©å®¹ã€‚å¦‚æœæ»¡è¶³æ‰©å®¹çš„æ¡ä»¶ï¼Œå°±ä¸»åŠ¨è§¦å‘ä¸€æ¬¡æ‰©å®¹æ“ä½œã€‚ \t// è¿™ä¹‹åï¼Œæ•´ä¸ªä¹‹å‰çš„æŸ¥æ‰¾å®šä½ key çš„è¿‡ç¨‹ï¼Œè¿˜å¾—å†é‡æ–°èµ°ä¸€æ¬¡ã€‚å› ä¸ºæ‰©å®¹ä¹‹åï¼Œkey çš„åˆ†å¸ƒéƒ½å‘ç”Ÿäº†å˜åŒ–ã€‚ \tif !h.growing() \u0026\u0026 (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { // æ‰©å®¹ \thashGrow(t, h) // é‡æ–°æ‰¾ \tgoto again // Growing the table invalidates everything, so try again \t} // æ‰€æœ‰çš„å½“å‰æ¡¶éƒ½æ˜¯æ»¡çš„ï¼Œéœ€è¦æ„å»ºä¸€ä¸ªæ–°çš„æº¢å‡ºæ¡¶ \t// å¦‚æœè¿™ä¸ª bucket çš„ 8 ä¸ª key éƒ½å·²ç»æ”¾ç½®æ»¡äº†ï¼Œé‚£åœ¨è·³å‡ºå¾ªç¯åï¼Œå‘ç° inserti å’Œ insertk éƒ½æ˜¯ç©ºï¼Œè¿™æ—¶å€™éœ€è¦åœ¨ bucket åé¢æŒ‚ä¸Š overflow bucket.å“ˆå¸Œä¼šè°ƒç”¨ runtime.hmap.newoverflow åˆ›å»ºæ–°æ¡¶æˆ–è€…ä½¿ç”¨ runtime.hmap é¢„å…ˆåœ¨ noverflow ä¸­åˆ›å»ºå¥½çš„æ¡¶æ¥ä¿å­˜æ•°æ®ï¼Œæ–°åˆ›å»ºçš„æ¡¶ä¸ä»…ä¼šè¢«è¿½åŠ åˆ°å·²æœ‰æ¡¶çš„æœ«å°¾ï¼Œè¿˜ä¼šå¢åŠ å“ˆå¸Œè¡¨çš„ noverflow è®¡æ•°å™¨ã€‚ \t// ç»è¿‡å‰é¢è¿­ä»£å¯»æ‰¾åŠ¨ä½œï¼Œè‹¥æ²¡æœ‰æ‰¾åˆ°å¯æ’å…¥çš„ä½ç½®ï¼Œæ„å‘³ç€å½“å‰çš„æ‰€æœ‰æ¡¶éƒ½æ»¡äº†ï¼Œå°†é‡æ–°åˆ†é…ä¸€ä¸ªæ–°æº¢å‡ºæ¡¶ç”¨äºæ’å…¥åŠ¨ä½œã€‚æœ€åå†åœ¨ä¸Šä¸€æ­¥ç”³è¯·çš„æ–°æ’å…¥ä½ç½®ï¼Œå­˜å‚¨é”®å€¼å¯¹ï¼Œè¿”å›è¯¥å€¼çš„å†…å­˜åœ°å€ \tif inserti == nil { // The current bucket and all the overflow buckets connected to it are full, allocate a new one. \tnewb := h.newoverflow(t, b) inserti = \u0026newb.tophash[0] insertk = add(unsafe.Pointer(newb), dataOffset) elem = add(insertk, bucketCnt*uintptr(t.keysize)) } // å°†æ–°key/elemå­˜å‚¨åœ¨æ’å…¥ä½ç½® \t// store new key/elem at insert position \t// æœ€åï¼Œä¼šæ›´æ–° map ç›¸å…³çš„å€¼ï¼Œå¦‚æœæ˜¯æ’å…¥æ–° keyï¼Œmap çš„å…ƒç´ æ•°é‡å­—æ®µ count å€¼ä¼šåŠ  1ï¼›åœ¨å‡½æ•°ä¹‹åˆè®¾ç½®çš„ hashWriting å†™æ ‡å¿—å‡ºä¼šæ¸…é›¶ã€‚ \tif t.indirectkey() { kmem := newobject(t.key) *(*unsafe.Pointer)(insertk) = kmem insertk = kmem } //å¼•ç”¨ç±»å‹åˆ†é…valueæ‰€éœ€ç©ºé—´ï¼ŒåŒæ—¶æŠŠvalueåœ¨æ§½ä¸­å¯¹åº”çš„ä½ç½®æŒ‡å‘è¿™ä¸ªç©ºé—´ \tif t.indirectelem() { vmem := newobject(t.elem) *(*unsafe.Pointer)(elem) = vmem } //å°†keyå†™å…¥åˆšåˆ†é…çš„ç©ºé—´ \ttypedmemmove(t.key, insertk, key) //æ›´æ–°æ ‡è®°ä½ \t*inserti = top //å…ƒç´ ä¸ªæ•°+1 \th.count++ done: // å†æ¬¡æ ¡éªŒå¹¶å‘å†™ \tif h.flags\u0026hashWriting == 0 { // å¹¶å‘çš„å†™ï¼Œæ ‡è®°åœ¨ä¸Šé¢é€šè¿‡h.flags ^= hashWritingè®¾ç½® \tthrow(\"concurrent map writes\") } // å–æ¶ˆå¹¶å‘å†™çš„æ ‡è®° \th.flags \u0026^= hashWriting if t.indirectelem() { elem = *((*unsafe.Pointer)(elem)) } // è¿”å›å¯ç”¨çš„value å­˜æ”¾åœ°å€  // éšåçš„èµ‹å€¼æ“ä½œä¼šåœ¨æ±‡ç¼–ä¸­è¿›è¡Œ \treturn elem } func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap { var ovf *bmap if h.extra != nil \u0026\u0026 h.extra.nextOverflow != nil { // We have preallocated overflow buckets available. \t// See makeBucketArray for more details. \tovf = h.extra.nextOverflow if ovf.overflow(t) == nil { // We're not at the end of the preallocated overflow buckets. Bump the pointer. \th.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize))) } else { // This is the last preallocated overflow bucket. \t// Reset the overflow pointer on this bucket, \t// which was set to a non-nil sentinel value. \tovf.setoverflow(t, nil) h.extra.nextOverflow = nil } } else { ovf = (*bmap)(newobject(t.bucket)) } h.incrnoverflow() if t.bucket.ptrdata == 0 { h.createOverflow() *h.extra.overflow = append(*h.extra.overflow, ovf) } b.setoverflow(t, ovf) return ovf }   å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­ä¸å­˜åœ¨ï¼Œå“ˆå¸Œä¼šä¸ºæ–°é”®å€¼å¯¹è§„åˆ’å­˜å‚¨çš„å†…å­˜åœ°å€ï¼Œé€šè¿‡ runtime.typedmemmove å°†é”®ç§»åŠ¨åˆ°å¯¹åº”çš„å†…å­˜ç©ºé—´ä¸­å¹¶è¿”å›é”®å¯¹åº”å€¼çš„åœ°å€ valã€‚å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ä¼šç›´æ¥è¿”å›ç›®æ ‡åŒºåŸŸçš„å†…å­˜åœ°å€ï¼Œå“ˆå¸Œå¹¶ä¸ä¼šåœ¨ runtime.mapassign è¿™ä¸ªè¿è¡Œæ—¶å‡½æ•°ä¸­å°†å€¼æ‹·è´åˆ°æ¡¶ä¸­ï¼Œè¯¥å‡½æ•°åªä¼šè¿”å›å†…å­˜åœ°å€ï¼ŒçœŸæ­£çš„èµ‹å€¼æ“ä½œæ˜¯åœ¨ç¼–è¯‘æœŸé—´æ’å…¥çš„ï¼š\n1 2 3 4  00018 (+5) CALL runtime.mapassign_fast64(SB) 00020 (5) MOVQ 24(SP), DI ;; DI = \u0026value 00026 (5) LEAQ go.string.\"88\"(SB), AX ;; AX = \u0026\"88\" 00027 (5) MOVQ AX, (DI) ;; *DI = AX   runtime.mapassign_fast64 ä¸ runtime.mapassign å‡½æ•°çš„é€»è¾‘å·®ä¸å¤šï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨çš„æ˜¯åé¢çš„ä¸‰è¡Œä»£ç ï¼Œå…¶ä¸­ 24(SP) æ˜¯è¯¥å‡½æ•°è¿”å›çš„å€¼åœ°å€ï¼Œæˆ‘ä»¬é€šè¿‡ LEAQ æŒ‡ä»¤å°†å­—ç¬¦ä¸²çš„åœ°å€å­˜å‚¨åˆ°å¯„å­˜å™¨ AX ä¸­ï¼ŒMOVQ æŒ‡ä»¤å°†å­—ç¬¦ä¸² â€œ88â€ å­˜å‚¨åˆ°äº†ç›®æ ‡åœ°å€ä¸Šå®Œæˆäº†è¿™æ¬¡å“ˆå¸Œçš„å†™å…¥ã€‚\nmapdelete å¦‚æœæƒ³è¦åˆ é™¤å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œå°±éœ€è¦ä½¿ç”¨ Go è¯­è¨€ä¸­çš„ delete å…³é”®å­—ï¼Œè¿™ä¸ªå…³é”®å­—çš„å”¯ä¸€ä½œç”¨å°±æ˜¯å°†æŸä¸€ä¸ªé”®å¯¹åº”çš„å…ƒç´ ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œæ— è®ºæ˜¯è¯¥é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¸ªå†…å»ºçš„å‡½æ•°éƒ½ä¸ä¼šè¿”å›ä»»ä½•çš„ç»“æœã€‚\nåœ¨ç¼–è¯‘æœŸé—´ï¼Œdelete å…³é”®å­—ä¼šè¢«è½¬æ¢æˆæ“ä½œä¸º ODELETE çš„èŠ‚ç‚¹ï¼Œè€Œ cmd/compile/internal/gc.walkexpr ä¼šå°† ODELETE èŠ‚ç‚¹è½¬æ¢æˆ runtime.mapdelete å‡½æ•°ç°‡ä¸­çš„ä¸€ä¸ªï¼ŒåŒ…æ‹¬ runtime.mapdeleteã€mapdelete_faststrã€mapdelete_fast32 å’Œ mapdelete_fast64ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func walkexpr(n *Node, init*Nodes) *Node { switch n.Op { case ODELETE: init.AppendNodes(\u0026n.Ninit) map_ := n.List.First() key := n.List.Second() map_ = walkexpr(map_, init) key = walkexpr(key, init) t := map_.Type fast := mapfast(t) if fast == mapslow { key = nod(OADDR, key, nil) } n = mkcall1(mapfndel(mapdelete[fast], t), nil, init, typename(t), map_, key) } }   è¿™äº›å‡½æ•°çš„å®ç°å…¶å®å·®ä¸å¤šï¼Œæˆ‘ä»¬æŒ‘é€‰å…¶ä¸­çš„ runtime.mapdelete åˆ†æä¸€ä¸‹ã€‚å“ˆå¸Œè¡¨çš„åˆ é™¤é€»è¾‘ä¸å†™å…¥é€»è¾‘å¾ˆç›¸ä¼¼ï¼Œåªæ˜¯è§¦å‘å“ˆå¸Œçš„åˆ é™¤éœ€è¦ä½¿ç”¨å…³é”®å­—ï¼Œå¦‚æœåœ¨åˆ é™¤æœŸé—´é‡åˆ°äº†å“ˆå¸Œè¡¨çš„æ‰©å®¹ï¼Œå°±ä¼šåˆ†æµæ¡¶ä¸­çš„å…ƒç´ ï¼Œåˆ†æµç»“æŸä¹‹åä¼šæ‰¾åˆ°æ¡¶ä¸­çš„ç›®æ ‡å…ƒç´ å®Œæˆé”®å€¼å¯¹çš„åˆ é™¤å·¥ä½œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) { if raceenabled \u0026\u0026 h != nil { callerpc := getcallerpc() pc := funcPC(mapdelete) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } if msanenabled \u0026\u0026 h != nil { msanread(key, t.key.size) } if h == nil || h.count == 0 { if t.hashMightPanic() { t.hasher(key, 0) // see issue 23734 \t} return } // æ£€æµ‹æ˜¯å¦æœ‰å¹¶å‘å†™ \tif h.flags\u0026hashWriting != 0 { throw(\"concurrent map writes\") } hash := t.hasher(key, uintptr(h.hash0)) // Set hashWriting after calling t.hasher, since t.hasher may panic, \t// in which case we have not actually done a write (delete). \t// æ ‡è®°æ­¤æ—¶æ­£åœ¨æ‰§è¡Œä¿®æ”¹æ“ä½œ \th.flags ^= hashWriting // æŒ‰ä½ä½è¿›è¡Œæ¡¶çš„é€‰æ‹© \tbucket := hash \u0026 bucketMask(h.B) // è®¡ç®— key çš„å“ˆå¸Œï¼Œæ‰¾åˆ°è½å…¥çš„ bucketã€‚æ£€æŸ¥æ­¤ map å¦‚æœæ­£åœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œç›´æ¥è§¦å‘ä¸€æ¬¡æ¬è¿æ“ä½œã€‚ \tif h.growing() { // è¿›è¡Œæ‰©å®¹ \tgrowWork(t, h, bucket) } b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) bOrig := b top := tophash(hash) search: // åˆ é™¤æ“ä½œåŒæ ·æ˜¯ä¸¤å±‚å¾ªç¯ï¼Œæ ¸å¿ƒè¿˜æ˜¯æ‰¾åˆ° key çš„å…·ä½“ä½ç½®ã€‚å¯»æ‰¾è¿‡ç¨‹éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œåœ¨ bucket ä¸­æŒ¨ä¸ª cell å¯»æ‰¾ã€‚ \t// æ‰¾åˆ°å¯¹åº”ä½ç½®åï¼Œå¯¹ key æˆ–è€… value è¿›è¡Œâ€œæ¸…é›¶â€æ“ä½œï¼š \tfor ; b != nil; b = b.overflow(t) { for i := uintptr(0); i  bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { break search } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) k2 := k // å¯¹ key æ¸…é›¶ \tif t.indirectkey() { k2 = *((*unsafe.Pointer)(k2)) } if !t.key.equal(key, k2) { continue } // Only clear key if there are pointers in it. \t// å¯¹ value æ¸…é›¶ \t// keyæ˜¯æŒ‡é’ˆçš„éœ€è¦ç½®ç©ºï¼Œæ–¹ä¾¿GC \tif t.indirectkey() { *(*unsafe.Pointer)(k) = nil } else if t.key.ptrdata != 0 { memclrHasPointers(k, t.key.size) } e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize)) if t.indirectelem() { *(*unsafe.Pointer)(e) = nil } else if t.elem.ptrdata != 0 { memclrHasPointers(e, t.elem.size) } else { memclrNoHeapPointers(e, t.elem.size) } // æ ‡è®°åˆ é™¤ä½ï¼Œè¯æ˜è¿™ä¸ªä½ç½®å·²è¢«åˆ é™¤ \tb.tophash[i] = emptyOne // If the bucket now ends in a bunch of emptyOne states, \t// change those to emptyRest states. \t// It would be nice to make this a separate function, but \t// for loops are not currently inlineable. \tif i == bucketCnt-1 { // å¦‚æœæ˜¯è¯¥tophashçš„æœ€åä¸€ä¸ªï¼Œåˆ™éœ€è¦åˆ¤æ–­overflowä¸­tophashçš„ç¬¬ä¸€ä½æ˜¯å¦æ˜¯emptyRest \tif b.overflow(t) != nil \u0026\u0026 b.overflow(t).tophash[0] != emptyRest { goto notLast } } else { // å¦‚æœä¸æ˜¯å½“å‰tophashçš„æœ€åä¸€ä¸ªï¼Œåˆ™ç›´æ¥åˆ¤æ–­å½“å‰tophashçš„ä¸‹ä¸€ä¸ªæ˜¯å¦æ˜¯emptyRest \tif b.tophash[i+1] != emptyRest { goto notLast } } // å½“å‰å€¼ä¹‹åä¸å­˜åœ¨å…¶ä»–çš„æ•°æ®ï¼Œåˆ™ç½®ä¸ºemptyRest  // éœ€è¦æŠŠè¯¥ä½ç½®ä¹‹å‰é™¤éç©ºä¹‹å¤–çš„æ‰€æœ‰emptyOneä½ç½®ä¹Ÿç½®ä¸ºemptyRest \tfor { // å°†å¯¹åº”ä½ç½®çš„ tophash å€¼ç½®æˆ Empty \tb.tophash[i] = emptyRest if i == 0 { if b == bOrig { break // beginning of initial bucket, we're done. \t} // Find previous bucket, continue at its last entry. \tc := b for b = bOrig; b.overflow(t) != c; b = b.overflow(t) { } i = bucketCnt - 1 } else { i-- } if b.tophash[i] != emptyOne { break } } notLast: // æœ€åï¼Œå°† count å€¼å‡ 1ã€‚ \th.count-- // Reset the hash seed to make it more difficult for attackers to \t// repeatedly trigger hash collisions. See issue 25237. \tif h.count == 0 { h.hash0 = fastrand() } break search } } // æŠ›å‡ºå¹¶å‘ä¿®æ”¹å¼‚å¸¸ \tif h.flags\u0026hashWriting == 0 { throw(\"concurrent map writes\") } h.flags \u0026^= hashWriting }   æˆ‘ä»¬å…¶å®åªéœ€è¦çŸ¥é“ delete å…³é”®å­—åœ¨ç¼–è¯‘æœŸé—´ç»è¿‡ç±»å‹æ£€æŸ¥å’Œä¸­é—´ä»£ç ç”Ÿæˆé˜¶æ®µè¢«è½¬æ¢æˆ runtime.mapdelete å‡½æ•°ç°‡ä¸­çš„ä¸€å‘˜ï¼Œç”¨äºå¤„ç†åˆ é™¤é€»è¾‘çš„å‡½æ•°ä¸å“ˆå¸Œè¡¨çš„ runtime.mapassign å‡ ä¹å®Œå…¨ç›¸åŒï¼Œä¸å¤ªéœ€è¦åˆ»æ„å…³æ³¨ã€‚\nåˆ é™¤æ•°æ®çš„é€»è¾‘ä¸æ˜¯å¾ˆå¤æ‚ï¼Œä½†æ˜¯é‡Œé¢å¯¹tophashä¸­çš„çŠ¶æ€è¿›è¡Œäº†ç½®æ¢ï¼Œå¢åŠ äº†é˜…è¯»ä»£ç çš„å¤æ‚åº¦ã€‚è¿™é‡Œä¸»è¦æ˜¯emptyOneå’ŒemptyRestè¿™ä¸¤ä¸ªçŠ¶æ€çš„è½¬åŒ–ï¼Œé‡Œé¢æœ‰å‡ ä¸ªä¸´ç•Œç‚¹ï¼Œä¸‹é¢ä¸€ä¸€è¯´æ˜ï¼š\n å½“å‰åˆ é™¤å…ƒç´ æ˜¯tophashä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™éœ€è¦æ£€æŸ¥å®ƒçš„ä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶tophashçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯emptyRestã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥returnã€‚ å½“å‰åˆ é™¤å…ƒç´ ä¸æ˜¯tophashä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™æ£€æŸ¥å½“å‰tophashçš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯emptyRestå³å¯ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥returnã€‚ å‰ä¸¤ä¸ªæ¡ä»¶éƒ½ä¸æ»¡è¶³çš„æƒ…å†µä¸‹ï¼Œåˆ™éœ€è¦å°†å½“å‰ä½ç½®ç½®ä¸ºemptyRestï¼ŒåŒæ—¶è¿˜è¦æ£€æµ‹å®ƒå‰é¢çš„emptyOneçŠ¶æ€çš„å…ƒç´ ï¼Œå°†å…¶å‡ç½®ä¸ºemptyRestï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š  è¿™ç§åˆ é™¤æ–¹å¼ï¼Œä»¥å°‘é‡ç©ºé—´é¿å…äº†è¢«åˆ é™¤çš„æ•°æ®å†æ¬¡æ’å…¥æ—¶å‡ºç°æ•°æ®ç§»åŠ¨çš„æƒ…å†µã€‚äº‹å®ä¸Šï¼ŒGo æ•°æ®ä¸€æ—¦è¢«æ’å…¥åˆ°æ¡¶çš„ç¡®åˆ‡ä½ç½®ï¼Œmap æ˜¯ä¸ä¼šå†ç§»åŠ¨è¯¥æ•°æ®åœ¨æ¡¶ä¸­çš„ä½ç½®äº†ã€‚\næ‰©å®¹ ä½¿ç”¨å“ˆå¸Œè¡¨çš„ç›®çš„å°±æ˜¯è¦å¿«é€ŸæŸ¥æ‰¾åˆ°ç›®æ ‡ keyï¼Œç„¶è€Œï¼Œéšç€å‘ map ä¸­æ·»åŠ çš„ key è¶Šæ¥è¶Šå¤šï¼Œkey å‘ç”Ÿç¢°æ’çš„æ¦‚ç‡ä¹Ÿè¶Šæ¥è¶Šå¤§ã€‚bucket ä¸­çš„ 8 ä¸ª cell ä¼šè¢«é€æ¸å¡æ»¡ï¼ŒæŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ key çš„æ•ˆç‡ä¹Ÿä¼šè¶Šæ¥è¶Šä½ã€‚æœ€ç†æƒ³çš„æƒ…å†µæ˜¯ä¸€ä¸ª bucket åªè£…ä¸€ä¸ª keyï¼Œè¿™æ ·ï¼Œå°±èƒ½è¾¾åˆ° O(1) çš„æ•ˆç‡ï¼Œä½†è¿™æ ·ç©ºé—´æ¶ˆè€—å¤ªå¤§ï¼Œç”¨ç©ºé—´æ¢æ—¶é—´çš„ä»£ä»·å¤ªé«˜ã€‚\nGo è¯­è¨€é‡‡ç”¨ä¸€ä¸ª bucket é‡Œè£…è½½ 8 ä¸ª keyï¼Œå®šä½åˆ°æŸä¸ª bucket åï¼Œè¿˜éœ€è¦å†å®šä½åˆ°å…·ä½“çš„ keyï¼Œè¿™å®é™…ä¸Šåˆç”¨äº†æ—¶é—´æ¢ç©ºé—´ã€‚\nå½“ç„¶ï¼Œè¿™æ ·åšï¼Œè¦æœ‰ä¸€ä¸ªåº¦ï¼Œä¸ç„¶æ‰€æœ‰çš„ key éƒ½è½åœ¨äº†åŒä¸€ä¸ª bucket é‡Œï¼Œç›´æ¥é€€åŒ–æˆäº†é“¾è¡¨ï¼Œå„ç§æ“ä½œçš„æ•ˆç‡ç›´æ¥é™ä¸º O(n)ï¼Œæ˜¯ä¸è¡Œçš„ã€‚\næ‰©å®¹æ—¶æœº å› æ­¤ï¼Œéœ€è¦æœ‰ä¸€ä¸ªæŒ‡æ ‡æ¥è¡¡é‡å‰é¢æè¿°çš„æƒ…å†µï¼Œè¿™å°±æ˜¯è£…è½½å› å­ã€‚\nè£…è½½å› å­çš„è®¡ç®—å…¬å¼æ˜¯ï¼šè£…è½½å› å­=å¡«å…¥è¡¨ä¸­çš„å…ƒç´ ä¸ªæ•°/æ•£åˆ—è¡¨çš„é•¿åº¦ï¼Œè£…è½½å› å­è¶Šå¤§ï¼Œè¯´æ˜ç©ºé—²ä½ç½®è¶Šå°‘ï¼Œå†²çªè¶Šå¤šï¼Œæ•£åˆ—è¡¨çš„æ€§èƒ½ä¼šä¸‹é™ã€‚\n1  loadFactor := count / (2^B)   count å°±æ˜¯ map çš„å…ƒç´ ä¸ªæ•°ï¼Œ2^B è¡¨ç¤º bucket æ•°é‡ã€‚\nå†æ¥è¯´è§¦å‘ map æ‰©å®¹çš„æ—¶æœºï¼šåœ¨å‘ map æ’å…¥æ–° key çš„æ—¶å€™ï¼Œä¼šè¿›è¡Œæ¡ä»¶æ£€æµ‹ï¼Œç¬¦åˆä¸‹é¢è¿™ 2 ä¸ªæ¡ä»¶ï¼Œå°±ä¼šè§¦å‘æ‰©å®¹ï¼š\n è£…è½½å› å­è¶…è¿‡é˜ˆå€¼ï¼Œæºç é‡Œå®šä¹‰çš„é˜ˆå€¼æ˜¯ 6.5ã€‚ overflow çš„ bucket æ•°é‡è¿‡å¤šï¼š  å½“ B å½“ B = 15ï¼Œä¹Ÿå°±æ˜¯ bucket æ€»æ•° 2^B å¤§äºç­‰äº 2^15ï¼Œå¦‚æœ overflow çš„ bucket æ•°é‡è¶…è¿‡ 2^15ã€‚    ä¸è¿‡å› ä¸º Go è¯­è¨€å“ˆå¸Œçš„æ‰©å®¹ä¸æ˜¯ä¸€ä¸ªåŸå­çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥ runtime.mapassign è¿˜éœ€è¦åˆ¤æ–­å½“å‰å“ˆå¸Œæ˜¯å¦å·²ç»å¤„äºæ‰©å®¹çŠ¶æ€ï¼Œé¿å…äºŒæ¬¡æ‰©å®¹é€ æˆæ··ä¹±ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // overLoadFactor reports whether count items placed in 1// è£…è½½å› å­è¶…è¿‡ 6.5 func overLoadFactor(count int, B uint8) bool { return count  bucketCnt \u0026\u0026 uintptr(count)  loadFactorNum*(bucketShift(B)/loadFactorDen) } // tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1// Note that most of these overflow buckets must be in sparse use; // if use was dense, then we'd have already triggered regular map growth. // overflow buckets å¤ªå¤š func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { // If the threshold is too low, we do extraneous work. \t// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. \t// \"too many\" means (approximately) as many overflow buckets as regular buckets. \t// See incrnoverflow for more details. \tif B  15 { B = 15 } // The compiler doesn't see here that B \treturn noverflow = uint16(1)(B\u002615) }   æˆ‘ä»¬çŸ¥é“ï¼Œæ¯ä¸ª bucket æœ‰ 8 ä¸ªç©ºä½ï¼Œåœ¨æ²¡æœ‰æº¢å‡ºï¼Œä¸”æ‰€æœ‰çš„æ¡¶éƒ½è£…æ»¡äº†çš„æƒ…å†µä¸‹ï¼Œè£…è½½å› å­ç®—å‡ºæ¥çš„ç»“æœæ˜¯ 8ã€‚å› æ­¤å½“è£…è½½å› å­è¶…è¿‡ 6.5 æ—¶ï¼Œè¡¨æ˜å¾ˆå¤š bucket éƒ½å¿«è¦è£…æ»¡äº†ï¼ŒæŸ¥æ‰¾æ•ˆç‡å’Œæ’å…¥æ•ˆç‡éƒ½å˜ä½äº†ã€‚åœ¨è¿™ä¸ªæ—¶å€™è¿›è¡Œæ‰©å®¹æ˜¯æœ‰å¿…è¦çš„ã€‚\nå°±æ˜¯è¯´åœ¨è£…è½½å› å­æ¯”è¾ƒå°çš„æƒ…å†µä¸‹ï¼Œè¿™æ—¶å€™ map çš„æŸ¥æ‰¾å’Œæ’å…¥æ•ˆç‡ä¹Ÿå¾ˆä½ï¼Œè€Œç¬¬ 1 ç‚¹è¯†åˆ«ä¸å‡ºæ¥è¿™ç§æƒ…å†µã€‚è¡¨é¢ç°è±¡å°±æ˜¯è®¡ç®—è£…è½½å› å­çš„åˆ†å­æ¯”è¾ƒå°ï¼Œå³ map é‡Œå…ƒç´ æ€»æ•°å°‘ï¼Œä½†æ˜¯ bucket æ•°é‡å¤šï¼ˆçœŸå®åˆ†é…çš„ bucket æ•°é‡å¤šï¼ŒåŒ…æ‹¬å¤§é‡çš„ overflow bucketï¼‰ã€‚\nä¸éš¾æƒ³åƒé€ æˆè¿™ç§æƒ…å†µçš„åŸå› ï¼šä¸åœåœ°æ’å…¥ã€åˆ é™¤å…ƒç´ ã€‚å…ˆæ’å…¥å¾ˆå¤šå…ƒç´ ï¼Œå¯¼è‡´åˆ›å»ºäº†å¾ˆå¤š bucketï¼Œä½†æ˜¯è£…è½½å› å­è¾¾ä¸åˆ°ç¬¬ 1 ç‚¹çš„ä¸´ç•Œå€¼ï¼Œæœªè§¦å‘æ‰©å®¹æ¥ç¼“è§£è¿™ç§æƒ…å†µã€‚ä¹‹åï¼Œåˆ é™¤å…ƒç´ é™ä½å…ƒç´ æ€»æ•°é‡ï¼Œå†æ’å…¥å¾ˆå¤šå…ƒç´ ï¼Œå¯¼è‡´åˆ›å»ºå¾ˆå¤šçš„ overflow bucketï¼Œä½†å°±æ˜¯ä¸ä¼šè§¦çŠ¯ç¬¬ 1 ç‚¹çš„è§„å®šï¼Œä½ èƒ½æ‹¿æˆ‘æ€ä¹ˆåŠï¼Ÿoverflow bucket æ•°é‡å¤ªå¤šï¼Œå¯¼è‡´ key ä¼šå¾ˆåˆ†æ•£ï¼ŒæŸ¥æ‰¾æ’å…¥æ•ˆç‡ä½å¾—å“äººï¼Œå› æ­¤å‡ºå°ç¬¬ 2 ç‚¹è§„å®šã€‚è¿™å°±åƒæ˜¯ä¸€åº§ç©ºåŸï¼Œæˆ¿å­å¾ˆå¤šï¼Œä½†æ˜¯ä½æˆ·å¾ˆå°‘ï¼Œéƒ½åˆ†æ•£äº†ï¼Œæ‰¾èµ·äººæ¥å¾ˆå›°éš¾ã€‚\nå¯¹äºå‘½ä¸­æ¡ä»¶ 1ï¼Œ2 çš„é™åˆ¶ï¼Œéƒ½ä¼šå‘ç”Ÿæ‰©å®¹ã€‚ä½†æ˜¯æ‰©å®¹çš„ç­–ç•¥å¹¶ä¸ç›¸åŒï¼Œæ¯•ç«Ÿä¸¤ç§æ¡ä»¶åº”å¯¹çš„åœºæ™¯ä¸åŒã€‚\næ‰©å®¹æ–¹æ¡ˆ å¯¹äºæ¡ä»¶ 1ï¼Œå…ƒç´ å¤ªå¤šï¼Œè€Œ bucket æ•°é‡å¤ªå°‘ï¼Œå¾ˆç®€å•ï¼šå°† B åŠ  1ï¼Œbucket æœ€å¤§æ•°é‡ï¼ˆ2^Bï¼‰ç›´æ¥å˜æˆåŸæ¥ bucket æ•°é‡çš„ 2 å€ã€‚äºæ˜¯ï¼Œå°±æœ‰æ–°è€ bucket äº†ã€‚æ³¨æ„ï¼Œè¿™æ—¶å€™å…ƒç´ éƒ½åœ¨è€ bucket é‡Œï¼Œè¿˜æ²¡è¿ç§»åˆ°æ–°çš„ bucket æ¥ã€‚è€Œä¸”ï¼Œæ–° bucket åªæ˜¯æœ€å¤§æ•°é‡å˜ä¸ºåŸæ¥æœ€å¤§æ•°é‡ï¼ˆ2^Bï¼‰çš„ 2 å€ï¼ˆ2^B * 2ï¼‰ã€‚\nå¯¹äºæ¡ä»¶ 2ï¼Œå…¶å®å…ƒç´ æ²¡é‚£ä¹ˆå¤šï¼Œä½†æ˜¯ overflow bucket æ•°ç‰¹åˆ«å¤šï¼Œè¯´æ˜å¾ˆå¤š bucket éƒ½æ²¡è£…æ»¡ã€‚è§£å†³åŠæ³•å°±æ˜¯å¼€è¾Ÿä¸€ä¸ªæ–° bucket ç©ºé—´ï¼Œå°†è€ bucket ä¸­çš„å…ƒç´ ç§»åŠ¨åˆ°æ–° bucketï¼Œä½¿å¾—åŒä¸€ä¸ª bucket ä¸­çš„ key æ’åˆ—åœ°æ›´ç´§å¯†ã€‚è¿™æ ·ï¼ŒåŸæ¥ï¼Œåœ¨ overflow bucket ä¸­çš„ key å¯ä»¥ç§»åŠ¨åˆ° bucket ä¸­æ¥ã€‚ç»“æœæ˜¯èŠ‚çœç©ºé—´ï¼Œæé«˜ bucket åˆ©ç”¨ç‡ï¼Œmap çš„æŸ¥æ‰¾å’Œæ’å…¥æ•ˆç‡è‡ªç„¶å°±ä¼šæå‡ã€‚\nå¯¹äºæ¡ä»¶ 2 çš„è§£å†³æ–¹æ¡ˆï¼Œæœ‰ä¸€ä¸ªæç«¯çš„æƒ…å†µï¼šå¦‚æœæ’å…¥ map çš„ key å“ˆå¸Œéƒ½ä¸€æ ·ï¼Œå°±ä¼šè½åˆ°åŒä¸€ä¸ª bucket é‡Œï¼Œè¶…è¿‡ 8 ä¸ªå°±ä¼šäº§ç”Ÿ overflow bucketï¼Œç»“æœä¹Ÿä¼šé€ æˆ overflow bucket æ•°è¿‡å¤šã€‚ç§»åŠ¨å…ƒç´ å…¶å®è§£å†³ä¸äº†é—®é¢˜ï¼Œå› ä¸ºè¿™æ—¶æ•´ä¸ªå“ˆå¸Œè¡¨å·²ç»é€€åŒ–æˆäº†ä¸€ä¸ªé“¾è¡¨ï¼Œæ“ä½œæ•ˆç‡å˜æˆäº† O(n)ã€‚\nå†æ¥çœ‹ä¸€ä¸‹æ‰©å®¹å…·ä½“æ˜¯æ€ä¹ˆåšçš„ã€‚ç”±äº map æ‰©å®¹éœ€è¦å°†åŸæœ‰çš„ key/value é‡æ–°æ¬è¿åˆ°æ–°çš„å†…å­˜åœ°å€ï¼Œå¦‚æœæœ‰å¤§é‡çš„ key/value éœ€è¦æ¬è¿ï¼Œä¼šéå¸¸å½±å“æ€§èƒ½ã€‚å› æ­¤ Go map çš„æ‰©å®¹é‡‡å–äº†ä¸€ç§ç§°ä¸ºâ€œæ¸è¿›å¼â€åœ°æ–¹å¼ï¼ŒåŸæœ‰çš„ key å¹¶ä¸ä¼šä¸€æ¬¡æ€§æ¬è¿å®Œæ¯•ï¼Œæ¯æ¬¡æœ€å¤šåªä¼šæ¬è¿ 2 ä¸ª bucketã€‚\nhashGrow() å‡½æ•°å®é™…ä¸Šå¹¶æ²¡æœ‰çœŸæ­£åœ°â€œæ¬è¿â€ï¼Œå®ƒåªæ˜¯åˆ†é…å¥½äº†æ–°çš„ bucketsï¼Œå¹¶å°†è€çš„ buckets æŒ‚åˆ°äº† oldbuckets å­—æ®µä¸Šã€‚çœŸæ­£æ¬è¿ buckets çš„åŠ¨ä½œåœ¨ growWork() å‡½æ•°ä¸­ï¼Œè€Œè°ƒç”¨ growWork() å‡½æ•°çš„åŠ¨ä½œæ˜¯åœ¨ mapassign å’Œ mapdelete å‡½æ•°ä¸­ã€‚ä¹Ÿå°±æ˜¯æ’å…¥æˆ–ä¿®æ”¹ã€åˆ é™¤ key çš„æ—¶å€™ï¼Œéƒ½ä¼šå°è¯•è¿›è¡Œæ¬è¿ buckets çš„å·¥ä½œã€‚å…ˆæ£€æŸ¥ oldbuckets æ˜¯å¦æ¬è¿å®Œæ¯•ï¼Œå…·ä½“æ¥è¯´å°±æ˜¯æ£€æŸ¥ oldbuckets æ˜¯å¦ä¸º nilã€‚\næ‰©å®¹è¿‡ç¨‹:\n å½“è£…è½½å› å­=6.5æˆ–è€…æº¢å‡ºbmapè¿‡å¤šæ—¶ï¼Œä¼šäº§ç”Ÿæ‰©å®¹ å¦‚æœæ˜¯è£…è½½å› å­=6.5çš„æ‰©å®¹åˆ™ä¸ºç¿»å€æ‰©å®¹ï¼Œåˆ›å»ºä¸€ä¸ªæ¯”å½“å‰æ¡¶ä¸ªæ•°*2çš„æ¡¶åˆ—è¡¨ï¼Œå¦‚æœæº¢å‡ºæ¡¶è¿‡å¤šä½†è£…è½½å› å­ ç„¶åä¼šæŠŠå½“å‰çš„æ¡¶æ”¾åˆ°hmap.oldbucketså­—æ®µä½œä¸ºæ—§æ¡¶ï¼Œç„¶åæŠŠå½“å‰çš„æº¢å‡ºæ¡¶ï¼ˆå¦‚æœæœ‰ï¼‰ä¹Ÿæ”¾åˆ°hmap.extra.oldoverflowä½œä¸ºæ—§çš„æº¢å‡ºæ¡¶ã€‚ åœ¨æ‰©å®¹æ—¶ä¸ä¼šè§¦å‘æ¬è¿æ“ä½œï¼Œæ¬è¿æ“ä½œåªä¼šåœ¨å†™å…¥/åˆ é™¤æ“ä½œæ—¶è¢«è§¦å‘ã€‚ æ¬è¿æ“ä½œè¿‡ç¨‹ï¼š  ç¿»å€æ‰©å®¹æ¬è¿è¿‡ç¨‹ï¼š  æ‰¾åˆ°å½“å‰keyçš„hashå¯¹åº”çš„æ—§æ¡¶ç„¶åç®—å‡ºå¯¹åº”çš„æ–°æ¡¶ä¿å­˜å…¶ä¸Šä¸‹æ–‡xy[0]ï¼Œå†æ‰¾åˆ°ä¸€ä¸ªæ ¹æ®å½“å‰æ–°æ¡¶+æ—§æ¡¶æ•°é‡åç§»çš„å“ªä¸ªæ¡¶xy[1]ï¼Œä¹Ÿä¿å­˜å…¶ä¸Šä¸‹æ–‡ã€‚æ¯”å¦‚å½“å‰keyçš„å“ˆå¸Œå¯¹åº”çš„æ—§æ¡¶æ˜¯3å·ï¼Œé‚£ä¹ˆxy[0]ä¹Ÿæ˜¯æ–°æ¡¶çš„3å·æ¡¶ï¼Œç„¶åxy[1]çš„æ¡¶å·å°±ä¸º3+æ—§æ¡¶çš„ä¸ªæ•°ã€æ¯”å¦‚7å·ã€‚ ç”±äºç¿»å€æ‰©å®¹æ—¶å½“å‰æ—§æ¡¶å¯¹åº”ä¸¤ä¸ªæ–°æ¡¶ï¼Œæ‰€ä»¥éœ€è¦é’ˆå¯¹å½“å‰æ—§æ¡¶ä¸­çš„keyåšé‡æ–°hashï¼Œé€‰æ‹©ä¸€ä¸ªç›®æ ‡æ¡¶å‡ºæ¥ï¼Œå³å½“å‰keyå¤„äº3å·æ¡¶ï¼Œç»è¿‡é‡æ–°å“ˆå¸Œåå¯èƒ½æ”¾åˆ°äº†7å·æ¡¶ï¼Œæ‰¾åˆ°ç›®æ ‡æ¡¶åï¼Œå°†å¯¹åº”çš„keyï¼Œvalueï¼Œtophashå¤åˆ¶è¿‡å»ï¼Œå®Œæˆä¸€ä¸ªkey-valueçš„æ¬è¿ã€‚ç„¶åå¾ªç¯æ­¤è¿‡ç¨‹ã€‚   ç­‰é‡æ‰©å®¹æ¬è¿è¿‡ç¨‹ï¼š  ä¸ç¿»å€æ‰©å®¹ç›¸åŒï¼Œä½†åªä¿å­˜ä¸€ä¸ªæ–°æ¡¶çš„ä¸Šä¸‹æ–‡ï¼Œå› ä¸ºç­‰é‡æ‰©å®¹æ²¡æœ‰åˆ›å»ºæ›´å¤šçš„æ¡¶ï¼Œæ‰©å®¹æ˜¯å¯¹åº”çš„å…³ç³»ï¼Œå³å½“å‰çš„keyå¤„äº3å·æ¡¶ï¼Œæ¬è¿åä¹Ÿå±äº3å·æ¡¶ã€‚ å‰©ä½™è¿‡ç¨‹ä¸ç¿»å€æ‰©å®¹ç›¸åŒã€‚   æ¬è¿å®Œæ¯•åï¼Œå°†æ—§æ¡¶åšä¸€äº›æ ‡è®°ä»¥ä¾¿å¯ä»¥gcæ¸…é™¤ï¼Œç„¶åå¦‚æœæ­¤æ¬¡æ¬è¿æ˜¯æŒ‰ç…§é¡ºåºæ¬è¿ï¼Œå³ h.nevacuateè®°å½•çš„æ¡¶æ¬è¿çš„ï¼Œåˆ™æ›´æ–° h.nevacuateåˆ°ä¸‹æ¬¡åº”è¯¥æ¬è¿çš„æ¡¶ä¸Šã€‚    æ‰©å®¹ä¸­:\n mapasssign:å°†å‘½ä¸­çš„ bucket ä» oldbuckets é¡ºæ‰‹æ¬è¿åˆ°buckets ä¸­ï¼Œé¡ºä¾¿å†å¤šæ¬è¿ä¸€ä¸ª bucket mapdelete:å°†å‘½ä¸­çš„ bucket ä» oldbuckets é¡ºæ‰‹æ¬è¿åˆ°buckets ä¸­ï¼Œé¡ºä¾¿å†å¤šæ¬è¿ä¸€ä¸ª bucket mapaccess: ä¼˜å…ˆåœ¨ oldbuckets ä¸­æ‰¾ï¼Œå¦‚æœå‘½ä¸­ï¼Œåˆ™è¯´æ˜è¿™ä¸ª bucket æ²¡æœ‰è¢«æ¬è¿ æ¬è¿ bucket x æ—¶ï¼Œä¼šè¢«è¯¥æ¡¶çš„ overflow æ¡¶ä¹Ÿä¸€å¹¶æ¬å®Œ  hashGrow æˆ‘ä»¬å…ˆçœ‹ hashGrow() å‡½æ•°æ‰€åšçš„å·¥ä½œï¼Œå†æ¥çœ‹å…·ä½“çš„æ¬è¿ buckets æ˜¯å¦‚ä½•è¿›è¡Œçš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  func hashGrow(t *maptype, h *hmap) { // If we've hit the load factor, get bigger. \t// Otherwise, there are too many overflow buckets, \t// so keep the same number of buckets and \"grow\" laterally. \t// éœ€è¦æ‰©å®¹å¤šå°‘bmap  // é»˜è®¤ä¸ºç¿»å€æ‰©å®¹  // æ­¤æƒ…å†µä¸ºè£…è½½å› å­=6.5 \t// B+1 ç›¸å½“äºæ˜¯åŸæ¥ 2 å€çš„ç©ºé—´ \tbigger := uint8(1) // å¯¹åº”æ¡ä»¶ 2 \tif !overLoadFactor(h.count+1, h.B) { // è¿™é‡Œè¡¨ç¤ºæ˜¯æº¢å‡ºæ¡¶æ•°é‡æ•°é‡è¿‡å¤šï¼Œä½†æ˜¯mapä¸­å…ƒç´ æ•°é‡è¿˜è¾¾ä¸åˆ°è¿‡è½½ï¼Œåˆ™æ— éœ€å¢é•¿æ¡¶æ•°é‡  // åˆ†é…ä¸€ä¸ªä¸ä¹‹å‰ä¸€æ ·çš„å³å¯ï¼Œå°†æ‰€æœ‰æ•°æ®æ‘Šå¹³ï¼Œå‡å°‘æº¢å‡ºæ¡¶çš„æ•°é‡ \t// è¿›è¡Œç­‰é‡çš„å†…å­˜æ‰©å®¹ï¼Œæ‰€ä»¥ B ä¸å˜ \tbigger = 0 h.flags |= sameSizeGrow } // å°†è€ buckets æŒ‚åˆ° buckets ä¸Š \toldbuckets := h.buckets // ç”³è¯·æ–°çš„ buckets ç©ºé—´ \tnewbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) flags := h.flags \u0026^ (iterator | oldIterator) // å¦‚æœå½“å‰çŠ¶æ€ä¸æ˜¯è¿­ä»£çŠ¶æ€ \tif h.flags\u0026iterator != 0 { // è®©è¿­ä»£çš„æ—¶å€™å»è¿­ä»£æ—§æ¡¶  // å› ä¸ºè¿˜æ²¡æœ‰æ¬è¿å®Œæ¯• \tflags |= oldIterator } // commit the grow (atomic wrt gc) \t// æäº¤ grow çš„åŠ¨ä½œ \th.B += bigger h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets // æ¬è¿è¿›åº¦ä¸º 0 \th.nevacuate = 0 // overflow buckets æ•°ä¸º 0 \th.noverflow = 0 // å¦‚æœä¹‹å‰æœ‰æº¢å‡ºbmapçš„è¯ï¼ŒæŠŠåŸæ¥æ‰€æŒæœ‰çš„æº¢å‡ºbmapä¹Ÿå˜æˆæ—§çš„æº¢å‡ºbmap \tif h.extra != nil \u0026\u0026 h.extra.overflow != nil { // Promote current overflow buckets to the old generation. \tif h.extra.oldoverflow != nil { throw(\"oldoverflow is not nil\") } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } // å¦‚æœæ‰©å®¹çš„æ–°bmapåˆ—è¡¨å­˜åœ¨å¯ç”¨æº¢å‡ºbmap  // é‚£å°±è®¾ç½®ä¸€ä¸‹ \tif nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally \t// by growWork() and evacuate(). \t// æ­¤å¤„æ²¡æœ‰å‘ç°æ‰©å®¹æ—¶çš„æ•°æ®æ¬è¿ï¼ˆä»æ—§bmapä¸­æ‹·è´åŸæ•°æ®åˆ°æ–°çš„bmapä¸­ï¼‰å·¥ä½œ  // å› ä¸ºå“ˆå¸Œè¡¨æ•°æ®çš„å®é™…å¤åˆ¶æ˜¯ç”±growWork()å’Œevacuate()é€æ­¥å®Œæˆçš„ã€‚  // è¿™ä¸¤ä¸ªå‡½æ•°çš„è§¦å‘æ—¶æœºæ˜¯åœ¨å†™/åˆ é™¤æ“ä½œæ—¶è§¦å‘ }   ä¸»è¦æ˜¯ç”³è¯·åˆ°äº†æ–°çš„ buckets ç©ºé—´ï¼ŒæŠŠç›¸å…³çš„æ ‡å¿—ä½éƒ½è¿›è¡Œäº†å¤„ç†ï¼šä¾‹å¦‚æ ‡å¿— nevacuate è¢«ç½®ä¸º 0ï¼Œ è¡¨ç¤ºå½“å‰æ¬è¿è¿›åº¦ä¸º 0ã€‚\nå“ˆå¸Œåœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ä¼šé€šè¿‡ runtime.makeBucketArray åˆ›å»ºä¸€ç»„æ–°æ¡¶å’Œé¢„åˆ›å»ºçš„æº¢å‡ºæ¡¶ï¼Œéšåå°†åŸæœ‰çš„æ¡¶æ•°ç»„è®¾ç½®åˆ° oldbuckets ä¸Šå¹¶å°†æ–°çš„ç©ºæ¡¶è®¾ç½®åˆ° buckets ä¸Šï¼Œæº¢å‡ºæ¡¶ä¹Ÿä½¿ç”¨äº†ç›¸åŒçš„é€»è¾‘æ›´æ–°ï¼Œä¸‹å›¾å±•ç¤ºäº†è§¦å‘æ‰©å®¹åçš„å“ˆå¸Œï¼š\næ‰©å®¹åŸºæœ¬é‡‡å–2*N + N/16çš„æ–¹å¼(2å€æ‰©å®¹)ï¼Œå¤šå‡ºæ¥çš„N/16ç”¨äºæ§½æ»¡çš„æƒ…å†µï¼Œæ–°å¢çš„èŠ‚ç‚¹å°±ä»è¿™å¤šå‡ºæ¥çš„åœ°æ–¹å–ï¼Œå¦‚æœå¤šå‡ºæ¥çš„æ§½ä¹Ÿç”¨å®Œäº†å°±ç›´æ¥newæ–°çš„å†…å­˜\nå€¼å¾—ä¸€è¯´çš„æ˜¯å¯¹ h.flags çš„å¤„ç†ï¼š\n1 2 3 4  flags := h.flags \u0026^ (iterator | oldIterator) if h.flags\u0026iterator != 0 { flags |= oldIterator }   è¿™é‡Œå¾—å…ˆè¯´ä¸‹è¿ç®—ç¬¦ï¼š\u0026^ã€‚è¿™å«æŒ‰ä½ç½®0è¿ç®—ç¬¦ã€‚ä¾‹å¦‚ï¼š\n1 2 3  x = 01010011 y = 01010100 z = x \u0026^ y = 00000011   å¦‚æœ y bit ä½ä¸º 1ï¼Œé‚£ä¹ˆç»“æœ z å¯¹åº” bit ä½å°±ä¸º 0ï¼Œå¦åˆ™ z å¯¹åº” bit ä½å°±å’Œ x å¯¹åº” bit ä½çš„å€¼ç›¸åŒã€‚\næ‰€ä»¥ä¸Šé¢é‚£æ®µå¯¹ flags ä¸€é¡¿æ“ä½œçš„ä»£ç çš„æ„æ€æ˜¯ï¼šå…ˆæŠŠ h.flags ä¸­ iterator å’Œ oldIterator å¯¹åº”ä½æ¸… 0ï¼Œç„¶åå¦‚æœå‘ç° iterator ä½ä¸º 1ï¼Œé‚£å°±æŠŠå®ƒè½¬æ¥åˆ° oldIterator ä½ï¼Œä½¿å¾— oldIterator æ ‡å¿—ä½å˜æˆ 1ã€‚æ½œå°è¯å°±æ˜¯ï¼šbuckets ç°åœ¨æŒ‚åˆ°äº† oldBuckets åä¸‹äº†ï¼Œå¯¹åº”çš„æ ‡å¿—ä½ä¹Ÿè½¬æ¥è¿‡å»å§ã€‚\ngrowWork å†æ¥çœ‹çœ‹çœŸæ­£æ‰§è¡Œæ¬è¿å·¥ä½œçš„ growWork() å‡½æ•°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func growWork(t *maptype, h *hmap, bucket uintptr) { // make sure we evacuate the oldbucket corresponding \t// to the bucket we're about to use \t// ç¡®è®¤æ¬è¿è€çš„ bucket å¯¹åº”æ­£åœ¨ä½¿ç”¨çš„ bucket \t// è¦ç¡®ä¿æˆ‘ä»¬è¿ç§»çš„æ¡¶å’Œå½“å‰ç”¨çš„æ¡¶æ˜¯ä¸€è‡´çš„ \tevacuate(t, h, bucket\u0026h.oldbucketmask()) // evacuate one more oldbucket to make progress on growing \t// å¦‚æœæ¬å®Œäº†ä¸€ä¸ªä¹‹åå‘ç°è¿˜æ²¡æ¬è¿å®Œ  // å°±å†æ¬ä¸€ä¸ª \t// è¿›è¡Œè¾…åŠ©è¿ç§»ï¼Œå½“å‰æ¡¶è¿ç§»å®ŒæˆæŸ¥çœ‹mapæ˜¯å¦è¿˜åœ¨æ‰©å®¹è¿‡ç¨‹ä¸­ï¼Œå¹¶å¸®åŠ©è¿›è¡Œè¿ç§» \tif h.growing() { evacuate(t, h, h.nevacuate) } } // oldbucketmask provides a mask that can be applied to calculate n % noldbuckets(). func (h *hmap) oldbucketmask() uintptr { return h.noldbuckets() - 1 }   h.growing() å‡½æ•°éå¸¸ç®€å•ï¼š\n1 2 3 4  // growing reports whether h is growing. The growth may be to the same size or bigger. func (h *hmap) growing() bool { return h.oldbuckets != nil }   å¦‚æœ oldbuckets ä¸ä¸ºç©ºï¼Œè¯´æ˜è¿˜æ²¡æœ‰æ¬è¿å®Œæ¯•ï¼Œè¿˜å¾—ç»§ç»­æ¬ã€‚\nbucket\u0026h.oldbucketmask() è¿™è¡Œä»£ç ï¼Œå¦‚æºç æ³¨é‡Šé‡Œè¯´çš„ï¼Œæ˜¯ä¸ºäº†ç¡®è®¤æ¬è¿çš„ bucket æ˜¯æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„ bucket.oldbucketmask() å‡½æ•°è¿”å›æ‰©å®¹å‰çš„ map çš„ bucketmaskã€‚\næ‰€è°“çš„ bucketmaskï¼Œä½œç”¨å°±æ˜¯å°† key è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ä¸ bucketmask ç›¸ä¸ï¼Œå¾—åˆ°çš„ç»“æœå°±æ˜¯ key åº”è¯¥è½å…¥çš„æ¡¶ã€‚æ¯”å¦‚ B = 5ï¼Œé‚£ä¹ˆ bucketmask çš„ä½ 5 ä½æ˜¯ 11111ï¼Œå…¶ä½™ä½æ˜¯ 0ï¼Œhash å€¼ä¸å…¶ç›¸ä¸çš„æ„æ€æ˜¯ï¼Œåªæœ‰ hash å€¼çš„ä½ 5 ä½å†³ç­– key åˆ°åº•è½å…¥å“ªä¸ª bucketã€‚\nevacuate æ¬è¿çš„ç›®çš„å°±æ˜¯å°†è€çš„ buckets æ¬è¿åˆ°æ–°çš„ bucketsã€‚è€Œé€šè¿‡å‰é¢çš„è¯´æ˜æˆ‘ä»¬çŸ¥é“ï¼Œåº”å¯¹æ¡ä»¶ 1ï¼Œæ–°çš„ buckets æ•°é‡æ˜¯ä¹‹å‰çš„ä¸€å€ï¼Œåº”å¯¹æ¡ä»¶ 2ï¼Œæ–°çš„ buckets æ•°é‡å’Œä¹‹å‰ç›¸ç­‰ã€‚\nå¯¹äºæ¡ä»¶ 2ï¼Œä»è€çš„ buckets æ¬è¿åˆ°æ–°çš„ bucketsï¼Œç”±äº bucktes æ•°é‡ä¸å˜ï¼Œå› æ­¤å¯ä»¥æŒ‰åºå·æ¥æ¬ï¼Œæ¯”å¦‚åŸæ¥åœ¨ 0 å· bucktesï¼Œåˆ°æ–°çš„åœ°æ–¹åï¼Œä»ç„¶æ”¾åœ¨ 0 å· bucketsã€‚\nå¯¹äºæ¡ä»¶ 1ï¼Œå°±æ²¡è¿™ä¹ˆç®€å•äº†ã€‚è¦é‡æ–°è®¡ç®— key çš„å“ˆå¸Œï¼Œæ‰èƒ½å†³å®šå®ƒåˆ°åº•è½åœ¨å“ªä¸ª bucketã€‚ä¾‹å¦‚ï¼ŒåŸæ¥ B = 5ï¼Œè®¡ç®—å‡º key çš„å“ˆå¸Œåï¼Œåªç”¨çœ‹å®ƒçš„ä½ 5 ä½ï¼Œå°±èƒ½å†³å®šå®ƒè½åœ¨å“ªä¸ª bucketã€‚æ‰©å®¹åï¼ŒB å˜æˆäº† 6ï¼Œå› æ­¤éœ€è¦å¤šçœ‹ä¸€ä½ï¼Œå®ƒçš„ä½ 6 ä½å†³å®š key è½åœ¨å“ªä¸ª bucketã€‚è¿™ç§°ä¸º rehashã€‚\nå› æ­¤ï¼ŒæŸä¸ª key åœ¨æ¬è¿å‰å bucket åºå·å¯èƒ½å’ŒåŸæ¥ç›¸ç­‰ï¼Œä¹Ÿå¯èƒ½æ˜¯ç›¸æ¯”åŸæ¥åŠ ä¸Š 2^Bï¼ˆåŸæ¥çš„ B å€¼ï¼‰ï¼Œå–å†³äº hash å€¼ ç¬¬ 6 bit ä½æ˜¯ 0 è¿˜æ˜¯ 1ã€‚\nç†è§£äº†ä¸Šé¢ bucket åºå·çš„å˜åŒ–ï¼Œæˆ‘ä»¬å°±å¯ä»¥å›ç­”å¦ä¸€ä¸ªé—®é¢˜äº†ï¼šä¸ºä»€ä¹ˆéå† map æ˜¯æ— åºçš„ï¼Ÿ\nmap åœ¨æ‰©å®¹åï¼Œä¼šå‘ç”Ÿ key çš„æ¬è¿ï¼ŒåŸæ¥è½åœ¨åŒä¸€ä¸ª bucket ä¸­çš„ keyï¼Œæ¬è¿åï¼Œæœ‰äº› key å°±è¦è¿œèµ°é«˜é£äº†ï¼ˆbucket åºå·åŠ ä¸Šäº† 2^Bï¼‰ã€‚è€Œéå†çš„è¿‡ç¨‹ï¼Œå°±æ˜¯æŒ‰é¡ºåºéå† bucketï¼ŒåŒæ—¶æŒ‰é¡ºåºéå† bucket ä¸­çš„ keyã€‚æ¬è¿åï¼Œkey çš„ä½ç½®å‘ç”Ÿäº†é‡å¤§çš„å˜åŒ–ï¼Œæœ‰äº› key é£ä¸Šé«˜æï¼Œæœ‰äº› key åˆ™åŸåœ°ä¸åŠ¨ã€‚è¿™æ ·ï¼Œéå† map çš„ç»“æœå°±ä¸å¯èƒ½æŒ‰åŸæ¥çš„é¡ºåºäº†ã€‚\nå½“ç„¶ï¼Œå¦‚æœæˆ‘å°±ä¸€ä¸ª hard code çš„ mapï¼Œæˆ‘ä¹Ÿä¸ä¼šå‘ map è¿›è¡Œæ’å…¥åˆ é™¤çš„æ“ä½œï¼ŒæŒ‰ç†è¯´æ¯æ¬¡éå†è¿™æ ·çš„ map éƒ½ä¼šè¿”å›ä¸€ä¸ªå›ºå®šé¡ºåºçš„ key/value åºåˆ—å§ã€‚çš„ç¡®æ˜¯è¿™æ ·ï¼Œä½†æ˜¯ Go æœç»äº†è¿™ç§åšæ³•ï¼Œå› ä¸ºè¿™æ ·ä¼šç»™æ–°æ‰‹ç¨‹åºå‘˜å¸¦æ¥è¯¯è§£ï¼Œä»¥ä¸ºè¿™æ˜¯ä¸€å®šä¼šå‘ç”Ÿçš„äº‹æƒ…ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šé…¿æˆå¤§é”™ã€‚\nå½“ç„¶ï¼ŒGo åšå¾—æ›´ç»ï¼Œå½“æˆ‘ä»¬åœ¨éå† map æ—¶ï¼Œå¹¶ä¸æ˜¯å›ºå®šåœ°ä» 0 å· bucket å¼€å§‹éå†ï¼Œæ¯æ¬¡éƒ½æ˜¯ä»ä¸€ä¸ªéšæœºå€¼åºå·çš„ bucket å¼€å§‹éå†ï¼Œå¹¶ä¸”æ˜¯ä»è¿™ä¸ª bucket çš„ä¸€ä¸ªéšæœºåºå·çš„ cell å¼€å§‹éå†ã€‚è¿™æ ·ï¼Œå³ä½¿ä½ æ˜¯ä¸€ä¸ªå†™æ­»çš„ mapï¼Œä»…ä»…åªæ˜¯éå†å®ƒï¼Œä¹Ÿä¸å¤ªå¯èƒ½ä¼šè¿”å›ä¸€ä¸ªå›ºå®šåºåˆ—çš„ key/value å¯¹äº†ã€‚\nå¤šè¯´ä¸€å¥ï¼Œâ€œè¿­ä»£ map çš„ç»“æœæ˜¯æ— åºçš„â€è¿™ä¸ªç‰¹æ€§æ˜¯ä» go 1.0 å¼€å§‹åŠ å…¥çš„ã€‚\nå†æ˜ç¡®ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœæ‰©å®¹åï¼ŒB å¢åŠ äº† 1ï¼Œæ„å‘³ç€ buckets æ€»æ•°æ˜¯åŸæ¥çš„ 2 å€ï¼ŒåŸæ¥ 1 å·çš„æ¡¶â€œè£‚å˜â€åˆ°ä¸¤ä¸ªæ¡¶ã€‚\nä¾‹å¦‚ï¼ŒåŸå§‹ B = 2ï¼Œ1å· bucket ä¸­æœ‰ 2 ä¸ª key çš„å“ˆå¸Œå€¼ä½ 3 ä½åˆ†åˆ«ä¸ºï¼š010ï¼Œ110ã€‚ç”±äºåŸæ¥ B = 2ï¼Œæ‰€ä»¥ä½ 2 ä½ 10 å†³å®šå®ƒä»¬è½åœ¨ 2 å·æ¡¶ï¼Œç°åœ¨ B å˜æˆ 3ï¼Œæ‰€ä»¥ 010ã€110 åˆ†åˆ«è½å…¥ 2ã€6 å·æ¡¶ã€‚\nç†è§£äº†è¿™ä¸ªï¼Œåé¢è®² map è¿­ä»£çš„æ—¶å€™ä¼šç”¨åˆ°ã€‚\næºç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233  // evacDst is an evacuation destination. // ç”¨äºä¿å­˜åˆ†é…ä¸Šä¸‹æ–‡çš„ç»“æ„ä½“ type evacDst struct { // è¡¨ç¤ºbucket ç§»åŠ¨çš„ç›®æ ‡åœ°å€ \tb *bmap // current destination bucket \t// æŒ‡å‘ x,y ä¸­çš„ key/val \ti int // key/elem index into b \t// æŒ‡å‘ xï¼Œy ä¸­çš„ key \tk unsafe.Pointer // pointer to current key storage \t// æŒ‡å‘ xï¼Œy ä¸­çš„ value \te unsafe.Pointer // pointer to current elem storage } // å®é™…çš„æ—§bmap æ¬è¿åˆ°æ–°bmapçš„é€»è¾‘  // ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯æ¬è¿çš„é‚£ä¸ªæ¡¶ func evacuate(t *maptype, h *hmap, oldbucket uintptr) { // å®šä½è€çš„ bucket åœ°å€ \tb := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) // ç»“æœæ˜¯ 2^Bï¼Œå¦‚ B = 5ï¼Œç»“æœä¸º32 \t// ç®—ä¸€ä¸‹ä¹‹å‰æœ‰å¤šå°‘ä¸ªæ¡¶ \tnewbit := h.noldbuckets() // å¦‚æœ b æ²¡æœ‰è¢«æ¬è¿è¿‡ \tif !evacuated(b) { // TODO: reuse overflow buckets instead of using new ones, if there \t// is no iterator using the old buckets. (If !oldIterator.)  // xy contains the x and y (low and high) evacuation destinations. \t// è¿™é‡Œåˆ†ä¸ºXåŒºå’ŒYåŒºï¼Œå³ä½ä½åŒºå’Œé«˜ä½åŒºï¼Œæ‰©å®¹ä¹‹åæ¡¶å®¹é‡ç¿»å€ï¼Œéœ€è¦æŠŠåŸæœ‰æ•°æ®  // å‡åŒ€çš„åˆ†æ•£åœ¨è¿™ä¸¤ä¸ªåŒºåŸŸ \t// è¡¨ç¤ºbucket ç§»åŠ¨çš„ç›®æ ‡åœ°å€ \t// ç”Ÿæˆä¸¤ä¸ªç”¨äºä¿å­˜æ–°æ¡¶ä¸Šä¸‹æ–‡çš„ç»“æ„ä½“ \tvar xy [2]evacDst // å…ˆä¿å­˜ä¸€ä¸ª æ–°bmapçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ \tx := \u0026xy[0] // é»˜è®¤æ˜¯ç­‰ size æ‰©å®¹ï¼Œå‰å bucket åºå·ä¸å˜ \t// ä½¿ç”¨ x æ¥è¿›è¡Œæ¬è¿ \tx.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize))) x.k = add(unsafe.Pointer(x.b), dataOffset) x.e = add(x.k, bucketCnt*uintptr(t.keysize)) // å¦‚æœä¸æ˜¯ç­‰ size æ‰©å®¹ï¼Œå‰å bucket åºå·æœ‰å˜ \t// ä½¿ç”¨ y æ¥è¿›è¡Œæ¬è¿ \t// å¦‚æœå½“å‰ä¸æ˜¯ç­‰é‡æ‰©å®¹ï¼ˆæ•´ç†ï¼‰  // é‚£ä¹ˆå°±æ¬ä¸¤ä¸ªæ¡¶  // å†è·å–ä¸€ä¸ªæ–°çš„bmapçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ \tif !h.sameSizeGrow() { // Only calculate y pointers if we're growing bigger. \t// Otherwise GC can see bad pointers. \t// y ä»£è¡¨çš„ bucket åºå·å¢åŠ äº† 2^B \t// ä»…ä»…åœ¨mapå®¹é‡ç¿»å€ä¹‹åå†è®¡ç®—YåŒºçš„åœ°å€ï¼Œå¦åˆ™GCä¼šçœ‹åˆ°ä¸€ä¸ªä¸å­˜åœ¨çš„æŒ‡é’ˆã€‚ \ty := \u0026xy[1] y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize))) y.k = add(unsafe.Pointer(y.b), dataOffset) y.e = add(y.k, bucketCnt*uintptr(t.keysize)) } // éå†æ‰€æœ‰çš„ bucketï¼ŒåŒ…æ‹¬ overflow buckets \t// b æ˜¯è€çš„ bucket åœ°å€ \t// å¾ªç¯å½“å‰éœ€è¦æ¬è¿çš„bmapåŠå…¶æº¢å‡ºbmap \tfor ; b != nil; b = b.overflow(t) { // æ‰¾åˆ°ç¬¬ä¸€ä¸ªkeyå’Œå¯¹åº”çš„valueçš„åœ°å€ \tk := add(unsafe.Pointer(b), dataOffset) e := add(k, bucketCnt*uintptr(t.keysize)) // éå† bucket ä¸­çš„æ‰€æœ‰ cell \tfor i := 0; i  bucketCnt; i, k, e = i+1, add(k, uintptr(t.keysize)), add(e, uintptr(t.elemsize)) { // å½“å‰ cell çš„ top hash å€¼ \ttop := b.tophash[i] // å¦‚æœ cell ä¸ºç©ºï¼Œå³æ²¡æœ‰ key \tif isEmpty(top) { // é‚£å°±æ ‡å¿—å®ƒè¢«\"æ¬è¿\"è¿‡ \tb.tophash[i] = evacuatedEmpty // ç»§ç»­ä¸‹ä¸ª cell \tcontinue } // æ­£å¸¸ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µ \t// æœªè¢«æ¬è¿çš„ cell åªå¯èƒ½æ˜¯ empty æˆ–æ˜¯ \t// æ­£å¸¸çš„ top hashï¼ˆå¤§äº minTopHashï¼‰ \tif top  minTopHash { throw(\"bad map state\") } k2 := k // å¦‚æœ key æ˜¯æŒ‡é’ˆï¼Œåˆ™è§£å¼•ç”¨ \tif t.indirectkey() { k2 = *((*unsafe.Pointer)(k2)) } var useY uint8 // å¦‚æœä¸æ˜¯ç­‰é‡æ‰©å®¹ \tif !h.sameSizeGrow() { // Compute hash to make our evacuation decision (whether we need \t// to send this key/elem to bucket x or bucket y). \t// é‚£ä¹ˆå°±éœ€è¦é‡æ–°è®¡ç®—å½“å‰è¿™ä¸ªkeyåº”è¯¥è½åˆ°xy[0]è¿˜æ˜¯xy[1]è¿™ä¸¤ä¸ªæ–°æ¡¶çš„å“ªä¸ªä¸­å»  // å› ä¸ºç­‰é‡æ‰©å®¹æ˜¯æ•´ç†ï¼Œæ¡¶çš„æ•°é‡å¹¶æ²¡æœ‰å¢åŠ ï¼Œæ‰€ä»¥åŸæ¥åœ¨å“ªè¿˜æ˜¯åœ¨å“ª  // ä½†æ˜¯ç¿»å€æ‰©å®¹åˆ™æ˜¯å¢åŠ äº†æ–°çš„æ¡¶ï¼Œå°±éœ€è¦é‡æ–°è®¡ç®—hash  // ä¹Ÿå°±æ˜¯è¯´ç¿»å€æ‰©å®¹å¯èƒ½å¯¼è‡´å½“å‰keyçš„å“ˆå¸Œå€¼å’Œä¹‹åçš„ä¸æ˜¯åŒä¸€ä¸ª \t// è®¡ç®— hash å€¼ï¼Œå’Œ key ç¬¬ä¸€æ¬¡å†™å…¥æ—¶ä¸€æ · \thash := t.hasher(k2, uintptr(h.hash0)) // å¦‚æœæœ‰åç¨‹æ­£åœ¨éå† map \t// å¦‚æœå‡ºç° ç›¸åŒçš„ key å€¼ï¼Œç®—å‡ºæ¥çš„ hash å€¼ä¸åŒ \t// è¿™ä¸ªæ˜¯è®¡ç®—åˆ°åº•è¯¥æŠŠå½“å‰çš„key-value æ”¾åˆ°xy[0]è¿˜æ˜¯xy[1] \tif h.flags\u0026iterator != 0 \u0026\u0026 !t.reflexivekey() \u0026\u0026 !t.key.equal(k2, k2) { // åªæœ‰åœ¨ float å˜é‡çš„ NaN() æƒ…å†µä¸‹ä¼šå‡ºç° \t// If key != key (NaNs), then the hash could be (and probably \t// will be) entirely different from the old hash. Moreover, \t// it isn't reproducible. Reproducibility is required in the \t// presence of iterators, as our evacuation decision must \t// match whatever decision the iterator made. \t// Fortunately, we have the freedom to send these keys either \t// way. Also, tophash is meaningless for these kinds of keys. \t// We let the low bit of tophash drive the evacuation decision. \t// We recompute a new random tophash for the next level so \t// these keys will get evenly distributed across all buckets \t// after multiple grows.  // key != keyï¼Œåªæœ‰åœ¨ float æ•°çš„ NaN æ—¶ä¼šå‡ºç°  // æ¯”å¦‚:  // n1 := math.NaN()  // n2 := math.NaN()  // è¿™ç§æƒ…å†µä¸‹ n1 å’Œ n2 çš„å“ˆå¸Œå€¼ä¹Ÿå®Œå…¨ä¸ä¸€æ ·ï¼Œ  // åŒæ—¶ tophash å¯¹äº NaN ä¹Ÿæ²¡å•¥æ„ä¹‰  // æ‰€ä»¥å¯¹äºè¿™ç§ key æˆ‘ä»¬ä¹Ÿå¯ä»¥éšæ„å¯¹å…¶ç›®æ ‡è¿›è¡Œå‘é…  // è¿˜æ˜¯æŒ‰æ­£å¸¸çš„æƒ…å†µä¸‹ç®—ä¸€ä¸ªéšæœºçš„ tophash  // ç„¶åå…¬å¹³åœ°æŠŠè¿™äº› key å¹³å‡åˆ†å¸ƒåˆ°å„ bucket å°±å¥½ \tuseY = top \u0026 1 // ä¿è¯è¿™ä¸ªkeyæœ‰ä¸€åŠçš„å‡ ç‡è½åˆ°YåŒºï¼Œéšæœºå‘é… \ttop = tophash(hash) } else { // ä¾‹å¦‚newbit=8ï¼Œå…¶äºŒè¿›åˆ¶å³1000ï¼Œå¦‚æœhash\u00261000!=0,åˆ™ç¬¬å››ä½å¿…é¡»ä¸ä¸º0  // å³xxxx1xxxï¼Œåˆ™åœ¨ç¿»å€æ‰©å®¹åï¼Œæ¡¶ä½ç½®è‚¯å®šæ˜¯oldsize+hash \tif hash\u0026newbit != 0 { useY = 1 } } } if evacuatedX+1 != evacuatedY || evacuatedX^1 != evacuatedY { throw(\"bad evacuatedN\") } // æ ‡å¿—è€çš„ cell çš„ top hash å€¼ï¼Œè¡¨ç¤ºæ¬ç§»åˆ° X éƒ¨åˆ† \tb.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY \tdst := \u0026xy[useY] // evacuation destination \t// å¦‚æœ xi ç­‰äº 8ï¼Œè¯´æ˜è¦æº¢å‡ºäº† \tif dst.i == bucketCnt { // å½“å‰æ¡¶è£…æ»¡äº†ï¼Œåˆ™éœ€è¦åˆ†é…ä¸€ä¸ªæº¢å‡ºæ¡¶è®©å…¶ä½¿ç”¨ \t// æ–°å»ºä¸€ä¸ª bucket \tdst.b = h.newoverflow(t, dst.b) // ä» 0 å¼€å§‹è®¡æ•° \tdst.i = 0 // è¡¨ç¤º key è¦ç§»åŠ¨åˆ°çš„ä½ç½® \tdst.k = add(unsafe.Pointer(dst.b), dataOffset) // è¡¨ç¤º value è¦ç§»åŠ¨åˆ°çš„ä½ç½® \tdst.e = add(dst.k, bucketCnt*uintptr(t.keysize)) } // è®¾ç½® top hash å€¼ \tdst.b.tophash[dst.i\u0026(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check \t// key æ˜¯æŒ‡é’ˆ \tif t.indirectkey() { // å°†åŸ keyï¼ˆæ˜¯æŒ‡é’ˆï¼‰å¤åˆ¶åˆ°æ–°ä½ç½® \t*(*unsafe.Pointer)(dst.k) = k2 // copy pointer \t} else { // å°†åŸ keyï¼ˆæ˜¯å€¼ï¼‰å¤åˆ¶åˆ°æ–°ä½ç½® \ttypedmemmove(t.key, dst.k, k) // copy elem \t} // value æ˜¯æŒ‡é’ˆï¼Œæ“ä½œåŒ key \tif t.indirectelem() { *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e) } else { typedmemmove(t.elem, dst.e, e) } // å®šä½åˆ°ä¸‹ä¸€ä¸ª cell \tdst.i++ // These updates might push these pointers past the end of the \t// key or elem arrays. That's ok, as we have the overflow pointer \t// at the end of the bucket to protect against pointing past the \t// end of the bucket. \tdst.k = add(dst.k, uintptr(t.keysize)) dst.e = add(dst.e, uintptr(t.elemsize)) } } // Unlink the overflow buckets \u0026 clear key/elem to help GC. \t// å¦‚æœæ²¡æœ‰åç¨‹åœ¨ä½¿ç”¨è€çš„ bucketsï¼Œå°±æŠŠè€ buckets æ¸…é™¤æ‰ï¼Œå¸®åŠ©gc \t// æŠŠæ¬å®Œäº†çš„æ—§æ¡¶åšä¸€äº›æ ‡è®°ä»¥ä¾¿ç­‰å¾…gcæ¸…é™¤ \tif h.flags\u0026oldIterator == 0 \u0026\u0026 t.bucket.ptrdata != 0 { b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)) // Preserve b.tophash because the evacuation \t// state is maintained there. \t// åªæ¸…é™¤bucket çš„ key,value éƒ¨åˆ†ï¼Œä¿ç•™ top hash éƒ¨åˆ†ï¼ŒæŒ‡ç¤ºæ¬è¿çŠ¶æ€ \tptr := add(b, dataOffset) n := uintptr(t.bucketsize) - dataOffset memclrHasPointers(ptr, n) } } // æ›´æ–°æ¬è¿è¿›åº¦ \t// å¦‚æœæ­¤æ¬¡æ¬è¿çš„ bucket ç­‰äºå½“å‰è¿›åº¦ \t// è¾…åŠ©æ¸…ç† \t// å¦‚æœæ­¤æ¬¡æ¬è¿æ˜¯æŒ‰ç…§ h.nevacuateçš„æ¬è¿åˆ™ \t// åšä¸ªæ ‡è®°ï¼Œä»£è¡¨ä¸‹ä¸€æ¬¡è¦æ¬è¿çš„æ¡¶æ˜¯å“ªä¸ª \tif oldbucket == h.nevacuate { advanceEvacuationMark(h, t, newbit) } } func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) { // è¿›åº¦åŠ  1 \th.nevacuate++ // Experiments suggest that 1024 is overkill by at least an order of magnitude. \t// Put it in there as a safeguard anyway, to ensure O(1) behavior. \t// å°è¯•å¾€åçœ‹ 1024 ä¸ª bucket \tstop := h.nevacuate + 1024 if stop  newbit { stop = newbit } // å¯»æ‰¾æ²¡æœ‰æ¬è¿çš„ bucket \t// åˆ¤æ–­å½“å‰bucketçš„tophashçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦å·²ç»è¢«è¿ç§»ï¼Œå¦‚æœå·²ç»è¿ç§»ï¼Œåˆ™è‡ªå¢ \tfor h.nevacuate != stop \u0026\u0026 bucketEvacuated(t, h, h.nevacuate) { h.nevacuate++ } // ç°åœ¨ h.nevacuate ä¹‹å‰çš„ bucket éƒ½è¢«æ¬è¿å®Œæ¯•  // æ‰€æœ‰çš„ buckets æ¬è¿å®Œæ¯• \tif h.nevacuate == newbit { // newbit == # of oldbuckets \t// Growing is all done. Free old main bucket array. \t// æ‰€æœ‰éƒ½å·²ç»è¿ç§»å®Œæ¯•ï¼Œåˆ™å°†oldbucketsç½®ç©º \t// æ¸…é™¤è€çš„ buckets \th.oldbuckets = nil // Can discard old overflow buckets as well. \t// If they are still referenced by an iterator, \t// then the iterator holds a pointers to the slice. \t// æ¸…é™¤è€çš„ overflow bucket \t// å›å¿†ä¸€ä¸‹ï¼š[0] è¡¨ç¤ºå½“å‰ overflow bucket \t// [1] è¡¨ç¤º old overflow bucket \t// ä¸¢å¼ƒæ‰è€çš„æº¢å‡ºæ¡¶ï¼Œå¦‚æœå®ƒä»¬è¿˜åœ¨è¢«è¿­ä»£å™¨å¼•ç”¨ï¼Œæ­¤æ—¶è¿­ä»£å™¨åªæ˜¯å¼•ç”¨ä¸€ä¸ªåˆ‡ç‰‡çš„æŒ‡é’ˆ \tif h.extra != nil { h.extra.oldoverflow = nil } // æ¸…é™¤æ­£åœ¨æ‰©å®¹çš„æ ‡å¿—ä½ \th.flags \u0026^= sameSizeGrow } }   evacuate å‡½æ•°æ¯æ¬¡åªå®Œæˆä¸€ä¸ª bucket çš„æ¬è¿å·¥ä½œï¼Œå› æ­¤è¦éå†å®Œæ­¤ bucket çš„æ‰€æœ‰çš„ cellï¼Œå°†æœ‰å€¼çš„ cell copy åˆ°æ–°çš„åœ°æ–¹ã€‚bucket è¿˜ä¼šé“¾æ¥ overflow bucketï¼Œå®ƒä»¬åŒæ ·éœ€è¦æ¬è¿ã€‚å› æ­¤ä¼šæœ‰ 2 å±‚å¾ªç¯ï¼Œå¤–å±‚éå† bucket å’Œ overflow bucketï¼Œå†…å±‚éå† bucket çš„æ‰€æœ‰ cellã€‚è¿™æ ·çš„å¾ªç¯åœ¨ map çš„æºç é‡Œåˆ°å¤„éƒ½æ˜¯ï¼Œè¦ç†è§£é€äº†ã€‚\næœ‰ä¸€ä¸ªç‰¹æ®Šæƒ…å†µæ˜¯ï¼šæœ‰ä¸€ç§ keyï¼Œæ¯æ¬¡å¯¹å®ƒè®¡ç®— hashï¼Œå¾—åˆ°çš„ç»“æœéƒ½ä¸ä¸€æ ·ã€‚è¿™ä¸ª key å°±æ˜¯ math.NaN() çš„ç»“æœï¼Œå®ƒçš„å«ä¹‰æ˜¯ not a numberï¼Œç±»å‹æ˜¯ float64ã€‚å½“å®ƒä½œä¸º map çš„ keyï¼Œåœ¨æ¬è¿çš„æ—¶å€™ï¼Œä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼šå†æ¬¡è®¡ç®—å®ƒçš„å“ˆå¸Œå€¼å’Œå®ƒå½“åˆæ’å…¥ map æ—¶çš„è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ä¸ä¸€æ ·ï¼\nä½ å¯èƒ½æƒ³åˆ°äº†ï¼Œè¿™æ ·å¸¦æ¥çš„ä¸€ä¸ªåæœæ˜¯ï¼Œè¿™ä¸ª key æ˜¯æ°¸è¿œä¸ä¼šè¢« Get æ“ä½œè·å–çš„ï¼å½“æˆ‘ä½¿ç”¨ m[math.NaN()] è¯­å¥çš„æ—¶å€™ï¼Œæ˜¯æŸ¥ä¸å‡ºæ¥ç»“æœçš„ã€‚è¿™ä¸ª key åªæœ‰åœ¨éå†æ•´ä¸ª map çš„æ—¶å€™ï¼Œæ‰æœ‰æœºä¼šç°èº«ã€‚æ‰€ä»¥ï¼Œå¯ä»¥å‘ä¸€ä¸ª map æ’å…¥ä»»æ„æ•°é‡çš„ math.NaN() ä½œä¸º keyã€‚\nå½“æ¬è¿ç¢°åˆ° math.NaN() çš„ key æ—¶ï¼Œåªé€šè¿‡ tophash çš„æœ€ä½ä½å†³å®šåˆ†é…åˆ° X part è¿˜æ˜¯ Y partï¼ˆå¦‚æœæ‰©å®¹åæ˜¯åŸæ¥ buckets æ•°é‡çš„ 2 å€ï¼‰ã€‚å¦‚æœ tophash çš„æœ€ä½ä½æ˜¯ 0 ï¼Œåˆ†é…åˆ° X partï¼›å¦‚æœæ˜¯ 1 ï¼Œåˆ™åˆ†é…åˆ° Y partã€‚\nè¿™æ˜¯é€šè¿‡ tophash å€¼ä¸æ–°ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼è¿›è¡Œè¿ç®—å¾—åˆ°çš„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if h.flags\u0026iterator != 0 \u0026\u0026 !t.reflexivekey() \u0026\u0026 !t.key.equal(k2, k2) { // åªæœ‰åœ¨ float å˜é‡çš„ NaN() æƒ…å†µä¸‹ä¼šå‡ºç° \t// If key != key (NaNs), then the hash could be (and probably \t// will be) entirely different from the old hash. Moreover, \t// it isn't reproducible. Reproducibility is required in the \t// presence of iterators, as our evacuation decision must \t// match whatever decision the iterator made. \t// Fortunately, we have the freedom to send these keys either \t// way. Also, tophash is meaningless for these kinds of keys. \t// We let the low bit of tophash drive the evacuation decision. \t// We recompute a new random tophash for the next level so \t// these keys will get evenly distributed across all buckets \t// after multiple grows. \tuseY = top \u0026 1 top = tophash(hash) } else { // æ–°ç®—å‡ºæ¥çš„ hash å€¼çš„ B ä½ç½® 0 \tif hash\u0026newbit != 0 { useY = 1 } }   å…¶å®è¿™æ ·çš„ key æˆ‘éšä¾¿æ¬è¿åˆ°å“ªä¸ª bucket éƒ½è¡Œï¼Œå½“ç„¶ï¼Œè¿˜æ˜¯è¦æ¬è¿åˆ°ä¸Šé¢è£‚å˜é‚£å¼ å›¾ä¸­çš„ä¸¤ä¸ª bucket ä¸­å»ã€‚ä½†è¿™æ ·åšæ˜¯æœ‰å¥½å¤„çš„ï¼Œåœ¨åé¢è®² map è¿­ä»£çš„æ—¶å€™ä¼šå†è¯¦ç»†è§£é‡Šï¼Œæš‚æ—¶çŸ¥é“æ˜¯è¿™æ ·åˆ†é…çš„å°±è¡Œã€‚\nç¡®å®šäº†è¦æ¬è¿åˆ°çš„ç›®æ ‡ bucket åï¼Œæ¬è¿æ“ä½œå°±æ¯”è¾ƒå¥½è¿›è¡Œäº†ã€‚å°†æº key/value å€¼ copy åˆ°ç›®çš„åœ°ç›¸åº”çš„ä½ç½®ã€‚\nè®¾ç½® key åœ¨åŸå§‹ buckets çš„ tophash ä¸º evacuatedX æˆ–æ˜¯ evacuatedYï¼Œè¡¨ç¤ºå·²ç»æ¬è¿åˆ°äº†æ–° map çš„ x part æˆ–æ˜¯ y partã€‚æ–° map çš„ tophash åˆ™æ­£å¸¸å– key å“ˆå¸Œå€¼çš„é«˜ 8 ä½ã€‚\nä¸‹é¢é€šè¿‡å›¾æ¥å®è§‚åœ°çœ‹ä¸€ä¸‹æ‰©å®¹å‰åçš„å˜åŒ–ã€‚\næ‰©å®¹å‰ï¼ŒB = 2ï¼Œå…±æœ‰ 4 ä¸ª bucketsï¼Œlowbits è¡¨ç¤º hash å€¼çš„ä½ä½ã€‚å‡è®¾æˆ‘ä»¬ä¸å…³æ³¨å…¶ä»– buckets æƒ…å†µï¼Œä¸“æ³¨åœ¨ 2 å· bucketã€‚å¹¶ä¸”å‡è®¾ overflow å¤ªå¤šï¼Œè§¦å‘äº†ç­‰é‡æ‰©å®¹ï¼ˆå¯¹åº”äºå‰é¢çš„æ¡ä»¶ 2ï¼‰ã€‚\næ‰©å®¹å®Œæˆåï¼Œoverflow bucket æ¶ˆå¤±äº†ï¼Œkey éƒ½é›†ä¸­åˆ°äº†ä¸€ä¸ª bucketï¼Œæ›´ä¸ºç´§å‡‘äº†ï¼Œæé«˜äº†æŸ¥æ‰¾çš„æ•ˆç‡ã€‚\nå‡è®¾è§¦å‘äº† 2 å€çš„æ‰©å®¹ï¼Œé‚£ä¹ˆæ‰©å®¹å®Œæˆåï¼Œè€ buckets ä¸­çš„ key åˆ†è£‚åˆ°äº† 2 ä¸ª æ–°çš„ bucketã€‚ä¸€ä¸ªåœ¨ x partï¼Œä¸€ä¸ªåœ¨ y çš„ partã€‚ä¾æ®æ˜¯ hash çš„ lowbitsã€‚æ–° map ä¸­ 0-3 ç§°ä¸º x partï¼Œ4-7 ç§°ä¸º y partã€‚\næ³¨æ„ï¼Œä¸Šé¢çš„ä¸¤å¼ å›¾å¿½ç•¥äº†å…¶ä»– buckets çš„æ¬è¿æƒ…å†µï¼Œè¡¨ç¤ºæ‰€æœ‰çš„ bucket éƒ½æ¬è¿å®Œæ¯•åçš„æƒ…å½¢ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œæ¬è¿æ˜¯ä¸€ä¸ªâ€œæ¸è¿›â€çš„è¿‡ç¨‹ï¼Œå¹¶ä¸ä¼šä¸€ä¸‹å­å°±å…¨éƒ¨æ¬è¿å®Œæ¯•ã€‚æ‰€ä»¥åœ¨æ¬è¿è¿‡ç¨‹ä¸­ï¼Œoldbuckets æŒ‡é’ˆè¿˜ä¼šæŒ‡å‘åŸæ¥è€çš„ []bmapï¼Œå¹¶ä¸”å·²ç»æ¬è¿å®Œæ¯•çš„ key çš„ tophash å€¼ä¼šæ˜¯ä¸€ä¸ªçŠ¶æ€å€¼ï¼Œè¡¨ç¤º key çš„æ¬è¿å»å‘ã€‚\néå† æœ¬æ¥ map çš„éå†è¿‡ç¨‹æ¯”è¾ƒç®€å•ï¼šéå†æ‰€æœ‰çš„ bucket ä»¥åŠå®ƒåé¢æŒ‚çš„ overflow bucketï¼Œç„¶åæŒ¨ä¸ªéå† bucket ä¸­çš„æ‰€æœ‰ cellã€‚æ¯ä¸ª bucket ä¸­åŒ…å« 8 ä¸ª cellï¼Œä»æœ‰ key çš„ cell ä¸­å–å‡º key å’Œ valueï¼Œè¿™ä¸ªè¿‡ç¨‹å°±å®Œæˆäº†ã€‚\nä½†æ˜¯ï¼Œç°å®å¹¶æ²¡æœ‰è¿™ä¹ˆç®€å•ã€‚è¿˜è®°å¾—å‰é¢è®²è¿‡çš„æ‰©å®¹è¿‡ç¨‹å—ï¼Ÿæ‰©å®¹è¿‡ç¨‹ä¸æ˜¯ä¸€ä¸ªåŸå­çš„æ“ä½œï¼Œå®ƒæ¯æ¬¡æœ€å¤šåªæ¬è¿ 2 ä¸ª bucketï¼Œæ‰€ä»¥å¦‚æœè§¦å‘äº†æ‰©å®¹æ“ä½œï¼Œé‚£ä¹ˆåœ¨å¾ˆé•¿æ—¶é—´é‡Œï¼Œmap çš„çŠ¶æ€éƒ½æ˜¯å¤„äºä¸€ä¸ªä¸­é—´æ€ï¼šæœ‰äº› bucket å·²ç»æ¬è¿åˆ°æ–°å®¶ï¼Œè€Œæœ‰äº› bucket è¿˜å¾…åœ¨è€åœ°æ–¹ã€‚\nå› æ­¤ï¼Œéå†å¦‚æœå‘ç”Ÿåœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œå°±ä¼šæ¶‰åŠåˆ°éå†æ–°è€ bucket çš„è¿‡ç¨‹ï¼Œè¿™æ˜¯éš¾ç‚¹æ‰€åœ¨ã€‚\næˆ‘å…ˆå†™ä¸€ä¸ªç®€å•çš„ä»£ç æ ·ä¾‹ï¼Œå‡è£…ä¸çŸ¥é“éå†è¿‡ç¨‹å…·ä½“è°ƒç”¨çš„æ˜¯ä»€ä¹ˆå‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  package main import \"fmt\" func main() { ageMp := make(map[string]int) ageMp[\"qcrao\"] = 18 for name, age := range ageMp { fmt.Println(name, age) } }   æ‰§è¡Œå‘½ä»¤ï¼š\n1  go tool compile -S main.go   å¾—åˆ°æ±‡ç¼–å‘½ä»¤ã€‚è¿™é‡Œå°±ä¸é€è¡Œè®²è§£äº†ï¼Œå¯ä»¥å»çœ‹ä¹‹å‰çš„å‡ ç¯‡æ–‡ç« ï¼Œè¯´å¾—å¾ˆè¯¦ç»†ã€‚\nå…³é”®çš„å‡ è¡Œæ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10  // ...... 0x0124 00292 (test16.go:9) CALL runtime.mapiterinit(SB) // ...... 0x01fb 00507 (test16.go:9) CALL runtime.mapiternext(SB) 0x0200 00512 (test16.go:9) MOVQ \"\"..autotmp_4+160(SP), AX 0x0208 00520 (test16.go:9) TESTQ AX, AX 0x020b 00523 (test16.go:9) JNE 302 // ......   è¿™æ ·ï¼Œå…³äº map è¿­ä»£ï¼Œåº•å±‚çš„å‡½æ•°è°ƒç”¨å…³ç³»ä¸€ç›®äº†ç„¶ã€‚å…ˆæ˜¯è°ƒç”¨ mapiterinit å‡½æ•°åˆå§‹åŒ–è¿­ä»£å™¨ï¼Œç„¶åå¾ªç¯è°ƒç”¨ mapiternext å‡½æ•°è¿›è¡Œ map è¿­ä»£ã€‚\nè¿­ä»£å™¨çš„ç»“æ„ä½“å®šä¹‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // A hash iteration structure. // If you modify hiter, also change cmd/compile/internal/gc/reflect.go to indicate // the layout of this structure. type hiter struct { // key æŒ‡é’ˆ \tkey unsafe.Pointer // Must be in first position. Write nil to indicate iteration end (see cmd/compile/internal/gc/range.go). \t// value æŒ‡é’ˆ \telem unsafe.Pointer // Must be in second position (see cmd/compile/internal/gc/range.go). \t// map ç±»å‹ï¼ŒåŒ…å«å¦‚ key size å¤§å°ç­‰ \tt *maptype h *hmap // åˆå§‹åŒ–æ—¶æŒ‡å‘çš„ bucket \tbuckets unsafe.Pointer // bucket ptr at hash_iter initialization time \t// å½“å‰éå†åˆ°çš„ bmap \tbptr *bmap // current bucket \toverflow *[]*bmap // keeps overflow buckets of hmap.buckets alive \toldoverflow *[]*bmap // keeps overflow buckets of hmap.oldbuckets alive \t// èµ·å§‹éå†çš„ bucet ç¼–å· \tstartBucket uintptr // bucket iteration started at \t// éå†å¼€å§‹æ—¶ cell çš„ç¼–å·ï¼ˆæ¯ä¸ª bucket ä¸­æœ‰ 8 ä¸ª cellï¼‰ \toffset uint8 // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) \t// æ˜¯å¦ä»å¤´éå†äº† \twrapped bool // already wrapped around from end of bucket array to beginning \t// B çš„å¤§å° \tB uint8 // æŒ‡ç¤ºå½“å‰ cell åºå· \ti uint8 // æŒ‡å‘å½“å‰çš„ bucket \tbucket uintptr // å› ä¸ºæ‰©å®¹ï¼Œéœ€è¦æ£€æŸ¥çš„ bucket \tcheckBucket uintptr }   mapiterinit å°±æ˜¯å¯¹ hiter ç»“æ„ä½“é‡Œçš„å­—æ®µè¿›è¡Œåˆå§‹åŒ–èµ‹å€¼æ“ä½œã€‚\nå‰é¢å·²ç»æåˆ°è¿‡ï¼Œå³ä½¿æ˜¯å¯¹ä¸€ä¸ªå†™æ­»çš„ map è¿›è¡Œéå†ï¼Œæ¯æ¬¡å‡ºæ¥çš„ç»“æœä¹Ÿæ˜¯æ— åºçš„ã€‚ä¸‹é¢æˆ‘ä»¬å°±å¯ä»¥è¿‘è·ç¦»åœ°è§‚å¯Ÿä»–ä»¬çš„å®ç°äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  // mapiterinit initializes the hiter struct used for ranging over maps. // The hiter struct pointed to by 'it' is allocated on the stack // by the compilers order pass or on the heap by reflect_mapiterinit. // Both need to have zeroed hiter since the struct contains pointers. func mapiterinit(t *maptype, h *hmap, it *hiter) { if raceenabled \u0026\u0026 h != nil { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiterinit)) } if h == nil || h.count == 0 { return } if unsafe.Sizeof(hiter{})/sys.PtrSize != 12 { throw(\"hash_iter size incorrect\") // see cmd/compile/internal/gc/reflect.go \t} it.t = t it.h = h // grab snapshot of bucket state \tit.B = h.B it.buckets = h.buckets if t.bucket.ptrdata == 0 { // Allocate the current slice and remember pointers to both current and old. \t// This preserves all relevant overflow buckets alive even if \t// the table grows and/or overflow buckets are added to the table \t// while we are iterating. \th.createOverflow() it.overflow = h.extra.overflow it.oldoverflow = h.extra.oldoverflow } // decide where to start \t// ç”Ÿæˆéšæœºæ•° r \tr := uintptr(fastrand()) if h.B  31-bucketCntBits { r += uintptr(fastrand())  31 } // ä»å“ªä¸ª bucket å¼€å§‹éå† \tit.startBucket = r \u0026 bucketMask(h.B) // ä» bucket çš„å“ªä¸ª cell å¼€å§‹éå† \tit.offset = uint8(r  h.B \u0026 (bucketCnt - 1)) // iterator state \tit.bucket = it.startBucket // Remember we have an iterator. \t// Can run concurrently with another mapiterinit(). \tif old := h.flags; old\u0026(iterator|oldIterator) != iterator|oldIterator { atomic.Or8(\u0026h.flags, iterator|oldIterator) } mapiternext(it) } //go:nosplit func fastrand() uint32 { mp := getg().m // Implement xorshift64+: 2 32-bit xorshift sequences added together. \t// Shift triplet [17,7,16] was calculated as indicated in Marsaglia's \t// Xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf \t// This generator passes the SmallCrush suite, part of TestU01 framework: \t// http://simul.iro.umontreal.ca/testu01/tu01.html \ts1, s0 := mp.fastrand[0], mp.fastrand[1] s1 ^= s1  17 s1 = s1 ^ s0 ^ s17 ^ s016 mp.fastrand[0], mp.fastrand[1] = s0, s1 return s0 + s1 }   ä¾‹å¦‚ï¼ŒB = 2ï¼Œé‚£ uintptr(1)ç»“æœå°±æ˜¯ 3ï¼Œä½ 8 ä½ä¸º 0000 0011ï¼Œå°† r ä¸ä¹‹ç›¸ä¸ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ª 0~3 çš„ bucket åºå·ï¼›bucketCnt - 1 ç­‰äº 7ï¼Œä½ 8 ä½ä¸º 0000 0111ï¼Œå°† r å³ç§» 2 ä½åï¼Œä¸ 7 ç›¸ä¸ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ª 0~7 å·çš„ cellã€‚\näºæ˜¯ï¼Œåœ¨ mapiternext å‡½æ•°ä¸­å°±ä¼šä» it.startBucket çš„ it.offset å·çš„ cell å¼€å§‹éå†ï¼Œå–å‡ºå…¶ä¸­çš„ key å’Œ valueï¼Œç›´åˆ°åˆå›åˆ°èµ·ç‚¹ bucketï¼Œå®Œæˆéå†è¿‡ç¨‹ã€‚\nå‡è®¾æˆ‘ä»¬æœ‰ä¸‹å›¾æ‰€ç¤ºçš„ä¸€ä¸ª mapï¼Œèµ·å§‹æ—¶ B = 1ï¼Œæœ‰ä¸¤ä¸ª bucketï¼Œåæ¥è§¦å‘äº†æ‰©å®¹ï¼ˆè¿™é‡Œä¸è¦æ·±ç©¶æ‰©å®¹æ¡ä»¶ï¼Œåªæ˜¯ä¸€ä¸ªè®¾å®šï¼‰ï¼ŒB å˜æˆ 2ã€‚å¹¶ä¸”ï¼Œ 1 å· bucket ä¸­çš„å†…å®¹æ¬è¿åˆ°äº†æ–°çš„ bucketï¼Œ1 å·è£‚å˜æˆ 1 å·å’Œ 3 å·ï¼›0 å· bucket æš‚æœªæ¬è¿ã€‚è€çš„ bucket æŒ‚åœ¨åœ¨ oldbuckets æŒ‡é’ˆä¸Šé¢ï¼Œæ–°çš„ bucket åˆ™æŒ‚åœ¨buckets æŒ‡é’ˆä¸Šé¢ã€‚\nè¿™æ—¶ï¼Œæˆ‘ä»¬å¯¹æ­¤ map è¿›è¡Œéå†ã€‚å‡è®¾ç»è¿‡åˆå§‹åŒ–åï¼ŒstartBucket = 3ï¼Œoffset = 2ã€‚äºæ˜¯ï¼Œéå†çš„èµ·ç‚¹å°†æ˜¯ 3 å· bucket çš„ 2 å· cellï¼Œä¸‹é¢è¿™å¼ å›¾å°±æ˜¯å¼€å§‹éå†æ—¶çš„çŠ¶æ€ï¼š\næ ‡çº¢çš„è¡¨ç¤ºèµ·å§‹ä½ç½®ï¼Œbucket éå†é¡ºåºä¸ºï¼š3 - 0 - 1 - 2ã€‚\nå› ä¸º 3 å· bucket å¯¹åº”è€çš„ 1 å· bucketï¼Œå› æ­¤å…ˆæ£€æŸ¥è€ 1 å· bucket æ˜¯å¦å·²ç»è¢«æ¬è¿è¿‡ã€‚åˆ¤æ–­æ–¹æ³•å°±æ˜¯ï¼š\n1 2 3 4  func evacuated(b *bmap) bool { h := b.tophash[0] return h  empty \u0026\u0026 h  minTopHash }   å¦‚æœ b.tophash[0] çš„å€¼åœ¨æ ‡å¿—å€¼èŒƒå›´å†…ï¼Œå³åœ¨ (0,4) åŒºé—´é‡Œï¼Œè¯´æ˜å·²ç»è¢«æ¬è¿è¿‡äº†ã€‚\nåœ¨æœ¬ä¾‹ä¸­ï¼Œè€ 1 å· bucket å·²ç»è¢«æ¬è¿è¿‡äº†ã€‚æ‰€ä»¥å®ƒçš„ tophash[0] å€¼åœ¨ (0,4) èŒƒå›´å†…ï¼Œå› æ­¤åªç”¨éå†æ–°çš„ 3 å· bucketã€‚\nä¾æ¬¡éå† 3 å· bucket çš„ cellï¼Œè¿™æ—¶å€™ä¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªéç©ºçš„ keyï¼šå…ƒç´  eã€‚åˆ°è¿™é‡Œï¼Œmapiternext å‡½æ•°è¿”å›ï¼Œè¿™æ—¶æˆ‘ä»¬çš„éå†ç»“æœä»…æœ‰ä¸€ä¸ªå…ƒç´ ï¼š\nç”±äºè¿”å›çš„ key ä¸ä¸ºç©ºï¼Œæ‰€ä»¥ä¼šç»§ç»­è°ƒç”¨ mapiternext å‡½æ•°ã€‚\nç»§ç»­ä»ä¸Šæ¬¡éå†åˆ°çš„åœ°æ–¹å¾€åéå†ï¼Œä»æ–° 3 å· overflow bucket ä¸­æ‰¾åˆ°äº†å…ƒç´  f å’Œ å…ƒç´  gã€‚\néå†ç»“æœé›†ä¹Ÿå› æ­¤å£®å¤§ï¼š\næ–° 3 å· bucket éå†å®Œä¹‹åï¼Œå›åˆ°äº†æ–° 0 å· bucketã€‚0 å· bucket å¯¹åº”è€çš„ 0 å· bucketï¼Œç»æ£€æŸ¥ï¼Œè€ 0 å· bucket å¹¶æœªæ¬è¿ï¼Œå› æ­¤å¯¹æ–° 0 å· bucket çš„éå†å°±æ”¹ä¸ºéå†è€ 0 å· bucketã€‚é‚£æ˜¯ä¸æ˜¯æŠŠè€ 0 å· bucket ä¸­çš„æ‰€æœ‰ key éƒ½å–å‡ºæ¥å‘¢ï¼Ÿ\nå¹¶æ²¡æœ‰è¿™ä¹ˆç®€å•ï¼Œå›å¿†ä¸€ä¸‹ï¼Œè€ 0 å· bucket åœ¨æ¬è¿åå°†è£‚å˜æˆ 2 ä¸ª bucketï¼šæ–° 0 å·ã€æ–° 2 å·ã€‚è€Œæˆ‘ä»¬æ­¤æ—¶æ­£åœ¨éå†çš„åªæ˜¯æ–° 0 å· bucketï¼ˆæ³¨æ„ï¼Œéå†éƒ½æ˜¯éå†çš„ *bucket æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„æ–° bucketsï¼‰ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬åªä¼šå–å‡ºè€ 0 å· bucket ä¸­é‚£äº›åœ¨è£‚å˜ä¹‹åï¼Œåˆ†é…åˆ°æ–° 0 å· bucket ä¸­çš„é‚£äº› keyã€‚\nå› æ­¤ï¼Œlowbits == 00 çš„å°†è¿›å…¥éå†ç»“æœé›†ï¼š\nå’Œä¹‹å‰çš„æµç¨‹ä¸€æ ·ï¼Œç»§ç»­éå†æ–° 1 å· bucketï¼Œå‘ç°è€ 1 å· bucket å·²ç»æ¬è¿ï¼Œåªç”¨éå†æ–° 1 å· bucket ä¸­ç°æœ‰çš„å…ƒç´ å°±å¯ä»¥äº†ã€‚ç»“æœé›†å˜æˆï¼š\nç»§ç»­éå†æ–° 2 å· bucketï¼Œå®ƒæ¥è‡ªè€ 0 å· bucketï¼Œå› æ­¤éœ€è¦åœ¨è€ 0 å· bucket ä¸­é‚£äº›ä¼šè£‚å˜åˆ°æ–° 2 å· bucket ä¸­çš„ keyï¼Œä¹Ÿå°±æ˜¯ lowbit == 10 çš„é‚£äº› keyã€‚\nè¿™æ ·ï¼Œéå†ç»“æœé›†å˜æˆï¼š\næœ€åï¼Œç»§ç»­éå†åˆ°æ–° 3 å· bucket æ—¶ï¼Œå‘ç°æ‰€æœ‰çš„ bucket éƒ½å·²ç»éå†å®Œæ¯•ï¼Œæ•´ä¸ªè¿­ä»£è¿‡ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚\né¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œå¦‚æœç¢°åˆ° key æ˜¯ math.NaN() è¿™ç§çš„ï¼Œå¤„ç†æ–¹å¼ç±»ä¼¼ã€‚æ ¸å¿ƒè¿˜æ˜¯è¦çœ‹å®ƒè¢«åˆ†è£‚åå…·ä½“è½å…¥å“ªä¸ª bucketã€‚åªä¸è¿‡åªç”¨çœ‹å®ƒ top hash çš„æœ€ä½ä½ã€‚å¦‚æœ top hash çš„æœ€ä½ä½æ˜¯ 0 ï¼Œåˆ†é…åˆ° X partï¼›å¦‚æœæ˜¯ 1 ï¼Œåˆ™åˆ†é…åˆ° Y partã€‚æ®æ­¤å†³å®šæ˜¯å¦å–å‡º keyï¼Œæ”¾åˆ°éå†ç»“æœé›†é‡Œã€‚\nmap éå†çš„æ ¸å¿ƒåœ¨äºç†è§£ 2 å€æ‰©å®¹æ—¶ï¼Œè€ bucket ä¼šåˆ†è£‚åˆ° 2 ä¸ªæ–° bucket ä¸­å»ã€‚è€Œéå†æ“ä½œï¼Œä¼šæŒ‰ç…§æ–° bucket çš„åºå·é¡ºåºè¿›è¡Œï¼Œç¢°åˆ°è€ bucket æœªæ¬è¿çš„æƒ…å†µæ—¶ï¼Œè¦åœ¨è€ bucket ä¸­æ‰¾åˆ°å°†æ¥è¦æ¬è¿åˆ°æ–° bucket æ¥çš„ keyã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  func mapiternext(it *hiter) { h := it.h if raceenabled { callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext)) } if h.flags\u0026hashWriting != 0 { throw(\"concurrent map iteration and map write\") } t := it.t bucket := it.bucket b := it.bptr i := it.i checkBucket := it.checkBucket next: if b == nil { if bucket == it.startBucket \u0026\u0026 it.wrapped { // end of iteration \tit.key = nil it.elem = nil return } if h.growing() \u0026\u0026 it.B == h.B { // Iterator was started in the middle of a grow, and the grow isn't done yet. \t// If the bucket we're looking at hasn't been filled in yet (i.e. the old \t// bucket hasn't been evacuated) then we need to iterate through the old \t// bucket and only return the ones that will be migrated to this bucket. \toldbucket := bucket \u0026 it.h.oldbucketmask() b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) if !evacuated(b) { checkBucket = bucket } else { b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) checkBucket = noCheck } } else { b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) checkBucket = noCheck } bucket++ if bucket == bucketShift(it.B) { bucket = 0 it.wrapped = true } i = 0 } for ; i  bucketCnt; i++ { offi := (i + it.offset) \u0026 (bucketCnt - 1) if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty { // TODO: emptyRest is hard to use here, as we start iterating \t// in the middle of a bucket. It's feasible, just tricky. \tcontinue } k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) if t.indirectkey() { k = *((*unsafe.Pointer)(k)) } e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.elemsize)) if checkBucket != noCheck \u0026\u0026 !h.sameSizeGrow() { // Special case: iterator was started during a grow to a larger size \t// and the grow is not done yet. We're working on a bucket whose \t// oldbucket has not been evacuated yet. Or at least, it wasn't \t// evacuated when we started the bucket. So we're iterating \t// through the oldbucket, skipping any keys that will go \t// to the other new bucket (each oldbucket expands to two \t// buckets during a grow). \tif t.reflexivekey() || t.key.equal(k, k) { // If the item in the oldbucket is not destined for \t// the current new bucket in the iteration, skip it. \thash := t.hasher(k, uintptr(h.hash0)) if hash\u0026bucketMask(it.B) != checkBucket { continue } } else { // Hash isn't repeatable if k != k (NaNs). We need a \t// repeatable and randomish choice of which direction \t// to send NaNs during evacuation. We'll use the low \t// bit of tophash to decide which way NaNs go. \t// NOTE: this case is why we need two evacuate tophash \t// values, evacuatedX and evacuatedY, that differ in \t// their low bit. \tif checkBucket(it.B-1) != uintptr(b.tophash[offi]\u00261) { continue } } } if (b.tophash[offi] != evacuatedX \u0026\u0026 b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || t.key.equal(k, k)) { // This is the golden data, we can return it. \t// OR \t// key!=key, so the entry can't be deleted or updated, so we can just return it. \t// That's lucky for us because when key!=key we can't look it up successfully. \tit.key = k if t.indirectelem() { e = *((*unsafe.Pointer)(e)) } it.elem = e } else { // The hash table has grown since the iterator was started. \t// The golden data for this key is now somewhere else. \t// Check the current hash table for the data. \t// This code handles the case where the key \t// has been deleted, updated, or deleted and reinserted. \t// NOTE: we need to regrab the key as it has potentially been \t// updated to an equal() but not identical key (e.g. +0.0 vs -0.0). \trk, re := mapaccessK(t, h, k) if rk == nil { continue // key has been deleted \t} it.key = rk it.elem = re } it.bucket = bucket if it.bptr != b { // avoid unnecessary write barrier; see issue 14921 \tit.bptr = b } it.i = i + 1 it.checkBucket = checkBucket return } b = b.overflow(t) i = 0 goto next }   å°ç»“ Go è¯­è¨€ä½¿ç”¨æ‹‰é“¾æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜å®ç°äº†å“ˆå¸Œè¡¨ï¼Œå®ƒçš„è®¿é—®ã€å†™å…¥å’Œåˆ é™¤ç­‰æ“ä½œéƒ½åœ¨ç¼–è¯‘æœŸé—´è½¬æ¢æˆäº†è¿è¡Œæ—¶çš„å‡½æ•°æˆ–è€…æ–¹æ³•ã€‚å“ˆå¸Œåœ¨æ¯ä¸€ä¸ªæ¡¶ä¸­å­˜å‚¨é”®å¯¹åº”å“ˆå¸Œçš„å‰ 8 ä½ï¼Œå½“å¯¹å“ˆå¸Œè¿›è¡Œæ“ä½œæ—¶ï¼Œè¿™äº› tophash å°±æˆä¸ºå¯ä»¥å¸®åŠ©å“ˆå¸Œå¿«é€Ÿéå†æ¡¶ä¸­å…ƒç´ çš„ç¼“å­˜ã€‚\nå“ˆå¸Œè¡¨çš„æ¯ä¸ªæ¡¶éƒ½åªèƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œä¸€æ—¦å½“å‰å“ˆå¸Œçš„æŸä¸ªæ¡¶è¶…å‡º 8 ä¸ªï¼Œæ–°çš„é”®å€¼å¯¹å°±ä¼šå­˜å‚¨åˆ°å“ˆå¸Œçš„æº¢å‡ºæ¡¶ä¸­ã€‚éšç€é”®å€¼å¯¹æ•°é‡çš„å¢åŠ ï¼Œæº¢å‡ºæ¡¶çš„æ•°é‡å’Œå“ˆå¸Œçš„è£…è½½å› å­ä¹Ÿä¼šé€æ¸å‡é«˜ï¼Œè¶…è¿‡ä¸€å®šèŒƒå›´å°±ä¼šè§¦å‘æ‰©å®¹ï¼Œæ‰©å®¹ä¼šå°†æ¡¶çš„æ•°é‡ç¿»å€ï¼Œå…ƒç´ å†åˆ†é…çš„è¿‡ç¨‹ä¹Ÿæ˜¯åœ¨è°ƒç”¨å†™æ“ä½œæ—¶å¢é‡è¿›è¡Œçš„ï¼Œä¸ä¼šé€ æˆæ€§èƒ½çš„ç¬æ—¶å·¨å¤§æŠ–åŠ¨ã€‚\nç¼ºé™· å·²ç»æ‰©å®¹çš„ mapï¼Œæ— æ³•æ”¶ç¼©\nä¿è¯å¹¶å‘å®‰å…¨æ—¶ï¼Œè¦æ‰‹åŠ¨è¯»å†™é”ï¼Œæ˜“å‡ºé”™,å¤šæ ¸å¿ƒä¸‹è¡¨ç°å·®\néš¾ä»¥ä½¿ç”¨ sync.Pool è¿›è¡Œé‡ç”¨\nå‚è€ƒ 3.3 å“ˆå¸Œè¡¨\nGo-Mapæºç è§£è¯»\næ·±åº¦è§£å¯†Goè¯­è¨€ä¹‹map\nã€ŒGolangã€ Mapæºç è§£æ\n",
  "wordCount" : "30062",
  "inLanguage": "zh-cn",
  "datePublished": "2021-07-01T20:22:12Z",
  "dateModified": "2021-07-01T20:22:12Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      åŸºæœ¬æ•°æ®ç»“æ„mapæºç å‰–æ
    </h1>
    <div class="post-meta">July 1, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="å‰è¨€">å‰è¨€<a hidden class="anchor" aria-hidden="true" href="#å‰è¨€">#</a></h2>
<p>æœ¬èŠ‚ä¼šä»‹ç» Go è¯­è¨€çš„å“ˆå¸Œçš„å®ç°åŸç†ï¼Œå“ˆå¸Œæ˜¯é™¤äº†æ•°ç»„ä¹‹å¤–ï¼Œæœ€å¸¸è§çš„æ•°æ®ç»“æ„ã€‚å‡ ä¹æ‰€æœ‰çš„è¯­è¨€éƒ½ä¼šæœ‰æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸¤ç§é›†åˆå…ƒç´ ï¼Œæœ‰çš„è¯­è¨€å°†æ•°ç»„å®ç°æˆåˆ—è¡¨ï¼Œè€Œæœ‰çš„è¯­è¨€å°†å“ˆå¸Œç§°ä½œå­—å…¸æˆ–è€…æ˜ å°„ã€‚æ— è®ºå¦‚ä½•å‘½åæˆ–è€…å¦‚ä½•å®ç°ï¼Œæ•°ç»„å’Œå“ˆå¸Œæ˜¯ä¸¤ç§è®¾è®¡é›†åˆå…ƒç´ çš„æ€è·¯ï¼Œæ•°ç»„ç”¨äºè¡¨ç¤ºå…ƒç´ çš„åºåˆ—ï¼Œè€Œå“ˆå¸Œè¡¨ç¤ºçš„æ˜¯é”®å€¼å¯¹ä¹‹é—´æ˜ å°„å…³ç³»ã€‚</p>
<p>å“ˆå¸Œè¡¨æ˜¯ä¸€ç§å¤è€çš„æ•°æ®ç»“æ„ï¼Œåœ¨ 1953 å¹´å°±æœ‰äººä½¿ç”¨æ‹‰é“¾æ³•å®ç°äº†å“ˆå¸Œè¡¨ï¼Œå®ƒèƒ½å¤Ÿé€šè¿‡é”®ç›´æ¥è·å–è¯¥é”®å¯¹åº”çš„å€¼ã€‚</p>
<h2 id="è®¾è®¡åŸç†">è®¾è®¡åŸç†<a hidden class="anchor" aria-hidden="true" href="#è®¾è®¡åŸç†">#</a></h2>
<p>å“ˆå¸Œè¡¨æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„æœ€é‡è¦æ•°æ®ç»“æ„ä¹‹ä¸€ï¼Œè¿™ä¸ä»…å› ä¸ºå®ƒ ğ‘‚(1) çš„è¯»å†™æ€§èƒ½éå¸¸ä¼˜ç§€ï¼Œè¿˜å› ä¸ºå®ƒæä¾›äº†é”®å€¼ä¹‹é—´çš„æ˜ å°„ã€‚æƒ³è¦å®ç°ä¸€ä¸ªæ€§èƒ½ä¼˜å¼‚çš„å“ˆå¸Œè¡¨ï¼Œéœ€è¦æ³¨æ„ä¸¤ä¸ªå…³é”®ç‚¹ â€”â€” å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³æ–¹æ³•ã€‚</p>
<h3 id="å“ˆå¸Œå‡½æ•°">å“ˆå¸Œå‡½æ•°<a hidden class="anchor" aria-hidden="true" href="#å“ˆå¸Œå‡½æ•°">#</a></h3>
<p>å®ç°å“ˆå¸Œè¡¨çš„å…³é”®ç‚¹åœ¨äºå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©ï¼Œå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šèƒ½å¤Ÿå†³å®šå“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°åº”è¯¥èƒ½å¤Ÿå°†ä¸åŒé”®æ˜ å°„åˆ°ä¸åŒçš„ç´¢å¼•ä¸Šï¼Œè¿™è¦æ±‚å“ˆå¸Œå‡½æ•°çš„è¾“å‡ºèŒƒå›´å¤§äºè¾“å…¥èŒƒå›´ï¼Œä½†æ˜¯ç”±äºé”®çš„æ•°é‡ä¼šè¿œè¿œå¤§äºæ˜ å°„çš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œè¿™ä¸ªç†æƒ³çš„æ•ˆæœæ˜¯ä¸å¯èƒ½å®ç°çš„ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702111005.png" alt=""  />
</p>
<p>æ¯”è¾ƒå®é™…çš„æ–¹å¼æ˜¯è®©å“ˆå¸Œå‡½æ•°çš„ç»“æœèƒ½å¤Ÿå°½å¯èƒ½çš„å‡åŒ€åˆ†å¸ƒï¼Œç„¶åé€šè¿‡å·¥ç¨‹ä¸Šçš„æ‰‹æ®µè§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜ã€‚å“ˆå¸Œå‡½æ•°æ˜ å°„çš„ç»“æœä¸€å®šè¦å°½å¯èƒ½å‡åŒ€ï¼Œç»“æœä¸å‡åŒ€çš„å“ˆå¸Œå‡½æ•°ä¼šå¸¦æ¥æ›´å¤šçš„å“ˆå¸Œå†²çªä»¥åŠæ›´å·®çš„è¯»å†™æ€§èƒ½ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702114225.png" alt=""  />
</p>
<p>å¦‚æœä½¿ç”¨ç»“æœåˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„å“ˆå¸Œå‡½æ•°ï¼Œé‚£ä¹ˆå“ˆå¸Œçš„å¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(1)ï¼›ä½†æ˜¯å¦‚æœå“ˆå¸Œå‡½æ•°çš„ç»“æœåˆ†å¸ƒä¸å‡åŒ€ï¼Œé‚£ä¹ˆæ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å¯èƒ½ä¼šè¾¾åˆ° ğ‘‚(ğ‘›)ï¼Œç”±æ­¤çœ‹æ¥ï¼Œä½¿ç”¨å¥½çš„å“ˆå¸Œå‡½æ•°æ˜¯è‡³å…³é‡è¦çš„ã€‚</p>
<h3 id="å†²çªè§£å†³">å†²çªè§£å†³<a hidden class="anchor" aria-hidden="true" href="#å†²çªè§£å†³">#</a></h3>
<p>å°±åƒæˆ‘ä»¬ä¹‹å‰æ‰€æåˆ°çš„ï¼Œåœ¨é€šå¸¸æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°è¾“å…¥çš„èŒƒå›´ä¸€å®šä¼šè¿œè¿œå¤§äºè¾“å‡ºçš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨å“ˆå¸Œè¡¨æ—¶ä¸€å®šä¼šé‡åˆ°å†²çªï¼Œå“ªæ€•æˆ‘ä»¬ä½¿ç”¨äº†å®Œç¾çš„å“ˆå¸Œå‡½æ•°ï¼Œå½“è¾“å…¥çš„é”®è¶³å¤Ÿå¤šä¹Ÿä¼šäº§ç”Ÿå†²çªã€‚ç„¶è€Œå¤šæ•°çš„å“ˆå¸Œå‡½æ•°éƒ½æ˜¯ä¸å¤Ÿå®Œç¾çš„ï¼Œæ‰€ä»¥ä»ç„¶å­˜åœ¨å‘ç”Ÿå“ˆå¸Œç¢°æ’çš„å¯èƒ½ï¼Œè¿™æ—¶å°±éœ€è¦ä¸€äº›æ–¹æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜ï¼Œå¸¸è§æ–¹æ³•çš„å°±æ˜¯å¼€æ”¾å¯»å€æ³•å’Œæ‹‰é“¾æ³•ã€‚</p>
<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæåˆ°çš„å“ˆå¸Œç¢°æ’ä¸æ˜¯å¤šä¸ªé”®å¯¹åº”çš„å“ˆå¸Œå®Œå…¨ç›¸ç­‰ï¼Œå¯èƒ½æ˜¯å¤šä¸ªå“ˆå¸Œçš„éƒ¨åˆ†ç›¸ç­‰ï¼Œä¾‹å¦‚ï¼šä¸¤ä¸ªé”®å¯¹åº”å“ˆå¸Œçš„å‰å››ä¸ªå­—èŠ‚ç›¸åŒã€‚</p>
<h4 id="å¼€æ”¾å¯»å€æ³•">å¼€æ”¾å¯»å€æ³•<a hidden class="anchor" aria-hidden="true" href="#å¼€æ”¾å¯»å€æ³•">#</a></h4>
<p>å¼€æ”¾å¯»å€æ³•æ˜¯ä¸€ç§åœ¨å“ˆå¸Œè¡¨ä¸­è§£å†³å“ˆå¸Œç¢°æ’çš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä¾æ¬¡æ¢æµ‹å’Œæ¯”è¾ƒæ•°ç»„ä¸­çš„å…ƒç´ ä»¥åˆ¤æ–­ç›®æ ‡é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨å¼€æ”¾å¯»å€æ³•æ¥å®ç°å“ˆå¸Œè¡¨ï¼Œé‚£ä¹ˆå®ç°å“ˆå¸Œè¡¨åº•å±‚çš„æ•°æ®ç»“æ„å°±æ˜¯æ•°ç»„ï¼Œä¸è¿‡å› ä¸ºæ•°ç»„çš„é•¿åº¦æœ‰é™ï¼Œå‘å“ˆå¸Œè¡¨å†™å…¥ (author, draven) è¿™ä¸ªé”®å€¼å¯¹æ—¶ä¼šä»å¦‚ä¸‹çš„ç´¢å¼•å¼€å§‹éå†ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">index</span> <span class="o">:=</span> <span class="nf">hash</span><span class="p">(</span><span class="s">&#34;author&#34;</span><span class="p">)</span> <span class="o">%</span> <span class="nx">array</span><span class="p">.</span><span class="nx">len</span>
</code></pre></td></tr></table>
</div>
</div><p>å½“æˆ‘ä»¬å‘å½“å‰å“ˆå¸Œè¡¨å†™å…¥æ–°çš„æ•°æ®æ—¶ï¼Œå¦‚æœå‘ç”Ÿäº†å†²çªï¼Œå°±ä¼šå°†é”®å€¼å¯¹å†™å…¥åˆ°ä¸‹ä¸€ä¸ªç´¢å¼•ä¸ä¸ºç©ºçš„ä½ç½®ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702115238.png" alt=""  />
</p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå½“ Key3 ä¸å·²ç»å­˜å…¥å“ˆå¸Œè¡¨ä¸­çš„ä¸¤ä¸ªé”®å€¼å¯¹ Key1 å’Œ Key2 å‘ç”Ÿå†²çªæ—¶ï¼ŒKey3 ä¼šè¢«å†™å…¥ Key2 åé¢çš„ç©ºé—²ä½ç½®ã€‚å½“æˆ‘ä»¬å†å»è¯»å– Key3 å¯¹åº”çš„å€¼æ—¶å°±ä¼šå…ˆè·å–é”®çš„å“ˆå¸Œå¹¶å–æ¨¡ï¼Œè¿™ä¼šå…ˆå¸®åŠ©æˆ‘ä»¬æ‰¾åˆ° Key1ï¼Œæ‰¾åˆ° Key1 åå‘ç°å®ƒä¸ Key 3 ä¸ç›¸ç­‰ï¼Œæ‰€ä»¥ä¼šç»§ç»­æŸ¥æ‰¾åé¢çš„å…ƒç´ ï¼Œç›´åˆ°å†…å­˜ä¸ºç©ºæˆ–è€…æ‰¾åˆ°ç›®æ ‡å…ƒç´ ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702115247.png" alt=""  />
</p>
<p>å½“éœ€è¦æŸ¥æ‰¾æŸä¸ªé”®å¯¹åº”çš„å€¼æ—¶ï¼Œä¼šä»ç´¢å¼•çš„ä½ç½®å¼€å§‹çº¿æ€§æ¢æµ‹æ•°ç»„ï¼Œæ‰¾åˆ°ç›®æ ‡é”®å€¼å¯¹æˆ–è€…ç©ºå†…å­˜å°±æ„å‘³ç€è¿™ä¸€æ¬¡æŸ¥è¯¢æ“ä½œçš„ç»“æŸã€‚</p>
<p>å¼€æ”¾å¯»å€æ³•ä¸­å¯¹æ€§èƒ½å½±å“æœ€å¤§çš„æ˜¯è£…è½½å› å­ï¼Œå®ƒæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ä¸æ•°ç»„å¤§å°çš„æ¯”å€¼ã€‚éšç€è£…è½½å› å­çš„å¢åŠ ï¼Œçº¿æ€§æ¢æµ‹çš„å¹³å‡ç”¨æ—¶å°±ä¼šé€æ¸å¢åŠ ï¼Œè¿™ä¼šå½±å“å“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚å½“è£…è½½ç‡è¶…è¿‡ 70% ä¹‹åï¼Œå“ˆå¸Œè¡¨çš„æ€§èƒ½å°±ä¼šæ€¥å‰§ä¸‹é™ï¼Œè€Œä¸€æ—¦è£…è½½ç‡è¾¾åˆ° 100%ï¼Œæ•´ä¸ªå“ˆå¸Œè¡¨å°±ä¼šå®Œå…¨å¤±æ•ˆï¼Œè¿™æ—¶æŸ¥æ‰¾å’Œæ’å…¥ä»»æ„å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ ğ‘‚(ğ‘›) çš„ï¼Œè¿™æ—¶éœ€è¦éå†æ•°ç»„ä¸­çš„å…¨éƒ¨å…ƒç´ ï¼Œæ‰€ä»¥åœ¨å®ç°å“ˆå¸Œè¡¨æ—¶ä¸€å®šè¦å…³æ³¨è£…è½½å› å­çš„å˜åŒ–ã€‚</p>
<h4 id="æ‹‰é“¾æ³•">æ‹‰é“¾æ³•<a hidden class="anchor" aria-hidden="true" href="#æ‹‰é“¾æ³•">#</a></h4>
<p>ä¸å¼€æ”¾åœ°å€æ³•ç›¸æ¯”ï¼Œæ‹‰é“¾æ³•æ˜¯å“ˆå¸Œè¡¨æœ€å¸¸è§çš„å®ç°æ–¹æ³•ï¼Œå¤§å¤šæ•°çš„ç¼–ç¨‹è¯­è¨€éƒ½ç”¨æ‹‰é“¾æ³•å®ç°å“ˆå¸Œè¡¨ï¼Œå®ƒçš„å®ç°æ¯”è¾ƒå¼€æ”¾åœ°å€æ³•ç¨å¾®å¤æ‚ä¸€äº›ï¼Œä½†æ˜¯å¹³å‡æŸ¥æ‰¾çš„é•¿åº¦ä¹Ÿæ¯”è¾ƒçŸ­ï¼Œå„ä¸ªç”¨äºå­˜å‚¨èŠ‚ç‚¹çš„å†…å­˜éƒ½æ˜¯åŠ¨æ€ç”³è¯·çš„ï¼Œå¯ä»¥èŠ‚çœæ¯”è¾ƒå¤šçš„å­˜å‚¨ç©ºé—´ã€‚</p>
<p>å®ç°æ‹‰é“¾æ³•ä¸€èˆ¬ä¼šä½¿ç”¨æ•°ç»„åŠ ä¸Šé“¾è¡¨ï¼Œä¸è¿‡ä¸€äº›ç¼–ç¨‹è¯­è¨€ä¼šåœ¨æ‹‰é“¾æ³•çš„å“ˆå¸Œä¸­å¼•å…¥çº¢é»‘æ ‘ä»¥ä¼˜åŒ–æ€§èƒ½ï¼Œæ‹‰é“¾æ³•ä¼šä½¿ç”¨é“¾è¡¨æ•°ç»„ä½œä¸ºå“ˆå¸Œåº•å±‚çš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒçœ‹æˆå¯ä»¥æ‰©å±•çš„äºŒç»´æ•°ç»„ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702115321.png" alt=""  />
</p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå½“æˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªé”®å€¼å¯¹ (Key6, Value6) å†™å…¥å“ˆå¸Œè¡¨æ—¶ï¼Œé”®å€¼å¯¹ä¸­çš„é”® Key6 éƒ½ä¼šå…ˆç»è¿‡ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼Œå“ˆå¸Œå‡½æ•°è¿”å›çš„å“ˆå¸Œä¼šå¸®åŠ©æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæ¡¶ï¼Œå’Œå¼€æ”¾åœ°å€æ³•ä¸€æ ·ï¼Œé€‰æ‹©æ¡¶çš„æ–¹å¼æ˜¯ç›´æ¥å¯¹å“ˆå¸Œè¿”å›çš„ç»“æœå–æ¨¡ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">index</span> <span class="o">:=</span> <span class="nf">hash</span><span class="p">(</span><span class="s">&#34;Key6&#34;</span><span class="p">)</span> % <span class="n">array.len</span>
</code></pre></td></tr></table>
</div>
</div><p>é€‰æ‹©äº† 2 å·æ¡¶åå°±å¯ä»¥éå†å½“å‰æ¡¶ä¸­çš„é“¾è¡¨äº†ï¼Œåœ¨éå†é“¾è¡¨çš„è¿‡ç¨‹ä¸­ä¼šé‡åˆ°ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š</p>
<ol>
<li>æ‰¾åˆ°é”®ç›¸åŒçš„é”®å€¼å¯¹ â€” æ›´æ–°é”®å¯¹åº”çš„å€¼ï¼›</li>
<li>æ²¡æœ‰æ‰¾åˆ°é”®ç›¸åŒçš„é”®å€¼å¯¹ â€” åœ¨é“¾è¡¨çš„æœ«å°¾è¿½åŠ æ–°çš„é”®å€¼å¯¹ï¼›</li>
</ol>
<p>å¦‚æœè¦åœ¨å“ˆå¸Œè¡¨ä¸­è·å–æŸä¸ªé”®å¯¹åº”çš„å€¼ï¼Œä¼šç»å†å¦‚ä¸‹çš„è¿‡ç¨‹ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702115622.png" alt=""  />
</p>
<p>Key11 å±•ç¤ºäº†ä¸€ä¸ªé”®åœ¨å“ˆå¸Œè¡¨ä¸­ä¸å­˜åœ¨çš„ä¾‹å­ï¼Œå½“å“ˆå¸Œè¡¨å‘ç°å®ƒå‘½ä¸­ 4 å·æ¡¶æ—¶ï¼Œå®ƒä¼šä¾æ¬¡éå†æ¡¶ä¸­çš„é“¾è¡¨ï¼Œç„¶è€Œéå†åˆ°é“¾è¡¨çš„æœ«å°¾ä¹Ÿæ²¡æœ‰æ‰¾åˆ°æœŸæœ›çš„é”®ï¼Œæ‰€ä»¥å“ˆå¸Œè¡¨ä¸­æ²¡æœ‰è¯¥é”®å¯¹åº”çš„å€¼ã€‚</p>
<p>åœ¨ä¸€ä¸ªæ€§èƒ½æ¯”è¾ƒå¥½çš„å“ˆå¸Œè¡¨ä¸­ï¼Œæ¯ä¸€ä¸ªæ¡¶ä¸­éƒ½åº”è¯¥æœ‰ 0~1 ä¸ªå…ƒç´ ï¼Œæœ‰æ—¶ä¼šæœ‰ 2~3 ä¸ªï¼Œå¾ˆå°‘ä¼šè¶…è¿‡è¿™ä¸ªæ•°é‡ã€‚è®¡ç®—å“ˆå¸Œã€å®šä½æ¡¶å’Œéå†é“¾è¡¨ä¸‰ä¸ªè¿‡ç¨‹æ˜¯å“ˆå¸Œè¡¨è¯»å†™æ“ä½œçš„ä¸»è¦å¼€é”€ï¼Œä½¿ç”¨æ‹‰é“¾æ³•å®ç°çš„å“ˆå¸Œä¹Ÿæœ‰è£…è½½å› å­è¿™ä¸€æ¦‚å¿µï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">è£…è½½å› å­<span class="o">:=</span>å…ƒç´ æ•°é‡Ã·æ¡¶æ•°é‡
</code></pre></td></tr></table>
</div>
</div><p>ä¸å¼€æ”¾åœ°å€æ³•ä¸€æ ·ï¼Œæ‹‰é“¾æ³•çš„è£…è½½å› å­è¶Šå¤§ï¼Œå“ˆå¸Œçš„è¯»å†™æ€§èƒ½å°±è¶Šå·®ã€‚åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ä½¿ç”¨æ‹‰é“¾æ³•çš„å“ˆå¸Œè¡¨è£…è½½å› å­éƒ½ä¸ä¼šè¶…è¿‡ 1ï¼Œå½“å“ˆå¸Œè¡¨çš„è£…è½½å› å­è¾ƒå¤§æ—¶ä¼šè§¦å‘å“ˆå¸Œçš„æ‰©å®¹ï¼Œåˆ›å»ºæ›´å¤šçš„æ¡¶æ¥å­˜å‚¨å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œä¿è¯æ€§èƒ½ä¸ä¼šå‡ºç°ä¸¥é‡çš„ä¸‹é™ã€‚å¦‚æœæœ‰ 1000 ä¸ªæ¡¶çš„å“ˆå¸Œè¡¨å­˜å‚¨äº† 10000 ä¸ªé”®å€¼å¯¹ï¼Œå®ƒçš„æ€§èƒ½æ˜¯ä¿å­˜ 1000 ä¸ªé”®å€¼å¯¹çš„ 1/10ï¼Œä½†æ˜¯ä»ç„¶æ¯”åœ¨é“¾è¡¨ä¸­ç›´æ¥è¯»å†™å¥½ 1000 å€ã€‚</p>
<h2 id="hmap">hmap<a hidden class="anchor" aria-hidden="true" href="#hmap">#</a></h2>
<p>Go è¯­è¨€è¿è¡Œæ—¶åŒæ—¶ä½¿ç”¨äº†å¤šä¸ªæ•°æ®ç»“æ„ç»„åˆè¡¨ç¤ºå“ˆå¸Œè¡¨ï¼Œå…¶ä¸­ runtime.hmap æ˜¯æœ€æ ¸å¿ƒçš„ç»“æ„ä½“ï¼Œå®ƒæ˜¯ hashmap çš„â€œç¼©å†™â€,æˆ‘ä»¬å…ˆæ¥äº†è§£ä¸€ä¸‹è¯¥ç»“æ„ä½“çš„å†…éƒ¨å­—æ®µï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A header for a Go map.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span><span class="c1"></span>	<span class="c1">// Make sure this stays in sync with the compiler&#39;s definition.
</span><span class="c1"></span>	<span class="c1">// å…ƒç´ ä¸ªæ•°ï¼Œè°ƒç”¨ len(map) æ—¶ï¼Œç›´æ¥è¿”å›æ­¤å€¼
</span><span class="c1"></span>	<span class="nx">count</span>     <span class="kt">int</span> <span class="c1">// # live cells == size of map.  Must be first (used by len() builtin)
</span><span class="c1"></span>	<span class="c1">//æ ‡å¿—ä½
</span><span class="c1"></span>	<span class="c1">// iterator     = 1 // å¯èƒ½æœ‰éå†ç”¨buckets
</span><span class="c1"></span>	<span class="c1">// oldIterator  = 2 // å¯èƒ½æœ‰éå†ç”¨oldbucketsï¼Œç”¨äºæ‰©å®¹æœŸé—´
</span><span class="c1"></span>	<span class="c1">// hashWriting  = 4 // æ ‡è®°å†™ï¼Œç”¨äºå¹¶å‘è¯»å†™æ£€æµ‹
</span><span class="c1"></span>	<span class="c1">// sameSizeGrow = 8 // ç”¨äºç­‰å¤§å°bucketsæ‰©å®¹ï¼Œå‡å°‘overflowæ¡¶
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>
	<span class="c1">// buckets çš„å¯¹æ•° log_2
</span><span class="c1"></span>	<span class="c1">// B è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨æŒæœ‰çš„ buckets æ•°é‡ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼Œæ‰€ä»¥è¯¥å­—æ®µä¼šå­˜å‚¨å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯ `len(buckets) == 2^B`ï¼›
</span><span class="c1"></span>	<span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span><span class="c1"></span>	<span class="c1">// overflow çš„ bucket è¿‘ä¼¼æ•°
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// approximate number of overflow buckets; see incrnoverflow for details
</span><span class="c1"></span>	<span class="c1">// è®¡ç®— key çš„å“ˆå¸Œçš„æ—¶å€™ä¼šä¼ å…¥å“ˆå¸Œå‡½æ•°
</span><span class="c1"></span>	<span class="c1">// hash0 æ˜¯å“ˆå¸Œçš„ç§å­ï¼Œå®ƒèƒ½ä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ï¼Œè¿™ä¸ªå€¼åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥ï¼›
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash seed
</span><span class="c1"></span>	<span class="c1">// æŒ‡å‘ buckets æ•°ç»„ï¼Œå¤§å°ä¸º 2^B
</span><span class="c1"></span>   	<span class="c1">// å¦‚æœå…ƒç´ ä¸ªæ•°ä¸º0ï¼Œå°±ä¸º nil
</span><span class="c1"></span>	<span class="c1">// æŒ‡å‘ç¬¬ä¸€ä¸ªæ¡¶çš„æŒ‡é’ˆ æ˜¯ä¸€ä¸ªè¿ç»­çš„åœ°å€ å› ä¸ºæ˜¯ä¸ªæ•°ç»„
</span><span class="c1"></span>  	<span class="c1">// è¿™é‡Œé¢å­˜çš„æ˜¯ *bmap
</span><span class="c1"></span>	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// array of 2^B Buckets. may be nil if count==0.
</span><span class="c1"></span>	<span class="c1">// æ‰©å®¹çš„æ—¶å€™ï¼Œbuckets é•¿åº¦ä¼šæ˜¯ oldbuckets çš„ä¸¤å€
</span><span class="c1"></span>	<span class="c1">// oldbuckets æ˜¯å“ˆå¸Œåœ¨æ‰©å®¹æ—¶ç”¨äºä¿å­˜ä¹‹å‰ buckets çš„å­—æ®µï¼Œå®ƒçš„å¤§å°æ˜¯å½“å‰ buckets çš„ä¸€åŠ
</span><span class="c1"></span>	<span class="c1">// æ—§æ¡¶ç¬¬ä¸€ä¸ªæ¡¶çš„æŒ‡é’ˆï¼Œç”¨äºåœ¨æ‰©å®¹æ¬è¿çš„æ—¶å€™æœªå®Œæˆæ¬è¿æ—¶ä¿å­˜ä¹‹å‰çš„æ—§æ¡¶
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// previous bucket array of half the size, non-nil only when growing
</span><span class="c1"></span>	<span class="c1">// æŒ‡ç¤ºæ‰©å®¹è¿›åº¦ï¼Œå°äºæ­¤åœ°å€çš„ buckets è¿ç§»å®Œæˆ
</span><span class="c1"></span>	<span class="c1">// æ¬è¿æ¡¶çš„è¿›åº¦ å°±æ˜¯å¤„äºæ‰©å®¹æ¬è¿æ—¶ï¼Œç›®å‰æ¬åˆ°å“ªäº†
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// progress counter for evacuation (buckets less than this have been evacuated)
</span><span class="c1"></span>	<span class="c1">// æº¢å‡ºæ¡¶  å½“bmapä¸­å­˜å‚¨çš„æ•°æ®è¿‡å¤š
</span><span class="c1"></span>  	<span class="c1">// å•ä¸ªbmapå·²ç»è£…æ»¡æ—¶å°±ä¼šä½¿ç”¨ extra.nextOverflow ä¸­æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ã€‚
</span><span class="c1"></span>  	<span class="c1">// æº¢å‡ºæ¡¶ä¸ä¸€å®šä¼šä½¿ç”¨ï¼Œå› ä¸ºä»–æ˜¯ä¸ªå¯é€‰å­—æ®µ
</span><span class="c1"></span>	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Mapçš„æœ€å¤§æ¡¶çš„æ•°é‡ä¸º2^255ä¸ªï¼Œå› ä¸ºhmap.Bä¸ºuint8ç±»å‹ï¼Œæœ€å¤§å€¼ä¸º255.</p>
<p>æ¡¶çš„æ•°é‡æ˜¯2^Bä¸ª</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810214123.png" alt=""  />
</p>
<h3 id="bmap">bmap<a hidden class="anchor" aria-hidden="true" href="#bmap">#</a></h3>
<p>å“ˆå¸Œè¡¨ <code>runtime.hmap</code> çš„æ¡¶æ˜¯ <code>runtime.bmap</code>ã€‚æ¯ä¸€ä¸ª <code>runtime.bmap</code> éƒ½èƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œå½“å“ˆå¸Œè¡¨ä¸­å­˜å‚¨çš„æ•°æ®è¿‡å¤šï¼Œå•ä¸ªæ¡¶å·²ç»è£…æ»¡æ—¶å°±ä¼šä½¿ç”¨ <code>extra.nextOverflow</code> ä¸­æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ã€‚</p>
<p>ä¸Šè¿°ä¸¤ç§ä¸åŒçš„æ¡¶åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°†å®ƒä»¬åˆ†åˆ«ç§°ä¸ºæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œä¸Šå›¾ä¸­é»„è‰²çš„ <code>runtime.bmap</code> å°±æ˜¯æ­£å¸¸æ¡¶ï¼Œç»¿è‰²çš„ <code>runtime.bmap</code> æ˜¯æº¢å‡ºæ¡¶ï¼Œæº¢å‡ºæ¡¶æ˜¯åœ¨ Go è¯­è¨€è¿˜ä½¿ç”¨ C è¯­è¨€å®ç°æ—¶ä½¿ç”¨çš„è®¾è®¡ï¼Œç”±äºå®ƒèƒ½å¤Ÿå‡å°‘æ‰©å®¹çš„é¢‘ç‡æ‰€ä»¥ä¸€ç›´ä½¿ç”¨è‡³ä»Šã€‚</p>
<p>æ¡¶çš„ç»“æ„ä½“ <code>runtime.bmap</code> åœ¨ Go è¯­è¨€æºä»£ç ä¸­çš„å®šä¹‰åªåŒ…å«ä¸€ä¸ªç®€å•çš„ tophash å­—æ®µï¼Œtophash å­˜å‚¨äº†é”®çš„å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œé€šè¿‡æ¯”è¾ƒä¸åŒé”®çš„å“ˆå¸Œçš„é«˜ 8 ä½å¯ä»¥å‡å°‘è®¿é—®é”®å€¼å¯¹æ¬¡æ•°ä»¥æé«˜æ€§èƒ½ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Maximum number of key/elem pairs a bucket can hold.
</span><span class="c1"></span><span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="mi">3</span>
<span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bucketCntBits</span>
<span class="c1">// A bucket for a Go map.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// è®°å½•æ¡¶å†…8ä¸ªå•å…ƒçš„é«˜8ä½hashå€¼ï¼Œæˆ–æ ‡è®°ç©ºæ¡¶çŠ¶æ€ï¼Œç”¨äºå¿«é€Ÿå®šä½key
</span><span class="c1"></span>	<span class="c1">// emptyRest      = 0 // æ­¤å•å…ƒä¸ºç©ºï¼Œä¸”æ›´é«˜ç´¢å¼•çš„å•å…ƒä¹Ÿä¸ºç©º
</span><span class="c1"></span>	<span class="c1">// emptyOne       = 1 // æ­¤å•å…ƒä¸ºç©º
</span><span class="c1"></span>	<span class="c1">// evacuatedX     = 2 // ç”¨äºè¡¨ç¤ºæ‰©å®¹è¿ç§»åˆ°æ–°æ¡¶å‰åŠæ®µåŒºé—´
</span><span class="c1"></span>	<span class="c1">// evacuatedY     = 3 // ç”¨äºè¡¨ç¤ºæ‰©å®¹è¿ç§»åˆ°æ–°æ¡¶ååŠæ®µåŒºé—´
</span><span class="c1"></span>	<span class="c1">// evacuatedEmpty = 4 // ç”¨äºè¡¨ç¤ºæ­¤å•å…ƒå·²è¿ç§»
</span><span class="c1"></span>	<span class="c1">// minTopHash     = 5 // æœ€å°çš„ç©ºæ¡¶æ ‡è®°å€¼ï¼Œå°äºå…¶åˆ™æ˜¯ç©ºæ¡¶æ ‡å¿—
</span><span class="c1"></span>	<span class="c1">// tophash generally contains the top byte of the hash value
</span><span class="c1"></span>	<span class="c1">// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span><span class="c1"></span>	<span class="c1">// tophash[0] is a bucket evacuation state instead.
</span><span class="c1"></span>	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
	<span class="c1">// Followed by bucketCnt keys and then bucketCnt elems.
</span><span class="c1"></span>	<span class="c1">// NOTE: packing all the keys together and then all the elems together makes the
</span><span class="c1"></span>	<span class="c1">// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span><span class="c1"></span>	<span class="c1">// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span><span class="c1"></span>	<span class="c1">// Followed by an overflow pointer.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>åœ¨è¿è¡ŒæœŸé—´ï¼Œ<code>runtime.bmap</code> ç»“æ„ä½“å…¶å®ä¸æ­¢åŒ…å« tophash å­—æ®µï¼Œå› ä¸ºå“ˆå¸Œè¡¨ä¸­å¯èƒ½å­˜å‚¨ä¸åŒç±»å‹çš„é”®å€¼å¯¹ï¼Œè€Œä¸” Go è¯­è¨€ä¹Ÿä¸æ”¯æŒæ³›å‹ï¼Œæ‰€ä»¥é”®å€¼å¯¹å æ®çš„å†…å­˜ç©ºé—´å¤§å°åªèƒ½åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ¨å¯¼ã€‚<code>runtime.bmap</code> ä¸­çš„å…¶ä»–å­—æ®µåœ¨è¿è¡Œæ—¶ä¹Ÿéƒ½æ˜¯é€šè¿‡è®¡ç®—å†…å­˜åœ°å€çš„æ–¹å¼è®¿é—®çš„ï¼Œæ‰€ä»¥å®ƒçš„å®šä¹‰ä¸­å°±ä¸åŒ…å«è¿™äº›å­—æ®µï¼Œä¸è¿‡æˆ‘ä»¬èƒ½æ ¹æ®ç¼–è¯‘æœŸé—´çš„ <code>cmd/compile/internal/gc.bmap</code> å‡½æ•°é‡å»ºå®ƒçš„ç»“æ„ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// å®é™…å­˜å‚¨kï¼Œvæ•°æ®çš„æ¡¶
</span><span class="c1">// è¯¥ç»“æ„ä½“è¿˜æœ‰ä¸€äº›å­—æ®µä¼šåœ¨ç¼–è¯‘æœŸæ·»åŠ 
</span><span class="c1">// æ¯”å¦‚ ä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶çš„åœ°å€
</span><span class="c1">// keyï¼Œvalueæ‰€å¤„çš„åœ°å€ç­‰
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// è¿™é‡Œå­˜å‚¨å¯ Keyçš„å“ˆå¸Œå€¼çš„é«˜8ä½ ä¾‹å­ 11111111 00000000
</span><span class="c1"></span>    <span class="c1">// ç”¨äºåœ¨æŸ¥æ‰¾æ—¶å¿«é€Ÿçš„å»åˆ¤æ–­å½“å‰Keyæ˜¯å¦å­˜åœ¨è¿™ä¸ªæ¡¶é‡Œ
</span><span class="c1"></span>    <span class="c1">// å› æ­¤å¾—å‡ºï¼Œæ¯ä¸ªæ¡¶åªèƒ½å­˜æ”¾8ä¸ªKey-Valueæ˜ å°„
</span><span class="c1"></span>    <span class="nx">topbits</span>  <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
    <span class="nx">keys</span>     <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">keytype</span>
    <span class="nx">values</span>   <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">valuetype</span>
    <span class="nx">pad</span>      <span class="kt">uintptr</span>
    <span class="c1">// overflow æ¡¶
</span><span class="c1"></span>    <span class="c1">// otyp ç±»å‹ä¸ºæŒ‡é’ˆ*Type,
</span><span class="c1"></span>    <span class="c1">// è‹¥keytypeåŠelemtypeä¸å«æŒ‡é’ˆï¼Œåˆ™ä¸ºuintptr
</span><span class="c1"></span>    <span class="c1">// ä½¿bmapæ•´ä½“ä¸å«æŒ‡é’ˆ,é¿å…gcå»scanæ­¤ç±»map
</span><span class="c1"></span>    <span class="nx">overflow</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>éšç€å“ˆå¸Œè¡¨å­˜å‚¨çš„æ•°æ®é€æ¸å¢å¤šï¼Œæˆ‘ä»¬ä¼šæ‰©å®¹å“ˆå¸Œè¡¨æˆ–è€…ä½¿ç”¨é¢å¤–çš„æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ï¼Œä¸ä¼šè®©å•ä¸ªæ¡¶ä¸­çš„æ•°æ®è¶…è¿‡ 8 ä¸ªï¼Œä¸è¿‡æº¢å‡ºæ¡¶åªæ˜¯ä¸´æ—¶çš„è§£å†³æ–¹æ¡ˆï¼Œåˆ›å»ºè¿‡å¤šçš„æº¢å‡ºæ¡¶æœ€ç»ˆä¹Ÿä¼šå¯¼è‡´å“ˆå¸Œçš„æ‰©å®¹ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702194837.png" alt=""  />
</p>
<p>bmap æ˜¯å­˜æ”¾ k-v çš„åœ°æ–¹ï¼Œæˆ‘ä»¬æŠŠè§†è§’æ‹‰è¿‘ï¼Œä»”ç»†çœ‹ bmap çš„å†…éƒ¨ç»„æˆã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702223736.png" alt=""  />
</p>
<p>ä¸Šå›¾å°±æ˜¯ bucket çš„å†…å­˜æ¨¡å‹ï¼ŒHOB Hash æŒ‡çš„å°±æ˜¯ top hashã€‚ æ³¨æ„åˆ° key å’Œ value æ˜¯å„è‡ªæ”¾åœ¨ä¸€èµ·çš„ï¼Œå¹¶ä¸æ˜¯ key/value/key/value/&hellip; è¿™æ ·çš„å½¢å¼ã€‚æºç é‡Œè¯´æ˜è¿™æ ·çš„å¥½å¤„æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥çœç•¥æ‰ padding å­—æ®µï¼ŒèŠ‚çœå†…å­˜ç©ºé—´ã€‚</p>
<p>ä¾‹å¦‚ï¼Œæœ‰è¿™æ ·ä¸€ä¸ªç±»å‹çš„ mapï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="kt">int8</span>
</code></pre></td></tr></table>
</div>
</div><p>å¦‚æœæŒ‰ç…§ <code>key/value/key/value/...</code> è¿™æ ·çš„æ¨¡å¼å­˜å‚¨ï¼Œé‚£åœ¨æ¯ä¸€ä¸ª <code>key/value</code> å¯¹ä¹‹åéƒ½è¦é¢å¤– padding 7 ä¸ªå­—èŠ‚ï¼›è€Œå°†æ‰€æœ‰çš„ keyï¼Œvalue åˆ†åˆ«ç»‘å®šåˆ°ä¸€èµ·ï¼Œè¿™ç§å½¢å¼ <code>key/key/.../value/value/...</code>ï¼Œåˆ™åªéœ€è¦åœ¨æœ€åæ·»åŠ  paddingã€‚</p>
<p>æ¯ä¸ª bucket è®¾è®¡æˆæœ€å¤šåªèƒ½æ”¾ 8 ä¸ª key-value å¯¹ï¼Œå¦‚æœæœ‰ç¬¬ 9 ä¸ª key-value è½å…¥å½“å‰çš„ bucketï¼Œé‚£å°±éœ€è¦å†æ„å»ºä¸€ä¸ª bucket ï¼Œé€šè¿‡ overflow æŒ‡é’ˆè¿æ¥èµ·æ¥ã€‚</p>
<p>æ­£å¸¸æƒ…å†µkeyå’Œelemç›´æ¥ä½¿ç”¨ç”¨æˆ·å£°æ˜çš„ç±»å‹ï¼Œä½†å½“å…¶sizeå¤§äº128(MAXKEYSIZE/MAXELEMSIZE)æ—¶ï¼Œåˆ™ä¼šè½¬ä¸ºæŒ‡é’ˆå»å­˜å‚¨ã€‚ï¼ˆä¹Ÿå°±æ˜¯indirectkeyã€indirectelemï¼‰</p>
<h3 id="mapextra">mapextra<a hidden class="anchor" aria-hidden="true" href="#mapextra">#</a></h3>
<p>å½“ map çš„ key å’Œ value éƒ½ä¸æ˜¯æŒ‡é’ˆï¼Œå¹¶ä¸” size éƒ½å°äº 128 å­—èŠ‚çš„æƒ…å†µä¸‹ï¼Œä¼šæŠŠ bmap æ ‡è®°ä¸ºä¸å«æŒ‡é’ˆï¼Œè¿™æ ·å¯ä»¥é¿å… gc æ—¶æ‰«ææ•´ä¸ª hmapã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬çœ‹ bmap å…¶å®æœ‰ä¸€ä¸ª overflow çš„å­—æ®µï¼Œæ˜¯æŒ‡é’ˆç±»å‹çš„ï¼Œç ´åäº† bmap ä¸å«æŒ‡é’ˆçš„è®¾æƒ³ï¼Œè¿™æ—¶ä¼šæŠŠ overflow ç§»åŠ¨åˆ° extra å­—æ®µæ¥ã€‚</p>
<p>hmap.extraå…·ä½“æ˜¯ä¸ºè§£å†³è®©gcä¸éœ€è¦æ‰«ææ­¤ç±»bucketã€‚åªè¦bmapå†…ä¸å«æŒ‡é’ˆå°±ä¸éœ€gcæ‰«æã€‚</p>
<p>å½“mapçš„keyå’Œelemç±»å‹éƒ½ä¸åŒ…å«æŒ‡é’ˆæ—¶ï¼Œä½†å…¶ä¸­çš„overflowæ˜¯æŒ‡é’ˆã€‚æ­¤æ—¶bmapçš„ç”Ÿæˆå‡½æ•°ä¼šå°†overflowçš„ç±»å‹è½¬åŒ–ä¸ºuintptrã€‚è€Œuintptrè™½ç„¶æ˜¯åœ°å€ï¼Œä½†ä¸ä¼šè¢«gcè®¤ä¸ºæ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘çš„æ•°æ®æœ‰è¢«å›æ”¶çš„é£é™©ã€‚</p>
<p>æ­¤æ—¶ä¸ºä¿è¯å…¶ä¸­çš„overflowæŒ‡é’ˆæŒ‡å‘çš„æ•°æ®å­˜æ´»ï¼Œå°±ç”¨mapextraç»“æ„æŒ‡å‘äº†è¿™äº›bucketsï¼Œè¿™æ ·bmapæœ‰è¢«å¼•ç”¨å°±ä¸ä¼šè¢«å›æ”¶äº†ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mapextra holds fields that are not present on all maps.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// If both key and elem do not contain pointers and are inline, then we mark bucket
</span><span class="c1"></span>	<span class="c1">// type as containing no pointers. This avoids scanning such maps.
</span><span class="c1"></span>	<span class="c1">// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span><span class="c1"></span>	<span class="c1">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span><span class="c1"></span>	<span class="c1">// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span><span class="c1"></span>	<span class="c1">// overflow contains overflow buckets for hmap.buckets.
</span><span class="c1"></span>	<span class="c1">// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span><span class="c1"></span>	<span class="c1">// The indirection allows to store a pointer to the slice in hiter.
</span><span class="c1"></span>	<span class="c1">// å¦‚æœkeyå’Œvalueéƒ½ä¸åŒ…å«æŒ‡é’ˆï¼Œè€Œä¸”æ˜¯å†…è”çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†bucketç±»å‹æ ‡è®°ä¸ºä¸åŒ…å«æŒ‡é’ˆã€‚
</span><span class="c1"></span> 	<span class="c1">// è¿™æ ·å°±é¿å…äº†å¯¹è¿™ç±»åœ°å›¾çš„æ‰«æã€‚
</span><span class="c1"></span> 	<span class="c1">// ç„¶è€Œï¼Œbmap.overflow æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚ä¸ºäº†é˜²æ­¢æº¢å‡ºæ¡¶è¢«gcå¤„ç†
</span><span class="c1"></span> 	<span class="c1">// æˆ‘ä»¬åœ¨hmap.extra.overflowå’Œhmap.extra.oldoverflowä¸­å­˜å‚¨æ‰€æœ‰æº¢å‡ºæ¡¶çš„æŒ‡é’ˆã€‚
</span><span class="c1"></span> 	<span class="c1">// overflowå’Œoldoverflowåªåœ¨keyå’Œvalueä¸åŒ…å«æŒ‡é’ˆçš„æƒ…å†µä¸‹ä½¿ç”¨
</span><span class="c1"></span>	<span class="c1">// å­˜å‚¨ä¸€ä¸ªå·²ç»åˆ›å»ºå¥½äº†ä½†æ˜¯æš‚æœªä½¿ç”¨çš„ç©ºbmapæº¢å‡ºæ¡¶
</span><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>

	<span class="c1">// nextOverflow holds a pointer to a free overflow bucket.
</span><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="maptype">maptype<a hidden class="anchor" aria-hidden="true" href="#maptype">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// map.goé‡Œå¾ˆå¤šå‡½æ•°çš„ç¬¬1ä¸ªå…¥å‚æ˜¯è¿™ä¸ªç»“æ„ï¼Œä»æˆå‘˜æ¥çœ‹å¾ˆæ˜æ˜¾ï¼Œæ­¤ç»“æ„æ ‡ç¤ºäº†é”®å€¼å¯¹å’Œæ¡¶çš„å¤§å°ç­‰å¿…è¦ä¿¡æ¯
</span><span class="c1">// æœ‰äº†è¿™ä¸ªç»“æ„çš„ä¿¡æ¯ï¼Œmap.goçš„ä»£ç å°±å¯ä»¥ä¸é”®å€¼å¯¹çš„å…·ä½“æ•°æ®ç±»å‹è§£è€¦
</span><span class="c1">// æ‰€ä»¥map.goç”¨å†…å­˜åç§»é‡å’Œunsafe.PointeræŒ‡é’ˆæ¥ç›´æ¥å¯¹å†…å­˜è¿›è¡Œå­˜å–ï¼Œè€Œæ— éœ€å…³å¿ƒkeyæˆ–valueçš„å…·ä½“ç±»å‹
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">maptype</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>    <span class="nx">_type</span>
	<span class="nx">key</span>    <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">elem</span>   <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">bucket</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// internal type representing a hash bucket
</span><span class="c1"></span>	<span class="c1">// function for hashing keys (ptr to key, seed) -&gt; hash
</span><span class="c1"></span>	<span class="nx">hasher</span>     <span class="kd">func</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span>
	<span class="nx">keysize</span>    <span class="kt">uint8</span>  <span class="c1">// size of key slot
</span><span class="c1"></span>	<span class="nx">elemsize</span>   <span class="kt">uint8</span>  <span class="c1">// size of elem slot
</span><span class="c1"></span>	<span class="nx">bucketsize</span> <span class="kt">uint16</span> <span class="c1">// size of bucket
</span><span class="c1"></span>	<span class="nx">flags</span>      <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="makemap">makemap<a hidden class="anchor" aria-hidden="true" href="#makemap">#</a></h2>
<p>æ—¢ç„¶å·²ç»ä»‹ç»äº†å“ˆå¸Œè¡¨çš„åŸºæœ¬åŸç†å’Œå®ç°æ–¹æ³•ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¼€å§‹åˆ†æ Go è¯­è¨€ä¸­å“ˆå¸Œè¡¨çš„å®ç°äº†ï¼Œé¦–å…ˆè¦åˆ†æçš„æ˜¯ Go è¯­è¨€åˆå§‹åŒ–å“ˆå¸Œçš„ä¸¤ç§æ–¹æ³• â€” é€šè¿‡å­—é¢é‡å’Œè¿è¡Œæ—¶ã€‚</p>
<p>ç›®å‰çš„ç°ä»£ç¼–ç¨‹è¯­è¨€åŸºæœ¬éƒ½æ”¯æŒä½¿ç”¨å­—é¢é‡çš„æ–¹å¼åˆå§‹åŒ–å“ˆå¸Œï¼Œä¸€èˆ¬éƒ½ä¼šä½¿ç”¨ <code>key: value</code> çš„è¯­æ³•æ¥è¡¨ç¤ºé”®å€¼å¯¹ï¼ŒGo è¯­è¨€ä¸­ä¹Ÿä¸ä¾‹å¤–ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">hash</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
	<span class="s">&#34;1&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
	<span class="s">&#34;3&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
	<span class="s">&#34;5&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>æˆ‘ä»¬éœ€è¦åœ¨åˆå§‹åŒ–å“ˆå¸Œæ—¶å£°æ˜é”®å€¼å¯¹çš„ç±»å‹ï¼Œè¿™ç§ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–çš„æ–¹å¼æœ€ç»ˆéƒ½ä¼šé€šè¿‡ <code>cmd/compile/internal/gc.maplit</code> åˆå§‹åŒ–ï¼Œæˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹è¯¥å‡½æ•°åˆå§‹åŒ–å“ˆå¸Œçš„è¿‡ç¨‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maplit</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">init</span> <span class="o">*</span><span class="nx">Nodes</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OMAKE</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nx">Esc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span>
	<span class="nx">a</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set2</span><span class="p">(</span><span class="nf">typenod</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">),</span> <span class="nf">nodintconst</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Len</span><span class="p">())))</span>
	<span class="nf">litas</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span>

	<span class="nx">entries</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Build list of var[c] = expr.
</span><span class="c1"></span>	<span class="c1">// Use temporaries so that mapassign1 can have addressable key, elem.
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>å½“å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡å°‘äºæˆ–è€…ç­‰äº 25 ä¸ªæ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°†å­—é¢é‡åˆå§‹åŒ–çš„ç»“æ„ä½“è½¬æ¢æˆä»¥ä¸‹çš„ä»£ç ï¼Œå°†æ‰€æœ‰çš„é”®å€¼å¯¹ä¸€æ¬¡åŠ å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">hash</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">hash</span><span class="p">[</span><span class="s">&#34;1&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">hash</span><span class="p">[</span><span class="s">&#34;3&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">hash</span><span class="p">[</span><span class="s">&#34;5&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">6</span>
</code></pre></td></tr></table>
</div>
</div><p>è¿™ç§åˆå§‹åŒ–çš„æ–¹å¼ä¸çš„æ•°ç»„å’Œåˆ‡ç‰‡å‡ ä¹å®Œå…¨ç›¸åŒï¼Œç”±æ­¤çœ‹æ¥é›†åˆç±»å‹çš„åˆå§‹åŒ–åœ¨ Go è¯­è¨€ä¸­æœ‰ç€ç›¸åŒçš„å¤„ç†é€»è¾‘ã€‚</p>
<p>ä¸€æ—¦å“ˆå¸Œè¡¨ä¸­å…ƒç´ çš„æ•°é‡è¶…è¿‡äº† 25 ä¸ªï¼Œç¼–è¯‘å™¨ä¼šåˆ›å»ºä¸¤ä¸ªæ•°ç»„åˆ†åˆ«å­˜å‚¨é”®å’Œå€¼ï¼Œè¿™äº›é”®å€¼å¯¹ä¼šé€šè¿‡å¦‚ä¸‹æ‰€ç¤ºçš„ for å¾ªç¯åŠ å…¥å“ˆå¸Œï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">hash</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
<span class="nx">vstatk</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">,</span> <span class="o">...</span> <span class="err">ï¼Œ</span> <span class="s">&#34;26&#34;</span><span class="p">}</span>
<span class="nx">vstatv</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="mi">26</span><span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vstak</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">hash</span><span class="p">[</span><span class="nx">vstatk</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">vstatv</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>è¿™é‡Œå±•å¼€çš„ä¸¤ä¸ªåˆ‡ç‰‡ <code>vstatk</code> å’Œ <code>vstatv</code> è¿˜ä¼šè¢«ç¼–è¾‘å™¨ç»§ç»­å±•å¼€ï¼Œå…·ä½“çš„å±•å¼€æ–¹å¼å¯ä»¥é˜…è¯»ä¸Šä¸€èŠ‚äº†è§£åˆ‡ç‰‡çš„åˆå§‹åŒ–ï¼Œä¸è¿‡æ— è®ºä½¿ç”¨å“ªç§æ–¹æ³•ï¼Œä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–çš„è¿‡ç¨‹éƒ½ä¼šä½¿ç”¨ Go è¯­è¨€ä¸­çš„å…³é”®å­— make æ¥åˆ›å»ºæ–°çš„å“ˆå¸Œå¹¶é€šè¿‡æœ€åŸå§‹çš„ <code>[]</code> è¯­æ³•å‘å“ˆå¸Œè¿½åŠ å…ƒç´ ã€‚</p>
<p>ä»è¯­æ³•å±‚é¢ä¸Šæ¥è¯´ï¼Œåˆ›å»º map å¾ˆç®€å•ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="c1">// æŒ‡å®š map é•¿åº¦
</span><span class="c1"></span><span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="c1">// ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ageMp</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>å½“åˆ›å»ºçš„å“ˆå¸Œè¢«åˆ†é…åˆ°å †ä¸Šå¹¶ä¸”å…¶å®¹é‡å°äº <code>BUCKETSIZE = 8</code> æ—¶ï¼ŒGo è¯­è¨€åœ¨ç¼–è¯‘é˜¶æ®µä¼šä½¿ç”¨å¦‚ä¸‹æ–¹å¼å¿«é€Ÿåˆå§‹åŒ–å“ˆå¸Œï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨å¯¹å°å®¹é‡çš„å“ˆå¸Œåšçš„ä¼˜åŒ–ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// makemap_small implements Go map creation for make(map[k]v) and
</span><span class="c1">// make(map[k]v, hint) when hint is known to be at most bucketCnt
</span><span class="c1">// at compile time and the map needs to be allocated on the heap.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>é™¤äº†ä¸Šè¿°ç‰¹å®šçš„ä¼˜åŒ–ä¹‹å¤–ï¼Œæ— è®º make æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Œåªè¦æˆ‘ä»¬ä½¿ç”¨ make åˆ›å»ºå“ˆå¸Œï¼ŒGo è¯­è¨€ç¼–è¯‘å™¨éƒ½ä¼šåœ¨ç±»å‹æ£€æŸ¥æœŸé—´å°†å®ƒä»¬è½¬æ¢æˆ <code>runtime.makemap</code>ï¼Œä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–å“ˆå¸Œä¹Ÿåªæ˜¯è¯­è¨€æä¾›çš„è¾…åŠ©å·¥å…·ï¼Œæœ€åè°ƒç”¨çš„éƒ½æ˜¯ <code>runtime.makemap</code>,ä¸»è¦åšçš„å·¥ä½œå°±æ˜¯åˆå§‹åŒ– hmap ç»“æ„ä½“çš„å„ç§å­—æ®µï¼Œä¾‹å¦‚è®¡ç®— B çš„å¤§å°ï¼Œè®¾ç½®å“ˆå¸Œç§å­ hash0 ç­‰ç­‰ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// makemap implements Go map creation for make(map[k]v, hint).
</span><span class="c1">// If the compiler has determined that the map or the first bucket
</span><span class="c1">// can be created on the stack, h and/or bucket may be non-nil.
</span><span class="c1">// If h != nil, the map can be created directly in h.
</span><span class="c1">// If h.buckets != nil, bucket pointed to can be used as the first bucket.
</span><span class="c1">// ä¼ å…¥çš„ä¸‰ä¸ªå‚æ•°åˆ†åˆ«ä¸º
</span><span class="c1">// 1.mapçš„ç±»å‹å³ keyå’Œvalueçš„ç±»å‹ä¿¡æ¯ç­‰å…¶ä»–æ•°æ®
</span><span class="c1">// 2.é•¿åº¦ å³ make ä¼ å…¥çš„len
</span><span class="c1">// 3.hmapç»“æ„ä½“ å¯ä»¥ä¸ºnil
</span><span class="c1">// è¿”å›å€¼ä¸ºç»è¿‡å¤„ç†çš„ *hmap
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="c1">// æ ¡éªŒä¸€ä¸‹éœ€æ±‚çš„é•¿åº¦å’Œç±»å‹å ç”¨å­—èŠ‚æ•°çš„ä¹˜ç§¯
</span><span class="c1"></span>  	<span class="c1">// æ˜¯å¦è¶…è¿‡å†…å­˜é™åˆ¶
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// initialize Hmap
</span><span class="c1"></span>	<span class="c1">// åˆ›å»ºä¸€ä¸ªæ–°çš„ hmapç»“æ„ä½“
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>

	<span class="c1">// Find the size parameter B which will hold the requested # of elements.
</span><span class="c1"></span>	<span class="c1">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.
</span><span class="c1"></span>	<span class="c1">// æ‰¾åˆ°ä¸€ä¸ª Bï¼Œä½¿å¾— map çš„è£…è½½å› å­åœ¨æ­£å¸¸èŒƒå›´å†…
</span><span class="c1"></span>	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// é€šè¿‡è¾“å…¥çš„é•¿åº¦ ç®—å‡ºä¸€ä¸ªåˆé€‚çš„Bå€¼
</span><span class="c1"></span>	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>

	<span class="c1">// åˆå§‹åŒ– hash table
</span><span class="c1"></span>	<span class="c1">// å¦‚æœ B ç­‰äº 0ï¼Œé‚£ä¹ˆ buckets å°±ä¼šåœ¨èµ‹å€¼çš„æ—¶å€™å†åˆ†é…
</span><span class="c1"></span>	<span class="c1">// å¦‚æœé•¿åº¦æ¯”è¾ƒå¤§ï¼Œåˆ†é…å†…å­˜ä¼šèŠ±è´¹é•¿ä¸€ç‚¹
</span><span class="c1"></span>	<span class="c1">// allocate initial hash table
</span><span class="c1"></span>	<span class="c1">// if B == 0, the buckets field is allocated lazily later (in mapassign)
</span><span class="c1"></span>	<span class="c1">// If hint is large zeroing this memory could take a while.
</span><span class="c1"></span>	<span class="c1">// å¦‚æœBä¸ä¸º0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
		<span class="c1">// è°ƒç”¨makeBucketArray è¿”å›ä¸€ä¸ªæº¢å‡ºbmapå’Œå¼€è¾Ÿå®Œå†…å­˜çš„æ¡¶çš„é¦–åœ°å€æŒ‡é’ˆ
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="c1">// å¦‚æœæœ‰æº¢å‡ºbmap
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>è¿™ä¸ªå‡½æ•°ä¼šæŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤æ‰§è¡Œï¼š</p>
<ol>
<li>è®¡ç®—å“ˆå¸Œå ç”¨çš„å†…å­˜æ˜¯å¦æº¢å‡ºæˆ–è€…è¶…å‡ºèƒ½åˆ†é…çš„æœ€å¤§å€¼ï¼›</li>
<li>è°ƒç”¨ runtime.fastrand è·å–ä¸€ä¸ªéšæœºçš„å“ˆå¸Œç§å­ï¼›</li>
<li>æ ¹æ®ä¼ å…¥çš„ hint è®¡ç®—å‡ºéœ€è¦çš„æœ€å°éœ€è¦çš„æ¡¶çš„æ•°é‡ï¼›</li>
<li>ä½¿ç”¨ runtime.makeBucketArray åˆ›å»ºç”¨äºä¿å­˜æ¡¶çš„æ•°ç»„ï¼›</li>
</ol>
<h3 id="makebucketarray">makeBucketArray<a hidden class="anchor" aria-hidden="true" href="#makebucketarray">#</a></h3>
<p><code>runtime.makeBucketArray</code> ä¼šæ ¹æ®ä¼ å…¥çš„ B è®¡ç®—å‡ºçš„éœ€è¦åˆ›å»ºçš„æ¡¶æ•°é‡å¹¶åœ¨å†…å­˜ä¸­åˆ†é…ä¸€ç‰‡è¿ç»­çš„ç©ºé—´ç”¨äºå­˜å‚¨æ•°æ®ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// æ±‚å‡ºéœ€è¦æ¡¶çš„ä¸ªæ•° å³è¿”å› 1&lt;&lt;Bçš„å€¼
</span><span class="c1"></span>	<span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span>
	<span class="c1">// å¦‚æœéœ€è¦çš„æ¡¶çš„ä¸ªæ•°å°äº4ä¸ª é‚£ä¹ˆå°±ä¸éœ€è¦åˆ›å»ºæº¢å‡ºbmap
</span><span class="c1"></span>  	<span class="c1">// ä¸ºçš„æ˜¯é˜²æ­¢æœ‰å¯èƒ½ä¸éœ€è¦bmapçš„æ—¶å€™å´åˆ›å»ºäº†bmap
</span><span class="c1"></span>  	<span class="c1">// ä½¿å…¶é™ä½èµ„æºå¼€é”€
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="c1">// åˆ›å»ºçš„æº¢å‡ºbmapçš„æ•°é‡æ˜¯1&lt;&lt;ï¼ˆB-4ï¼‰ä¸ª
</span><span class="c1"></span>    		<span class="c1">// è·å¾—æ‰€éœ€çš„æ¡¶ä¸æº¢å‡ºbmapçš„æ•°é‡
</span><span class="c1"></span>		<span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
		<span class="c1">// è®¡ç®—ç±»å‹ å ç”¨å­—èŠ‚æ•° * æ‰€éœ€çš„æ¡¶ä¸æº¢å‡ºbmapçš„æ•°é‡çš„ä¹˜ç§¯
</span><span class="c1"></span>		<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="c1">// è·å–å¯¹åº”é•¿åº¦çš„å†…å­˜å—çš„å¤§å°
</span><span class="c1"></span>		<span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span>
			<span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// åˆ†é…ä¸€ä¸ªnbuckets é•¿åº¦çš„bmapæ•°ç»„ è¿”å›é¦–æŒ‡é’ˆ
</span><span class="c1"></span>    	<span class="c1">// æ­£å¸¸æƒ…å†µä¸‹æ¡¶å’Œæº¢å‡ºbmapæ˜¯è¿ç»­çš„
</span><span class="c1"></span>    	<span class="c1">// ä½†æ˜¯å½“æº¢å‡ºbmapè¿‡å¤šçš„æ—¶å€™æ¯æ¬¡é€šè¿‡runtime.newobjectç”³è¯·çš„bmap
</span><span class="c1"></span>    	<span class="c1">// ä¸æœ€åˆåˆ›å»ºçš„ä¸ä¸€å®šæ˜¯è¿ç»­çš„äº†
</span><span class="c1"></span>	<span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>
	<span class="c1">// å¦‚æœåˆ›å»ºäº†æº¢å‡ºbmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
	<span class="c1">// è¿™é‡Œå–å·§äº†ä¸€ç‚¹ï¼Œé¢„å…ˆåˆ†é…çš„æº¢å‡ºæ¡¶çš„overflowéƒ½æ˜¯nil,æˆ‘ä»¬è¦æƒ³çŸ¥é“å“ªä¸ªæº¢å‡ºæ¡¶æ˜¯
</span><span class="c1"></span>        <span class="c1">// æœ€åä¸€ä¸ªï¼Œå¿…é¡»å¾—ç»™ä¸ªæ ‡è®°ï¼Œè¿™é‡Œå°†last.overflow = bucketsè¿›è¡Œèµ‹å€¼ï¼Œæ–¹ä¾¿
</span><span class="c1"></span>        <span class="c1">// åœ¨åˆ†é…overflowçš„æ—¶å€™èƒ½å¤Ÿé«˜æ•ˆçš„çŸ¥é“å·²ç»åˆ°äº†æº¢å‡ºæ¡¶çš„å°¾éƒ¨ã€‚
</span><span class="c1"></span>	<span class="c1">// å¦‚æœæœ‰æº¢å‡ºæ¡¶
</span><span class="c1"></span>    	<span class="c1">// å°±æŠŠæº¢å‡ºbmapè®¾ç½®ä¸ºç”³è¯·çš„bmapæ•°ç»„çš„ nbuckets-baseå¤„çš„é‚£ä¸ªå½“ä½œç©ºé—²æº¢å‡ºbmap
</span><span class="c1"></span>		<span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>å½“æ¡¶çš„æ•°é‡å°äº 2^4 æ—¶ï¼Œç”±äºæ•°æ®è¾ƒå°‘ã€ä½¿ç”¨æº¢å‡ºæ¡¶çš„å¯èƒ½æ€§è¾ƒä½ï¼Œä¼šçœç•¥åˆ›å»ºçš„è¿‡ç¨‹ä»¥å‡å°‘é¢å¤–å¼€é”€ï¼›</li>
<li>å½“æ¡¶çš„æ•°é‡å¤šäº 2^4 æ—¶ï¼Œä¼šé¢å¤–åˆ›å»º 2^(ğµâˆ’4) ä¸ªæº¢å‡ºæ¡¶ï¼›</li>
</ul>
<p>æ ¹æ®ä¸Šè¿°ä»£ç ï¼Œæˆ‘ä»¬èƒ½ç¡®å®šåœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ç©ºé—´æ˜¯è¿ç»­çš„ï¼Œåªæ˜¯è¢« <code>runtime.hmap</code> ä¸­çš„ä¸åŒå­—æ®µå¼•ç”¨ï¼Œå½“æº¢å‡ºæ¡¶æ•°é‡è¾ƒå¤šæ—¶ä¼šé€šè¿‡ runtime.newobject åˆ›å»ºæ–°çš„æº¢å‡ºæ¡¶ã€‚</p>
<h2 id="å“ˆå¸Œå®šä½">å“ˆå¸Œå®šä½<a hidden class="anchor" aria-hidden="true" href="#å“ˆå¸Œå®šä½">#</a></h2>
<p>map çš„ä¸€ä¸ªå…³é”®ç‚¹åœ¨äºï¼Œå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©ã€‚åœ¨ç¨‹åºå¯åŠ¨æ—¶ï¼Œä¼šæ£€æµ‹ cpu æ˜¯å¦æ”¯æŒ aesï¼Œå¦‚æœæ”¯æŒï¼Œåˆ™ä½¿ç”¨ aes hashï¼Œå¦åˆ™ä½¿ç”¨ memhashã€‚è¿™æ˜¯åœ¨å‡½æ•° <code>alginit()</code> ä¸­å®Œæˆï¼Œä½äºè·¯å¾„ï¼š<code>src/runtime/alg.go</code> ä¸‹ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">alginit</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Install AES hash algorithms if the instructions needed are present.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;386&#34;</span> <span class="o">||</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;amd64&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">cpu</span><span class="p">.</span><span class="nx">X86</span><span class="p">.</span><span class="nx">HasAES</span> <span class="o">&amp;&amp;</span> <span class="c1">// AESENC
</span><span class="c1"></span>		<span class="nx">cpu</span><span class="p">.</span><span class="nx">X86</span><span class="p">.</span><span class="nx">HasSSSE3</span> <span class="o">&amp;&amp;</span> <span class="c1">// PSHUFB
</span><span class="c1"></span>		<span class="nx">cpu</span><span class="p">.</span><span class="nx">X86</span><span class="p">.</span><span class="nx">HasSSE41</span> <span class="p">{</span> <span class="c1">// PINSR{D,Q}
</span><span class="c1"></span>		<span class="nf">initAlgAES</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;arm64&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">cpu</span><span class="p">.</span><span class="nx">ARM64</span><span class="p">.</span><span class="nx">HasAES</span> <span class="p">{</span>
		<span class="nf">initAlgAES</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">getRandomData</span><span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">hashkey</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">hashkey</span><span class="p">))[:])</span>
	<span class="nx">hashkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="c1">// make sure these numbers are odd
</span><span class="c1"></span>	<span class="nx">hashkey</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span>
	<span class="nx">hashkey</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span>
	<span class="nx">hashkey</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">initAlgAES</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">useAeshash</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="c1">// Initialize with random data so hash collisions will be hard to engineer.
</span><span class="c1"></span>	<span class="nf">getRandomData</span><span class="p">(</span><span class="nx">aeskeysched</span><span class="p">[:])</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>key ç»è¿‡å“ˆå¸Œè®¡ç®—åå¾—åˆ°å“ˆå¸Œå€¼ï¼Œå…± 64 ä¸ª bit ä½ï¼ˆ64ä½æœºï¼Œ32ä½æœºå°±ä¸è®¨è®ºäº†ï¼Œç°åœ¨ä¸»æµéƒ½æ˜¯64ä½æœºï¼‰ï¼Œè®¡ç®—å®ƒåˆ°åº•è¦è½åœ¨å“ªä¸ªæ¡¶æ—¶ï¼Œåªä¼šç”¨åˆ°æœ€å B ä¸ª bit ä½ã€‚è¿˜è®°å¾—å‰é¢æåˆ°è¿‡çš„ B å—ï¼Ÿå¦‚æœ B = 5ï¼Œé‚£ä¹ˆæ¡¶çš„æ•°é‡ï¼Œä¹Ÿå°±æ˜¯ buckets æ•°ç»„çš„é•¿åº¦æ˜¯ 2^5 = 32ã€‚</p>
<p>ä¾‹å¦‚ï¼Œç°åœ¨æœ‰ä¸€ä¸ª key ç»è¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—åï¼Œå¾—åˆ°çš„å“ˆå¸Œç»“æœæ˜¯ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">10010111</span> <span class="o">|</span> <span class="m">000011110110110010001111001010100010010110010101010</span> â”‚ <span class="m">01010</span>
</code></pre></td></tr></table>
</div>
</div><p>ç”¨æœ€åçš„ 5 ä¸ª bit ä½ï¼Œä¹Ÿå°±æ˜¯ 01010ï¼Œå€¼ä¸º 10ï¼Œä¹Ÿå°±æ˜¯ 10 å·æ¡¶ã€‚è¿™ä¸ªæ“ä½œå®é™…ä¸Šå°±æ˜¯å–ä½™æ“ä½œï¼Œä½†æ˜¯å–ä½™å¼€é”€å¤ªå¤§ï¼Œæ‰€ä»¥ä»£ç å®ç°ä¸Šç”¨çš„ä½æ“ä½œä»£æ›¿ã€‚</p>
<p>å†ç”¨å“ˆå¸Œå€¼çš„é«˜ 8 ä½ï¼Œæ‰¾åˆ°æ­¤ key åœ¨ bucket ä¸­çš„ä½ç½®ï¼Œè¿™æ˜¯åœ¨å¯»æ‰¾å·²æœ‰çš„ keyã€‚æœ€å¼€å§‹æ¡¶å†…è¿˜æ²¡æœ‰ keyï¼Œæ–°åŠ å…¥çš„ key ä¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºä½ï¼Œæ”¾å…¥ã€‚</p>
<p>buckets ç¼–å·å°±æ˜¯æ¡¶ç¼–å·ï¼Œå½“ä¸¤ä¸ªä¸åŒçš„ key è½åœ¨åŒä¸€ä¸ªæ¡¶ä¸­ï¼Œä¹Ÿå°±æ˜¯å‘ç”Ÿäº†å“ˆå¸Œå†²çªã€‚å†²çªçš„è§£å†³æ‰‹æ®µæ˜¯ç”¨é“¾è¡¨æ³•ï¼šåœ¨ bucket ä¸­ï¼Œä»å‰å¾€åæ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºä½ã€‚è¿™æ ·ï¼Œåœ¨æŸ¥æ‰¾æŸä¸ª key æ—¶ï¼Œå…ˆæ‰¾åˆ°å¯¹åº”çš„æ¡¶ï¼Œå†å»éå† bucket ä¸­çš„ keyã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703115758.png" alt=""  />
</p>
<p>ä¸Šå›¾ä¸­ï¼Œå‡å®š B = 5ï¼Œæ‰€ä»¥ bucket æ€»æ•°å°±æ˜¯ 2^5 = 32ã€‚é¦–å…ˆè®¡ç®—å‡ºå¾…æŸ¥æ‰¾ key çš„å“ˆå¸Œï¼Œä½¿ç”¨ä½ 5 ä½ 00110ï¼Œæ‰¾åˆ°å¯¹åº”çš„ 6 å· bucketï¼Œä½¿ç”¨é«˜ 8 ä½ 10010111ï¼Œå¯¹åº”åè¿›åˆ¶ 151ï¼Œåœ¨ 6 å· bucket ä¸­å¯»æ‰¾ tophash å€¼ï¼ˆHOB hashï¼‰ä¸º 151 çš„ keyï¼Œæ‰¾åˆ°äº† 2 å·æ§½ä½ï¼Œè¿™æ ·æ•´ä¸ªæŸ¥æ‰¾è¿‡ç¨‹å°±ç»“æŸäº†ã€‚</p>
<p>å¦‚æœåœ¨ bucket ä¸­æ²¡æ‰¾åˆ°ï¼Œå¹¶ä¸” overflow ä¸ä¸ºç©ºï¼Œè¿˜è¦ç»§ç»­å» overflow bucket ä¸­å¯»æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æˆ–æ˜¯æ‰€æœ‰çš„ key æ§½ä½éƒ½æ‰¾éäº†ï¼ŒåŒ…æ‹¬æ‰€æœ‰çš„ overflow bucketã€‚</p>
<h2 id="mapaccess">mapaccess<a hidden class="anchor" aria-hidden="true" href="#mapaccess">#</a></h2>
<p>åœ¨ç¼–è¯‘çš„ç±»å‹æ£€æŸ¥æœŸé—´ï¼Œ<code>hash[key]</code> ä»¥åŠç±»ä¼¼çš„æ“ä½œéƒ½ä¼šè¢«è½¬æ¢æˆå“ˆå¸Œçš„ OINDEXMAP æ“ä½œï¼Œä¸­é—´ä»£ç ç”Ÿæˆé˜¶æ®µä¼šåœ¨ <code>cmd/compile/internal/gc.walkexpr</code> å‡½æ•°ä¸­å°†è¿™äº› OINDEXMAP æ“ä½œè½¬æ¢æˆå¦‚ä¸‹çš„ä»£ç ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">v</span>     <span class="o">:=</span> <span class="n">hash[key]</span> <span class="o">//</span> <span class="o">=&gt;</span> <span class="n">v</span>     <span class="o">:=</span> <span class="o">*</span><span class="nf">mapaccess1</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">hash[key]</span> <span class="o">//</span> <span class="o">=&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="nf">mapaccess2</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>èµ‹å€¼è¯­å¥å·¦ä¾§æ¥å—å‚æ•°çš„ä¸ªæ•°ä¼šå†³å®šä½¿ç”¨çš„è¿è¡Œæ—¶æ–¹æ³•ï¼š</p>
<ul>
<li>å½“æ¥å—ä¸€ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ <code>runtime.mapaccess1</code>ï¼Œè¯¥å‡½æ•°ä»…ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ç›®æ ‡å€¼çš„æŒ‡é’ˆï¼›</li>
<li>å½“æ¥å—ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ <code>runtime.mapaccess2</code>ï¼Œé™¤äº†è¿”å›ç›®æ ‡å€¼ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šè¿”å›ä¸€ä¸ªç”¨äºè¡¨ç¤ºå½“å‰é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨çš„ bool å€¼ï¼š</li>
</ul>
<p>å¦å¤–ï¼Œæ ¹æ® key çš„ä¸åŒç±»å‹ï¼Œç¼–è¯‘å™¨è¿˜ä¼šå°†æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„å‡½æ•°ç”¨æ›´å…·ä½“çš„å‡½æ•°æ›¿æ¢ï¼Œä»¥ä¼˜åŒ–æ•ˆç‡ï¼š</p>
<table>
<thead>
<tr>
<th>key ç±»å‹</th>
<th>æŸ¥æ‰¾</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32</td>
<td>mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td>uint32</td>
<td>mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td>uint64</td>
<td>mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td>uint64</td>
<td>mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td>string</td>
<td>mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
</tr>
<tr>
<td>string</td>
<td>mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)</td>
</tr>
</tbody>
</table>
<p>è¿™äº›å‡½æ•°çš„å‚æ•°ç±»å‹ç›´æ¥æ˜¯å…·ä½“çš„ uint32ã€unt64ã€stringï¼Œåœ¨å‡½æ•°å†…éƒ¨ç”±äºæå‰çŸ¥æ™“äº† key çš„ç±»å‹ï¼Œæ‰€ä»¥å†…å­˜å¸ƒå±€æ˜¯å¾ˆæ¸…æ¥šçš„ï¼Œå› æ­¤èƒ½èŠ‚çœå¾ˆå¤šæ“ä½œï¼Œæé«˜æ•ˆç‡ã€‚</p>
<p>ä¸Šé¢è¿™äº›å‡½æ•°éƒ½æ˜¯åœ¨æ–‡ä»¶ src/runtime/hashmap_fast.go é‡Œã€‚</p>
<h3 id="mapaccess1">mapaccess1<a hidden class="anchor" aria-hidden="true" href="#mapaccess1">#</a></h3>
<p><code>runtime.mapaccess1</code> ä¼šå…ˆé€šè¿‡å“ˆå¸Œè¡¨è®¾ç½®çš„å“ˆå¸Œå‡½æ•°ã€ç§å­è·å–å½“å‰é”®å¯¹åº”çš„å“ˆå¸Œï¼Œå†é€šè¿‡ <code>runtime.bucketMask</code> å’Œ <code>runtime.add</code> æ‹¿åˆ°è¯¥é”®å€¼å¯¹æ‰€åœ¨çš„æ¡¶åºå·å’Œå“ˆå¸Œé«˜ä½çš„ 8 ä½æ•°å­—ã€‚</p>
<p>mapçš„è¯»å–å¤§æ¦‚å°±æ˜¯ä»¥ä¸‹å‡ æ­¥ï¼š</p>
<ol>
<li>nilçš„Mapæˆ–è€…len==0çš„Mapç›´æ¥è¿”å›å¯¹åº”ç±»å‹é›¶å€¼</li>
<li>å¦‚æœå½“å‰å¤„äºç¿»å€æ‰©å®¹çŠ¶æ€ä¸”å½“å‰keyçš„hashå¯¹åº”çš„æ¡¶è¿˜æ²¡æ¬è¿å®Œï¼Œé‚£ä¹ˆå°±åœ¨æ—§æ¡¶é‡Œæ‰¾å¯¹åº”çš„é‚£ä¸ªæ¡¶å»æ‰¾å¯¹åº”çš„key-value</li>
<li>è·Ÿå†™å…¥ä¸€æ · éå†æ¡¶åŠå…¶æº¢å‡ºæ¡¶</li>
<li>æ‰¾åˆ°äº†è¿”å›å€¼ï¼Œæ²¡æ‰¾åˆ°è¿”å›è¿”å›å¯¹åº”ç±»å‹é›¶å€¼</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead
</span><span class="c1">// it will return a reference to the zero object for the elem type if
</span><span class="c1">// the key is not in the map.
</span><span class="c1">// NOTE: The returned pointer may keep the whole map live, so don&#39;t
</span><span class="c1">// hold onto it for very long.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapaccess1</span><span class="p">)</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// mapä¸ºç©ºæˆ–è€…å…ƒç´ æ•°é‡ä¸º0æ—¶å¿«é€Ÿè¿”å›
</span><span class="c1"></span>	<span class="c1">// å¦‚æœ h ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œè¿”å›é›¶å€¼
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// åŒå†™å…¥
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="c1">// å†™å’Œè¯»å†²çª
</span><span class="c1"></span>	<span class="c1">// åœ¨è¿™é‡Œåšå¹¶å‘åˆ¤æ–­ï¼Œæ£€æµ‹åˆ°å¹¶å‘å†™æ—¶ï¼ŒæŠ›å¼‚å¸¸
</span><span class="c1"></span>	<span class="c1">// æ³¨æ„ï¼šgo mapçš„å¹¶å‘æ£€æµ‹æ˜¯ä¼ªæ£€æµ‹ï¼Œå¹¶ä¸ä¿è¯æ‰€æœ‰çš„å¹¶å‘éƒ½ä¼šè¢«æ£€æµ‹å‡ºæ¥ã€‚è€Œä¸”è¿™ç©æ„æ˜¯åœ¨è¿è¡ŒæœŸæ£€æµ‹ã€‚
</span><span class="c1"></span>	<span class="c1">// æ‰€ä»¥å¯¹mapæœ‰å¹¶å‘è¦æ±‚æ—¶ï¼Œåº”ä½¿ç”¨sync.mapæ¥ä»£æ›¿æ™®é€šmapï¼Œé€šè¿‡åŠ é”æ¥é˜»æ–­å¹¶å‘å†²çª
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// è®¡ç®—å“ˆå¸Œå€¼ï¼Œå¹¶ä¸”åŠ å…¥ hash0 å¼•å…¥éšæœºæ€§
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="c1">// æ¯”å¦‚ B=5ï¼Œé‚£ m å°±æ˜¯31ï¼ŒäºŒè¿›åˆ¶æ˜¯å…¨ 1
</span><span class="c1"></span>	<span class="c1">// æ±‚ bucket num æ—¶ï¼Œå°† hash ä¸ m ç›¸ä¸ï¼Œ
</span><span class="c1"></span>	<span class="c1">// è¾¾åˆ° bucket num ç”± hash çš„ä½ 8 ä½å†³å®šçš„æ•ˆæœ
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// b å°±æ˜¯ bucket çš„åœ°å€
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// oldbuckets ä¸ä¸º nilï¼Œè¯´æ˜å‘ç”Ÿäº†æ‰©å®¹
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// å¦‚æœä¸æ˜¯åŒ size æ‰©å®¹ï¼ˆçœ‹åé¢æ‰©å®¹çš„å†…å®¹ï¼‰
</span><span class="c1"></span>	    	<span class="c1">// å¯¹åº”æ¡ä»¶ 1 çš„è§£å†³æ–¹æ¡ˆ
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span><span class="c1"></span>			<span class="c1">// æ–° bucket æ•°é‡æ˜¯è€çš„ 2 å€
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="c1">// æ±‚å‡º key åœ¨è€çš„ map ä¸­çš„ bucket ä½ç½®
</span><span class="c1"></span>		<span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="c1">// å¦‚æœ oldb æ²¡æœ‰æ¬è¿åˆ°æ–°çš„ bucket
</span><span class="c1"></span>		<span class="c1">// é‚£å°±åœ¨è€çš„ bucket ä¸­å¯»æ‰¾
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// å¤„äºæ‰©å®¹è¿‡ç¨‹ä¸­ï¼Œåº”è¯¥ä»oldbucketsä¸­å»è·å–æ•°æ®
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// è®¡ç®—å‡ºé«˜ 8 ä½çš„ hash
</span><span class="c1"></span>	<span class="c1">// ç›¸å½“äºå³ç§» 56 ä½ï¼Œåªå–é«˜8ä½
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="c1">// éå†æ¡¶å’Œå…¶æº¢å‡ºæ¡¶
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//éå†æ¡¶çš„tophash
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			 <span class="c1">// tophash ä¸åŒ¹é…ï¼Œç»§ç»­
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="c1">// æå‰è¿”å›ï¼ŒemptyRestè¡¨ç¤ºåœ¨å®ƒä¹‹åä¸ä¼šå­˜åœ¨éç©ºå€¼
</span><span class="c1"></span>					<span class="c1">// å½“å‰bucketå†…æ‰¾å®Œï¼ˆè¿˜æ²¡æ‰¾åˆ°ï¼‰ï¼Œç»§ç»­åˆ° overflow bucket é‡Œæ‰¾
</span><span class="c1"></span>					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// tophash åŒ¹é…ï¼Œå®šä½åˆ° key çš„ä½ç½®
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="c1">// key æ˜¯æŒ‡é’ˆ
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// è§£å¼•ç”¨
</span><span class="c1"></span>				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// å¦‚æœ key ç›¸ç­‰
</span><span class="c1"></span>			<span class="c1">// é˜²æ­¢ä»…topä½ç›¸åŒçš„hashå†²çª
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// å®šä½åˆ° value çš„ä½ç½®
</span><span class="c1"></span>				<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="c1">// value è§£å¼•ç”¨
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// overflow bucket ä¹Ÿæ‰¾å®Œäº†ï¼Œè¯´æ˜æ²¡æœ‰ç›®æ ‡ key
</span><span class="c1"></span>	<span class="c1">// è¿”å›é›¶å€¼
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>
<span class="c1">// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="c1">// bucketShift returns 1&lt;&lt;b, optimized for code generation.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="c1">// Masking the shift amount allows overflow checks to be elided.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">)</span> <span class="o">*</span><span class="nx">bmap</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span><span class="o">-</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>åœ¨ <code>bucketloop</code> å¾ªç¯ä¸­ï¼Œå“ˆå¸Œä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­çš„æ•°æ®ï¼Œå®ƒä¼šå…ˆæ¯”è¾ƒå“ˆå¸Œçš„é«˜ 8 ä½å’Œæ¡¶ä¸­å­˜å‚¨çš„ <code>tophash</code>ï¼Œåæ¯”è¾ƒä¼ å…¥çš„å’Œæ¡¶ä¸­çš„å€¼ä»¥åŠ é€Ÿæ•°æ®çš„è¯»å†™ã€‚ç”¨äºé€‰æ‹©æ¡¶åºå·çš„æ˜¯å“ˆå¸Œçš„æœ€ä½å‡ ä½ï¼Œè€Œç”¨äºåŠ é€Ÿè®¿é—®çš„æ˜¯å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œè¿™ç§è®¾è®¡èƒ½å¤Ÿå‡å°‘åŒä¸€ä¸ªæ¡¶ä¸­æœ‰å¤§é‡ç›¸ç­‰ tophash çš„æ¦‚ç‡å½±å“æ€§èƒ½ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702145553.png" alt=""  />
</p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¯ä¸€ä¸ªæ¡¶éƒ½æ˜¯ä¸€æ•´ç‰‡çš„å†…å­˜ç©ºé—´ï¼Œå½“å‘ç°æ¡¶ä¸­çš„ tophash ä¸ä¼ å…¥é”®çš„ tophash åŒ¹é…ä¹‹åï¼Œæˆ‘ä»¬ä¼šé€šè¿‡æŒ‡é’ˆå’Œåç§»é‡è·å–å“ˆå¸Œä¸­å­˜å‚¨çš„é”® <code>keys[0]</code> å¹¶ä¸ <code>key</code> æ¯”è¾ƒï¼Œå¦‚æœä¸¤è€…ç›¸åŒå°±ä¼šè·å–ç›®æ ‡å€¼çš„æŒ‡é’ˆ <code>values[0]</code> å¹¶è¿”å›ã€‚</p>
<p>å¦‚æœ h ä¸­æ²¡æœ‰æ­¤ keyï¼Œé‚£å°±ä¼šè¿”å›ä¸€ä¸ª key ç›¸åº”ç±»å‹çš„é›¶å€¼ï¼Œä¸ä¼šè¿”å› nilã€‚</p>
<p>è¿™é‡Œï¼Œè¯´ä¸€ä¸‹å®šä½ key å’Œ value çš„æ–¹æ³•ä»¥åŠæ•´ä¸ªå¾ªç¯çš„å†™æ³•ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// key å®šä½å…¬å¼
</span><span class="c1"></span><span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>

<span class="c1">// value å®šä½å…¬å¼
</span><span class="c1"></span><span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>b æ˜¯ bmap çš„åœ°å€ï¼Œè¿™é‡Œ bmap è¿˜æ˜¯æºç é‡Œå®šä¹‰çš„ç»“æ„ä½“ï¼ŒåªåŒ…å«ä¸€ä¸ª tophash æ•°ç»„ï¼Œç»ç¼–è¯‘å™¨æ‰©å……ä¹‹åçš„ç»“æ„ä½“æ‰åŒ…å« keyï¼Œvalueï¼Œoverflow è¿™äº›å­—æ®µã€‚dataOffset æ˜¯ key ç›¸å¯¹äº bmap èµ·å§‹åœ°å€çš„åç§»ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">dataOffset</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="nx">bmap</span>
		<span class="nx">v</span> <span class="kt">int64</span>
	<span class="p">}{}.</span><span class="nx">v</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>å› æ­¤ bucket é‡Œ key çš„èµ·å§‹åœ°å€å°±æ˜¯ <code>unsafe.Pointer(b)+dataOffset</code>ã€‚ç¬¬ i ä¸ª key çš„åœ°å€å°±è¦åœ¨æ­¤åŸºç¡€ä¸Šè·¨è¿‡ i ä¸ª key çš„å¤§å°ï¼›è€Œæˆ‘ä»¬åˆçŸ¥é“ï¼Œvalue çš„åœ°å€æ˜¯åœ¨æ‰€æœ‰ key ä¹‹åï¼Œå› æ­¤ç¬¬ i ä¸ª value çš„åœ°å€è¿˜éœ€è¦åŠ ä¸Šæ‰€æœ‰ key çš„åç§»ã€‚ç†è§£äº†è¿™äº›ï¼Œä¸Šé¢ key å’Œ value çš„å®šä½å…¬å¼å°±å¾ˆå¥½ç†è§£äº†ã€‚</p>
<p>å†è¯´æ•´ä¸ªå¤§å¾ªç¯çš„å†™æ³•ï¼Œæœ€å¤–å±‚æ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œé€šè¿‡</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>éå†æ‰€æœ‰çš„ bucketï¼Œè¿™ç›¸å½“äºæ˜¯ä¸€ä¸ª bucket é“¾è¡¨ã€‚</p>
<p>å½“å®šä½åˆ°ä¸€ä¸ªå…·ä½“çš„ bucket æ—¶ï¼Œé‡Œå±‚å¾ªç¯å°±æ˜¯éå†è¿™ä¸ª bucket é‡Œæ‰€æœ‰çš„ cellï¼Œæˆ–è€…è¯´æ‰€æœ‰çš„æ§½ä½ï¼Œä¹Ÿå°±æ˜¯ bucketCnt=8 ä¸ªæ§½ä½ã€‚æ•´ä¸ªå¾ªç¯è¿‡ç¨‹ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703131153.png" alt=""  />
</p>
<h4 id="tophash">tophash<a hidden class="anchor" aria-hidden="true" href="#tophash">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// tophash calculates the tophash value for hash.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uint8</span> <span class="p">{</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
		<span class="nx">top</span> <span class="o">+=</span> <span class="nx">minTopHash</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">top</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>å½“ä¸€ä¸ª cell çš„ tophash å€¼å°äº minTopHash æ—¶ï¼Œæ ‡å¿—è¿™ä¸ª cell çš„è¿ç§»çŠ¶æ€ã€‚å› ä¸ºè¿™ä¸ªçŠ¶æ€å€¼æ˜¯æ”¾åœ¨ tophash æ•°ç»„é‡Œï¼Œä¸ºäº†å’Œæ­£å¸¸çš„å“ˆå¸Œå€¼åŒºåˆ†å¼€ï¼Œä¼šç»™ key è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ä¸€ä¸ªå¢é‡ï¼šminTopHashã€‚è¿™æ ·å°±èƒ½åŒºåˆ†æ­£å¸¸çš„ top hash å€¼å’Œè¡¨ç¤ºçŠ¶æ€çš„å“ˆå¸Œå€¼ã€‚</p>
<p>ä¸‹é¢çš„è¿™å‡ ç§çŠ¶æ€å°±è¡¨å¾äº† bucket çš„æƒ…å†µï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// Possible tophash values. We reserve a few possibilities for special marks.
</span><span class="c1"></span>	<span class="c1">// Each bucket (including its overflow buckets, if any) will have either all or none of its
</span><span class="c1"></span>	<span class="c1">// entries in the evacuated* states (except during the evacuate() method, which only happens
</span><span class="c1"></span>	<span class="c1">// during map writes and thus no one else can observe the map during that time).
</span><span class="c1"></span>	<span class="c1">// tophashå¯¹åº”çš„ä½ç½®ä¸ºç©ºï¼Œå¹¶ä¸”åç»­æ²¡æœ‰éç©ºçš„å€¼
</span><span class="c1"></span>	<span class="nx">emptyRest</span>      <span class="p">=</span> <span class="mi">0</span> <span class="c1">// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.
</span><span class="c1"></span>	<span class="c1">// tophashå¯¹åº”çš„ä½ç½®ä¸ºç©ºï¼Œå…ƒç´ è¢«åˆ é™¤åå¯èƒ½çš„æ ‡è®°å€¼
</span><span class="c1"></span>	<span class="nx">emptyOne</span>       <span class="p">=</span> <span class="mi">1</span> <span class="c1">// this cell is empty
</span><span class="c1"></span>	<span class="c1">// key/valueæ˜¯æ— æ•ˆçš„ï¼Œå€¼è¢«è¿ç§»åˆ°æ–°tableçš„å‰åŠæ®µ
</span><span class="c1"></span>	<span class="nx">evacuatedX</span>     <span class="p">=</span> <span class="mi">2</span> <span class="c1">// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span><span class="c1"></span>	<span class="c1">// key/valueæ˜¯æ— æ•ˆçš„ï¼Œå€¼è¢«è¿ç§»åˆ°æ–°tableçš„ååŠæ®µ
</span><span class="c1"></span>	<span class="nx">evacuatedY</span>     <span class="p">=</span> <span class="mi">3</span> <span class="c1">// same as above, but evacuated to second half of larger table.
</span><span class="c1"></span>	<span class="c1">// tophashå¯¹åº”çš„å€¼ä¸ºç©ºï¼Œä½†æ˜¯è¡¨ç¤ºæ­£åœ¨è¿ç§»ä¸­
</span><span class="c1"></span>	<span class="nx">evacuatedEmpty</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// cell is empty, bucket is evacuated.
</span><span class="c1"></span>	<span class="c1">// ä¸€ä¸ªä¸´ç•Œå€¼ï¼Œå‰é¢æ‰€æœ‰çš„å€¼éƒ½ä»£è¡¨ä¸€ä¸ªç‰¹æ®Šçš„å«ä¹‰ï¼Œæ‰€ä»¥å½“top&lt;5æ—¶ï¼Œtop+=5
</span><span class="c1"></span>	<span class="nx">minTopHash</span>     <span class="p">=</span> <span class="mi">5</span> <span class="c1">// minimum tophash for a normal filled cell.
</span></code></pre></td></tr></table>
</div>
</div><p>æºç é‡Œåˆ¤æ–­è¿™ä¸ª bucket æ˜¯å¦å·²ç»æ¬è¿å®Œæ¯•ï¼Œç”¨åˆ°çš„å‡½æ•°ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">h</span> <span class="p">&gt;</span> <span class="nx">emptyOne</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>åªå–äº† tophash æ•°ç»„çš„ç¬¬ä¸€ä¸ªå€¼ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦åœ¨ 2-4 ä¹‹é—´ã€‚å¯¹æ¯”ä¸Šé¢çš„å¸¸é‡ï¼Œå½“ top hash æ˜¯ evacuatedEmptyã€evacuatedXã€evacuatedY è¿™ä¸‰ä¸ªå€¼ä¹‹ä¸€ï¼Œè¯´æ˜æ­¤ bucket ä¸­çš„ key å…¨éƒ¨è¢«æ¬è¿åˆ°äº†æ–° bucketã€‚</p>
<h3 id="mapaccess2">mapaccess2<a hidden class="anchor" aria-hidden="true" href="#mapaccess2">#</a></h3>
<p>å¦ä¸€ä¸ªåŒæ ·ç”¨äºè®¿é—®å“ˆå¸Œè¡¨ä¸­æ•°æ®çš„ <code>runtime.mapaccess2</code> åªæ˜¯åœ¨ <code>runtime.mapaccess1</code> çš„åŸºç¡€ä¸Šå¤šè¿”å›äº†ä¸€ä¸ªæ ‡è¯†é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨çš„ bool å€¼ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapaccess2</span><span class="p">)</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">e</span><span class="p">,</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ä½¿ç”¨ <code>v, ok := hash[k]</code> çš„å½¢å¼è®¿é—®å“ˆå¸Œè¡¨ä¸­å…ƒç´ æ—¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡è¿™ä¸ªå¸ƒå°”å€¼æ›´å‡†ç¡®åœ°çŸ¥é“å½“ <code>v == nil</code> æ—¶ï¼Œv åˆ°åº•æ˜¯å“ˆå¸Œä¸­å­˜å‚¨çš„å…ƒç´ è¿˜æ˜¯è¡¨ç¤ºè¯¥é”®å¯¹åº”çš„å…ƒç´ ä¸å­˜åœ¨ï¼Œæ‰€ä»¥åœ¨è®¿é—®å“ˆå¸Œæ—¶ï¼Œæ›´æ¨èä½¿ç”¨è¿™ç§æ–¹å¼åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨ã€‚</p>
<h2 id="mapassign">mapassign<a hidden class="anchor" aria-hidden="true" href="#mapassign">#</a></h2>
<p>é€šè¿‡æ±‡ç¼–è¯­è¨€å¯ä»¥çœ‹åˆ°ï¼Œå‘ map ä¸­æ’å…¥æˆ–è€…ä¿®æ”¹ keyï¼Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯ mapassign å‡½æ•°ã€‚</p>
<p>å®é™…ä¸Šæ’å…¥æˆ–ä¿®æ”¹ key çš„è¯­æ³•æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡å‰è€…æ“ä½œçš„ key åœ¨ map ä¸­ä¸å­˜åœ¨ï¼Œè€Œåè€…æ“ä½œçš„ key å­˜åœ¨ map ä¸­ã€‚</p>
<p>mapassign æœ‰ä¸€ä¸ªç³»åˆ—çš„å‡½æ•°ï¼Œæ ¹æ® key ç±»å‹çš„ä¸åŒï¼Œç¼–è¯‘å™¨ä¼šå°†å…¶ä¼˜åŒ–ä¸ºç›¸åº”çš„â€œå¿«é€Ÿå‡½æ•°â€ã€‚</p>
<table>
<thead>
<tr>
<th>key</th>
<th>ç±»å‹</th>
<th>æ’å…¥</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32</td>
<td>mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td>mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
<td></td>
</tr>
</tbody>
</table>
<p>æˆ‘ä»¬åªç”¨ç ”ç©¶æœ€ä¸€èˆ¬çš„èµ‹å€¼å‡½æ•° mapassignã€‚</p>
<p>Mapå†™å…¥æ“ä½œè¿‡ç¨‹:</p>
<ol>
<li>é¦–å…ˆä¼šè®¡ç®—å‡ºä¼ å…¥Keyçš„å“ˆå¸Œï¼Œå…¶ä½Bä½ç”¨äºé€‰æ‹©å¯¹åº”çš„bmapï¼Œå…¶å“ˆå¸Œå€¼çš„é«˜8ä½ç”¨äºåœ¨å¯¹åº”çš„bmapä¸­å¿«é€Ÿçš„æŸ¥æ‰¾æ˜¯å¦æœ‰æ­¤keyçš„å­˜åœ¨ï¼Œå¹¶ä¸”å¯¹è¯¥mapæ‰“ä¸Šå†™æ ‡è®°ï¼Œé˜²æ­¢å¹¶å‘è¯»å†™ã€‚</li>
<li>éå†æ‰¾åˆ°çš„bmapåŠå…¶æº¢å‡ºbmapï¼Œå¹¶æŒ‰ç…§ä¸‹é¢çš„æ¡ä»¶æ‰§è¡Œ
<ol>
<li>å¦‚æœæ¯”è¾ƒåˆ°å½“å‰çš„tophashä¸ç­‰äºä¼ å…¥keyçš„tophashï¼Œä¸”æœªæ‰¾åˆ°å¯ç”¨tophashåœ°å€æ—¶ï¼Œå¦‚æœå½“å‰tophashæ— å·²å­˜æ”¾çš„keyï¼Œé‚£ä¹ˆè®°å½•ä¸‹è¿™ä¸ªtophashçš„åœ°å€å’Œå…¶å¯¹åº”çš„kï¼Œvçš„åœ°å€ï¼Œæ­¤æ¡ä»¶ä¸ºæ’å…¥æ“ä½œã€‚</li>
<li>å¦‚æœå½“å‰tophashæ˜¯emptyRestï¼Œåˆ™ä»£è¡¨åç»­æ²¡æœ‰æº¢å‡ºbmapæˆ–è€…å¯éå†çš„tophashäº†</li>
<li>å¦‚æœå½“å‰çš„tophash==ä¼ å…¥keyçš„tophashï¼Œåˆ™ä¼šå¯¹æ¯”ä¼ å…¥çš„Keyä»¥åŠtophashå¯¹åº”çš„Keyçš„åœ°å€çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰åˆ™ä»£è¡¨å·²ç»å­˜åœ¨äº†å½“å‰ä¼ å…¥çš„Keyï¼Œåˆ™æ­¤æ“ä½œä¸ºæ›´æ–°æ“ä½œï¼Œæ­¤æ—¶è®¡ç®—å‡ºå¯¹åº”valueçš„å­˜æ”¾åœ°å€</li>
<li>å¦‚æœä¸Šè¿°æ¡ä»¶éƒ½ä¸æ»¡è¶³åˆ™éå†æº¢å‡ºbmapï¼ˆå¦‚æœæœ‰ï¼‰</li>
</ol>
</li>
<li>å¦‚æœåœ¨bmapåŠå…¶æº¢å‡ºbmapä¸­éƒ½æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å­˜æ”¾åœ°å€ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„æº¢å‡ºbmapï¼Œå› ä¸ºæ²¡æ‰¾åˆ°è¯´æ˜æ²¡æœ‰å¯ç”¨çš„tophashä½ç½®äº†ï¼Œå³æ‰€æœ‰çš„bmapéƒ½æ»¡äº†ã€‚</li>
<li>å¦‚æœç¬¦åˆä¸‹åˆ—æ‰©å®¹æ¡ä»¶å°±ä¼šäº§ç”Ÿæ‰©å®¹ï¼Œæ‰©å®¹å®Œæ¯•åé‡æ–°å¼€å§‹ åºå·2 çš„è¿‡ç¨‹ã€‚
<ol>
<li>å½“è£…è½½å› å­&gt;=6.5</li>
<li>æº¢å‡ºbmapè¿‡å¤šï¼Œè¯¥æƒ…å†µåªä¼šå‡ºç°åœ¨å…ˆå¤§é‡çš„å†™ç„¶åå†å¤§é‡åˆ é™¤ä½†è£…è½½å› å­å¹¶æ²¡æœ‰&gt;=6.5çš„æƒ…å†µ</li>
</ol>
</li>
<li>å¦‚æœä¸éœ€è¦æ‰©å®¹åˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„bmapï¼Œç»™ä¼ å…¥Keyçš„å“ˆå¸Œï¼Œå…¶ä½Bä½ç”¨äºé€‰æ‹©å¯¹åº”çš„bmapçš„æº¢å‡ºbmapé“¾è¡¨å°¾éƒ¨ï¼Œç„¶åè·å¾—å¯ç”¨çš„tophashï¼Œkeyï¼Œvalueåœ°å€ã€‚ç„¶åå–æ¶ˆå†™æ ‡è®°ï¼Œè¿”å›å¯ç”¨çš„value å­˜æ”¾åœ°å€ ï¼Œ éšåçš„èµ‹å€¼æ“ä½œä¼šåœ¨æ±‡ç¼–ä¸­è¿›è¡Œ</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Like mapaccess, but allocates a slot for the key if it is not present in the map.
</span><span class="c1">// è¯¥å‡½æ•°ä¼ å…¥çš„å‚æ•°åˆ†åˆ«ä¸º
</span><span class="c1">// 1.mapçš„ç±»å‹å³ keyå’Œvalueçš„ç±»å‹ä¿¡æ¯ç­‰å…¶ä»–æ•°æ®
</span><span class="c1">// 2.é‚£ä¸ªmap
</span><span class="c1">// 3.keyæ‰€åœ¨å†…å­˜çš„åœ°å€
</span><span class="c1">// è¿”å›çš„å‚æ•°ä¸º
</span><span class="c1">// 1.æ‰¾åˆ°çš„å¯ç”¨çš„å¯å­˜å‚¨valueçš„å†…å­˜åœ°å€
</span><span class="c1">// è¿”å›åå…·ä½“çš„èµ‹å€¼æ“ä½œç”±æ±‡ç¼–å®Œæˆ
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">//åˆ¤æ–­ hmap æ˜¯å¦å·²ç»åˆå§‹åŒ–ï¼ˆæ˜¯å¦ä¸º nilï¼‰
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapassign</span><span class="p">)</span>
		<span class="nf">racewritepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//åˆ¤æ–­æ˜¯å¦å¹¶å‘è¯»å†™ mapï¼Œè‹¥æ˜¯åˆ™æŠ›å‡ºå¼‚å¸¸
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// æ±‚å‡ºè¿™ä¸ªkeyçš„å“ˆå¸Œå€¼
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="c1">// å‡½æ•°é¦–å…ˆä¼šæ£€æŸ¥ map çš„æ ‡å¿—ä½ flagsã€‚å¦‚æœ flags çš„å†™æ ‡å¿—ä½æ­¤æ—¶è¢«ç½® 1 äº†ï¼Œè¯´æ˜æœ‰å…¶ä»–åç¨‹åœ¨æ‰§è¡Œâ€œå†™â€æ“ä½œï¼Œè¿›è€Œå¯¼è‡´ç¨‹åº panicã€‚è¿™ä¹Ÿè¯´æ˜äº† map å¯¹åç¨‹æ˜¯ä¸å®‰å…¨çš„ã€‚
</span><span class="c1"></span>	<span class="c1">// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span><span class="c1"></span>	<span class="c1">// in which case we have not actually done a write.
</span><span class="c1"></span>	<span class="c1">// è®¾ç½® flags æ ‡å¿—ä½ï¼Œè¡¨ç¤ºæœ‰ä¸€ä¸ª goroutine æ­£åœ¨å†™å…¥æ•°æ®ã€‚å› ä¸º alg.hash æœ‰å¯èƒ½å‡ºç° panic å¯¼è‡´å¼‚å¸¸
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// åˆ¤æ–­ buckets æ˜¯å¦ä¸º nilï¼Œè‹¥æ˜¯åˆ™è°ƒç”¨ newobject æ ¹æ®å½“å‰ bucket å¤§å°è¿›è¡Œåˆ†é…
</span><span class="c1"></span>    	<span class="c1">// åˆå§‹åŒ–æ—¶æ²¡æœ‰åˆå§‹ bucketsï¼Œé‚£ä¹ˆå®ƒåœ¨ç¬¬ä¸€æ¬¡èµ‹å€¼æ—¶å°±ä¼šå¯¹ buckets åˆ†é…
</span><span class="c1"></span>	<span class="c1">// æ‡’åˆå§‹åŒ–ï¼Œåœ¨å‰é¢åˆå§‹åŒ–mapæ—¶ï¼ŒBä¸º0ï¼Œæ¡¶æ•°ç»„æ”¾åˆ°è¿™é‡Œæ¥è¿›è¡Œåˆå§‹åŒ–
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span> <span class="c1">// newarray(t.bucket, 1)
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// é¦–å…ˆæ˜¯å‡½æ•°ä¼šæ ¹æ®ä¼ å…¥çš„é”®æ‹¿åˆ°å¯¹åº”çš„å“ˆå¸Œå’Œæ¡¶ï¼š
</span><span class="c1"></span><span class="nx">again</span><span class="p">:</span>
	<span class="c1">// æ ¹æ®ä½å…«ä½è®¡ç®—å¾—åˆ° bucket çš„å†…å­˜åœ°å€
</span><span class="c1"></span>	<span class="c1">// ç®—å‡ºè¿™ä¸ªkeyåº”è¯¥è½åˆ°å“ªä¸ªbmapé‡Œ
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// å¦‚æœ map å¤„åœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œé‚£ä¹ˆå½“ key å®šä½åˆ°äº†æŸä¸ª bucket åï¼Œéœ€è¦ç¡®ä¿è¿™ä¸ª bucket å¯¹åº”çš„è€ bucket å®Œæˆäº†è¿ç§»è¿‡ç¨‹ã€‚å³è€ bucket é‡Œçš„ key éƒ½è¦è¿ç§»åˆ°æ–°çš„ bucket ä¸­æ¥ï¼ˆåˆ†è£‚åˆ° 2 ä¸ªæ–° bucketï¼‰ï¼Œæ‰èƒ½åœ¨æ–°çš„ bucket ä¸­è¿›è¡Œæ’å…¥æˆ–è€…æ›´æ–°çš„æ“ä½œã€‚
</span><span class="c1"></span>	<span class="c1">// åªæœ‰è¿›è¡Œå®Œäº†è¿™ä¸ªæ¬è¿æ“ä½œåï¼Œæˆ‘ä»¬æ‰èƒ½æ”¾å¿ƒåœ°åœ¨æ–° bucket é‡Œå®šä½ key è¦å®‰ç½®çš„åœ°å€ï¼Œå†è¿›è¡Œä¹‹åçš„æ“ä½œã€‚
</span><span class="c1"></span>	<span class="c1">// åˆ¤æ–­æ˜¯å¦å¤„äºæ¬è¿æ¡¶çš„çŠ¶æ€
</span><span class="c1"></span>  	<span class="c1">// å¦‚æœå¤„äºè¯¥çŠ¶æ€åˆ™è¿›è¡Œæ—§æ¡¶ -&gt; æ–°æ¡¶çš„æ¬è¿
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// é€šè¿‡ä½ç§»æ“ä½œè·å¾— bucket := hash &amp; bucketMask(h.B) è¿™ä¸ªæ¡¶çš„å¯¹è±¡
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// è®¡ç®—å‡ºkeyçš„å“ˆå¸Œå€¼ä¹‹åçš„é«˜8ä½å“ˆå¸Œå€¼
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
	<span class="c1">// ç„¶åé€šè¿‡éå†æ¯”è¾ƒæ¡¶ä¸­å­˜å‚¨çš„ tophash å’Œé”®çš„å“ˆå¸Œï¼Œå¦‚æœæ‰¾åˆ°äº†ç›¸åŒç»“æœå°±ä¼šè¿”å›ç›®æ ‡ä½ç½®çš„åœ°å€ã€‚
</span><span class="c1"></span>	<span class="c1">// å‡†å¤‡ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªï¼ˆinsertiï¼‰æŒ‡å‘ key çš„ hash å€¼åœ¨ tophash æ•°ç»„æ‰€å¤„çš„ä½ç½®ï¼Œå¦ä¸€ä¸ª(insertk)æŒ‡å‘ cell çš„ä½ç½®ï¼ˆä¹Ÿå°±æ˜¯ key æœ€ç»ˆæ”¾ç½®çš„åœ°å€ï¼‰ï¼Œå½“ç„¶ï¼Œå¯¹åº” value çš„ä½ç½®å°±å¾ˆå®¹æ˜“å®šä½å‡ºæ¥äº†ã€‚è¿™ä¸‰è€…å®é™…ä¸Šéƒ½æ˜¯å…³è”çš„ï¼Œåœ¨ tophash æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®å†³å®šäº† key åœ¨æ•´ä¸ª bucket ä¸­çš„ä½ç½®ï¼ˆå…± 8 ä¸ª keyï¼‰ï¼Œè€Œ value çš„ä½ç½®éœ€è¦â€œè·¨è¿‡â€ 8 ä¸ª key çš„é•¿åº¦ã€‚
</span><span class="c1"></span>	<span class="c1">// å…ƒç´ åœ¨bmapä¸­tophashæ•°ç»„çš„åœ°å€
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
	<span class="c1">// keyçš„åœ°å€
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="c1">// value çš„åœ°å€
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="c1">// for å¾ªç¯ä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­å­˜å‚¨çš„æ•°æ®ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¼šåˆ†åˆ«åˆ¤æ–­ tophash æ˜¯å¦ç›¸ç­‰ã€key æ˜¯å¦ç›¸ç­‰ï¼Œéå†ç»“æŸåä¼šä»å¾ªç¯ä¸­è·³å‡ºã€‚
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// éå†å½“å‰é€‰ä¸­çš„bmap
</span><span class="c1"></span>		<span class="c1">// è¿­ä»£ buckets ä¸­çš„æ¯ä¸€ä¸ª bucketï¼ˆå…± 8 ä¸ªï¼‰
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// å¯¹æ¯” bucket.tophash ä¸ topï¼ˆé«˜å…«ä½ï¼‰æ˜¯å¦ä¸€è‡´
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="c1">// åœ¨å¾ªç¯çš„è¿‡ç¨‹ä¸­ï¼Œinserti å’Œ insertk åˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ç©ºé—²çš„ cellã€‚å¦‚æœä¹‹ååœ¨ map æ²¡æœ‰æ‰¾åˆ° key çš„å­˜åœ¨ï¼Œä¹Ÿå°±æ˜¯è¯´åŸæ¥ map ä¸­æ²¡æœ‰æ­¤ keyï¼Œè¿™æ„å‘³ç€æ’å…¥æ–° keyã€‚é‚£æœ€ç»ˆ key çš„å®‰ç½®åœ°å€å°±æ˜¯ç¬¬ä¸€æ¬¡å‘ç°çš„â€œç©ºä½â€ï¼ˆtophash æ˜¯ emptyï¼‰ã€‚
</span><span class="c1"></span>				<span class="c1">// è‹¥ä¸ä¸€è‡´ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºç©ºæ§½
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="c1">// è®°å½•tophashä¸­æœ€æ—©ä¸€æ¬¡å‡ºç°emptyçš„æƒ…å†µï¼Œè¿™é‡Œä¸ä¸€å®šæ˜¯emptyRestï¼Œæœ‰å¯èƒ½æ˜¯åˆ é™¤æ•°æ®æ—¶çš„emptyOneçŠ¶æ€
</span><span class="c1"></span>					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
					<span class="c1">// æŠŠè¯¥ä½ç½®æ ‡è¯†ä¸ºå¯æ’å…¥ tophash ä½ç½®,è¿™é‡Œå°±æ˜¯ç¬¬ä¸€ä¸ªå¯ä»¥æ’å…¥æ•°æ®çš„åœ°æ–¹
</span><span class="c1"></span>					<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="c1">// å¦‚æœ b.tophash[i] == emptyRest
</span><span class="c1"></span>        			<span class="c1">// ä»£è¡¨åç»­çš„b.tophashæ²¡æœ‰ æº¢å‡ºbmapæˆ–è€…å¯éå†çš„b.tophashäº†
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="c1">// è·³å‡ºå¾ªç¯
</span><span class="c1"></span>					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// è‹¥æ˜¯åŒ¹é…ï¼ˆä¹Ÿå°±æ˜¯åŸæœ¬å·²ç»å­˜åœ¨ï¼‰ï¼Œåˆ™è¿›è¡Œæ›´æ–°ã€‚æœ€åè·³å‡ºå¹¶è¿”å› value çš„å†…å­˜åœ°å€
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// è®¡ç®—å½“å‰kä¸ä¼ è¿›æ¥çš„keyæ˜¯å¦ç›¸ç­‰ï¼Œæœ‰å¯èƒ½åªæ˜¯é«˜ä½ç›¸ç­‰ï¼Œåˆ™éœ€è¦ç»§ç»­å¾ªç¯
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// already have a mapping for key. Update it.
</span><span class="c1"></span>			<span class="c1">// å¦‚æœç›¸ç­‰é‚£ä¹ˆå°±ä»£è¡¨æ˜¯æ›´æ–°æ“ä½œ
</span><span class="c1"></span>      			<span class="c1">// å…ˆæŠŠä¼ å…¥çš„keyçš„èµ‹å€¼åˆ°kå¤„
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">needkeyupdate</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// è®¡ç®—å‡ºkå¯¹åº”valueçš„åœ°å€
</span><span class="c1"></span>			<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="c1">// ç›´æ¥è·³è½¬åˆ°ç»“æŸ
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">done</span>
		<span class="p">}</span>
		<span class="c1">// åˆ¤æ–­æ˜¯å¦è¿­ä»£å®Œæ¯•ï¼Œè‹¥æ˜¯åˆ™ç»“æŸè¿­ä»£ buckets å¹¶æ›´æ–°å½“å‰æ¡¶ä½ç½®
</span><span class="c1"></span>		<span class="c1">// å½“å‰æ¡¶å·²ç»æ²¡æœ‰å­˜å‚¨æ•°æ®çš„ä½ç½®äº†ï¼Œåˆ™éœ€è¦ä»overflowæº¢å‡ºæ¡¶ä¸­æŸ¥è¯¢ä½ç½®
</span><span class="c1"></span>		<span class="c1">// è·å–æº¢å‡ºbmap
</span><span class="c1"></span>    		<span class="c1">// ä»£è¡¨åœ¨å½“å‰bmapé‡Œé¢ä¹ˆå¾—æ‰¾åˆ°å¯ç”¨çš„åœ°å€
</span><span class="c1"></span>		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="c1">// æ²¡æœ‰æº¢å‡ºbmapå°±è·³å‡º
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// ç»§ç»­å¾ªç¯
</span><span class="c1"></span>		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
	<span class="p">}</span>
	<span class="c1">// å¦‚æœæ²¡æ‰¾åˆ°å¯ç”¨çš„æ’æ§½ï¼Œé‚£ä¹ˆå°±åˆ›å»ºä¸€ä¸ª
</span><span class="c1"></span>  	<span class="c1">// åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
</span><span class="c1"></span>  	<span class="c1">// æ‰©å®¹æ¡ä»¶ä¸ºï¼š
</span><span class="c1"></span>  	<span class="c1">// 1.å½“è£…è½½å› å­&gt;=6.5
</span><span class="c1"></span>  	<span class="c1">// 2.æº¢å‡ºbmapè¿‡å¤š
</span><span class="c1"></span>  	<span class="c1">// ç¬¬äºŒç§æƒ…å†µåªä¼šå‡ºç°åœ¨å…ˆå¤§é‡çš„å†™ç„¶åå†å¤§é‡åˆ é™¤çš„æƒ…å†µ
</span><span class="c1"></span>	<span class="c1">// Did not find mapping for key. Allocate new cell &amp; add entry.
</span><span class="c1"></span>
	<span class="c1">// If we hit the max load factor or we have too many overflow buckets,
</span><span class="c1"></span>	<span class="c1">// and we&#39;re not already in the middle of growing, start growing.
</span><span class="c1"></span>	<span class="c1">// åœ¨æ­£å¼å®‰ç½® key ä¹‹å‰ï¼Œè¿˜è¦æ£€æŸ¥ map çš„çŠ¶æ€ï¼Œçœ‹å®ƒæ˜¯å¦éœ€è¦è¿›è¡Œæ‰©å®¹ã€‚å¦‚æœæ»¡è¶³æ‰©å®¹çš„æ¡ä»¶ï¼Œå°±ä¸»åŠ¨è§¦å‘ä¸€æ¬¡æ‰©å®¹æ“ä½œã€‚
</span><span class="c1"></span>	<span class="c1">// è¿™ä¹‹åï¼Œæ•´ä¸ªä¹‹å‰çš„æŸ¥æ‰¾å®šä½ key çš„è¿‡ç¨‹ï¼Œè¿˜å¾—å†é‡æ–°èµ°ä¸€æ¬¡ã€‚å› ä¸ºæ‰©å®¹ä¹‹åï¼Œkey çš„åˆ†å¸ƒéƒ½å‘ç”Ÿäº†å˜åŒ–ã€‚
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// æ‰©å®¹
</span><span class="c1"></span>		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
		<span class="c1">// é‡æ–°æ‰¾
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">again</span> <span class="c1">// Growing the table invalidates everything, so try again
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// æ‰€æœ‰çš„å½“å‰æ¡¶éƒ½æ˜¯æ»¡çš„ï¼Œéœ€è¦æ„å»ºä¸€ä¸ªæ–°çš„æº¢å‡ºæ¡¶
</span><span class="c1"></span>	<span class="c1">// å¦‚æœè¿™ä¸ª bucket çš„ 8 ä¸ª key éƒ½å·²ç»æ”¾ç½®æ»¡äº†ï¼Œé‚£åœ¨è·³å‡ºå¾ªç¯åï¼Œå‘ç° inserti å’Œ insertk éƒ½æ˜¯ç©ºï¼Œè¿™æ—¶å€™éœ€è¦åœ¨ bucket åé¢æŒ‚ä¸Š overflow bucket.å“ˆå¸Œä¼šè°ƒç”¨ runtime.hmap.newoverflow åˆ›å»ºæ–°æ¡¶æˆ–è€…ä½¿ç”¨ runtime.hmap é¢„å…ˆåœ¨ noverflow ä¸­åˆ›å»ºå¥½çš„æ¡¶æ¥ä¿å­˜æ•°æ®ï¼Œæ–°åˆ›å»ºçš„æ¡¶ä¸ä»…ä¼šè¢«è¿½åŠ åˆ°å·²æœ‰æ¡¶çš„æœ«å°¾ï¼Œè¿˜ä¼šå¢åŠ å“ˆå¸Œè¡¨çš„ noverflow è®¡æ•°å™¨ã€‚
</span><span class="c1"></span>	<span class="c1">// ç»è¿‡å‰é¢è¿­ä»£å¯»æ‰¾åŠ¨ä½œï¼Œè‹¥æ²¡æœ‰æ‰¾åˆ°å¯æ’å…¥çš„ä½ç½®ï¼Œæ„å‘³ç€å½“å‰çš„æ‰€æœ‰æ¡¶éƒ½æ»¡äº†ï¼Œå°†é‡æ–°åˆ†é…ä¸€ä¸ªæ–°æº¢å‡ºæ¡¶ç”¨äºæ’å…¥åŠ¨ä½œã€‚æœ€åå†åœ¨ä¸Šä¸€æ­¥ç”³è¯·çš„æ–°æ’å…¥ä½ç½®ï¼Œå­˜å‚¨é”®å€¼å¯¹ï¼Œè¿”å›è¯¥å€¼çš„å†…å­˜åœ°å€
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span><span class="c1"></span>		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// å°†æ–°key/elemå­˜å‚¨åœ¨æ’å…¥ä½ç½®
</span><span class="c1"></span>	<span class="c1">// store new key/elem at insert position
</span><span class="c1"></span>	<span class="c1">// æœ€åï¼Œä¼šæ›´æ–° map ç›¸å…³çš„å€¼ï¼Œå¦‚æœæ˜¯æ’å…¥æ–° keyï¼Œmap çš„å…ƒç´ æ•°é‡å­—æ®µ count å€¼ä¼šåŠ  1ï¼›åœ¨å‡½æ•°ä¹‹åˆè®¾ç½®çš„ hashWriting å†™æ ‡å¿—å‡ºä¼šæ¸…é›¶ã€‚
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="p">}</span>
	<span class="c1">//å¼•ç”¨ç±»å‹åˆ†é…valueæ‰€éœ€ç©ºé—´ï¼ŒåŒæ—¶æŠŠvalueåœ¨æ§½ä¸­å¯¹åº”çš„ä½ç½®æŒ‡å‘è¿™ä¸ªç©ºé—´
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
	<span class="p">}</span>
	<span class="c1">//å°†keyå†™å…¥åˆšåˆ†é…çš„ç©ºé—´
</span><span class="c1"></span>	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="c1">//æ›´æ–°æ ‡è®°ä½
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
	<span class="c1">//å…ƒç´ ä¸ªæ•°+1
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="c1">// å†æ¬¡æ ¡éªŒå¹¶å‘å†™
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// å¹¶å‘çš„å†™ï¼Œæ ‡è®°åœ¨ä¸Šé¢é€šè¿‡h.flags ^= hashWritingè®¾ç½®
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// å–æ¶ˆå¹¶å‘å†™çš„æ ‡è®°
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// è¿”å›å¯ç”¨çš„value å­˜æ”¾åœ°å€
</span><span class="c1"></span>  	<span class="c1">// éšåçš„èµ‹å€¼æ“ä½œä¼šåœ¨æ±‡ç¼–ä¸­è¿›è¡Œ
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">elem</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">bmap</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ovf</span> <span class="o">*</span><span class="nx">bmap</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// We have preallocated overflow buckets available.
</span><span class="c1"></span>		<span class="c1">// See makeBucketArray for more details.
</span><span class="c1"></span>		<span class="nx">ovf</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span>
		<span class="k">if</span> <span class="nx">ovf</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// We&#39;re not at the end of the preallocated overflow buckets. Bump the pointer.
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ovf</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// This is the last preallocated overflow bucket.
</span><span class="c1"></span>			<span class="c1">// Reset the overflow pointer on this bucket,
</span><span class="c1"></span>			<span class="c1">// which was set to a non-nil sentinel value.
</span><span class="c1"></span>			<span class="nx">ovf</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">ovf</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">incrnoverflow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>
		<span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span><span class="p">,</span> <span class="nx">ovf</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">ovf</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ovf</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­ä¸å­˜åœ¨ï¼Œå“ˆå¸Œä¼šä¸ºæ–°é”®å€¼å¯¹è§„åˆ’å­˜å‚¨çš„å†…å­˜åœ°å€ï¼Œé€šè¿‡ <code>runtime.typedmemmove</code> å°†é”®ç§»åŠ¨åˆ°å¯¹åº”çš„å†…å­˜ç©ºé—´ä¸­å¹¶è¿”å›é”®å¯¹åº”å€¼çš„åœ°å€ valã€‚å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ä¼šç›´æ¥è¿”å›ç›®æ ‡åŒºåŸŸçš„å†…å­˜åœ°å€ï¼Œå“ˆå¸Œå¹¶ä¸ä¼šåœ¨ <code>runtime.mapassign</code> è¿™ä¸ªè¿è¡Œæ—¶å‡½æ•°ä¸­å°†å€¼æ‹·è´åˆ°æ¡¶ä¸­ï¼Œè¯¥å‡½æ•°åªä¼šè¿”å›å†…å­˜åœ°å€ï¼ŒçœŸæ­£çš„èµ‹å€¼æ“ä½œæ˜¯åœ¨ç¼–è¯‘æœŸé—´æ’å…¥çš„ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">00018</span> <span class="p">(</span><span class="m">+5</span><span class="p">)</span> <span class="n">CALL</span> <span class="nf">runtime.mapassign_fast64</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
<span class="m">00020</span> <span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="n">MOVQ</span> <span class="m">24</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">DI</span>               <span class="p">;;</span> <span class="n">DI</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value</span>
<span class="m">00026</span> <span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="n">LEAQ</span> <span class="n">go.string.</span><span class="s">&#34;88&#34;</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">AX</span>   <span class="p">;;</span> <span class="n">AX</span> <span class="o">=</span> <span class="o">&amp;</span><span class="s">&#34;88&#34;</span>
<span class="m">00027</span> <span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="n">MOVQ</span> <span class="n">AX</span><span class="p">,</span> <span class="p">(</span><span class="n">DI</span><span class="p">)</span>                 <span class="p">;;</span> <span class="o">*</span><span class="n">DI</span> <span class="o">=</span> <span class="n">AX</span>
</code></pre></td></tr></table>
</div>
</div><p><code>runtime.mapassign_fast64</code> ä¸ <code>runtime.mapassign</code> å‡½æ•°çš„é€»è¾‘å·®ä¸å¤šï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨çš„æ˜¯åé¢çš„ä¸‰è¡Œä»£ç ï¼Œå…¶ä¸­ 24(SP) æ˜¯è¯¥å‡½æ•°è¿”å›çš„å€¼åœ°å€ï¼Œæˆ‘ä»¬é€šè¿‡ LEAQ æŒ‡ä»¤å°†å­—ç¬¦ä¸²çš„åœ°å€å­˜å‚¨åˆ°å¯„å­˜å™¨ AX ä¸­ï¼ŒMOVQ æŒ‡ä»¤å°†å­—ç¬¦ä¸² &ldquo;88&rdquo; å­˜å‚¨åˆ°äº†ç›®æ ‡åœ°å€ä¸Šå®Œæˆäº†è¿™æ¬¡å“ˆå¸Œçš„å†™å…¥ã€‚</p>
<h2 id="mapdelete">mapdelete<a hidden class="anchor" aria-hidden="true" href="#mapdelete">#</a></h2>
<p>å¦‚æœæƒ³è¦åˆ é™¤å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œå°±éœ€è¦ä½¿ç”¨ Go è¯­è¨€ä¸­çš„ delete å…³é”®å­—ï¼Œè¿™ä¸ªå…³é”®å­—çš„å”¯ä¸€ä½œç”¨å°±æ˜¯å°†æŸä¸€ä¸ªé”®å¯¹åº”çš„å…ƒç´ ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œæ— è®ºæ˜¯è¯¥é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¸ªå†…å»ºçš„å‡½æ•°éƒ½ä¸ä¼šè¿”å›ä»»ä½•çš„ç»“æœã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702182636.png" alt=""  />
</p>
<p>åœ¨ç¼–è¯‘æœŸé—´ï¼Œdelete å…³é”®å­—ä¼šè¢«è½¬æ¢æˆæ“ä½œä¸º ODELETE çš„èŠ‚ç‚¹ï¼Œè€Œ <code>cmd/compile/internal/gc.walkexpr</code> ä¼šå°† ODELETE èŠ‚ç‚¹è½¬æ¢æˆ <code>runtime.mapdelete</code> å‡½æ•°ç°‡ä¸­çš„ä¸€ä¸ªï¼ŒåŒ…æ‹¬ <code>runtime.mapdeleteã€mapdelete_faststr</code>ã€<code>mapdelete_fast32</code> å’Œ <code>mapdelete_fast64</code>ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">walkexpr</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">init</span><span class="o">*</span><span class="nx">Nodes</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">ODELETE</span><span class="p">:</span>
		<span class="nx">init</span><span class="p">.</span><span class="nf">AppendNodes</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">Ninit</span><span class="p">)</span>
		<span class="nx">map_</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">First</span><span class="p">()</span>
		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Second</span><span class="p">()</span>
		<span class="nx">map_</span> <span class="p">=</span> <span class="nf">walkexpr</span><span class="p">(</span><span class="nx">map_</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span>
		<span class="nx">key</span> <span class="p">=</span> <span class="nf">walkexpr</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span>

		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">map_</span><span class="p">.</span><span class="nx">Type</span>
		<span class="nx">fast</span> <span class="o">:=</span> <span class="nf">mapfast</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">fast</span> <span class="o">==</span> <span class="nx">mapslow</span> <span class="p">{</span>
			<span class="nx">key</span> <span class="p">=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OADDR</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nf">mkcall1</span><span class="p">(</span><span class="nf">mapfndel</span><span class="p">(</span><span class="nx">mapdelete</span><span class="p">[</span><span class="nx">fast</span><span class="p">],</span> <span class="nx">t</span><span class="p">),</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">init</span><span class="p">,</span> <span class="nf">typename</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="nx">map_</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>è¿™äº›å‡½æ•°çš„å®ç°å…¶å®å·®ä¸å¤šï¼Œæˆ‘ä»¬æŒ‘é€‰å…¶ä¸­çš„ runtime.mapdelete åˆ†æä¸€ä¸‹ã€‚å“ˆå¸Œè¡¨çš„åˆ é™¤é€»è¾‘ä¸å†™å…¥é€»è¾‘å¾ˆç›¸ä¼¼ï¼Œåªæ˜¯è§¦å‘å“ˆå¸Œçš„åˆ é™¤éœ€è¦ä½¿ç”¨å…³é”®å­—ï¼Œå¦‚æœåœ¨åˆ é™¤æœŸé—´é‡åˆ°äº†å“ˆå¸Œè¡¨çš„æ‰©å®¹ï¼Œå°±ä¼šåˆ†æµæ¡¶ä¸­çš„å…ƒç´ ï¼Œåˆ†æµç»“æŸä¹‹åä¼šæ‰¾åˆ°æ¡¶ä¸­çš„ç›®æ ‡å…ƒç´ å®Œæˆé”®å€¼å¯¹çš„åˆ é™¤å·¥ä½œã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapdelete</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapdelete</span><span class="p">)</span>
		<span class="nf">racewritepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hashMightPanic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// see issue 23734
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// æ£€æµ‹æ˜¯å¦æœ‰å¹¶å‘å†™
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>

	<span class="c1">// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span><span class="c1"></span>	<span class="c1">// in which case we have not actually done a write (delete).
</span><span class="c1"></span>	<span class="c1">// æ ‡è®°æ­¤æ—¶æ­£åœ¨æ‰§è¡Œä¿®æ”¹æ“ä½œ
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>
	<span class="c1">// æŒ‰ä½ä½è¿›è¡Œæ¡¶çš„é€‰æ‹©
</span><span class="c1"></span>	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// è®¡ç®— key çš„å“ˆå¸Œï¼Œæ‰¾åˆ°è½å…¥çš„ bucketã€‚æ£€æŸ¥æ­¤ map å¦‚æœæ­£åœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œç›´æ¥è§¦å‘ä¸€æ¬¡æ¬è¿æ“ä½œã€‚
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// è¿›è¡Œæ‰©å®¹
</span><span class="c1"></span>		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="nx">bOrig</span> <span class="o">:=</span> <span class="nx">b</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">search</span><span class="p">:</span>
	<span class="c1">// åˆ é™¤æ“ä½œåŒæ ·æ˜¯ä¸¤å±‚å¾ªç¯ï¼Œæ ¸å¿ƒè¿˜æ˜¯æ‰¾åˆ° key çš„å…·ä½“ä½ç½®ã€‚å¯»æ‰¾è¿‡ç¨‹éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œåœ¨ bucket ä¸­æŒ¨ä¸ª cell å¯»æ‰¾ã€‚
</span><span class="c1"></span>	<span class="c1">// æ‰¾åˆ°å¯¹åº”ä½ç½®åï¼Œå¯¹ key æˆ–è€… value è¿›è¡Œâ€œæ¸…é›¶â€æ“ä½œï¼š
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">search</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
			<span class="c1">// å¯¹ key æ¸…é›¶
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// Only clear key if there are pointers in it.
</span><span class="c1"></span>			<span class="c1">// å¯¹ value æ¸…é›¶
</span><span class="c1"></span>			<span class="c1">// keyæ˜¯æŒ‡é’ˆçš„éœ€è¦ç½®ç©ºï¼Œæ–¹ä¾¿GC
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
				<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// æ ‡è®°åˆ é™¤ä½ï¼Œè¯æ˜è¿™ä¸ªä½ç½®å·²è¢«åˆ é™¤
</span><span class="c1"></span>			<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span>
			<span class="c1">// If the bucket now ends in a bunch of emptyOne states,
</span><span class="c1"></span>			<span class="c1">// change those to emptyRest states.
</span><span class="c1"></span>			<span class="c1">// It would be nice to make this a separate function, but
</span><span class="c1"></span>			<span class="c1">// for loops are not currently inlineable.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
				<span class="c1">// å¦‚æœæ˜¯è¯¥tophashçš„æœ€åä¸€ä¸ªï¼Œåˆ™éœ€è¦åˆ¤æ–­overflowä¸­tophashçš„ç¬¬ä¸€ä½æ˜¯å¦æ˜¯emptyRest
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="nx">notLast</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// å¦‚æœä¸æ˜¯å½“å‰tophashçš„æœ€åä¸€ä¸ªï¼Œåˆ™ç›´æ¥åˆ¤æ–­å½“å‰tophashçš„ä¸‹ä¸€ä¸ªæ˜¯å¦æ˜¯emptyRest
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="nx">notLast</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// å½“å‰å€¼ä¹‹åä¸å­˜åœ¨å…¶ä»–çš„æ•°æ®ï¼Œåˆ™ç½®ä¸ºemptyRest
</span><span class="c1"></span>             		<span class="c1">// éœ€è¦æŠŠè¯¥ä½ç½®ä¹‹å‰é™¤éç©ºä¹‹å¤–çš„æ‰€æœ‰emptyOneä½ç½®ä¹Ÿç½®ä¸ºemptyRest
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">{</span>
				<span class="c1">// å°†å¯¹åº”ä½ç½®çš„ tophash å€¼ç½®æˆ Empty
</span><span class="c1"></span>				<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyRest</span>
				<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">bOrig</span> <span class="p">{</span>
						<span class="k">break</span> <span class="c1">// beginning of initial bucket, we&#39;re done.
</span><span class="c1"></span>					<span class="p">}</span>
					<span class="c1">// Find previous bucket, continue at its last entry.
</span><span class="c1"></span>					<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span>
					<span class="k">for</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">bOrig</span><span class="p">;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">}</span>
					<span class="nx">i</span> <span class="p">=</span> <span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">i</span><span class="o">--</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">emptyOne</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="nx">notLast</span><span class="p">:</span>
			<span class="c1">// æœ€åï¼Œå°† count å€¼å‡ 1ã€‚
</span><span class="c1"></span>			<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span>
			<span class="c1">// Reset the hash seed to make it more difficult for attackers to
</span><span class="c1"></span>			<span class="c1">// repeatedly trigger hash collisions. See issue 25237.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">break</span> <span class="nx">search</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// æŠ›å‡ºå¹¶å‘ä¿®æ”¹å¼‚å¸¸
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>æˆ‘ä»¬å…¶å®åªéœ€è¦çŸ¥é“ delete å…³é”®å­—åœ¨ç¼–è¯‘æœŸé—´ç»è¿‡ç±»å‹æ£€æŸ¥å’Œä¸­é—´ä»£ç ç”Ÿæˆé˜¶æ®µè¢«è½¬æ¢æˆ <code>runtime.mapdelete</code> å‡½æ•°ç°‡ä¸­çš„ä¸€å‘˜ï¼Œç”¨äºå¤„ç†åˆ é™¤é€»è¾‘çš„å‡½æ•°ä¸å“ˆå¸Œè¡¨çš„ <code>runtime.mapassign</code> å‡ ä¹å®Œå…¨ç›¸åŒï¼Œä¸å¤ªéœ€è¦åˆ»æ„å…³æ³¨ã€‚</p>
<p>åˆ é™¤æ•°æ®çš„é€»è¾‘ä¸æ˜¯å¾ˆå¤æ‚ï¼Œä½†æ˜¯é‡Œé¢å¯¹tophashä¸­çš„çŠ¶æ€è¿›è¡Œäº†ç½®æ¢ï¼Œå¢åŠ äº†é˜…è¯»ä»£ç çš„å¤æ‚åº¦ã€‚è¿™é‡Œä¸»è¦æ˜¯emptyOneå’ŒemptyRestè¿™ä¸¤ä¸ªçŠ¶æ€çš„è½¬åŒ–ï¼Œé‡Œé¢æœ‰å‡ ä¸ªä¸´ç•Œç‚¹ï¼Œä¸‹é¢ä¸€ä¸€è¯´æ˜ï¼š</p>
<ol>
<li>å½“å‰åˆ é™¤å…ƒç´ æ˜¯tophashä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™éœ€è¦æ£€æŸ¥å®ƒçš„ä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶tophashçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯emptyRestã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥returnã€‚</li>
<li>å½“å‰åˆ é™¤å…ƒç´ ä¸æ˜¯tophashä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œåˆ™æ£€æŸ¥å½“å‰tophashçš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯emptyRestå³å¯ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™ç›´æ¥returnã€‚</li>
<li>å‰ä¸¤ä¸ªæ¡ä»¶éƒ½ä¸æ»¡è¶³çš„æƒ…å†µä¸‹ï¼Œåˆ™éœ€è¦å°†å½“å‰ä½ç½®ç½®ä¸ºemptyRestï¼ŒåŒæ—¶è¿˜è¦æ£€æµ‹å®ƒå‰é¢çš„emptyOneçŠ¶æ€çš„å…ƒç´ ï¼Œå°†å…¶å‡ç½®ä¸ºemptyRestï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</li>
</ol>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210704213628.png" alt=""  />
</p>
<p>è¿™ç§åˆ é™¤æ–¹å¼ï¼Œä»¥å°‘é‡ç©ºé—´é¿å…äº†è¢«åˆ é™¤çš„æ•°æ®å†æ¬¡æ’å…¥æ—¶å‡ºç°æ•°æ®ç§»åŠ¨çš„æƒ…å†µã€‚äº‹å®ä¸Šï¼ŒGo æ•°æ®ä¸€æ—¦è¢«æ’å…¥åˆ°æ¡¶çš„ç¡®åˆ‡ä½ç½®ï¼Œmap æ˜¯ä¸ä¼šå†ç§»åŠ¨è¯¥æ•°æ®åœ¨æ¡¶ä¸­çš„ä½ç½®äº†ã€‚</p>
<h2 id="æ‰©å®¹">æ‰©å®¹<a hidden class="anchor" aria-hidden="true" href="#æ‰©å®¹">#</a></h2>
<p>ä½¿ç”¨å“ˆå¸Œè¡¨çš„ç›®çš„å°±æ˜¯è¦å¿«é€ŸæŸ¥æ‰¾åˆ°ç›®æ ‡ keyï¼Œç„¶è€Œï¼Œéšç€å‘ map ä¸­æ·»åŠ çš„ key è¶Šæ¥è¶Šå¤šï¼Œkey å‘ç”Ÿç¢°æ’çš„æ¦‚ç‡ä¹Ÿè¶Šæ¥è¶Šå¤§ã€‚bucket ä¸­çš„ 8 ä¸ª cell ä¼šè¢«é€æ¸å¡æ»¡ï¼ŒæŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ key çš„æ•ˆç‡ä¹Ÿä¼šè¶Šæ¥è¶Šä½ã€‚æœ€ç†æƒ³çš„æƒ…å†µæ˜¯ä¸€ä¸ª bucket åªè£…ä¸€ä¸ª keyï¼Œè¿™æ ·ï¼Œå°±èƒ½è¾¾åˆ° O(1) çš„æ•ˆç‡ï¼Œä½†è¿™æ ·ç©ºé—´æ¶ˆè€—å¤ªå¤§ï¼Œç”¨ç©ºé—´æ¢æ—¶é—´çš„ä»£ä»·å¤ªé«˜ã€‚</p>
<p>Go è¯­è¨€é‡‡ç”¨ä¸€ä¸ª bucket é‡Œè£…è½½ 8 ä¸ª keyï¼Œå®šä½åˆ°æŸä¸ª bucket åï¼Œè¿˜éœ€è¦å†å®šä½åˆ°å…·ä½“çš„ keyï¼Œè¿™å®é™…ä¸Šåˆç”¨äº†æ—¶é—´æ¢ç©ºé—´ã€‚</p>
<p>å½“ç„¶ï¼Œè¿™æ ·åšï¼Œè¦æœ‰ä¸€ä¸ªåº¦ï¼Œä¸ç„¶æ‰€æœ‰çš„ key éƒ½è½åœ¨äº†åŒä¸€ä¸ª bucket é‡Œï¼Œç›´æ¥é€€åŒ–æˆäº†é“¾è¡¨ï¼Œå„ç§æ“ä½œçš„æ•ˆç‡ç›´æ¥é™ä¸º O(n)ï¼Œæ˜¯ä¸è¡Œçš„ã€‚</p>
<h3 id="æ‰©å®¹æ—¶æœº">æ‰©å®¹æ—¶æœº<a hidden class="anchor" aria-hidden="true" href="#æ‰©å®¹æ—¶æœº">#</a></h3>
<p>å› æ­¤ï¼Œéœ€è¦æœ‰ä¸€ä¸ªæŒ‡æ ‡æ¥è¡¡é‡å‰é¢æè¿°çš„æƒ…å†µï¼Œè¿™å°±æ˜¯è£…è½½å› å­ã€‚</p>
<p>è£…è½½å› å­çš„è®¡ç®—å…¬å¼æ˜¯ï¼šè£…è½½å› å­=å¡«å…¥è¡¨ä¸­çš„å…ƒç´ ä¸ªæ•°/æ•£åˆ—è¡¨çš„é•¿åº¦ï¼Œè£…è½½å› å­è¶Šå¤§ï¼Œè¯´æ˜ç©ºé—²ä½ç½®è¶Šå°‘ï¼Œå†²çªè¶Šå¤šï¼Œæ•£åˆ—è¡¨çš„æ€§èƒ½ä¼šä¸‹é™ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">loadFactor</span> <span class="o">:=</span> <span class="n">count</span> <span class="o">/</span> <span class="p">(</span><span class="m">2</span><span class="n">^B</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>count å°±æ˜¯ map çš„å…ƒç´ ä¸ªæ•°ï¼Œ2^B è¡¨ç¤º bucket æ•°é‡ã€‚</p>
<p>å†æ¥è¯´è§¦å‘ map æ‰©å®¹çš„æ—¶æœºï¼šåœ¨å‘ map æ’å…¥æ–° key çš„æ—¶å€™ï¼Œä¼šè¿›è¡Œæ¡ä»¶æ£€æµ‹ï¼Œç¬¦åˆä¸‹é¢è¿™ 2 ä¸ªæ¡ä»¶ï¼Œå°±ä¼šè§¦å‘æ‰©å®¹ï¼š</p>
<ol>
<li>è£…è½½å› å­è¶…è¿‡é˜ˆå€¼ï¼Œæºç é‡Œå®šä¹‰çš„é˜ˆå€¼æ˜¯ 6.5ã€‚</li>
<li>overflow çš„ bucket æ•°é‡è¿‡å¤šï¼š
<ol>
<li>å½“ B &lt; 15ï¼Œä¹Ÿå°±æ˜¯ bucket æ€»æ•° 2^B å°äº 2^15 æ—¶ï¼Œå¦‚æœ overflow çš„ bucket æ•°é‡è¶…è¿‡ 2^Bï¼›</li>
<li>å½“ B &gt;= 15ï¼Œä¹Ÿå°±æ˜¯ bucket æ€»æ•° 2^B å¤§äºç­‰äº 2^15ï¼Œå¦‚æœ overflow çš„ bucket æ•°é‡è¶…è¿‡ 2^15ã€‚</li>
</ol>
</li>
</ol>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810220350.png" alt=""  />
</p>
<p>ä¸è¿‡å› ä¸º Go è¯­è¨€å“ˆå¸Œçš„æ‰©å®¹ä¸æ˜¯ä¸€ä¸ªåŸå­çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥ runtime.mapassign è¿˜éœ€è¦åˆ¤æ–­å½“å‰å“ˆå¸Œæ˜¯å¦å·²ç»å¤„äºæ‰©å®¹çŠ¶æ€ï¼Œé¿å…äºŒæ¬¡æ‰©å®¹é€ æˆæ··ä¹±ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.
</span><span class="c1">// è£…è½½å› å­è¶…è¿‡ 6.5
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.
</span><span class="c1">// Note that most of these overflow buckets must be in sparse use;
</span><span class="c1">// if use was dense, then we&#39;d have already triggered regular map growth.
</span><span class="c1">// overflow buckets å¤ªå¤š
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// If the threshold is too low, we do extraneous work.
</span><span class="c1"></span>	<span class="c1">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
</span><span class="c1"></span>	<span class="c1">// &#34;too many&#34; means (approximately) as many overflow buckets as regular buckets.
</span><span class="c1"></span>	<span class="c1">// See incrnoverflow for more details.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
		<span class="nx">B</span> <span class="p">=</span> <span class="mi">15</span>
	<span class="p">}</span>
	<span class="c1">// The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">noverflow</span> <span class="o">&gt;=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">B</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>æˆ‘ä»¬çŸ¥é“ï¼Œæ¯ä¸ª bucket æœ‰ 8 ä¸ªç©ºä½ï¼Œåœ¨æ²¡æœ‰æº¢å‡ºï¼Œä¸”æ‰€æœ‰çš„æ¡¶éƒ½è£…æ»¡äº†çš„æƒ…å†µä¸‹ï¼Œè£…è½½å› å­ç®—å‡ºæ¥çš„ç»“æœæ˜¯ 8ã€‚å› æ­¤å½“è£…è½½å› å­è¶…è¿‡ 6.5 æ—¶ï¼Œè¡¨æ˜å¾ˆå¤š bucket éƒ½å¿«è¦è£…æ»¡äº†ï¼ŒæŸ¥æ‰¾æ•ˆç‡å’Œæ’å…¥æ•ˆç‡éƒ½å˜ä½äº†ã€‚åœ¨è¿™ä¸ªæ—¶å€™è¿›è¡Œæ‰©å®¹æ˜¯æœ‰å¿…è¦çš„ã€‚</p>
<p>å°±æ˜¯è¯´åœ¨è£…è½½å› å­æ¯”è¾ƒå°çš„æƒ…å†µä¸‹ï¼Œè¿™æ—¶å€™ map çš„æŸ¥æ‰¾å’Œæ’å…¥æ•ˆç‡ä¹Ÿå¾ˆä½ï¼Œè€Œç¬¬ 1 ç‚¹è¯†åˆ«ä¸å‡ºæ¥è¿™ç§æƒ…å†µã€‚è¡¨é¢ç°è±¡å°±æ˜¯è®¡ç®—è£…è½½å› å­çš„åˆ†å­æ¯”è¾ƒå°ï¼Œå³ map é‡Œå…ƒç´ æ€»æ•°å°‘ï¼Œä½†æ˜¯ bucket æ•°é‡å¤šï¼ˆçœŸå®åˆ†é…çš„ bucket æ•°é‡å¤šï¼ŒåŒ…æ‹¬å¤§é‡çš„ overflow bucketï¼‰ã€‚</p>
<p>ä¸éš¾æƒ³åƒé€ æˆè¿™ç§æƒ…å†µçš„åŸå› ï¼šä¸åœåœ°æ’å…¥ã€åˆ é™¤å…ƒç´ ã€‚å…ˆæ’å…¥å¾ˆå¤šå…ƒç´ ï¼Œå¯¼è‡´åˆ›å»ºäº†å¾ˆå¤š bucketï¼Œä½†æ˜¯è£…è½½å› å­è¾¾ä¸åˆ°ç¬¬ 1 ç‚¹çš„ä¸´ç•Œå€¼ï¼Œæœªè§¦å‘æ‰©å®¹æ¥ç¼“è§£è¿™ç§æƒ…å†µã€‚ä¹‹åï¼Œåˆ é™¤å…ƒç´ é™ä½å…ƒç´ æ€»æ•°é‡ï¼Œå†æ’å…¥å¾ˆå¤šå…ƒç´ ï¼Œå¯¼è‡´åˆ›å»ºå¾ˆå¤šçš„ overflow bucketï¼Œä½†å°±æ˜¯ä¸ä¼šè§¦çŠ¯ç¬¬ 1 ç‚¹çš„è§„å®šï¼Œä½ èƒ½æ‹¿æˆ‘æ€ä¹ˆåŠï¼Ÿoverflow bucket æ•°é‡å¤ªå¤šï¼Œå¯¼è‡´ key ä¼šå¾ˆåˆ†æ•£ï¼ŒæŸ¥æ‰¾æ’å…¥æ•ˆç‡ä½å¾—å“äººï¼Œå› æ­¤å‡ºå°ç¬¬ 2 ç‚¹è§„å®šã€‚è¿™å°±åƒæ˜¯ä¸€åº§ç©ºåŸï¼Œæˆ¿å­å¾ˆå¤šï¼Œä½†æ˜¯ä½æˆ·å¾ˆå°‘ï¼Œéƒ½åˆ†æ•£äº†ï¼Œæ‰¾èµ·äººæ¥å¾ˆå›°éš¾ã€‚</p>
<p>å¯¹äºå‘½ä¸­æ¡ä»¶ 1ï¼Œ2 çš„é™åˆ¶ï¼Œéƒ½ä¼šå‘ç”Ÿæ‰©å®¹ã€‚ä½†æ˜¯æ‰©å®¹çš„ç­–ç•¥å¹¶ä¸ç›¸åŒï¼Œæ¯•ç«Ÿä¸¤ç§æ¡ä»¶åº”å¯¹çš„åœºæ™¯ä¸åŒã€‚</p>
<h3 id="æ‰©å®¹æ–¹æ¡ˆ">æ‰©å®¹æ–¹æ¡ˆ<a hidden class="anchor" aria-hidden="true" href="#æ‰©å®¹æ–¹æ¡ˆ">#</a></h3>
<p>å¯¹äºæ¡ä»¶ 1ï¼Œå…ƒç´ å¤ªå¤šï¼Œè€Œ bucket æ•°é‡å¤ªå°‘ï¼Œå¾ˆç®€å•ï¼šå°† B åŠ  1ï¼Œbucket æœ€å¤§æ•°é‡ï¼ˆ2^Bï¼‰ç›´æ¥å˜æˆåŸæ¥ bucket æ•°é‡çš„ 2 å€ã€‚äºæ˜¯ï¼Œå°±æœ‰æ–°è€ bucket äº†ã€‚æ³¨æ„ï¼Œè¿™æ—¶å€™å…ƒç´ éƒ½åœ¨è€ bucket é‡Œï¼Œè¿˜æ²¡è¿ç§»åˆ°æ–°çš„ bucket æ¥ã€‚è€Œä¸”ï¼Œæ–° bucket åªæ˜¯æœ€å¤§æ•°é‡å˜ä¸ºåŸæ¥æœ€å¤§æ•°é‡ï¼ˆ2^Bï¼‰çš„ 2 å€ï¼ˆ2^B * 2ï¼‰ã€‚</p>
<p>å¯¹äºæ¡ä»¶ 2ï¼Œå…¶å®å…ƒç´ æ²¡é‚£ä¹ˆå¤šï¼Œä½†æ˜¯ overflow bucket æ•°ç‰¹åˆ«å¤šï¼Œè¯´æ˜å¾ˆå¤š bucket éƒ½æ²¡è£…æ»¡ã€‚è§£å†³åŠæ³•å°±æ˜¯å¼€è¾Ÿä¸€ä¸ªæ–° bucket ç©ºé—´ï¼Œå°†è€ bucket ä¸­çš„å…ƒç´ ç§»åŠ¨åˆ°æ–° bucketï¼Œä½¿å¾—åŒä¸€ä¸ª bucket ä¸­çš„ key æ’åˆ—åœ°æ›´ç´§å¯†ã€‚è¿™æ ·ï¼ŒåŸæ¥ï¼Œåœ¨ overflow bucket ä¸­çš„ key å¯ä»¥ç§»åŠ¨åˆ° bucket ä¸­æ¥ã€‚ç»“æœæ˜¯èŠ‚çœç©ºé—´ï¼Œæé«˜ bucket åˆ©ç”¨ç‡ï¼Œmap çš„æŸ¥æ‰¾å’Œæ’å…¥æ•ˆç‡è‡ªç„¶å°±ä¼šæå‡ã€‚</p>
<p>å¯¹äºæ¡ä»¶ 2 çš„è§£å†³æ–¹æ¡ˆï¼Œæœ‰ä¸€ä¸ªæç«¯çš„æƒ…å†µï¼šå¦‚æœæ’å…¥ map çš„ key å“ˆå¸Œéƒ½ä¸€æ ·ï¼Œå°±ä¼šè½åˆ°åŒä¸€ä¸ª bucket é‡Œï¼Œè¶…è¿‡ 8 ä¸ªå°±ä¼šäº§ç”Ÿ overflow bucketï¼Œç»“æœä¹Ÿä¼šé€ æˆ overflow bucket æ•°è¿‡å¤šã€‚ç§»åŠ¨å…ƒç´ å…¶å®è§£å†³ä¸äº†é—®é¢˜ï¼Œå› ä¸ºè¿™æ—¶æ•´ä¸ªå“ˆå¸Œè¡¨å·²ç»é€€åŒ–æˆäº†ä¸€ä¸ªé“¾è¡¨ï¼Œæ“ä½œæ•ˆç‡å˜æˆäº† O(n)ã€‚</p>
<p>å†æ¥çœ‹ä¸€ä¸‹æ‰©å®¹å…·ä½“æ˜¯æ€ä¹ˆåšçš„ã€‚ç”±äº map æ‰©å®¹éœ€è¦å°†åŸæœ‰çš„ key/value é‡æ–°æ¬è¿åˆ°æ–°çš„å†…å­˜åœ°å€ï¼Œå¦‚æœæœ‰å¤§é‡çš„ key/value éœ€è¦æ¬è¿ï¼Œä¼šéå¸¸å½±å“æ€§èƒ½ã€‚å› æ­¤ Go map çš„æ‰©å®¹é‡‡å–äº†ä¸€ç§ç§°ä¸ºâ€œæ¸è¿›å¼â€åœ°æ–¹å¼ï¼ŒåŸæœ‰çš„ key å¹¶ä¸ä¼šä¸€æ¬¡æ€§æ¬è¿å®Œæ¯•ï¼Œæ¯æ¬¡æœ€å¤šåªä¼šæ¬è¿ 2 ä¸ª bucketã€‚</p>
<p>hashGrow() å‡½æ•°å®é™…ä¸Šå¹¶æ²¡æœ‰çœŸæ­£åœ°â€œæ¬è¿â€ï¼Œå®ƒåªæ˜¯åˆ†é…å¥½äº†æ–°çš„ bucketsï¼Œå¹¶å°†è€çš„ buckets æŒ‚åˆ°äº† oldbuckets å­—æ®µä¸Šã€‚çœŸæ­£æ¬è¿ buckets çš„åŠ¨ä½œåœ¨ growWork() å‡½æ•°ä¸­ï¼Œè€Œè°ƒç”¨ growWork() å‡½æ•°çš„åŠ¨ä½œæ˜¯åœ¨ mapassign å’Œ mapdelete å‡½æ•°ä¸­ã€‚ä¹Ÿå°±æ˜¯æ’å…¥æˆ–ä¿®æ”¹ã€åˆ é™¤ key çš„æ—¶å€™ï¼Œéƒ½ä¼šå°è¯•è¿›è¡Œæ¬è¿ buckets çš„å·¥ä½œã€‚å…ˆæ£€æŸ¥ oldbuckets æ˜¯å¦æ¬è¿å®Œæ¯•ï¼Œå…·ä½“æ¥è¯´å°±æ˜¯æ£€æŸ¥ oldbuckets æ˜¯å¦ä¸º nilã€‚</p>
<p>æ‰©å®¹è¿‡ç¨‹:</p>
<ol>
<li>å½“è£…è½½å› å­&gt;=6.5æˆ–è€…æº¢å‡ºbmapè¿‡å¤šæ—¶ï¼Œä¼šäº§ç”Ÿæ‰©å®¹</li>
<li>å¦‚æœæ˜¯è£…è½½å› å­&gt;=6.5çš„æ‰©å®¹åˆ™ä¸ºç¿»å€æ‰©å®¹ï¼Œåˆ›å»ºä¸€ä¸ªæ¯”å½“å‰æ¡¶ä¸ªæ•°*2çš„æ¡¶åˆ—è¡¨ï¼Œå¦‚æœæº¢å‡ºæ¡¶è¿‡å¤šä½†è£…è½½å› å­&lt;6.5æ—¶ä¸ºç­‰é‡æ‰©å®¹ï¼Œå³æŠŠå½“å‰ç¨€ç–çš„æ¡¶å†…å…ƒç´ è¿›è¡Œæ•´ç†ï¼Œä½¿å…¶æ²¡æœ‰é‚£ä¹ˆå¤šçš„æº¢å‡ºæ¡¶ã€‚</li>
<li>ç„¶åä¼šæŠŠå½“å‰çš„æ¡¶æ”¾åˆ°hmap.oldbucketså­—æ®µä½œä¸ºæ—§æ¡¶ï¼Œç„¶åæŠŠå½“å‰çš„æº¢å‡ºæ¡¶ï¼ˆå¦‚æœæœ‰ï¼‰ä¹Ÿæ”¾åˆ°hmap.extra.oldoverflowä½œä¸ºæ—§çš„æº¢å‡ºæ¡¶ã€‚</li>
<li>åœ¨æ‰©å®¹æ—¶ä¸ä¼šè§¦å‘æ¬è¿æ“ä½œï¼Œæ¬è¿æ“ä½œåªä¼šåœ¨å†™å…¥/åˆ é™¤æ“ä½œæ—¶è¢«è§¦å‘ã€‚</li>
<li>æ¬è¿æ“ä½œè¿‡ç¨‹ï¼š
<ol>
<li>ç¿»å€æ‰©å®¹æ¬è¿è¿‡ç¨‹ï¼š
<ol>
<li>æ‰¾åˆ°å½“å‰keyçš„hashå¯¹åº”çš„æ—§æ¡¶ç„¶åç®—å‡ºå¯¹åº”çš„æ–°æ¡¶ä¿å­˜å…¶ä¸Šä¸‹æ–‡xy[0]ï¼Œå†æ‰¾åˆ°ä¸€ä¸ªæ ¹æ®å½“å‰æ–°æ¡¶+æ—§æ¡¶æ•°é‡åç§»çš„å“ªä¸ªæ¡¶xy[1]ï¼Œä¹Ÿä¿å­˜å…¶ä¸Šä¸‹æ–‡ã€‚æ¯”å¦‚å½“å‰keyçš„å“ˆå¸Œå¯¹åº”çš„æ—§æ¡¶æ˜¯3å·ï¼Œé‚£ä¹ˆxy[0]ä¹Ÿæ˜¯æ–°æ¡¶çš„3å·æ¡¶ï¼Œç„¶åxy[1]çš„æ¡¶å·å°±ä¸º3+æ—§æ¡¶çš„ä¸ªæ•°ã€æ¯”å¦‚7å·ã€‚</li>
<li>ç”±äºç¿»å€æ‰©å®¹æ—¶å½“å‰æ—§æ¡¶å¯¹åº”ä¸¤ä¸ªæ–°æ¡¶ï¼Œæ‰€ä»¥éœ€è¦é’ˆå¯¹å½“å‰æ—§æ¡¶ä¸­çš„keyåšé‡æ–°hashï¼Œé€‰æ‹©ä¸€ä¸ªç›®æ ‡æ¡¶å‡ºæ¥ï¼Œå³å½“å‰keyå¤„äº3å·æ¡¶ï¼Œç»è¿‡é‡æ–°å“ˆå¸Œåå¯èƒ½æ”¾åˆ°äº†7å·æ¡¶ï¼Œæ‰¾åˆ°ç›®æ ‡æ¡¶åï¼Œå°†å¯¹åº”çš„keyï¼Œvalueï¼Œtophashå¤åˆ¶è¿‡å»ï¼Œå®Œæˆä¸€ä¸ªkey-valueçš„æ¬è¿ã€‚ç„¶åå¾ªç¯æ­¤è¿‡ç¨‹ã€‚</li>
</ol>
</li>
<li>ç­‰é‡æ‰©å®¹æ¬è¿è¿‡ç¨‹ï¼š
<ol>
<li>ä¸ç¿»å€æ‰©å®¹ç›¸åŒï¼Œä½†åªä¿å­˜ä¸€ä¸ªæ–°æ¡¶çš„ä¸Šä¸‹æ–‡ï¼Œå› ä¸ºç­‰é‡æ‰©å®¹æ²¡æœ‰åˆ›å»ºæ›´å¤šçš„æ¡¶ï¼Œæ‰©å®¹æ˜¯å¯¹åº”çš„å…³ç³»ï¼Œå³å½“å‰çš„keyå¤„äº3å·æ¡¶ï¼Œæ¬è¿åä¹Ÿå±äº3å·æ¡¶ã€‚</li>
<li>å‰©ä½™è¿‡ç¨‹ä¸ç¿»å€æ‰©å®¹ç›¸åŒã€‚</li>
</ol>
</li>
<li>æ¬è¿å®Œæ¯•åï¼Œå°†æ—§æ¡¶åšä¸€äº›æ ‡è®°ä»¥ä¾¿å¯ä»¥gcæ¸…é™¤ï¼Œç„¶åå¦‚æœæ­¤æ¬¡æ¬è¿æ˜¯æŒ‰ç…§é¡ºåºæ¬è¿ï¼Œå³ h.nevacuateè®°å½•çš„æ¡¶æ¬è¿çš„ï¼Œåˆ™æ›´æ–° h.nevacuateåˆ°ä¸‹æ¬¡åº”è¯¥æ¬è¿çš„æ¡¶ä¸Šã€‚</li>
</ol>
</li>
</ol>
<p>æ‰©å®¹ä¸­:</p>
<ul>
<li>mapasssign:å°†å‘½ä¸­çš„ bucket ä» oldbuckets é¡ºæ‰‹æ¬è¿åˆ°buckets ä¸­ï¼Œé¡ºä¾¿å†å¤šæ¬è¿ä¸€ä¸ª bucket</li>
<li>mapdelete:å°†å‘½ä¸­çš„ bucket ä» oldbuckets é¡ºæ‰‹æ¬è¿åˆ°buckets ä¸­ï¼Œé¡ºä¾¿å†å¤šæ¬è¿ä¸€ä¸ª bucket</li>
<li>mapaccess: ä¼˜å…ˆåœ¨ oldbuckets ä¸­æ‰¾ï¼Œå¦‚æœå‘½ä¸­ï¼Œåˆ™è¯´æ˜è¿™ä¸ª bucket æ²¡æœ‰è¢«æ¬è¿</li>
<li>æ¬è¿ bucket x æ—¶ï¼Œä¼šè¢«è¯¥æ¡¶çš„ overflow æ¡¶ä¹Ÿä¸€å¹¶æ¬å®Œ</li>
</ul>
<h4 id="hashgrow">hashGrow<a hidden class="anchor" aria-hidden="true" href="#hashgrow">#</a></h4>
<p>æˆ‘ä»¬å…ˆçœ‹ hashGrow() å‡½æ•°æ‰€åšçš„å·¥ä½œï¼Œå†æ¥çœ‹å…·ä½“çš„æ¬è¿ buckets æ˜¯å¦‚ä½•è¿›è¡Œçš„ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// If we&#39;ve hit the load factor, get bigger.
</span><span class="c1"></span>	<span class="c1">// Otherwise, there are too many overflow buckets,
</span><span class="c1"></span>	<span class="c1">// so keep the same number of buckets and &#34;grow&#34; laterally.
</span><span class="c1"></span>	<span class="c1">// éœ€è¦æ‰©å®¹å¤šå°‘bmap
</span><span class="c1"></span>  	<span class="c1">// é»˜è®¤ä¸ºç¿»å€æ‰©å®¹
</span><span class="c1"></span>  	<span class="c1">// æ­¤æƒ…å†µä¸ºè£…è½½å› å­&gt;=6.5
</span><span class="c1"></span>	<span class="c1">// B+1 ç›¸å½“äºæ˜¯åŸæ¥ 2 å€çš„ç©ºé—´
</span><span class="c1"></span>	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="c1">// å¯¹åº”æ¡ä»¶ 2
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// è¿™é‡Œè¡¨ç¤ºæ˜¯æº¢å‡ºæ¡¶æ•°é‡æ•°é‡è¿‡å¤šï¼Œä½†æ˜¯mapä¸­å…ƒç´ æ•°é‡è¿˜è¾¾ä¸åˆ°è¿‡è½½ï¼Œåˆ™æ— éœ€å¢é•¿æ¡¶æ•°é‡
</span><span class="c1"></span>        	<span class="c1">// åˆ†é…ä¸€ä¸ªä¸ä¹‹å‰ä¸€æ ·çš„å³å¯ï¼Œå°†æ‰€æœ‰æ•°æ®æ‘Šå¹³ï¼Œå‡å°‘æº¢å‡ºæ¡¶çš„æ•°é‡
</span><span class="c1"></span>		<span class="c1">// è¿›è¡Œç­‰é‡çš„å†…å­˜æ‰©å®¹ï¼Œæ‰€ä»¥ B ä¸å˜
</span><span class="c1"></span>		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
	<span class="c1">// å°†è€ buckets æŒ‚åˆ° buckets ä¸Š
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="c1">// ç”³è¯·æ–°çš„ buckets ç©ºé—´
</span><span class="c1"></span>	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
	<span class="c1">// å¦‚æœå½“å‰çŠ¶æ€ä¸æ˜¯è¿­ä»£çŠ¶æ€
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// è®©è¿­ä»£çš„æ—¶å€™å»è¿­ä»£æ—§æ¡¶
</span><span class="c1"></span>    		<span class="c1">// å› ä¸ºè¿˜æ²¡æœ‰æ¬è¿å®Œæ¯•
</span><span class="c1"></span>		<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
	<span class="p">}</span>
	<span class="c1">// commit the grow (atomic wrt gc)
</span><span class="c1"></span>	<span class="c1">// æäº¤ grow çš„åŠ¨ä½œ
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">flags</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
	<span class="c1">// æ¬è¿è¿›åº¦ä¸º 0
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// overflow buckets æ•°ä¸º 0
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// å¦‚æœä¹‹å‰æœ‰æº¢å‡ºbmapçš„è¯ï¼ŒæŠŠåŸæ¥æ‰€æŒæœ‰çš„æº¢å‡ºbmapä¹Ÿå˜æˆæ—§çš„æº¢å‡ºbmap
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Promote current overflow buckets to the old generation.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// å¦‚æœæ‰©å®¹çš„æ–°bmapåˆ—è¡¨å­˜åœ¨å¯ç”¨æº¢å‡ºbmap
</span><span class="c1"></span>  	<span class="c1">// é‚£å°±è®¾ç½®ä¸€ä¸‹
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
	<span class="p">}</span>

	<span class="c1">// the actual copying of the hash table data is done incrementally
</span><span class="c1"></span>	<span class="c1">// by growWork() and evacuate().
</span><span class="c1"></span>	<span class="c1">// æ­¤å¤„æ²¡æœ‰å‘ç°æ‰©å®¹æ—¶çš„æ•°æ®æ¬è¿ï¼ˆä»æ—§bmapä¸­æ‹·è´åŸæ•°æ®åˆ°æ–°çš„bmapä¸­ï¼‰å·¥ä½œ
</span><span class="c1"></span> 	<span class="c1">// å› ä¸ºå“ˆå¸Œè¡¨æ•°æ®çš„å®é™…å¤åˆ¶æ˜¯ç”±growWork()å’Œevacuate()é€æ­¥å®Œæˆçš„ã€‚
</span><span class="c1"></span>  	<span class="c1">// è¿™ä¸¤ä¸ªå‡½æ•°çš„è§¦å‘æ—¶æœºæ˜¯åœ¨å†™/åˆ é™¤æ“ä½œæ—¶è§¦å‘
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ä¸»è¦æ˜¯ç”³è¯·åˆ°äº†æ–°çš„ buckets ç©ºé—´ï¼ŒæŠŠç›¸å…³çš„æ ‡å¿—ä½éƒ½è¿›è¡Œäº†å¤„ç†ï¼šä¾‹å¦‚æ ‡å¿— nevacuate è¢«ç½®ä¸º 0ï¼Œ è¡¨ç¤ºå½“å‰æ¬è¿è¿›åº¦ä¸º 0ã€‚</p>
<p>å“ˆå¸Œåœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ä¼šé€šè¿‡ <code>runtime.makeBucketArray</code> åˆ›å»ºä¸€ç»„æ–°æ¡¶å’Œé¢„åˆ›å»ºçš„æº¢å‡ºæ¡¶ï¼Œéšåå°†åŸæœ‰çš„æ¡¶æ•°ç»„è®¾ç½®åˆ° oldbuckets ä¸Šå¹¶å°†æ–°çš„ç©ºæ¡¶è®¾ç½®åˆ° buckets ä¸Šï¼Œæº¢å‡ºæ¡¶ä¹Ÿä½¿ç”¨äº†ç›¸åŒçš„é€»è¾‘æ›´æ–°ï¼Œä¸‹å›¾å±•ç¤ºäº†è§¦å‘æ‰©å®¹åçš„å“ˆå¸Œï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210702173217.png" alt=""  />
</p>
<p>æ‰©å®¹åŸºæœ¬é‡‡å–2*N + N/16çš„æ–¹å¼(2å€æ‰©å®¹)ï¼Œå¤šå‡ºæ¥çš„N/16ç”¨äºæ§½æ»¡çš„æƒ…å†µï¼Œæ–°å¢çš„èŠ‚ç‚¹å°±ä»è¿™å¤šå‡ºæ¥çš„åœ°æ–¹å–ï¼Œå¦‚æœå¤šå‡ºæ¥çš„æ§½ä¹Ÿç”¨å®Œäº†å°±ç›´æ¥newæ–°çš„å†…å­˜</p>
<p>å€¼å¾—ä¸€è¯´çš„æ˜¯å¯¹ h.flags çš„å¤„ç†ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>è¿™é‡Œå¾—å…ˆè¯´ä¸‹è¿ç®—ç¬¦ï¼š&amp;^ã€‚è¿™å«æŒ‰ä½ç½®0è¿ç®—ç¬¦ã€‚ä¾‹å¦‚ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">x</span> <span class="o">=</span> <span class="m">01010011</span>
<span class="n">y</span> <span class="o">=</span> <span class="m">01010100</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">^</span> <span class="n">y</span> <span class="o">=</span> <span class="m">00000011</span>
</code></pre></td></tr></table>
</div>
</div><p>å¦‚æœ y bit ä½ä¸º 1ï¼Œé‚£ä¹ˆç»“æœ z å¯¹åº” bit ä½å°±ä¸º 0ï¼Œå¦åˆ™ z å¯¹åº” bit ä½å°±å’Œ x å¯¹åº” bit ä½çš„å€¼ç›¸åŒã€‚</p>
<p>æ‰€ä»¥ä¸Šé¢é‚£æ®µå¯¹ flags ä¸€é¡¿æ“ä½œçš„ä»£ç çš„æ„æ€æ˜¯ï¼šå…ˆæŠŠ h.flags ä¸­ iterator å’Œ oldIterator å¯¹åº”ä½æ¸… 0ï¼Œç„¶åå¦‚æœå‘ç° iterator ä½ä¸º 1ï¼Œé‚£å°±æŠŠå®ƒè½¬æ¥åˆ° oldIterator ä½ï¼Œä½¿å¾— oldIterator æ ‡å¿—ä½å˜æˆ 1ã€‚æ½œå°è¯å°±æ˜¯ï¼šbuckets ç°åœ¨æŒ‚åˆ°äº† oldBuckets åä¸‹äº†ï¼Œå¯¹åº”çš„æ ‡å¿—ä½ä¹Ÿè½¬æ¥è¿‡å»å§ã€‚</p>
<h4 id="growwork">growWork<a hidden class="anchor" aria-hidden="true" href="#growwork">#</a></h4>
<p>å†æ¥çœ‹çœ‹çœŸæ­£æ‰§è¡Œæ¬è¿å·¥ä½œçš„ growWork() å‡½æ•°ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// make sure we evacuate the oldbucket corresponding
</span><span class="c1"></span>	<span class="c1">// to the bucket we&#39;re about to use
</span><span class="c1"></span>	<span class="c1">// ç¡®è®¤æ¬è¿è€çš„ bucket å¯¹åº”æ­£åœ¨ä½¿ç”¨çš„ bucket
</span><span class="c1"></span>	<span class="c1">// è¦ç¡®ä¿æˆ‘ä»¬è¿ç§»çš„æ¡¶å’Œå½“å‰ç”¨çš„æ¡¶æ˜¯ä¸€è‡´çš„
</span><span class="c1"></span>	<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>

	<span class="c1">// evacuate one more oldbucket to make progress on growing
</span><span class="c1"></span>	<span class="c1">// å¦‚æœæ¬å®Œäº†ä¸€ä¸ªä¹‹åå‘ç°è¿˜æ²¡æ¬è¿å®Œ
</span><span class="c1"></span>  	<span class="c1">// å°±å†æ¬ä¸€ä¸ª
</span><span class="c1"></span>	<span class="c1">// è¿›è¡Œè¾…åŠ©è¿ç§»ï¼Œå½“å‰æ¡¶è¿ç§»å®ŒæˆæŸ¥çœ‹mapæ˜¯å¦è¿˜åœ¨æ‰©å®¹è¿‡ç¨‹ä¸­ï¼Œå¹¶å¸®åŠ©è¿›è¡Œè¿ç§»
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// oldbucketmask provides a mask that can be applied to calculate n % noldbuckets().
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">oldbucketmask</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>h.growing() å‡½æ•°éå¸¸ç®€å•ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// growing reports whether h is growing. The growth may be to the same size or bigger.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">growing</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="o">!=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>å¦‚æœ oldbuckets ä¸ä¸ºç©ºï¼Œè¯´æ˜è¿˜æ²¡æœ‰æ¬è¿å®Œæ¯•ï¼Œè¿˜å¾—ç»§ç»­æ¬ã€‚</p>
<p><code>bucket&amp;h.oldbucketmask()</code> è¿™è¡Œä»£ç ï¼Œå¦‚æºç æ³¨é‡Šé‡Œè¯´çš„ï¼Œæ˜¯ä¸ºäº†ç¡®è®¤æ¬è¿çš„ bucket æ˜¯æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„ <code>bucket.oldbucketmask()</code> å‡½æ•°è¿”å›æ‰©å®¹å‰çš„ map çš„ bucketmaskã€‚</p>
<p>æ‰€è°“çš„ bucketmaskï¼Œä½œç”¨å°±æ˜¯å°† key è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ä¸ bucketmask ç›¸ä¸ï¼Œå¾—åˆ°çš„ç»“æœå°±æ˜¯ key åº”è¯¥è½å…¥çš„æ¡¶ã€‚æ¯”å¦‚ B = 5ï¼Œé‚£ä¹ˆ bucketmask çš„ä½ 5 ä½æ˜¯ 11111ï¼Œå…¶ä½™ä½æ˜¯ 0ï¼Œhash å€¼ä¸å…¶ç›¸ä¸çš„æ„æ€æ˜¯ï¼Œåªæœ‰ hash å€¼çš„ä½ 5 ä½å†³ç­– key åˆ°åº•è½å…¥å“ªä¸ª bucketã€‚</p>
<h4 id="evacuate">evacuate<a hidden class="anchor" aria-hidden="true" href="#evacuate">#</a></h4>
<p>æ¬è¿çš„ç›®çš„å°±æ˜¯å°†è€çš„ buckets æ¬è¿åˆ°æ–°çš„ bucketsã€‚è€Œé€šè¿‡å‰é¢çš„è¯´æ˜æˆ‘ä»¬çŸ¥é“ï¼Œåº”å¯¹æ¡ä»¶ 1ï¼Œæ–°çš„ buckets æ•°é‡æ˜¯ä¹‹å‰çš„ä¸€å€ï¼Œåº”å¯¹æ¡ä»¶ 2ï¼Œæ–°çš„ buckets æ•°é‡å’Œä¹‹å‰ç›¸ç­‰ã€‚</p>
<p>å¯¹äºæ¡ä»¶ 2ï¼Œä»è€çš„ buckets æ¬è¿åˆ°æ–°çš„ bucketsï¼Œç”±äº bucktes æ•°é‡ä¸å˜ï¼Œå› æ­¤å¯ä»¥æŒ‰åºå·æ¥æ¬ï¼Œæ¯”å¦‚åŸæ¥åœ¨ 0 å· bucktesï¼Œåˆ°æ–°çš„åœ°æ–¹åï¼Œä»ç„¶æ”¾åœ¨ 0 å· bucketsã€‚</p>
<p>å¯¹äºæ¡ä»¶ 1ï¼Œå°±æ²¡è¿™ä¹ˆç®€å•äº†ã€‚è¦é‡æ–°è®¡ç®— key çš„å“ˆå¸Œï¼Œæ‰èƒ½å†³å®šå®ƒåˆ°åº•è½åœ¨å“ªä¸ª bucketã€‚ä¾‹å¦‚ï¼ŒåŸæ¥ B = 5ï¼Œè®¡ç®—å‡º key çš„å“ˆå¸Œåï¼Œåªç”¨çœ‹å®ƒçš„ä½ 5 ä½ï¼Œå°±èƒ½å†³å®šå®ƒè½åœ¨å“ªä¸ª bucketã€‚æ‰©å®¹åï¼ŒB å˜æˆäº† 6ï¼Œå› æ­¤éœ€è¦å¤šçœ‹ä¸€ä½ï¼Œå®ƒçš„ä½ 6 ä½å†³å®š key è½åœ¨å“ªä¸ª bucketã€‚è¿™ç§°ä¸º rehashã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703163909.png" alt=""  />
</p>
<p>å› æ­¤ï¼ŒæŸä¸ª key åœ¨æ¬è¿å‰å bucket åºå·å¯èƒ½å’ŒåŸæ¥ç›¸ç­‰ï¼Œä¹Ÿå¯èƒ½æ˜¯ç›¸æ¯”åŸæ¥åŠ ä¸Š 2^Bï¼ˆåŸæ¥çš„ B å€¼ï¼‰ï¼Œå–å†³äº hash å€¼ ç¬¬ 6 bit ä½æ˜¯ 0 è¿˜æ˜¯ 1ã€‚</p>
<p>ç†è§£äº†ä¸Šé¢ bucket åºå·çš„å˜åŒ–ï¼Œæˆ‘ä»¬å°±å¯ä»¥å›ç­”å¦ä¸€ä¸ªé—®é¢˜äº†ï¼šä¸ºä»€ä¹ˆéå† map æ˜¯æ— åºçš„ï¼Ÿ</p>
<p>map åœ¨æ‰©å®¹åï¼Œä¼šå‘ç”Ÿ key çš„æ¬è¿ï¼ŒåŸæ¥è½åœ¨åŒä¸€ä¸ª bucket ä¸­çš„ keyï¼Œæ¬è¿åï¼Œæœ‰äº› key å°±è¦è¿œèµ°é«˜é£äº†ï¼ˆbucket åºå·åŠ ä¸Šäº† 2^Bï¼‰ã€‚è€Œéå†çš„è¿‡ç¨‹ï¼Œå°±æ˜¯æŒ‰é¡ºåºéå† bucketï¼ŒåŒæ—¶æŒ‰é¡ºåºéå† bucket ä¸­çš„ keyã€‚æ¬è¿åï¼Œkey çš„ä½ç½®å‘ç”Ÿäº†é‡å¤§çš„å˜åŒ–ï¼Œæœ‰äº› key é£ä¸Šé«˜æï¼Œæœ‰äº› key åˆ™åŸåœ°ä¸åŠ¨ã€‚è¿™æ ·ï¼Œéå† map çš„ç»“æœå°±ä¸å¯èƒ½æŒ‰åŸæ¥çš„é¡ºåºäº†ã€‚</p>
<p>å½“ç„¶ï¼Œå¦‚æœæˆ‘å°±ä¸€ä¸ª hard code çš„ mapï¼Œæˆ‘ä¹Ÿä¸ä¼šå‘ map è¿›è¡Œæ’å…¥åˆ é™¤çš„æ“ä½œï¼ŒæŒ‰ç†è¯´æ¯æ¬¡éå†è¿™æ ·çš„ map éƒ½ä¼šè¿”å›ä¸€ä¸ªå›ºå®šé¡ºåºçš„ key/value åºåˆ—å§ã€‚çš„ç¡®æ˜¯è¿™æ ·ï¼Œä½†æ˜¯ Go æœç»äº†è¿™ç§åšæ³•ï¼Œå› ä¸ºè¿™æ ·ä¼šç»™æ–°æ‰‹ç¨‹åºå‘˜å¸¦æ¥è¯¯è§£ï¼Œä»¥ä¸ºè¿™æ˜¯ä¸€å®šä¼šå‘ç”Ÿçš„äº‹æƒ…ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šé…¿æˆå¤§é”™ã€‚</p>
<p>å½“ç„¶ï¼ŒGo åšå¾—æ›´ç»ï¼Œå½“æˆ‘ä»¬åœ¨éå† map æ—¶ï¼Œå¹¶ä¸æ˜¯å›ºå®šåœ°ä» 0 å· bucket å¼€å§‹éå†ï¼Œæ¯æ¬¡éƒ½æ˜¯ä»ä¸€ä¸ªéšæœºå€¼åºå·çš„ bucket å¼€å§‹éå†ï¼Œå¹¶ä¸”æ˜¯ä»è¿™ä¸ª bucket çš„ä¸€ä¸ªéšæœºåºå·çš„ cell å¼€å§‹éå†ã€‚è¿™æ ·ï¼Œå³ä½¿ä½ æ˜¯ä¸€ä¸ªå†™æ­»çš„ mapï¼Œä»…ä»…åªæ˜¯éå†å®ƒï¼Œä¹Ÿä¸å¤ªå¯èƒ½ä¼šè¿”å›ä¸€ä¸ªå›ºå®šåºåˆ—çš„ key/value å¯¹äº†ã€‚</p>
<p>å¤šè¯´ä¸€å¥ï¼Œâ€œè¿­ä»£ map çš„ç»“æœæ˜¯æ— åºçš„â€è¿™ä¸ªç‰¹æ€§æ˜¯ä» go 1.0 å¼€å§‹åŠ å…¥çš„ã€‚</p>
<p>å†æ˜ç¡®ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœæ‰©å®¹åï¼ŒB å¢åŠ äº† 1ï¼Œæ„å‘³ç€ buckets æ€»æ•°æ˜¯åŸæ¥çš„ 2 å€ï¼ŒåŸæ¥ 1 å·çš„æ¡¶â€œè£‚å˜â€åˆ°ä¸¤ä¸ªæ¡¶ã€‚</p>
<p>ä¾‹å¦‚ï¼ŒåŸå§‹ B = 2ï¼Œ1å· bucket ä¸­æœ‰ 2 ä¸ª key çš„å“ˆå¸Œå€¼ä½ 3 ä½åˆ†åˆ«ä¸ºï¼š010ï¼Œ110ã€‚ç”±äºåŸæ¥ B = 2ï¼Œæ‰€ä»¥ä½ 2 ä½ 10 å†³å®šå®ƒä»¬è½åœ¨ 2 å·æ¡¶ï¼Œç°åœ¨ B å˜æˆ 3ï¼Œæ‰€ä»¥ 010ã€110 åˆ†åˆ«è½å…¥ 2ã€6 å·æ¡¶ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703164721.png" alt=""  />
</p>
<p>ç†è§£äº†è¿™ä¸ªï¼Œåé¢è®² map è¿­ä»£çš„æ—¶å€™ä¼šç”¨åˆ°ã€‚</p>
<p>æºç å¦‚ä¸‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// evacDst is an evacuation destination.
</span><span class="c1">//  ç”¨äºä¿å­˜åˆ†é…ä¸Šä¸‹æ–‡çš„ç»“æ„ä½“
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">evacDst</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// è¡¨ç¤ºbucket ç§»åŠ¨çš„ç›®æ ‡åœ°å€
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span>          <span class="c1">// current destination bucket
</span><span class="c1"></span>	<span class="c1">// æŒ‡å‘ x,y ä¸­çš„ key/val
</span><span class="c1"></span>	<span class="nx">i</span> <span class="kt">int</span>            <span class="c1">// key/elem index into b
</span><span class="c1"></span>	<span class="c1">// æŒ‡å‘ xï¼Œy ä¸­çš„ key
</span><span class="c1"></span>	<span class="nx">k</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// pointer to current key storage
</span><span class="c1"></span>	<span class="c1">// æŒ‡å‘ xï¼Œy ä¸­çš„ value
</span><span class="c1"></span>	<span class="nx">e</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// pointer to current elem storage
</span><span class="c1"></span><span class="p">}</span>
 <span class="c1">// å®é™…çš„æ—§bmap æ¬è¿åˆ°æ–°bmapçš„é€»è¾‘
</span><span class="c1"></span> <span class="c1">// ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯æ¬è¿çš„é‚£ä¸ªæ¡¶
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// å®šä½è€çš„ bucket åœ°å€
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="c1">// ç»“æœæ˜¯ 2^Bï¼Œå¦‚ B = 5ï¼Œç»“æœä¸º32
</span><span class="c1"></span>	<span class="c1">// ç®—ä¸€ä¸‹ä¹‹å‰æœ‰å¤šå°‘ä¸ªæ¡¶
</span><span class="c1"></span>	<span class="nx">newbit</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span>
	<span class="c1">// å¦‚æœ b æ²¡æœ‰è¢«æ¬è¿è¿‡
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: reuse overflow buckets instead of using new ones, if there
</span><span class="c1"></span>		<span class="c1">// is no iterator using the old buckets.  (If !oldIterator.)
</span><span class="c1"></span>
		<span class="c1">// xy contains the x and y (low and high) evacuation destinations.
</span><span class="c1"></span>		<span class="c1">// è¿™é‡Œåˆ†ä¸ºXåŒºå’ŒYåŒºï¼Œå³ä½ä½åŒºå’Œé«˜ä½åŒºï¼Œæ‰©å®¹ä¹‹åæ¡¶å®¹é‡ç¿»å€ï¼Œéœ€è¦æŠŠåŸæœ‰æ•°æ®
</span><span class="c1"></span>        	<span class="c1">// å‡åŒ€çš„åˆ†æ•£åœ¨è¿™ä¸¤ä¸ªåŒºåŸŸ
</span><span class="c1"></span>		<span class="c1">// è¡¨ç¤ºbucket ç§»åŠ¨çš„ç›®æ ‡åœ°å€
</span><span class="c1"></span>		<span class="c1">// ç”Ÿæˆä¸¤ä¸ªç”¨äºä¿å­˜æ–°æ¡¶ä¸Šä¸‹æ–‡çš„ç»“æ„ä½“
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">xy</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">evacDst</span>
		<span class="c1">// å…ˆä¿å­˜ä¸€ä¸ª æ–°bmapçš„ä¸Šä¸‹æ–‡ä¿¡æ¯
</span><span class="c1"></span>		<span class="nx">x</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// é»˜è®¤æ˜¯ç­‰ size æ‰©å®¹ï¼Œå‰å bucket åºå·ä¸å˜
</span><span class="c1"></span>		<span class="c1">// ä½¿ç”¨ x æ¥è¿›è¡Œæ¬è¿
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="c1">// å¦‚æœä¸æ˜¯ç­‰ size æ‰©å®¹ï¼Œå‰å bucket åºå·æœ‰å˜
</span><span class="c1"></span>		<span class="c1">// ä½¿ç”¨ y æ¥è¿›è¡Œæ¬è¿
</span><span class="c1"></span>		<span class="c1">// å¦‚æœå½“å‰ä¸æ˜¯ç­‰é‡æ‰©å®¹ï¼ˆæ•´ç†ï¼‰
</span><span class="c1"></span>    		<span class="c1">// é‚£ä¹ˆå°±æ¬ä¸¤ä¸ªæ¡¶
</span><span class="c1"></span>    		<span class="c1">// å†è·å–ä¸€ä¸ªæ–°çš„bmapçš„ä¸Šä¸‹æ–‡ä¿¡æ¯
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Only calculate y pointers if we&#39;re growing bigger.
</span><span class="c1"></span>			<span class="c1">// Otherwise GC can see bad pointers.
</span><span class="c1"></span>			<span class="c1">// y ä»£è¡¨çš„ bucket åºå·å¢åŠ äº† 2^B
</span><span class="c1"></span>			<span class="c1">// ä»…ä»…åœ¨mapå®¹é‡ç¿»å€ä¹‹åå†è®¡ç®—YåŒºçš„åœ°å€ï¼Œå¦åˆ™GCä¼šçœ‹åˆ°ä¸€ä¸ªä¸å­˜åœ¨çš„æŒ‡é’ˆã€‚
</span><span class="c1"></span>			<span class="nx">y</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">oldbucket</span><span class="o">+</span><span class="nx">newbit</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="c1">// éå†æ‰€æœ‰çš„ bucketï¼ŒåŒ…æ‹¬ overflow buckets
</span><span class="c1"></span>		<span class="c1">// b æ˜¯è€çš„ bucket åœ°å€
</span><span class="c1"></span>		<span class="c1">// å¾ªç¯å½“å‰éœ€è¦æ¬è¿çš„bmapåŠå…¶æº¢å‡ºbmap
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// æ‰¾åˆ°ç¬¬ä¸€ä¸ªkeyå’Œå¯¹åº”çš„valueçš„åœ°å€
</span><span class="c1"></span>			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="c1">// éå† bucket ä¸­çš„æ‰€æœ‰ cell
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span> <span class="p">{</span>
				<span class="c1">// å½“å‰ cell çš„ top hash å€¼
</span><span class="c1"></span>				<span class="nx">top</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="c1">// å¦‚æœ cell ä¸ºç©ºï¼Œå³æ²¡æœ‰ key
</span><span class="c1"></span>				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">top</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// é‚£å°±æ ‡å¿—å®ƒè¢«&#34;æ¬è¿&#34;è¿‡
</span><span class="c1"></span>					<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedEmpty</span>
					<span class="c1">// ç»§ç»­ä¸‹ä¸ª cell
</span><span class="c1"></span>					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="c1">// æ­£å¸¸ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µ
</span><span class="c1"></span>				<span class="c1">// æœªè¢«æ¬è¿çš„ cell åªå¯èƒ½æ˜¯ empty æˆ–æ˜¯
</span><span class="c1"></span>				<span class="c1">// æ­£å¸¸çš„ top hashï¼ˆå¤§äº minTopHashï¼‰
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad map state&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">k2</span> <span class="o">:=</span> <span class="nx">k</span>
				<span class="c1">// å¦‚æœ key æ˜¯æŒ‡é’ˆï¼Œåˆ™è§£å¼•ç”¨
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">k2</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k2</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="kd">var</span> <span class="nx">useY</span> <span class="kt">uint8</span>
				<span class="c1">// å¦‚æœä¸æ˜¯ç­‰é‡æ‰©å®¹
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// Compute hash to make our evacuation decision (whether we need
</span><span class="c1"></span>					<span class="c1">// to send this key/elem to bucket x or bucket y).
</span><span class="c1"></span>					<span class="c1">// é‚£ä¹ˆå°±éœ€è¦é‡æ–°è®¡ç®—å½“å‰è¿™ä¸ªkeyåº”è¯¥è½åˆ°xy[0]è¿˜æ˜¯xy[1]è¿™ä¸¤ä¸ªæ–°æ¡¶çš„å“ªä¸ªä¸­å»
</span><span class="c1"></span>          				<span class="c1">// å› ä¸ºç­‰é‡æ‰©å®¹æ˜¯æ•´ç†ï¼Œæ¡¶çš„æ•°é‡å¹¶æ²¡æœ‰å¢åŠ ï¼Œæ‰€ä»¥åŸæ¥åœ¨å“ªè¿˜æ˜¯åœ¨å“ª
</span><span class="c1"></span>          				<span class="c1">// ä½†æ˜¯ç¿»å€æ‰©å®¹åˆ™æ˜¯å¢åŠ äº†æ–°çš„æ¡¶ï¼Œå°±éœ€è¦é‡æ–°è®¡ç®—hash
</span><span class="c1"></span>          				<span class="c1">// ä¹Ÿå°±æ˜¯è¯´ç¿»å€æ‰©å®¹å¯èƒ½å¯¼è‡´å½“å‰keyçš„å“ˆå¸Œå€¼å’Œä¹‹åçš„ä¸æ˜¯åŒä¸€ä¸ª
</span><span class="c1"></span>					<span class="c1">// è®¡ç®— hash å€¼ï¼Œå’Œ key ç¬¬ä¸€æ¬¡å†™å…¥æ—¶ä¸€æ ·
</span><span class="c1"></span>					<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
					<span class="c1">// å¦‚æœæœ‰åç¨‹æ­£åœ¨éå† map
</span><span class="c1"></span>					<span class="c1">// å¦‚æœå‡ºç° ç›¸åŒçš„ key å€¼ï¼Œç®—å‡ºæ¥çš„ hash å€¼ä¸åŒ
</span><span class="c1"></span>					<span class="c1">// è¿™ä¸ªæ˜¯è®¡ç®—åˆ°åº•è¯¥æŠŠå½“å‰çš„key-value æ”¾åˆ°xy[0]è¿˜æ˜¯xy[1]
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
						<span class="c1">// åªæœ‰åœ¨ float å˜é‡çš„ NaN() æƒ…å†µä¸‹ä¼šå‡ºç°
</span><span class="c1"></span>						<span class="c1">// If key != key (NaNs), then the hash could be (and probably
</span><span class="c1"></span>						<span class="c1">// will be) entirely different from the old hash. Moreover,
</span><span class="c1"></span>						<span class="c1">// it isn&#39;t reproducible. Reproducibility is required in the
</span><span class="c1"></span>						<span class="c1">// presence of iterators, as our evacuation decision must
</span><span class="c1"></span>						<span class="c1">// match whatever decision the iterator made.
</span><span class="c1"></span>						<span class="c1">// Fortunately, we have the freedom to send these keys either
</span><span class="c1"></span>						<span class="c1">// way. Also, tophash is meaningless for these kinds of keys.
</span><span class="c1"></span>						<span class="c1">// We let the low bit of tophash drive the evacuation decision.
</span><span class="c1"></span>						<span class="c1">// We recompute a new random tophash for the next level so
</span><span class="c1"></span>						<span class="c1">// these keys will get evenly distributed across all buckets
</span><span class="c1"></span>						<span class="c1">// after multiple grows.
</span><span class="c1"></span>                        			<span class="c1">// key != keyï¼Œåªæœ‰åœ¨ float æ•°çš„ NaN æ—¶ä¼šå‡ºç°
</span><span class="c1"></span>                        			<span class="c1">// æ¯”å¦‚:
</span><span class="c1"></span>                        			<span class="c1">// n1 := math.NaN()
</span><span class="c1"></span>                        			<span class="c1">// n2 := math.NaN()
</span><span class="c1"></span>                        			<span class="c1">// è¿™ç§æƒ…å†µä¸‹ n1 å’Œ n2 çš„å“ˆå¸Œå€¼ä¹Ÿå®Œå…¨ä¸ä¸€æ ·ï¼Œ
</span><span class="c1"></span>                        			<span class="c1">// åŒæ—¶ tophash å¯¹äº NaN ä¹Ÿæ²¡å•¥æ„ä¹‰
</span><span class="c1"></span>                        			<span class="c1">// æ‰€ä»¥å¯¹äºè¿™ç§ key æˆ‘ä»¬ä¹Ÿå¯ä»¥éšæ„å¯¹å…¶ç›®æ ‡è¿›è¡Œå‘é…
</span><span class="c1"></span>                        			<span class="c1">// è¿˜æ˜¯æŒ‰æ­£å¸¸çš„æƒ…å†µä¸‹ç®—ä¸€ä¸ªéšæœºçš„ tophash
</span><span class="c1"></span>                        			<span class="c1">// ç„¶åå…¬å¹³åœ°æŠŠè¿™äº› key å¹³å‡åˆ†å¸ƒåˆ°å„ bucket å°±å¥½
</span><span class="c1"></span>						<span class="nx">useY</span> <span class="p">=</span> <span class="nx">top</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="c1">// ä¿è¯è¿™ä¸ªkeyæœ‰ä¸€åŠçš„å‡ ç‡è½åˆ°YåŒºï¼Œéšæœºå‘é…
</span><span class="c1"></span>						<span class="nx">top</span> <span class="p">=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="c1">// ä¾‹å¦‚newbit=8ï¼Œå…¶äºŒè¿›åˆ¶å³1000ï¼Œå¦‚æœhash&amp;1000!=0,åˆ™ç¬¬å››ä½å¿…é¡»ä¸ä¸º0
</span><span class="c1"></span>                        			<span class="c1">// å³xxxx1xxxï¼Œåˆ™åœ¨ç¿»å€æ‰©å®¹åï¼Œæ¡¶ä½ç½®è‚¯å®šæ˜¯oldsize+hash
</span><span class="c1"></span>						<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nx">newbit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
							<span class="nx">useY</span> <span class="p">=</span> <span class="mi">1</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="nx">evacuatedX</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="o">||</span> <span class="nx">evacuatedX</span><span class="p">^</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">evacuatedY</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad evacuatedN&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// æ ‡å¿—è€çš„ cell çš„ top hash å€¼ï¼Œè¡¨ç¤ºæ¬ç§»åˆ° X éƒ¨åˆ†
</span><span class="c1"></span>				<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">evacuatedX</span> <span class="o">+</span> <span class="nx">useY</span> <span class="c1">// evacuatedX + 1 == evacuatedY
</span><span class="c1"></span>				<span class="nx">dst</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="nx">useY</span><span class="p">]</span>                 <span class="c1">// evacuation destination
</span><span class="c1"></span>				<span class="c1">// å¦‚æœ xi ç­‰äº 8ï¼Œè¯´æ˜è¦æº¢å‡ºäº†
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">bucketCnt</span> <span class="p">{</span>
					<span class="c1">// å½“å‰æ¡¶è£…æ»¡äº†ï¼Œåˆ™éœ€è¦åˆ†é…ä¸€ä¸ªæº¢å‡ºæ¡¶è®©å…¶ä½¿ç”¨
</span><span class="c1"></span>					<span class="c1">// æ–°å»ºä¸€ä¸ª bucket
</span><span class="c1"></span>					<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
					<span class="c1">// ä» 0 å¼€å§‹è®¡æ•°
</span><span class="c1"></span>					<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
					<span class="c1">// è¡¨ç¤º key è¦ç§»åŠ¨åˆ°çš„ä½ç½®
</span><span class="c1"></span>					<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
					<span class="c1">// è¡¨ç¤º value è¦ç§»åŠ¨åˆ°çš„ä½ç½®
</span><span class="c1"></span>					<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="c1">// è®¾ç½® top hash å€¼
</span><span class="c1"></span>				<span class="nx">dst</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">bucketCnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">top</span> <span class="c1">// mask dst.i as an optimization, to avoid a bounds check
</span><span class="c1"></span>				<span class="c1">// key æ˜¯æŒ‡é’ˆ
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// å°†åŸ keyï¼ˆæ˜¯æŒ‡é’ˆï¼‰å¤åˆ¶åˆ°æ–°ä½ç½®
</span><span class="c1"></span>					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="nx">k2</span> <span class="c1">// copy pointer
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// å°†åŸ keyï¼ˆæ˜¯å€¼ï¼‰å¤åˆ¶åˆ°æ–°ä½ç½®
</span><span class="c1"></span>					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="c1">// copy elem
</span><span class="c1"></span>				<span class="p">}</span>
				<span class="c1">// value æ˜¯æŒ‡é’ˆï¼Œæ“ä½œåŒ key
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// å®šä½åˆ°ä¸‹ä¸€ä¸ª cell
</span><span class="c1"></span>				<span class="nx">dst</span><span class="p">.</span><span class="nx">i</span><span class="o">++</span>
				<span class="c1">// These updates might push these pointers past the end of the
</span><span class="c1"></span>				<span class="c1">// key or elem arrays.  That&#39;s ok, as we have the overflow pointer
</span><span class="c1"></span>				<span class="c1">// at the end of the bucket to protect against pointing past the
</span><span class="c1"></span>				<span class="c1">// end of the bucket.
</span><span class="c1"></span>				<span class="nx">dst</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
				<span class="nx">dst</span><span class="p">.</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">dst</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// Unlink the overflow buckets &amp; clear key/elem to help GC.
</span><span class="c1"></span>		<span class="c1">// å¦‚æœæ²¡æœ‰åç¨‹åœ¨ä½¿ç”¨è€çš„ bucketsï¼Œå°±æŠŠè€ buckets æ¸…é™¤æ‰ï¼Œå¸®åŠ©gc
</span><span class="c1"></span>		<span class="c1">// æŠŠæ¬å®Œäº†çš„æ—§æ¡¶åšä¸€äº›æ ‡è®°ä»¥ä¾¿ç­‰å¾…gcæ¸…é™¤
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">oldIterator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">))</span>
			<span class="c1">// Preserve b.tophash because the evacuation
</span><span class="c1"></span>			<span class="c1">// state is maintained there.
</span><span class="c1"></span>			<span class="c1">// åªæ¸…é™¤bucket çš„ key,value éƒ¨åˆ†ï¼Œä¿ç•™ top hash éƒ¨åˆ†ï¼ŒæŒ‡ç¤ºæ¬è¿çŠ¶æ€
</span><span class="c1"></span>			<span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span> <span class="o">-</span> <span class="nx">dataOffset</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// æ›´æ–°æ¬è¿è¿›åº¦
</span><span class="c1"></span>	<span class="c1">// å¦‚æœæ­¤æ¬¡æ¬è¿çš„ bucket ç­‰äºå½“å‰è¿›åº¦
</span><span class="c1"></span>	<span class="c1">// è¾…åŠ©æ¸…ç†
</span><span class="c1"></span>	<span class="c1">// å¦‚æœæ­¤æ¬¡æ¬è¿æ˜¯æŒ‰ç…§ h.nevacuateçš„æ¬è¿åˆ™
</span><span class="c1"></span>	<span class="c1">// åšä¸ªæ ‡è®°ï¼Œä»£è¡¨ä¸‹ä¸€æ¬¡è¦æ¬è¿çš„æ¡¶æ˜¯å“ªä¸ª
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">oldbucket</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">{</span>
		<span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">newbit</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">newbit</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// è¿›åº¦åŠ  1
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
	<span class="c1">// Experiments suggest that 1024 is overkill by at least an order of magnitude.
</span><span class="c1"></span>	<span class="c1">// Put it in there as a safeguard anyway, to ensure O(1) behavior.
</span><span class="c1"></span>	<span class="c1">// å°è¯•å¾€åçœ‹ 1024 ä¸ª bucket
</span><span class="c1"></span>	<span class="nx">stop</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">+</span> <span class="mi">1024</span>
	<span class="k">if</span> <span class="nx">stop</span> <span class="p">&gt;</span> <span class="nx">newbit</span> <span class="p">{</span>
		<span class="nx">stop</span> <span class="p">=</span> <span class="nx">newbit</span>
	<span class="p">}</span>
	<span class="c1">// å¯»æ‰¾æ²¡æœ‰æ¬è¿çš„ bucket
</span><span class="c1"></span>	<span class="c1">// åˆ¤æ–­å½“å‰bucketçš„tophashçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦å·²ç»è¢«è¿ç§»ï¼Œå¦‚æœå·²ç»è¿ç§»ï¼Œåˆ™è‡ªå¢
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">!=</span> <span class="nx">stop</span> <span class="o">&amp;&amp;</span> <span class="nf">bucketEvacuated</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="c1">// ç°åœ¨ h.nevacuate ä¹‹å‰çš„ bucket éƒ½è¢«æ¬è¿å®Œæ¯•
</span><span class="c1"></span>
	<span class="c1">// æ‰€æœ‰çš„ buckets æ¬è¿å®Œæ¯•
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="o">==</span> <span class="nx">newbit</span> <span class="p">{</span> <span class="c1">// newbit == # of oldbuckets
</span><span class="c1"></span>		<span class="c1">// Growing is all done. Free old main bucket array.
</span><span class="c1"></span>		<span class="c1">// æ‰€æœ‰éƒ½å·²ç»è¿ç§»å®Œæ¯•ï¼Œåˆ™å°†oldbucketsç½®ç©º
</span><span class="c1"></span>		<span class="c1">// æ¸…é™¤è€çš„ buckets
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="c1">// Can discard old overflow buckets as well.
</span><span class="c1"></span>		<span class="c1">// If they are still referenced by an iterator,
</span><span class="c1"></span>		<span class="c1">// then the iterator holds a pointers to the slice.
</span><span class="c1"></span>		<span class="c1">// æ¸…é™¤è€çš„ overflow bucket
</span><span class="c1"></span>		<span class="c1">// å›å¿†ä¸€ä¸‹ï¼š[0] è¡¨ç¤ºå½“å‰ overflow bucket
</span><span class="c1"></span>		<span class="c1">// [1] è¡¨ç¤º old overflow bucket
</span><span class="c1"></span>		<span class="c1">// ä¸¢å¼ƒæ‰è€çš„æº¢å‡ºæ¡¶ï¼Œå¦‚æœå®ƒä»¬è¿˜åœ¨è¢«è¿­ä»£å™¨å¼•ç”¨ï¼Œæ­¤æ—¶è¿­ä»£å™¨åªæ˜¯å¼•ç”¨ä¸€ä¸ªåˆ‡ç‰‡çš„æŒ‡é’ˆ
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// æ¸…é™¤æ­£åœ¨æ‰©å®¹çš„æ ‡å¿—ä½
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>evacuate å‡½æ•°æ¯æ¬¡åªå®Œæˆä¸€ä¸ª bucket çš„æ¬è¿å·¥ä½œï¼Œå› æ­¤è¦éå†å®Œæ­¤ bucket çš„æ‰€æœ‰çš„ cellï¼Œå°†æœ‰å€¼çš„ cell copy åˆ°æ–°çš„åœ°æ–¹ã€‚bucket è¿˜ä¼šé“¾æ¥ overflow bucketï¼Œå®ƒä»¬åŒæ ·éœ€è¦æ¬è¿ã€‚å› æ­¤ä¼šæœ‰ 2 å±‚å¾ªç¯ï¼Œå¤–å±‚éå† bucket å’Œ overflow bucketï¼Œå†…å±‚éå† bucket çš„æ‰€æœ‰ cellã€‚è¿™æ ·çš„å¾ªç¯åœ¨ map çš„æºç é‡Œåˆ°å¤„éƒ½æ˜¯ï¼Œè¦ç†è§£é€äº†ã€‚</p>
<p>æœ‰ä¸€ä¸ªç‰¹æ®Šæƒ…å†µæ˜¯ï¼šæœ‰ä¸€ç§ keyï¼Œæ¯æ¬¡å¯¹å®ƒè®¡ç®— hashï¼Œå¾—åˆ°çš„ç»“æœéƒ½ä¸ä¸€æ ·ã€‚è¿™ä¸ª key å°±æ˜¯ <code>math.NaN()</code> çš„ç»“æœï¼Œå®ƒçš„å«ä¹‰æ˜¯ not a numberï¼Œç±»å‹æ˜¯ float64ã€‚å½“å®ƒä½œä¸º map çš„ keyï¼Œåœ¨æ¬è¿çš„æ—¶å€™ï¼Œä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼šå†æ¬¡è®¡ç®—å®ƒçš„å“ˆå¸Œå€¼å’Œå®ƒå½“åˆæ’å…¥ map æ—¶çš„è®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ä¸ä¸€æ ·ï¼</p>
<p>ä½ å¯èƒ½æƒ³åˆ°äº†ï¼Œè¿™æ ·å¸¦æ¥çš„ä¸€ä¸ªåæœæ˜¯ï¼Œè¿™ä¸ª key æ˜¯æ°¸è¿œä¸ä¼šè¢« Get æ“ä½œè·å–çš„ï¼å½“æˆ‘ä½¿ç”¨ <code>m[math.NaN()]</code> è¯­å¥çš„æ—¶å€™ï¼Œæ˜¯æŸ¥ä¸å‡ºæ¥ç»“æœçš„ã€‚è¿™ä¸ª key åªæœ‰åœ¨éå†æ•´ä¸ª map çš„æ—¶å€™ï¼Œæ‰æœ‰æœºä¼šç°èº«ã€‚æ‰€ä»¥ï¼Œå¯ä»¥å‘ä¸€ä¸ª map æ’å…¥ä»»æ„æ•°é‡çš„ <code>math.NaN()</code> ä½œä¸º keyã€‚</p>
<p>å½“æ¬è¿ç¢°åˆ° <code>math.NaN()</code> çš„ key æ—¶ï¼Œåªé€šè¿‡ tophash çš„æœ€ä½ä½å†³å®šåˆ†é…åˆ° X part è¿˜æ˜¯ Y partï¼ˆå¦‚æœæ‰©å®¹åæ˜¯åŸæ¥ buckets æ•°é‡çš„ 2 å€ï¼‰ã€‚å¦‚æœ tophash çš„æœ€ä½ä½æ˜¯ 0 ï¼Œåˆ†é…åˆ° X partï¼›å¦‚æœæ˜¯ 1 ï¼Œåˆ™åˆ†é…åˆ° Y partã€‚</p>
<p>è¿™æ˜¯é€šè¿‡ tophash å€¼ä¸æ–°ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼è¿›è¡Œè¿ç®—å¾—åˆ°çš„ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="nx">k2</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// åªæœ‰åœ¨ float å˜é‡çš„ NaN() æƒ…å†µä¸‹ä¼šå‡ºç°
</span><span class="c1"></span>	<span class="c1">// If key != key (NaNs), then the hash could be (and probably
</span><span class="c1"></span>	<span class="c1">// will be) entirely different from the old hash. Moreover,
</span><span class="c1"></span>	<span class="c1">// it isn&#39;t reproducible. Reproducibility is required in the
</span><span class="c1"></span>	<span class="c1">// presence of iterators, as our evacuation decision must
</span><span class="c1"></span>	<span class="c1">// match whatever decision the iterator made.
</span><span class="c1"></span>	<span class="c1">// Fortunately, we have the freedom to send these keys either
</span><span class="c1"></span>	<span class="c1">// way. Also, tophash is meaningless for these kinds of keys.
</span><span class="c1"></span>	<span class="c1">// We let the low bit of tophash drive the evacuation decision.
</span><span class="c1"></span>	<span class="c1">// We recompute a new random tophash for the next level so
</span><span class="c1"></span>	<span class="c1">// these keys will get evenly distributed across all buckets
</span><span class="c1"></span>	<span class="c1">// after multiple grows.
</span><span class="c1"></span>	<span class="nx">useY</span> <span class="p">=</span> <span class="nx">top</span> <span class="o">&amp;</span> <span class="mi">1</span>
	<span class="nx">top</span> <span class="p">=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	 <span class="c1">// æ–°ç®—å‡ºæ¥çš„ hash å€¼çš„ B ä½ç½® 0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nx">newbit</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">useY</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>å…¶å®è¿™æ ·çš„ key æˆ‘éšä¾¿æ¬è¿åˆ°å“ªä¸ª bucket éƒ½è¡Œï¼Œå½“ç„¶ï¼Œè¿˜æ˜¯è¦æ¬è¿åˆ°ä¸Šé¢è£‚å˜é‚£å¼ å›¾ä¸­çš„ä¸¤ä¸ª bucket ä¸­å»ã€‚ä½†è¿™æ ·åšæ˜¯æœ‰å¥½å¤„çš„ï¼Œåœ¨åé¢è®² map è¿­ä»£çš„æ—¶å€™ä¼šå†è¯¦ç»†è§£é‡Šï¼Œæš‚æ—¶çŸ¥é“æ˜¯è¿™æ ·åˆ†é…çš„å°±è¡Œã€‚</p>
<p>ç¡®å®šäº†è¦æ¬è¿åˆ°çš„ç›®æ ‡ bucket åï¼Œæ¬è¿æ“ä½œå°±æ¯”è¾ƒå¥½è¿›è¡Œäº†ã€‚å°†æº key/value å€¼ copy åˆ°ç›®çš„åœ°ç›¸åº”çš„ä½ç½®ã€‚</p>
<p>è®¾ç½® key åœ¨åŸå§‹ buckets çš„ tophash ä¸º evacuatedX æˆ–æ˜¯ evacuatedYï¼Œè¡¨ç¤ºå·²ç»æ¬è¿åˆ°äº†æ–° map çš„ x part æˆ–æ˜¯ y partã€‚æ–° map çš„ tophash åˆ™æ­£å¸¸å– key å“ˆå¸Œå€¼çš„é«˜ 8 ä½ã€‚</p>
<p>ä¸‹é¢é€šè¿‡å›¾æ¥å®è§‚åœ°çœ‹ä¸€ä¸‹æ‰©å®¹å‰åçš„å˜åŒ–ã€‚</p>
<p>æ‰©å®¹å‰ï¼ŒB = 2ï¼Œå…±æœ‰ 4 ä¸ª bucketsï¼Œlowbits è¡¨ç¤º hash å€¼çš„ä½ä½ã€‚å‡è®¾æˆ‘ä»¬ä¸å…³æ³¨å…¶ä»– buckets æƒ…å†µï¼Œä¸“æ³¨åœ¨ 2 å· bucketã€‚å¹¶ä¸”å‡è®¾ overflow å¤ªå¤šï¼Œè§¦å‘äº†ç­‰é‡æ‰©å®¹ï¼ˆå¯¹åº”äºå‰é¢çš„æ¡ä»¶ 2ï¼‰ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703170543.png" alt=""  />
</p>
<p>æ‰©å®¹å®Œæˆåï¼Œoverflow bucket æ¶ˆå¤±äº†ï¼Œkey éƒ½é›†ä¸­åˆ°äº†ä¸€ä¸ª bucketï¼Œæ›´ä¸ºç´§å‡‘äº†ï¼Œæé«˜äº†æŸ¥æ‰¾çš„æ•ˆç‡ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703170556.png" alt=""  />
</p>
<p>å‡è®¾è§¦å‘äº† 2 å€çš„æ‰©å®¹ï¼Œé‚£ä¹ˆæ‰©å®¹å®Œæˆåï¼Œè€ buckets ä¸­çš„ key åˆ†è£‚åˆ°äº† 2 ä¸ª æ–°çš„ bucketã€‚ä¸€ä¸ªåœ¨ x partï¼Œä¸€ä¸ªåœ¨ y çš„ partã€‚ä¾æ®æ˜¯ hash çš„ lowbitsã€‚æ–° map ä¸­ 0-3 ç§°ä¸º x partï¼Œ4-7 ç§°ä¸º y partã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703170701.png" alt=""  />
</p>
<p>æ³¨æ„ï¼Œä¸Šé¢çš„ä¸¤å¼ å›¾å¿½ç•¥äº†å…¶ä»– buckets çš„æ¬è¿æƒ…å†µï¼Œè¡¨ç¤ºæ‰€æœ‰çš„ bucket éƒ½æ¬è¿å®Œæ¯•åçš„æƒ…å½¢ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œæ¬è¿æ˜¯ä¸€ä¸ªâ€œæ¸è¿›â€çš„è¿‡ç¨‹ï¼Œå¹¶ä¸ä¼šä¸€ä¸‹å­å°±å…¨éƒ¨æ¬è¿å®Œæ¯•ã€‚æ‰€ä»¥åœ¨æ¬è¿è¿‡ç¨‹ä¸­ï¼Œoldbuckets æŒ‡é’ˆè¿˜ä¼šæŒ‡å‘åŸæ¥è€çš„ <code>[]bmap</code>ï¼Œå¹¶ä¸”å·²ç»æ¬è¿å®Œæ¯•çš„ key çš„ tophash å€¼ä¼šæ˜¯ä¸€ä¸ªçŠ¶æ€å€¼ï¼Œè¡¨ç¤º key çš„æ¬è¿å»å‘ã€‚</p>
<h2 id="éå†">éå†<a hidden class="anchor" aria-hidden="true" href="#éå†">#</a></h2>
<p>æœ¬æ¥ map çš„éå†è¿‡ç¨‹æ¯”è¾ƒç®€å•ï¼šéå†æ‰€æœ‰çš„ bucket ä»¥åŠå®ƒåé¢æŒ‚çš„ overflow bucketï¼Œç„¶åæŒ¨ä¸ªéå† bucket ä¸­çš„æ‰€æœ‰ cellã€‚æ¯ä¸ª bucket ä¸­åŒ…å« 8 ä¸ª cellï¼Œä»æœ‰ key çš„ cell ä¸­å–å‡º key å’Œ valueï¼Œè¿™ä¸ªè¿‡ç¨‹å°±å®Œæˆäº†ã€‚</p>
<p>ä½†æ˜¯ï¼Œç°å®å¹¶æ²¡æœ‰è¿™ä¹ˆç®€å•ã€‚è¿˜è®°å¾—å‰é¢è®²è¿‡çš„æ‰©å®¹è¿‡ç¨‹å—ï¼Ÿæ‰©å®¹è¿‡ç¨‹ä¸æ˜¯ä¸€ä¸ªåŸå­çš„æ“ä½œï¼Œå®ƒæ¯æ¬¡æœ€å¤šåªæ¬è¿ 2 ä¸ª bucketï¼Œæ‰€ä»¥å¦‚æœè§¦å‘äº†æ‰©å®¹æ“ä½œï¼Œé‚£ä¹ˆåœ¨å¾ˆé•¿æ—¶é—´é‡Œï¼Œmap çš„çŠ¶æ€éƒ½æ˜¯å¤„äºä¸€ä¸ªä¸­é—´æ€ï¼šæœ‰äº› bucket å·²ç»æ¬è¿åˆ°æ–°å®¶ï¼Œè€Œæœ‰äº› bucket è¿˜å¾…åœ¨è€åœ°æ–¹ã€‚</p>
<p>å› æ­¤ï¼Œéå†å¦‚æœå‘ç”Ÿåœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œå°±ä¼šæ¶‰åŠåˆ°éå†æ–°è€ bucket çš„è¿‡ç¨‹ï¼Œè¿™æ˜¯éš¾ç‚¹æ‰€åœ¨ã€‚</p>
<p>æˆ‘å…ˆå†™ä¸€ä¸ªç®€å•çš„ä»£ç æ ·ä¾‹ï¼Œå‡è£…ä¸çŸ¥é“éå†è¿‡ç¨‹å…·ä½“è°ƒç”¨çš„æ˜¯ä»€ä¹ˆå‡½æ•°ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">ageMp</span><span class="p">[</span><span class="s">&#34;qcrao&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">18</span>

	<span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ageMp</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>æ‰§è¡Œå‘½ä»¤ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">tool</span> <span class="n">compile</span> <span class="o">-</span><span class="n">S</span> <span class="n">main.go</span>
</code></pre></td></tr></table>
</div>
</div><p>å¾—åˆ°æ±‡ç¼–å‘½ä»¤ã€‚è¿™é‡Œå°±ä¸é€è¡Œè®²è§£äº†ï¼Œå¯ä»¥å»çœ‹ä¹‹å‰çš„å‡ ç¯‡æ–‡ç« ï¼Œè¯´å¾—å¾ˆè¯¦ç»†ã€‚</p>
<p>å…³é”®çš„å‡ è¡Œæ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="o">//</span> <span class="n">......</span>
<span class="mh">0x0124</span> <span class="m">00292</span> <span class="p">(</span><span class="n">test16.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">CALL</span>    <span class="nf">runtime.mapiterinit</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>

<span class="o">//</span> <span class="n">......</span>
<span class="mh">0x01fb</span> <span class="m">00507</span> <span class="p">(</span><span class="n">test16.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">CALL</span>    <span class="nf">runtime.mapiternext</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
<span class="mh">0x0200</span> <span class="m">00512</span> <span class="p">(</span><span class="n">test16.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="n">..autotmp_4</span><span class="m">+160</span><span class="p">(</span><span class="n">SP</span><span class="p">),</span> <span class="n">AX</span>
<span class="mh">0x0208</span> <span class="m">00520</span> <span class="p">(</span><span class="n">test16.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">TESTQ</span>   <span class="n">AX</span><span class="p">,</span> <span class="n">AX</span>
<span class="mh">0x020b</span> <span class="m">00523</span> <span class="p">(</span><span class="n">test16.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">JNE</span>     <span class="m">302</span>

<span class="o">//</span> <span class="n">......</span>
</code></pre></td></tr></table>
</div>
</div><p>è¿™æ ·ï¼Œå…³äº map è¿­ä»£ï¼Œåº•å±‚çš„å‡½æ•°è°ƒç”¨å…³ç³»ä¸€ç›®äº†ç„¶ã€‚å…ˆæ˜¯è°ƒç”¨ mapiterinit å‡½æ•°åˆå§‹åŒ–è¿­ä»£å™¨ï¼Œç„¶åå¾ªç¯è°ƒç”¨ mapiternext å‡½æ•°è¿›è¡Œ map è¿­ä»£ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703173130.png" alt=""  />
</p>
<p>è¿­ä»£å™¨çš„ç»“æ„ä½“å®šä¹‰ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A hash iteration structure.
</span><span class="c1">// If you modify hiter, also change cmd/compile/internal/gc/reflect.go to indicate
</span><span class="c1">// the layout of this structure.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">hiter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// key æŒ‡é’ˆ
</span><span class="c1"></span>	<span class="nx">key</span>         <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// Must be in first position.  Write nil to indicate iteration end (see cmd/compile/internal/gc/range.go).
</span><span class="c1"></span>	<span class="c1">// value æŒ‡é’ˆ
</span><span class="c1"></span>	<span class="nx">elem</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// Must be in second position (see cmd/compile/internal/gc/range.go).
</span><span class="c1"></span>	<span class="c1">// map ç±»å‹ï¼ŒåŒ…å«å¦‚ key size å¤§å°ç­‰
</span><span class="c1"></span>	<span class="nx">t</span>           <span class="o">*</span><span class="nx">maptype</span>
	<span class="nx">h</span>           <span class="o">*</span><span class="nx">hmap</span>
	<span class="c1">// åˆå§‹åŒ–æ—¶æŒ‡å‘çš„ bucket
</span><span class="c1"></span>	<span class="nx">buckets</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// bucket ptr at hash_iter initialization time
</span><span class="c1"></span>	<span class="c1">// å½“å‰éå†åˆ°çš„ bmap
</span><span class="c1"></span>	<span class="nx">bptr</span>        <span class="o">*</span><span class="nx">bmap</span>          <span class="c1">// current bucket
</span><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>       <span class="c1">// keeps overflow buckets of hmap.buckets alive
</span><span class="c1"></span>	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>       <span class="c1">// keeps overflow buckets of hmap.oldbuckets alive
</span><span class="c1"></span>	<span class="c1">// èµ·å§‹éå†çš„ bucet ç¼–å·
</span><span class="c1"></span>	<span class="nx">startBucket</span> <span class="kt">uintptr</span>        <span class="c1">// bucket iteration started at
</span><span class="c1"></span>	<span class="c1">// éå†å¼€å§‹æ—¶ cell çš„ç¼–å·ï¼ˆæ¯ä¸ª bucket ä¸­æœ‰ 8 ä¸ª cellï¼‰
</span><span class="c1"></span>	<span class="nx">offset</span>      <span class="kt">uint8</span>          <span class="c1">// intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1)
</span><span class="c1"></span>	<span class="c1">// æ˜¯å¦ä»å¤´éå†äº†
</span><span class="c1"></span>	<span class="nx">wrapped</span>     <span class="kt">bool</span>           <span class="c1">// already wrapped around from end of bucket array to beginning
</span><span class="c1"></span>	<span class="c1">// B çš„å¤§å°
</span><span class="c1"></span>	<span class="nx">B</span>           <span class="kt">uint8</span>
	<span class="c1">// æŒ‡ç¤ºå½“å‰ cell åºå·
</span><span class="c1"></span>	<span class="nx">i</span>           <span class="kt">uint8</span>
	<span class="c1">// æŒ‡å‘å½“å‰çš„ bucket
</span><span class="c1"></span>	<span class="nx">bucket</span>      <span class="kt">uintptr</span>
	<span class="c1">// å› ä¸ºæ‰©å®¹ï¼Œéœ€è¦æ£€æŸ¥çš„ bucket
</span><span class="c1"></span>	<span class="nx">checkBucket</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>mapiterinit å°±æ˜¯å¯¹ hiter ç»“æ„ä½“é‡Œçš„å­—æ®µè¿›è¡Œåˆå§‹åŒ–èµ‹å€¼æ“ä½œã€‚</p>
<p>å‰é¢å·²ç»æåˆ°è¿‡ï¼Œå³ä½¿æ˜¯å¯¹ä¸€ä¸ªå†™æ­»çš„ map è¿›è¡Œéå†ï¼Œæ¯æ¬¡å‡ºæ¥çš„ç»“æœä¹Ÿæ˜¯æ— åºçš„ã€‚ä¸‹é¢æˆ‘ä»¬å°±å¯ä»¥è¿‘è·ç¦»åœ°è§‚å¯Ÿä»–ä»¬çš„å®ç°äº†ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mapiterinit initializes the hiter struct used for ranging over maps.
</span><span class="c1">// The hiter struct pointed to by &#39;it&#39; is allocated on the stack
</span><span class="c1">// by the compilers order pass or on the heap by reflect_mapiterinit.
</span><span class="c1">// Both need to have zeroed hiter since the struct contains pointers.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapiterinit</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">hiter</span><span class="p">{})</span><span class="o">/</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">!=</span> <span class="mi">12</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;hash_iter size incorrect&#34;</span><span class="p">)</span> <span class="c1">// see cmd/compile/internal/gc/reflect.go
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="p">=</span> <span class="nx">h</span>

	<span class="c1">// grab snapshot of bucket state
</span><span class="c1"></span>	<span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Allocate the current slice and remember pointers to both current and old.
</span><span class="c1"></span>		<span class="c1">// This preserves all relevant overflow buckets alive even if
</span><span class="c1"></span>		<span class="c1">// the table grows and/or overflow buckets are added to the table
</span><span class="c1"></span>		<span class="c1">// while we are iterating.
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span>
	<span class="p">}</span>

	<span class="c1">// decide where to start
</span><span class="c1"></span>	<span class="c1">// ç”Ÿæˆéšæœºæ•° r
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">31</span><span class="o">-</span><span class="nx">bucketCntBits</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
	<span class="p">}</span>
	<span class="c1">// ä»å“ªä¸ª bucket å¼€å§‹éå†
</span><span class="c1"></span>	<span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="c1">// ä» bucket çš„å“ªä¸ª cell å¼€å§‹éå†
</span><span class="c1"></span>	<span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

	<span class="c1">// iterator state
</span><span class="c1"></span>	<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>

	<span class="c1">// Remember we have an iterator.
</span><span class="c1"></span>	<span class="c1">// Can run concurrently with another mapiterinit().
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">old</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">|</span><span class="nx">oldIterator</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">fastrand</span><span class="p">()</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span>
	<span class="c1">// Implement xorshift64+: 2 32-bit xorshift sequences added together.
</span><span class="c1"></span>	<span class="c1">// Shift triplet [17,7,16] was calculated as indicated in Marsaglia&#39;s
</span><span class="c1"></span>	<span class="c1">// Xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf
</span><span class="c1"></span>	<span class="c1">// This generator passes the SmallCrush suite, part of TestU01 framework:
</span><span class="c1"></span>	<span class="c1">// http://simul.iro.umontreal.ca/testu01/tu01.html
</span><span class="c1"></span>	<span class="nx">s1</span><span class="p">,</span> <span class="nx">s0</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">s1</span> <span class="p">^=</span> <span class="nx">s1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span>
	<span class="nx">s1</span> <span class="p">=</span> <span class="nx">s1</span> <span class="p">^</span> <span class="nx">s0</span> <span class="p">^</span> <span class="nx">s1</span><span class="o">&gt;&gt;</span><span class="mi">7</span> <span class="p">^</span> <span class="nx">s0</span><span class="o">&gt;&gt;</span><span class="mi">16</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s0</span><span class="p">,</span> <span class="nx">s1</span>
	<span class="k">return</span> <span class="nx">s0</span> <span class="o">+</span> <span class="nx">s1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ä¾‹å¦‚ï¼ŒB = 2ï¼Œé‚£ <code>uintptr(1)&lt;&lt;h.B - 1</code> ç»“æœå°±æ˜¯ 3ï¼Œä½ 8 ä½ä¸º 0000 0011ï¼Œå°† r ä¸ä¹‹ç›¸ä¸ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ª 0~3 çš„ bucket åºå·ï¼›<code>bucketCnt - 1</code> ç­‰äº 7ï¼Œä½ 8 ä½ä¸º 0000 0111ï¼Œå°† r å³ç§» 2 ä½åï¼Œä¸ 7 ç›¸ä¸ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ª 0~7 å·çš„ cellã€‚</p>
<p>äºæ˜¯ï¼Œåœ¨ mapiternext å‡½æ•°ä¸­å°±ä¼šä» <code>it.startBucket</code> çš„ it.offset å·çš„ cell å¼€å§‹éå†ï¼Œå–å‡ºå…¶ä¸­çš„ key å’Œ valueï¼Œç›´åˆ°åˆå›åˆ°èµ·ç‚¹ bucketï¼Œå®Œæˆéå†è¿‡ç¨‹ã€‚</p>
<p>å‡è®¾æˆ‘ä»¬æœ‰ä¸‹å›¾æ‰€ç¤ºçš„ä¸€ä¸ª mapï¼Œèµ·å§‹æ—¶ B = 1ï¼Œæœ‰ä¸¤ä¸ª bucketï¼Œåæ¥è§¦å‘äº†æ‰©å®¹ï¼ˆè¿™é‡Œä¸è¦æ·±ç©¶æ‰©å®¹æ¡ä»¶ï¼Œåªæ˜¯ä¸€ä¸ªè®¾å®šï¼‰ï¼ŒB å˜æˆ 2ã€‚å¹¶ä¸”ï¼Œ 1 å· bucket ä¸­çš„å†…å®¹æ¬è¿åˆ°äº†æ–°çš„ bucketï¼Œ1 å·è£‚å˜æˆ 1 å·å’Œ 3 å·ï¼›0 å· bucket æš‚æœªæ¬è¿ã€‚è€çš„ bucket æŒ‚åœ¨åœ¨ <em>oldbuckets æŒ‡é’ˆä¸Šé¢ï¼Œæ–°çš„ bucket åˆ™æŒ‚åœ¨</em>buckets æŒ‡é’ˆä¸Šé¢ã€‚</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703174850.png" alt=""  />
</p>
<p>è¿™æ—¶ï¼Œæˆ‘ä»¬å¯¹æ­¤ map è¿›è¡Œéå†ã€‚å‡è®¾ç»è¿‡åˆå§‹åŒ–åï¼ŒstartBucket = 3ï¼Œoffset = 2ã€‚äºæ˜¯ï¼Œéå†çš„èµ·ç‚¹å°†æ˜¯ 3 å· bucket çš„ 2 å· cellï¼Œä¸‹é¢è¿™å¼ å›¾å°±æ˜¯å¼€å§‹éå†æ—¶çš„çŠ¶æ€ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703175216.png" alt=""  />
</p>
<p>æ ‡çº¢çš„è¡¨ç¤ºèµ·å§‹ä½ç½®ï¼Œbucket éå†é¡ºåºä¸ºï¼š3 -&gt; 0 -&gt; 1 -&gt; 2ã€‚</p>
<p>å› ä¸º 3 å· bucket å¯¹åº”è€çš„ 1 å· bucketï¼Œå› æ­¤å…ˆæ£€æŸ¥è€ 1 å· bucket æ˜¯å¦å·²ç»è¢«æ¬è¿è¿‡ã€‚åˆ¤æ–­æ–¹æ³•å°±æ˜¯ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">h</span> <span class="p">&gt;</span> <span class="nx">empty</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>å¦‚æœ <code>b.tophash[0]</code> çš„å€¼åœ¨æ ‡å¿—å€¼èŒƒå›´å†…ï¼Œå³åœ¨ (0,4) åŒºé—´é‡Œï¼Œè¯´æ˜å·²ç»è¢«æ¬è¿è¿‡äº†ã€‚</p>
<p>åœ¨æœ¬ä¾‹ä¸­ï¼Œè€ 1 å· bucket å·²ç»è¢«æ¬è¿è¿‡äº†ã€‚æ‰€ä»¥å®ƒçš„ <code>tophash[0]</code> å€¼åœ¨ (0,4) èŒƒå›´å†…ï¼Œå› æ­¤åªç”¨éå†æ–°çš„ 3 å· bucketã€‚</p>
<p>ä¾æ¬¡éå† 3 å· bucket çš„ cellï¼Œè¿™æ—¶å€™ä¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªéç©ºçš„ keyï¼šå…ƒç´  eã€‚åˆ°è¿™é‡Œï¼Œmapiternext å‡½æ•°è¿”å›ï¼Œè¿™æ—¶æˆ‘ä»¬çš„éå†ç»“æœä»…æœ‰ä¸€ä¸ªå…ƒç´ ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703175910.png" alt=""  />
</p>
<p>ç”±äºè¿”å›çš„ key ä¸ä¸ºç©ºï¼Œæ‰€ä»¥ä¼šç»§ç»­è°ƒç”¨ mapiternext å‡½æ•°ã€‚</p>
<p>ç»§ç»­ä»ä¸Šæ¬¡éå†åˆ°çš„åœ°æ–¹å¾€åéå†ï¼Œä»æ–° 3 å· overflow bucket ä¸­æ‰¾åˆ°äº†å…ƒç´  f å’Œ å…ƒç´  gã€‚</p>
<p>éå†ç»“æœé›†ä¹Ÿå› æ­¤å£®å¤§ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703175921.png" alt=""  />
</p>
<p>æ–° 3 å· bucket éå†å®Œä¹‹åï¼Œå›åˆ°äº†æ–° 0 å· bucketã€‚0 å· bucket å¯¹åº”è€çš„ 0 å· bucketï¼Œç»æ£€æŸ¥ï¼Œè€ 0 å· bucket å¹¶æœªæ¬è¿ï¼Œå› æ­¤å¯¹æ–° 0 å· bucket çš„éå†å°±æ”¹ä¸ºéå†è€ 0 å· bucketã€‚é‚£æ˜¯ä¸æ˜¯æŠŠè€ 0 å· bucket ä¸­çš„æ‰€æœ‰ key éƒ½å–å‡ºæ¥å‘¢ï¼Ÿ</p>
<p>å¹¶æ²¡æœ‰è¿™ä¹ˆç®€å•ï¼Œå›å¿†ä¸€ä¸‹ï¼Œè€ 0 å· bucket åœ¨æ¬è¿åå°†è£‚å˜æˆ 2 ä¸ª bucketï¼šæ–° 0 å·ã€æ–° 2 å·ã€‚è€Œæˆ‘ä»¬æ­¤æ—¶æ­£åœ¨éå†çš„åªæ˜¯æ–° 0 å· bucketï¼ˆæ³¨æ„ï¼Œéå†éƒ½æ˜¯éå†çš„ *bucket æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„æ–° bucketsï¼‰ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬åªä¼šå–å‡ºè€ 0 å· bucket ä¸­é‚£äº›åœ¨è£‚å˜ä¹‹åï¼Œåˆ†é…åˆ°æ–° 0 å· bucket ä¸­çš„é‚£äº› keyã€‚</p>
<p>å› æ­¤ï¼Œlowbits == 00 çš„å°†è¿›å…¥éå†ç»“æœé›†ï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703180002.png" alt=""  />
</p>
<p>å’Œä¹‹å‰çš„æµç¨‹ä¸€æ ·ï¼Œç»§ç»­éå†æ–° 1 å· bucketï¼Œå‘ç°è€ 1 å· bucket å·²ç»æ¬è¿ï¼Œåªç”¨éå†æ–° 1 å· bucket ä¸­ç°æœ‰çš„å…ƒç´ å°±å¯ä»¥äº†ã€‚ç»“æœé›†å˜æˆï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703180019.png" alt=""  />
</p>
<p>ç»§ç»­éå†æ–° 2 å· bucketï¼Œå®ƒæ¥è‡ªè€ 0 å· bucketï¼Œå› æ­¤éœ€è¦åœ¨è€ 0 å· bucket ä¸­é‚£äº›ä¼šè£‚å˜åˆ°æ–° 2 å· bucket ä¸­çš„ keyï¼Œä¹Ÿå°±æ˜¯ lowbit == 10 çš„é‚£äº› keyã€‚</p>
<p>è¿™æ ·ï¼Œéå†ç»“æœé›†å˜æˆï¼š</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210703180029.png" alt=""  />
</p>
<p>æœ€åï¼Œç»§ç»­éå†åˆ°æ–° 3 å· bucket æ—¶ï¼Œå‘ç°æ‰€æœ‰çš„ bucket éƒ½å·²ç»éå†å®Œæ¯•ï¼Œæ•´ä¸ªè¿­ä»£è¿‡ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚</p>
<p>é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œå¦‚æœç¢°åˆ° key æ˜¯ <code>math.NaN()</code> è¿™ç§çš„ï¼Œå¤„ç†æ–¹å¼ç±»ä¼¼ã€‚æ ¸å¿ƒè¿˜æ˜¯è¦çœ‹å®ƒè¢«åˆ†è£‚åå…·ä½“è½å…¥å“ªä¸ª bucketã€‚åªä¸è¿‡åªç”¨çœ‹å®ƒ top hash çš„æœ€ä½ä½ã€‚å¦‚æœ top hash çš„æœ€ä½ä½æ˜¯ 0 ï¼Œåˆ†é…åˆ° X partï¼›å¦‚æœæ˜¯ 1 ï¼Œåˆ™åˆ†é…åˆ° Y partã€‚æ®æ­¤å†³å®šæ˜¯å¦å–å‡º keyï¼Œæ”¾åˆ°éå†ç»“æœé›†é‡Œã€‚</p>
<p>map éå†çš„æ ¸å¿ƒåœ¨äºç†è§£ 2 å€æ‰©å®¹æ—¶ï¼Œè€ bucket ä¼šåˆ†è£‚åˆ° 2 ä¸ªæ–° bucket ä¸­å»ã€‚è€Œéå†æ“ä½œï¼Œä¼šæŒ‰ç…§æ–° bucket çš„åºå·é¡ºåºè¿›è¡Œï¼Œç¢°åˆ°è€ bucket æœªæ¬è¿çš„æƒ…å†µæ—¶ï¼Œè¦åœ¨è€ bucket ä¸­æ‰¾åˆ°å°†æ¥è¦æ¬è¿åˆ°æ–° bucket æ¥çš„ keyã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mapiternext</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map iteration and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">t</span>
	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">i</span>
	<span class="nx">checkBucket</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span>

<span class="nx">next</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">{</span>
			<span class="c1">// end of iteration
</span><span class="c1"></span>			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">{</span>
			<span class="c1">// Iterator was started in the middle of a grow, and the grow isn&#39;t done yet.
</span><span class="c1"></span>			<span class="c1">// If the bucket we&#39;re looking at hasn&#39;t been filled in yet (i.e. the old
</span><span class="c1"></span>			<span class="c1">// bucket hasn&#39;t been evacuated) then we need to iterate through the old
</span><span class="c1"></span>			<span class="c1">// bucket and only return the ones that will be migrated to this bucket.
</span><span class="c1"></span>			<span class="nx">oldbucket</span> <span class="o">:=</span> <span class="nx">bucket</span> <span class="o">&amp;</span> <span class="nx">it</span><span class="p">.</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">()</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">bucket</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
				<span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">noCheck</span>
		<span class="p">}</span>
		<span class="nx">bucket</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">bucket</span> <span class="o">==</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">bucket</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">wrapped</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">offi</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">it</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">])</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">==</span> <span class="nx">evacuatedEmpty</span> <span class="p">{</span>
			<span class="c1">// TODO: emptyRest is hard to use here, as we start iterating
</span><span class="c1"></span>			<span class="c1">// in the middle of a bucket. It&#39;s feasible, just tricky.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">checkBucket</span> <span class="o">!=</span> <span class="nx">noCheck</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Special case: iterator was started during a grow to a larger size
</span><span class="c1"></span>			<span class="c1">// and the grow is not done yet. We&#39;re working on a bucket whose
</span><span class="c1"></span>			<span class="c1">// oldbucket has not been evacuated yet. Or at least, it wasn&#39;t
</span><span class="c1"></span>			<span class="c1">// evacuated when we started the bucket. So we&#39;re iterating
</span><span class="c1"></span>			<span class="c1">// through the oldbucket, skipping any keys that will go
</span><span class="c1"></span>			<span class="c1">// to the other new bucket (each oldbucket expands to two
</span><span class="c1"></span>			<span class="c1">// buckets during a grow).
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// If the item in the oldbucket is not destined for
</span><span class="c1"></span>				<span class="c1">// the current new bucket in the iteration, skip it.
</span><span class="c1"></span>				<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">hash</span><span class="o">&amp;</span><span class="nf">bucketMask</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">checkBucket</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// Hash isn&#39;t repeatable if k != k (NaNs).  We need a
</span><span class="c1"></span>				<span class="c1">// repeatable and randomish choice of which direction
</span><span class="c1"></span>				<span class="c1">// to send NaNs during evacuation. We&#39;ll use the low
</span><span class="c1"></span>				<span class="c1">// bit of tophash to decide which way NaNs go.
</span><span class="c1"></span>				<span class="c1">// NOTE: this case is why we need two evacuate tophash
</span><span class="c1"></span>				<span class="c1">// values, evacuatedX and evacuatedY, that differ in
</span><span class="c1"></span>				<span class="c1">// their low bit.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">checkBucket</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nx">it</span><span class="p">.</span><span class="nx">B</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedX</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">!(</span><span class="nx">t</span><span class="p">.</span><span class="nf">reflexivekey</span><span class="p">()</span> <span class="o">||</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// This is the golden data, we can return it.
</span><span class="c1"></span>			<span class="c1">// OR
</span><span class="c1"></span>			<span class="c1">// key!=key, so the entry can&#39;t be deleted or updated, so we can just return it.
</span><span class="c1"></span>			<span class="c1">// That&#39;s lucky for us because when key!=key we can&#39;t look it up successfully.
</span><span class="c1"></span>			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// The hash table has grown since the iterator was started.
</span><span class="c1"></span>			<span class="c1">// The golden data for this key is now somewhere else.
</span><span class="c1"></span>			<span class="c1">// Check the current hash table for the data.
</span><span class="c1"></span>			<span class="c1">// This code handles the case where the key
</span><span class="c1"></span>			<span class="c1">// has been deleted, updated, or deleted and reinserted.
</span><span class="c1"></span>			<span class="c1">// NOTE: we need to regrab the key as it has potentially been
</span><span class="c1"></span>			<span class="c1">// updated to an equal() but not identical key (e.g. +0.0 vs -0.0).
</span><span class="c1"></span>			<span class="nx">rk</span><span class="p">,</span> <span class="nx">re</span> <span class="o">:=</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">rk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span> <span class="c1">// key has been deleted
</span><span class="c1"></span>			<span class="p">}</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">rk</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">re</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">bucket</span>
		<span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="o">!=</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// avoid unnecessary write barrier; see issue 14921
</span><span class="c1"></span>			<span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="p">=</span> <span class="nx">b</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">checkBucket</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">goto</span> <span class="nx">next</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="å°ç»“">å°ç»“<a hidden class="anchor" aria-hidden="true" href="#å°ç»“">#</a></h2>
<p>Go è¯­è¨€ä½¿ç”¨æ‹‰é“¾æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜å®ç°äº†å“ˆå¸Œè¡¨ï¼Œå®ƒçš„è®¿é—®ã€å†™å…¥å’Œåˆ é™¤ç­‰æ“ä½œéƒ½åœ¨ç¼–è¯‘æœŸé—´è½¬æ¢æˆäº†è¿è¡Œæ—¶çš„å‡½æ•°æˆ–è€…æ–¹æ³•ã€‚å“ˆå¸Œåœ¨æ¯ä¸€ä¸ªæ¡¶ä¸­å­˜å‚¨é”®å¯¹åº”å“ˆå¸Œçš„å‰ 8 ä½ï¼Œå½“å¯¹å“ˆå¸Œè¿›è¡Œæ“ä½œæ—¶ï¼Œè¿™äº› tophash å°±æˆä¸ºå¯ä»¥å¸®åŠ©å“ˆå¸Œå¿«é€Ÿéå†æ¡¶ä¸­å…ƒç´ çš„ç¼“å­˜ã€‚</p>
<p>å“ˆå¸Œè¡¨çš„æ¯ä¸ªæ¡¶éƒ½åªèƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œä¸€æ—¦å½“å‰å“ˆå¸Œçš„æŸä¸ªæ¡¶è¶…å‡º 8 ä¸ªï¼Œæ–°çš„é”®å€¼å¯¹å°±ä¼šå­˜å‚¨åˆ°å“ˆå¸Œçš„æº¢å‡ºæ¡¶ä¸­ã€‚éšç€é”®å€¼å¯¹æ•°é‡çš„å¢åŠ ï¼Œæº¢å‡ºæ¡¶çš„æ•°é‡å’Œå“ˆå¸Œçš„è£…è½½å› å­ä¹Ÿä¼šé€æ¸å‡é«˜ï¼Œè¶…è¿‡ä¸€å®šèŒƒå›´å°±ä¼šè§¦å‘æ‰©å®¹ï¼Œæ‰©å®¹ä¼šå°†æ¡¶çš„æ•°é‡ç¿»å€ï¼Œå…ƒç´ å†åˆ†é…çš„è¿‡ç¨‹ä¹Ÿæ˜¯åœ¨è°ƒç”¨å†™æ“ä½œæ—¶å¢é‡è¿›è¡Œçš„ï¼Œä¸ä¼šé€ æˆæ€§èƒ½çš„ç¬æ—¶å·¨å¤§æŠ–åŠ¨ã€‚</p>
<h2 id="ç¼ºé™·">ç¼ºé™·<a hidden class="anchor" aria-hidden="true" href="#ç¼ºé™·">#</a></h2>
<p>å·²ç»æ‰©å®¹çš„ mapï¼Œæ— æ³•æ”¶ç¼©</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810215452.png" alt=""  />
</p>
<p>ä¿è¯å¹¶å‘å®‰å…¨æ—¶ï¼Œè¦æ‰‹åŠ¨è¯»å†™é”ï¼Œæ˜“å‡ºé”™,å¤šæ ¸å¿ƒä¸‹è¡¨ç°å·®</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810215520.png" alt=""  />
</p>
<p>éš¾ä»¥ä½¿ç”¨ sync.Pool è¿›è¡Œé‡ç”¨</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810215537.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810215544.png" alt=""  />
</p>
<h2 id="å‚è€ƒ">å‚è€ƒ<a hidden class="anchor" aria-hidden="true" href="#å‚è€ƒ">#</a></h2>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E6%89%A9%E5%AE%B9">3.3 å“ˆå¸Œè¡¨</a></p>
<p><a href="https://www.jianshu.com/p/241583eb8158">Go-Mapæºç è§£è¯»</a></p>
<p><a href="https://www.cnblogs.com/qcrao-2018/p/10903807.html">æ·±åº¦è§£å¯†Goè¯­è¨€ä¹‹map</a></p>
<p><a href="http://echoblog.cc/posts/golangmap%E8%A7%A3%E6%9E%90/">ã€ŒGolangã€ Mapæºç è§£æ</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Goæºç </a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
