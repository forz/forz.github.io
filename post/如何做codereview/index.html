<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>如何做CodeReview - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="前言 作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.91.2 with theme even" />


<link rel="canonical" href="/post/%E5%A6%82%E4%BD%95%E5%81%9Acodereview/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="如何做CodeReview" />
<meta property="og:description" content="前言 作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%A6%82%E4%BD%95%E5%81%9Acodereview/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-17T14:24:17+00:00" />
<meta property="article:modified_time" content="2021-06-17T14:24:17+00:00" />

<meta itemprop="name" content="如何做CodeReview">
<meta itemprop="description" content="前言 作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的"><meta itemprop="datePublished" content="2021-06-17T14:24:17+00:00" />
<meta itemprop="dateModified" content="2021-06-17T14:24:17+00:00" />
<meta itemprop="wordCount" content="34802">
<meta itemprop="keywords" content="Go规范," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何做CodeReview"/>
<meta name="twitter:description" content="前言 作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">如何做CodeReview</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-17 </span>
        <div class="post-category">
            <a href="/categories/go%E8%A7%84%E8%8C%83/"> Go规范 </a>
            </div>
          <span class="more-meta"> 约 34802 字 </span>
          <span class="more-meta"> 预计阅读 70 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#为什么技术人员包括-leader-都要做-code-review">为什么技术人员包括 leader 都要做 code review</a></li>
    <li><a href="#为什么同学们要在-review-中思考和总结最佳实践">为什么同学们要在 review 中思考和总结最佳实践</a></li>
    <li><a href="#代码变坏的根源">代码变坏的根源</a>
      <ul>
        <li><a href="#早期有效的决策不再有效">早期有效的决策不再有效</a></li>
        <li><a href="#过早的优化">过早的优化</a></li>
        <li><a href="#对合理性没有苛求">对合理性没有苛求</a></li>
        <li><a href="#总是面向对象总喜欢封装">总是面向对象/总喜欢封装</a></li>
        <li><a href="#根本没有设计">根本没有设计</a></li>
      </ul>
    </li>
    <li><a href="#必须形而上的思考">必须形而上的思考</a></li>
    <li><a href="#model-设计">model 设计</a></li>
    <li><a href="#unix-设计哲学">UNIX 设计哲学</a>
      <ul>
        <li><a href="#keep-it-simple-stuped">Keep It Simple Stuped</a></li>
        <li><a href="#原则-3-组合原则-设计时考虑拼接组合">原则 3 组合原则: 设计时考虑拼接组合</a></li>
        <li><a href="#原则-6-吝啬原则-除非确无它法-不要编写庞大的程序">原则 6 吝啬原则: 除非确无它法, 不要编写庞大的程序</a></li>
        <li><a href="#原则-7-透明性原则-设计要可见以便审查和调试">原则 7 透明性原则: 设计要可见，以便审查和调试</a></li>
        <li><a href="#原则-10-通俗原则-接口设计避免标新立异">原则 10 通俗原则: 接口设计避免标新立异</a></li>
        <li><a href="#原则-11-缄默原则-如果一个程序没什么好说的就沉默">原则 11 缄默原则: 如果一个程序没什么好说的，就沉默</a></li>
        <li><a href="#原则-12-补救原则-出现异常时马上退出并给出足够错误信息">原则 12 补救原则: 出现异常时，马上退出并给出足够错误信息</a></li>
      </ul>
    </li>
    <li><a href="#具体实践点">具体实践点</a></li>
    <li><a href="#主干开发">主干开发</a></li>
    <li><a href="#unix-编程艺术">《unix 编程艺术》</a></li>
    <li><a href="#综述">综述</a></li>
    <li><a href="#知名架构原则">知名架构原则</a>
      <ul>
        <li><a href="#细节即是架构">细节即是架构</a></li>
        <li><a href="#把代码和文档绑在一起自解释原则">把代码和文档绑在一起(自解释原则)</a></li>
        <li><a href="#etc-价值观easy-to-change">ETC 价值观(easy to change)</a></li>
        <li><a href="#dry-原则don-not-repeat-yourself">DRY 原则(don not repeat yourself)</a></li>
        <li><a href="#正交性原则全局变量的危害">正交性原则(全局变量的危害)</a></li>
        <li><a href="#单例就是全局变量">单例就是全局变量</a></li>
        <li><a href="#可逆性原则">可逆性原则</a></li>
        <li><a href="#依赖倒置原则dip">依赖倒置原则(DIP)</a></li>
        <li><a href="#将知识用纯文本来保存">将知识用纯文本来保存</a></li>
        <li><a href="#契约式设计">契约式设计</a></li>
        <li><a href="#尽早崩溃">尽早崩溃</a></li>
        <li><a href="#解耦代码让改变容易">解耦代码让改变容易</a></li>
        <li><a href="#不要链式调用方法">不要链式调用方法</a></li>
        <li><a href="#继承税多用组合">继承税(多用组合)</a></li>
        <li><a href="#共享状态是不正确的状态">共享状态是不正确的状态</a></li>
        <li><a href="#缄默原则">缄默原则</a></li>
        <li><a href="#错误传递原则">错误传递原则</a></li>
        <li><a href="#solid">SOLID</a></li>
        <li><a href="#一个函数不要出现多个层级的代码">一个函数不要出现多个层级的代码</a></li>
        <li><a href="#unix-哲学基础">Unix 哲学基础</a></li>
      </ul>
    </li>
    <li><a href="#工程师的自我修养">工程师的自我修养</a>
      <ul>
        <li><a href="#偏执">偏执</a></li>
        <li><a href="#控制软件的熵是软件工程的重要任务之一">控制软件的熵是软件工程的重要任务之一</a></li>
        <li><a href="#为测试做设计">为测试做设计</a></li>
        <li><a href="#尽早测试-经常测试-自动测试">尽早测试, 经常测试, 自动测试</a></li>
        <li><a href="#项目中使用统一的术语">项目中使用统一的术语</a></li>
        <li><a href="#不要面向需求编程">不要面向需求编程</a></li>
        <li><a href="#写代码要有对于美的追求">写代码要有对于&rsquo;美&rsquo;的追求</a></li>
        <li><a href="#应用程序框架是实现细节">应用程序框架是实现细节</a></li>
        <li><a href="#一切都应该是代码通过代码去显式组合">一切都应该是代码(通过代码去显式组合)</a></li>
        <li><a href="#封装不一定是好的组织形式">封装不一定是好的组织形式</a></li>
        <li><a href="#所有细节都应该被显式处理">所有细节都应该被显式处理</a></li>
      </ul>
    </li>
    <li><a href="#不能上升到原则的一些常见案例">不能上升到原则的一些常见案例</a>
      <ul>
        <li><a href="#合理注释一些并不通俗的逻辑和数值">合理注释一些并不&rsquo;通俗&rsquo;的逻辑和数值</a></li>
        <li><a href="#习惯留下-todo">习惯留下 TODO</a></li>
        <li><a href="#不要丢弃错误信息">不要丢弃错误信息</a></li>
        <li><a href="#自动化测试要快">自动化测试要快</a></li>
        <li><a href="#历史有问题的代码-发现了问题要及时-push-相关人主动解决">历史有问题的代码, 发现了问题要及时 push 相关人主动解决</a></li>
        <li><a href="#less-is-more">less is more</a></li>
        <li><a href="#如果打了错误日志-有效信息必须充足-且不过多">如果打了错误日志, 有效信息必须充足, 且不过多</a></li>
        <li><a href="#注释要把问题讲清楚-讲不清楚的日志等于没有">注释要把问题讲清楚, 讲不清楚的日志等于没有</a></li>
        <li><a href="#mr-要自己先-review-不要浪费-reviewer-的时间">MR 要自己先 review, 不要浪费 reviewer 的时间</a></li>
        <li><a href="#要寻找合适的定语">要寻找合适的定语</a></li>
        <li><a href="#不要出现特定-ip或者把什么可变的东西写死">不要出现特定 IP,或者把什么可变的东西写死</a></li>
        <li><a href="#使用定语-不要-1234">使用定语, 不要 1、2、3、4</a></li>
        <li><a href="#有必要才使用-init">有必要才使用 init</a></li>
        <li><a href="#要关注-shadow-write">要关注 shadow write</a></li>
        <li><a href="#能不耦合接收器就别耦合">能不耦合接收器就别耦合</a></li>
        <li><a href="#空实现需要注明空实现就是实现">空实现需要注明空实现就是实现</a></li>
        <li><a href="#看错题集没多少有用-我们需要教练和传承">看错题集没多少有用, 我们需要教练和传承</a></li>
        <li><a href="#展望">展望</a></li>
        <li><a href="#拾遗">拾遗</a></li>
      </ul>
    </li>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的一些理念和思路。</p>
<h2 id="为什么技术人员包括-leader-都要做-code-review">为什么技术人员包括 leader 都要做 code review</h2>
<p>谚语曰: &lsquo;Talk Is Cheap, Show Me The Code&rsquo;。知易行难，知行合一难。嘴里要讲出来总是轻松，把别人讲过的话记住，组织一下语言，再讲出来，很容易。绝知此事要躬行。设计理念你可能道听途说了一些，以为自己掌握了，但是你会做么？有能力去思考、改进自己当前的实践方式和实践中的代码细节么？不客气地说，很多人仅仅是知道并且认同了某个设计理念，进而产生了一种虚假的安心感&mdash;自己的技术并不差。但是，他根本没有去实践这些设计理念，甚至根本实践不了这些设计理念，从结果来说，他懂不懂这些道理/理念，有什么差别？变成了自欺欺人。</p>
<p>代码，是设计理念落地的地方，是技术的呈现和根本。同学们可以在 review 过程中做到落地沟通，不再是空对空的讨论，可以在实际问题中产生思考的碰撞，互相学习，大家都掌握团队里积累出来最好的实践方式！当然，如果 leader 没时间写代码，仅仅是 review 代码，指出其他同学某些实践方式不好，要给出好的实践的意见，即使没亲手写代码，也是对最佳实践要有很多思考。</p>
<h2 id="为什么同学们要在-review-中思考和总结最佳实践">为什么同学们要在 review 中思考和总结最佳实践</h2>
<p>我这里先给一个我自己的总结：所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则。进而控制 30+万行代码项目的开发便利性、可维护性、可测试性、运营质量。</p>
<p>厉害的技术人，主要可以分为下面几个方向：</p>
<ul>
<li>
<p>奇技淫巧
掌握很多技巧，以及发现技巧一系列思路，比如很多编程大赛，比的就是这个。但是，这个对工程，用处好像并不是很大。</p>
</li>
<li>
<p>领域奠基
比如约翰*卡马克，他创造出了现代计算机图形高效渲染的方法论。不论如果没有他，后面会不会有人发明，他就是第一个发明了。1999 年，卡马克登上了美国时代杂志评选出来的科技领域 50 大影响力人物榜单，并且名列第 10 位。但是，类似的殿堂级位置，没有几个，不够大家分，没我们的事儿。</p>
</li>
<li>
<p>理论研究
八十年代李开复博士坚持采用隐含马尔可夫模型的框架，成功地开发了世界上第一个大词汇量连续语音识别系统 Sphinx。我辈工程师，好像擅长这个的很少。</p>
</li>
<li>
<p>产品成功
小龙哥是标杆。</p>
</li>
<li>
<p>最佳实践
这个是大家都可以做到，按照上面架构师的定义。在这条路上走得好，就能为任何公司组建技术团队，组织建设高质量的系统。</p>
</li>
</ul>
<p>从上面的讨论中，可以看出，我们普通工程师的进化之路，就是不断打磨最佳实践方法论、落地细节。</p>
<h2 id="代码变坏的根源">代码变坏的根源</h2>
<p>在讨论什么代码是好代码之前，我们先讨论什么是不好的。计算机是人造的学科，我们自己制造了很多问题，进而去思考解法。</p>
<p>重复的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BatchGetQQTinyWithAdmin 获取QQ uin的tinyID, 需要主uin的tiny和登录态
</span><span class="c1">// friendUins 可以是空列表, 只要admin uin的tiny
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BatchGetQQTinyWithAdmin</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">adminUin</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">friendUin</span> <span class="p">[]</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span>
 <span class="nx">adminTiny</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">sig</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">frdTiny</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="nx">friendAccountList</span> <span class="p">[]</span><span class="o">*</span><span class="nx">basedef</span><span class="p">.</span><span class="nx">AccountInfo</span>
 <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">friendUin</span> <span class="p">{</span>
  <span class="nx">friendAccountList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">friendAccountList</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">basedef</span><span class="p">.</span><span class="nx">AccountInfo</span><span class="p">{</span>
   <span class="nx">AccountType</span><span class="p">:</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">def</span><span class="p">.</span><span class="nx">StrQQU</span><span class="p">),</span>
   <span class="nx">Userid</span><span class="p">:</span>      <span class="nx">proto</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">v</span><span class="p">)),</span>
  <span class="p">})</span>
 <span class="p">}</span>

 <span class="nx">req</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cmd0xb91</span><span class="p">.</span><span class="nx">ReqBody</span><span class="p">{</span>
  <span class="nx">Appid</span><span class="p">:</span>       <span class="nx">proto</span><span class="p">.</span><span class="nf">Uint32</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">DocAppID</span><span class="p">),</span>
  <span class="nx">CheckMethod</span><span class="p">:</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">CheckQQ</span><span class="p">),</span>
  <span class="nx">AdminAccount</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">basedef</span><span class="p">.</span><span class="nx">AccountInfo</span><span class="p">{</span>
   <span class="nx">AccountType</span><span class="p">:</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">def</span><span class="p">.</span><span class="nx">StrQQU</span><span class="p">),</span>
   <span class="nx">Userid</span><span class="p">:</span>      <span class="nx">proto</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">adminUin</span><span class="p">)),</span>
  <span class="p">},</span>
  <span class="nx">FriendAccountList</span><span class="p">:</span> <span class="nx">friendAccountList</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为最开始协议设计得不好，第一个使用接口的人，没有类似上面这个函数的代码，自己实现了一个嵌入逻辑代码的填写请求结构结构体的代码，一开始，挺好的。但当有第二个人，第三个人干了类似的事情，我们将无法再重构这个协议，必须做到麻烦的向前兼容。而且每个同学，都要理解一遍上面这个协议怎么填，理解有问题，就触发 bug。或者，如果某个错误的理解，普遍存在，我们就得找到所有这些重复的片段，都修改一遍。</p>
<p>当你要读一个数据，发现两个地方有，不知道该选择哪个。当你要实现一个功能，发现两个 rpc 接口、两个函数能做到，你不知道选哪一个。你有面临过这样的&rsquo;人生难题&rsquo;么？其实怎么选并不重要了，你写的这个代码已经在走向 shit 的道路上迈出了坚实的一步。</p>
<p>但是，A little copying is better than a little dependency。这里提一嘴，不展开。</p>
<p>这里，我必须额外说一句。大家使用 trpc。感觉自己被鼓励&rsquo;每个服务搞一个 git'。那，你这个服务里访问 db 的代码，rpc 的代码，各种可以复用的代码，是用的大家都复用的 git 下的代码么？每次都重复写一遍，db 字段细节改了，每个使用过 db 的 server 对应的 git 都改一遍？这个通用 git 已经写好的接口应该不知道哪些 git 下的代码因为自己不向前兼容的修改而永远放弃了向前不兼容的修改？</p>
<h3 id="早期有效的决策不再有效">早期有效的决策不再有效</h3>
<p>很多时候，我们第一版代码写出来，是没有太大的问题的。比如，下面这个代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Update 增量更新
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">FilePrivilegeStore</span><span class="p">)</span> <span class="nf">Update</span><span class="p">(</span><span class="nx">key</span> <span class="nx">def</span><span class="p">.</span><span class="nx">PrivilegeKey</span><span class="p">,</span>
 <span class="nx">clear</span><span class="p">,</span> <span class="nx">isMerge</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">subtract</span> <span class="p">[]</span><span class="o">*</span><span class="nx">access</span><span class="p">.</span><span class="nx">AccessInfo</span><span class="p">,</span> <span class="nx">increment</span> <span class="p">[]</span><span class="o">*</span><span class="nx">access</span><span class="p">.</span><span class="nx">AccessInfo</span><span class="p">,</span>
<span class="nx">policy</span><span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">adv</span> <span class="o">*</span><span class="nx">access</span><span class="p">.</span><span class="nx">AdvPolicy</span><span class="p">,</span> <span class="nx">shareKey</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">importQQGroupID</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="c1">// 获取之前的数据
</span><span class="c1"></span> <span class="nx">info</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
 <span class="p">}</span>

 <span class="nx">incOnlyModify</span> <span class="o">:=</span> <span class="nf">update</span><span class="p">(</span><span class="nx">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">key</span><span class="p">,</span> <span class="nx">clear</span><span class="p">,</span> <span class="nx">subtract</span><span class="p">,</span>
  <span class="nx">increment</span><span class="p">,</span> <span class="nx">policy</span><span class="p">,</span> <span class="nx">adv</span><span class="p">,</span> <span class="nx">shareKey</span><span class="p">,</span> <span class="nx">importQQGroupID</span><span class="p">)</span>
 <span class="nx">stat</span> <span class="o">:=</span> <span class="nf">statAndUpdateAccessInfo</span><span class="p">(</span><span class="nx">info</span><span class="p">)</span>
 <span class="k">if</span> <span class="p">!</span><span class="nx">incOnlyModify</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">stat</span><span class="p">.</span><span class="nx">groupNumber</span> <span class="p">&gt;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">FilePrivilegeGroupMax</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">PrivilegeGroupLimit</span><span class="p">,</span>
    <span class="s">&#34;group num %d larger than limit %d&#34;</span><span class="p">,</span>
    <span class="nx">stat</span><span class="p">.</span><span class="nx">groupNumber</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">FilePrivilegeGroupMax</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">if</span> <span class="p">!</span><span class="nx">isMerge</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">key</span><span class="p">.</span><span class="nx">DomainID</span> <span class="o">==</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">access</span><span class="p">.</span><span class="nx">SPECIAL_FOLDER_DOMAIN_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
   <span class="nb">len</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">AccessInfos</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">FilePrivilegeMaxFolderNum</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">PrivilegeFolderLimit</span><span class="p">,</span>
    <span class="s">&#34;folder owner num %d larger than limit %d&#34;</span><span class="p">,</span>
    <span class="nb">len</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">AccessInfos</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">FilePrivilegeMaxFolderNum</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">AccessInfos</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">FilePrivilegeMaxNum</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">PrivilegeUserLimit</span><span class="p">,</span>
    <span class="s">&#34;file owner num %d larger than limit %d&#34;</span><span class="p">,</span>
    <span class="nb">len</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">AccessInfos</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">FilePrivilegeMaxNum</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>

 <span class="nx">pbDataSt</span> <span class="o">:=</span> <span class="nf">infoToData</span><span class="p">(</span><span class="nx">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">key</span><span class="p">)</span>
 <span class="kd">var</span> <span class="nx">updateBuf</span> <span class="p">[]</span><span class="kt">byte</span>
 <span class="k">if</span> <span class="nx">updateBuf</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">pbDataSt</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">MarshalPBError</span><span class="p">,</span>
   <span class="s">&#34;FilePrivilegeStore.Update Marshal data error, key[%v]&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">setCKV</span><span class="p">(</span><span class="nf">generateKey</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">key</span><span class="p">),</span> <span class="nx">updateBuf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Code</span><span class="p">(</span><span class="nx">err</span><span class="p">),</span>
   <span class="s">&#34;FilePrivilegeStore.Update setCKV error, key[%v]&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在看，这个代码挺好的，长度没超过 80 行，逻辑比价清晰。但是当 isMerge 这里判断逻辑，如果加入更多的逻辑，把局部行数撑到 50 行以上，这个函数，味道就坏了。出现两个问题：</p>
<p>1）函数内代码不在一个逻辑层次上，阅读代码，本来在阅读着顶层逻辑，突然就掉入了长达 50 行的 isMerge 的逻辑处理细节，还没看完，读者已经忘了前面的代码讲了什么，需要来回看，挑战自己大脑的 cache 尺寸。</p>
<p>2）代码有问题后，再新加代码的同学，是改还是不改前人写好的代码呢？出 bug 谁来背？这是一个灵魂拷问。</p>
<h3 id="过早的优化">过早的优化</h3>
<p>这个大家听了很多了，这里不赘述。</p>
<h3 id="对合理性没有苛求">对合理性没有苛求</h3>
<p>&lsquo;两种写法都 ok，你随便挑一种吧&rsquo;，&lsquo;我这样也没什么吧&rsquo;，这是我经常听到的话。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get 获取IP
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IPGetter</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">cardName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
 <span class="nx">i</span><span class="p">.</span><span class="nx">l</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
 <span class="nx">ip</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">cardName</span><span class="p">]</span>
 <span class="nx">i</span><span class="p">.</span><span class="nx">l</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

 <span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ip</span>
 <span class="p">}</span>

 <span class="nx">i</span><span class="p">.</span><span class="nx">l</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
 <span class="nx">ip</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getNetIP</span><span class="p">(</span><span class="nx">cardName</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">cardName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ip</span>
 <span class="p">}</span>

  <span class="nx">i</span><span class="p">.</span><span class="nx">l</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
 <span class="k">return</span> <span class="nx">ip</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>i.l.Unlock()</code>可以放在当前的位置，也可以放在 <code>i.l.Lock()</code>下面，做成 defer。两种在最初构造的时候，好像都行。这个时候，很多同学态度就变得不坚决。实际上，这里必须是 defer 的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">  <span class="nx">i</span><span class="p">.</span><span class="nx">l</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="k">defer</span> <span class="nx">i</span><span class="p">.</span><span class="nx">l</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

 <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
 <span class="nx">ip</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getNetIP</span><span class="p">(</span><span class="nx">cardName</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;127.0.0.1&#34;</span>
 <span class="p">}</span>

 <span class="nx">i</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">cardName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ip</span>
 <span class="k">return</span> <span class="nx">ip</span>
</code></pre></td></tr></table>
</div>
</div><p>这样的修改，是极有可能发生的，它还是要变成 defer，那，为什么不一开始就是 defer，进入最合理的状态？不一开始就进入最合理的状态，在后续协作中，其他同学很可能犯错！</p>
<h3 id="总是面向对象总喜欢封装">总是面向对象/总喜欢封装</h3>
<p>我是软件工程科班出身。学的第一门编程语言是 c++。教材是这本 。当时自己读完教材，初入程序设计之门，对于里面讲的&rsquo;封装'，惊为天人，多么美妙的设计啊，面向对象，多么智慧的设计啊。但是，这些年来，我看到了大牛&rsquo;云风&rsquo;对于&rsquo;毕业生使用 mysql api 就喜欢搞个 class 封装再用&rsquo;的嘲讽；看到了各种莫名其妙的 class 定义；体会到了经常要去看一个莫名其妙的继承树，必须要把整个继承树整体读明白才能确认一个细小的逻辑分支；多次体会到了我需要辛苦地压抑住自己的抵触情绪，去细度一个自作聪明的被封装的代码，确认我的 bug。除了 UI 类场景，我认为少用继承、多用组合。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_PKG_TYPE</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">CSuperAction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CSuperActionBase</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_PKG_TYPE</span> <span class="n">pkg_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">CSuperAction</span><span class="o">&lt;</span><span class="n">pkg_type</span><span class="o">&gt;</span> <span class="n">this_type</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是 sspp 的代码。CSuperAction 和 CSuperActionBase，一会儿 super，一会儿 base，Super 和 SuperBase 是在怎样的两个抽象层次上，不通读代码，没人能读明白。我想确认任何细节，都要把多个层次的代码都通读了，有什么封装性可言？</p>
<p>好，你说是作者没有把 class name 取得好。那，问题是，你能取得好么？一个刚入职的 T1.2 的同学能把 class name、class 树设计得好么？即使是对简单的业务模型，也需要无数次&rsquo;坏&rsquo;的对象抽象实践，才能培养出一个具有合格的 class 抽象能力的同学，这对于大型却松散的团队协作，不是破坏性的？已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的 class，以及使用它们的地方，你都去改？不，是个正常人都会放弃，开始堆屎山。</p>
<p>封装，就是我可以不关心实现。但是，做一个稳定的系统，每一层设计都可能出问题。abi，总有合适的用法和不合适的用法，真的存在我们能完全不关心封装的部分是怎么实现的？不，你不能。bug 和性能问题，常常就出现在，你用了错误的用法去使用一个封装好的函数。即使是 android、ios 的 api，golang、java 现成的 api，我们常常都要去探究实现，才能把 api 用好。那，我们是不是该一上来，就做一个透明性很强的函数，才更为合理？使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，我们还要强调函数内部工作方式&rsquo;可以让读者在大脑里想象呈现完整过程&rsquo;的可现性，让使用者轻松读懂，有把握，使用时，不迷路！</p>
<h3 id="根本没有设计">根本没有设计</h3>
<p>这个最可怕，所有需求，上手就是一顿撸，&lsquo;设计是什么东西？我一个文件 5w 行，一个函数 5k 行，干不完需求？&lsquo;从第一行代码开始，就是无设计的，随意地踩着满地的泥坑，对于旁人的眼光没有感觉，一个人独舞，产出的代码，完成了需求，毁灭了接手自己代码的人。这个就不举例了，每个同学应该都能在自己的项目类发现这种代码。</p>
<h2 id="必须形而上的思考">必须形而上的思考</h2>
<p>常常，同学们听演讲，公开课，就喜欢听一些细枝末节的&rsquo;干活&rsquo;。这没有问题。但是，你干了几年活，学习了多少干货知识点？构建起自己的技术思考&rsquo;面&rsquo;，进入立体的&rsquo;工程思维'，把技术细节和系统要满足的需求在思考上连接起来了么？当听一个需求的时候，你能思考到自己的 code package 该怎么组织，函数该怎么组织了么？</p>
<p>那，技术点要怎么和需求连接起来呢？答案很简单，你需要在时间里总结，总结出一些明确的原则、思维过程。思考怎么去总结，特别像是在思考哲学问题。从一些琐碎的细节中，由具体情况上升到一些原则、公理。同时，大家在接受原则时，不应该是接受和记住原则本身，而应该是结构原则，让这个原则在自己这里重新推理一遍，自己完全掌握这个原则的适用范围。</p>
<p>再进一步具体地说，对于工程最佳实践的形而上的思考过程，就是：</p>
<p>把工程实践中遇到的问题，从问题类型和解法类型，两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。当你这套方案能适应 30w+行代码的项目，超过 30 人的项目，你就架构师入门了！当你这个项目，是多端，多语言，代码量超过 300w 行，参与人数超过 300 人，代码质量依然很高，代码依然在高效地自我迭代，每天消除掉过时的代码，填充高质量的替换旧代码和新生的代码。恭喜你，你已经是一个很高级的架构师了！再进一步，你对某个业务模型有独到或者全面的理解，构建了一套行业第一的解决方案，结合刚才高质量实现的能力，实现了这么一个项目。没啥好说的，你已经是专家工程师了。级别再高，我就不了解了，不在这里讨论。</p>
<p>那么，我们要重头开始积累思考和总结？不，有一本书叫做《unix 编程艺术》，我在不同的时期分别读了 3 遍，等一会，我讲一些里面提到的，我觉得在腾讯尤其值得拿出来说的原则。这些原则，正好就能作为 code review 时大家判定代码质量的准绳。但，在那之前，我得讲一下另外一个很重要的话题，模型设计。</p>
<h2 id="model-设计">model 设计</h2>
<p>没读过 oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个撇脚的 oauth。</p>
<p>2012 年我刚毕业，我和一个去了广州联通公司的华南理工毕业生聊天。当时他说他工作很不开心，因为工作里不经常写代码，而且认为自己有 ACM 竞赛金牌级的算法熟练度+对 CPP 代码的熟悉，写下一个个指针操作内存，什么程序写不出来，什么事情做不好。当时我觉得，挺有道理，编程工具在手，我什么事情做不了？</p>
<p>现在，我会告诉他，复杂如 linux 操作系统、Chromium 引擎、windows office，你做不了。原因是，他根本没进入软件工程的工程世界。不是会搬砖就能修出港珠澳大桥。但是，这么回答并不好，举证用的论据离我们太遥远了。见微知著。我现在会回答，你做不了，简单如一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？简单如一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的 ife lse？你联通有上万台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的 ife lse？</p>
<p>上来就是干，能实现上面提到的三个看似简单的需求？想一想，亚马逊、阿里云折腾了多少年，最后才找到了容器+Kubernetes 的大杀器。这里，需要谷歌多少年在 BORG 系统上的实践，提出了优秀的服务编排领域模型。权限领域，有 RBAC、DAC、MAC 等等模型，到了业务，又会有细节的不同。如 Domain Driven Design 说的，没有良好的领域思考和模型抽象，逻辑复杂度就是 n^2 指数级的，你得写多少 ifelse，得思考多少可能的 if 路径，来 cover 所有的不合符预期的情况。你必须要有 Domain 思考探索、model 拆解/抽象/构建的能力。有人问过我，要怎么有效地获得这个能力？这个问题我没能回答，就像是在问我，怎么才能获得 MIT 博士的学术能力？我无法回答。唯一回答就是，进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力，去进一步思考。至于怎么建立好的通识思考能力，可能得去常青藤读个书吧：）或者，就在工程实践中思考和锻炼自己的这个能力！</p>
<p>同时，基于 model 设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个 calendar(日历)应用，简单来想，不要太简单！以&rsquo;userid_date&rsquo;为 key 记录一个用户的每日安排不就完成了么？只往前走一步，设计了一个任务，上限分发给 100w 个人，创建这么一个任务，是往 100w 个人下面添加一条记录？你得改掉之前的设计，换 db。再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做 join？好像还行。如果是和 100 个人一起参与的所有任务呢？100 个人的任务来 join？不现实了吧。好，你引入一个群组 id，那么，你最开始的&rsquo;userid_date&rsquo;为 key 的设计，是不是又要修改和做数据迁移了？经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个 model，设计一套通用的 store 层接口，基于通用接口的逻辑代码。当产品不断发展，就是不停往模型里填内容，而不是推翻重来。这，思考模型边界，构建模型细节，就是两个很重要的能力，也是绝大多数腾讯产品经理不具备的能力，你得具备，对整个团队都是极其有益的。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。</p>
<p>model 设计，是形而上思考中的一个方面，一个特别重要的方面。接下来，我们来抄袭抄袭 unix 操作系统构建的实践为我们提出的前人实践经验和&rsquo;公理&rsquo;总结。在自己的 coding/code review 中，站在巨人的肩膀上去思考。不重复地发现经典力学，而是往相对论挺进。</p>
<h2 id="unix-设计哲学">UNIX 设计哲学</h2>
<p>不懂 Unix 的人注定最终还要重复发明一个撇脚的 Unix。&ndash;Henry Spenncer, 1987.11</p>
<p>下面这一段话太经典，我必须要摘抄一遍(自《UNIX 编程艺术》)：“工程和设计的每个分支都有自己的技术文化。在大多数工程领域中，就一个专业人员的素养组成来说，有些不成文的行业素养具有与标准手册及教科书同等重要的地位(并且随着专业人员经验的日积月累，这些经验常常会比书本更重要)。资深工程师们在工作中会积累大量的隐性知识，他们用类似禅宗&rsquo;教外别传&rsquo;的方式，通过言传身教传授给后辈。软件工程算是此规则的一个例外：技术变革如此之快，软件环境日新月异，软件技术文化暂如朝露。然而，例外之中也有例外。确有极少数软件技术被证明经久耐用，足以演进为强势的技术文化、有鲜明特色的艺术和世代相传的设计哲学。“</p>
<p>接下来，我用我的理解，讲解一下几个我们常常做不到的原则。</p>
<h3 id="keep-it-simple-stuped">Keep It Simple Stuped</h3>
<p>KISS 原则，大家应该是如雷贯耳了。但是，你真的在遵守？什么是 Simple？简单？golang 语言主要设计者之一的 Rob Pike 说&rsquo;大道至简'，这个&rsquo;简&rsquo;和简单是一个意思么？</p>
<p>首先，简单不是面对一个问题，我们印入眼帘第一映像的解法为简单。我说一句，感受一下。&ldquo;把一个事情做出来容易，把事情用最简单有效的方法做出来，是一个很难的事情。&ldquo;比如，做一个三方授权，oauth2.0 很简单，所有概念和细节都是紧凑、完备、易用的。你觉得要设计到 oauth2.0 这个效果很容易么？要做到简单，就要对自己处理的问题有全面的了解，然后需要不断积累思考，才能做到从各个角度和层级去认识这个问题，打磨出一个通俗、紧凑、完备的设计，就像 ios 的交互设计。简单不是容易做到的，需要大家在不断的时间和 code review 过程中去积累思考，pk 中触发思考，交流中总结思考，才能做得愈发地好，接近&rsquo;大道至简'。</p>
<p>两张经典的模型图，简单又全面，感受一下，没看懂，可以立即自行 google 学习一下：RBAC:图片</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617185151.png" alt=""></p>
<h3 id="原则-3-组合原则-设计时考虑拼接组合">原则 3 组合原则: 设计时考虑拼接组合</h3>
<p>关于 OOP，关于继承，我前面已经说过了。那我们怎么组织自己的模块？对，用组合的方式来达到。linux 操作系统离我们这么近，它是怎么架构起来的？往小里说，我们一个串联一个业务请求的数据集合，如果使用 BaseSession，XXXSession inherit BaseSession 的设计，其实，这个继承树，很难适应层出不穷的变化。但是如果使用组合，就可以拆解出 UserSignature 等等各种可能需要的部件，在需要的时候组合使用，不断添加新的部件而没有对老的继承树的记忆这个心智负担。</p>
<p>使用组合，其实就是要让你明确清楚自己现在所拥有的是哪个部件。如果部件过于多，其实完成组合最终成品这个步骤，就会有较高的心智负担，每个部件展开来，琳琅满目，眼花缭乱。比如 QT 这个通用 UI 框架，看它的Class 列表，有 1000 多个。如果不用继承树把它组织起来，平铺展开，组合出一个页面，将会变得心智负担高到无法承受。OOP 在&rsquo;需要无数元素同时展现出来&rsquo;这种复杂度极高的场景，有效的控制了复杂度 。&lsquo;那么，古尔丹，代价是什么呢？&lsquo;代价就是，一开始做出这个自上而下的设计，牵一发而动全身，每次调整都变得异常困难。</p>
<p>实际项目中，各种职业级别不同的同学一起协作修改一个 server 的代码，就会出现，职级低的同学改哪里都改不对，根本没能力进行修改，高级别的同学能修改对，也不愿意大规模修改，整个项目变得愈发不合理。对整个继承树没有完全认识的同学都没有资格进行任何一个对继承树有调整的修改，协作变得寸步难行。代码的修改，都变成了依赖一个高级架构师高强度监控继承体系的变化，低级别同学们束手束脚的结果。组合，就很好的解决了这个问题，把问题不断细分，每个同学都可以很好地攻克自己需要攻克的点，实现一个 package。产品逻辑代码，只需要去组合各个 package，就能达到效果。</p>
<p>这是 golang 标准库里 http request 的定义，它就是 Http 请求所有特性集合出来的结果。其中通用/异变/多种实现的部分，通过 duck interface 抽象，比如 Body io.ReadCloser。你想知道哪些细节，就从组合成 request 的部件入手，要修改，只需要修改对应部件。[这段代码后，对比.NET 的 HTTP 基于 OOP 的抽象]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A Request represents an HTTP request received by a server
</span><span class="c1">// or to be sent by a client.
</span><span class="c1">//
</span><span class="c1">// The field semantics differ slightly between client and server
</span><span class="c1">// usage. In addition to the notes on the fields below, see the
</span><span class="c1">// documentation for Request.Write and RoundTripper.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Method specifies the HTTP method (GET, POST, PUT, etc.).
</span><span class="c1"></span>	<span class="c1">// For client requests, an empty string means GET.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Go&#39;s HTTP client does not support sending a request with
</span><span class="c1"></span>	<span class="c1">// the CONNECT method. See the documentation on Transport for
</span><span class="c1"></span>	<span class="c1">// details.
</span><span class="c1"></span>	<span class="nx">Method</span> <span class="kt">string</span>

	<span class="c1">// URL specifies either the URI being requested (for server
</span><span class="c1"></span>	<span class="c1">// requests) or the URL to access (for client requests).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the URL is parsed from the URI
</span><span class="c1"></span>	<span class="c1">// supplied on the Request-Line as stored in RequestURI.  For
</span><span class="c1"></span>	<span class="c1">// most requests, fields other than Path and RawQuery will be
</span><span class="c1"></span>	<span class="c1">// empty. (See RFC 7230, Section 5.3)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, the URL&#39;s Host specifies the server to
</span><span class="c1"></span>	<span class="c1">// connect to, while the Request&#39;s Host field optionally
</span><span class="c1"></span>	<span class="c1">// specifies the Host header value to send in the HTTP
</span><span class="c1"></span>	<span class="c1">// request.
</span><span class="c1"></span>	<span class="nx">URL</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>

	<span class="c1">// The protocol version for incoming server requests.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, these fields are ignored. The HTTP
</span><span class="c1"></span>	<span class="c1">// client code always uses either HTTP/1.1 or HTTP/2.
</span><span class="c1"></span>	<span class="c1">// See the docs on Transport for details.
</span><span class="c1"></span>	<span class="nx">Proto</span>      <span class="kt">string</span> <span class="c1">// &#34;HTTP/1.0&#34;
</span><span class="c1"></span>	<span class="nx">ProtoMajor</span> <span class="kt">int</span>    <span class="c1">// 1
</span><span class="c1"></span>	<span class="nx">ProtoMinor</span> <span class="kt">int</span>    <span class="c1">// 0
</span><span class="c1"></span>
	<span class="c1">// Header contains the request header fields either received
</span><span class="c1"></span>	<span class="c1">// by the server or to be sent by the client.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If a server received a request with header lines,
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	Host: example.com
</span><span class="c1"></span>	<span class="c1">//	accept-encoding: gzip, deflate
</span><span class="c1"></span>	<span class="c1">//	Accept-Language: en-us
</span><span class="c1"></span>	<span class="c1">//	fOO: Bar
</span><span class="c1"></span>	<span class="c1">//	foo: two
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// then
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	Header = map[string][]string{
</span><span class="c1"></span>	<span class="c1">//		&#34;Accept-Encoding&#34;: {&#34;gzip, deflate&#34;},
</span><span class="c1"></span>	<span class="c1">//		&#34;Accept-Language&#34;: {&#34;en-us&#34;},
</span><span class="c1"></span>	<span class="c1">//		&#34;Foo&#34;: {&#34;Bar&#34;, &#34;two&#34;},
</span><span class="c1"></span>	<span class="c1">//	}
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For incoming requests, the Host header is promoted to the
</span><span class="c1"></span>	<span class="c1">// Request.Host field and removed from the Header map.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// HTTP defines that header names are case-insensitive. The
</span><span class="c1"></span>	<span class="c1">// request parser implements this by using CanonicalHeaderKey,
</span><span class="c1"></span>	<span class="c1">// making the first character and any characters following a
</span><span class="c1"></span>	<span class="c1">// hyphen uppercase and the rest lowercase.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, certain headers such as Content-Length
</span><span class="c1"></span>	<span class="c1">// and Connection are automatically written when needed and
</span><span class="c1"></span>	<span class="c1">// values in Header may be ignored. See the documentation
</span><span class="c1"></span>	<span class="c1">// for the Request.Write method.
</span><span class="c1"></span>	<span class="nx">Header</span> <span class="nx">Header</span>

	<span class="c1">// Body is the request&#39;s body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, a nil body means the request has no
</span><span class="c1"></span>	<span class="c1">// body, such as a GET request. The HTTP Client&#39;s Transport
</span><span class="c1"></span>	<span class="c1">// is responsible for calling the Close method.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the Request Body is always non-nil
</span><span class="c1"></span>	<span class="c1">// but will return EOF immediately when no body is present.
</span><span class="c1"></span>	<span class="c1">// The Server will close the request body. The ServeHTTP
</span><span class="c1"></span>	<span class="c1">// Handler does not need to.
</span><span class="c1"></span>	<span class="nx">Body</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span>

	<span class="c1">// GetBody defines an optional func to return a new copy of
</span><span class="c1"></span>	<span class="c1">// Body. It is used for client requests when a redirect requires
</span><span class="c1"></span>	<span class="c1">// reading the body more than once. Use of GetBody still
</span><span class="c1"></span>	<span class="c1">// requires setting Body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, it is unused.
</span><span class="c1"></span>	<span class="nx">GetBody</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// ContentLength records the length of the associated content.
</span><span class="c1"></span>	<span class="c1">// The value -1 indicates that the length is unknown.
</span><span class="c1"></span>	<span class="c1">// Values &gt;= 0 indicate that the given number of bytes may
</span><span class="c1"></span>	<span class="c1">// be read from Body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, a value of 0 with a non-nil Body is
</span><span class="c1"></span>	<span class="c1">// also treated as unknown.
</span><span class="c1"></span>	<span class="nx">ContentLength</span> <span class="kt">int64</span>

	<span class="c1">// TransferEncoding lists the transfer encodings from outermost to
</span><span class="c1"></span>	<span class="c1">// innermost. An empty list denotes the &#34;identity&#34; encoding.
</span><span class="c1"></span>	<span class="c1">// TransferEncoding can usually be ignored; chunked encoding is
</span><span class="c1"></span>	<span class="c1">// automatically added and removed as necessary when sending and
</span><span class="c1"></span>	<span class="c1">// receiving requests.
</span><span class="c1"></span>	<span class="nx">TransferEncoding</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="c1">// Close indicates whether to close the connection after
</span><span class="c1"></span>	<span class="c1">// replying to this request (for servers) or after sending this
</span><span class="c1"></span>	<span class="c1">// request and reading its response (for clients).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the HTTP server handles this automatically
</span><span class="c1"></span>	<span class="c1">// and this field is not needed by Handlers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, setting this field prevents re-use of
</span><span class="c1"></span>	<span class="c1">// TCP connections between requests to the same hosts, as if
</span><span class="c1"></span>	<span class="c1">// Transport.DisableKeepAlives were set.
</span><span class="c1"></span>	<span class="nx">Close</span> <span class="kt">bool</span>

	<span class="c1">// For server requests, Host specifies the host on which the
</span><span class="c1"></span>	<span class="c1">// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this
</span><span class="c1"></span>	<span class="c1">// is either the value of the &#34;Host&#34; header or the host name
</span><span class="c1"></span>	<span class="c1">// given in the URL itself. For HTTP/2, it is the value of the
</span><span class="c1"></span>	<span class="c1">// &#34;:authority&#34; pseudo-header field.
</span><span class="c1"></span>	<span class="c1">// It may be of the form &#34;host:port&#34;. For international domain
</span><span class="c1"></span>	<span class="c1">// names, Host may be in Punycode or Unicode form. Use
</span><span class="c1"></span>	<span class="c1">// golang.org/x/net/idna to convert it to either format if
</span><span class="c1"></span>	<span class="c1">// needed.
</span><span class="c1"></span>	<span class="c1">// To prevent DNS rebinding attacks, server Handlers should
</span><span class="c1"></span>	<span class="c1">// validate that the Host header has a value for which the
</span><span class="c1"></span>	<span class="c1">// Handler considers itself authoritative. The included
</span><span class="c1"></span>	<span class="c1">// ServeMux supports patterns registered to particular host
</span><span class="c1"></span>	<span class="c1">// names and thus protects its registered Handlers.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, Host optionally overrides the Host
</span><span class="c1"></span>	<span class="c1">// header to send. If empty, the Request.Write method uses
</span><span class="c1"></span>	<span class="c1">// the value of URL.Host. Host may contain an international
</span><span class="c1"></span>	<span class="c1">// domain name.
</span><span class="c1"></span>	<span class="nx">Host</span> <span class="kt">string</span>

	<span class="c1">// Form contains the parsed form data, including both the URL
</span><span class="c1"></span>	<span class="c1">// field&#39;s query parameters and the PATCH, POST, or PUT form data.
</span><span class="c1"></span>	<span class="c1">// This field is only available after ParseForm is called.
</span><span class="c1"></span>	<span class="c1">// The HTTP client ignores Form and uses Body instead.
</span><span class="c1"></span>	<span class="nx">Form</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

	<span class="c1">// PostForm contains the parsed form data from PATCH, POST
</span><span class="c1"></span>	<span class="c1">// or PUT body parameters.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This field is only available after ParseForm is called.
</span><span class="c1"></span>	<span class="c1">// The HTTP client ignores PostForm and uses Body instead.
</span><span class="c1"></span>	<span class="nx">PostForm</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span>

	<span class="c1">// MultipartForm is the parsed multipart form, including file uploads.
</span><span class="c1"></span>	<span class="c1">// This field is only available after ParseMultipartForm is called.
</span><span class="c1"></span>	<span class="c1">// The HTTP client ignores MultipartForm and uses Body instead.
</span><span class="c1"></span>	<span class="nx">MultipartForm</span> <span class="o">*</span><span class="nx">multipart</span><span class="p">.</span><span class="nx">Form</span>

	<span class="c1">// Trailer specifies additional headers that are sent after the request
</span><span class="c1"></span>	<span class="c1">// body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, the Trailer map initially contains only the
</span><span class="c1"></span>	<span class="c1">// trailer keys, with nil values. (The client declares which trailers it
</span><span class="c1"></span>	<span class="c1">// will later send.)  While the handler is reading from Body, it must
</span><span class="c1"></span>	<span class="c1">// not reference Trailer. After reading from Body returns EOF, Trailer
</span><span class="c1"></span>	<span class="c1">// can be read again and will contain non-nil values, if they were sent
</span><span class="c1"></span>	<span class="c1">// by the client.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For client requests, Trailer must be initialized to a map containing
</span><span class="c1"></span>	<span class="c1">// the trailer keys to later send. The values may be nil or their final
</span><span class="c1"></span>	<span class="c1">// values. The ContentLength must be 0 or -1, to send a chunked request.
</span><span class="c1"></span>	<span class="c1">// After the HTTP request is sent the map values can be updated while
</span><span class="c1"></span>	<span class="c1">// the request body is read. Once the body returns EOF, the caller must
</span><span class="c1"></span>	<span class="c1">// not mutate Trailer.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Few HTTP clients, servers, or proxies support HTTP trailers.
</span><span class="c1"></span>	<span class="nx">Trailer</span> <span class="nx">Header</span>

	<span class="c1">// RemoteAddr allows HTTP servers and other software to record
</span><span class="c1"></span>	<span class="c1">// the network address that sent the request, usually for
</span><span class="c1"></span>	<span class="c1">// logging. This field is not filled in by ReadRequest and
</span><span class="c1"></span>	<span class="c1">// has no defined format. The HTTP server in this package
</span><span class="c1"></span>	<span class="c1">// sets RemoteAddr to an &#34;IP:port&#34; address before invoking a
</span><span class="c1"></span>	<span class="c1">// handler.
</span><span class="c1"></span>	<span class="c1">// This field is ignored by the HTTP client.
</span><span class="c1"></span>	<span class="nx">RemoteAddr</span> <span class="kt">string</span>

	<span class="c1">// RequestURI is the unmodified request-target of the
</span><span class="c1"></span>	<span class="c1">// Request-Line (RFC 7230, Section 3.1.1) as sent by the client
</span><span class="c1"></span>	<span class="c1">// to a server. Usually the URL field should be used instead.
</span><span class="c1"></span>	<span class="c1">// It is an error to set this field in an HTTP client request.
</span><span class="c1"></span>	<span class="nx">RequestURI</span> <span class="kt">string</span>

	<span class="c1">// TLS allows HTTP servers and other software to record
</span><span class="c1"></span>	<span class="c1">// information about the TLS connection on which the request
</span><span class="c1"></span>	<span class="c1">// was received. This field is not filled in by ReadRequest.
</span><span class="c1"></span>	<span class="c1">// The HTTP server in this package sets the field for
</span><span class="c1"></span>	<span class="c1">// TLS-enabled connections before invoking a handler;
</span><span class="c1"></span>	<span class="c1">// otherwise it leaves the field nil.
</span><span class="c1"></span>	<span class="c1">// This field is ignored by the HTTP client.
</span><span class="c1"></span>	<span class="nx">TLS</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>

	<span class="c1">// Cancel is an optional channel whose closure indicates that the client
</span><span class="c1"></span>	<span class="c1">// request should be regarded as canceled. Not all implementations of
</span><span class="c1"></span>	<span class="c1">// RoundTripper may support Cancel.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For server requests, this field is not applicable.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Set the Request&#39;s context with NewRequestWithContext
</span><span class="c1"></span>	<span class="c1">// instead. If a Request&#39;s Cancel field and context are both
</span><span class="c1"></span>	<span class="c1">// set, it is undefined whether Cancel is respected.
</span><span class="c1"></span>	<span class="nx">Cancel</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

	<span class="c1">// Response is the redirect response which caused this request
</span><span class="c1"></span>	<span class="c1">// to be created. This field is only populated during client
</span><span class="c1"></span>	<span class="c1">// redirects.
</span><span class="c1"></span>	<span class="nx">Response</span> <span class="o">*</span><span class="nx">Response</span>

	<span class="c1">// ctx is either the client or server context. It should only
</span><span class="c1"></span>	<span class="c1">// be modified via copying the whole Request using WithContext.
</span><span class="c1"></span>	<span class="c1">// It is unexported to prevent people from using Context wrong
</span><span class="c1"></span>	<span class="c1">// and mutating the contexts held by callers of the same request.
</span><span class="c1"></span>	<span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>看看.NET 里对于 web 服务的抽象，仅仅看到末端，不去看完整个继承树的完整图景，我根本无法知道我关心的某个细节在什么位置。进而，我要往整个 http 服务体系里修改任何功能，都无法抛开对整体完整设计的理解和熟悉，还极容易没有知觉地破坏者整体的设计。</p>
<p>说到组合，还有一个关系很紧密的词，叫插件化。大家都用 vscode 用得很开心，它比 visual studio 成功在哪里？如果 vscode 通过添加一堆插件达到 visual studio 具备的能力，那么它将变成另一个和 visual studio 差不多的东西，叫做 vs studio 吧。大家应该发现问题了，我们很多时候其实并不需要 visual studio 的大多数功能，而且希望灵活定制化一些比较小众的能力，用一些小众的插件。甚至，我们希望选择不同实现的同类型插件。这就是组合的力量，各种不同的组合，它简单，却又满足了各种需求，灵活多变，要实现一个插件，不需要事先掌握一个庞大的体系。体现在代码上，也是一样的道理。至少后端开发领域，组合，比 OOP，&lsquo;香&rsquo;很多。</p>
<h3 id="原则-6-吝啬原则-除非确无它法-不要编写庞大的程序">原则 6 吝啬原则: 除非确无它法, 不要编写庞大的程序</h3>
<p>可能有些同学会觉得，把程序写得庞大一些才好拿得出手去评 T11、T12。leader 们一看评审方案就容易觉得：很大，很好，很全面。但是，我们真的需要写这么大的程序么？</p>
<p>我又要说了&quot;那么，古尔丹，代价是什么呢？&quot;。代价是代码越多，越难维护，难调整。C 语言之父 Ken Thompson 说&quot;删除一行代码，给我带来的成就感要比添加一行要大&rdquo;。我们对于代码，要吝啬。能把系统做小，就不要做大。腾讯不乏 200w+行的客户端，很大，很牛。但是，同学们自问，现在还调整得动架构么。手 Q 的同学们，看看自己代码，曾经叹息过么。能小做的事情就小做，寻求通用化，通过 duck interface(甚至多进程，用于隔离能力的多线程)把模块、能力隔离开，时刻想着删减代码量，才能保持代码的可维护性和面对未来的需求、架构，调整自身的活力。客户端代码，UI 渲染模块可以复杂吊炸天，非 UI 部分应该追求最简单，能力接口化，可替换、重组合能力强。</p>
<p>落地到大家的代码，review 时，就应该最关注核心 struct 定义，构建起一个完备的模型，核心 interface，明确抽象 model 对外部的依赖，明确抽象 model 对外提供的能力。其他代码，就是要用最简单、平平无奇的代码实现模型内部细节。</p>
<h3 id="原则-7-透明性原则-设计要可见以便审查和调试">原则 7 透明性原则: 设计要可见，以便审查和调试</h3>
<p>首先，定义一下，什么是透明性和可显性。</p>
<p>&ldquo;如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动的品质。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的，因为可以看透机器究竟在干什么。</p>
<p>如果软件系统所包含的功能是为了帮助人们对软件建立正确的&rsquo;做什么、怎么做&rsquo;的心理模型而设计，这个软件系统就是可显的。因此，举例来说，对用户而言，良好的文档有助于提高可显性；对程序员而言，良好的变量和函数名有助于提高可显性。可显性是一种主动品质。在软件中要达到这一点，仅仅做到不晦涩是不够的，还必须要尽力做到有帮助。&rdquo;</p>
<p>我们要写好程序，减少 bug，就要增强自己对代码的控制力。你始终做到，理解自己调用的函数/复用的代码大概是怎么实现的。不然，你可能就会在单线程状态机的 server 里调用有 IO 阻塞的函数，让自己的 server 吞吐量直接掉到底。进而，为了保证大家能对自己代码能做到有控制力，所有人写的函数，就必须具备很高的透明性。而不是写一些看了一阵看不明白的函数/代码，结果被迫使用你代码的人，直接放弃了对掌控力的追取，甚至放弃复用你的代码，另起炉灶，走向了&rsquo;制造重复代码&rsquo;的深渊。</p>
<p>透明性其实相对容易做到的，大家有意识地锻炼一两个月，就能做得很好。可显性就不容易了。有一个现象是，你写的每一个函数都不超过 80 行，每一行我都能看懂，但是你层层调用，很多函数调用，组合起来怎么就实现了某个功能，看两遍，还是看不懂。第三遍可能才能大概看懂。大概看懂了，但太复杂，很难在大脑里构建起你实现这个功能的整体流程。结果就是，阅读者根本做不到对你的代码有好的掌控力。</p>
<p>可显性的标准很简单，大家看一段代码，懂不懂，一下就明白了。但是，如何做好可显性？那就是要追求合理的函数分组，合理的函数上下级层次，同一层次的代码才会出现在同一个函数里，追求通俗易懂的函数分组分层方式，是通往可显性的道路。</p>
<p>当然，复杂如 linux 操作系统，office 文档，问题本身就很复杂，拆解、分层、组合得再合理，都难建立心理模型。这个时候，就需要完备的文档了。完备的文档还需要出现在离代码最近的地方，让人&rsquo;知道这里复杂的逻辑有文档&rsquo;，而不是其实文档，但是阅读者不知道。再看看上面 golang 标准库里的 http.Request，感受到它在可显性上的努力了么？对，就去学它。</p>
<h3 id="原则-10-通俗原则-接口设计避免标新立异">原则 10 通俗原则: 接口设计避免标新立异</h3>
<p>设计程序过于标新立异的话，可能会提升别人理解的难度。</p>
<p>一般，我们这么定义一个&rsquo;点&rsquo;，使用 x 表示横坐标，用 y 表示纵坐标：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">X</span> <span class="kt">float64</span>
 <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你就是要不同、精准：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">VerticalOrdinate</span>   <span class="kt">float64</span>
 <span class="nx">HorizontalOrdinate</span> <span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很好，你用词很精准，一般人还驳斥不了你。但是，多数人读你的 VerticalOrdinate 就是没有读 X 理解来得快，来得容易懂、方便。你是在刻意制造协作成本。</p>
<p>上面的例子常见，但还不是最小立异原则最想说明的问题。想想一下，一个程序里，你把用&rsquo;+&lsquo;这个符号表示数组添加元素，而不是数学&rsquo;加&rsquo;，&lsquo;result := 1+2&rsquo; &ndash;&gt; &lsquo;result = []int{1, 2}&lsquo;而不是&rsquo;result=3&rsquo;，那么，你这个标新立异，对程序的破坏性，简直无法想象。&ldquo;最小立异原则的另一面是避免表象想死而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同事物有明显区别，而不要看起来几乎一模一样。&rdquo; &ndash; Henry Spencer。</p>
<p>你实现一个 db.Add()函数却做着 db.AddOrUpdate()的操作，有人使用了你的接口，错误地把数据覆盖了。</p>
<h3 id="原则-11-缄默原则-如果一个程序没什么好说的就沉默">原则 11 缄默原则: 如果一个程序没什么好说的，就沉默</h3>
<p>这个原则，应该是大家最经常破坏的原则之一。一段简短的代码里插入了各种&rsquo;log(&ldquo;cmd xxx enter&rdquo;)&rsquo;, &lsquo;log(&ldquo;req data &quot; + req.String())'，非常害怕自己信息打印得不够。害怕自己不知道程序执行成功了，总要最后&rsquo;log(&ldquo;success&rdquo;)'。但是，我问一下大家，你们真的耐心看过别人写的代码打的一堆日志么？不是自己需要哪个，就在一堆日志里，再打印一个日志出来一个带有特殊标记的日志&rsquo;log(&ldquo;this_is_my_log_&rdquo; + xxxxx)'？结果，第一个作者打印的日志，在代码交接给其他人或者在跟别人协作的时候，这个日志根本没有价值，反而提升了大家看日志的难度。</p>
<p>一个服务一跑起来，就疯狂打日志，请求处理正常也打一堆日志。滚滚而来的日志，把错误日志淹没在里面。错误日志失去了效果，简单地 tail 查看日志，眼花缭乱，看不出任何问题，这不就成了&rsquo;为了捕获问题&rsquo;而让自己&rsquo;根本无法捕获问题&rsquo;了么？</p>
<p>沉默是金。除了简单的 stat log，如果你的程序&rsquo;发声&rsquo;了，那么它抛出的信息就一定要有效！打印一个 log(&lsquo;process fail&rsquo;)也是毫无价值，到底什么 fail 了？是哪个用户带着什么参数在哪个环节怎么 fail 了？如果发声，就要把必要信息给全。不然就是不发声，表示自己好好地 work 着呢。不发声就是最好的消息，现在我的 work 一切正常！</p>
<p>&ldquo;设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。&ldquo;程序员自己的主力，也是宝贵的资源！只有有必要的时候，日志才跑来提醒程序员&rsquo;我有问题，来看看&rsquo;，而且，必须要给到足够的信息，让一把讲明白现在发生了什么。而不是程序员还需要很多辅助手段来搞明白到底发生了什么。</p>
<p>每当我发布程序 ，我抽查一个机器，看它的日志。发现只有每分钟外部接入、内部 rpc 的个数/延时分布日志的时候，我就心情很愉悦。我知道，这一分钟，它的成功率又是 100%，没任何问题！</p>
<h3 id="原则-12-补救原则-出现异常时马上退出并给出足够错误信息">原则 12 补救原则: 出现异常时，马上退出并给出足够错误信息</h3>
<p>其实这个问题很简单，如果出现异常，异常并不会因为我们尝试掩盖它，它就不存在了。所以，程序错误和逻辑错误要严格区分对待。这是一个态度问题。</p>
<p>&lsquo;异常是互联网服务器的常态&rsquo;。逻辑错误通过 metrics 统计，我们做好告警分析。对于程序错误 ，我们就必须要严格做到在问题最早出现的位置就把必要的信息搜集起来，高调地告知开发和维护者&rsquo;我出现异常了，请立即修复我!'。可以是直接就没有被捕获的 panic 了。也可以在一个最上层的位置统一做好 recover 机制，但是在 recover 的时候一定要能获得准确异常位置的准确异常信息。不能有中间 catch 机制，catch 之后丢失很多信息再往上传递。</p>
<p>很多 Java 开发的同学，不区分程序错误和逻辑错误，要么都很宽容，要么都很严格，对代码的可维护性是毁灭性的破坏。&ldquo;我的程序没有程序错误，如果有，我当时就解决了。&ldquo;只有这样，才能保持程序代码质量的相对稳定，在火苗出现时扑灭火灾是最好的扑灭火灾的方式。当然，更有效的方式是全面自动化测试的预防：）</p>
<h2 id="具体实践点">具体实践点</h2>
<p>前面提了好多思考方向的问题。大的原则问题和方向。我这里，再来给大家简单列举几个细节执行点吧。毕竟，大家要上手，是从执行开始，然后才是总结思考，能把我的思考方式抄过去。下面是针对 golang 语言的，其他语言略有不同。以及，我一时也想不全我所执行的 所有细则，这就是我强调&rsquo;原则&rsquo;的重要性，原则是可枚举的。</p>
<ul>
<li>
<p>对于代码格式规范，100%严格执行，严重容不得一点沙。</p>
</li>
<li>
<p>文件绝不能超过 800 行，超过，一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。</p>
</li>
<li>
<p>函数对决不能超过 80 行，超过，一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。</p>
</li>
<li>
<p>代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nx">needContinue</span> <span class="p">{</span>
 <span class="nf">doA</span><span class="p">()</span>
 <span class="k">return</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="nf">doB</span><span class="p">()</span>
 <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nx">needContinue</span> <span class="p">{</span>
 <span class="nf">doA</span><span class="p">()</span>
 <span class="k">return</span>
<span class="p">}</span>

<span class="nf">doB</span><span class="p">()</span>
<span class="k">return</span>
</code></pre></td></tr></table>
</div>
</div><p>下面这个就是 early return，把两端代码从逻辑上解耦了。</p>
<ul>
<li>从目录、package、文件、struct、function 一层层下来 ，信息一定不能出现冗余。比如 file.FileProperty 这种定义。只有每个&rsquo;定语&rsquo;只出现在一个位置，才为&rsquo;做好逻辑、定义分组/分层&rsquo;提供了可能性。</li>
<li>多用多级目录来组织代码所承载的信息，即使某一些中间目录只有一个子目录。</li>
<li>随着代码的扩展，老的代码违反了一些设计原则，应该立即原地局部重构，维持住代码质量不滑坡。比如:拆文件；拆函数；用 Session 来保存一个复杂的流程型函数的所有信息；重新调整目录结构。</li>
<li>基于上一点考虑，我们应该尽量让项目的代码有一定的组织、层次关系。我个人的当前实践是除了特别通用的代码，都放在一个 git 里。特别通用、修改少的代码，逐渐独立出 git，作为子 git 连接到当前项目 git，让 goland 的 Refactor 特性、各种 Refactor 工具能帮助我们快速、安全局部重构。</li>
<li>自己的项目代码，应该有一个内生的层级和逻辑关系。flat 平铺展开是非常不利于代码复用的。怎么复用、怎么组织复用，肯定会变成&rsquo;人生难题'。T4-T7 的同学根本无力解决这种难题。</li>
<li>如果被 review 的代码虽然简短，但是你看了一眼却发现不咋懂，那就一定有问题。自己看不出来，就找高级别的同学交流。这是你和别 review 代码的同学成长的时刻。</li>
<li>日志要少打。要打日志就要把关键索引信息带上。必要的日志必须打。</li>
<li>有疑问就立即问，不要怕问错。让代码作者给出解释。不要怕问出极低问题。</li>
<li>不要说&rsquo;建议'，提问题，就是刚，你 pk 不过我，就得改！</li>
<li>请积极使用 trpc。总是要和老板站在一起！只有和老板达成的对于代码质量建设的共识，才能在团队里更好地做好代码质量建设。</li>
<li>消灭重复！消灭重复！消灭重复！</li>
</ul>
<h2 id="主干开发">主干开发</h2>
<p>最后，我来为&rsquo;主干开发&rsquo;多说一句话。道理很简单，只有每次被 review 代码不到 500 行，reviewer 才能快速地看完，而且几乎不会看漏。超过 500 行，reviewer 就不能仔细看，只能大概浏览了。而且，让你调整 500 行代码内的逻辑比调整 3000 行甚至更多的代码，容易很多，降低不仅仅是 6 倍，而是一到两个数量级。有问题，在刚出现的时候就调整了，不会给被 revew 的人带来大的修改负担。</p>
<p>关于 CI(continuous integration)，还有很多好的资料和书籍，大家应该及时去学习学习。</p>
<h2 id="unix-编程艺术">《unix 编程艺术》</h2>
<p>建议大家把这本书找出来读一读。特别是，T7 及更高级别的同学。你们已经积累了大量的代码实践，亟需对&rsquo;工程性&rsquo;做思考总结。很多工程方法论都过时了，这本书的内容，是例外中的例外。它所表达出的内容没有因为软件技术的不断更替而过时。</p>
<p>佛教禅宗讲&rsquo;不立文字'(不立文字，教外别传，直指人心，见性成佛)，很多道理和感悟是不能用文字传达的，文字的表达能力，不能表达。大家常常因为&quot;自己听说过、知道某个道理&quot;而产生一种安心感，认为&quot;我懂了这个道理&rdquo;，但是自己却不能在实践中做到。知易行难，知道却做不到，在工程实践里，就和&rsquo;不懂这个道理&rsquo;没有任何区别了。</p>
<p>曾经，我面试过一个别的公司的总监，讲得好像一套一套，代码拉出来遛一遛，根本就没做到，仅仅会道听途说。他在工程实践上的探索前路可以说已经基本断绝了。我只能祝君能做好向上管理，走自己的纯管理道路吧。请不要再说自己对技术有追求，是个技术人了！</p>
<p>所以，大家不仅仅是看看我这篇文章，而是在实践中去不断践行和积累自己的&rsquo;教外别传&rsquo;吧。</p>
<p>Software Engineering at Google也是一本必读好书，可惜没找到中文翻译。</p>
<h2 id="综述">综述</h2>
<p>我写过一篇《Code Review 我都 CR 些什么》，讲解了 Code Review 对团队有什么价值，我认为 CR 最重要的原则有哪些。最近我在团队工作中还发现了：</p>
<ul>
<li>原则不清晰。对于代码架构的原则，编码的追求，我的骨干员工对它的认识也不是很全面。当前还是在 review 过程中我对他们口口相传，总有遗漏。</li>
<li>从知道到会做需要时间。我需要反复跟他们补充 review 他们漏掉的点，他们才能完成吸收、内化，在后续的 review 过程中，能自己提出这些 review 的点。</li>
</ul>
<p>过度文档化是有害的，当过多的内容需要被阅读，工程师们最终就会选择不去读，读了也仅仅能吸收很少一部分。在 google，对于代码细节的理解，更多还是口口相传，在实践中去感受和理解。但是，适当的文档、文字宣传，是必要的。特此，我就又输出了这一篇文章，尝试从&rsquo;知名架构原则'、&lsquo;工程师的自我修养&rsquo;、&lsquo;不能上升到原则的几个常见案例&rsquo;三大模块，把我个人的经验系统地输出，供其他团队参考。</p>
<h2 id="知名架构原则">知名架构原则</h2>
<p>后面原则主要受《程序员修炼之道: 通向务实的最高境界》、《架构整洁之道》、《Unix 编程艺术》启发。我不是第一个发明这些原则的人，甚至不是第一个总结出来的人，别人都已经写成书了！务实的程序员对于方法的总结，总是殊途同归。</p>
<h3 id="细节即是架构">细节即是架构</h3>
<p>(下面是原文摘录, 我有类似观点, 但是原文就写得很好, 直接摘录)</p>
<p>一直以来，设计(Design)和架构(Architecture)这两个概念让大多数人十分迷惑&ndash;什么是设计？什么是架构？二者究竟有什么区别？二者没有区别。一丁点区别都没有！&ldquo;架构&quot;这个词往往适用于&quot;高层级&quot;的讨论中，这类讨论一般都把&quot;底层&quot;的实现细节排除在外。而&quot;设计&quot;一词，往往用来指代具体的系统底层组织结构和实现的细节。但是，从一个真正的系统架构师的日常工作来看，这些区分是根本不成立的。以给我设计新房子的建筑设计师要做的事情为例。新房子当然是存在着既定架构的，但这个架构具体包含哪些内容呢？首先，它应该包括房屋的形状、外观设计、垂直高度、房间的布局，等等。</p>
<p>但是，如果查看建筑设计师使用的图纸，会发现其中也充斥着大量的设计细节。譬如，我们可以看到每个插座、开关以及每个电灯具体的安装位置，同时也可以看到某个开关与所控制的电灯的具体连接信息；我们也能看到壁炉的具体位置，热水器的大小和位置信息，甚至是污水泵的位置；同时也可以看到关于墙体、屋顶和地基所有非常详细的建造说明。总的来说，架构图里实际上包含了所有的底层设计细节，这些细节信息共同支撑了顶层的架构设计，底层设计信息和顶层架构设计共同组成了整个房屋的架构文档。</p>
<p>软件设计也是如此。底层设计细节和高层架构信息是不可分割的。他们组合在一起，共同定义了整个软件系统，缺一不可。所谓的底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。</p>
<p>我们编写、review 细节代码，就是在做架构设计的一部分。我们编写的细节代码构成了整个系统。我们就应该在细节 review 中，总是带着所有架构原则去审视。你会发现，你已经写下了无数让整体变得丑陋的细节，它们背后，都有前人总结过的架构原则。</p>
<h3 id="把代码和文档绑在一起自解释原则">把代码和文档绑在一起(自解释原则)</h3>
<p>写文档是个好习惯。但是写一个别人需要咨询老开发者才能找到的文档，是个坏习惯。这个坏习惯甚至会给工程师们带来伤害。比如，当初始开发者写的文档在一个犄角旮旯(在 wiki 里，但是阅读代码的时候没有在明显的位置看到链接)，后续代码被修改了，文档已经过时，有人再找出文档来获取到过时、错误的知识的时候，阅读文档这个同学的开发效率必然受到伤害。所以，如同 golang 的 godoc 工具能把代码里&rsquo;按规范来&rsquo;的注释自动生成一个文档页面一样，我们应该:</p>
<ul>
<li>按照 godoc 的要求好好写代码的注释。</li>
<li>代码首先要自解释，当解释不了的时候，需要就近、合理地写注释。</li>
<li>当小段的注释不能解释清楚的时候，应该有 doc.go 来解释，或者，在同级目录的 ReadMe.md 里注释讲解。</li>
<li>文档需要强大的富文本编辑能力，Down 无法满足，可以写到 wiki 里，同时必须把 wiki 的简单描述和链接放在代码里合适的位置。让阅读和维护代码的同学一眼就看到，能做到及时的维护。</li>
</ul>
<p>以上，总结起来就是，解释信息必须离被解释的东西，越近越好。代码能做到自解释，是最棒的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617212317.png" alt=""></p>
<h3 id="etc-价值观easy-to-change">ETC 价值观(easy to change)</h3>
<p>ETC 是一种价值观念，不是一条原则。价值观念是帮助你做决定的: 我应该做这个，还是做那个？当你在软件领域思考时，ETC 是个向导，它能帮助你在不同的路线中选出一条。就像其他一些价值观念一样，你应该让它漂浮在意识思维之下，让它微妙地将你推向正确的方向。</p>
<p>敏捷软件工程，所谓敏捷，就是要能快速变更，并且在变更中保持代码的质量。所以，持有 ETC 价值观看待代码细节、技术方案，我们将能更好地编写出适合敏捷项目的代码。这是一个大的价值观，不是一个基础微观的原则，所以没有例子。本文提到的所有原则，或者接，或间接，都要为 ETC 服务。</p>
<h3 id="dry-原则don-not-repeat-yourself">DRY 原则(don not repeat yourself)</h3>
<p>在《Code Review 我都 CR 些什么》里面，我已经就 DRY 原则做了深入阐述，这里不再赘述。我认为 DRY 原则是编码原则中最重要的编码原则，没有之一(ETC 是个观念)。不要重复！不要重复！不要重复！</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617212435.png" alt=""></p>
<h3 id="正交性原则全局变量的危害">正交性原则(全局变量的危害)</h3>
<p>&lsquo;正交性&rsquo;是几何学中的术语。我们的代码应该消除不相关事物之间的影响。这是一给简单的道理。我们写代码要&rsquo;高内聚、低耦合&rsquo;，这是大家都在提的。</p>
<p>但是，你有为了使用某个 class 一堆能力中的某个能力而去派生它么？你有写过一个 helper 工具，它什么都做么？在腾讯，我相信你是做过的。你自己说，你这是不是为了复用一点点代码，而让两大块甚至多块代码耦合在一起，不再正交了？大家可能并不是不明白正交性的价值，只是不知道怎么去正交。手段有很多，但是首先我就要批判一下 OOP。它的核心是多态，多态需要通过派生/继承来实现。继承树一旦写出来，就变得很难 change，你不得不为了使用一小段代码而去做继承，让代码耦合。</p>
<p>你应该多使用组合，而不是继承。以及，应该多使用 DIP(Dependence Inversion Principle)，依赖倒置原则。换个说法，就是面向 interface 编程，面向契约编程，面向切面编程，他们都是 DIP 的一种衍生。写 golang 的同学就更不陌生了，我们要把一个 struct 作为一个 interface 来使用，不需要显式 implement/extend，仅仅需要持有对应 interface 定义了的函数。这种 duck interface 的做法，让 DIP 来得更简单。AB 两个模块可以独立编码，他们仅仅需要一个依赖一个 interface 签名，一个刚好实现该 interface 签名。并不需要显式知道对方 interface 签名的两个模块就可以在需要的模块、场景下被组合起来使用。代码在需要被组合使用的时候才产生了一点关系，同时，它们依然保持着独立。</p>
<p>说个正交性的典型案例。全局变量是不正交的！没有充分的理由，禁止使用全局变量。全局变量让依赖了该全局变量的代码段互相耦合，不再正交。特别是一个 pkg 提供一个全局变量给其他模块修改，这个做法会让 pkg 之间的耦合变得复杂、隐秘、难以定位。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617212913.png" alt=""></p>
<h3 id="单例就是全局变量">单例就是全局变量</h3>
<p>这个不需要我解释，大家自己品一品。后面有&rsquo;共享状态就是不正确的状态&rsquo;原则，会进一步讲到。我先给出解决方案，可以通过管道、消息机制来替代共享状态/使用全局变量/使用单例。仅仅能获取此刻最新的状态，通过消息变更状态。要拿到最新的状态，需要重新获取。在必要的时候，引入锁机制。</p>
<h3 id="可逆性原则">可逆性原则</h3>
<p>可逆性原则是很少被提及的一个原则。可逆性，就是你做出的判断，最好都是可以被逆转的。再换一个容易懂的说法，你最好尽量少认为什么东西是一定的、不变的。比如，你认为你的系统永远服务于，用 32 位无符号整数(比如 QQ 号)作为用户标识的系统。你认为，你的持久化存储，就选型 SQL 存储了。当这些一开始你认为一定的东西，被推翻的时候，你的代码却很难去 change，那么，你的代码就是可逆性做得很差。书里有一个例证，我觉得很好，直接引用过来。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617212941.png" alt=""></p>
<p>与其认为决定是被刻在石头上的，还不如把它们想像成写在沙滩的沙子上。一个大浪随时都可能袭来，卷走一切。腾讯也确实在 20 年内经历了&rsquo;大铁块&rsquo;到&rsquo;云虚拟机换成容器&rsquo;的几个阶段。几次变化都是伤筋动骨，浪费大量的时间。甚至总会有一些上一个时代残留的服务。就机器数量而论，还不小。一到裁撤季，就很难受。就最近，我看到某个 trpc 插件，直接从环境变量里读取本机 IP，仅仅因为 STKE(Tencent Kubernetes Engine)提供了这个能力。这个细节设计就是不可逆的，将来会有人为它买单，可能价格还不便宜。</p>
<p>我今天才想起一个事儿。当年 SNG 的很多部门对于 metrics 监控的使用。就潜意识地认为，我们将一直使用&rsquo;模块间调用监控&rsquo;组件。使用它的 API 是直接把上报通道 DCLog 的 API 裸露在业务代码里的。今天(2020.12.01)，该组件应该已经完全没有人维护、完全下线了，这些核心业务代码要怎么办？有人能对它做出修改么？那，这些部门现在还有 metrics 监控么？答案，可能是悲观的。有人已经已经尝到了可逆性之痛。</p>
<h3 id="依赖倒置原则dip">依赖倒置原则(DIP)</h3>
<p>DIP 原则太重要了，我这里单独列一节来讲解。我这里只是简单的讲解，讲解它最原始和简单的形态。依赖倒置原则，全称是 Dependence Inversion Principle，简称 DIP。考虑下面这几段代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">dip</span>

<span class="kd">type</span> <span class="nx">Botton</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">TurnOn</span><span class="p">()</span>
    <span class="nf">TurnOff</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">UI</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">botton</span> <span class="nx">Botton</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewUI</span><span class="p">(</span><span class="nx">b</span> <span class="nx">Botton</span><span class="p">)</span> <span class="o">*</span><span class="nx">UI</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">UI</span><span class="p">{</span><span class="nx">botton</span><span class="p">:</span> <span class="nx">b</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">UI</span><span class="p">)</span> <span class="nf">Poll</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">botton</span><span class="p">.</span><span class="nf">TurnOn</span><span class="p">()</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">botton</span><span class="p">.</span><span class="nf">TurnOff</span><span class="p">()</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">botton</span><span class="p">.</span><span class="nf">TurnOn</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">javaimpl</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Lamp</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewLamp</span><span class="p">()</span> <span class="o">*</span><span class="nx">Lamp</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Lamp</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Lamp</span><span class="p">)</span> <span class="nf">TurnOn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;turn on java lamp&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Lamp</span><span class="p">)</span> <span class="nf">TurnOff</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;turn off java lamp&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">pythonimpl</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Lamp</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewLamp</span><span class="p">()</span> <span class="o">*</span><span class="nx">Lamp</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Lamp</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Lamp</span><span class="p">)</span> <span class="nf">TurnOn</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;turn on python lamp&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Lamp</span><span class="p">)</span> <span class="nf">TurnOff</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;turn off python lamp&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;javaimpl&#34;</span>
    <span class="s">&#34;pythonimpl&#34;</span>
    <span class="s">&#34;dip&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">runPoll</span><span class="p">(</span><span class="nx">b</span> <span class="nx">dip</span><span class="p">.</span><span class="nx">Botton</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ui</span> <span class="o">:=</span> <span class="nf">NewUI</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="nx">ui</span><span class="p">.</span><span class="nf">Poll</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">runPoll</span><span class="p">(</span><span class="nx">pythonimpl</span><span class="p">.</span><span class="nf">NewLamp</span><span class="p">())</span>
    <span class="nf">runPoll</span><span class="p">(</span><span class="nx">javaimpl</span><span class="p">.</span><span class="nf">NewLamp</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>看代码，main pkg 里的 runPoll 函数仅仅面向 Botton interface 编码，main pkg 不再关心 Botton interface 里定义的 TurnOn、TurnOff 的实现细节。实现了解耦。这里，我们能看到 struct UI 需要被注入(inject)一个 Botton interface 才能逻辑完整。所以，DIP 经常换一个名字出现，叫做依赖注入(Dependency Injection)。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617213332.png" alt=""></p>
<p>从这个依赖图观察。我们发现，一般来说，UI struct 的实现是要应该依赖于具体的 pythonLamp、javaLamp、其他各种 Lamp，才能让自己的逻辑完整。那就是 UI struct 依赖于各种 Lamp 的实现，才能逻辑完整。但是，我们看上面的代码，却是反过来了。pythonLamp、javaLamp、其他各种 Lamp 是依赖 Botton interface 的定义，才能用来和 UI struct 组合起来拼接成完整的业务逻辑。变成了，Lamp 的实现细节，依赖于 UI struct 对于 Botton interface 的定义。这个时候，你发现，这种依赖关系被倒置了！依赖倒置原则里的&rsquo;倒置&rsquo;，就是这么来的。在 golang 里，&lsquo;pythonLamp、javaLamp、其他各种 Lamp 是依赖 Botton interface 的定义&rsquo;，这个依赖是隐性的，没有显式的 implement 和 extend 关键字。代码层面，pkg dip 和 pkg pythonimpl、javaimpl 没有任何依赖关系。他们仅仅需要被你在 main pkg 里组合起来使用。</p>
<p>在 J2EE 里，用户的业务逻辑不再依赖低具体低层的各种存储细节，而仅仅依赖一套配置化的 Java Bean 接口。Object 落地存储的具体细节，被做成了 Java Bean 配置，注入到框架里。这就是 J2EE 的核心科技，并不复杂，其实也没有多么&rsquo;高不可攀'。反而，在&rsquo;动态代码&rsquo;优于&rsquo;配置&rsquo;的今天，这种通过配置实现的依赖注入，反而有点过时了。</p>
<h3 id="将知识用纯文本来保存">将知识用纯文本来保存</h3>
<p>这也是一个生僻的原则。指代码操作的数据和方案设计文稿，如果没有充分的必要使用特定的方案，就应该使用人类可读的文本来保存、交互。对于方案设计文稿，你能不使用 office 格式，就不使用(office 能极大提升效率，才用)，最好是原始 text。这是《Unix 编程艺术》也提到了的 Unix 系产生的设计信条。简而言之一句话，当需要确保有一个所有各方都能使用的公共标准，才能实现交互沟通时，纯文本就是这个标准。它是一个接受度最高的通行标准。如果没有必要的理由，我们就应该使用纯文本。</p>
<h3 id="契约式设计">契约式设计</h3>
<p>如果你对契约式设计(Design by Contract, DBC)还很陌生，我相信，你和其他端的同学(web、client、后端)联调需求应该是一件很花费时间的事情。你自己编写接口自动化，也会是一件很耗费精力的事情。你先看看它的wiki 解释吧。grpc + grpc-gateway + swagger 是个很香的东西。</p>
<p>代码是否不多不少刚好完成它宣称要做的事情，可以使用契约加以校验和文档化。TDD 就是全程在不断调整和履行着契约。TDD(Test-Driven Development)是自底向上地编码过程，其实会耗费大量的精力，并且对于一个良好的层级架构没有帮助。TDD 不是强推的规范，但是同学们可以用一用，感受一下。TDD 方法论实现的接口、函数，自我解释能力一般来说比较强，因为它就是一个实现契约的过程。</p>
<p>抛开 TDD 不谈。我们的函数、api，你能快速抓住它描述的核心契约么？它的契约简单么？如果不能、不简单，那你应该要求被 review 的代码做出调整。如果你在指导一个后辈，你应该帮他思考一下，给出至少一个可能的简化、拆解方向。</p>
<h3 id="尽早崩溃">尽早崩溃</h3>
<p>Erlang 和 Elixir 语言信奉这种哲学。乔-阿姆斯特朗，Erlang 的发明者，《Erlang 程序设计》的作者，有一句反复被引用的话: &ldquo;防御式编程是在浪费时间，让它崩溃&rdquo;。</p>
<p>尽早崩溃不是说不容错，而是程序应该被设计成允许出故障，有适当的故障监管程序和代码，及时告警，告知工程师，哪里出问题了，而不是尝试掩盖问题，不让程序员知道。当最后程序员知道程序出故障的时候，已经找不到问题出现在哪里了。</p>
<p>特别是一些 recover 之后什么都不做的代码，这种代码简直是毒瘤！当然，崩溃，可以是早一些向上传递 error，不一定就是 panic。同时，我要求大家不要在没有充分的必要性的时候 panic，应该更多地使用向上传递 error，做好 metrics 监控。合格的 golang 程序员，都不会在没有必要的时候无视 error，会妥善地做好 error 处理、向上传递、监控。一个死掉的程序，通常比一个瘫痪的程序，造成的损害要小得多。</p>
<p>崩溃但是不告警,或者没有补救的办法,不可取.尽早崩溃的题外话是,要在问题出现的时候做合理的告警,有预案,不能掩盖,不能没有预案：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617213434.png" alt=""></p>
<h3 id="解耦代码让改变容易">解耦代码让改变容易</h3>
<p>这个原则，显而易见，大家自己也常常提，其他原则或多或少都和它有关系。但是我也再提一提。我主要是描述一下它的症状，让同学们更好地警示自己&rsquo;我这两块代码是不是耦合太重，需要额外引入解耦的设计了'。症状如下:</p>
<ul>
<li>不相关的 pkg 之间古怪的依赖关系</li>
<li>对一个模块进行的&rsquo;简单&rsquo;修改，会传播到系统中不相关的模块里，或是破坏了系统中的其他部分</li>
<li>开发人员害怕修改代码，因为他们不确定会造成什么影响</li>
<li>会议要求每个人都必须参加，因为没有人能确定谁会受到变化的影响
只管命令不要询问</li>
</ul>
<p>看看如下三段代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">applyDiscount</span><span class="p">(</span><span class="nx">customer</span> <span class="nx">Customer</span><span class="p">,</span> <span class="nx">orderID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">discount</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">customer</span><span class="p">.</span>
  <span class="nx">Orders</span><span class="p">.</span>
  <span class="nf">Find</span><span class="p">(</span><span class="nx">orderID</span><span class="p">).</span>
  <span class="nf">GetTotals</span><span class="p">().</span>
  <span class="nf">ApplyDiscount</span><span class="p">(</span><span class="nx">discount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">applyDiscount</span><span class="p">(</span><span class="nx">customer</span> <span class="nx">Customer</span><span class="p">,</span> <span class="nx">orderID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">discount</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">customer</span><span class="p">.</span>
  <span class="nf">FindOrder</span><span class="p">(</span><span class="nx">orderID</span><span class="p">).</span>
  <span class="nf">GetTotals</span><span class="p">().</span>
  <span class="nf">ApplyDiscount</span><span class="p">(</span><span class="nx">discount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">applyDiscount</span><span class="p">(</span><span class="nx">customer</span> <span class="nx">Customer</span><span class="p">,</span> <span class="nx">orderID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">discount</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">customer</span><span class="p">.</span>
  <span class="nf">FindOrder</span><span class="p">(</span><span class="nx">orderID</span><span class="p">).</span>
  <span class="nf">ApplyDiscount</span><span class="p">(</span><span class="nx">discount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>明显，最后一段代码最简洁。不关心 Orders 成员、总价的存在，直接命令 customer 找到 Order 并对其进行打折。当我们调整 Orders 成员、GetTotals()方法的时候，这段代码不用修改。还有一种更吓人的写法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">applyDiscount</span><span class="p">(</span><span class="nx">customer</span> <span class="nx">Customer</span><span class="p">,</span> <span class="nx">orderID</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">discount</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">total</span> <span class="o">:=</span> <span class="nx">customer</span><span class="p">.</span>
  <span class="nf">FindOrder</span><span class="p">(</span><span class="nx">orderID</span><span class="p">).</span>
  <span class="nf">GetTotals</span><span class="p">()</span>
 <span class="nx">customer</span><span class="p">.</span>
  <span class="nf">FindOrder</span><span class="p">(</span><span class="nx">orderID</span><span class="p">).</span>
  <span class="nf">SetTotal</span><span class="p">(</span><span class="nx">total</span><span class="o">*</span><span class="nx">discount</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它做了更多的查询，关心了更多的细节，变得更加 hard to change 了。我相信，大家写过类似的代码也不少。特别是客户端同学。</p>
<p>最好的那一段代码，就是只管给每个 struct 发送命令，要求大家做事儿。怎么做，就内聚在和 struct 关联的方法里，其他人不要去操心。一旦其他人操心了，当需要做修改的时候，就要操心了这个细节的人都一起参与进修改过程。</p>
<h3 id="不要链式调用方法">不要链式调用方法</h3>
<p>看下面的例子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">amount</span><span class="p">(</span><span class="nx">customer</span> <span class="nx">Customer</span><span class="p">)</span> <span class="kt">float32</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">customer</span><span class="p">.</span><span class="nx">Orders</span><span class="p">.</span><span class="nf">Last</span><span class="p">().</span><span class="nf">Totals</span><span class="p">().</span><span class="nx">Amount</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">amount</span><span class="p">(</span><span class="nx">totals</span> <span class="nx">Totals</span><span class="p">)</span> <span class="kt">float32</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">totals</span><span class="p">.</span><span class="nx">Amount</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第二个例子明显优于第一个，它变得更简单、通用、ETC。我们应该给函数传入它关心的最小集合作为参数。而不是，我有一个 struct，当某个函数需要这个 struct 的成员的时候，我们把整个 struct 都作为参数传递进去。应该仅仅传递函数关心的最小集合。传进去的一整条调用链对函数来说，都是无关的耦合，只会让代码更 hard to change，让工程师惧怕去修改。这一条原则，和上一条关系很紧密，问题常常同时出现。还是，特别是在客户端代码里。</p>
<h3 id="继承税多用组合">继承税(多用组合)</h3>
<p>继承就是耦合。不仅子类耦合到父类，以及父类的父类等，而且使用子类的代码也耦合到所有祖先类。 有些人认为继承是定义新类型的一种方式。他们喜欢设计图表，会展示出类的层次结构。他们看待问题的方式，与维多利亚时代的绅士科学家们看待自然的方式是一样的，即将自然视为须分解到不同类别的综合体。 不幸的是，这些图表很快就会为了表示类之间的细微差别而逐层添加，最终可怕地爬满墙壁。由此增加的复杂性，可能使应用程序更加脆弱，因为变更可能在许多层次之间上下波动。 因为一些值得商榷的词义消歧方面的原因，C++在20世纪90年代玷污了多重继承的名声。结果，许多当下的OO语言都没有提供这种功能。</p>
<p>因此，即使你很喜欢复杂的类型树，也完全无法为你的领域准确地建模。</p>
<p>Java 下一切都是类。C++里不使用类还不如使用 C。写 Python、PHP，我们也肯定要时髦地写一些类。写类可以，当你要去继承，你就得考虑清楚了。继承树一旦形成，就是非常 hard to change 的，在敏捷项目里，你要想清楚&rsquo;代价是什么'，有必要么？这个设计&rsquo;可逆&rsquo;么？对于边界清晰的 UI 框架、游戏引擎，使用复杂的继承树，挺好的。对于 UI 逻辑、后台逻辑，可能，你仅仅需要组合、DIP(依赖反转)技术、契约式编程(接口与协议)就够了。写出继承树不是&rsquo;就应该这么做'，它是成本，继承是要收税的！</p>
<p>在 golang 下，继承税的烦恼被减轻了，golang 从来说自己不是 OO 的语言，但是你 OO 的事情，我都能轻松地做到。更进一步，OO 和过程式编程的区别到底是什么？</p>
<p>面向过程，面向对象，函数式编程。三种编程结构的核心区别，是在不同的方向限制程序员，来做到好的代码结构(引自《架构整洁之道》):</p>
<ul>
<li>结构化编程是对程序控制权的直接转移的限制。</li>
<li>面向对象是对程序控制权的间接转移的限制。</li>
<li>函数式编程是对程序中赋值操作的限制。</li>
</ul>
<p>SOLID 原则(单一功能、开闭原则、里氏替换、接口隔离、依赖反转，后面会讲到)是 OOP 编程的最经典的原则。其中 D 是指依赖倒置原则(Dependence Inversion Principle)，我认为，是 SOLID 里最重要的原则。J2EE 的 container 就是围绕 DIP 原则设计的。DIP 能用于避免构建复杂的继承树，DIP 就是&rsquo;限制控制权的间接转移&rsquo;能继续发挥积极作用的最大保障。合理使用 DIP 的 OOP 代码才可能是高质量的代码。</p>
<p>golang 的 interface 是 duck interface，把 DIP 原则更进一步，不需要显式 implement/extend interface，就能做到 DIP。golang 使用结构化编程范式，却有面向对象编程范式的核心优点，甚至简化了。这是一个基于高度抽象理解的极度精巧的设计。google 把 abstraction 这个设计理念发挥到了极致。曾经，J2EE 的 container(EJB, Java Bean)设计是国内 Java 程序员引以为傲&rsquo;架构设计'、&lsquo;厉害的设计&rsquo;。</p>
<p>在 golang 里，它被分析、解构，以更简单、灵活、统一、易懂的方式呈现出来。写了多年垃圾 C++代码的腾讯后端工程师们，是你们再次审视 OOP 的时候了。我大学一年级的时候看的 C++教材，终归给我描述了一个美好却无法抵达的世界。目标我没有放弃，但我不再用 OOP，而是更多地使用组合(Mixin)。写 golang 的同学，应该对 DIP 和组合都不陌生，这里我不再赘述。如果有人自傲地说他在 golang 下搞起了继承，我只能说，&lsquo;同志，你现在站在了广大 gopher 的对立面&rsquo;。现在，你站在哲学的云端，鸟瞰了 Structured Programming 和 OOP。你还愿意再继续支付继承税么？</p>
<h3 id="共享状态是不正确的状态">共享状态是不正确的状态</h3>
<p>你坐在最喜欢的餐厅。吃完主菜，问男服务员还有没有苹果派。他回头一看-陈列柜里还有一个，就告诉你&quot;还有&rdquo;。点到了苹果派，你心满意足地长出了一口气。与此同时，在餐厅的另一边，还有一个顾客也问了女服务员同样的问题。她也看了看，确认有一个，让顾客点了单。总有一个顾客会失望的。</p>
<p>问题出在共享状态。餐厅里的每一个服务员都查看了陈列柜，却没有考虑到其他服务员。你们可以通过加互斥锁来解决正确性的问题，但是，两个顾客有一个会失望或者很久都得不到答案，这是肯定的。</p>
<p>所谓共享状态，换个说法，就是: 由多个人查看和修改状态。这么一说，更好的解决方案就浮出水面了: 将状态改为集中控制。预定苹果派，不再是先查询，再下单。而是有一个餐厅经理负责和服务员沟通，服务员只管发送下单的命令/消息，经理看情况能不能满足服务员的命令。</p>
<p>这种解决方案，换一个说法，也可以说成&quot;用角色实现并发性时不必共享状态&rdquo;。对，上面，我们引入了餐厅经理这个角色，赋予了他职责。当然，我们仅仅应该给这个角色发送命令，不应该去询问他。前面讲过了，&lsquo;只管命令不要询问&rsquo;，你还记得么。</p>
<p>同时，这个原则就是 golang 里大家耳熟能详的谚语: &ldquo;不要通过共享内存来通信，而应该通过通信来共享内存&rdquo;。作为并发性问题的根源，内存的共享备受关注。但实际上，在应用程序代码共享可变资源(文件、数据库、外部服务)的任何地方，问题都有可能冒出来。当代码的两个或多个实例可以同时访问某些资源时，就会出现潜在的问题。</p>
<h3 id="缄默原则">缄默原则</h3>
<p>如果一个程序没什么好说，就保持沉默。过多的正常日志，会掩盖错误信息。过多的信息，会让人根本不再关注新出现的信息，&lsquo;更多信息&rsquo;变成了&rsquo;没有信息&rsquo;。每人添加一点信息，就变成了输出很多信息，最后等于没有任何信息。</p>
<ul>
<li>不要在正常 case 下打印日志。</li>
<li>不要在单元测试里使用 fmt 标准输出，至少不要提交到 master。</li>
<li>不打不必要的日志。当错误出现的时候，会非常明显，我们能第一时间反应过来并处理。</li>
<li>让调试的日志停留在调试阶段，或者使用较低的日志级别，你的调试信息，对其他人根本没有价值。</li>
<li>即使低级别日志，也不能泛滥。不然，日志打开与否都没有差别，日志变得毫无价值。
<img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617213724.png" alt=""></li>
</ul>
<h3 id="错误传递原则">错误传递原则</h3>
<p>我不喜欢 Java 和 C++的 exception 特性，它容易被滥用，它具有传染性(如果代码 throw 了 excepttion, 你就得 handle 它，不 handle 它，你就崩溃了。可能你不希望崩溃，你仅仅希望报警)。但是 exception(在 golang 下是 panic)是有价值的，参考微软的文章:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Exceptions</span> <span class="n">are</span> <span class="n">preferred</span> <span class="n">in</span> <span class="n">modern</span> <span class="n">C</span><span class="o">++</span> <span class="n">for</span> <span class="n">the</span> <span class="n">following</span> <span class="n">reasons</span><span class="o">:</span>

<span class="o">*</span> <span class="n">An</span> <span class="n">exception</span> <span class="n">forces</span> <span class="n">calling</span> <span class="n">code</span> <span class="n">to</span> <span class="n">recognize</span> <span class="n">an</span> <span class="n">error</span> <span class="n">condition</span> <span class="n">and</span> <span class="n">handle</span> <span class="n">it.</span> <span class="n">Unhandled</span> <span class="n">exceptions</span> <span class="n">stop</span> <span class="n">program</span> <span class="n">execution.</span>
<span class="o">*</span> <span class="n">An</span> <span class="n">exception</span> <span class="n">jumps</span> <span class="n">to</span> <span class="n">the</span> <span class="n">point</span> <span class="n">in</span> <span class="n">the</span> <span class="n">call</span> <span class="n">stack</span> <span class="n">that</span> <span class="n">can</span> <span class="n">handle</span> <span class="n">the</span> <span class="n">error.</span> <span class="n">Intermediate</span> <span class="n">functions</span> <span class="n">can</span> <span class="n">let</span> <span class="n">the</span> <span class="n">exception</span> <span class="n">propagate.</span> <span class="n">They</span> <span class="n">don</span><span class="s">&#39;</span><span class="err">t have to coordinate with other layers.</span>
<span class="o">*</span> <span class="n">The</span> <span class="n">exception</span> <span class="n">stack</span><span class="o">-</span><span class="n">unwinding</span> <span class="n">mechanism</span> <span class="n">destroys</span> <span class="n">all</span> <span class="n">objects</span> <span class="n">in</span> <span class="n">scope</span> <span class="n">after</span> <span class="n">an</span> <span class="n">exception</span> <span class="n">is</span> <span class="n">thrown</span><span class="p">,</span> <span class="n">according</span> <span class="n">to</span> <span class="n">well</span><span class="o">-</span><span class="n">defined</span> <span class="n">rules.</span>
<span class="o">*</span> <span class="n">An</span> <span class="n">exception</span> <span class="n">enables</span> <span class="n">a</span> <span class="n">clean</span> <span class="n">separation</span> <span class="n">between</span> <span class="n">the</span> <span class="n">code</span> <span class="n">that</span> <span class="n">detects</span> <span class="n">the</span> <span class="n">error</span> <span class="n">and</span> <span class="n">the</span> <span class="n">code</span> <span class="n">that</span> <span class="n">handles</span> <span class="n">the</span> <span class="n">error.</span>
</code></pre></td></tr></table>
</div>
</div><p>Google 的 C++规范在常规情况禁用 exception，理由包含如下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">Because</span> <span class="n">most</span> <span class="n">existing</span> <span class="n">C</span><span class="o">++</span> <span class="n">code</span> <span class="n">at</span> <span class="n">Google</span> <span class="n">is</span> <span class="n">not</span> <span class="n">prepared</span> <span class="n">to</span> <span class="n">deal</span> <span class="n">with</span> <span class="n">exceptions</span><span class="p">,</span> <span class="n">it</span> <span class="n">is</span> <span class="n">comparatively</span> <span class="n">difficult</span> <span class="n">to</span> <span class="n">adopt</span> <span class="n">new</span> <span class="n">code</span> <span class="n">that</span> <span class="n">generates</span> <span class="n">exceptions.</span>
</code></pre></td></tr></table>
</div>
</div><p>从 google 和微软的文章中，我们不难总结出以下几点衍生的结论:</p>
<ul>
<li>在必要的时候抛出 exception。使用者必须具备&rsquo;必要性&rsquo;的判断能力。</li>
<li>exception 能一路把底层的异常往上传递到高函数层级，信息被向上传递，并且在上级被妥善处理。可以让异常和关心具体异常的处理函数在高层级和低层级遥相呼应，中间层级什么都不需要做，仅仅向上传递。</li>
<li>exception 传染性很强。当代码由多人协作，使用 A 模块的代码都必须要了解它可能抛出的异常，做出合理的处理。不然，就都写一个丑陋的 catch，catch 所有异常，然后做一个没有针对性的处理。每次 catch 都需要加深一个代码层级，代码常常写得很丑。</li>
</ul>
<p>我们看到了异常的优缺点。上面第二点提到的信息传递，是很有价值的一点。golang 在 1.13 版本中拓展了标准库，支持了Error Wrapping也是承认了 error 传递的价值。</p>
<p>所以，我们认为错误处理，应该具备跨层级的错误信息传递能力，中间层级如果不关心，就把 error 加上本层的信息向上透传(有时候可以直接透传)，应该使用 Error Wrapping。exception/panic 具有传染性。大量使用，会让代码变得丑陋，同时容易滋生可读性问题。我们应该多使用 Error Wrapping，在必要的时候，才使用 exception/panic。每一次使用 exception/panic，都应该被认真审核。需要 panic 的地方，不去 panic，也是有问题的。参考本文的&rsquo;尽早崩溃'。</p>
<p>额外说一点，注意不要把整个链路的错误信息带到公司外，带到用户的浏览器、native 客户端。至少不能直接展示给用户看到。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210617213805.png" alt=""></p>
<h3 id="solid">SOLID</h3>
<p>SOLID 原则，是由以下几个原则的集合体:</p>
<ul>
<li>SRP: 单一职责原则</li>
<li>OCP: 开闭原则</li>
<li>LSP: 里氏替换原则</li>
<li>ISP: 接口隔离原则</li>
<li>DIP: 依赖反转原则</li>
</ul>
<p>这些年来，这几个设计原则在很多不同的出版物里都有过详细描述。它们太出名了，我这里就不更多地做详解了。我这里想说的是，这 5 个原则环环相扣，前 4 个原则，要么就是同时做到，要么就是都没做到，很少有说，做到其中一点其他三点都不满足。ISP 就是做到 LSP 的常用手段。ISP 也是做到 DIP 的基础。只是，它刚被提出来的时候，是主要针对&rsquo;设计继承树&rsquo;这个目的的。现在，它们已经被更广泛地使用在模块、领域、组件这种更大的概念上。</p>
<p>SOLI 都显而易见，DIP 原则是最值得注意的一点，我在其他原则里也多次提到了它。如果你还不清楚什么是 DIP，一定去看明白。这是工程师最基础、必备的知识点之一了。</p>
<p>要做到 OCP 开闭原则，其实，就是要大家要通过后面讲到的&rsquo;不要面向需求编程&rsquo;才能做好。如果你还是面向需求、面向 UI、交互编程，你永远做不到开闭，并且不知道如何才能做到开闭。</p>
<p>如果你对这些原则确实不了解，建议读一读《架构整洁之道》。该书的作者 Bob 大叔，就是第一个提出 SOLID 这个集合体的人(20 世纪 80 年代末，在 USENET 新闻组)。</p>
<h3 id="一个函数不要出现多个层级的代码">一个函数不要出现多个层级的代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// IrisFriends 拉取好友
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">IrisFriends</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">iris</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">app</span> <span class="o">*</span><span class="nx">app</span><span class="p">.</span><span class="nx">App</span><span class="p">)</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="nx">rsp</span> <span class="nx">sdc</span><span class="p">.</span><span class="nx">FriendsRsp</span>
 <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">_</span> <span class="p">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">jsonpb</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">{</span><span class="nx">EmitDefaults</span><span class="p">:</span> <span class="kc">true</span><span class="p">}).</span><span class="nf">Marshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">rsp</span><span class="p">)</span>
  <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
 <span class="p">}()</span>
 <span class="nx">common</span><span class="p">.</span><span class="nf">AdjustCookie</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
 <span class="k">if</span> <span class="p">!</span><span class="nf">checkCookie</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span>
 <span class="p">}</span>

 <span class="c1">// 从cookie中拿到关键的登陆态等有效信息
</span><span class="c1"></span> <span class="kd">var</span> <span class="nx">session</span> <span class="nx">common</span><span class="p">.</span><span class="nx">BaseSession</span>
 <span class="nx">common</span><span class="p">.</span><span class="nf">GetBaseSessionFromCookie</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">session</span><span class="p">)</span>
 <span class="c1">// 校验登陆态
</span><span class="c1"></span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">common</span><span class="p">.</span><span class="nf">CheckLoginSig</span><span class="p">(</span><span class="nx">session</span><span class="p">,</span> <span class="nx">app</span><span class="p">.</span><span class="nx">ConfigStore</span><span class="p">.</span><span class="nf">Get</span><span class="p">().</span><span class="nx">OIDBCmdSetting</span><span class="p">.</span><span class="nx">PTLogin</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">_</span> <span class="p">=</span> <span class="nx">common</span><span class="p">.</span><span class="nf">ErrorResponse</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">PTSigErr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;check login sig error&#34;</span><span class="p">)</span>
  <span class="k">return</span>
 <span class="p">}</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">getRelationship</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">app</span><span class="p">.</span><span class="nx">ConfigStore</span><span class="p">.</span><span class="nf">Get</span><span class="p">().</span><span class="nx">OIDBCmdSetting</span><span class="p">,</span> <span class="nf">NewAPI</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">rsp</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="c1">// TODO:日志
</span><span class="c1"></span> <span class="p">}</span>
 <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面这一段代码，是我随意找的一段代码。逻辑非常清晰，因为除了最上面 defer 写回包的代码，其他部分都是顶层函数组合出来的。阅读代码，我们不会掉到细节里出不来，反而忽略了整个业务流程。同时，我们能明显发现它没写完，以及 common.ErrorResponse 和 defer func 两个地方都写了回包，可能出现发起两次 http 回包。TODO 也会非常显眼。</p>
<p>想象一下，我们没有把细节收归进 checkCookie()、getRelationship()等函数，而是展开在这里，但是总函数行数没有到 80 行，表面上符合规范。但是实际上，阅读代码的同学不再能轻松掌握业务逻辑，而是同时在阅读功能细节和业务流程。阅读代码变成了每个时刻心智负担都很重的事情。</p>
<p>显而易见，单个函数里应该只保留某一个层级(layer)的代码，更细化的细节应该被抽象到下一个 layer 去，成为子函数。</p>
<h3 id="unix-哲学基础">Unix 哲学基础</h3>
<p>《Code Review 我都 CR 些什么》讲解了很多 Unix 的设计哲学。这里不再赘述，仅仅列举一下。大家自行阅读和参悟，并且运用到编码、review 活动中。</p>
<ul>
<li>模块原则: 使用简洁的接口拼合简单的部件</li>
<li>清晰原则: 清晰胜于技巧</li>
<li>组合原则: 设计时考虑拼接组合</li>
<li>分离原则: 策略同机制分离，接口同引擎分离</li>
<li>简洁原则: 设计要简洁，复杂度能低则低</li>
<li>吝啬原则: 除非确无它法，不要编写庞大的程序</li>
<li>透明性原则: 设计要可见，以便审查和调试</li>
<li>健壮原则: 健壮源于透明与简洁</li>
<li>表示原则: 把知识叠入数据以求逻辑质朴而健壮</li>
<li>通俗原则: 接口设计避免标新立异</li>
<li>缄默原则: 如果一个程序没什么好说，就保持沉默</li>
<li>补救原则: 出现异常时，马上退出并给出足量错误信息</li>
<li>经济原则: 宁花机器一分，不花程序员一秒</li>
<li>生成原则: 避免手工 hack，尽量编写程序去生成程序</li>
<li>优化原则: 雕琢前先得有原型，跑之前先学会走</li>
<li>多样原则: 绝不相信所谓&quot;不二法门&quot;的断言</li>
<li>扩展原则: 设计着眼未来，未来总比预想快</li>
</ul>
<h2 id="工程师的自我修养">工程师的自我修养</h2>
<p>下面，是一些在 review 细节中不能直接使用的原则。更像是一种信念和自我约束。带着这些信念去编写、review 代码，把这些信念在实践中传递下去，将是极有价值的。</p>
<h3 id="偏执">偏执</h3>
<p>对代码细节偏执的观念，是我自己提出的新观点。在当下研发质量不高的腾讯，是很有必要普遍存在的一个观念。在一个系统不完善、时间安排荒谬、工具可笑、需求不可能实现的世界里，让我们安全行事吧。就像伍迪-艾伦说的:&ldquo;当所有人都真的在给你找麻烦的时候，偏执就是一个好主意。&rdquo;</p>
<p>对于一个方案，一个实现，请不要说出&quot;好像这样也可以&rdquo;。你一定要选出一个更好的做法，并且一直坚持这个做法，并且要求别人也这样做。既然他来让你 review 了，你就要有自己的偏执，你一定要他按照你觉得合适的方式去做。当然，你得有说服得了自己，也说服得了他人的理由。即使，只有一点点。偏执会让你的世界变得简单，你的团队的协作变得简单。特别当你身处一个编码质量低下的团队的时候。你至少能说，我是一个务实的程序员。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618104943.png" alt=""></p>
<h3 id="控制软件的熵是软件工程的重要任务之一">控制软件的熵是软件工程的重要任务之一</h3>
<p>熵是个物理学概念，大家可能看过诺兰的电影《信条》。简单来说，熵可以理解为&rsquo;混乱程度'。我们的项目，在刚开始的几千行代码，是很简洁的。但是，为什么到了 100w 行，我们常常就感觉&rsquo;太复杂了'？比如 QQ 客户端，最近终于在做大面积重构，但是发现无数 crash。其中一个重要原因，就是&rsquo;混乱程度&rsquo;太高了。&lsquo;混乱程度&rsquo;，理解起来还是比较抽象，它有很多其他名字。&lsquo;hard code 很多&rsquo;、&lsquo;特殊逻辑很多&rsquo;、&lsquo;定制化逻辑很多&rsquo;。再换另一个抽象的说法，&lsquo;我们面对一类问题，采取了过多的范式和特殊逻辑细节去实现它&rsquo;。</p>
<p>熵，是一点点堆叠起来的，在一个需求的 2000 行代码更改中，你可能就引入了一个不同的范式，打破了之前的通用范式。在微观来看，你觉得你的代码是&rsquo;整洁干净&rsquo;的。就像一个已经穿着好看的红色风衣的人，你隔一天让他接着穿上一条绿色的裤子，这还干净整洁么？熵，在不断增加，我们需要做到以下几点，不然你的团队将在希望通过重构来降低项目的熵的时候尝到恶果，甚至放弃重构，让熵不断增长下去。</p>
<ul>
<li>如果没有充分的理由，始终使用项目规范的范式对每一类问题做出解决方案。</li>
<li>如果业务发展发现老的解决方案不再优秀，做整体重构。</li>
<li>项目级主干开发，对重构很友好，让重构变得可行。(客户端很容易实现主干开发)。</li>
<li>务实地讲，重构已经不可能了。那么，你们可以谨慎地提出新的一整套范式。重建它。</li>
<li>禁止 hardcode，特殊逻辑。如果你发现特殊逻辑容易实现需求，否则很难。那么，你的架构已经出现问题了，你和你的团队应该深入思考这个问题，而不是轻易加上一个特殊逻辑。</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618105544.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618105553.png" alt=""></p>
<h3 id="为测试做设计">为测试做设计</h3>
<p>现在我们在做&rsquo;测试左移'，让工程师编写自动化测试来保证质量。测试工程师的工作更多的是类似 google SET(Software Engineer In Test, 参考《google 软件测试之道》)的工作。工作重心在于测试编码规范、测试编码流程、测试编码工具、测试平台的思考和建设。测试代码，还是得工程师来做。</p>
<p>为方法写一个测试的考虑过程，使我们得以从外部看待这个方法，这让我们看起来是代码的客户，而不是代码的作者。很多同学，就感觉很难受。对，这是必然的。因为你的代码设计的时候，并没有把&rsquo;容易测试&rsquo;考虑进去，可测试性不强。如果工程师在开发逻辑的过程中，就同时思考着这段代码怎样才能轻松地被测试。那么，这段写就的代码，同时可读性、简单性都会得到保障，经过了良好的设计，而不仅仅是&rsquo;能工作'。</p>
<p>我觉得，测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是在运行测试的时候！在编码的时候同时让思考怎么测试的思维存在，会让编写高质量的代码变得简单，在编码时就更多地考虑边界条件、异常条件，并且妥善处理。仅仅是抱有这个思维，不去真地编写自动化测试，就能让代码的质量上升，代码架构的能力得到提升。</p>
<p>硬件工程出 bug 很难查，bug 造成的成本很高，每次都要重新做一套模具、做模具的工具。所以硬件工程往往有层层测试，极早发现问题，尽量保证简单且质量高。我们可以在软件上做同样的事情。与硬件工程师一样，从一开始就在软件中构建可测试性，并且尝试将每个部分连接在一起之前，对他们进行彻底的测试。</p>
<p>这个时候，有人就说，TDD 就是这样，让你同时思考编码架构和测试架构。我对 TDD 的态度是: 它不一定就是最好的。测试对开发的驱动，绝对有帮助。但是，就像每次驱动汽车一样，除非心里有一个目的地，否则就可能会兜圈子。TDD 是一种自底向上的编程方法。但是，适当的时候使用自顶向下设计，才能获得一个最好的整体架构。很多人处理不好自顶向下和自底向上的关系，结果在使用 TDD 的时候发现举步维艰、收效甚微。</p>
<p>以及，如果没有强大的外部驱动力，&ldquo;以后再测&quot;实际上意味着&quot;永远不测&rdquo;。大家，务实一点，在编码时就考虑怎么测试。不然，你永远没有机会考虑了。当面对着测试性低的代码，需要编写自动化测试的时候，你会感觉很难受。</p>
<h3 id="尽早测试-经常测试-自动测试">尽早测试, 经常测试, 自动测试</h3>
<p>一旦代码写出来，就要尽早开始测试。这些小鱼的恶心之处在于，它们很快就会变成巨大的食人鲨，而捕捉鲨鱼则相当困难。所以我们要写单元测试，写很多单元测试。</p>
<p>事实上，好项目的测试代码可能会比产品代码更多。生成这些测试代码所花费的时间是值得的。从长远来看，最终的成本会低得多，而且你实际上有机会生产出几乎没有缺陷的产品。</p>
<p>另外，知道通过了测试，可以让你对代码已经&quot;完成&quot;产生高度信心。</p>
<h3 id="项目中使用统一的术语">项目中使用统一的术语</h3>
<p>如果用户和开发者使用不同的名称来称呼相同的事物，或者更糟糕的是，使用相同的名称来代指不同的事物，那么项目就很难取得成功。</p>
<p>DDD(Domain-Driven Design)把&rsquo;项目中使用统一的术语&rsquo;做到了极致，要求项目把目标系统分解为不同的领域(也可以称作上下文)。在不同的上下文中，同一个术语名字意义可能不同，但是要项目内统一认识。比如证券这个词，是个多种经济权益凭证的统称，在股票、债券、权证市场，意义和规则是完全不同的。当你第一次听说&rsquo;涡轮(港股特有金融衍生品，是一种股权)&lsquo;的时候，是不是瞬间蒙圈，搞不清它和证券的关系了。买&rsquo;涡轮&rsquo;是在买什么鬼证劵？</p>
<p>在软件领域是一样的。你需要对股票、债券、权证市场建模，你就得有不同的领域，在每个领域里有一套词汇表(实体、值对象)，在不同的领域之间，同一个概念可能会换一个名字，需要映射。如果你们既不区分领域，甚至在同一个领域还对同一个实体给出不同的名字。那，你们怎么确保自己沟通到位了？写成代码，别人如何知道你现在写的&rsquo;证券&rsquo;这个 struct 具体是指的什么？</p>
<h3 id="不要面向需求编程">不要面向需求编程</h3>
<p>需求不是架构；需求无关设计，也非用户界面；需求就是需要的东西。需要的东西是经常变化的，是不断被探索，不断被加深认识的。产品经理的说辞是经常变化的。当你面向需求编程，你就是在依赖一个认识每一秒都在改变的女/男朋友。你将身心俱疲。</p>
<p>我们应该面向业务模型编程。我在《Code Review 我都 CR 些什么》里也提到了这一点，但是我当时并没有给出应该怎么去设计业务模型的指导。我的潜台词就是，你还是仅仅能凭借自己的智力和经验，没有很多方法论工具。</p>
<p>现在，我给你推荐一个工具，DDD(Domain-Driven Design)，面向领域驱动设计。它能让你对业务更好地建模，让对业务建模变成一个可拆解的执行步骤，仅仅需要少得多的智力和经验。区分好领域上下文，思考明白它们之间的关系，找到领域下的实体和值对象，找到和模型贴合的架构方案。这些任务，让业务建模变得简单。</p>
<p>当我们面向业务模型编程，变更的需求就变成了&ndash;提供给用户他所需要的业务模型的不同部分。我们不再是在不断地 change 代码，而是在不断地 extend 代码，逐渐做完一个业务模型的填空题。</p>
<h3 id="写代码要有对于美的追求">写代码要有对于&rsquo;美&rsquo;的追求</h3>
<p>google 的很多同学说(至少 hankzheng 这么说)，软件工程=科学+艺术。当前腾讯，很多人，不讲科学。工程学，计算机科学，都不管。就喜欢搞&rsquo;巧合式编程&rsquo;。刚好能工作了，打完收工，交付需求。绝大多数人，根本不追求编码、设计的艺术。对细节的好看，毫无感觉。对于一个空格、空行的使用，毫无逻辑，毫无美感。用代码和其他人沟通，连基本的整洁、合理都不讲。根本没想过，别人会看我的代码，我要给代码&rsquo;梳妆打扮&rsquo;一下，整洁大方，美丽动人，还极有内涵。&lsquo;窈窕淑女，君子好逑&rsquo;，我们应该对别人慷慨一点，你总是得阅读别人的代码的。大家都对美有一点追求，就是互相都慷慨一些。</p>
<p>很无奈，我把对美的追求说得这么&rsquo;卑微'。必须要由&rsquo;务实的需要&rsquo;来构建必要性。而不是每个工程师发自内心的，像对待漂亮的异性、好的音乐、好的电影一样的发自内心的需要它。认为代码也是取悦别人、取悦自己的东西。</p>
<p>如果我们想做一个有尊严、有格调的工程师，我们就应该把自己的代码、劳动的产物，当成一件艺术品去雕琢。务实地追求效率，同时也追求美感。效率产出价值，美感取悦自己。不仅仅是为了一口饭，同时也把工程师的工作当成自己一个快乐的源头。工作不再是 overhead，而是 happiness。此刻，你做不到，但是应该有这样的追求。当我们都有了这样的追求，有一天，我们会能像 google 一样做到的 。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618105655.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618110850.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618110900.png" alt=""></p>
<h3 id="应用程序框架是实现细节">应用程序框架是实现细节</h3>
<p>以下是《整洁架构之道》的原文摘抄：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618110935.png" alt=""></p>
<p>对，DIP 大发神威。我觉得核心做法就是:</p>
<ul>
<li>核心代码应该通过 DIP 来让它不要和具体框架绑定！它应该使用 DIP(比如代理类)，抽象出一个防腐层，让自己的核心代码免于腐坏。
选择一个框架，你不去做防腐层(主要通过 DIP)，你就是单方面领了结婚证，你只有义务，没有权利。同学们要想明白。同学们应该对框架本身是否优秀，是否足够组件化，它本身能否在项目里做到可插拔，做出思考和设计。</li>
<li>trpc-go 对于插件化这事儿，做得还不错，大家会积极地使用它。trpc-cpp 离插件化非常远，它自己根本就成不了一个插件，而是有一种要强暴你的感觉，你能凭直觉明显地感觉到不愿意和它订终身。例如，trpc-cpp 甚至强暴了你构建、编译项目的方式。当然，这很多时候是 c++语言本身的问题。</li>
</ul>
<p>‘解耦’、&lsquo;插件化’就是 golang 语言的关键词。大家开玩笑说，c++已经被委员会玩坏了，加入了太多特性。less is more, more means nothing。c++从来都是让别的工具来解决自己的问题，trpc-cpp 可能把自己松绑定到 bazel 等优秀的构建方案。寻求优秀的组件去软绑定，提供解决方案，是可行的出路。我个人喜欢 rust。但是大家还是熟悉 cpp，我们确实需要一个投入更多人力做得更好的 trpc-cpp。</p>
<h3 id="一切都应该是代码通过代码去显式组合">一切都应该是代码(通过代码去显式组合)</h3>
<p>Unix 编程哲学告诉我们: 如果有一些参数是可变的，我们应该使用配置，而不是把参数写死在代码里。在腾讯，这一点做得很好。但是，大人，现在时代又变了。</p>
<p>J2EE 框架让我们看到，组件也可以是通过配置 Java Bean 的形式注入到框架里的。J2EE 实现了把组件也配置化的壮举。但是，时代变了！你下载一个 golang 编译器，你进入你下载的文件里去看，会发现你找不到任何配置文件。这是为什么？两个简单，但是很多年都被人们忽略的道理:</p>
<ul>
<li>配置即隐性耦合。配置只有和使用配置的代码组合使用，它才能完成它的工作。它是通过把&rsquo;一个事情分开两个步骤&rsquo;来换取动态性。换句话说，它让两个相隔十万八千里的地方产生了耦合！作为工程师，你一开始就要理解双倍的复杂度。配置如何使用、配置的处理程序会如何解读配置。</li>
<li>代码能够有很强的自解释能力，工程师们更愿意阅读可读性强的代码，而不是编写得很烂的配置文档。配置只能通过厚重的配置说明书去解释。当你缺乏完备的配置说明书，配置变成了地狱。</li>
</ul>
<p>golang 的编译器是怎么做的呢？它会在代码里给你设定一个通用性较强的默认配置项。同时，配置项都是集中管理的，就像管理配置文件一样。你可以通过额外配置一个配置文件或者命令行参数，来改变编译器的行为。这就变成了，代码解释了每一个配置项是用来做什么的。只有当你需要的时候，你会先看懂代码，然后，当你有需求的时候，通过额外的配置去改变一个你有预期的行为。</p>
<p>逻辑变成了。一开始，所有事情都是解耦的。一件事情都只看一块代码就能明白。代码有较好的自解释性和注解，不再需要费劲地编写撇脚的文档。当你明白之后，你需要不一样的行为，就通过额外的配置来实现。关于怎么配置，代码里也讲明白了。</p>
<p>对于 trpc-go 框架，以及一众插件，优先考虑配置，然后才是代码去指定，部分功能还只能通过配置去指定，我就很难受。我接受它，就得把一个事情放在两个地方去完成:</p>
<ul>
<li>需要在代码里 import 插件包。</li>
<li>需要在配置文件里配置插件参数。</li>
</ul>
<p>既然不能消灭第一步，为什么不能是显式 import，同时通过代码+其他自定义配置管理方案去完成插件的配置？当然，插件，直接不需要任何配置，提供代码 Option 去改变插件的行为，是最香的。这个时候，我就真的能把 trpc 框架本身也当成一个插件来使用了。</p>
<h3 id="封装不一定是好的组织形式">封装不一定是好的组织形式</h3>
<p>封装(Encapsulation)，是我上学时刚接触 OOP，惊为天人的思想方法。但是，我工作了一些年头了，看过了不知道多少腐烂的代码。其中一部分还需要我来维护。我看到了很多莫名其妙的封装，让我难受至极。封装，经常被滥用。封装的时候，我们一定要让自己的代码，自己就能解释自己是按照下面的哪一种套路在做封装:</p>
<ul>
<li>按层封装</li>
<li>按功能封装</li>
<li>按领域封装</li>
<li>按组件封装</li>
</ul>
<p>或者，其他能被命名到某种有价值的类型的封装。你要能说出为什么你的封装是必要的，有价值的。必要的时候，你必须要封装。比如，当你的 golang 函数达到了 80 行，你就应该对逻辑分组，或者把一块过于细节化却功能单一的较长的代码独立到一个函数。同时，你又不能胡乱封装，或者过度封装。是否过度，取决于大家的共识，要 reviwer 能认可你这个封装是有价值的。当然，你也会成为 reviewer，别人也需要获得你的认可。缺乏意图设计的封装，是破坏性的。这会使其他人在面对这段代码时，畏首畏尾，不敢修改它。形成一个腐烂的肉块，并且，这种腐烂会逐渐蔓延开来。</p>
<p>所以，所有细节都是关键的。每一块砖头都被精心设计，才能构建一个漂亮的项目！</p>
<h3 id="所有细节都应该被显式处理">所有细节都应该被显式处理</h3>
<p>这是一个显而易见的道理。但是很多同学却毫无知觉。我为需要深入阅读他们编写的代码的同学默哀一秒。当有一个函数 func F() error，我仅仅是用 F()，没有用变量接收它的返回值。你阅读代码的时候，你就会想，第一开发者是忘记了 error handling 了，还是他思考过了，他决定不关注这个返回值？他是设计如此，还是这里是个 bug？他人即地狱，维护代码的苦难又多了一分。</p>
<p>我们对于自己的代码可能会给别人带来困扰的地方，都应该显式地去处理。就像写了一篇不会有歧义的文章。如果就是想要忽略错误，'<em>= F()&lsquo;搞定。我将来再处理错误逻辑，'</em> = F() // TODO 这里需要更好地处理错误&rsquo;。在代码里，把事情讲明白，所有人都能快速理解他人的代码，就能快速做出修改的决策。&lsquo;猜测他人代码的逻辑用意&rsquo;是很难受且困难的，他人的代码也会在这种场景下，产生被误读。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111337.png" alt=""></p>
<h2 id="不能上升到原则的一些常见案例">不能上升到原则的一些常见案例</h2>
<h3 id="合理注释一些并不通俗的逻辑和数值">合理注释一些并不&rsquo;通俗&rsquo;的逻辑和数值</h3>
<p>和&rsquo;所有细节都应该被显式处理&rsquo;一脉相承。所有他人可能要花较多时间猜测原因的细节，都应该在代码里提前清楚地讲明白。请慷慨一点。也可能，三个月后的将来，是你回来 eat your own dog food。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111353.png" alt=""></p>
<h3 id="习惯留下-todo">习惯留下 TODO</h3>
<p>要这么做的道理很简单。便于所有人能接着你开发。极有可能就是你自己接着自己开发。如果没有标注 TODO 把没有做完的事情标示出来。可能，你自己都会搞忘自己有事儿没做完了。留下 TODO 是很简单的事情，我们为什么不做呢？</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111406.png" alt=""></p>
<h3 id="不要丢弃错误信息">不要丢弃错误信息</h3>
<p>即&rsquo;错误传递原则&rsquo;。这里给它换个名字&ndash;你不应该主动把很多有用的信息给丢弃了。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111418.png" alt=""></p>
<h3 id="自动化测试要快">自动化测试要快</h3>
<p>在 google，自动化测试是硬性要求在限定时间内跑完的。这从细节上保障了自动化测试的速度，进而保障了自动化测试的价值和可用性。你真的需要 sleep 这么久？应该认真考量。考量清楚了把原因写下来。当大家发现总时长太长的时候，可以选择其中最不必要的部分做优化。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111429.png" alt=""></p>
<h3 id="历史有问题的代码-发现了问题要及时-push-相关人主动解决">历史有问题的代码, 发现了问题要及时 push 相关人主动解决</h3>
<p>这是&rsquo;控制软件的熵是软件工程的重要任务之一&rsquo;的表现之一。我们是团队作战，不是无组织无记录的部队。发现了问题，就及时抛出和解决。让伤痛更少，跑得更快。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111441.png" alt=""></p>
<h3 id="less-is-more">less is more</h3>
<p>less is more. 《Code Review 我都 CR 些什么》强调过了，这里不再强调。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111449.png" alt=""></p>
<h3 id="如果打了错误日志-有效信息必须充足-且不过多">如果打了错误日志, 有效信息必须充足, 且不过多</h3>
<p>和&rsquo;less is more&rsquo;一脉相承。同时，必须有的时候，就得有，不能漏。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111502.png" alt=""></p>
<h3 id="注释要把问题讲清楚-讲不清楚的日志等于没有">注释要把问题讲清楚, 讲不清楚的日志等于没有</h3>
<p>是个简单的道理，和&rsquo;所有细节都应该被显式处理&rsquo;一脉相承。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111525.png" alt=""></p>
<h3 id="mr-要自己先-review-不要浪费-reviewer-的时间">MR 要自己先 review, 不要浪费 reviewer 的时间</h3>
<p>你也会成为 reviewer，节省他人的时间，他人也节省你的时间。缩短交互次数，提升 review 的愉悦感。让他人提的 comment 都是&rsquo;言之有物&rsquo;的东西，而不是一些反反复复的最基础的细节。会让他人更愉悦，自己在看 comment 的时候，也更愉悦，更愿意去讨论、沟通。让 code review 成为一个技术交流的平台。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111538.png" alt=""></p>
<h3 id="要寻找合适的定语">要寻找合适的定语</h3>
<p>这个显而易见。但是，同学们就是爱放纵自己？</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111549.png" alt=""></p>
<h3 id="不要出现特定-ip或者把什么可变的东西写死">不要出现特定 IP,或者把什么可变的东西写死</h3>
<p>这个和&rsquo;ETC&rsquo;一脉相承，我觉得也是显而易见的东西。但是很多同学还是喜欢放纵自己？</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111822.png" alt=""></p>
<h3 id="使用定语-不要-1234">使用定语, 不要 1、2、3、4</h3>
<p>这个存粹就是放纵自己了。当然，也会有只能用 1、2、3、4 的时候。但是，你这里，是么？多数时候，都不会是。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111847.png" alt=""></p>
<h3 id="有必要才使用-init">有必要才使用 init</h3>
<p>这，也显而易见。init 很方便，但是，它也会带来心智负担。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618111905.png" alt=""></p>
<h3 id="要关注-shadow-write">要关注 shadow write</h3>
<p>这个很重要，看例子就知道了。但是大家常常忽略，特此提一下。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618112009.png" alt=""></p>
<h3 id="能不耦合接收器就别耦合">能不耦合接收器就别耦合</h3>
<p>减少耦合是我们保障代码质量的重要手段。请把 ETC 原则放在自己的头上漂浮着，时刻带着它思考，不要懒惰。熟能生巧，它并不会成为心智负担。反而常常会在你做决策的时候帮你快速找到方向，提升决策速度。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618112019.png" alt=""></p>
<h3 id="空实现需要注明空实现就是实现">空实现需要注明空实现就是实现</h3>
<p>这个和&rsquo;所有细节都应该被显式处理&rsquo;一脉相承。这个理念，我见过无数种形式表现出来。这里就是其中一种。列举这个 case，让你印象再深刻一点。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210618112030.png" alt=""></p>
<h3 id="看错题集没多少有用-我们需要教练和传承">看错题集没多少有用, 我们需要教练和传承</h3>
<p>上面我列了很多例子。是我能列出来的例子中的九牛一毛。但是，我列一个非常庞大的错题集没有任何用。我也不再例举更多。只有当大家信奉了敏捷工程的美。认可好的代码架构对于业务的价值，才能真正地做到举一反三，理解无数例子，能对更多的 case 自己做出合理的判断。同时，把好的判断传播起来，做到&quot;群体免疫&rdquo;，最终做好 review，做好代码质量。</p>
<h3 id="展望">展望</h3>
<p>希望本文能帮助到需要做好 CR、做好编码，需要培养更多 reviwer 的团队。让你门看到很多原则，吸收这些原则和理念。去理解、相信这些理念。在 CR 中把这些理念、原则传播出去。成为别人的临时教练，让大家都成为合格的 reviwer。加强对于代码的交流，飞轮效应，让团队构建好的人才梯度和工程文化。</p>
<p>写到最后，我发现，我上面写的这些东西都不那么重要了。你有想把代码写得更利于团队协作的价值观和态度，反而是最重要的事情。上面讲的都仅仅是写高质量代码的手段和思想方法。当你认可了&rsquo;应该编写利于团队协作的高质量代码&rsquo;，并且拥有对&rsquo;不利于团队代码质量的代码&rsquo;嫉恶如仇的态度。你总能找到高质量代码的写法。没有我帮你总结，你也总会掌握！</p>
<h3 id="拾遗">拾遗</h3>
<p>如果你深入了解 DDD，就会了解到&rsquo;六边形架构'、&lsquo;CQRS(Command Query Responsibility Segregation，查询职责分离)架构&rsquo;、&lsquo;事件驱动架构&rsquo;等关键词。这是 DDD 构建自己体系的基石，这些架构及是细节又是顶层设计，也值得了解一下。</p>
<h2 id="转载">转载</h2>
<p><a href="https://mp.weixin.qq.com/s/c3RApB8a98tWahgC9mahJg">万字详文告诉你如何做 Code Review</a></p>
<p><a href="https://mp.weixin.qq.com/s/XIwfj_AdZqX_vHM4VIq9EA">万字详文阐释程序员修炼之道</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-06-17
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E8%A7%84%E8%8C%83/">Go规范</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%ADmake%E5%92%8Cnew%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">基本原语make和new源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/">
            <span class="next-text nav-default">Go语言面向对象设计</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
