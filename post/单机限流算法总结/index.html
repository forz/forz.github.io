<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>单机限流算法总结 | Forz Blog</title>
<meta name="keywords" content="限流" />
<meta name="description" content="限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="单机限流算法总结" />
<meta property="og:description" content="限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-11-04T11:51:54&#43;00:00" />
<meta property="article:modified_time" content="2019-11-04T11:51:54&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="单机限流算法总结"/>
<meta name="twitter:description" content="限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "单机限流算法总结",
      "item": "/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "单机限流算法总结",
  "name": "单机限流算法总结",
  "description": "限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统",
  "keywords": [
    "限流"
  ],
  "articleBody": "限流 在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统中更是如此，限流是高并发系统的一大杀器，在设计限流算法之前我们先来了解一下它们是什么。\n限流的英文是 Rate limit（速率限制），维基百科中的定义比较简单。我们编写的程序可以被外部调用，Web 应用通过浏览器或者其他方式的 HTTP 方式访问，接口的访问频率可能会非常快，如果我们没有对接口访问频次做限制可能会导致服务器无法承受过高的压力挂掉，这时候也可能会产生数据丢失。\n而限流算法就可以帮助我们去控制每个接口或程序的函数被调用频率，它有点儿像保险丝，防止系统因为超过访问频率或并发量而引起瘫痪。我们可能在调用某些第三方的接口的时候会看到类似这样的响应头：\n1 2 3  X-RateLimit-Limit: 60 //每秒60次请求 X-RateLimit-Remaining: 23 //当前还剩下多少次 X-RateLimit-Reset: 1540650789 //限制重置时间   上面的 HTTP Response 是通过响应头告诉调用方服务端的限流频次是怎样的，保证后端的接口访问上限。为了解决限流问题出现了很多的算法，它们都有不同的用途，通常的策略就是拒绝超出的请求，或者让超出的请求排队等待。\n计数器法 计数器是最简单的限流算法，思路是维护一个单位时间内的计数器 Counter，如判断单位时间已经过去，则将计数器归零。\n我们假设有个需求对于某个接口 /query 每分钟最多允许访问 200 次。\n 可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。 当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。  如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。 如果该请求与第一个请求的间隔时间大于 1 分钟，且 count 值还在限流范围内，就重置 count。    伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type Counter struct { Count uint // 初始计数器  Limit uint // 时间窗口最大请求频次  Interval int64 // 单位毫秒 ms  RefreshTime int64 // 时间窗口 } func (c *Counter) rateLimit() bool { now := time.Now().Unix() if now  (c.RefreshTime + c.Interval) { // 在时间窗口内  c.Count++ return c.Count  c.Limit } else { c.RefreshTime = now c.Count = 0 // 超时重置  return true } }   这种方法虽然简单，但也有个大问题就是没有很好的处理单位时间的边界。\n假设有个用户在第 59 秒的最后几毫秒瞬间发送 200 个请求，当 59 秒结束后 Counter 清零了，他在下一秒的时候又发送 200 个请求。那么在 1 秒钟内这个用户发送了 2 倍的请求，如下图：\n这种方式的缺点在于它没有更细粒度的划分临界点，如果我们可以把这个时间窗口划分成 6 份，每一份代表 10 秒，当然你可以将它划分的更细。那么如何解决这里的临界问题呢？来看看下面的滑动窗口吧。\n滑动窗口 所谓 滑动窗口（Sliding window） 是一种流量控制技术，这个词出现在 TCP 协议中。我们来看看在限流中它是怎样表现的：\n上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。\n那么滑动窗口如何解决我们上面遇到的问题呢？来看下面的图：\n当用户在 0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。\n通过上面的分析相信你了解什么是滑动窗口了，回想一下其实计数器就是滑动窗口啊，只不过只有一个格子而已，所以我们想让限流做的更精确只需要划分更多的格子就可以了，真是秒啊！为了更精确我们也不知道到底该设置多少个格子，所以又出了 2 种流行的平滑限流算法分别是漏桶算法和令牌桶算法，继续往下看。\n漏桶算法 漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。\n如图所示，把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。\n可以看出，漏桶算法可以很好的控制流量的访问速度，一旦超过该速度就拒绝服务。\n这张图中有 2 个变量，一个是桶的大小（capacity），另一个是水桶漏洞的大小（rate），那么我们可以写下如下代码来实现：\n伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  type LeakyBucket struct { Capacity int64 // 桶的容量  Rate int64 // 漏桶出水速度  Water int64 // 当前水量(当前累积请求数)  RefreshTime int64 } func (b *LeakyBucket) rateLimit() bool { now := time.Now().Unix() // 先执行漏水，计算剩余水量  b.Water = max(0, b.Water-(now-b.RefreshTime)*b.Rate); b.RefreshTime = now if b.Water  b.Capacity { // 水桶还没满，继续加 1  b.Water++ return true } else { // 水满，拒绝流入  return false } } func max(a int64, b int64) int64 { if b  a { return b } return a }   漏桶算法有以下特点：\n 漏桶具有固定容量，出水速率是固定常量（流出请求） 如果桶是空的，则不需流出水滴 可以以任意速率流入水滴到漏桶（流入请求） 如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）  漏桶限制的是常量流出速率（即流出速率是一个固定常量值），所以最大的速率就是出水的速率，不能出现突发流量。\n令牌桶算法 令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。\n令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。\n从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。当请求来的时候，从桶里移除一个令牌，如果桶是空的则拒绝请求或者阻塞。\n伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  type TokenBucket struct { Capacity int64 // 桶的容量  Rate int64 // 令牌放入速度  Tokens int64 // 当前令牌数量  RefreshTime int64 } func (t *TokenBucket) rateLimit() bool { now := time.Now().Unix() // 先添加令牌  t.Tokens = min(t.Capacity, t.Tokens+(now-t.RefreshTime)*t.Rate); t.RefreshTime = now if t.Tokens  1 { // 令牌数小于 1 拒绝请求  return false } else { // 还有令牌，领取令牌  t.Tokens-- return true } }   令牌桶有以下特点：\n 令牌按固定的速率被放入令牌桶中 桶中最多存放 B 个令牌，当桶满时，新添加的令牌被丢弃或拒绝 如果桶中的令牌不足 N 个，则不会删除令牌，且请求将被限流（丢弃或阻塞等待）  令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量。\n算法比较 计数器和滑动窗口 计数器算法实现起来最简单，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。\n漏桶和令牌桶 漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。漏桶算法与令牌桶算法的区别在于，漏桶算法能够强行限制数据的传输速率，令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输:\n  漏桶:漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。\n  令牌桶:生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。\n  需要注意的是，在某些情况下，漏桶算法不能够有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。\n参考:\nhttps://www.jianshu.com/p/a59c13e70582\nhttps://blog.biezhi.me/2018/10/rate-limit-algorithm.html\n",
  "wordCount" : "3192",
  "inLanguage": "zh-cn",
  "datePublished": "2019-11-04T11:51:54Z",
  "dateModified": "2019-11-04T11:51:54Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%8D%95%E6%9C%BA%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      单机限流算法总结
    </h1>
    <div class="post-meta">November 4, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="限流">限流<a hidden class="anchor" aria-hidden="true" href="#限流">#</a></h1>
<p>在开发中我们可能会遇到接口访问频次过高，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制也可能是用了一些流行的类库实现。在分布式系统中更是如此，限流是高并发系统的一大杀器，在设计限流算法之前我们先来了解一下它们是什么。</p>
<p>限流的英文是 Rate limit（速率限制），维基百科中的定义比较简单。我们编写的程序可以被外部调用，Web 应用通过浏览器或者其他方式的 HTTP 方式访问，接口的访问频率可能会非常快，如果我们没有对接口访问频次做限制可能会导致服务器无法承受过高的压力挂掉，这时候也可能会产生数据丢失。</p>
<p>而限流算法就可以帮助我们去控制每个接口或程序的函数被调用频率，它有点儿像保险丝，防止系统因为超过访问频率或并发量而引起瘫痪。我们可能在调用某些第三方的接口的时候会看到类似这样的响应头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">X-RateLimit-Limit: 60         //每秒60次请求
X-RateLimit-Remaining: 23     //当前还剩下多少次
X-RateLimit-Reset: 1540650789 //限制重置时间
</code></pre></td></tr></table>
</div>
</div><p>上面的 HTTP Response 是通过响应头告诉调用方服务端的限流频次是怎样的，保证后端的接口访问上限。为了解决限流问题出现了很多的算法，它们都有不同的用途，通常的策略就是拒绝超出的请求，或者让超出的请求排队等待。</p>
<h1 id="计数器法">计数器法<a hidden class="anchor" aria-hidden="true" href="#计数器法">#</a></h1>
<p>计数器是最简单的限流算法，思路是维护一个单位时间内的计数器 Counter，如判断单位时间已经过去，则将计数器归零。</p>
<p>我们假设有个需求对于某个接口 /query 每分钟最多允许访问 200 次。</p>
<ul>
<li>可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。</li>
<li>当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。
<ul>
<li>如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。</li>
<li>如果该请求与第一个请求的间隔时间大于 1 分钟，且 count 值还在限流范围内，就重置 count。</li>
</ul>
</li>
</ul>
<p>伪代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Count</span>       <span class="kt">uint</span>   <span class="c1">// 初始计数器
</span><span class="c1"></span>    <span class="nx">Limit</span>       <span class="kt">uint</span>   <span class="c1">// 时间窗口最大请求频次
</span><span class="c1"></span>    <span class="nx">Interval</span>    <span class="kt">int64</span>  <span class="c1">// 单位毫秒 ms
</span><span class="c1"></span>    <span class="nx">RefreshTime</span> <span class="kt">int64</span>  <span class="c1">// 时间窗口
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nf">rateLimit</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">now</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">RefreshTime</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Interval</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在时间窗口内
</span><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">Count</span><span class="o">++</span>
        <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Count</span> <span class="o">&lt;=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Limit</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">RefreshTime</span> <span class="p">=</span> <span class="nx">now</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">Count</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 超时重置
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种方法虽然简单，但也有个大问题就是没有很好的处理单位时间的边界。</p>
<p>假设有个用户在第 59 秒的最后几毫秒瞬间发送 200 个请求，当 59 秒结束后 Counter 清零了，他在下一秒的时候又发送 200 个请求。那么在 1 秒钟内这个用户发送了 2 倍的请求，如下图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191104154148.png" alt=""  />
</p>
<p>这种方式的缺点在于它没有更细粒度的划分临界点，如果我们可以把这个时间窗口划分成 6 份，每一份代表 10 秒，当然你可以将它划分的更细。那么如何解决这里的临界问题呢？来看看下面的滑动窗口吧。</p>
<h1 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h1>
<p>所谓 滑动窗口（Sliding window） 是一种流量控制技术，这个词出现在 TCP 协议中。我们来看看在限流中它是怎样表现的：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191104154252.png" alt=""  />
</p>
<p>上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。</p>
<p>那么滑动窗口如何解决我们上面遇到的问题呢？来看下面的图：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191104154327.png" alt=""  />
</p>
<p>当用户在 0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。</p>
<p>通过上面的分析相信你了解什么是滑动窗口了，回想一下其实计数器就是滑动窗口啊，只不过只有一个格子而已，所以我们想让限流做的更精确只需要划分更多的格子就可以了，真是秒啊！为了更精确我们也不知道到底该设置多少个格子，所以又出了 2 种流行的平滑限流算法分别是漏桶算法和令牌桶算法，继续往下看。</p>
<h1 id="漏桶算法">漏桶算法<a hidden class="anchor" aria-hidden="true" href="#漏桶算法">#</a></h1>
<p>漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p>
<p>如图所示，把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191104133642.png" alt=""  />
</p>
<p>可以看出，漏桶算法可以很好的控制流量的访问速度，一旦超过该速度就拒绝服务。</p>
<p>这张图中有 2 个变量，一个是桶的大小（capacity），另一个是水桶漏洞的大小（rate），那么我们可以写下如下代码来实现：</p>
<p>伪代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LeakyBucket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Capacity</span>    <span class="kt">int64</span> <span class="c1">// 桶的容量
</span><span class="c1"></span>    <span class="nx">Rate</span>        <span class="kt">int64</span> <span class="c1">// 漏桶出水速度
</span><span class="c1"></span>    <span class="nx">Water</span>       <span class="kt">int64</span> <span class="c1">// 当前水量(当前累积请求数)
</span><span class="c1"></span>    <span class="nx">RefreshTime</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">LeakyBucket</span><span class="p">)</span> <span class="nf">rateLimit</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
    
    <span class="c1">// 先执行漏水，计算剩余水量
</span><span class="c1"></span>    <span class="nx">b</span><span class="p">.</span><span class="nx">Water</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Water</span><span class="o">-</span><span class="p">(</span><span class="nx">now</span><span class="o">-</span><span class="nx">b</span><span class="p">.</span><span class="nx">RefreshTime</span><span class="p">)</span><span class="o">*</span><span class="nx">b</span><span class="p">.</span><span class="nx">Rate</span><span class="p">);</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">RefreshTime</span> <span class="p">=</span> <span class="nx">now</span>

    <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Water</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Capacity</span> <span class="p">{</span>
        <span class="c1">// 水桶还没满，继续加 1
</span><span class="c1"></span>        <span class="nx">b</span><span class="p">.</span><span class="nx">Water</span><span class="o">++</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 水满，拒绝流入
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">b</span> <span class="p">&gt;</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>漏桶算法有以下特点：</p>
<ul>
<li>漏桶具有固定容量，出水速率是固定常量（流出请求）</li>
<li>如果桶是空的，则不需流出水滴</li>
<li>可以以任意速率流入水滴到漏桶（流入请求）</li>
<li>如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</li>
</ul>
<p>漏桶限制的是常量流出速率（即流出速率是一个固定常量值），所以最大的速率就是出水的速率，不能出现突发流量。</p>
<h1 id="令牌桶算法">令牌桶算法<a hidden class="anchor" aria-hidden="true" href="#令牌桶算法">#</a></h1>
<p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p>
<p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p>
<p>从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。当请求来的时候，从桶里移除一个令牌，如果桶是空的则拒绝请求或者阻塞。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191029103028.png" alt=""  />
</p>
<p>伪代码实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TokenBucket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Capacity</span>    <span class="kt">int64</span> <span class="c1">// 桶的容量
</span><span class="c1"></span>    <span class="nx">Rate</span>        <span class="kt">int64</span> <span class="c1">// 令牌放入速度
</span><span class="c1"></span>    <span class="nx">Tokens</span>      <span class="kt">int64</span> <span class="c1">// 当前令牌数量
</span><span class="c1"></span>    <span class="nx">RefreshTime</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TokenBucket</span><span class="p">)</span> <span class="nf">rateLimit</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>

    <span class="c1">// 先添加令牌
</span><span class="c1"></span>    <span class="nx">t</span><span class="p">.</span><span class="nx">Tokens</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Capacity</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Tokens</span><span class="o">+</span><span class="p">(</span><span class="nx">now</span><span class="o">-</span><span class="nx">t</span><span class="p">.</span><span class="nx">RefreshTime</span><span class="p">)</span><span class="o">*</span><span class="nx">t</span><span class="p">.</span><span class="nx">Rate</span><span class="p">);</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">RefreshTime</span> <span class="p">=</span> <span class="nx">now</span>

    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Tokens</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="c1">// 令牌数小于 1 拒绝请求
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 还有令牌，领取令牌
</span><span class="c1"></span>        <span class="nx">t</span><span class="p">.</span><span class="nx">Tokens</span><span class="o">--</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>令牌桶有以下特点：</p>
<ul>
<li>令牌按固定的速率被放入令牌桶中</li>
<li>桶中最多存放 B 个令牌，当桶满时，新添加的令牌被丢弃或拒绝</li>
<li>如果桶中的令牌不足 N 个，则不会删除令牌，且请求将被限流（丢弃或阻塞等待）</li>
</ul>
<p>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量。</p>
<h1 id="算法比较">算法比较<a hidden class="anchor" aria-hidden="true" href="#算法比较">#</a></h1>
<h2 id="计数器和滑动窗口">计数器和滑动窗口<a hidden class="anchor" aria-hidden="true" href="#计数器和滑动窗口">#</a></h2>
<p>计数器算法实现起来最简单，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。</p>
<h2 id="漏桶和令牌桶">漏桶和令牌桶<a hidden class="anchor" aria-hidden="true" href="#漏桶和令牌桶">#</a></h2>
<p>漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。漏桶算法与令牌桶算法的区别在于，漏桶算法能够强行限制数据的传输速率，令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191104154834.png" alt=""  />
</p>
<ul>
<li>
<p>漏桶:漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。</p>
</li>
<li>
<p>令牌桶:生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</p>
</li>
</ul>
<p>需要注意的是，在某些情况下，漏桶算法不能够有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。</p>
<p>参考:<br>
<a href="https://www.jianshu.com/p/a59c13e70582">https://www.jianshu.com/p/a59c13e70582</a><br>
<a href="https://blog.biezhi.me/2018/10/rate-limit-algorithm.html">https://blog.biezhi.me/2018/10/rate-limit-algorithm.html</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E9%99%90%E6%B5%81/">限流</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
