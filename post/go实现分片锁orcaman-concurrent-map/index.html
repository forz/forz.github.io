<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go实现分片锁:orcaman-concurrent-map | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。 在并发编程中,我们的一条">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81orcaman-concurrent-map/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go实现分片锁:orcaman-concurrent-map" />
<meta property="og:description" content="虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。 在并发编程中,我们的一条" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81orcaman-concurrent-map/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-19T17:01:41&#43;00:00" />
<meta property="article:modified_time" content="2021-01-19T17:01:41&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go实现分片锁:orcaman-concurrent-map"/>
<meta name="twitter:description" content="虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。 在并发编程中,我们的一条"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go实现分片锁:orcaman-concurrent-map",
      "item": "/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81orcaman-concurrent-map/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go实现分片锁:orcaman-concurrent-map",
  "name": "Go实现分片锁:orcaman-concurrent-map",
  "description": "虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。 在并发编程中,我们的一条",
  "keywords": [
    "Go"
  ],
  "articleBody": "虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。\n在并发编程中,我们的一条原则就是尽量减少锁的使用。一些单线程单进程的应用(比如 Redis 等),基本上不需要使用锁去解决并发线程访问的问题,所以可以取得很高的性能。但是对于 Go 开发的应用程序来说,并发是常用的一个特性,在这种情况下,我们能做的就是,尽量减少锁的粒度和锁的持有时间。\n你可以优化业务处理的代码,以此来减少锁的持有时间,比如将串行的操作变成并行的子任务执行。不过,这就是另外的故事了,今天我们还是主要讲对同步原语的优化,所以这里我重点讲如何减少锁的粒度。\n减少锁的粒度常用的方法就是分片(Shard),将一把锁分成几把锁,每个锁控制一个分片。Go 比较知名的分片并发 map 的实现是 orcaman/concurrent-map。\n它默认采用 32 个分片,GetShard 是一个关键的方法,能够根据 key 计算出分片索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352  package cmap import ( \"encoding/json\" \"sync\" ) var SHARD_COUNT = 32 // A \"thread\" safe map of type string:Anything. // To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards. // 分成SHARD_COUNT个分片的map type ConcurrentMap []*ConcurrentMapShared // A \"thread\" safe string to anything map. // 通过RWMutex保护的线程安全的分片,包含一个map type ConcurrentMapShared struct { items map[string]interface{} sync.RWMutex // Read Write mutex, guards access to internal map. } // Creates a new concurrent map. // 创建并发map func New() ConcurrentMap { m := make(ConcurrentMap, SHARD_COUNT) for i := 0; i  SHARD_COUNT; i++ { m[i] = \u0026ConcurrentMapShared{items: make(map[string]interface{})} } return m } // GetShard returns shard under given key // 根据key计算分片索引 func (m ConcurrentMap) GetShard(key string) *ConcurrentMapShared { return m[uint(fnv32(key))%uint(SHARD_COUNT)] } func (m ConcurrentMap) MSet(data map[string]interface{}) { for key, value := range data { shard := m.GetShard(key) shard.Lock() shard.items[key] = value shard.Unlock() } } // Sets the given value under the specified key. //增加或者查询的时候,首先根据分片索引得到分片对象,然后对分片对象加锁进行操作: func (m ConcurrentMap) Set(key string, value interface{}) { // Get map shard.  // 根据key计算出对应的分片  shard := m.GetShard(key) //对这个分片加锁,执行业务操作 \tshard.Lock() shard.items[key] = value shard.Unlock() } // Callback to return new element to be inserted into the map // It is called while lock is held, therefore it MUST NOT // try to access other keys in same map, as it can lead to deadlock since // Go sync.RWLock is not reentrant type UpsertCb func(exist bool, valueInMap interface{}, newValue interface{}) interface{} // Insert or Update - updates existing element or inserts a new one using UpsertCb func (m ConcurrentMap) Upsert(key string, value interface{}, cb UpsertCb) (res interface{}) { shard := m.GetShard(key) shard.Lock() v, ok := shard.items[key] res = cb(ok, v, value) shard.items[key] = res shard.Unlock() return res } // Sets the given value under the specified key if no value was associated with it. func (m ConcurrentMap) SetIfAbsent(key string, value interface{}) bool { // Get map shard. \tshard := m.GetShard(key) shard.Lock() _, ok := shard.items[key] if !ok { shard.items[key] = value } shard.Unlock() return !ok } // Get retrieves an element from map under given key. func (m ConcurrentMap) Get(key string) (interface{}, bool) { // Get shard  // 根据key计算出对应的分片 \tshard := m.GetShard(key) shard.RLock() // Get item from shard.  // 从这个分片读取key的值 \tval, ok := shard.items[key] shard.RUnlock() return val, ok } // Count returns the number of elements within the map. func (m ConcurrentMap) Count() int { count := 0 for i := 0; i  SHARD_COUNT; i++ { shard := m[i] shard.RLock() count += len(shard.items) shard.RUnlock() } return count } // Looks up an item under specified key func (m ConcurrentMap) Has(key string) bool { // Get shard \tshard := m.GetShard(key) shard.RLock() // See if element is within shard. \t_, ok := shard.items[key] shard.RUnlock() return ok } // Remove removes an element from the map. func (m ConcurrentMap) Remove(key string) { // Try to get shard. \tshard := m.GetShard(key) shard.Lock() delete(shard.items, key) shard.Unlock() } // RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held // If returns true, the element will be removed from the map type RemoveCb func(key string, v interface{}, exists bool) bool // RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params // If callback returns true and element exists, it will remove it from the map // Returns the value returned by the callback (even if element was not present in the map) func (m ConcurrentMap) RemoveCb(key string, cb RemoveCb) bool { // Try to get shard. \tshard := m.GetShard(key) shard.Lock() v, ok := shard.items[key] remove := cb(key, v, ok) if remove \u0026\u0026 ok { delete(shard.items, key) } shard.Unlock() return remove } // Pop removes an element from the map and returns it func (m ConcurrentMap) Pop(key string) (v interface{}, exists bool) { // Try to get shard. \tshard := m.GetShard(key) shard.Lock() v, exists = shard.items[key] delete(shard.items, key) shard.Unlock() return v, exists } // IsEmpty checks if map is empty. func (m ConcurrentMap) IsEmpty() bool { return m.Count() == 0 } // Used by the Iter \u0026 IterBuffered functions to wrap two variables together over a channel, type Tuple struct { Key string Val interface{} } // Iter returns an iterator which could be used in a for range loop. // // Deprecated: using IterBuffered() will get a better performence func (m ConcurrentMap) Iter() chan Tuple { chans := snapshot(m) ch := make(chan Tuple) go fanIn(chans, ch) return ch } // IterBuffered returns a buffered iterator which could be used in a for range loop. func (m ConcurrentMap) IterBuffered() chan Tuple { chans := snapshot(m) total := 0 for _, c := range chans { total += cap(c) } ch := make(chan Tuple, total) go fanIn(chans, ch) return ch } // Clear removes all items from map. func (m ConcurrentMap) Clear() { for item := range m.IterBuffered() { m.Remove(item.Key) } } // Returns a array of channels that contains elements in each shard, // which likely takes a snapshot of `m`. // It returns once the size of each buffered channel is determined, // before all the channels are populated using goroutines. func snapshot(m ConcurrentMap) (chans []chan Tuple) { chans = make([]chan Tuple, SHARD_COUNT) wg := sync.WaitGroup{} wg.Add(SHARD_COUNT) // Foreach shard. \tfor index, shard := range m { go func(index int, shard *ConcurrentMapShared) { // Foreach key, value pair. \tshard.RLock() chans[index] = make(chan Tuple, len(shard.items)) wg.Done() for key, val := range shard.items { chans[index]  Tuple{key, val} } shard.RUnlock() close(chans[index]) }(index, shard) } wg.Wait() return chans } // fanIn reads elements from channels `chans` into channel `out` func fanIn(chans []chan Tuple, out chan Tuple) { wg := sync.WaitGroup{} wg.Add(len(chans)) for _, ch := range chans { go func(ch chan Tuple) { for t := range ch { out  t } wg.Done() }(ch) } wg.Wait() close(out) } // Items returns all items as map[string]interface{} func (m ConcurrentMap) Items() map[string]interface{} { tmp := make(map[string]interface{}) // Insert items to temporary map. \tfor item := range m.IterBuffered() { tmp[item.Key] = item.Val } return tmp } // Iterator callback,called for every key,value found in // maps. RLock is held for all calls for a given shard // therefore callback sess consistent view of a shard, // but not across the shards type IterCb func(key string, v interface{}) // Callback based iterator, cheapest way to read // all elements in a map. func (m ConcurrentMap) IterCb(fn IterCb) { for idx := range m { shard := (m)[idx] shard.RLock() for key, value := range shard.items { fn(key, value) } shard.RUnlock() } } // Keys returns all keys as []string func (m ConcurrentMap) Keys() []string { count := m.Count() ch := make(chan string, count) go func() { // Foreach shard. \twg := sync.WaitGroup{} wg.Add(SHARD_COUNT) for _, shard := range m { go func(shard *ConcurrentMapShared) { // Foreach key, value pair. \tshard.RLock() for key := range shard.items { ch  key } shard.RUnlock() wg.Done() }(shard) } wg.Wait() close(ch) }() // Generate keys \tkeys := make([]string, 0, count) for k := range ch { keys = append(keys, k) } return keys } //Reviles ConcurrentMap \"private\" variables to json marshal. func (m ConcurrentMap) MarshalJSON() ([]byte, error) { // Create a temporary map, which will hold all item spread across shards. \ttmp := make(map[string]interface{}) // Insert items to temporary map. \tfor item := range m.IterBuffered() { tmp[item.Key] = item.Val } return json.Marshal(tmp) } func fnv32(key string) uint32 { hash := uint32(2166136261) const prime32 = uint32(16777619) for i := 0; i  len(key); i++ { hash *= prime32 hash ^= uint32(key[i]) } return hash } // Concurrent map uses Interface{} as its value, therefor JSON Unmarshal // will probably won't know which to type to unmarshal into, in such case // we'll end up with a value of type map[string]interface{}, In most cases this isn't // out value type, this is why we've decided to remove this functionality.  // func (m *ConcurrentMap) UnmarshalJSON(b []byte) (err error) { // // Reverse process of Marshal.  // tmp := make(map[string]interface{})  // // Unmarshal into a single map. // if err := json.Unmarshal(b, \u0026tmp); err != nil { // return nil // }  // // foreach key,value pair in temporary map insert into our concurrent map. // for key, val := range tmp { // m.Set(key, val) // } // return nil // }    ",
  "wordCount" : "2271",
  "inLanguage": "zh-cn",
  "datePublished": "2021-01-19T17:01:41Z",
  "dateModified": "2021-01-19T17:01:41Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E5%AE%9E%E7%8E%B0%E5%88%86%E7%89%87%E9%94%81orcaman-concurrent-map/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go实现分片锁:orcaman-concurrent-map
    </h1>
    <div class="post-meta">January 19, 2021
</div>
  </header> 
  <div class="post-content"><p>虽然使用读写锁可以提供线程安全的 map,但是在大量并发读写的情况下,锁的竞争会非常激烈。锁是性能下降的万恶之源之一。</p>
<p>在并发编程中,我们的一条原则就是尽量减少锁的使用。一些单线程单进程的应用(比如 Redis 等),基本上不需要使用锁去解决并发线程访问的问题,所以可以取得很高的性能。但是对于 Go 开发的应用程序来说,并发是常用的一个特性,在这种情况下,我们能做的就是,尽量减少锁的粒度和锁的持有时间。</p>
<p>你可以优化业务处理的代码,以此来减少锁的持有时间,比如将串行的操作变成并行的子任务执行。不过,这就是另外的故事了,今天我们还是主要讲对同步原语的优化,所以这里我重点讲如何减少锁的粒度。</p>
<p>减少锁的粒度常用的方法就是分片(Shard),将一把锁分成几把锁,每个锁控制一个分片。Go 比较知名的分片并发 map 的实现是 orcaman/concurrent-map。</p>
<p>它默认采用 32 个分片,GetShard 是一个关键的方法,能够根据 key 计算出分片索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">cmap</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">SHARD_COUNT</span> <span class="p">=</span> <span class="mi">32</span>

<span class="c1">// A &#34;thread&#34; safe map of type string:Anything.
</span><span class="c1">// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.
</span><span class="c1">// 分成SHARD_COUNT个分片的map
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcurrentMap</span> <span class="p">[]</span><span class="o">*</span><span class="nx">ConcurrentMapShared</span>

<span class="c1">// A &#34;thread&#34; safe string to anything map.
</span><span class="c1">// 通过RWMutex保护的线程安全的分片,包含一个map
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConcurrentMapShared</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">items</span>        <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// Read Write mutex, guards access to internal map.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Creates a new concurrent map.
</span><span class="c1">// 创建并发map
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="nx">ConcurrentMap</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">ConcurrentMap</span><span class="p">,</span> <span class="nx">SHARD_COUNT</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">SHARD_COUNT</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ConcurrentMapShared</span><span class="p">{</span><span class="nx">items</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>

<span class="c1">// GetShard returns shard under given key
</span><span class="c1">// 根据key计算分片索引
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">ConcurrentMapShared</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nb">uint</span><span class="p">(</span><span class="nf">fnv32</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span><span class="o">%</span><span class="nb">uint</span><span class="p">(</span><span class="nx">SHARD_COUNT</span><span class="p">)]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">MSet</span><span class="p">(</span><span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
		<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Sets the given value under the specified key.
</span><span class="c1">//增加或者查询的时候,首先根据分片索引得到分片对象,然后对分片对象加锁进行操作:
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// Get map shard.
</span><span class="c1"></span>    <span class="c1">// 根据key计算出对应的分片
</span><span class="c1"></span>    <span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="c1">//对这个分片加锁,执行业务操作
</span><span class="c1"></span>	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Callback to return new element to be inserted into the map
</span><span class="c1">// It is called while lock is held, therefore it MUST NOT
</span><span class="c1">// try to access other keys in same map, as it can lead to deadlock since
</span><span class="c1">// Go sync.RWLock is not reentrant
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UpsertCb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">exist</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">valueInMap</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">newValue</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>

<span class="c1">// Insert or Update - updates existing element or inserts a new one using UpsertCb
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Upsert</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cb</span> <span class="nx">UpsertCb</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nf">cb</span><span class="p">(</span><span class="nx">ok</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="c1">// Sets the given value under the specified key if no value was associated with it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">SetIfAbsent</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// Get map shard.
</span><span class="c1"></span>	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="p">!</span><span class="nx">ok</span>
<span class="p">}</span>

<span class="c1">// Get retrieves an element from map under given key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Get shard
</span><span class="c1"></span>    <span class="c1">// 根据key计算出对应的分片
</span><span class="c1"></span>	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
    <span class="c1">// Get item from shard.
</span><span class="c1"></span>    <span class="c1">// 从这个分片读取key的值
</span><span class="c1"></span>	<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="c1">// Count returns the number of elements within the map.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Count</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">SHARD_COUNT</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
		<span class="nx">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">)</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>

<span class="c1">// Looks up an item under specified key
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Has</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// Get shard
</span><span class="c1"></span>	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="c1">// See if element is within shard.
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="c1">// Remove removes an element from the map.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Try to get shard.
</span><span class="c1"></span>	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held
</span><span class="c1">// If returns true, the element will be removed from the map
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RemoveCb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">exists</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span>

<span class="c1">// RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params
</span><span class="c1">// If callback returns true and element exists, it will remove it from the map
</span><span class="c1">// Returns the value returned by the callback (even if element was not present in the map)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">RemoveCb</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cb</span> <span class="nx">RemoveCb</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// Try to get shard.
</span><span class="c1"></span>	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">remove</span> <span class="o">:=</span> <span class="nf">cb</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">remove</span> <span class="o">&amp;&amp;</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">delete</span><span class="p">(</span><span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">remove</span>
<span class="p">}</span>

<span class="c1">// Pop removes an element from the map and returns it
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">exists</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Try to get shard.
</span><span class="c1"></span>	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">exists</span> <span class="p">=</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">exists</span>
<span class="p">}</span>

<span class="c1">// IsEmpty checks if map is empty.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Used by the Iter &amp; IterBuffered functions to wrap two variables together over a channel,
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Tuple</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Key</span> <span class="kt">string</span>
	<span class="nx">Val</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// Iter returns an iterator which could be used in a for range loop.
</span><span class="c1">//
</span><span class="c1">// Deprecated: using IterBuffered() will get a better performence
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Iter</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Tuple</span> <span class="p">{</span>
	<span class="nx">chans</span> <span class="o">:=</span> <span class="nf">snapshot</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nx">chans</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="c1">// IterBuffered returns a buffered iterator which could be used in a for range loop.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">IterBuffered</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">Tuple</span> <span class="p">{</span>
	<span class="nx">chans</span> <span class="o">:=</span> <span class="nf">snapshot</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">chans</span> <span class="p">{</span>
		<span class="nx">total</span> <span class="o">+=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nx">chans</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="c1">// Clear removes all items from map.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Clear</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nf">IterBuffered</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Returns a array of channels that contains elements in each shard,
</span><span class="c1">// which likely takes a snapshot of `m`.
</span><span class="c1">// It returns once the size of each buffered channel is determined,
</span><span class="c1">// before all the channels are populated using goroutines.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">snapshot</span><span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="p">(</span><span class="nx">chans</span> <span class="p">[]</span><span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">chans</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">,</span> <span class="nx">SHARD_COUNT</span><span class="p">)</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">SHARD_COUNT</span><span class="p">)</span>
	<span class="c1">// Foreach shard.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">*</span><span class="nx">ConcurrentMapShared</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Foreach key, value pair.
</span><span class="c1"></span>			<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
			<span class="nx">chans</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">shard</span><span class="p">.</span><span class="nx">items</span><span class="p">))</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span> <span class="p">{</span>
				<span class="nx">chans</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">Tuple</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
			<span class="nb">close</span><span class="p">(</span><span class="nx">chans</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
		<span class="p">}(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">shard</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">chans</span>
<span class="p">}</span>

<span class="c1">// fanIn reads elements from channels `chans` into channel `out`
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nx">chans</span> <span class="p">[]</span><span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">chans</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">chans</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="nx">Tuple</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
				<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">t</span>
			<span class="p">}</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Items returns all items as map[string]interface{}
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Items</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>

	<span class="c1">// Insert items to temporary map.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nf">IterBuffered</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">tmp</span><span class="p">[</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Val</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">tmp</span>
<span class="p">}</span>

<span class="c1">// Iterator callback,called for every key,value found in
</span><span class="c1">// maps. RLock is held for all calls for a given shard
</span><span class="c1">// therefore callback sess consistent view of a shard,
</span><span class="c1">// but not across the shards
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">IterCb</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span>

<span class="c1">// Callback based iterator, cheapest way to read
</span><span class="c1">// all elements in a map.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">IterCb</span><span class="p">(</span><span class="nx">fn</span> <span class="nx">IterCb</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">idx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">shard</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">m</span><span class="p">)[</span><span class="nx">idx</span><span class="p">]</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span> <span class="p">{</span>
			<span class="nf">fn</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Keys returns all keys as []string
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">Keys</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Count</span><span class="p">()</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Foreach shard.
</span><span class="c1"></span>		<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">SHARD_COUNT</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">shard</span> <span class="o">*</span><span class="nx">ConcurrentMapShared</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// Foreach key, value pair.
</span><span class="c1"></span>				<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
				<span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">shard</span><span class="p">.</span><span class="nx">items</span> <span class="p">{</span>
					<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">key</span>
				<span class="p">}</span>
				<span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
				<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="p">}(</span><span class="nx">shard</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="c1">// Generate keys
</span><span class="c1"></span>	<span class="nx">keys</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
		<span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">keys</span>
<span class="p">}</span>

<span class="c1">//Reviles ConcurrentMap &#34;private&#34; variables to json marshal.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConcurrentMap</span><span class="p">)</span> <span class="nf">MarshalJSON</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Create a temporary map, which will hold all item spread across shards.
</span><span class="c1"></span>	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>

	<span class="c1">// Insert items to temporary map.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nf">IterBuffered</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">tmp</span><span class="p">[</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Val</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">tmp</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fnv32</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">2166136261</span><span class="p">)</span>
	<span class="kd">const</span> <span class="nx">prime32</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">16777619</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">hash</span> <span class="o">*=</span> <span class="nx">prime32</span>
		<span class="nx">hash</span> <span class="p">^=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">hash</span>
<span class="p">}</span>

<span class="c1">// Concurrent map uses Interface{} as its value, therefor JSON Unmarshal
</span><span class="c1">// will probably won&#39;t know which to type to unmarshal into, in such case
</span><span class="c1">// we&#39;ll end up with a value of type map[string]interface{}, In most cases this isn&#39;t
</span><span class="c1">// out value type, this is why we&#39;ve decided to remove this functionality.
</span><span class="c1"></span>
<span class="c1">// func (m *ConcurrentMap) UnmarshalJSON(b []byte) (err error) {
</span><span class="c1">// 	// Reverse process of Marshal.
</span><span class="c1"></span>
<span class="c1">// 	tmp := make(map[string]interface{})
</span><span class="c1"></span>
<span class="c1">// 	// Unmarshal into a single map.
</span><span class="c1">// 	if err := json.Unmarshal(b, &amp;tmp); err != nil {
</span><span class="c1">// 		return nil
</span><span class="c1">// 	}
</span><span class="c1"></span>
<span class="c1">// 	// foreach key,value pair in temporary map insert into our concurrent map.
</span><span class="c1">// 	for key, val := range tmp {
</span><span class="c1">// 		m.Set(key, val)
</span><span class="c1">// 	}
</span><span class="c1">// 	return nil
</span><span class="c1">// }
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
