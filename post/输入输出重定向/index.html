<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>输入输出重定向 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.2 with theme even" />


<link rel="canonical" href="/post/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="输入输出重定向" />
<meta property="og:description" content="标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-08-10T14:08:15+00:00" />
<meta property="article:modified_time" content="2017-08-10T14:08:15+00:00" />

<meta itemprop="name" content="输入输出重定向">
<meta itemprop="description" content="标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文"><meta itemprop="datePublished" content="2017-08-10T14:08:15+00:00" />
<meta itemprop="dateModified" content="2017-08-10T14:08:15+00:00" />
<meta itemprop="wordCount" content="5647">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="输入输出重定向"/>
<meta name="twitter:description" content="标准文件描述符 Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">输入输出重定向</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-08-10 </span>
        <div class="post-category">
            <a href="/categories/shell/"> Shell </a>
            </div>
          <span class="more-meta"> 约 5647 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#stdin">STDIN</a></li>
    <li><a href="#stdout">STDOUT</a></li>
    <li><a href="#stderr">STDERR</a></li>
    <li><a href="#重定向错误">重定向错误</a>
      <ul>
        <li><a href="#只重定向错误">只重定向错误</a></li>
        <li><a href="#重定向错误和数据">重定向错误和数据</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#临时重定向">临时重定向</a></li>
    <li><a href="#永久重定向">永久重定向</a></li>
  </ul>

  <ul>
    <li><a href="#创建输出文件描述符">创建输出文件描述符</a></li>
    <li><a href="#重定向文件描述符">重定向文件描述符</a></li>
    <li><a href="#创建输入文件描述符">创建输入文件描述符</a></li>
    <li><a href="#创建读写文件描述符">创建读写文件描述符</a></li>
    <li><a href="#关闭文件描述符">关闭文件描述符</a></li>
  </ul>

  <ul>
    <li><a href="#为何21要写在后面">为何2&gt;&amp;1要写在后面？</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="标准文件描述符">标准文件描述符</h1>
<p>Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开 的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文 件描述符(0、1和2).</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170810-141324@2x.png" alt=""></p>
<h2 id="stdin">STDIN</h2>
<p>STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN 文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>
<p>在使用输入重定向符号(&lt;)时，Linux会用重定向指定的文件来替换标准输入文件描述符。 它会读取文件并提取数据，就如同它是键盘上键入的。</p>
<h2 id="stdout">STDOUT</h2>
<p>STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell 的所有输出(包括shell中运行的程序和脚本)会被定向到标准输出中，也就是显示器。</p>
<p>默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。你可以用输出重定向来改变。你也可以将数据追加到某个文件。这可以用&raquo;符号来完成。</p>
<h2 id="stderr">STDERR</h2>
<p>shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。</p>
<p>默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方(尽管分配给它们 的文件描述符值不同)。也就是说，默认情况下，错误消息也会输出到显示器输出中。</p>
<p>但STDERR并不会随着STDOUT的重定向而发生改变。</p>
<h2 id="重定向错误">重定向错误</h2>
<h3 id="只重定向错误">只重定向错误</h3>
<p>STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文 件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。</p>
<pre><code>ls -al badfile 2&gt; test4
</code></pre>
<p>现在运行该命令，错误消息不会出现在屏幕上了。该命令生成的任何错误消息都会保存在输 出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。</p>
<h3 id="重定向错误和数据">重定向错误和数据</h3>
<p>如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据 所对应的文件描述符，然后指向用于保存数据的输出文件。</p>
<pre><code>$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7
</code></pre>
<p>可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息，再不用在成千上万行正常输出数据中翻腾了。</p>
<p>另外，如果愿意，也可以将STDERR和STDOUT的输出重定向到同一个输出文件。为此bash shell 提供了特殊的重定向符号&amp;&gt;。</p>
<h1 id="在脚本中重定向输出">在脚本中重定向输出</h1>
<p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相 应的文件描述符就行了。有两种方法来在脚本中重定向输出:</p>
<ol>
<li>临时重定向行输出</li>
<li>永久重定向脚本中的所有命令</li>
</ol>
<h2 id="临时重定向">临时重定向</h2>
<p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的 是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，你必须在文件描述符数字之前加一个&amp;:</p>
<pre><code>echo &quot;This is an error message&quot; &gt;&amp;2 
</code></pre>
<p>这行会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT.</p>
<p>记住，默认情况下，Linux会将STDERR导向STDOUT。但是，如果你在运行脚本时重定向了 STDERR，脚本中所有导向STDERR的文本都会被重定向。</p>
<pre><code>$ ./test8 2&gt; test9
This is normal output
$ cat test9
This is an error
$
</code></pre>
<h2 id="永久重定向">永久重定向</h2>
<p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可 以用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>
<pre><code>exec 1&gt;testout
</code></pre>
<p>exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所 有输出会被重定向到文件。</p>
<h1 id="在脚本中重定向输入">在脚本中重定向输入</h1>
<p>你可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许你将STDIN重定向到Linux系统上的文件中:</p>
<pre><code>exec 0&lt; testfile
</code></pre>
<p>这个命令会告诉shell它应该从文件testfile中获得输入，而不是STDIN。这个重定向只要 在脚本需要输入时就会作用。</p>
<pre><code>$ cat test12
#!/bin/bash
# redirecting file input
exec 0&lt; testfile
count=1
while read line
do
   echo &quot;Line #$count: $line&quot;
   count=$[ $count + 1 ]
done
$ ./test12
Line #1: This is the first line.
Line #2: This is the second line.
Line #3: This is the third line.
$
</code></pre>
<h1 id="创建自己的重定向">创建自己的重定向</h1>
<p>在shell 中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。 你可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>
<h2 id="创建输出文件描述符">创建输出文件描述符</h2>
<p>可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件 描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。</p>
<pre><code>exec 3&gt;test13out 
echo &quot;and this should be stored in the file&quot; &gt;&amp;3
</code></pre>
<p>这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内 容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入 了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中(比如 日志文件)。</p>
<p>也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中。</p>
<pre><code>exec 3&gt;&gt;test13out
</code></pre>
<p>现在输出会被追加到test13out文件，而不是创建一个新文件。</p>
<h2 id="重定向文件描述符">重定向文件描述符</h2>
<p>你可以分配另外一个文件描述符给标准文件描述 符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用 该文件描述符重定向回STDOUT。听起来可能有点复杂，但实际上相当直接。</p>
<pre><code> exec 3&gt;&amp;1
exec 1&gt;test14out
exec 1&gt;&amp;3
</code></pre>
<p>首先，脚本将文件描述符3重定向到文件描述符1的当前位置，也就是STDOUT。这意味着任何发送给文件描述符3的输出都将出现在显示器上。</p>
<p>第二个exec命令将STDOUT重定向到文件，shell现在会将发送给STDOUT的输出直接重定向到 输出文件中。但是，文件描述符3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出 数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。</p>
<p>在向STDOUT(现在指向一个文件)发送一些输出之后，脚本将STDOUT重定向到文件描述符 3的当前位置(现在仍然是显示器)。这意味着现在STDOUT又指向了它原来的位置:显示器。</p>
<h2 id="创建输入文件描述符">创建输入文件描述符</h2>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前， 先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它 原来的位置。</p>
<pre><code>exec 6&lt;&amp;0
exec 0&lt; testfile
exec 0&lt;&amp;6
</code></pre>
<p>文件描述符6用来保存STDIN的位置。然后脚本将STDIN重定向到一个文件。 read命令的所有输入都来自重定向后的STDIN(也就是输入文件)。
在读取了所有行之后，脚本会将STDIN重定向到文件描述符6，从而将STDIN恢复到原先的位置。</p>
<h2 id="创建读写文件描述符">创建读写文件描述符</h2>
<p>你也可以打开单个文件描述符来作为输入和输出。可以用同 一个文件描述符对同一个文件进行读写。</p>
<p>不过用这种方法时，你要特别小心。由于你是对同一个文件进行数据读写，shell会维护一个 内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。如果不够小心，它会产生一些令人瞠目的结果。看看下面这个例子。</p>
<pre><code>$ cat test16
#!/bin/bash
# testing input/output file descriptor
exec 3&lt;&gt; testfile
read line &lt;&amp;3
echo &quot;Read: $line&quot;
echo &quot;This is a test line&quot; &gt;&amp;3
$ cat testfile
This is the first line.
This is the second line.
This is the third line.
$ ./test16
Read: This is the first line.
$ cat testfile
This is the first line.
This is a test line
ine.
This is the third line.
$
</code></pre>
<p>这个例子用了exec命令将文件描述符3分配给文件testfile以进行文件读写。接下来，它 通过分配好的文件描述符，使用read命令读取文件中的第一行，然后将这一行显示在STDOUT上。 最后，它用echo语句将一行数据写入由同一个文件描述符打开的文件中。</p>
<p>在运行脚本时，一开始还算正常。输出内容表明脚本读取了testfile文件中的第一行。但如果 你在脚本运行完毕后，查看testfile文件内容的话，你会发现写入文件中的数据覆盖了已有的数据。</p>
<p>当脚本向文件中写入数据时，它会从文件指针所处的位置开始。read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符。在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h2 id="关闭文件描述符">关闭文件描述符</h2>
<p>要关闭文件描述符，将它重定向到特殊符号&amp;-。脚本中看起来如下:</p>
<pre><code>exec 3&gt;&amp;-
</code></pre>
<p>该语句会关闭文件描述符3，不再在脚本中使用它。</p>
<p>一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息。</p>
<p>在关闭文件描述符时还要注意另一件事。如果随后你在脚本中打开了同一个输出文件，shell 会用一个新文件来替换已有文件。这意味着如果你输出数据，它就会覆盖已有文件。</p>
<h1 id="列出打开的文件描述符">列出打开的文件描述符</h1>
<p>lsof命令会列出整个Linux系统打开的所有文件描述符。这是个有争议的功能，因为它会向 非系统管理员用户提供Linux系统的信息。鉴于此，许多Linux系统隐藏了该命令，这样用户就不 会一不小心就发现了。</p>
<p>在很多Linux系统中(如Fedora)，lsof命令位于/usr/sbin目录。要想以普通用户账户来运行 它，必须通过全路径名来引用:</p>
<pre><code>$ /usr/sbin/lsof
</code></pre>
<p>该命令会产生大量的输出。它会显示当前Linux系统上打开的每个文件的有关信息。这包括 后台运行的所有进程以及登录到系统的任何用户。</p>
<p>有大量的命令行选项和参数可以用来帮助过滤lsof的输出。最常用的有-p和-d，前者允许 指定进程ID(PID)，后者允许指定要显示的文件描述符编号。</p>
<p>要想知道进程的当前PID，可以用特殊环境变量$$(shell会将它设为当前PID)。-a选项用来 对其他两个选项的结果执行布尔AND运算.</p>
<pre><code> $ /usr/sbin/lsof -a -p $$ -d 0,1,2
</code></pre>
<p>lsof的默认输出中有7 列信息</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170810-164024@2x.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170810-164111@2x.png" alt=""></p>
<p>与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文件描述符都指向终端，所以输出文件的名称就是终端的设备名。所有3种标准文件都支持读和写(尽管向STDIN写数据以及从STDOUT读数据看起来有点奇怪)。</p>
<h1 id="阻止命令输出">阻止命令输出</h1>
<p>有时候，你可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见(参见第16 章)。如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。</p>
<p>要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名 字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。</p>
<p>在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<pre><code>ls -al &gt; /dev/null
</code></pre>
<p>这是避免出现错误消息，也无需保存它们的一个常用方法。</p>
<p>也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容，程序员 通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。</p>
<pre><code>cat /dev/null &gt; testfile
</code></pre>
<p>文件testfile仍然存在系统上，但现在它是空文件。这是清除日志文件的一个常用方法，因为日志文件必须时刻准备等待应用程序操作。</p>
<h1 id="记录消息">记录消息</h1>
<p>将输出同时发送到显示器和日志文件，这种做法有时候能够派上用场。你不用将输出重定向 两次，只要用特殊的tee命令就行。</p>
<p>tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处。一处是 STDOUT，另一处是tee命令行所指定的文件名:</p>
<pre><code>tee filename
</code></pre>
<p>由于tee会重定向来自STDIN的数据，你可以用它配合管道命令来重定向命令输出。</p>
<pre><code>$ date | tee testfile
</code></pre>
<p>如果你想将数据追加到文件中，必须用-a选项。</p>
<pre><code>$ date | tee -a testfile
</code></pre>
<p>利用这个方法，既能将数据保存在文件中，也能将数据显示在屏幕上。</p>
<h1 id="重定向脚本内部的文本块">重定向脚本内部的文本块</h1>
<p>有时候，我们需要对文本块（多行文本）像标准输人一样进行重定向。考虑一个特殊情况：</p>
<p>源文本就位于shell脚本中。一个实用的例子是向log文件中写入头部数据，可以按照下面的方法完成：</p>
<pre><code>#! /bin/baah
cat &lt; &lt;EOF&gt;log.txt
LOG PILE HEADER
This is a test log file
Functions System statistics
EOF
</code></pre>
<p>在cat &lt; &lt;EOF&gt;log.txt与下一个EOF行之间的所有文本行都会被当做stdin数据。log_txt文件的内容打印如下：</p>
<pre><code>$ cat log.txt
LOG FILE HBADBR
this is a test log file
Function： System statistics
</code></pre>
<h1 id="与">&gt;&amp;与&amp;&gt;</h1>
<p>shell上:</p>
<p>0表示标准输入</p>
<p>1表示标准输出</p>
<p>2表示标准错误输出</p>
<p>&gt; 默认为标准输出重定向，与 1&gt; 相同</p>
<p>2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出.</p>
<p>&amp;&gt;file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中</p>
<p>用例子说话：</p>
<pre><code>grep da * 1&gt;&amp;2 
rm -f $(find / -name core) &amp;&gt; /dev/null
</code></pre>
<p>上面两例中的 &amp; 如何理解，&amp;不是放到后台执行吗?</p>
<p>解释：</p>
<ol>
<li>&amp;&gt;file或n&gt;&amp;m均是一个独立的重定向符号，不要分开来理解。</li>
<li>明确文件和文件描述符的区别。</li>
<li>&amp;&gt;file表示重定向标准输出和错误到文件</li>
<li>n&gt;&amp;m表示使文件描述符n成为输出文件描述符m的副本。当你运行某些命令的时候,出错信息也许很重要,便于你检查是哪出了毛病,如:2&gt;&amp;1</li>
</ol>
<p>例如：</p>
<p>注意，为了方便理解，必须设置一个环境使得执行grep da *命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grep da * &gt; greplog1
</span></span><span class="line"><span class="cl">grep da * &gt; greplog2 1&gt;&amp;2   
</span></span><span class="line"><span class="cl">grep da * &gt; greplog3 2&gt;&amp;1  //grep da * 2&gt; greplog4 1&gt;&amp;2 结果一样
</span></span><span class="line"><span class="cl">#查看greplog1会发现里面只有正常输出内容
</span></span><span class="line"><span class="cl">#查看greplog2会发现里面什么都没有
</span></span><span class="line"><span class="cl">#查看greplog3会发现里面既有正常输出内容又有错误输出内容
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="为何21要写在后面">为何2&gt;&amp;1要写在后面？</h2>
<pre><code>command &gt; file 2&gt;&amp;1 
</code></pre>
<p>首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。</p>
<pre><code>command 2&gt;&amp;1 &gt;file 
</code></pre>
<p>2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-08-10
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84%E5%A0%86%E6%A0%88%E6%89%93%E5%8D%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的堆栈打印</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%88%A9%E7%94%A8read%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/">
            <span class="next-text nav-default">利用read获取用户输入</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
