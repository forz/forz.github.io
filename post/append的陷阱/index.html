<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>append的陷阱 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &amp;#34;fmt&amp;#34; func main() { s := []byte(&amp;#34;&amp;#34;) s1 := append(s, &amp;#39;a&amp;#39;) s2 := append(s, &amp;#39;b&amp;#39;) //fmt.Println(s1, &amp;#34;==========&amp;#34;, s2) fmt.Println(string(s1), &amp;#34;==========&amp;#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.97.3 with theme even" />


<link rel="canonical" href="/post/append%E7%9A%84%E9%99%B7%E9%98%B1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="append的陷阱" />
<meta property="og:description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &#34;fmt&#34; func main() { s := []byte(&#34;&#34;) s1 := append(s, &#39;a&#39;) s2 := append(s, &#39;b&#39;) //fmt.Println(s1, &#34;==========&#34;, s2) fmt.Println(string(s1), &#34;==========&#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/append%E7%9A%84%E9%99%B7%E9%98%B1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-01-05T11:24:39+00:00" />
<meta property="article:modified_time" content="2019-01-05T11:24:39+00:00" />

<meta itemprop="name" content="append的陷阱">
<meta itemprop="description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &#34;fmt&#34; func main() { s := []byte(&#34;&#34;) s1 := append(s, &#39;a&#39;) s2 := append(s, &#39;b&#39;) //fmt.Println(s1, &#34;==========&#34;, s2) fmt.Println(string(s1), &#34;==========&#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //"><meta itemprop="datePublished" content="2019-01-05T11:24:39+00:00" />
<meta itemprop="dateModified" content="2019-01-05T11:24:39+00:00" />
<meta itemprop="wordCount" content="3478">
<meta itemprop="keywords" content="Go,逃逸机制,slice," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="append的陷阱"/>
<meta name="twitter:description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &#34;fmt&#34; func main() { s := []byte(&#34;&#34;) s1 := append(s, &#39;a&#39;) s2 := append(s, &#39;b&#39;) //fmt.Println(s1, &#34;==========&#34;, s2) fmt.Println(string(s1), &#34;==========&#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">append的陷阱</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-01-05 </span>
        <div class="post-category">
            <a href="/categories/go%E4%BD%BF%E7%94%A8/"> Go使用 </a>
            </div>
          <span class="more-meta"> 约 3478 字 </span>
          <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#大小分配">大小分配</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="背景">背景</h1>
<p>问题代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">//fmt.Println(s1, &#34;==========&#34;, s2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;==========&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 出现个让我理解不了的现象, 注释时候输出是 b ========== b
</span></span></span><span class="line"><span class="cl"><span class="c1">// 取消注释输出是 [97] ========== [98] a ========== b
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="string转byte">string转[]byte</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其capacity 是32，length是 0</p>
<p>那为什么空字符串转的slice的容量是32？而不是0或者8呢？</p>
<p>只好祭出杀手锏了，翻源码。Go官方提供的工具，可以查到编译后调用的汇编信息，不然在大片源码中搜索也很累。</p>
<p><code>-gcflags</code> 是传递参数给Go编译器，<code>-S -S</code>是打印汇编调用信息和数据，<code>-S</code>只打印调用信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go run -gcflags <span class="s1">&#39;-S -S&#39;</span> main.go
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    0x0000 00000 ()    TEXT    &#34;&#34;.main(SB), $264-0
</span></span><span class="line"><span class="cl">	0x003e 00062 ()   MOVQ    AX, (SP)
</span></span><span class="line"><span class="cl">	0x0042 00066 ()   XORPS   X0, X0
</span></span><span class="line"><span class="cl">	0x0045 00069 ()   MOVUPS  X0, 8(SP)
</span></span><span class="line"><span class="cl">	0x004a 00074 ()   PCDATA  $0, $0
</span></span><span class="line"><span class="cl">	0x004a 00074 ()   CALL    runtime.stringtoslicebyte(SB)
</span></span><span class="line"><span class="cl">	0x004f 00079 ()   MOVQ    32(SP), AX
</span></span><span class="line"><span class="cl">	b , b
</span></span></code></pre></td></tr></table>
</div>
</div><p>Go使用的是plan9汇编语法，虽然整体有些不好理解，但也能看出我们需要的关键点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CALL    runtime.stringtoslicebyte(SB)
</span></span></code></pre></td></tr></table>
</div>
</div><p>定位源码到<code>src\runtime\string.go</code>:</p>
<p>从<code>stringtoslicebyte</code>函数中可以看出容量32的源头，见注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">tmpStringBufSize</span> <span class="p">=</span> <span class="mi">32</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">tmpBuf</span> <span class="p">[</span><span class="nx">tmpStringBufSize</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">tmpBuf</span><span class="p">{}</span>   <span class="c1">// tmpBuf的默认容量是32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>  <span class="c1">// 创建个容量为32，长度为0的新slice，赋值给b。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// s是空字符串，复制过去也是长度0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果走else的话，容量就不是32了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cap</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">cap</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cap</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)),</span> <span class="nx">cap</span><span class="o">-</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">slice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">cap</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="切片覆盖">切片覆盖</h1>
<p><code>s := []byte(&quot;&quot;)</code> 这行代码中的s实际引用了一个 byte 的数组。</p>
<p>其capacity 是32，length是 0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出： 32 0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关键点在于下面代码<code>s1 := append(s, 'a')</code>中的append，并没有在原slice修改，当然也没办法修改，因为在Go中都是值传递的。当把s传入append函数内时，已经复制出一份s1，然后在s1上追加 <code>a</code>，s1长度是增加了1，但s长度仍然是0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 输出
</span></span></span><span class="line"><span class="cl"><span class="c1">// 32 0
</span></span></span><span class="line"><span class="cl"><span class="c1">// 32 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于s，s1指向同一份数组，所以在s1上进行append <code>a</code>操作时（底层数组[0]=a），也是s所指向数组的操作，但s本身不会有任何变化。这也是Go中append的写法都是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>append函数会返回s1，需要重新赋值给s。 如果不赋值的话，s本身记录的数据就滞后了，再次对其append，就会从滞后的数据开始操作。虽然看起是append，实际上确是把上一次append的值给覆盖了。</p>
<p>所以问题的答案是：后append的b，把上次append的a给覆盖了，所以才会输出b b。</p>
<p>假设底层数组是<code>arr</code>，如注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// 等同于 arr[0] = &#39;a&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span> <span class="c1">// 等同于 arr[0] = &#39;b&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;==========&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span> <span class="c1">// 只是把同一份数组打印出来了
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="重新分配">重新分配</h1>
<p>我们继续，先来看个题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>猜猜输出什么？</p>
<p>答案是：a , b 和 0 0，符合预期。</p>
<p>上面例子中输出的是：32，0。看来问题关键在这里，两者差别在于一个是默认<code>[]byte{}</code>，另外个是空字符串转的<code>[]byte(&quot;&quot;)</code>。其长度都是0，比较好理解，但为什么容量是32就不符合预期输出了？</p>
<p>因为 capacity 是数组还能添加多少的容量，在能满足的情况，不会重新分配。所以 capacity-length=32，是足够append<code>a，b</code>的。我们用make来验证下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// append 内会重新分配，输出a，b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// append 内不会重新分配，输出b，b，因为容量为1，足够append
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>重新分配指的是：append 会检查slice大小，如果容量不够，会重新创建个更大的slice，并把原数组复制一份出来。在<code>make([]byte,0,0)</code>这样情况下，s容量肯定不够用，所以s1，s2使用的都是各自从s复制出来的数组，结果也自然符合预期a，b了。</p>
<p>测试重新分配后的容量变大，打印s1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 输出 8，1。重新分配后扩大了
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="逃逸">逃逸</h1>
<p>为啥加上注释就符合预期输出<code>a，b</code>?  还有加上注释为啥连容量都变了？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">//输出
</span></span></span><span class="line"><span class="cl"><span class="c1">// 0 0
</span></span></span><span class="line"><span class="cl"><span class="c1">// [97] ========== [98]
</span></span></span><span class="line"><span class="cl"><span class="c1">// a , b
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>取消注释情况下：Go编译程序进行逃逸分析时，检测到<code>fmt.Println</code>有引用到s，所以在决定堆上分配s下的数组。在进行string转[]byte时，如果分配到栈上就会有个默认32的容量，分配堆上则没有。</p>
<p>用下面命令执行，可以得到逃逸信息，这个命令只编译程序不运行，上面用的go run -gcflags是传递参数到编译器并运行程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go tool compile -m main.go
</span></span></code></pre></td></tr></table>
</div>
</div><p>取消注释<code>fmt.Println(s1, &quot;,&quot;, s2) </code> 后 ([]byte)(&quot;&quot;)会逃逸到堆上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">main.go:23:13: s1 escapes to heap
</span></span><span class="line"><span class="cl">main.go:20:13: <span class="o">([]</span>byte<span class="o">)(</span><span class="s2">&#34;&#34;</span><span class="o">)</span> escapes to heap  // 逃逸到堆上
</span></span><span class="line"><span class="cl">main.go:23:18: <span class="s2">&#34;,&#34;</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:23:18: s2 escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:26: <span class="s2">&#34;,&#34;</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:23:13: main ... argument does not escape
</span></span><span class="line"><span class="cl">main.go:24:13: main ... argument does not escape
</span></span></code></pre></td></tr></table>
</div>
</div><p>加上注释<code>//fmt.Println(s1, &quot;,&quot;, s2) </code>不会逃逸到堆上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go tool compile -m main.go
</span></span><span class="line"><span class="cl">main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:26: <span class="s2">&#34;,&#34;</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
</span></span><span class="line"><span class="cl">main.go:20:13: main <span class="o">([]</span>byte<span class="o">)(</span><span class="s2">&#34;&#34;</span><span class="o">)</span> does not escape  //不逃逸
</span></span><span class="line"><span class="cl">main.go:24:13: main ... argument does not escape
</span></span></code></pre></td></tr></table>
</div>
</div><p>接着继续定位调用<code>stringtoslicebyte </code>的地方，在<code>src\cmd\compile\internal\gc\walk.go</code> 文件。 为了便于理解，下面代码进行了汇总：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">EscUnknown</span>        <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="nx">EscNone</span>           <span class="c1">// 结果或参数不逃逸堆上.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="nx">OSTRARRAYBYTE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nodnil</span><span class="p">()</span>   <span class="c1">//默认数组为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNone</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 在栈上为slice创建临时数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewArray</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">tmpstringbufsize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">a</span> <span class="p">=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OADDR</span><span class="p">,</span> <span class="nf">temp</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="p">=</span> <span class="nf">mkcall</span><span class="p">(</span><span class="s">&#34;stringtoslicebyte&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">init</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nf">conv</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TSTRING</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不逃逸情况下会分配个32字节的数组 <code>t</code>。逃逸情况下不分配，数组设置为 nil，所以s的容量是0。接着从s上append a，b到s1，s2，其必然会发生复制，所以不会发生覆盖前值，也符合预期结果a，b 。再看<code>stringtoslicebyte</code>就很清晰了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">tmpBuf</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="大小分配">大小分配</h2>
<p>不逃逸情况下默认32。那逃逸情况下分配策略是？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是空字符串它的输出：0。&ldquo;a&quot;字符串时输出：8。</p>
<p>大小取决于<code>src\runtime\size.go</code> 中的roundupsize 函数和 class_to_size 变量。</p>
<p>这些增加大小的变化，是由  <code>src\runtime\mksizeclasses.go </code>生成的。</p>
<h1 id="版本差异">版本差异</h1>
<p>我们在用Go写程序，如果Go底层发生变化了，肯定结果不一样。作者在调研过程中，发现另外博客得到的<code>stringtoslicebyte</code>源码是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">s</span> <span class="nx">String</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Slice</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span><span class="p">.</span><span class="nx">array</span> <span class="p">=</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">FlagNoScan</span><span class="p">|</span><span class="nx">FlagNoZero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span><span class="p">.</span><span class="nx">cap</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">runtime</span><span class="err">·</span><span class="nf">memmove</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">str</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面版本的源码，得到的结果，也是符合预期的，因为不会默认分配32字节的数组。</p>
<p>继续翻旧版代码，到1.3.2版是这样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">s</span> <span class="nx">String</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Slice</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uintptr</span> <span class="nx">cap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cap</span> <span class="p">=</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">roundupsize</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">array</span> <span class="p">=</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">cap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">FlagNoScan</span><span class="p">|</span><span class="nx">FlagNoZero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">cap</span> <span class="p">=</span> <span class="nx">cap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="err">·</span><span class="nf">memmove</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">str</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="nx">cap</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">runtime</span><span class="err">·</span><span class="nf">memclr</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">array</span><span class="o">+</span><span class="nx">b</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="o">-</span><span class="nx">b</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>1.6.4版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>更古老的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">__go_open_array</span>
</span></span><span class="line"><span class="cl"><span class="nf">__go_string_to_byte_array</span> <span class="p">(</span><span class="n">String</span> <span class="n">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uintptr</span> <span class="n">cap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">__go_open_array</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">cap</span> <span class="o">=</span> <span class="n">runtime_roundupsize</span> <span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">runtime_mallocgc</span> <span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FlagNoScan</span> <span class="o">|</span> <span class="n">FlagNoZero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">__builtin_memcpy</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">!=</span> <span class="p">(</span><span class="n">uintptr</span><span class="p">)</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">__builtin_memset</span> <span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap</span> <span class="o">-</span> <span class="p">(</span><span class="n">uintptr</span><span class="p">)</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ret</span><span class="p">.</span><span class="n">__values</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ret</span><span class="p">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ret</span><span class="p">.</span><span class="n">__capacity</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>作者在1.6.4版本上测试，得到的结果确实是反的，注释了反而得到预期结果 a, b。  本文中使用的是1.10.2</p>
<h1 id="结论">结论</h1>
<ol>
<li>
<p>注释时输出b，b。是因为没有逃逸，所以分配了默认32字节大小的数组，2次append都是在数组[0]赋值，后值覆盖前值，所以才是b，b。</p>
</li>
<li>
<p>取消注释时输出a，b。是因为<code>fmt.Println</code>引用了s，逃逸分析时发现需要逃逸并且是空字符串，所以分配了空数组。2次append都是操作各自重新分配后的新slice，所以输出a，b。</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>
<p>源码目录中的<code>gc</code>是<code>Go compiler</code>的意思，而不是<code>Garbage Collection </code>，<code>gcflags</code>中的<code>gc</code>也是同样意思。</p>
</li>
<li>
<p>另外这种写法是没意义的，也极不推荐。应该把 <code>[]byte(&quot;string&quot;)</code>当成只读的来用，不然就容易出现难排查的bug。</p>
</li>
</ol>
<p>转载:<a href="https://raw.githubusercontent.com/mushroomsir/blog/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md">https://raw.githubusercontent.com/mushroomsir/blog/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-01-05
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/%E9%80%83%E9%80%B8%E6%9C%BA%E5%88%B6/">逃逸机制</a>
          <a href="/tags/slice/">slice</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%9C%A8go%E4%B8%AD%E7%94%A8%E5%90%8D%E5%AD%97%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">在GO中用名字调用函数</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/time%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/">
            <span class="next-text nav-default">time包解析(1.11)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
