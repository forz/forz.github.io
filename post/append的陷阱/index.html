<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>append的陷阱 | Forz Blog</title>
<meta name="keywords" content="Go, 逃逸机制, slice" />
<meta name="description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &#34;fmt&#34; func main() { s := []byte(&#34;&#34;) s1 := append(s, &#39;a&#39;) s2 := append(s, &#39;b&#39;) //fmt.Println(s1, &#34;==========&#34;, s2) fmt.Println(string(s1), &#34;==========&#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //">
<meta name="author" content="">
<link rel="canonical" href="/post/append%E7%9A%84%E9%99%B7%E9%98%B1/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="append的陷阱" />
<meta property="og:description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &#34;fmt&#34; func main() { s := []byte(&#34;&#34;) s1 := append(s, &#39;a&#39;) s2 := append(s, &#39;b&#39;) //fmt.Println(s1, &#34;==========&#34;, s2) fmt.Println(string(s1), &#34;==========&#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/append%E7%9A%84%E9%99%B7%E9%98%B1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-01-05T11:24:39&#43;00:00" />
<meta property="article:modified_time" content="2019-01-05T11:24:39&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="append的陷阱"/>
<meta name="twitter:description" content="背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import &#34;fmt&#34; func main() { s := []byte(&#34;&#34;) s1 := append(s, &#39;a&#39;) s2 := append(s, &#39;b&#39;) //fmt.Println(s1, &#34;==========&#34;, s2) fmt.Println(string(s1), &#34;==========&#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "append的陷阱",
      "item": "/post/append%E7%9A%84%E9%99%B7%E9%98%B1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "append的陷阱",
  "name": "append的陷阱",
  "description": "背景 问题代码如下： 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { s := []byte(\u0026#34;\u0026#34;) s1 := append(s, \u0026#39;a\u0026#39;) s2 := append(s, \u0026#39;b\u0026#39;) //fmt.Println(s1, \u0026#34;==========\u0026#34;, s2) fmt.Println(string(s1), \u0026#34;==========\u0026#34;, string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b //",
  "keywords": [
    "Go", "逃逸机制", "slice"
  ],
  "articleBody": "背景 问题代码如下：\n1 2 3 4 5 6 7 8 9 10 11  package main import \"fmt\" func main() { s := []byte(\"\") s1 := append(s, 'a') s2 := append(s, 'b') //fmt.Println(s1, \"==========\", s2) fmt.Println(string(s1), \"==========\", string(s2)) } // 出现个让我理解不了的现象, 注释时候输出是 b ========== b // 取消注释输出是 [97] ========== [98] a ========== b   string转[]byte 1 2  s := []byte(\"\") fmt.Println(cap(s), len(s))   其capacity 是32，length是 0\n那为什么空字符串转的slice的容量是32？而不是0或者8呢？\n只好祭出杀手锏了，翻源码。Go官方提供的工具，可以查到编译后调用的汇编信息，不然在大片源码中搜索也很累。\n-gcflags 是传递参数给Go编译器，-S -S是打印汇编调用信息和数据，-S只打印调用信息。\n1  go run -gcflags '-S -S' main.go   下面是输出：\n1 2 3 4 5 6 7 8  0x0000 00000 () TEXT \"\".main(SB), $264-0 0x003e 00062 () MOVQ AX, (SP) 0x0042 00066 () XORPS X0, X0 0x0045 00069 () MOVUPS X0, 8(SP) 0x004a 00074 () PCDATA $0, $0 0x004a 00074 () CALL runtime.stringtoslicebyte(SB) 0x004f 00079 () MOVQ 32(SP), AX b , b   Go使用的是plan9汇编语法，虽然整体有些不好理解，但也能看出我们需要的关键点：\n1  CALL runtime.stringtoslicebyte(SB)   定位源码到src\\runtime\\string.go:\n从stringtoslicebyte函数中可以看出容量32的源头，见注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13  const tmpStringBufSize = 32 type tmpBuf [tmpStringBufSize]byte func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s)  len(buf) { *buf = tmpBuf{} // tmpBuf的默认容量是32 \tb = buf[:len(s)] // 创建个容量为32，长度为0的新slice，赋值给b。 \t} else { b = rawbyteslice(len(s)) } copy(b, s) // s是空字符串，复制过去也是长度0 \treturn b }   如果走else的话，容量就不是32了。\n1 2 3 4 5 6 7 8 9 10  func rawbyteslice(size int) (b []byte) { cap := roundupsize(uintptr(size)) p := mallocgc(cap, nil, false) if cap != uintptr(size) { memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(cap)} return }   切片覆盖 s := []byte(\"\") 这行代码中的s实际引用了一个 byte 的数组。\n其capacity 是32，length是 0：\n1 2 3  s := []byte(\"\") fmt.Println(cap(s), len(s)) //输出： 32 0   关键点在于下面代码s1 := append(s, 'a')中的append，并没有在原slice修改，当然也没办法修改，因为在Go中都是值传递的。当把s传入append函数内时，已经复制出一份s1，然后在s1上追加 a，s1长度是增加了1，但s长度仍然是0：\n1 2 3 4 5 6 7  s := []byte(\"\") fmt.Println(cap(s), len(s)) s1 := append(s, 'a') fmt.Println(cap(s1), len(s1)) // 输出 // 32 0 // 32 1   由于s，s1指向同一份数组，所以在s1上进行append a操作时（底层数组[0]=a），也是s所指向数组的操作，但s本身不会有任何变化。这也是Go中append的写法都是：\n1  s = append(s,'a')   append函数会返回s1，需要重新赋值给s。 如果不赋值的话，s本身记录的数据就滞后了，再次对其append，就会从滞后的数据开始操作。虽然看起是append，实际上确是把上一次append的值给覆盖了。\n所以问题的答案是：后append的b，把上次append的a给覆盖了，所以才会输出b b。\n假设底层数组是arr，如注释：\n1 2 3 4  s := []byte(\"\") s1 := append(s, 'a') // 等同于 arr[0] = 'a' s2 := append(s, 'b') // 等同于 arr[0] = 'b' fmt.Println(string(s1), \"==========\", string(s2)) // 只是把同一份数组打印出来了   重新分配 我们继续，先来看个题：\n1 2 3 4 5  s := []byte{} s1 := append(s, 'a') s2 := append(s, 'b') fmt.Println(string(s1), \",\", string(s2)) fmt.Println(cap(s), len(s))   猜猜输出什么？\n答案是：a , b 和 0 0，符合预期。\n上面例子中输出的是：32，0。看来问题关键在这里，两者差别在于一个是默认[]byte{}，另外个是空字符串转的[]byte(\"\")。其长度都是0，比较好理解，但为什么容量是32就不符合预期输出了？\n因为 capacity 是数组还能添加多少的容量，在能满足的情况，不会重新分配。所以 capacity-length=32，是足够appenda，b的。我们用make来验证下：\n1 2 3 4 5 6 7  // append 内会重新分配，输出a，b s := make([]byte, 0, 0) // append 内不会重新分配，输出b，b，因为容量为1，足够append s := make([]byte, 0, 1) s1 := append(s, 'a') s2 := append(s, 'b') fmt.Println(string(s1), \",\", string(s2))   重新分配指的是：append 会检查slice大小，如果容量不够，会重新创建个更大的slice，并把原数组复制一份出来。在make([]byte,0,0)这样情况下，s容量肯定不够用，所以s1，s2使用的都是各自从s复制出来的数组，结果也自然符合预期a，b了。\n测试重新分配后的容量变大，打印s1:\n1 2 3 4  s := make([]byte, 0, 0) s1 := append(s, 'a') fmt.Println(cap(s1), len(s1)) // 输出 8，1。重新分配后扩大了   逃逸 为啥加上注释就符合预期输出a，b? 还有加上注释为啥连容量都变了？\n1 2 3 4 5 6 7 8 9 10  s := []byte(\"\") fmt.Println(cap(s), len(s)) s1 := append(s, 'a') s2 := append(s, 'b') fmt.Println(s1, \",\", s2) fmt.Println(string(s1), \",\", string(s2)) //输出 // 0 0 // [97] ========== [98] // a , b   取消注释情况下：Go编译程序进行逃逸分析时，检测到fmt.Println有引用到s，所以在决定堆上分配s下的数组。在进行string转[]byte时，如果分配到栈上就会有个默认32的容量，分配堆上则没有。\n用下面命令执行，可以得到逃逸信息，这个命令只编译程序不运行，上面用的go run -gcflags是传递参数到编译器并运行程序。\n1  go tool compile -m main.go   取消注释fmt.Println(s1, \",\", s2)  后 ([]byte)(\"\")会逃逸到堆上：\n1 2 3 4 5 6 7 8 9 10 11  main.go:23:13: s1 escapes to heap main.go:20:13: ([]byte)(\"\") escapes to heap // 逃逸到堆上 main.go:23:18: \",\" escapes to heap main.go:23:18: s2 escapes to heap main.go:24:20: string(s1) escapes to heap main.go:24:20: string(s1) escapes to heap main.go:24:26: \",\" escapes to heap main.go:24:37: string(s2) escapes to heap main.go:24:37: string(s2) escapes to heap main.go:23:13: main ... argument does not escape main.go:24:13: main ... argument does not escape   加上注释//fmt.Println(s1, \",\", s2) 不会逃逸到堆上：\n1 2 3 4 5 6 7 8  go tool compile -m main.go main.go:24:20: string(s1) escapes to heap main.go:24:20: string(s1) escapes to heap main.go:24:26: \",\" escapes to heap main.go:24:37: string(s2) escapes to heap main.go:24:37: string(s2) escapes to heap main.go:20:13: main ([]byte)(\"\") does not escape //不逃逸 main.go:24:13: main ... argument does not escape   接着继续定位调用stringtoslicebyte 的地方，在src\\cmd\\compile\\internal\\gc\\walk.go 文件。 为了便于理解，下面代码进行了汇总：\n1 2 3 4 5 6 7 8 9 10 11 12  const ( EscUnknown = iota EscNone // 结果或参数不逃逸堆上.  ) case OSTRARRAYBYTE: a := nodnil() //默认数组为空 \tif n.Esc == EscNone { // 在栈上为slice创建临时数组 \tt := types.NewArray(types.Types[TUINT8], tmpstringbufsize) a = nod(OADDR, temp(t), nil) } n = mkcall(\"stringtoslicebyte\", n.Type, init, a, conv(n.Left, types.Types[TSTRING]))   不逃逸情况下会分配个32字节的数组 t。逃逸情况下不分配，数组设置为 nil，所以s的容量是0。接着从s上append a，b到s1，s2，其必然会发生复制，所以不会发生覆盖前值，也符合预期结果a，b 。再看stringtoslicebyte就很清晰了。\n1 2 3 4 5 6 7 8 9 10 11  func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s)  len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b }   大小分配 不逃逸情况下默认32。那逃逸情况下分配策略是？\n1 2 3 4 5  s := []byte(\"a\") fmt.Println(cap(s)) s1 := append(s, 'a') s2 := append(s, 'b') fmt.Print(s1, s2)   如果是空字符串它的输出：0。“a\"字符串时输出：8。\n大小取决于src\\runtime\\size.go 中的roundupsize 函数和 class_to_size 变量。\n这些增加大小的变化，是由 src\\runtime\\mksizeclasses.go 生成的。\n版本差异 我们在用Go写程序，如果Go底层发生变化了，肯定结果不一样。作者在调研过程中，发现另外博客得到的stringtoslicebyte源码是：\n1 2 3 4 5 6  func stringtoslicebyte(s String) (b Slice) { b.array = runtime·mallocgc(s.len, 0, FlagNoScan|FlagNoZero); b.len = s.len; b.cap = s.len; runtime·memmove(b.array, s.str, s.len); }   上面版本的源码，得到的结果，也是符合预期的，因为不会默认分配32字节的数组。\n继续翻旧版代码，到1.3.2版是这样:\n1 2 3 4 5 6 7 8 9 10  func stringtoslicebyte(s String) (b Slice) { uintptr cap; cap = runtime·roundupsize(s.len); b.array = runtime·mallocgc(cap, 0, FlagNoScan|FlagNoZero); b.len = s.len; b.cap = cap; runtime·memmove(b.array, s.str, s.len); if(cap != b.len) runtime·memclr(b.array+b.len, cap-b.len); }   1.6.4版:\n1 2 3 4 5 6 7 8 9 10  func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s)  len(buf) { b = buf[:len(s):len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b }   更古老的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  struct __go_open_array __go_string_to_byte_array (String str) { uintptr cap; unsigned char *data; struct __go_open_array ret; cap = runtime_roundupsize (str.len); data = (unsigned char *) runtime_mallocgc (cap, 0, FlagNoScan | FlagNoZero); __builtin_memcpy (data, str.str, str.len); if (cap != (uintptr) str.len) __builtin_memset (data + str.len, 0, cap - (uintptr) str.len); ret.__values = (void *) data; ret.__count = str.len; ret.__capacity = str.len; return ret; }   作者在1.6.4版本上测试，得到的结果确实是反的，注释了反而得到预期结果 a, b。 本文中使用的是1.10.2\n结论   注释时输出b，b。是因为没有逃逸，所以分配了默认32字节大小的数组，2次append都是在数组[0]赋值，后值覆盖前值，所以才是b，b。\n  取消注释时输出a，b。是因为fmt.Println引用了s，逃逸分析时发现需要逃逸并且是空字符串，所以分配了空数组。2次append都是操作各自重新分配后的新slice，所以输出a，b。\n  注意：\n  源码目录中的gc是Go compiler的意思，而不是Garbage Collection ，gcflags中的gc也是同样意思。\n  另外这种写法是没意义的，也极不推荐。应该把 []byte(\"string\")当成只读的来用，不然就容易出现难排查的bug。\n  转载:https://raw.githubusercontent.com/mushroomsir/blog/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md\n",
  "wordCount" : "3478",
  "inLanguage": "zh-cn",
  "datePublished": "2019-01-05T11:24:39Z",
  "dateModified": "2019-01-05T11:24:39Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/append%E7%9A%84%E9%99%B7%E9%98%B1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      append的陷阱
    </h1>
    <div class="post-meta">January 5, 2019
</div>
  </header> 
  <div class="post-content"><h1 id="背景">背景<a hidden class="anchor" aria-hidden="true" href="#背景">#</a></h1>
<p>问题代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
<span class="c1">//fmt.Println(s1, &#34;==========&#34;, s2)
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;==========&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// 出现个让我理解不了的现象, 注释时候输出是 b ========== b 
</span><span class="c1">// 取消注释输出是 [97] ========== [98] a ========== b 
</span></code></pre></td></tr></table>
</div>
</div><h1 id="string转byte">string转[]byte<a hidden class="anchor" aria-hidden="true" href="#string转byte">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>其capacity 是32，length是 0</p>
<p>那为什么空字符串转的slice的容量是32？而不是0或者8呢？</p>
<p>只好祭出杀手锏了，翻源码。Go官方提供的工具，可以查到编译后调用的汇编信息，不然在大片源码中搜索也很累。</p>
<p><code>-gcflags</code> 是传递参数给Go编译器，<code>-S -S</code>是打印汇编调用信息和数据，<code>-S</code>只打印调用信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">go run -gcflags <span class="s1">&#39;-S -S&#39;</span> main.go
</code></pre></td></tr></table>
</div>
</div><p>下面是输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    0x0000 00000 ()    TEXT    &#34;&#34;.main(SB), $264-0
	0x003e 00062 ()   MOVQ    AX, (SP)
	0x0042 00066 ()   XORPS   X0, X0
	0x0045 00069 ()   MOVUPS  X0, 8(SP)
	0x004a 00074 ()   PCDATA  $0, $0
	0x004a 00074 ()   CALL    runtime.stringtoslicebyte(SB)
	0x004f 00079 ()   MOVQ    32(SP), AX
	b , b
</code></pre></td></tr></table>
</div>
</div><p>Go使用的是plan9汇编语法，虽然整体有些不好理解，但也能看出我们需要的关键点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">CALL    runtime.stringtoslicebyte(SB)
</code></pre></td></tr></table>
</div>
</div><p>定位源码到<code>src\runtime\string.go</code>:</p>
<p>从<code>stringtoslicebyte</code>函数中可以看出容量32的源头，见注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">tmpStringBufSize</span> <span class="p">=</span> <span class="mi">32</span>
<span class="kd">type</span> <span class="nx">tmpBuf</span> <span class="p">[</span><span class="nx">tmpStringBufSize</span><span class="p">]</span><span class="kt">byte</span>
<span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>  
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">tmpBuf</span><span class="p">{}</span>   <span class="c1">// tmpBuf的默认容量是32
</span><span class="c1"></span>		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>  <span class="c1">// 创建个容量为32，长度为0的新slice，赋值给b。
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// s是空字符串，复制过去也是长度0
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果走else的话，容量就不是32了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cap</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">cap</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">cap</span> <span class="o">!=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)),</span> <span class="nx">cap</span><span class="o">-</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">slice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">cap</span><span class="p">)}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="切片覆盖">切片覆盖<a hidden class="anchor" aria-hidden="true" href="#切片覆盖">#</a></h1>
<p><code>s := []byte(&quot;&quot;)</code> 这行代码中的s实际引用了一个 byte 的数组。</p>
<p>其capacity 是32，length是 0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="c1">//输出： 32 0
</span></code></pre></td></tr></table>
</div>
</div><p>关键点在于下面代码<code>s1 := append(s, 'a')</code>中的append，并没有在原slice修改，当然也没办法修改，因为在Go中都是值传递的。当把s传入append函数内时，已经复制出一份s1，然后在s1上追加 <code>a</code>，s1长度是增加了1，但s长度仍然是0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
<span class="c1">// 输出
</span><span class="c1">// 32 0
</span><span class="c1">// 32 1
</span></code></pre></td></tr></table>
</div>
</div><p>由于s，s1指向同一份数组，所以在s1上进行append <code>a</code>操作时（底层数组[0]=a），也是s所指向数组的操作，但s本身不会有任何变化。这也是Go中append的写法都是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>append函数会返回s1，需要重新赋值给s。 如果不赋值的话，s本身记录的数据就滞后了，再次对其append，就会从滞后的数据开始操作。虽然看起是append，实际上确是把上一次append的值给覆盖了。</p>
<p>所以问题的答案是：后append的b，把上次append的a给覆盖了，所以才会输出b b。</p>
<p>假设底层数组是<code>arr</code>，如注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// 等同于 arr[0] = &#39;a&#39;
</span><span class="c1"></span><span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span> <span class="c1">// 等同于 arr[0] = &#39;b&#39;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;==========&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span> <span class="c1">// 只是把同一份数组打印出来了
</span></code></pre></td></tr></table>
</div>
</div><h1 id="重新分配">重新分配<a hidden class="anchor" aria-hidden="true" href="#重新分配">#</a></h1>
<p>我们继续，先来看个题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> 
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span> 
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>猜猜输出什么？</p>
<p>答案是：a , b 和 0 0，符合预期。</p>
<p>上面例子中输出的是：32，0。看来问题关键在这里，两者差别在于一个是默认<code>[]byte{}</code>，另外个是空字符串转的<code>[]byte(&quot;&quot;)</code>。其长度都是0，比较好理解，但为什么容量是32就不符合预期输出了？</p>
<p>因为 capacity 是数组还能添加多少的容量，在能满足的情况，不会重新分配。所以 capacity-length=32，是足够append<code>a，b</code>的。我们用make来验证下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// append 内会重新分配，输出a，b
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// append 内不会重新分配，输出b，b，因为容量为1，足够append
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>重新分配指的是：append 会检查slice大小，如果容量不够，会重新创建个更大的slice，并把原数组复制一份出来。在<code>make([]byte,0,0)</code>这样情况下，s容量肯定不够用，所以s1，s2使用的都是各自从s复制出来的数组，结果也自然符合预期a，b了。</p>
<p>测试重新分配后的容量变大，打印s1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
<span class="c1">// 输出 8，1。重新分配后扩大了
</span></code></pre></td></tr></table>
</div>
</div><h1 id="逃逸">逃逸<a hidden class="anchor" aria-hidden="true" href="#逃逸">#</a></h1>
<p>为啥加上注释就符合预期输出<code>a，b</code>?  还有加上注释为啥连容量都变了？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> 
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span> 
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
<span class="c1">//输出
</span><span class="c1">// 0 0
</span><span class="c1">// [97] ========== [98]
</span><span class="c1">// a , b
</span></code></pre></td></tr></table>
</div>
</div><p>取消注释情况下：Go编译程序进行逃逸分析时，检测到<code>fmt.Println</code>有引用到s，所以在决定堆上分配s下的数组。在进行string转[]byte时，如果分配到栈上就会有个默认32的容量，分配堆上则没有。</p>
<p>用下面命令执行，可以得到逃逸信息，这个命令只编译程序不运行，上面用的go run -gcflags是传递参数到编译器并运行程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">go tool compile -m main.go
</code></pre></td></tr></table>
</div>
</div><p>取消注释<code>fmt.Println(s1, &quot;,&quot;, s2) </code> 后 ([]byte)(&quot;&quot;)会逃逸到堆上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">main.go:23:13: s1 escapes to heap
main.go:20:13: <span class="o">([]</span>byte<span class="o">)(</span><span class="s2">&#34;&#34;</span><span class="o">)</span> escapes to heap  // 逃逸到堆上
main.go:23:18: <span class="s2">&#34;,&#34;</span> escapes to heap
main.go:23:18: s2 escapes to heap
main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
main.go:24:26: <span class="s2">&#34;,&#34;</span> escapes to heap
main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
main.go:23:13: main ... argument does not escape
main.go:24:13: main ... argument does not escape
</code></pre></td></tr></table>
</div>
</div><p>加上注释<code>//fmt.Println(s1, &quot;,&quot;, s2) </code>不会逃逸到堆上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">go tool compile -m main.go
main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
main.go:24:20: string<span class="o">(</span>s1<span class="o">)</span> escapes to heap
main.go:24:26: <span class="s2">&#34;,&#34;</span> escapes to heap
main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
main.go:24:37: string<span class="o">(</span>s2<span class="o">)</span> escapes to heap
main.go:20:13: main <span class="o">([]</span>byte<span class="o">)(</span><span class="s2">&#34;&#34;</span><span class="o">)</span> does not escape  //不逃逸
main.go:24:13: main ... argument does not escape
</code></pre></td></tr></table>
</div>
</div><p>接着继续定位调用<code>stringtoslicebyte </code>的地方，在<code>src\cmd\compile\internal\gc\walk.go</code> 文件。 为了便于理解，下面代码进行了汇总：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">EscUnknown</span>        <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">EscNone</span>           <span class="c1">// 结果或参数不逃逸堆上.
</span><span class="c1"></span> <span class="p">)</span>  
<span class="k">case</span> <span class="nx">OSTRARRAYBYTE</span><span class="p">:</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nodnil</span><span class="p">()</span>   <span class="c1">//默认数组为空
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNone</span> <span class="p">{</span>
			<span class="c1">// 在栈上为slice创建临时数组
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewArray</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">tmpstringbufsize</span><span class="p">)</span>
			<span class="nx">a</span> <span class="p">=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OADDR</span><span class="p">,</span> <span class="nf">temp</span><span class="p">(</span><span class="nx">t</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nf">mkcall</span><span class="p">(</span><span class="s">&#34;stringtoslicebyte&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">init</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nf">conv</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TSTRING</span><span class="p">]))</span>
</code></pre></td></tr></table>
</div>
</div><p>不逃逸情况下会分配个32字节的数组 <code>t</code>。逃逸情况下不分配，数组设置为 nil，所以s的容量是0。接着从s上append a，b到s1，s2，其必然会发生复制，所以不会发生覆盖前值，也符合预期结果a，b 。再看<code>stringtoslicebyte</code>就很清晰了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span> 
		<span class="o">*</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">tmpBuf</span><span class="p">{}</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="大小分配">大小分配<a hidden class="anchor" aria-hidden="true" href="#大小分配">#</a></h2>
<p>不逃逸情况下默认32。那逃逸情况下分配策略是？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是空字符串它的输出：0。&ldquo;a&quot;字符串时输出：8。</p>
<p>大小取决于<code>src\runtime\size.go</code> 中的roundupsize 函数和 class_to_size 变量。</p>
<p>这些增加大小的变化，是由  <code>src\runtime\mksizeclasses.go </code>生成的。</p>
<h1 id="版本差异">版本差异<a hidden class="anchor" aria-hidden="true" href="#版本差异">#</a></h1>
<p>我们在用Go写程序，如果Go底层发生变化了，肯定结果不一样。作者在调研过程中，发现另外博客得到的<code>stringtoslicebyte</code>源码是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">s</span> <span class="nx">String</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Slice</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">array</span> <span class="p">=</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">FlagNoScan</span><span class="p">|</span><span class="nx">FlagNoZero</span><span class="p">);</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">cap</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span>
    <span class="nx">runtime</span><span class="err">·</span><span class="nf">memmove</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">str</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面版本的源码，得到的结果，也是符合预期的，因为不会默认分配32字节的数组。</p>
<p>继续翻旧版代码，到1.3.2版是这样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">s</span> <span class="nx">String</span><span class="p">)</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Slice</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">uintptr</span> <span class="nx">cap</span><span class="p">;</span>
	<span class="nx">cap</span> <span class="p">=</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">roundupsize</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">array</span> <span class="p">=</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">cap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">FlagNoScan</span><span class="p">|</span><span class="nx">FlagNoZero</span><span class="p">);</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">len</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">cap</span> <span class="p">=</span> <span class="nx">cap</span><span class="p">;</span>
	<span class="nx">runtime</span><span class="err">·</span><span class="nf">memmove</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">str</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="nx">cap</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
		<span class="nx">runtime</span><span class="err">·</span><span class="nf">memclr</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">array</span><span class="o">+</span><span class="nx">b</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="o">-</span><span class="nx">b</span><span class="p">.</span><span class="nx">len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>1.6.4版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringtoslicebyte</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">tmpBuf</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nf">rawbyteslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>更古老的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">__go_open_array</span>
<span class="nf">__go_string_to_byte_array</span> <span class="p">(</span><span class="n">String</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uintptr</span> <span class="n">cap</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__go_open_array</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">cap</span> <span class="o">=</span> <span class="n">runtime_roundupsize</span> <span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
  <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">runtime_mallocgc</span> <span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FlagNoScan</span> <span class="o">|</span> <span class="n">FlagNoZero</span><span class="p">);</span>
  <span class="n">__builtin_memcpy</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">!=</span> <span class="p">(</span><span class="n">uintptr</span><span class="p">)</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
    <span class="n">__builtin_memset</span> <span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap</span> <span class="o">-</span> <span class="p">(</span><span class="n">uintptr</span><span class="p">)</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
  <span class="n">ret</span><span class="p">.</span><span class="n">__values</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">ret</span><span class="p">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
  <span class="n">ret</span><span class="p">.</span><span class="n">__capacity</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>作者在1.6.4版本上测试，得到的结果确实是反的，注释了反而得到预期结果 a, b。  本文中使用的是1.10.2</p>
<h1 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h1>
<ol>
<li>
<p>注释时输出b，b。是因为没有逃逸，所以分配了默认32字节大小的数组，2次append都是在数组[0]赋值，后值覆盖前值，所以才是b，b。</p>
</li>
<li>
<p>取消注释时输出a，b。是因为<code>fmt.Println</code>引用了s，逃逸分析时发现需要逃逸并且是空字符串，所以分配了空数组。2次append都是操作各自重新分配后的新slice，所以输出a，b。</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>
<p>源码目录中的<code>gc</code>是<code>Go compiler</code>的意思，而不是<code>Garbage Collection </code>，<code>gcflags</code>中的<code>gc</code>也是同样意思。</p>
</li>
<li>
<p>另外这种写法是没意义的，也极不推荐。应该把 <code>[]byte(&quot;string&quot;)</code>当成只读的来用，不然就容易出现难排查的bug。</p>
</li>
</ol>
<p>转载:<a href="https://raw.githubusercontent.com/mushroomsir/blog/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md">https://raw.githubusercontent.com/mushroomsir/blog/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
      <li><a href="/tags/%E9%80%83%E9%80%B8%E6%9C%BA%E5%88%B6/">逃逸机制</a></li>
      <li><a href="/tags/slice/">slice</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
