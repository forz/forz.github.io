<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>字典树相关问题 | Forz Blog</title>
<meta name="keywords" content="字典树, Backtracking" />
<meta name="description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="字典树相关问题" />
<meta property="og:description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:31:45&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:31:45&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字典树相关问题"/>
<meta name="twitter:description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "字典树相关问题",
      "item": "/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "字典树相关问题",
  "name": "字典树相关问题",
  "description": "LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word",
  "keywords": [
    "字典树", "Backtracking"
  ],
  "articleBody": "LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nFor example,\nGiven board =\n[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ]  word = “ABCCED”, - returns true, word = “SEE”, - returns true, word = “ABCB”, - returns false.\n解析：\n回溯法求解，枚举每一个起点进行dfs寻找路径，dfs过程中需要知道当前扫描点的坐标和当前匹配的字符。\n在图中寻找路径dfs会出现路径重复，需要用visit数组来标记已经访问的点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution { public: bool exist(vectorvectorchar  \u0026board, string word) { const int m = board.size();//m为行  const int n = board[0].size();//n为列  vectorvectorbool  visited(m, vectorbool(n, false)); for (int i = 0; i  m; ++i) //枚举起点  for (int j = 0; j  n; ++j) if (dfs(board, word, 0, i, j, visited)) return true; return false; } private: static bool dfs(const vectorvectorchar  \u0026board, const string \u0026word, int index, int x, int y, vectorvectorbool  \u0026visited) { if (index == word.size()) return true; // 收敛条件  if (x  0 || y  0 || x = board.size() || y = board[0].size()) return false; // 越界，终止条件  if (visited[x][y]) return false; // 已经访问过，剪枝  if (board[x][y] != word[index]) return false; // 不相等，结束  visited[x][y] = true;//维护visit  bool ret = dfs(board, word, index + 1, x - 1, y, visited) || // 上  dfs(board, word, index + 1, x + 1, y, visited) || // 下  dfs(board, word, index + 1, x, y - 1, visited) || // 左  dfs(board, word, index + 1, x, y + 1, visited); // 右  visited[x][y] = false;//还原visit  return ret; } };   LeetCode 212. Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board.\nEach word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nFor example, Given words = [“oath”,”pea”,”eat”,”rain”] and board =\n[ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ]  Return [“eat”,”oath”].\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.\n解析：\n要查找多个单词是否存在，需要用字典树。\n字典树主要有如下三点性质：\n  根节点不包含字符，除根节点意外每个节点只包含一个字符。\n  从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。\n  每个节点的所有子节点包含的字符串不相同。\n  字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第i 次循环找到前i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。\n至于结点对儿子的指向，一般有三种方法：\n1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；\n2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；\n3、使用左儿子右兄弟表示法记录这棵树。\n三种方法，各有特点。\n第一种，易实现，但实际的空间要求较大；\n第二种，较易实现，空间要求相对较小，但比较费时；\n第三种，空间要求最小，但相对费时且不易写。\n我们来看第一种实现方法，这种方法实现起来简单直观。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  class Solution { private: class Trie { public: Trie * children[26]; bool isEnd;//单词标记 int wordIdx;//保存当前单词编号 int prefixCount;//记录使用次数 Trie() { isEnd = false; wordIdx = 0; prefixCount = 0; fill_n(children, 26, nullptr); } ~Trie() { for(auto i=0; i26; ++i) delete children[i]; } }; void insertWord(Trie *root, const vectorstring\u0026 words, int idx)//将单词插入字典 {//将整个string数组和单词编号传入  int i, childID, len = words[idx].size(); for(i=0, root-prefixCount++ ; ilen; ++i) { childID = words[idx][i]-'a'; if(!root-children[childID]) root-children[childID] = new Trie(); root = root-children[childID]; ++root-prefixCount;//计算该字符在字典树中的使用次数  } root-isEnd = true; root-wordIdx = idx;//单词编号存入 } Trie *buildTrie(const vectorstring \u0026words)//利用单词组构建字典树 { Trie *root = new Trie(); for(int i=0; i  words.size(); ++i) insertWord(root, words, i); return root; } int dfs_Trie(vectorstring \u0026res, Trie *root, vectorvectorchar\u0026 board, vectorstring\u0026 words, int row, int col) {//res保存结果，root保存当前在树中的位置  int detected = 0;//表示root的prefixCount变化量  if(root-isEnd)//递归终止条件  { ++detected; root-isEnd = false;//每个单词只出现一次  res.push_back(words[root-wordIdx]);//放入结果  } if( row0 || row=board.size() || col0 || col=board[0].size() || board[row][col]=='*' ||//保证不越界和同一单元不再次使用  !root-children[ board[row][col]-'a'] || root-children[ board[row][col]-'a']-prefixCount  0 ) //保证字典树中存在该节点并且以该节点组成的单词还没被挑选完  return detected; int curC = board[row][col] - 'a';//局部变量保存该节点字符  board[row][col] = '*';//改变单元格状态  //四个方向，  detected += dfs_Trie(res, root-children[curC], board, words, row-1, col) + dfs_Trie(res, root-children[curC], board, words, row+1, col) + dfs_Trie(res, root-children[curC], board, words, row, col - 1) + dfs_Trie(res, root-children[curC], board, words, row, col + 1) ; root-prefixCount -=detected;//维护PrefixCount  board[row][col] = curC+'a';//回溯  return detected; } public: vectorstring findWords(vectorvectorchar\u0026 board, vectorstring\u0026 words) { //字典树的构建需要有一定顺序的字符串，所以用words构建字典树，利用dfs在board中搜索  int M, N, wordNum = words.size();//需查找的单词个数  vectorstring res; if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res;//判断是否为空  Trie *root = buildTrie(words);//将单词存入字典  for(auto i=0; iM \u0026\u0026 root-prefixCount; ++i)//扫描行  for(auto j=0; jN; ++j)//扫描列  dfs_Trie(res, root, board, words, i, j);//进行dfs  delete root; return res; } };   LeetCode 208. Implement Trie (Prefix Tree) mplement a trie with insert, search, and startsWith methods.\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.\n解析：\n构建字典树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  class TrieNode { public: // Initialize your data structure here. TrieNode *child[26];//字母的字典树每个节点要定义一个大小为26的子节点指针数组， bool isWord;//用一个标志符用来记录到当前位置为止是否为一个词， TrieNode() : isWord(false){//默认构造函数  for (auto \u0026a : child) a = NULL; } }; class Trie { public: Trie() { root = new TrieNode();//初始化root } // Inserts a word into the trie. void insert(string s) { //insert操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，  TrieNode *p = root; for (auto \u0026a : s) { int i = a - 'a'; if (!p-child[i]) //若不存在则新建一个，然后再查找下一个。  p-child[i] = new TrieNode(); p = p-child[i]; } p-isWord = true; } // Returns if the word is in the trie. bool search(string key) { TrieNode *p = root; for (auto \u0026a : key) {//不存在子节点，则返回false  int i = a - 'a'; if (!p-child[i]) return false; p = p-child[i]; } return p-isWord;//还要看标志位 } // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) { TrieNode *p = root; for (auto \u0026a : prefix) { int i = a - 'a'; if (!p-child[i]) return false; p = p-child[i]; } return true;//查找到直接返回true } private: TrieNode* root; }; /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * bool param_2 = obj.search(word); * bool param_3 = obj.startsWith(prefix); */   LeetCode 211. Add and Search Word - Data structure design Design a data structure that supports the following two operations:\nvoid addWord(word)\nbool search(word)\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\nFor example:\naddWord(“bad”) addWord(“dad”) addWord(“mad”) search(“pad”) - false search(“bad”) - true search(“.ad”) - true search(“b..”) - true  Note:\nYou may assume that all words are consist of lowercase letters a-z.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class TrieNode { public: bool isKey; TrieNode* children[26]; TrieNode(): isKey(false) { memset(children, NULL, sizeof(TrieNode*) * 26); } }; class WordDictionary { public: WordDictionary() { root = new TrieNode(); } // Adds a word into the data structure. void addWord(string word) {//插入单词  TrieNode* run = root; for (char c : word) { if (!(run - children[c - 'a'])) run - children[c - 'a'] = new TrieNode(); run = run - children[c - 'a']; } run - isKey = true; } // Returns if the word is in the data structure. A word could // contain the dot character '.' to represent any one letter. bool search(string word) { return query(word.c_str(), root); } private: TrieNode* root; bool query(const char* word, TrieNode* node) {//在树中查找字符串  TrieNode* run = node; for (int i = 0; word[i]; i++) {//扫描字符串，进行匹配  if (run \u0026\u0026 word[i] != '.')//精确匹配，直接继续向下寻找  run = run - children[word[i] - 'a']; else if (run \u0026\u0026 word[i] == '.') { //非精确匹配  TrieNode* tmp = run; for (int j = 0; j  26; j++) { run = tmp - children[j]; if (query(word + i + 1, run))//非精确匹配有很多可能，需要dfs  return true; } } else break; } return run \u0026\u0026 run - isKey; } }; // Your WordDictionary object will be instantiated and called as such: // WordDictionary wordDictionary; // wordDictionary.addWord(\"word\"); // wordDictionary.search(\"pattern\");   LeetCode 421. Maximum XOR of Two Numbers in an Array Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai Find the maximum result of ai XOR aj, where 0 ≤ i, j Could you do this in O(n) runtime?\nExample:\nInput: [3, 10, 5, 25, 2, 8]\nOutput: 28\nExplanation: The maximum result is 5 ^ 25 = 28.\n解析：\n给定一个数组，求出某两个元素的最大异或和。\n整数在存储时是一个占据32bit的数，因此可以看成一个含32个字符的字符串，这个字符串中的每个字符只可能是0或1。因此，将一个整数插入Trie树就是从它的最高位开始，根据每一位上的值进入不同的分支，直到最低位。而且在建树时不需要单词结束的标记，因为所有单词长度相同。\n接下来，是如何找到最大的异或值，两个数异或得到一个数，这个数的值要尽量大，那么这个数的二进制表示法中，第一个1出现的位数越高这个数就越大，即置1位越高数越大。\n所以，对于数组中的每一个数，要找到它和数组中其他数异或后得到的最大异或值，可以采用类似贪心的策略，从最高位开始，找和它相反的位。如果有，那么和这个数异或就得到最大异或值，如果没有就只好选择相同的位，然后往下一位找，直到找到相异的位，沿途经过的所有位就是所找的数。因为每一个字典树中可行的路径必然代表了一个数，这个数和所枚举的数构成最优解。\n可以在枚举数组元素进行求解的过程中，先对该元素取反。因为取反之后在查找Trie的时候如果当前匹配的话，那么就说明当前这一位异或之后是为１的，我们就可以继续沿着这个分支走下去．如果不匹配说明异或之后当前这位是为０，并且这个分支为空，所以我们只能走另外一个分支．时间复杂度为O(32*n)，也就是O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Solution { public: struct Trie{ vectorTrie* next; Trie():next(vectorTrie*(2, NULL)){} }; void add(int num){ Trie* tem = root; for(int i = 31; i =0; i--){ int val = (numi)\u00261; if(!tem-next[val]) tem-next[val] = new Trie(); tem = tem-next[val]; } } int search(int num){ int ans = 0; Trie* tem = root; for(int i = 31; i = 0; i--){ int val = (numi)\u00261; ans = ans1; if(tem-next[val]) ans++, tem = tem-next[val]; else tem = tem-next[!val]; //该位相同的数值，只能选不同的  } return ans; } int findMaximumXOR(vectorint\u0026 nums) { root = new Trie(); for(auto val: nums) add(val); int ans = INT_MIN; for(auto val: nums) ans = max(ans, search(~val)); return ans; } private: Trie *root; };   补充：\n此题也可以用位运算来暴力模拟字典树的查找过程。\nmax为每次从高位开始，到某一位为止，所能获得的最大的数。（相当于字典树的每一层）\n计算使用的结果，不是只看一位，而是每次把新的一位加到原来的结果后面。这样的好处是不需要记录之前的结果满足条件的有哪些，每次就重新计算和查找就可以了，大大降低了复杂度。\n设置变量mask用来表示能形成的值，每一次将mask和其他的num相与得到的值加入set，表示在当前这一位上，数组里有这么多prefix。（字典树的当前层的所有节点）\n利用XOR的性质，a^b = c, 则有 a^c = b，且 b^c = a;\n假定在某一位上的任意两数xor能得到的最大值是tmp,那么他一定满足a(xor)b = tmp,其中set.count(a) \u0026\u0026 set.count(b).\n所以，我们只需要判断b(xor)tmp的结果是不是在当前这一位下的set内，就可以知道这个tmp能不能由这个set中的任意两个数组成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public: int findMaximumXOR(vectorint\u0026 nums) { int max = 0, mask = 0; for(int i = 31; i = 0; i--){ mask = mask | (1  i); setint Set; for(int num : nums){ Set.insert(num \u0026 mask); } // 假设当前所能达到的最大值是这个temp值；  int tmp = max | (1  i); for(int prefix : Set){ if(Set.count(tmp ^ prefix)) { // 如果能组成就直接break  max = tmp; break; } } } return max; } };   ",
  "wordCount" : "4349",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:31:45Z",
  "dateModified": "2017-06-24T20:31:45Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      字典树相关问题
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-79-word-search">LeetCode 79. Word Search<a hidden class="anchor" aria-hidden="true" href="#leetcode-79-word-search">#</a></h1>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>
Given board =</p>
<pre><code>[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
</code></pre>
<p>word = “ABCCED”, -&gt; returns true, <br>
word = “SEE”, -&gt; returns true,  <br>
word = “ABCB”, -&gt; returns false.</p>
<p>解析：</p>
<p>回溯法求解，枚举每一个起点进行dfs寻找路径，dfs过程中需要知道当前扫描点的坐标和当前匹配的字符。</p>
<p>在图中寻找路径dfs会出现路径重复，需要用visit数组来标记已经访问的点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">exist</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//m为行
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//n为列
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>        <span class="c1">//枚举起点
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 收敛条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 越界，终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 已经访问过，剪枝
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 不相等，结束
</span><span class="c1"></span>    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//维护visit
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span> <span class="o">||</span> <span class="c1">// 上
</span><span class="c1"></span>            <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>    <span class="o">||</span> <span class="c1">// 下
</span><span class="c1"></span>            <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>    <span class="o">||</span> <span class="c1">// 左
</span><span class="c1"></span>            <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">);</span>      <span class="c1">// 右
</span><span class="c1"></span>    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//还原visit
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-212-word-search-ii">LeetCode 212. Word Search II<a hidden class="anchor" aria-hidden="true" href="#leetcode-212-word-search-ii">#</a></h1>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,
Given words = [“oath”,”pea”,”eat”,”rain”] and board =</p>
<pre><code>[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
</code></pre>
<p>Return [“eat”,”oath”].</p>
<p>Note:</p>
<p>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>解析：</p>
<p>要查找多个单词是否存在，需要用字典树。</p>
<p>字典树主要有如下三点性质：</p>
<ol>
<li>
<p>根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>
</li>
<li>
<p>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
</li>
<li>
<p>每个节点的所有子节点包含的字符串不相同。</p>
</li>
</ol>
<p>字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第i 次循环找到前i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。</p>
<p>至于结点对儿子的指向，一般有三种方法：</p>
<p>1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；</p>
<p>2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；</p>
<p>3、使用左儿子右兄弟表示法记录这棵树。</p>
<p>三种方法，各有特点。</p>
<p>第一种，易实现，但实际的空间要求较大；</p>
<p>第二种，较易实现，空间要求相对较小，但比较费时；</p>
<p>第三种，空间要求最小，但相对费时且不易写。</p>
<p>我们来看第一种实现方法，这种方法实现起来简单直观。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">class</span> <span class="n">Trie</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>    
<span class="n">Trie</span> <span class="o">*</span> <span class="n">children</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isEnd</span><span class="p">;</span><span class="c1">//单词标记
</span><span class="c1"></span><span class="kt">int</span>  <span class="n">wordIdx</span><span class="p">;</span><span class="c1">//保存当前单词编号
</span><span class="c1"></span><span class="kt">int</span> <span class="n">prefixCount</span><span class="p">;</span><span class="c1">//记录使用次数
</span><span class="c1"></span><span class="n">Trie</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">isEnd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">wordIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prefixCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fill_n</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">Trie</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">delete</span> <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">insertWord</span><span class="p">(</span><span class="n">Trie</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="c1">//将单词插入字典
</span><span class="c1"></span><span class="p">{</span><span class="c1">//将整个string数组和单词编号传入
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">childID</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span><span class="o">++</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">childID</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">childID</span><span class="p">])</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">childID</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">childID</span><span class="p">];</span>
        <span class="o">++</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span><span class="p">;</span><span class="c1">//计算该字符在字典树中的使用次数
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">isEnd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">wordIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span><span class="c1">//单词编号存入
</span><span class="c1"></span><span class="p">}</span>

<span class="n">Trie</span> <span class="o">*</span><span class="nf">buildTrie</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">)</span><span class="c1">//利用单词组构建字典树
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">Trie</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">insertWord</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dfs_Trie</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">Trie</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span>
<span class="p">{</span><span class="c1">//res保存结果，root保存当前在树中的位置 
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//表示root的prefixCount变化量
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">isEnd</span><span class="p">)</span><span class="c1">//递归终止条件
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="o">++</span><span class="n">detected</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">isEnd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//每个单词只出现一次
</span><span class="c1"></span>        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">wordIdx</span><span class="p">]);</span><span class="c1">//放入结果
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">row</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">row</span><span class="o">&gt;=</span><span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">col</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">col</span><span class="o">&gt;=</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;*&#39;</span> <span class="o">||</span><span class="c1">//保证不越界和同一单元不再次使用 
</span><span class="c1"></span>            <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">prefixCount</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span> 
        <span class="c1">//保证字典树中存在该节点并且以该节点组成的单词还没被挑选完
</span><span class="c1"></span>                    <span class="k">return</span> <span class="n">detected</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curC</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="c1">//局部变量保存该节点字符
</span><span class="c1"></span>    <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;*&#39;</span><span class="p">;</span><span class="c1">//改变单元格状态
</span><span class="c1"></span>    <span class="c1">//四个方向，
</span><span class="c1"></span>    <span class="n">detected</span> <span class="o">+=</span> <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">+</span> 
           <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">+</span>    
           <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>    
           <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span> <span class="o">-=</span><span class="n">detected</span><span class="p">;</span><span class="c1">//维护PrefixCount
</span><span class="c1"></span>    <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">curC</span><span class="o">+</span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">detected</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findWords</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//字典树的构建需要有一定顺序的字符串，所以用words构建字典树，利用dfs在board中搜索
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">wordNum</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//需查找的单词个数
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">M</span> <span class="o">=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="o">||</span> <span class="o">!</span><span class="n">wordNum</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span><span class="c1">//判断是否为空
</span><span class="c1"></span>    <span class="n">Trie</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">buildTrie</span><span class="p">(</span><span class="n">words</span><span class="p">);</span><span class="c1">//将单词存入字典
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//扫描行
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="c1">//扫描列
</span><span class="c1"></span>            <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span><span class="c1">//进行dfs
</span><span class="c1"></span>    <span class="n">delete</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-208-implement-trie-prefix-tree">LeetCode 208. Implement Trie (Prefix Tree)<a hidden class="anchor" aria-hidden="true" href="#leetcode-208-implement-trie-prefix-tree">#</a></h1>
<p>mplement a trie with insert, search, and startsWith methods.</p>
<p>Note:</p>
<p>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>解析：</p>
<p>构建字典树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">TrieNode</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="c1">// Initialize your data structure here.
</span><span class="c1"></span><span class="n">TrieNode</span> <span class="o">*</span><span class="n">child</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span><span class="c1">//字母的字典树每个节点要定义一个大小为26的子节点指针数组，
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">isWord</span><span class="p">;</span><span class="c1">//用一个标志符用来记录到当前位置为止是否为一个词，
</span><span class="c1"></span><span class="n">TrieNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">isWord</span><span class="p">(</span><span class="nb">false</span><span class="p">){</span><span class="c1">//默认构造函数
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">child</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="n">class</span> <span class="n">Trie</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">Trie</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span><span class="c1">//初始化root
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// Inserts a word into the trie.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//insert操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，
</span><span class="c1"></span>    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">//若不存在则新建一个，然后再查找下一个。
</span><span class="c1"></span>            <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">isWord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns if the word is in the trie.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">search</span><span class="p">(</span><span class="n">string</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span><span class="c1">//不存在子节点，则返回false
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">isWord</span><span class="p">;</span><span class="c1">//还要看标志位
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Returns if there is any word in the trie
</span><span class="c1">// that starts with the given prefix.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">startsWith</span><span class="p">(</span><span class="n">string</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//查找到直接返回true
</span><span class="c1"></span><span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
<span class="n">TrieNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/**
</span><span class="cm"> * Your Trie object will be instantiated and called as such:
</span><span class="cm"> * Trie obj = new Trie();
</span><span class="cm"> * obj.insert(word);
</span><span class="cm"> * bool param_2 = obj.search(word);
</span><span class="cm"> * bool param_3 = obj.startsWith(prefix);
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-211-add-and-search-word---data-structure-design">LeetCode 211. Add and Search Word - Data structure design<a hidden class="anchor" aria-hidden="true" href="#leetcode-211-add-and-search-word---data-structure-design">#</a></h1>
<p>Design a data structure that supports the following two operations:</p>
<p>void addWord(word)<br>
bool search(word)<br>
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>For example:</p>
<pre><code>addWord(“bad”)
addWord(“dad”)
addWord(“mad”)
search(“pad”) -&gt; false
search(“bad”) -&gt; true
search(“.ad”) -&gt; true
search(“b..”) -&gt; true
</code></pre>
<p>Note:</p>
<p>You may assume that all words are consist of lowercase letters a-z.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">TrieNode</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">isKey</span><span class="p">;</span>
<span class="n">TrieNode</span><span class="o">*</span> <span class="n">children</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
<span class="n">TrieNode</span><span class="p">()</span><span class="o">:</span> <span class="n">isKey</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TrieNode</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">26</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">WordDictionary</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">WordDictionary</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// Adds a word into the data structure.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">addWord</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span><span class="c1">//插入单词
</span><span class="c1"></span>    <span class="n">TrieNode</span><span class="o">*</span> <span class="n">run</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]))</span> 
            <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span>
        <span class="n">run</span> <span class="o">=</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">isKey</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns if the word is in the data structure. A word could
</span><span class="c1">// contain the dot character &#39;.&#39; to represent any one letter.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">search</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
<span class="n">TrieNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">query</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">,</span> <span class="n">TrieNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span><span class="c1">//在树中查找字符串
</span><span class="c1"></span>    <span class="n">TrieNode</span><span class="o">*</span> <span class="n">run</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//扫描字符串，进行匹配
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">run</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="c1">//精确匹配，直接继续向下寻找
</span><span class="c1"></span>            <span class="n">run</span> <span class="o">=</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">run</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//非精确匹配
</span><span class="c1"></span>            <span class="n">TrieNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">run</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">run</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">word</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">run</span><span class="p">))</span><span class="c1">//非精确匹配有很多可能，需要dfs
</span><span class="c1"></span>                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">run</span> <span class="o">&amp;&amp;</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">isKey</span><span class="p">;</span> 
<span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Your WordDictionary object will be instantiated and called as such:
</span><span class="c1">// WordDictionary wordDictionary;
</span><span class="c1">// wordDictionary.addWord(&#34;word&#34;);
</span><span class="c1">// wordDictionary.search(&#34;pattern&#34;);
</span></code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-421-maximum-xor-of-two-numbers-in-an-array">LeetCode 421. Maximum XOR of Two Numbers in an Array<a hidden class="anchor" aria-hidden="true" href="#leetcode-421-maximum-xor-of-two-numbers-in-an-array">#</a></h1>
<p>Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231.</p>
<p>Find the maximum result of ai XOR aj, where 0 ≤ i, j &lt; n.</p>
<p>Could you do this in O(n) runtime?</p>
<p>Example:</p>
<p>Input: [3, 10, 5, 25, 2, 8]</p>
<p>Output: 28</p>
<p>Explanation: The maximum result is 5 ^ 25 = 28.</p>
<p>解析：</p>
<p>给定一个数组，求出某两个元素的最大异或和。</p>
<p>整数在存储时是一个占据32bit的数，因此可以看成一个含32个字符的字符串，这个字符串中的每个字符只可能是0或1。因此，将一个整数插入Trie树就是从它的最高位开始，根据每一位上的值进入不同的分支，直到最低位。而且在建树时不需要单词结束的标记，因为所有单词长度相同。</p>
<p>接下来，是如何找到最大的异或值，两个数异或得到一个数，这个数的值要尽量大，那么这个数的二进制表示法中，第一个1出现的位数越高这个数就越大，即置1位越高数越大。</p>
<p>所以，对于数组中的每一个数，要找到它和数组中其他数异或后得到的最大异或值，可以采用类似贪心的策略，从最高位开始，找和它相反的位。如果有，那么和这个数异或就得到最大异或值，如果没有就只好选择相同的位，然后往下一位找，直到找到相异的位，沿途经过的所有位就是所找的数。因为每一个字典树中可行的路径必然代表了一个数，这个数和所枚举的数构成最优解。</p>
<p>可以在枚举数组元素进行求解的过程中，先对该元素取反。因为取反之后在查找Trie的时候如果当前匹配的话，那么就说明当前这一位异或之后是为１的，我们就可以继续沿着这个分支走下去．如果不匹配说明异或之后当前这位是为０，并且这个分支为空，所以我们只能走另外一个分支．时间复杂度为O(32*n)，也就是O(n)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="k">struct</span> <span class="n">Trie</span><span class="p">{</span>  
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Trie</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>  
    <span class="n">Trie</span><span class="p">()</span><span class="o">:</span><span class="n">next</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Trie</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)){}</span>  
<span class="p">};</span>  
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">){</span>  
    <span class="n">Trie</span><span class="o">*</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>  
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">])</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>  
        <span class="n">tem</span> <span class="o">=</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">){</span>  
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="n">Trie</span><span class="o">*</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>  
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>  
        <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">if</span><span class="p">(</span><span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">])</span> <span class="n">ans</span><span class="o">++</span><span class="p">,</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>  
        <span class="k">else</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="o">!</span><span class="n">val</span><span class="p">];</span>  <span class="c1">//该位相同的数值，只能选不同的
</span><span class="c1"></span>    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">findMaximumXOR</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>  
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">search</span><span class="p">(</span><span class="o">~</span><span class="n">val</span><span class="p">));</span>  
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="nl">private</span><span class="p">:</span>  
<span class="n">Trie</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>此题也可以用位运算来暴力模拟字典树的查找过程。</p>
<p>max为每次从高位开始，到某一位为止，所能获得的最大的数。（相当于字典树的每一层）</p>
<p>计算使用的结果，不是只看一位，而是每次把新的一位加到原来的结果后面。这样的好处是不需要记录之前的结果满足条件的有哪些，每次就重新计算和查找就可以了，大大降低了复杂度。</p>
<p>设置变量mask用来表示能形成的值，每一次将mask和其他的num相与得到的值加入set，表示在当前这一位上，数组里有这么多prefix。（字典树的当前层的所有节点）</p>
<p>利用XOR的性质，a^b = c, 则有 a^c = b，且 b^c = a;</p>
<p>假定在某一位上的任意两数xor能得到的最大值是tmp,那么他一定满足a(xor)b = tmp,其中set.count(a) &amp;&amp; set.count(b).</p>
<p>所以，我们只需要判断b(xor)tmp的结果是不是在当前这一位下的set内，就可以知道这个tmp能不能由这个set中的任意两个数组成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">findMaximumXOR</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Set</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">){</span>
            <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">num</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 假设当前所能达到的最大值是这个temp值；
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">max</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">prefix</span> <span class="p">:</span> <span class="n">Set</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">tmp</span> <span class="o">^</span> <span class="n">prefix</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 如果能组成就直接break 
</span><span class="c1"></span>                <span class="n">max</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a></li>
      <li><a href="/tags/backtracking/">Backtracking</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
