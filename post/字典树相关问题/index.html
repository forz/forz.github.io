<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>字典树相关问题 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.84.1 with theme even" />


<link rel="canonical" href="/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="字典树相关问题" />
<meta property="og:description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:31:45&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:31:45&#43;00:00" />

<meta itemprop="name" content="字典树相关问题">
<meta itemprop="description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word"><meta itemprop="datePublished" content="2017-06-24T20:31:45&#43;00:00" />
<meta itemprop="dateModified" content="2017-06-24T20:31:45&#43;00:00" />
<meta itemprop="wordCount" content="4349">
<meta itemprop="keywords" content="字典树,Backtracking," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字典树相关问题"/>
<meta name="twitter:description" content="LeetCode 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">字典树相关问题</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-24 </span>
        <div class="post-category">
            <a href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"> 解题报告 </a>
            </div>
          <span class="more-meta"> 约 4349 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="leetcode-79-word-search">LeetCode 79. Word Search</h1>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>
Given board =</p>
<pre><code>[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
</code></pre>
<p>word = “ABCCED”, -&gt; returns true, <br>
word = “SEE”, -&gt; returns true,  <br>
word = “ABCB”, -&gt; returns false.</p>
<p>解析：</p>
<p>回溯法求解，枚举每一个起点进行dfs寻找路径，dfs过程中需要知道当前扫描点的坐标和当前匹配的字符。</p>
<p>在图中寻找路径dfs会出现路径重复，需要用visit数组来标记已经访问的点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">exist</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//m为行
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//n为列
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>        <span class="c1">//枚举起点
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 收敛条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 越界，终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 已经访问过，剪枝
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 不相等，结束
</span><span class="c1"></span>    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//维护visit
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span> <span class="o">||</span> <span class="c1">// 上
</span><span class="c1"></span>            <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>    <span class="o">||</span> <span class="c1">// 下
</span><span class="c1"></span>            <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>    <span class="o">||</span> <span class="c1">// 左
</span><span class="c1"></span>            <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">);</span>      <span class="c1">// 右
</span><span class="c1"></span>    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//还原visit
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-212-word-search-ii">LeetCode 212. Word Search II</h1>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,
Given words = [“oath”,”pea”,”eat”,”rain”] and board =</p>
<pre><code>[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
</code></pre>
<p>Return [“eat”,”oath”].</p>
<p>Note:</p>
<p>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>解析：</p>
<p>要查找多个单词是否存在，需要用字典树。</p>
<p>字典树主要有如下三点性质：</p>
<ol>
<li>
<p>根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>
</li>
<li>
<p>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
</li>
<li>
<p>每个节点的所有子节点包含的字符串不相同。</p>
</li>
</ol>
<p>字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第i 次循环找到前i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。</p>
<p>至于结点对儿子的指向，一般有三种方法：</p>
<p>1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；</p>
<p>2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；</p>
<p>3、使用左儿子右兄弟表示法记录这棵树。</p>
<p>三种方法，各有特点。</p>
<p>第一种，易实现，但实际的空间要求较大；</p>
<p>第二种，较易实现，空间要求相对较小，但比较费时；</p>
<p>第三种，空间要求最小，但相对费时且不易写。</p>
<p>我们来看第一种实现方法，这种方法实现起来简单直观。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="n">class</span> <span class="n">Trie</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>    
<span class="n">Trie</span> <span class="o">*</span> <span class="n">children</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isEnd</span><span class="p">;</span><span class="c1">//单词标记
</span><span class="c1"></span><span class="kt">int</span>  <span class="n">wordIdx</span><span class="p">;</span><span class="c1">//保存当前单词编号
</span><span class="c1"></span><span class="kt">int</span> <span class="n">prefixCount</span><span class="p">;</span><span class="c1">//记录使用次数
</span><span class="c1"></span><span class="n">Trie</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">isEnd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">wordIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prefixCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fill_n</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">Trie</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">delete</span> <span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">insertWord</span><span class="p">(</span><span class="n">Trie</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="c1">//将单词插入字典
</span><span class="c1"></span><span class="p">{</span><span class="c1">//将整个string数组和单词编号传入
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">childID</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span><span class="o">++</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">childID</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">childID</span><span class="p">])</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">childID</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">childID</span><span class="p">];</span>
        <span class="o">++</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span><span class="p">;</span><span class="c1">//计算该字符在字典树中的使用次数
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">isEnd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">wordIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span><span class="c1">//单词编号存入
</span><span class="c1"></span><span class="p">}</span>

<span class="n">Trie</span> <span class="o">*</span><span class="nf">buildTrie</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">)</span><span class="c1">//利用单词组构建字典树
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">Trie</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">insertWord</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dfs_Trie</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">Trie</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span>
<span class="p">{</span><span class="c1">//res保存结果，root保存当前在树中的位置 
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//表示root的prefixCount变化量
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">isEnd</span><span class="p">)</span><span class="c1">//递归终止条件
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="o">++</span><span class="n">detected</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">isEnd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//每个单词只出现一次
</span><span class="c1"></span>        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">wordIdx</span><span class="p">]);</span><span class="c1">//放入结果
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">row</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">row</span><span class="o">&gt;=</span><span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">col</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">col</span><span class="o">&gt;=</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;*&#39;</span> <span class="o">||</span><span class="c1">//保证不越界和同一单元不再次使用 
</span><span class="c1"></span>            <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">prefixCount</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span> 
        <span class="c1">//保证字典树中存在该节点并且以该节点组成的单词还没被挑选完
</span><span class="c1"></span>                    <span class="k">return</span> <span class="n">detected</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curC</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="c1">//局部变量保存该节点字符
</span><span class="c1"></span>    <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;*&#39;</span><span class="p">;</span><span class="c1">//改变单元格状态
</span><span class="c1"></span>    <span class="c1">//四个方向，
</span><span class="c1"></span>    <span class="n">detected</span> <span class="o">+=</span> <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">+</span> 
           <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">+</span>    
           <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>    
           <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">curC</span><span class="p">],</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span> <span class="o">-=</span><span class="n">detected</span><span class="p">;</span><span class="c1">//维护PrefixCount
</span><span class="c1"></span>    <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">curC</span><span class="o">+</span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">detected</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findWords</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//字典树的构建需要有一定顺序的字符串，所以用words构建字典树，利用dfs在board中搜索
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">wordNum</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//需查找的单词个数
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">M</span> <span class="o">=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="o">||</span> <span class="o">!</span><span class="n">wordNum</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span><span class="c1">//判断是否为空
</span><span class="c1"></span>    <span class="n">Trie</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">buildTrie</span><span class="p">(</span><span class="n">words</span><span class="p">);</span><span class="c1">//将单词存入字典
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prefixCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//扫描行
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="c1">//扫描列
</span><span class="c1"></span>            <span class="n">dfs_Trie</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span><span class="c1">//进行dfs
</span><span class="c1"></span>    <span class="n">delete</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-208-implement-trie-prefix-tree">LeetCode 208. Implement Trie (Prefix Tree)</h1>
<p>mplement a trie with insert, search, and startsWith methods.</p>
<p>Note:</p>
<p>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>解析：</p>
<p>构建字典树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">TrieNode</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="c1">// Initialize your data structure here.
</span><span class="c1"></span><span class="n">TrieNode</span> <span class="o">*</span><span class="n">child</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span><span class="c1">//字母的字典树每个节点要定义一个大小为26的子节点指针数组，
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">isWord</span><span class="p">;</span><span class="c1">//用一个标志符用来记录到当前位置为止是否为一个词，
</span><span class="c1"></span><span class="n">TrieNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">isWord</span><span class="p">(</span><span class="nb">false</span><span class="p">){</span><span class="c1">//默认构造函数
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">child</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="n">class</span> <span class="n">Trie</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">Trie</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span><span class="c1">//初始化root
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// Inserts a word into the trie.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//insert操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，
</span><span class="c1"></span>    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">//若不存在则新建一个，然后再查找下一个。
</span><span class="c1"></span>            <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">isWord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns if the word is in the trie.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">search</span><span class="p">(</span><span class="n">string</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span><span class="c1">//不存在子节点，则返回false
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">isWord</span><span class="p">;</span><span class="c1">//还要看标志位
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Returns if there is any word in the trie
</span><span class="c1">// that starts with the given prefix.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">startsWith</span><span class="p">(</span><span class="n">string</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TrieNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">a</span> <span class="p">:</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//查找到直接返回true
</span><span class="c1"></span><span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
<span class="n">TrieNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/**
</span><span class="cm"> * Your Trie object will be instantiated and called as such:
</span><span class="cm"> * Trie obj = new Trie();
</span><span class="cm"> * obj.insert(word);
</span><span class="cm"> * bool param_2 = obj.search(word);
</span><span class="cm"> * bool param_3 = obj.startsWith(prefix);
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-211-add-and-search-word---data-structure-design">LeetCode 211. Add and Search Word - Data structure design</h1>
<p>Design a data structure that supports the following two operations:</p>
<p>void addWord(word)<br>
bool search(word)<br>
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>For example:</p>
<pre><code>addWord(“bad”)
addWord(“dad”)
addWord(“mad”)
search(“pad”) -&gt; false
search(“bad”) -&gt; true
search(“.ad”) -&gt; true
search(“b..”) -&gt; true
</code></pre>
<p>Note:</p>
<p>You may assume that all words are consist of lowercase letters a-z.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">TrieNode</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">isKey</span><span class="p">;</span>
<span class="n">TrieNode</span><span class="o">*</span> <span class="n">children</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
<span class="n">TrieNode</span><span class="p">()</span><span class="o">:</span> <span class="n">isKey</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TrieNode</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="mi">26</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">WordDictionary</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">WordDictionary</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// Adds a word into the data structure.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">addWord</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span><span class="c1">//插入单词
</span><span class="c1"></span>    <span class="n">TrieNode</span><span class="o">*</span> <span class="n">run</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]))</span> 
            <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TrieNode</span><span class="p">();</span>
        <span class="n">run</span> <span class="o">=</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">isKey</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns if the word is in the data structure. A word could
</span><span class="c1">// contain the dot character &#39;.&#39; to represent any one letter.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">search</span><span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
<span class="n">TrieNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">query</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">,</span> <span class="n">TrieNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span><span class="c1">//在树中查找字符串
</span><span class="c1"></span>    <span class="n">TrieNode</span><span class="o">*</span> <span class="n">run</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//扫描字符串，进行匹配
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">run</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="c1">//精确匹配，直接继续向下寻找
</span><span class="c1"></span>            <span class="n">run</span> <span class="o">=</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">run</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//非精确匹配
</span><span class="c1"></span>            <span class="n">TrieNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">run</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">run</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">word</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">run</span><span class="p">))</span><span class="c1">//非精确匹配有很多可能，需要dfs
</span><span class="c1"></span>                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">run</span> <span class="o">&amp;&amp;</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="n">isKey</span><span class="p">;</span> 
<span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Your WordDictionary object will be instantiated and called as such:
</span><span class="c1">// WordDictionary wordDictionary;
</span><span class="c1">// wordDictionary.addWord(&#34;word&#34;);
</span><span class="c1">// wordDictionary.search(&#34;pattern&#34;);
</span></code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-421-maximum-xor-of-two-numbers-in-an-array">LeetCode 421. Maximum XOR of Two Numbers in an Array</h1>
<p>Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231.</p>
<p>Find the maximum result of ai XOR aj, where 0 ≤ i, j &lt; n.</p>
<p>Could you do this in O(n) runtime?</p>
<p>Example:</p>
<p>Input: [3, 10, 5, 25, 2, 8]</p>
<p>Output: 28</p>
<p>Explanation: The maximum result is 5 ^ 25 = 28.</p>
<p>解析：</p>
<p>给定一个数组，求出某两个元素的最大异或和。</p>
<p>整数在存储时是一个占据32bit的数，因此可以看成一个含32个字符的字符串，这个字符串中的每个字符只可能是0或1。因此，将一个整数插入Trie树就是从它的最高位开始，根据每一位上的值进入不同的分支，直到最低位。而且在建树时不需要单词结束的标记，因为所有单词长度相同。</p>
<p>接下来，是如何找到最大的异或值，两个数异或得到一个数，这个数的值要尽量大，那么这个数的二进制表示法中，第一个1出现的位数越高这个数就越大，即置1位越高数越大。</p>
<p>所以，对于数组中的每一个数，要找到它和数组中其他数异或后得到的最大异或值，可以采用类似贪心的策略，从最高位开始，找和它相反的位。如果有，那么和这个数异或就得到最大异或值，如果没有就只好选择相同的位，然后往下一位找，直到找到相异的位，沿途经过的所有位就是所找的数。因为每一个字典树中可行的路径必然代表了一个数，这个数和所枚举的数构成最优解。</p>
<p>可以在枚举数组元素进行求解的过程中，先对该元素取反。因为取反之后在查找Trie的时候如果当前匹配的话，那么就说明当前这一位异或之后是为１的，我们就可以继续沿着这个分支走下去．如果不匹配说明异或之后当前这位是为０，并且这个分支为空，所以我们只能走另外一个分支．时间复杂度为O(32*n)，也就是O(n)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="k">struct</span> <span class="n">Trie</span><span class="p">{</span>  
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Trie</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>  
    <span class="n">Trie</span><span class="p">()</span><span class="o">:</span><span class="n">next</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Trie</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)){}</span>  
<span class="p">};</span>  
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">){</span>  
    <span class="n">Trie</span><span class="o">*</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>  
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">])</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>  
        <span class="n">tem</span> <span class="o">=</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">){</span>  
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="n">Trie</span><span class="o">*</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>  
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>  
        <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">if</span><span class="p">(</span><span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">])</span> <span class="n">ans</span><span class="o">++</span><span class="p">,</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>  
        <span class="k">else</span> <span class="n">tem</span> <span class="o">=</span> <span class="n">tem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="o">!</span><span class="n">val</span><span class="p">];</span>  <span class="c1">//该位相同的数值，只能选不同的
</span><span class="c1"></span>    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">findMaximumXOR</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Trie</span><span class="p">();</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>  
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">search</span><span class="p">(</span><span class="o">~</span><span class="n">val</span><span class="p">));</span>  
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="nl">private</span><span class="p">:</span>  
<span class="n">Trie</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><p>补充：</p>
<p>此题也可以用位运算来暴力模拟字典树的查找过程。</p>
<p>max为每次从高位开始，到某一位为止，所能获得的最大的数。（相当于字典树的每一层）</p>
<p>计算使用的结果，不是只看一位，而是每次把新的一位加到原来的结果后面。这样的好处是不需要记录之前的结果满足条件的有哪些，每次就重新计算和查找就可以了，大大降低了复杂度。</p>
<p>设置变量mask用来表示能形成的值，每一次将mask和其他的num相与得到的值加入set，表示在当前这一位上，数组里有这么多prefix。（字典树的当前层的所有节点）</p>
<p>利用XOR的性质，a^b = c, 则有 a^c = b，且 b^c = a;</p>
<p>假定在某一位上的任意两数xor能得到的最大值是tmp,那么他一定满足a(xor)b = tmp,其中set.count(a) &amp;&amp; set.count(b).</p>
<p>所以，我们只需要判断b(xor)tmp的结果是不是在当前这一位下的set内，就可以知道这个tmp能不能由这个set中的任意两个数组成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">findMaximumXOR</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Set</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">){</span>
            <span class="n">Set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">num</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 假设当前所能达到的最大值是这个temp值；
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">max</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">prefix</span> <span class="p">:</span> <span class="n">Set</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">Set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">tmp</span> <span class="o">^</span> <span class="n">prefix</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 如果能组成就直接break 
</span><span class="c1"></span>                <span class="n">max</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AD%97%E5%85%B8%E6%A0%91/">字典树</a>
          <a href="/tags/backtracking/">Backtracking</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%AD%90%E9%9B%86/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">子集</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/">
            <span class="next-text nav-default">单链表排序总结</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
