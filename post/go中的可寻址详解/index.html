<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go中的可寻址详解 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go中的可寻址详解" />
<meta property="og:description" content="Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-12-12T20:02:18&#43;00:00" />
<meta property="article:modified_time" content="2018-12-12T20:02:18&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go中的可寻址详解"/>
<meta name="twitter:description" content="Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go中的可寻址详解",
      "item": "/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go中的可寻址详解",
  "name": "Go中的可寻址详解",
  "description": "Go语言规范中规定了可寻址(addressable)对象的定义, For an operand x of type T, the address operation \u0026amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field",
  "keywords": [
    
  ],
  "articleBody": "Go语言规范中规定了可寻址(addressable)对象的定义,\nFor an operand x of type T, the address operation \u0026x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. If the evaluation of x would cause a run-time panic, then the evaluation of \u0026x does too.\n对于一个对象x, 如果它的类型为T, 那么\u0026x则会产生一个类型为*T的指针，这个指针指向x, 这是这一段的第一句话，也是我们在开发过程中经常使用的一种获取对象指针的一种方式。\naddressable 上面规范中的这段话规定， x必须是可寻址的， 也就是说，它只能是以下几种方式：\n 一个变量: \u0026x 指针引用(pointer indirection): \u0026*x slice索引操作(不管slice是否可寻址): \u0026s[1] 可寻址struct的字段: \u0026point.X 可寻址数组的索引操作: \u0026a[0] 结构体字面值类型literal: \u0026struct{ X int }{1}  下列情况x是不可以寻址的，你不能使用\u0026x取得指针：\n 字符串中的字节: map对象中的元素 接口对象的动态值(通过type assertions获得) 常数 字面值literal(非composite literal) package 级别的函数 方法method (用作函数值)   中间值(intermediate value):  函数调用 显式类型转换 各种类型的操作 （除了指针引用pointer dereference操作 *x):  channel receive operations sub-string operations sub-slice operations 加减乘除等运算符      有几个点需要解释下：\n 常数为什么不可以寻址?： 如果可以寻址的话，我们可以通过指针修改常数的值，破坏了常数的定义。 map的元素为什么不可以寻址？:两个原因，如果对象不存在，则返回零值，零值是不可变对象，所以不能寻址，如果对象存在，因为Go中map实现中元素的地址是变化的，这意味着寻址的结果是无意义的。 为什么slice不管是否可寻址，它的元素读是可以寻址的？:因为slice底层实现了一个数组，它是可以寻址的。 为什么字符串中的字符/字节又不能寻址呢：因为字符串是不可变的。  规范中还有几处提到了 addressable:\n 调用一个receiver为指针类型的方法时，使用一个addressable的值将自动获取这个值的指针 ++、–语句的操作对象必须是addressable或者是map的index操作 赋值语句=的左边对象必须是addressable,或者是map的index操作，或者是_ 上条同样使用for … range语句  reflect.Value的CanAddr方法和CanSet方法 在我们使用reflect执行一些底层的操作的时候， 比如编写序列化库、rpc框架开发、编解码、插件开发等业务的时候，经常会使用到reflect.Value的CanSet方法，用来动态的给对象赋值。 CanSet比CanAddr只加了一个限制，就是struct类型的unexported的字段不能Set，所以我们这节主要介绍CanAddr。\n并不是任意的reflect.Value的CanAddr方法都返回true,根据它的godoc,我们可以知道：\nCanAddr reports whether the value’s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.\n也就是只有下面的类型reflect.Value的CanAddr才是true, 这样的值是addressable:\n slice的元素 可寻址数组的元素 可寻址struct的字段 指针引用的结果  与规范中规定的addressable, reflect.Value的addressable范围有所缩小， 比如对于栈上分配的变量， 随着方法的生命周期的结束， 栈上的对象也就被回收掉了，这个时候如果获取它们的地址，就会出现不一致的结果，甚至安全问题。\n所以如果你想通过reflect.Value对它的值进行更新，应该确保它的CanSet方法返回true,这样才能调用SetXXX进行设置。\n使用reflect.Value的时候有时会对func Indirect(v Value) Value和func (v Value) Elem() Value两个方法有些迷惑，有时候他们俩会返回同样的值，有时候又不会。\n总结一下：\n 如果reflect.Value是一个指针， 那么v.Elem()等价于reflect.Indirect(v) 如果不是指针  如果是interface, 那么reflect.Indirect(v)返回同样的值，而v.Elem()返回接口的动态的值 如果是其它值, v.Elem()会panic,而reflect.Indirect(v)返回原值    下面的代码列出一些reflect.Value是否可以addressable, 你需要注意数组和struct字段的情况，也就是x7、x9、x14、x15的正确的处理方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  package main import ( \"fmt\" \"reflect\" \"time\" ) func main() { checkCanAddr() } type S struct { X int Y string z int } func M() int { return 100 } var x0 = 0 func checkCanAddr() { // 可寻址的情况 \tv := reflect.ValueOf(x0) fmt.Printf(\"x0: %v \\tcan be addressable and set: %t, %t\\n\", x0, v.CanAddr(), v.CanSet()) //false,false \tvar x1 = 1 v = reflect.Indirect(reflect.ValueOf(x1)) fmt.Printf(\"x1: %v \\tcan be addressable and set: %t, %t\\n\", x1, v.CanAddr(), v.CanSet()) //false,false \tvar x2 = \u0026x1 v = reflect.Indirect(reflect.ValueOf(x2)) fmt.Printf(\"x2: %v \\tcan be addressable and set: %t, %t\\n\", x2, v.CanAddr(), v.CanSet()) //true,true \tvar x3 = time.Now() v = reflect.Indirect(reflect.ValueOf(x3)) fmt.Printf(\"x3: %v \\tcan be addressable and set: %t, %t\\n\", x3, v.CanAddr(), v.CanSet()) //false,false \tvar x4 = \u0026x3 v = reflect.Indirect(reflect.ValueOf(x4)) fmt.Printf(\"x4: %v \\tcan be addressable and set: %t, %t\\n\", x4, v.CanAddr(), v.CanSet()) // true,true \tvar x5 = []int{1, 2, 3} v = reflect.ValueOf(x5) fmt.Printf(\"x5: %v \\tcan be addressable and set: %t, %t\\n\", x5, v.CanAddr(), v.CanSet()) // false,false \tvar x6 = []int{1, 2, 3} v = reflect.ValueOf(x6[0]) fmt.Printf(\"x6: %v \\tcan be addressable and set: %t, %t\\n\", x6[0], v.CanAddr(), v.CanSet()) //false,false \tvar x7 = []int{1, 2, 3} v = reflect.ValueOf(x7).Index(0) fmt.Printf(\"x7: %v \\tcan be addressable and set: %t, %t\\n\", x7[0], v.CanAddr(), v.CanSet()) //true,true \tv = reflect.ValueOf(\u0026x7[1]) fmt.Printf(\"x7.1: %v \\tcan be addressable and set: %t, %t\\n\", x7[1], v.CanAddr(), v.CanSet()) //true,true \tvar x8 = [3]int{1, 2, 3} v = reflect.ValueOf(x8[0]) fmt.Printf(\"x8: %v \\tcan be addressable and set: %t, %t\\n\", x8[0], v.CanAddr(), v.CanSet()) //false,false \t// https://groups.google.com/forum/#!topic/golang-nuts/RF9zsX82MWw \tvar x9 = [3]int{1, 2, 3} v = reflect.Indirect(reflect.ValueOf(x9).Index(0)) fmt.Printf(\"x9: %v \\tcan be addressable and set: %t, %t\\n\", x9[0], v.CanAddr(), v.CanSet()) //false,false \tvar x10 = [3]int{1, 2, 3} v = reflect.Indirect(reflect.ValueOf(\u0026x10)).Index(0) fmt.Printf(\"x9: %v \\tcan be addressable and set: %t, %t\\n\", x10[0], v.CanAddr(), v.CanSet()) //true,true \tvar x11 = S{} v = reflect.ValueOf(x11) fmt.Printf(\"x11: %v \\tcan be addressable and set: %t, %t\\n\", x11, v.CanAddr(), v.CanSet()) //false,false \tvar x12 = S{} v = reflect.Indirect(reflect.ValueOf(\u0026x12)) fmt.Printf(\"x12: %v \\tcan be addressable and set: %t, %t\\n\", x12, v.CanAddr(), v.CanSet()) //true,true \tvar x13 = S{} v = reflect.ValueOf(x13).FieldByName(\"X\") fmt.Printf(\"x13: %v \\tcan be addressable and set: %t, %t\\n\", x13, v.CanAddr(), v.CanSet()) //false,false \tvar x14 = S{} v = reflect.Indirect(reflect.ValueOf(\u0026x14)).FieldByName(\"X\") fmt.Printf(\"x14: %v \\tcan be addressable and set: %t, %t\\n\", x14, v.CanAddr(), v.CanSet()) //true,true \tvar x15 = S{} v = reflect.Indirect(reflect.ValueOf(\u0026x15)).FieldByName(\"z\") fmt.Printf(\"x15: %v \\tcan be addressable and set: %t, %t\\n\", x15, v.CanAddr(), v.CanSet()) //true,false \tv = reflect.Indirect(reflect.ValueOf(\u0026S{})) fmt.Printf(\"x15.1: %v \\tcan be addressable and set: %t, %t\\n\", \u0026S{}, v.CanAddr(), v.CanSet()) //true,true \tvar x16 = M v = reflect.ValueOf(x16) fmt.Printf(\"x16: %p \\tcan be addressable and set: %t, %t\\n\", x16, v.CanAddr(), v.CanSet()) //false,false \tvar x17 = M v = reflect.Indirect(reflect.ValueOf(\u0026x17)) fmt.Printf(\"x17: %p \\tcan be addressable and set: %t, %t\\n\", x17, v.CanAddr(), v.CanSet()) //true,true \tvar x18 interface{} = \u0026x11 v = reflect.ValueOf(x18) fmt.Printf(\"x18: %v \\tcan be addressable and set: %t, %t\\n\", x18, v.CanAddr(), v.CanSet()) //false,false \tvar x19 interface{} = \u0026x11 v = reflect.ValueOf(x19).Elem() fmt.Printf(\"x19: %v \\tcan be addressable and set: %t, %t\\n\", x19, v.CanAddr(), v.CanSet()) //true,true \tvar x20 = [...]int{1, 2, 3} v = reflect.ValueOf([...]int{1, 2, 3}) fmt.Printf(\"x20: %v \\tcan be addressable and set: %t, %t\\n\", x20, v.CanAddr(), v.CanSet()) //false,false }   ",
  "wordCount" : "2451",
  "inLanguage": "zh-cn",
  "datePublished": "2018-12-12T20:02:18Z",
  "dateModified": "2018-12-12T20:02:18Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go中的可寻址详解
    </h1>
    <div class="post-meta">December 12, 2018
</div>
  </header> 
  <div class="post-content"><p>Go语言规范中规定了可寻址(addressable)对象的定义,</p>
<p>For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. If the evaluation of x would cause a run-time panic, then the evaluation of &amp;x does too.</p>
<p>对于一个对象x, 如果它的类型为T, 那么&amp;x则会产生一个类型为*T的指针，这个指针指向x, 这是这一段的第一句话，也是我们在开发过程中经常使用的一种获取对象指针的一种方式。</p>
<h1 id="addressable">addressable<a hidden class="anchor" aria-hidden="true" href="#addressable">#</a></h1>
<p>上面规范中的这段话规定， x必须是可寻址的， 也就是说，它只能是以下几种方式：</p>
<ul>
<li>一个变量: &amp;x</li>
<li>指针引用(pointer indirection): &amp;*x</li>
<li>slice索引操作(不管slice是否可寻址): &amp;s[1]</li>
<li>可寻址struct的字段: &amp;point.X</li>
<li>可寻址数组的索引操作: &amp;a[0]</li>
<li>结构体字面值类型literal: &amp;struct{ X int }{1}</li>
</ul>
<p>下列情况x是不可以寻址的，你不能使用&amp;x取得指针：</p>
<ul>
<li>字符串中的字节:</li>
<li>map对象中的元素</li>
<li>接口对象的动态值(通过type assertions获得)</li>
<li>常数</li>
<li>字面值literal(非composite literal)</li>
<li>package 级别的函数</li>
<li>方法method (用作函数值)</li>
</ul>
<ul>
<li>中间值(intermediate value):
<ul>
<li>函数调用</li>
<li>显式类型转换</li>
<li>各种类型的操作 （除了指针引用pointer dereference操作 *x):
<ul>
<li>channel receive operations</li>
<li>sub-string operations</li>
<li>sub-slice operations</li>
<li>加减乘除等运算符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有几个点需要解释下：</p>
<ul>
<li>常数为什么不可以寻址?： 如果可以寻址的话，我们可以通过指针修改常数的值，破坏了常数的定义。</li>
<li>map的元素为什么不可以寻址？:两个原因，如果对象不存在，则返回零值，零值是不可变对象，所以不能寻址，如果对象存在，因为Go中map实现中元素的地址是变化的，这意味着寻址的结果是无意义的。</li>
<li>为什么slice不管是否可寻址，它的元素读是可以寻址的？:因为slice底层实现了一个数组，它是可以寻址的。</li>
<li>为什么字符串中的字符/字节又不能寻址呢：因为字符串是不可变的。</li>
</ul>
<p>规范中还有几处提到了 addressable:</p>
<ul>
<li>调用一个receiver为指针类型的方法时，使用一个addressable的值将自动获取这个值的指针</li>
<li>++、&ndash;语句的操作对象必须是addressable或者是map的index操作</li>
<li>赋值语句=的左边对象必须是addressable,或者是map的index操作，或者是_</li>
<li>上条同样使用for &hellip; range语句</li>
</ul>
<h1 id="reflectvalue的canaddr方法和canset方法">reflect.Value的CanAddr方法和CanSet方法<a hidden class="anchor" aria-hidden="true" href="#reflectvalue的canaddr方法和canset方法">#</a></h1>
<p>在我们使用reflect执行一些底层的操作的时候， 比如编写序列化库、rpc框架开发、编解码、插件开发等业务的时候，经常会使用到reflect.Value的CanSet方法，用来动态的给对象赋值。 CanSet比CanAddr只加了一个限制，就是struct类型的unexported的字段不能Set，所以我们这节主要介绍CanAddr。</p>
<p>并不是任意的reflect.Value的CanAddr方法都返回true,根据它的godoc,我们可以知道：</p>
<p>CanAddr reports whether the value&rsquo;s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.</p>
<p>也就是只有下面的类型reflect.Value的CanAddr才是true, 这样的值是addressable:</p>
<ul>
<li>slice的元素</li>
<li>可寻址数组的元素</li>
<li>可寻址struct的字段</li>
<li>指针引用的结果</li>
</ul>
<p>与规范中规定的addressable, reflect.Value的addressable范围有所缩小， 比如对于栈上分配的变量， 随着方法的生命周期的结束， 栈上的对象也就被回收掉了，这个时候如果获取它们的地址，就会出现不一致的结果，甚至安全问题。</p>
<p>所以如果你想通过reflect.Value对它的值进行更新，应该确保它的CanSet方法返回true,这样才能调用SetXXX进行设置。</p>
<p>使用reflect.Value的时候有时会对func Indirect(v Value) Value和func (v Value) Elem() Value两个方法有些迷惑，有时候他们俩会返回同样的值，有时候又不会。</p>
<p>总结一下：</p>
<ol>
<li>如果reflect.Value是一个指针， 那么v.Elem()等价于reflect.Indirect(v)</li>
<li>如果不是指针
<ol>
<li>如果是interface, 那么reflect.Indirect(v)返回同样的值，而v.Elem()返回接口的动态的值</li>
<li>如果是其它值, v.Elem()会panic,而reflect.Indirect(v)返回原值</li>
</ol>
</li>
</ol>
<p>下面的代码列出一些reflect.Value是否可以addressable, 你需要注意数组和struct字段的情况，也就是x7、x9、x14、x15的正确的处理方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">checkCanAddr</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">S</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span> <span class="kt">int</span>
	<span class="nx">Y</span> <span class="kt">string</span>
	<span class="nx">z</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">M</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">100</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x0</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">func</span> <span class="nf">checkCanAddr</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 可寻址的情况
</span><span class="c1"></span>	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x0</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x0: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x0</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x1</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x1</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x1: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x2</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x1</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x2</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x2: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x3</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x3</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x3: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x3</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x4</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x3</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x4</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x4: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x4</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">// true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x5</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x5</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x5: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x5</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">// false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x6</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x6</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x6: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x6</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x7</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x7</span><span class="p">).</span><span class="nf">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x7: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x7</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x7</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x7.1: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x7</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x8</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x8</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x8: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x8</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="c1">// https://groups.google.com/forum/#!topic/golang-nuts/RF9zsX82MWw
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x9</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x9</span><span class="p">).</span><span class="nf">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x9: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x9</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x10</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x10</span><span class="p">)).</span><span class="nf">Index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x9: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x10</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x11</span> <span class="p">=</span> <span class="nx">S</span><span class="p">{}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x11</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x11: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x11</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x12</span> <span class="p">=</span> <span class="nx">S</span><span class="p">{}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x12</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x12: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x12</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x13</span> <span class="p">=</span> <span class="nx">S</span><span class="p">{}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x13</span><span class="p">).</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;X&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x13: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x13</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x14</span> <span class="p">=</span> <span class="nx">S</span><span class="p">{}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x14</span><span class="p">)).</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;X&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x14: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x14</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x15</span> <span class="p">=</span> <span class="nx">S</span><span class="p">{}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x15</span><span class="p">)).</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;z&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x15: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x15</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,false
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">S</span><span class="p">{}))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x15.1: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">S</span><span class="p">{},</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x16</span> <span class="p">=</span> <span class="nx">M</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x16</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x16: %p \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x16</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x17</span> <span class="p">=</span> <span class="nx">M</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Indirect</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x17</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x17: %p \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x17</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x18</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x11</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x18</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x18: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x18</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x19</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x11</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x19</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x19: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x19</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//true,true
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">x20</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">([</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x20: %v \tcan be addressable and set: %t, %t\n&#34;</span><span class="p">,</span> <span class="nx">x20</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanAddr</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span> <span class="c1">//false,false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
