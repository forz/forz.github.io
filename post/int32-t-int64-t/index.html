<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>int32_t,int64_t | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较： 16位">
<meta name="author" content="">
<link rel="canonical" href="/post/int32-t-int64-t/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="int32_t,int64_t" />
<meta property="og:description" content="数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较： 16位" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/int32-t-int64-t/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-23T20:27:13&#43;00:00" />
<meta property="article:modified_time" content="2019-09-29T20:52:47&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="int32_t,int64_t"/>
<meta name="twitter:description" content="数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较： 16位"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "int32_t,int64_t",
      "item": "/post/int32-t-int64-t/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "int32_t,int64_t",
  "name": "int32_t,int64_t",
  "description": "数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较： 16位",
  "keywords": [
    
  ],
  "articleBody": "数据类型 数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较：\n16位平台\nchar 1个字节8位 short 2个字节16位 int 2个字节16位 long 4个字节32位 指针 2个字节  32位平台\nchar 1个字节8位 short 2个字节16位 int 4个字节32位 long 4个字节 long long 8个字节 指针 4个字节  64位平台\nchar 1个字节 short 2个字节 int 4个字节 long 8个字节（区别） long long 8个字节 指针 8个字节（区别）  固定大小的数据类型 为了保证平台的通用性，程序中尽量不要使用long数据库型。可以使用固定大小的数据类型宏定义：\ntypedef signed char int8_t typedef short int int16_t; typedef int int32_t; # if __WORDSIZE == 64 typedef long int int64_t; # else __extension__ typedef long long int int64_t; #endif  使用int时也可以使用intptr_t来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台长度，比如64位机器它的长度就是8字节，32位机器它的长度是4字节，定义如下：\n1 2 3 4 5  #if __WORDSIZE == 64 typedef long int intptr_t; #else typedef int intptr_t; #endif   编程中要尽量使用sizeof来计算数据类型的大小\n以上类型定义都有相应的无符号类型。\n另外还有ssize_t和size_t分别是sign size_t和unsigned signed size of computer word size。它们也是表示计算机的字长，在32位机器上是int型，在64位机器上long型，从某种意义上来说它们等同于intptr_t和 uintptr_t。它们在stddef.h里面定义。需要注意的是socket的accept函数在有些操作系统上使用size_t是不正确的，因为 accept接收的int*类型，而size_t可能是long int 类型。后来BSD使用sock_t来替代它。\nC/C++的64位整型 在C/C++中，64为整型一直是一种没有确定规范的数据类型。现今主流的编译器中，对64为整型的支持也是标准不一，形态各异。一般来说，64位整型的定义方式有long long和__int64两种(VC还支持_int64)，而输出到标准输出方式有printf(“%lld”,a)，printf(“%I64d”,a)，和cout « a三种方式。\n本文讨论的是五种常用的C/C++编译器对64位整型的支持，这五种编译器分别是gcc(mingw32)，g++(mingw32)，gcc(Linux i386)，g++(linux i386)，Microsoft Visual C++ 6.0。可惜的是，没有一种定义和输出方式组合，同时兼容这五种编译器。为彻底弄清不同编译器对64位整型，我写了程序对它们进行了评测，结果如下表。\n上表中，正确指编译通过，运行完全正确；错误指编译虽然通过，但运行结果有误；无法编译指编译器根本不能编译完成。观察上表，我们可以发现以下几点：\nlong long定义方式可以用于gcc/g++，不受平台限制，但不能用于VC6.0。\n__int64是Win32平台编译器64位长整型的定义方式，不能用于Linux。\n“%lld”用于Linux i386平台编译器，”%I64d”用于Win32平台编译器。\ncout只能用于C++编译，在VC6.0中，cout不支持64位长整型。\n如果服务器是linux系统，那么定义用long long，IO用%lld 如果服务器是win系统，那么声明要针对编译器而定：\n  如果用MS系列编译器，声明用__int64 [现在新版的Visual Studio也支持long long了]\n  如果用MinGW环境，声明用long long\n  无论什么编译器，IO一律%I64d\n  参考：http://blog.csdn.net/hongxdong/article/details/5559312\n",
  "wordCount" : "1455",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-23T20:27:13Z",
  "dateModified": "2019-09-29T20:52:47+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/int32-t-int64-t/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      int32_t,int64_t
    </h1>
    <div class="post-meta">June 23, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="数据类型">数据类型<a hidden class="anchor" aria-hidden="true" href="#数据类型">#</a></h1>
<p>数据类型特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较：</p>
<p>16位平台</p>
<pre><code>char         1个字节8位
short        2个字节16位
int            2个字节16位
long         4个字节32位
指针         2个字节
</code></pre>
<p>32位平台</p>
<pre><code>char         1个字节8位
short        2个字节16位
int            4个字节32位
long         4个字节
long long 8个字节
指针         4个字节
</code></pre>
<p>64位平台</p>
<pre><code>char         1个字节
short        2个字节
int            4个字节
long         8个字节（区别）
long long 8个字节
指针        8个字节（区别）
</code></pre>
<h1 id="固定大小的数据类型">固定大小的数据类型<a hidden class="anchor" aria-hidden="true" href="#固定大小的数据类型">#</a></h1>
<p>为了保证平台的通用性，程序中尽量不要使用long数据库型。可以使用固定大小的数据类型宏定义：</p>
<pre><code>typedef signed char       int8_t

typedef short int         int16_t;

typedef int               int32_t;

# if __WORDSIZE == 64
typedef long int          int64_t;
# else
__extension__
typedef long long int     int64_t;

#endif
</code></pre>
<p>使用int时也可以使用intptr_t来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台长度，比如64位机器它的长度就是8字节，32位机器它的长度是4字节，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#if __WORDSIZE == 64
</span><span class="cp"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">int</span>                <span class="n">intptr_t</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span><span class="k">typedef</span> <span class="kt">int</span>                        <span class="n">intptr_t</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div><p>编程中要尽量使用sizeof来计算数据类型的大小</p>
<p>以上类型定义都有相应的无符号类型。</p>
<p>另外还有ssize_t和size_t分别是sign size_t和unsigned signed size of computer word size。它们也是表示计算机的字长，在32位机器上是int型，在64位机器上long型，从某种意义上来说它们等同于intptr_t和 uintptr_t。它们在stddef.h里面定义。需要注意的是socket的accept函数在有些操作系统上使用size_t是不正确的，因为 accept接收的int*类型，而size_t可能是long int 类型。后来BSD使用sock_t来替代它。</p>
<h1 id="cc的64位整型">C/C++的64位整型<a hidden class="anchor" aria-hidden="true" href="#cc的64位整型">#</a></h1>
<p>在C/C++中，64为整型一直是一种没有确定规范的数据类型。现今主流的编译器中，对64为整型的支持也是标准不一，形态各异。一般来说，64位整型的定义方式有long long和__int64两种(VC还支持_int64)，而输出到标准输出方式有printf(“%lld”,a)，printf(“%I64d”,a)，和cout &laquo; a三种方式。</p>
<p>本文讨论的是五种常用的C/C++编译器对64位整型的支持，这五种编译器分别是gcc(mingw32)，g++(mingw32)，gcc(Linux i386)，g++(linux i386)，Microsoft Visual C++ 6.0。可惜的是，没有一种定义和输出方式组合，同时兼容这五种编译器。为彻底弄清不同编译器对64位整型，我写了程序对它们进行了评测，结果如下表。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170427144752.png" alt=""  />
</p>
<p>上表中，正确指编译通过，运行完全正确；错误指编译虽然通过，但运行结果有误；无法编译指编译器根本不能编译完成。观察上表，我们可以发现以下几点：</p>
<p>long long定义方式可以用于gcc/g++，不受平台限制，但不能用于VC6.0。</p>
<p>__int64是Win32平台编译器64位长整型的定义方式，不能用于Linux。</p>
<p>“%lld”用于Linux i386平台编译器，”%I64d”用于Win32平台编译器。</p>
<p>cout只能用于C++编译，在VC6.0中，cout不支持64位长整型。</p>
<p>如果服务器是linux系统，那么定义用long long，IO用%lld
如果服务器是win系统，那么声明要针对编译器而定：</p>
<ol>
<li>
<p>如果用MS系列编译器，声明用__int64 [现在新版的Visual Studio也支持long long了]</p>
</li>
<li>
<p>如果用MinGW环境，声明用long long</p>
</li>
<li>
<p>无论什么编译器，IO一律%I64d</p>
</li>
</ol>
<p>参考：<a href="">http://blog.csdn.net/hongxdong/article/details/5559312</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
