<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>最长子串/子序列 | Forz Blog</title>
<meta name="keywords" content="Two Pointers" />
<meta name="description" content="LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="最长子串/子序列" />
<meta property="og:description" content="LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:28:32&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T02:28:32&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="最长子串/子序列"/>
<meta name="twitter:description" content="LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "最长子串/子序列",
      "item": "/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "最长子串/子序列",
  "name": "最长子串\/子序列",
  "description": "LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (\u0026lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting",
  "keywords": [
    "Two Pointers"
  ],
  "articleBody": "LeetCode 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t.\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).\nExample 1: s = \"abc\", t = \"ahbgdc\" Return true. Example 2: s = \"axc\", t = \"ahbgdc\" Return false.  Follow up:\nIf there are lots of incoming S, say S1, S2, … , Sk where k = 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\n解析：\n判断字符串s是否为t的子序列。双指针分别代表两个字符串即可。\n1 2 3 4 5 6 7 8  class Solution { public: bool isSubsequence(string s, string t) { auto i = s.begin(); for(char c : t) i += (*i == c); return i == s.end(); } };   LeetCode 485. Max Consecutive Ones Given a binary array, find the maximum number of consecutive 1s in this array.\nExample 1:\nInput: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\nThe maximum number of consecutive 1s is 3.\nNote:\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000\n解析：求连续1的最大长度，设一个sum变量，碰到1就递增，碰到0清空，可以用一个数学算式来表示\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int findMaxConsecutiveOnes(vectorint\u0026 nums) { int max = 0; int sum = 0; for (int i=0; inums.size(); i++) { sum = (sum+nums[i])*nums[i]; if(maxsum){max=sum;} } return max; } };   LeetCode 128. Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nFor example,\nGiven [100, 4, 200, 1, 3, 2],\nThe longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.\nYour algorithm should run in O(n) complexity.\n解析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public: int longestConsecutive(const vectorint \u0026num) { unordered_mapint, bool used; for (auto i : num) used[i] = false;//初始化  int longest = 0; for (auto i : num) { if (used[i]) continue;//之前访问过，直接跳过  int length = 1; used[i] = true; for (int j = i + 1; used.find(j) != used.end(); ++j) {//向右扩张  used[j] = true; ++length; } for (int j = i - 1; used.find(j) != used.end(); --j) {//向左扩张  used[j] = true; ++length; } longest = max(longest, length);//更新结果  } return longest; } };   LeetCode 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters.\nExamples:\nGiven “abcabcbb”, the answer is “abc”, which the length is 3.\nGiven “bbbbb”, the answer is “b”, with the length of 1.\nGiven “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.\n解析：\n双指针记录窗口的左右边界，枚举左边界，扩大右边界，利用hash表判断是否重复，只要右端扫描到重复字符，就需要一直移动左端直到该重复字符消失。\n有一种优化方法，直接用hash表记录字符上一次出现的位置，可以让左端消除重复更快，这需要让hash表全部初始化为-1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int lengthOfLongestSubstring(string s) { //题意为求不包含重复字符的最长子串(不能断开)  // left用以记录合法的最远左边界位置，last记录字符上一次出现的位置（双指针滑动窗口）  int ans = 0, left = 0, len = s.length(); int last[255];//hash表  memset(last, -1, sizeof(last)); for (int i = 0; i  len; i++) {//一次扫描字符串s  if (last[s[i]] = left) //上次出现位置在当前记录边界之后，即该子串中出现了重复字符，需调整left使得子串合法  left = last[s[i]] + 1; last[s[i]] = i; ans = max(ans, i - left + 1);//长度  } return ans; } };   LeetCode 395. Longest Substring with At Least K Repeating Characters Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\nExample 1:\nInput:\ns = “aaabb”, k = 3\nOutput:\n3\nThe longest substring is “aaa”, as ‘a’ is repeated 3 times.\nExample 2:\nInput:\ns = “ababbc”, k = 2\nOutput:\n5\nThe longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.\n解析：\n这题如果逐一查找的话，因为有很多间隔，所以双指针操作起来不太方便，这题最方便的做法就是递归了。碰到遍历可以处理但是很麻烦的情况下，递归是最好的选择。\n建立一个哈希表来统计每个字母出现的次数，对于出现次数少于K次的，我们把它们当做间隔，从而把原数列分为几段，要找的满足重复的最长的子序列一定在这几段其中。对于分开的每段，又是一个同样性质的子问题。如果一段中没有小于K的间隔，那么直接返回这一段的长度，更新最大长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: int longestSubstring(string s, int k) { return longestSubstring_recur(s, k, 0, s.size()); } int longestSubstring_recur(const string\u0026 s, int k, int first, int last) { int count[26] = {0};//哈希表，保存每个字符出现次数 for (int i = first; i  last; ++i) ++count[s[i] - 'a'];//预处理 int max_len = 0; for (int l = first; l  last;) {//枚举左边界  while (l  last \u0026\u0026 count[s[l]-'a']k) ++l;//如果字符出现次数小于k，直接跳过  if (l == last) break;//在上一个语句中l++，可能直接到达last，需要及时判断  int r = l;//右边界  while (r  last \u0026\u0026 count[s[r]-'a']=k) ++r;//右边界增加  if (l == first \u0026\u0026 r == last) return last-first; //子字符串就是该字符串本身，直接返回，不需要继续dfs  max_len = max(max_len, longestSubstring_recur(s, k, l, r));//维护结果  l= r;//左边界更新为右边界的下一位，继续循环找下一个符合的子字符串 } return max_len; } };   最小包含子串的长度 题目:\n给定字符串strl和str2，求strl的子串中含有str2所有字符的最小子串长度。\n举例:\nstr1=“abcde”, str2=“ac”。因为\"abc\"包含str2的所有字符，并且在满足这一条件的str1的所有子串中，“abc\"是最短的，返回3。\nstr1=“12345”, str2=“344”。最小包含子串不存在，返回0。\n解析:\n时间复杂度为O(N)的解法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public static int minLength(String str1, String str2) { if (str1 == null || str2 == null || str1.length()  str2.length()) { return 0; } char[] chas1 = str1.toCharArray(); char[] chas2 = str2.toCharArray(); int[] map = new int[256]; for (int i = 0; i != chas2.length; i++) { map[chas2[i]]++; } int left = 0; int right = 0; int match = chas2.length; int minLen = Integer.MAX_VALUE; while (right != chas1.length) { map[chas1[right]]--; if (map[chas1[right]] = 0) { match--; } if (match == 0) { while (map[chas1[left]]  0) { map[chas1[left++]]++; } minLen = Math.min(minLen, right - left + 1); match++; map[chas1[left++]]++; } right++; } return minLen == Integer.MAX_VALUE ? 0 : minLen; }   ",
  "wordCount" : "2054",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T02:28:32Z",
  "dateModified": "2017-06-25T02:28:32Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      最长子串/子序列
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-392-is-subsequence">LeetCode 392. Is Subsequence<a hidden class="anchor" aria-hidden="true" href="#leetcode-392-is-subsequence">#</a></h1>
<p>Given a string s and a string t, check if s is subsequence of t.</p>
<p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).</p>
<pre><code>Example 1:
s = &quot;abc&quot;, t = &quot;ahbgdc&quot;

Return true.

Example 2:
s = &quot;axc&quot;, t = &quot;ahbgdc&quot;

Return false.
</code></pre>
<p>Follow up:</p>
<p>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>
<p>解析：</p>
<p>判断字符串s是否为t的子序列。双指针分别代表两个字符串即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">isSubsequence</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">t</span><span class="p">)</span> <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">==</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-485-max-consecutive-ones">LeetCode 485. Max Consecutive Ones<a hidden class="anchor" aria-hidden="true" href="#leetcode-485-max-consecutive-ones">#</a></h1>
<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Example 1:</p>
<p>Input: [1,1,0,1,1,1]</p>
<p>Output: 3</p>
<p>Explanation: The first two digits or the last three digits are consecutive 1s.</p>
<p>The maximum number of consecutive 1s is 3.</p>
<p>Note:</p>
<p>The input array will only contain 0 and 1.</p>
<p>The length of input array is a positive integer and will not exceed 10,000</p>
<p>解析：求连续1的最大长度，设一个sum变量，碰到1就递增，碰到0清空，可以用一个数学算式来表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">findMaxConsecutiveOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">max</span><span class="o">&lt;</span><span class="n">sum</span><span class="p">){</span><span class="n">max</span><span class="o">=</span><span class="n">sum</span><span class="p">;}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-128-longest-consecutive-sequence">LeetCode 128. Longest Consecutive Sequence<a hidden class="anchor" aria-hidden="true" href="#leetcode-128-longest-consecutive-sequence">#</a></h1>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,</p>
<p>Given [100, 4, 200, 1, 3, 2],</p>
<p>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>解析：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170823-223703@2x.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">longestConsecutive</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">used</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">num</span><span class="p">)</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//初始化
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span><span class="c1">//之前访问过，直接跳过
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">used</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="n">used</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="c1">//向右扩张
</span><span class="c1"></span>            <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="o">++</span><span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">used</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="n">used</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="c1">//向左扩张
</span><span class="c1"></span>            <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="o">++</span><span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span><span class="c1">//更新结果
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">longest</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-3-longest-substring-without-repeating-characters">LeetCode 3. Longest Substring Without Repeating Characters<a hidden class="anchor" aria-hidden="true" href="#leetcode-3-longest-substring-without-repeating-characters">#</a></h1>
<p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<p>解析：</p>
<p>双指针记录窗口的左右边界，枚举左边界，扩大右边界，利用hash表判断是否重复，只要右端扫描到重复字符，就需要一直移动左端直到该重复字符消失。</p>
<p>有一种优化方法，直接用hash表记录字符上一次出现的位置，可以让左端消除重复更快，这需要让hash表全部初始化为-1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//题意为求不包含重复字符的最长子串(不能断开)
</span><span class="c1"></span>    <span class="c1">// left用以记录合法的最远左边界位置，last记录字符上一次出现的位置（双指针滑动窗口）
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">last</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span><span class="c1">//hash表
</span><span class="c1"></span>    <span class="n">memset</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">last</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//一次扫描字符串s
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">)</span>
<span class="c1">//上次出现位置在当前记录边界之后，即该子串中出现了重复字符，需调整left使得子串合法
</span><span class="c1"></span>            <span class="n">left</span> <span class="o">=</span> <span class="n">last</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">last</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//长度
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-395-longest-substring-with-at-least-k-repeating-characters">LeetCode 395. Longest Substring with At Least K Repeating Characters<a hidden class="anchor" aria-hidden="true" href="#leetcode-395-longest-substring-with-at-least-k-repeating-characters">#</a></h1>
<p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>
<p>Example 1:</p>
<p>Input:</p>
<p>s = &ldquo;aaabb&rdquo;, k = 3</p>
<p>Output:</p>
<p>3</p>
<p>The longest substring is &ldquo;aaa&rdquo;, as &lsquo;a&rsquo; is repeated 3 times.</p>
<p>Example 2:</p>
<p>Input:</p>
<p>s = &ldquo;ababbc&rdquo;, k = 2</p>
<p>Output:</p>
<p>5</p>
<p>The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.</p>
<p>解析：</p>
<p>这题如果逐一查找的话，因为有很多间隔，所以双指针操作起来不太方便，这题最方便的做法就是递归了。碰到遍历可以处理但是很麻烦的情况下，递归是最好的选择。</p>
<p>建立一个哈希表来统计每个字母出现的次数，对于出现次数少于K次的，我们把它们当做间隔，从而把原数列分为几段，要找的满足重复的最长的子序列一定在这几段其中。对于分开的每段，又是一个同样性质的子问题。如果一段中没有小于K的间隔，那么直接返回这一段的长度，更新最大长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">longestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">longestSubstring_recur</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">longestSubstring_recur</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="c1">//哈希表，保存每个字符出现次数
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">];</span><span class="c1">//预处理
</span><span class="c1"></span><span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;)</span> <span class="p">{</span><span class="c1">//枚举左边界
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="n">k</span><span class="p">)</span> <span class="o">++</span><span class="n">l</span><span class="p">;</span><span class="c1">//如果字符出现次数小于k，直接跳过
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span><span class="c1">//在上一个语句中l++，可能直接到达last，需要及时判断
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span><span class="c1">//右边界
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">)</span> <span class="o">++</span><span class="n">r</span><span class="p">;</span><span class="c1">//右边界增加
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">last</span><span class="o">-</span><span class="n">first</span><span class="p">;</span> <span class="c1">//子字符串就是该字符串本身，直接返回，不需要继续dfs
</span><span class="c1"></span>    <span class="n">max_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">longestSubstring_recur</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span><span class="c1">//维护结果
</span><span class="c1"></span>    <span class="n">l</span><span class="o">=</span> <span class="n">r</span><span class="p">;</span><span class="c1">//左边界更新为右边界的下一位，继续循环找下一个符合的子字符串
</span><span class="c1"></span><span class="p">}</span>
<span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="最小包含子串的长度">最小包含子串的长度<a hidden class="anchor" aria-hidden="true" href="#最小包含子串的长度">#</a></h1>
<p>题目:</p>
<p>给定字符串strl和str2，求strl的子串中含有str2所有字符的最小子串长度。</p>
<p>举例:</p>
<p>str1=&ldquo;abcde&rdquo;, str2=&ldquo;ac&rdquo;。因为&quot;abc&quot;包含str2的所有字符，并且在满足这一条件的str1的所有子串中，&ldquo;abc&quot;是最短的，返回3。</p>
<p>str1=&ldquo;12345&rdquo;, str2=&ldquo;344&rdquo;。最小包含子串不存在，返回0。</p>
<p>解析:</p>
<p>时间复杂度为O(N)的解法如下</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-015817@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-021616@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-020221@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-021807@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-020254@2x.png" alt=""  />

<img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170827-021903@2x.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minLength</span><span class="o">(</span><span class="n">String</span> <span class="n">str1</span><span class="o">,</span> <span class="n">String</span> <span class="n">str2</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">str2</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">0</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">char</span><span class="o">[]</span> <span class="n">chas1</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
		<span class="kt">char</span><span class="o">[]</span> <span class="n">chas2</span> <span class="o">=</span> <span class="n">str2</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">256</span><span class="o">];</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">chas2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">map</span><span class="o">[</span><span class="n">chas2</span><span class="o">[</span><span class="n">i</span><span class="o">]]++;</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="n">chas2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">!=</span> <span class="n">chas1</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">map</span><span class="o">[</span><span class="n">chas1</span><span class="o">[</span><span class="n">right</span><span class="o">]]--;</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">chas1</span><span class="o">[</span><span class="n">right</span><span class="o">]]</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">match</span><span class="o">--;</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">match</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">while</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">chas1</span><span class="o">[</span><span class="n">left</span><span class="o">]]</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">map</span><span class="o">[</span><span class="n">chas1</span><span class="o">[</span><span class="n">left</span><span class="o">++]]++;</span>
				<span class="o">}</span>
				<span class="n">minLen</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
				<span class="n">match</span><span class="o">++;</span>
				<span class="n">map</span><span class="o">[</span><span class="n">chas1</span><span class="o">[</span><span class="n">left</span><span class="o">++]]++;</span>
			<span class="o">}</span>
			<span class="n">right</span><span class="o">++;</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">minLen</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">minLen</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/two-pointers/">Two Pointers</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
