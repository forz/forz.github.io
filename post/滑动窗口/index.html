<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>滑动窗口 | Forz Blog</title>
<meta name="keywords" content="DFS, 滑动窗口" />
<meta name="description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="滑动窗口" />
<meta property="og:description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:21:40&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T02:21:40&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="滑动窗口"/>
<meta name="twitter:description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "滑动窗口",
      "item": "/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "滑动窗口",
  "name": "滑动窗口",
  "description": "LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指",
  "keywords": [
    "DFS", "滑动窗口"
  ],
  "articleBody": "LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.\nFor example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint.\n解析：用双指针维护一个窗口，枚举窗口右端，记录此时窗口和，如果当前窗口和大于等于s，维护结果。然后收缩窗口左端。直到右端枚举结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public: int minSubArrayLen(int s, vectorint\u0026 nums) { int n = nums.size(), start = 0, sum = 0, minlen = INT_MAX; for (int i = 0; i  n; i++) { sum += nums[i]; while (sum = s) { minlen = min(minlen, i - start + 1); sum -= nums[start++]; } } return minlen == INT_MAX ? 0 : minlen; } };   LeetCode 239. Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nFor example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.\nWindow position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7  Therefore, return the max sliding window as [3,3,5,5,6,7].\nNote:\nYou may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.\n解析：\n此题用单调队列来维护单调递减序列，单调队列的长度就是k,枚举窗口右边界,因为已经规定了窗口的大小，所以左边界固定为i-k+1.为了方便维护动态窗口,可以直接保存元素的下标,而不是元素的值.\n队首就是该窗口的最大值。因为要维护一个窗口，需要经常把队首队尾弹出，所以采用双端队列deque.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution {//单调队列 public: vectorint maxSlidingWindow(vectorint\u0026 nums, int k) { dequeint dq; vectorint ans; for (int i=0; inums.size(); i++) {//枚举窗口右边界  if (!dq.empty() \u0026\u0026 dq.front() == i-k) dq.pop_front();//维护单调队列，把窗口外的元素删除。  while (!dq.empty() \u0026\u0026 nums[dq.back()]  nums[i]) dq.pop_back();//维护递减区间，将小于nums[i]的元素全部弹出  dq.push_back(i);//放入序号  if (i=k-1) ans.push_back(nums[dq.front()]);//已经构成窗口，将单调队列的队首添加到结果中  } return ans; } };   LeetCode 424. Longest Repeating Character Replacement Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\nNote:\nBoth the string’s length and k will not exceed 104.\nExample 1:\nInput: s = “ABAB”, k = 2\nOutput: 4 Explanation:\nReplace the two ‘A’s with two ‘B’s or vice versa.\nExample 2:\nInput: s = “AABABBA”, k = 1\nOutput: 4 Explanation:\nReplace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”.\nThe substring “BBBB” has the longest repeating letters, which is 4.\n解析：\n题目的意思比较清楚，不过可能的情况有很多，不可能用代码去寻找最佳的替换位置，所以这里采用一种滑动窗口的方法。\n定义start和end两个标记，中间的内容即是窗口，计算窗口内所有字母出现的次数，因为全是大写字母，所以可以用一个26位的数组来记录窗口内每个字母出现的次数。为了减少时间复杂度，我们不去每次都遍历窗口来计算出现的字母次数，而是在移动end或者start时，将对应位置的字母的次数加一或者减一。\n找到窗口内出现最多的次数，加上允许替换的字母数k，看是否超过窗口宽度，如果超过了，说明窗口还可以更长， 也就是说窗口内重复的字母的长度可以更长，就将end右移一位，形成新的窗口，然后继续重复上面的步骤。如果没超过，说明能构成的最长的重复字母长度已经到顶了，这时应该将start右移一位，来寻找新的可能的更长重复字母长度。\n每次计算重复字母长度时，当出现更长的可能时，都更新最终的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int characterReplacement(string s, int k) { int len = s.length(); int count[26] ={0}; int start = 0, maxCount = 0, maxLength = 0; for (int end = 0; end  len; end++) { maxCount = max(maxCount, ++count[s[end] - 'A']); while (end - start + 1 - maxCount  k) { count[s[start] - 'A']--; start++; } maxLength = max(maxLength, end - start + 1); } return maxLength; } };   LeetCode 480. Sliding Window Median Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nExamples:\n[2,3,4] , the median is 3\n[2,3], the median is (2 + 3) / 2 = 2.5\nGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\nWindow position Median --------------- ----- [1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6  Therefore, return the median sliding window as [1,-1,-1,3,5,6].\nNote:\nYou may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.\n解析：\n直接在窗口中使用multiset，因为只要窗口内数组已排序，那么中位数很好求，而且有重复元素出现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: vectordouble medianSlidingWindow(vectorint\u0026 nums, int k) { multisetint window(nums.begin(), nums.begin() + k);//先放满窗口 auto mid = next(window.begin(), k / 2);//mltiset不支持随机访问 vectordouble medians; for (int i=k; ; i++) { medians.push_back((double(*mid) + *prev(mid, 1 - k%2)) / 2);//放入中位数  if (i == nums.size())//扫描结束  return medians; //维护加入num[i]后的窗口信息  window.insert(nums[i]);//右边界扩张  if (nums[i]  *mid) mid--; if (nums[i-k]  *mid)//左边界收缩  mid++; window.erase(window.lower_bound(nums[i-k]));//删掉num[i-k]对应的set迭代器 } } };   LeetCode 76. Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\nFor example, S = “ADOBECODEBANC”. T = “ABC”.\nMinimum window is “BANC”.\nNote: If there is no such window in S that covers all characters in T, return the empty string “”.\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\n解析：\n利用哈希表保存t中的所有字符，然后双指针维护窗口。\n哈希表map是t和s中窗口共用的，有2点作用：\n保存模板串中字符的出现情况（包括个数）。 若map[i]大于0，则模板串比窗口多，若map[i]小于0，则模板串比窗口少，若等于0，证明两者相同。 使用count记录剩余“有效”字符数，当count达到0时，即可说明[begin,end]包含了T。此时可以进行窗口的维护。\n在保证[begin,end]窗口包含T中所有字符的条件下，延伸end，收缩begin。进行一次扫描后，记录符合条件的最小窗口(end-begin+1)表示的字符串。\n注意：“有效”的意思是指，当前延伸得到的S[end]字符，使得[begin,end]更进一步包含T，而不是重复劳动。\n比如说，T=”a”, [begin,end]已经包含”a”,再延伸得到”aa”，只是无效操作，并没有使得[begin,end]更接近T,有效字符数仍为1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: string minWindow(string s, string t) { vectorint map(128,0); for(auto c: t) map[c]++;//哈希表  int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(ends.size()){//保证头部不越界  if(map[s[end++]]--0) counter--; //如果该元素在t中存在,counter--,  //end和map无论什么情况都会改变（无效字符的map会变成负数，只有有效字符会变成0）  while(counter==0){ //完全包含时可以求出结果，并收缩左端边界，使其不完全包含。  if(end-begind) d=end-(head=begin);//更新最优结果的起始位置  if(map[s[begin++]]++==0) counter++; //收缩begin，因为之前所有字符都自减过，所以只有有效字符才能是0，此时counter++  } } return d==INT_MAX? \"\":s.substr(head, d); } };   注意：先执行当前操作，再进行后置运算：\nint i=0,j=1; if((i++==1)\u0026\u0026(j++))  看\u0026\u0026左右两边，左边可简化为i==1; i++;因为i=0，所以左边表达式为假，就不执行右边的表达式，此时i = 1， j = 1\nLeetCode 30. Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\nFor example, given: s: “barfoothefoobarman”.\nwords: [“foo”, “bar”].\nYou should return the indices: [0,9]. (order does not matter).\n解析：\n假设字符串S的长度为n，单词列表L中单词的长度为l。因为不是一个字符，所以需要对字符串S所有长度为l的子串进行判断。\n做法是i从0到l-1个字符开始，得到开始index分别为i, i+l, i+2*l, …的长度为l的单词。这样就可以保证判断到所有的满足条件的子串。\ncnt为模板串计数器，count为原串计数器，如果两者相等，说明该窗口匹配成功\ndict和tdict分别为模板和窗口的哈希表。根据这2个哈希表判断窗口是否收缩。\n因为每次扫描的时间复杂度是O(2n/l)（每个单词不会被访问多于两次，一次是窗口右端，一次是窗口左端），总共扫描l次（i=0, …, l-1)，所以总复杂度是O(2n/ll)=O(n)，是一个线性算法。空间复杂度是单词列表的大小，即O(cntl)其中cnt是单词列表的单词数量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Solution { public: vectorint findSubstring(string S, vectorstring \u0026L) { vectorint ans; int n = S.size(), cnt = L.size(); if (n  0 || cnt  0) return ans; unordered_mapstring, int dict; for (int i = 0; i  cnt; ++i) dict[L[i]]++;//构造模板哈希表（以字符串为单位）  int wl = L[0].size();//所有单词长度相等  for (int i = 0; i  wl; ++i) {//滑动窗口的初始起点0~wl-1，保证答案全部覆盖，之后收缩左端不靠这个  int left = i, count = 0; unordered_mapstring, int tdict;//当前哈希表  for (int j = i; j  n - wl; j += wl) {//右端每次递增wl  string str = S.substr(j, wl);//剪切出当前长度为wl的单词，进行比较  if (dict.count(str)) {//符合t中单词,右端可以扩张，维护count和哈希表和左端  tdict[str]++;//维护窗口哈希表  if (tdict[str]  dict[str]) //如果当前哈希表中单词数没比模板单词数大，还没到需要维护窗口的时候，继续进行  count++; else {//如果比模板的单词数大，说明窗口左端需要收缩才能继续右端口扩张  while (tdict[str]  dict[str]) {//只要没有解除右端单词数多的情况，就要不断收缩左端  string str1 = S.substr(left, wl);//左端的单词  tdict[str1]--;//收缩左端  if (tdict[str1]  dict[str1]) count--;//若左端单词是非冗余单词，count--  left += wl;//左端收缩  } } if (count == cnt) {//满足条件，更新结果  ans.push_back(left);//答案（符合该要求的所有子串的左端）  tdict[S.substr(left, wl)]--;//左端右移一个单位长度  count--;//因为窗口内的字符串肯定全是模板串集合中的某个，所以必定减少count的值  left += wl; } } else {//如果当前单词不是t中单词，右端无法右移（要保证滑动窗口字符串是连续有效的）  tdict.clear();//重新哈希  count = 0; left = j + wl;//左端右移（以当前的左端来说是不可能完成答案了）  } } } return ans; } };   最大值减去最小值小于或等于num的子数组数量 题目:\n给定数组arr和整数num,共返回有多少个子数组满足如下情况：\nmax(arr[i..j]) - min(arr[i..j])  max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。\n如果数组长度为N,请实现时间复杂度为O(N)的解法。\n解析:\n首先介绍普通的解法，找到arr的所有子数组，一共有N^2个，然后对每一个子数组做遍历找到其中的最小值和最大值，这个过程时间复杂度为O(N)的，然后看看这个子数组是 否满足条件。统计所有满足的子数组数量即可。普通解法容易实现，但是时间复杂度为 O(n^3)，最优解可以做到时间复杂度O(n),额外空间复杂度O(n).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  LinkedListInteger qmin = new LinkedListInteger(); LinkedListInteger qmax = new LinkedListInteger(); int i = 0; int j = 0; int res = 0; while (i  arr.length) { while (j  arr.length) { while (!qmin.isEmpty() \u0026\u0026 arr[qmin.peekLast()] = arr[j]) { qmin.pollLast(); } qmin.addLast(j); while (!qmax.isEmpty() \u0026\u0026 arr[qmax.peekLast()]  arr[j]) { qmax.pollLast(); } qmax.addLast(j); if (arr [qmax.getFirst()] - arr [qmin.getFirst () ]  num) { break; } j++; } //为下一次循环做准备,先把i元素弹出队列  if (qmin.peekFirst() == i) {//  qmin.pollFirst(); } if (qmax.peekFirst() == i) { qmax.pollFirst(); } res += j - i; i++; } return res;   ",
  "wordCount" : "4394",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T02:21:40Z",
  "dateModified": "2017-06-25T02:21:40Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      滑动窗口
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-209-minimum-size-subarray-sum">LeetCode 209. Minimum Size Subarray Sum<a hidden class="anchor" aria-hidden="true" href="#leetcode-209-minimum-size-subarray-sum">#</a></h1>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,   <br>
the subarray [4,3] has the minimal length under the problem constraint.</p>
<p>解析：用双指针维护一个窗口，枚举窗口右端，记录此时窗口和，如果当前窗口和大于等于s，维护结果。然后收缩窗口左端。直到右端枚举结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">minSubArrayLen</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">minlen</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
        <span class="k">while</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">minlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">minlen</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">minlen</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-239-sliding-window-maximum">LeetCode 239. Sliding Window Maximum<a hidden class="anchor" aria-hidden="true" href="#leetcode-239-sliding-window-maximum">#</a></h1>
<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example, <br>
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<pre><code>Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p>Note:</p>
<p>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p>解析：</p>
<p>此题用单调队列来维护单调递减序列，单调队列的长度就是k,枚举窗口右边界,因为已经规定了窗口的大小，所以左边界固定为i-k+1.为了方便维护动态窗口,可以直接保存元素的下标,而不是元素的值.</p>
<p>队首就是该窗口的最大值。因为要维护一个窗口，需要经常把队首队尾弹出，所以采用双端队列deque.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span><span class="c1">//单调队列
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maxSlidingWindow</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dq</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举窗口右边界
</span><span class="c1"></span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="n">dq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span><span class="c1">//维护单调队列，把窗口外的元素删除。
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">dq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="c1">//维护递减区间，将小于nums[i]的元素全部弹出
</span><span class="c1"></span>        <span class="n">dq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//放入序号
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()]);</span><span class="c1">//已经构成窗口，将单调队列的队首添加到结果中
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-424-longest-repeating-character-replacement">LeetCode 424. Longest Repeating Character Replacement<a hidden class="anchor" aria-hidden="true" href="#leetcode-424-longest-repeating-character-replacement">#</a></h1>
<p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>
<p>Note:</p>
<p>Both the string’s length and k will not exceed 104.</p>
<p>Example 1:</p>
<p>Input:  <br>
s = &ldquo;ABAB&rdquo;, k = 2</p>
<p>Output: <br>
4
Explanation:</p>
<p>Replace the two ‘A’s with two ‘B’s or vice versa.</p>
<p>Example 2:</p>
<p>Input: <br>
s = &ldquo;AABABBA&rdquo;, k = 1</p>
<p>Output: <br>
4
Explanation:</p>
<p>Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”.</p>
<p>The substring “BBBB” has the longest repeating letters, which is 4.</p>
<p>解析：</p>
<p>题目的意思比较清楚，不过可能的情况有很多，不可能用代码去寻找最佳的替换位置，所以这里采用一种滑动窗口的方法。</p>
<p>定义start和end两个标记，中间的内容即是窗口，计算窗口内所有字母出现的次数，因为全是大写字母，所以可以用一个26位的数组来记录窗口内每个字母出现的次数。为了减少时间复杂度，我们不去每次都遍历窗口来计算出现的字母次数，而是在移动end或者start时，将对应位置的字母的次数加一或者减一。</p>
<p>找到窗口内出现最多的次数，加上允许替换的字母数k，看是否超过窗口宽度，如果超过了，说明窗口还可以更长， 也就是说窗口内重复的字母的长度可以更长，就将end右移一位，形成新的窗口，然后继续重复上面的步骤。如果没超过，说明能构成的最长的重复字母长度已经到顶了，这时应该将start右移一位，来寻找新的可能的更长重复字母长度。</p>
<p>每次计算重复字母长度时，当出现更长的可能时，都更新最终的结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">characterReplacement</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxCount</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxCount</span><span class="p">,</span> <span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxCount</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="n">start</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">maxLength</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxLength</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-480-sliding-window-median">LeetCode 480. Sliding Window Median<a hidden class="anchor" aria-hidden="true" href="#leetcode-480-sliding-window-median">#</a></h1>
<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples:</p>
<p>[2,3,4] , the median is 3</p>
<p>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>
<p>For example,</p>
<p>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<pre><code>Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
</code></pre>
<p>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p>
<p>Note:</p>
<p>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p>解析：</p>
<p>直接在窗口中使用multiset，因为只要窗口内数组已排序，那么中位数很好求，而且有重复元素出现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">medianSlidingWindow</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
<span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span><span class="c1">//先放满窗口
</span><span class="c1"></span><span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span><span class="c1">//mltiset不支持随机访问
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">medians</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">k</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">medians</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">prev</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span><span class="c1">//放入中位数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="c1">//扫描结束
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">medians</span><span class="p">;</span>
    <span class="c1">//维护加入num[i]后的窗口信息
</span><span class="c1"></span>    <span class="n">window</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//右边界扩张
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span>
        <span class="n">mid</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span><span class="c1">//左边界收缩
</span><span class="c1"></span>        <span class="n">mid</span><span class="o">++</span><span class="p">;</span>
    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">]));</span><span class="c1">//删掉num[i-k]对应的set迭代器
</span><span class="c1"></span><span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-76-minimum-window-substring">LeetCode 76. Minimum Window Substring<a hidden class="anchor" aria-hidden="true" href="#leetcode-76-minimum-window-substring">#</a></h1>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,   <br>
S = “ADOBECODEBANC”.  <br>
T = “ABC”.<br>
Minimum window is “BANC”.</p>
<p>Note: <br>
If there is no such window in S that covers all characters in T, return the empty string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
<p>解析：</p>
<p>利用哈希表保存t中的所有字符，然后双指针维护窗口。</p>
<p>哈希表map是t和s中窗口共用的，有2点作用：</p>
<p>保存模板串中字符的出现情况（包括个数）。
若map[i]大于0，则模板串比窗口多，若map[i]小于0，则模板串比窗口少，若等于0，证明两者相同。
使用count记录剩余“有效”字符数，当count达到0时，即可说明[begin,end]包含了T。此时可以进行窗口的维护。</p>
<p>在保证[begin,end]窗口包含T中所有字符的条件下，延伸end，收缩begin。进行一次扫描后，记录符合条件的最小窗口(end-begin+1)表示的字符串。</p>
<p>注意：“有效”的意思是指，当前延伸得到的S[end]字符，使得[begin,end]更进一步包含T，而不是重复劳动。</p>
<p>比如说，T=”a”, [begin,end]已经包含”a”,再延伸得到”aa”，只是无效操作，并没有使得[begin,end]更接近T,有效字符数仍为1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">string</span> <span class="n">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">c</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span> <span class="n">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//哈希表
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">counter</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">end</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span><span class="c1">//保证头部不越界
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="o">++</span><span class="p">]]</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">counter</span><span class="o">--</span><span class="p">;</span> <span class="c1">//如果该元素在t中存在,counter--,
</span><span class="c1"></span>    <span class="c1">//end和map无论什么情况都会改变（无效字符的map会变成负数，只有有效字符会变成0）
</span><span class="c1"></span>
        <span class="k">while</span><span class="p">(</span><span class="n">counter</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span> <span class="c1">//完全包含时可以求出结果，并收缩左端边界，使其不完全包含。
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">d</span><span class="p">)</span>  <span class="n">d</span><span class="o">=</span><span class="n">end</span><span class="o">-</span><span class="p">(</span><span class="n">head</span><span class="o">=</span><span class="n">begin</span><span class="p">);</span><span class="c1">//更新最优结果的起始位置
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">begin</span><span class="o">++</span><span class="p">]]</span><span class="o">++==</span><span class="mi">0</span><span class="p">)</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>  <span class="c1">//收缩begin，因为之前所有字符都自减过，所以只有有效字符才能是0，此时counter++
</span><span class="c1"></span>        <span class="p">}</span>  
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">==</span><span class="n">INT_MAX</span><span class="o">?</span> <span class="s">&#34;&#34;</span><span class="o">:</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：先执行当前操作，再进行后置运算：</p>
<pre><code>int i=0,j=1;
if((i++==1)&amp;&amp;(j++))
</code></pre>
<p>看&amp;&amp;左右两边，左边可简化为i==1; i++;因为i=0，所以左边表达式为假，就不执行右边的表达式，此时i = 1， j = 1</p>
<h1 id="leetcode-30-substring-with-concatenation-of-all-words">LeetCode 30. Substring with Concatenation of All Words<a hidden class="anchor" aria-hidden="true" href="#leetcode-30-substring-with-concatenation-of-all-words">#</a></h1>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:   <br>
s: “barfoothefoobarman”.<br>
words: [“foo”, “bar”].</p>
<p>You should return the indices: [0,9].  <br>
(order does not matter).</p>
<p>解析：</p>
<p>假设字符串S的长度为n，单词列表L中单词的长度为l。因为不是一个字符，所以需要对字符串S所有长度为l的子串进行判断。</p>
<p>做法是i从0到l-1个字符开始，得到开始index分别为i, i+l, i+2*l, …的长度为l的单词。这样就可以保证判断到所有的满足条件的子串。</p>
<p>cnt为模板串计数器，count为原串计数器，如果两者相等，说明该窗口匹配成功</p>
<p>dict和tdict分别为模板和窗口的哈希表。根据这2个哈希表判断窗口是否收缩。</p>
<p>因为每次扫描的时间复杂度是O(2n/l)（每个单词不会被访问多于两次，一次是窗口右端，一次是窗口左端），总共扫描l次（i=0, …, l-1)，所以总复杂度是O(2n/ll)=O(n)，是一个线性算法。空间复杂度是单词列表的大小，即O(cntl)其中cnt是单词列表的单词数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">S</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">dict</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">dict</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span><span class="c1">//构造模板哈希表（以字符串为单位）
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//所有单词长度相等
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wl</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//滑动窗口的初始起点0~wl-1，保证答案全部覆盖，之后收缩左端不靠这个
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">tdict</span><span class="p">;</span><span class="c1">//当前哈希表
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">wl</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">wl</span><span class="p">)</span> <span class="p">{</span><span class="c1">//右端每次递增wl
</span><span class="c1"></span>            <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">wl</span><span class="p">);</span><span class="c1">//剪切出当前长度为wl的单词，进行比较
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span><span class="c1">//符合t中单词,右端可以扩张，维护count和哈希表和左端
</span><span class="c1"></span>                <span class="n">tdict</span><span class="p">[</span><span class="n">str</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//维护窗口哈希表
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">tdict</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dict</span><span class="p">[</span><span class="n">str</span><span class="p">])</span> <span class="c1">//如果当前哈希表中单词数没比模板单词数大，还没到需要维护窗口的时候，继续进行
</span><span class="c1"></span>                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span> <span class="p">{</span><span class="c1">//如果比模板的单词数大，说明窗口左端需要收缩才能继续右端口扩张
</span><span class="c1"></span>                    <span class="k">while</span> <span class="p">(</span><span class="n">tdict</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dict</span><span class="p">[</span><span class="n">str</span><span class="p">])</span> <span class="p">{</span><span class="c1">//只要没有解除右端单词数多的情况，就要不断收缩左端
</span><span class="c1"></span>                        <span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">wl</span><span class="p">);</span><span class="c1">//左端的单词
</span><span class="c1"></span>                        <span class="n">tdict</span><span class="p">[</span><span class="n">str1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span><span class="c1">//收缩左端
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">tdict</span><span class="p">[</span><span class="n">str1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="p">[</span><span class="n">str1</span><span class="p">])</span> <span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="c1">//若左端单词是非冗余单词，count--
</span><span class="c1"></span>                        <span class="n">left</span> <span class="o">+=</span> <span class="n">wl</span><span class="p">;</span><span class="c1">//左端收缩
</span><span class="c1"></span>                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span><span class="c1">//满足条件，更新结果
</span><span class="c1"></span>                    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span><span class="c1">//答案（符合该要求的所有子串的左端）
</span><span class="c1"></span>                    <span class="n">tdict</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">wl</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span><span class="c1">//左端右移一个单位长度
</span><span class="c1"></span>                    <span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="c1">//因为窗口内的字符串肯定全是模板串集合中的某个，所以必定减少count的值
</span><span class="c1"></span>                    <span class="n">left</span> <span class="o">+=</span> <span class="n">wl</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span><span class="c1">//如果当前单词不是t中单词，右端无法右移（要保证滑动窗口字符串是连续有效的）
</span><span class="c1"></span>                <span class="n">tdict</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//重新哈希
</span><span class="c1"></span>                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">wl</span><span class="p">;</span><span class="c1">//左端右移（以当前的左端来说是不可能完成答案了）
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="最大值减去最小值小于或等于num的子数组数量">最大值减去最小值小于或等于num的子数组数量<a hidden class="anchor" aria-hidden="true" href="#最大值减去最小值小于或等于num的子数组数量">#</a></h1>
<p>题目:</p>
<p>给定数组arr和整数num,共返回有多少个子数组满足如下情况：</p>
<pre><code>max(arr[i..j]) - min(arr[i..j]) &lt;= num
</code></pre>
<p>max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。</p>
<p>如果数组长度为N,请实现时间复杂度为O(N)的解法。</p>
<p>解析:</p>
<p>首先介绍普通的解法，找到arr的所有子数组，一共有N^2个，然后对每一个子数组做遍历找到其中的最小值和最大值，这个过程时间复杂度为O(N)的，然后看看这个子数组是
否满足条件。统计所有满足的子数组数量即可。普通解法容易实现，但是时间复杂度为
O(n^3)，最优解可以做到时间复杂度O(n),额外空间复杂度O(n).</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-201615@2x.png" alt=""  />
</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-201631@2x.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">qmin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">qmax</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">qmin</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">qmin</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">qmin</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">qmin</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">qmax</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">qmax</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">qmax</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">qmax</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">[</span><span class="n">qmax</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()]</span> <span class="o">-</span> <span class="n">arr</span> <span class="o">[</span><span class="n">qmin</span><span class="o">.</span><span class="na">getFirst</span> <span class="o">()</span> <span class="o">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="o">)</span> 			  <span class="o">{</span>
            		<span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
				<span class="n">j</span><span class="o">++;</span>
		<span class="o">}</span>
			<span class="c1">//为下一次循环做准备,先把i元素弹出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">qmin</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="c1">//
</span><span class="c1"></span>                <span class="n">qmin</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">qmax</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">qmax</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>


</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/dfs/">DFS</a></li>
      <li><a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
