<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>滑动窗口 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="滑动窗口" />
<meta property="og:description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:21:40+00:00" />
<meta property="article:modified_time" content="2017-06-25T02:21:40+00:00" />

<meta itemprop="name" content="滑动窗口">
<meta itemprop="description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指"><meta itemprop="datePublished" content="2017-06-25T02:21:40+00:00" />
<meta itemprop="dateModified" content="2017-06-25T02:21:40+00:00" />
<meta itemprop="wordCount" content="4394">
<meta itemprop="keywords" content="DFS,滑动窗口," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="滑动窗口"/>
<meta name="twitter:description" content="LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">滑动窗口</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-25 </span>
        <div class="post-category">
            <a href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"> 解题报告 </a>
            </div>
          <span class="more-meta"> 约 4394 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="leetcode-209-minimum-size-subarray-sum">LeetCode 209. Minimum Size Subarray Sum</h1>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,   <br>
the subarray [4,3] has the minimal length under the problem constraint.</p>
<p>解析：用双指针维护一个窗口，枚举窗口右端，记录此时窗口和，如果当前窗口和大于等于s，维护结果。然后收缩窗口左端。直到右端枚举结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">minSubArrayLen</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">minlen</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
        <span class="k">while</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">minlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">minlen</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">minlen</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-239-sliding-window-maximum">LeetCode 239. Sliding Window Maximum</h1>
<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example, <br>
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<pre><code>Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p>Note:</p>
<p>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p>解析：</p>
<p>此题用单调队列来维护单调递减序列，单调队列的长度就是k,枚举窗口右边界,因为已经规定了窗口的大小，所以左边界固定为i-k+1.为了方便维护动态窗口,可以直接保存元素的下标,而不是元素的值.</p>
<p>队首就是该窗口的最大值。因为要维护一个窗口，需要经常把队首队尾弹出，所以采用双端队列deque.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span><span class="c1">//单调队列
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maxSlidingWindow</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dq</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举窗口右边界
</span><span class="c1"></span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="n">dq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span><span class="c1">//维护单调队列，把窗口外的元素删除。
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">dq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="c1">//维护递减区间，将小于nums[i]的元素全部弹出
</span><span class="c1"></span>        <span class="n">dq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//放入序号
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()]);</span><span class="c1">//已经构成窗口，将单调队列的队首添加到结果中
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-424-longest-repeating-character-replacement">LeetCode 424. Longest Repeating Character Replacement</h1>
<p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>
<p>Note:</p>
<p>Both the string’s length and k will not exceed 104.</p>
<p>Example 1:</p>
<p>Input:  <br>
s = &ldquo;ABAB&rdquo;, k = 2</p>
<p>Output: <br>
4
Explanation:</p>
<p>Replace the two ‘A’s with two ‘B’s or vice versa.</p>
<p>Example 2:</p>
<p>Input: <br>
s = &ldquo;AABABBA&rdquo;, k = 1</p>
<p>Output: <br>
4
Explanation:</p>
<p>Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”.</p>
<p>The substring “BBBB” has the longest repeating letters, which is 4.</p>
<p>解析：</p>
<p>题目的意思比较清楚，不过可能的情况有很多，不可能用代码去寻找最佳的替换位置，所以这里采用一种滑动窗口的方法。</p>
<p>定义start和end两个标记，中间的内容即是窗口，计算窗口内所有字母出现的次数，因为全是大写字母，所以可以用一个26位的数组来记录窗口内每个字母出现的次数。为了减少时间复杂度，我们不去每次都遍历窗口来计算出现的字母次数，而是在移动end或者start时，将对应位置的字母的次数加一或者减一。</p>
<p>找到窗口内出现最多的次数，加上允许替换的字母数k，看是否超过窗口宽度，如果超过了，说明窗口还可以更长， 也就是说窗口内重复的字母的长度可以更长，就将end右移一位，形成新的窗口，然后继续重复上面的步骤。如果没超过，说明能构成的最长的重复字母长度已经到顶了，这时应该将start右移一位，来寻找新的可能的更长重复字母长度。</p>
<p>每次计算重复字母长度时，当出现更长的可能时，都更新最终的结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">characterReplacement</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxCount</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxCount</span><span class="p">,</span> <span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxCount</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="n">start</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">maxLength</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxLength</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-480-sliding-window-median">LeetCode 480. Sliding Window Median</h1>
<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples:</p>
<p>[2,3,4] , the median is 3</p>
<p>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>
<p>For example,</p>
<p>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<pre><code>Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
</code></pre>
<p>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p>
<p>Note:</p>
<p>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p>解析：</p>
<p>直接在窗口中使用multiset，因为只要窗口内数组已排序，那么中位数很好求，而且有重复元素出现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">medianSlidingWindow</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
<span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span><span class="c1">//先放满窗口
</span><span class="c1"></span><span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span><span class="c1">//mltiset不支持随机访问
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">medians</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">k</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">medians</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">prev</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span><span class="c1">//放入中位数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="c1">//扫描结束
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">medians</span><span class="p">;</span>
    <span class="c1">//维护加入num[i]后的窗口信息
</span><span class="c1"></span>    <span class="n">window</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//右边界扩张
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span>
        <span class="n">mid</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span><span class="c1">//左边界收缩
</span><span class="c1"></span>        <span class="n">mid</span><span class="o">++</span><span class="p">;</span>
    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">]));</span><span class="c1">//删掉num[i-k]对应的set迭代器
</span><span class="c1"></span><span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-76-minimum-window-substring">LeetCode 76. Minimum Window Substring</h1>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,   <br>
S = “ADOBECODEBANC”.  <br>
T = “ABC”.<br>
Minimum window is “BANC”.</p>
<p>Note: <br>
If there is no such window in S that covers all characters in T, return the empty string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
<p>解析：</p>
<p>利用哈希表保存t中的所有字符，然后双指针维护窗口。</p>
<p>哈希表map是t和s中窗口共用的，有2点作用：</p>
<p>保存模板串中字符的出现情况（包括个数）。
若map[i]大于0，则模板串比窗口多，若map[i]小于0，则模板串比窗口少，若等于0，证明两者相同。
使用count记录剩余“有效”字符数，当count达到0时，即可说明[begin,end]包含了T。此时可以进行窗口的维护。</p>
<p>在保证[begin,end]窗口包含T中所有字符的条件下，延伸end，收缩begin。进行一次扫描后，记录符合条件的最小窗口(end-begin+1)表示的字符串。</p>
<p>注意：“有效”的意思是指，当前延伸得到的S[end]字符，使得[begin,end]更进一步包含T，而不是重复劳动。</p>
<p>比如说，T=”a”, [begin,end]已经包含”a”,再延伸得到”aa”，只是无效操作，并没有使得[begin,end]更接近T,有效字符数仍为1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">string</span> <span class="n">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">c</span><span class="p">:</span> <span class="n">t</span><span class="p">)</span> <span class="n">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//哈希表
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">counter</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">end</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span><span class="c1">//保证头部不越界
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="o">++</span><span class="p">]]</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">counter</span><span class="o">--</span><span class="p">;</span> <span class="c1">//如果该元素在t中存在,counter--,
</span><span class="c1"></span>    <span class="c1">//end和map无论什么情况都会改变（无效字符的map会变成负数，只有有效字符会变成0）
</span><span class="c1"></span>
        <span class="k">while</span><span class="p">(</span><span class="n">counter</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span> <span class="c1">//完全包含时可以求出结果，并收缩左端边界，使其不完全包含。
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">d</span><span class="p">)</span>  <span class="n">d</span><span class="o">=</span><span class="n">end</span><span class="o">-</span><span class="p">(</span><span class="n">head</span><span class="o">=</span><span class="n">begin</span><span class="p">);</span><span class="c1">//更新最优结果的起始位置
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">begin</span><span class="o">++</span><span class="p">]]</span><span class="o">++==</span><span class="mi">0</span><span class="p">)</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>  <span class="c1">//收缩begin，因为之前所有字符都自减过，所以只有有效字符才能是0，此时counter++
</span><span class="c1"></span>        <span class="p">}</span>  
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">==</span><span class="n">INT_MAX</span><span class="o">?</span> <span class="s">&#34;&#34;</span><span class="o">:</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：先执行当前操作，再进行后置运算：</p>
<pre><code>int i=0,j=1;
if((i++==1)&amp;&amp;(j++))
</code></pre>
<p>看&amp;&amp;左右两边，左边可简化为i==1; i++;因为i=0，所以左边表达式为假，就不执行右边的表达式，此时i = 1， j = 1</p>
<h1 id="leetcode-30-substring-with-concatenation-of-all-words">LeetCode 30. Substring with Concatenation of All Words</h1>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:   <br>
s: “barfoothefoobarman”.<br>
words: [“foo”, “bar”].</p>
<p>You should return the indices: [0,9].  <br>
(order does not matter).</p>
<p>解析：</p>
<p>假设字符串S的长度为n，单词列表L中单词的长度为l。因为不是一个字符，所以需要对字符串S所有长度为l的子串进行判断。</p>
<p>做法是i从0到l-1个字符开始，得到开始index分别为i, i+l, i+2*l, …的长度为l的单词。这样就可以保证判断到所有的满足条件的子串。</p>
<p>cnt为模板串计数器，count为原串计数器，如果两者相等，说明该窗口匹配成功</p>
<p>dict和tdict分别为模板和窗口的哈希表。根据这2个哈希表判断窗口是否收缩。</p>
<p>因为每次扫描的时间复杂度是O(2n/l)（每个单词不会被访问多于两次，一次是窗口右端，一次是窗口左端），总共扫描l次（i=0, …, l-1)，所以总复杂度是O(2n/ll)=O(n)，是一个线性算法。空间复杂度是单词列表的大小，即O(cntl)其中cnt是单词列表的单词数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">S</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">dict</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">dict</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span><span class="c1">//构造模板哈希表（以字符串为单位）
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="c1">//所有单词长度相等
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wl</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//滑动窗口的初始起点0~wl-1，保证答案全部覆盖，之后收缩左端不靠这个
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">tdict</span><span class="p">;</span><span class="c1">//当前哈希表
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">wl</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">wl</span><span class="p">)</span> <span class="p">{</span><span class="c1">//右端每次递增wl
</span><span class="c1"></span>            <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">wl</span><span class="p">);</span><span class="c1">//剪切出当前长度为wl的单词，进行比较
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span><span class="c1">//符合t中单词,右端可以扩张，维护count和哈希表和左端
</span><span class="c1"></span>                <span class="n">tdict</span><span class="p">[</span><span class="n">str</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//维护窗口哈希表
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">tdict</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dict</span><span class="p">[</span><span class="n">str</span><span class="p">])</span> <span class="c1">//如果当前哈希表中单词数没比模板单词数大，还没到需要维护窗口的时候，继续进行
</span><span class="c1"></span>                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span> <span class="p">{</span><span class="c1">//如果比模板的单词数大，说明窗口左端需要收缩才能继续右端口扩张
</span><span class="c1"></span>                    <span class="k">while</span> <span class="p">(</span><span class="n">tdict</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dict</span><span class="p">[</span><span class="n">str</span><span class="p">])</span> <span class="p">{</span><span class="c1">//只要没有解除右端单词数多的情况，就要不断收缩左端
</span><span class="c1"></span>                        <span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">wl</span><span class="p">);</span><span class="c1">//左端的单词
</span><span class="c1"></span>                        <span class="n">tdict</span><span class="p">[</span><span class="n">str1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span><span class="c1">//收缩左端
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">tdict</span><span class="p">[</span><span class="n">str1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="p">[</span><span class="n">str1</span><span class="p">])</span> <span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="c1">//若左端单词是非冗余单词，count--
</span><span class="c1"></span>                        <span class="n">left</span> <span class="o">+=</span> <span class="n">wl</span><span class="p">;</span><span class="c1">//左端收缩
</span><span class="c1"></span>                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span><span class="c1">//满足条件，更新结果
</span><span class="c1"></span>                    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span><span class="c1">//答案（符合该要求的所有子串的左端）
</span><span class="c1"></span>                    <span class="n">tdict</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">wl</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span><span class="c1">//左端右移一个单位长度
</span><span class="c1"></span>                    <span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="c1">//因为窗口内的字符串肯定全是模板串集合中的某个，所以必定减少count的值
</span><span class="c1"></span>                    <span class="n">left</span> <span class="o">+=</span> <span class="n">wl</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span><span class="c1">//如果当前单词不是t中单词，右端无法右移（要保证滑动窗口字符串是连续有效的）
</span><span class="c1"></span>                <span class="n">tdict</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//重新哈希
</span><span class="c1"></span>                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">wl</span><span class="p">;</span><span class="c1">//左端右移（以当前的左端来说是不可能完成答案了）
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="最大值减去最小值小于或等于num的子数组数量">最大值减去最小值小于或等于num的子数组数量</h1>
<p>题目:</p>
<p>给定数组arr和整数num,共返回有多少个子数组满足如下情况：</p>
<pre><code>max(arr[i..j]) - min(arr[i..j]) &lt;= num
</code></pre>
<p>max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。</p>
<p>如果数组长度为N,请实现时间复杂度为O(N)的解法。</p>
<p>解析:</p>
<p>首先介绍普通的解法，找到arr的所有子数组，一共有N^2个，然后对每一个子数组做遍历找到其中的最小值和最大值，这个过程时间复杂度为O(N)的，然后看看这个子数组是
否满足条件。统计所有满足的子数组数量即可。普通解法容易实现，但是时间复杂度为
O(n^3)，最优解可以做到时间复杂度O(n),额外空间复杂度O(n).</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-201615@2x.png" alt=""></p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170816-201631@2x.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">qmin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">qmax</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">qmin</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">qmin</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">qmin</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">qmin</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">qmax</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">qmax</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">qmax</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">qmax</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">[</span><span class="n">qmax</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()]</span> <span class="o">-</span> <span class="n">arr</span> <span class="o">[</span><span class="n">qmin</span><span class="o">.</span><span class="na">getFirst</span> <span class="o">()</span> <span class="o">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="o">)</span> 			  <span class="o">{</span>
            		<span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
				<span class="n">j</span><span class="o">++;</span>
		<span class="o">}</span>
			<span class="c1">//为下一次循环做准备,先把i元素弹出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">qmin</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="c1">//
</span><span class="c1"></span>                <span class="n">qmin</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">qmax</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">qmax</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>


</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/dfs/">DFS</a>
          <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">设计一个有getMin功能的栈</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/">
            <span class="next-text nav-default">二叉树的按层打印与ZigZig打印</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
