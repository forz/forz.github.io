<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>如何优雅地控制goroutine | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="如何优雅地控制goroutine" />
<meta property="og:description" content="如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-12-14T18:17:38&#43;00:00" />
<meta property="article:modified_time" content="2018-12-14T18:17:38&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何优雅地控制goroutine"/>
<meta name="twitter:description" content="如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "如何优雅地控制goroutine",
      "item": "/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何优雅地控制goroutine",
  "name": "如何优雅地控制goroutine",
  "description": "如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就",
  "keywords": [
    
  ],
  "articleBody": "如何控制goroutine的数量 用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行。第一时间想到的就是使用通道。每次执行的go之前向通道写入值，直到通道满的时候就阻塞了，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var ch chan int func work() { //do something  ch } func main() { ch = make(chan int, 10) for i:=0; i  10000; i++ { ch  1 go work() } }   这样每次同时运行的goroutine就被限制为10个了。但是新的问题出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var wg *sync.WaitGroup func work() { defer wg.Done() //do something } func main() { wg = \u0026sync.WaitGroup{} for i:=0; i  10000; i++ { wg.Add(1) go work() } wg.Wait()//等待所有goroutine退出 }   综上所述，我们封装一下，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package gpool import ( \"sync\" ) type pool struct { queue chan int wg *sync.WaitGroup } func New(size int) *pool { if size  0 { size = 1 } return \u0026pool{ queue: make(chan int, size), wg: \u0026sync.WaitGroup{}, } } func (p *pool) Add(delta int) { for i := 0; i  delta; i++ { p.queue  1 } for i := 0; i  delta; i-- { p.queue } p.wg.Add(delta) } func (p *pool) Done() { p.queue p.wg.Done() } func (p *pool) Wait() { p.wg.Wait() }   来段测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package gpool_test import ( \"runtime\" \"testing\" \"time\" \"gpool\" ) func Test_Example(t *testing.T) { pool := gpool.New(100) println(runtime.NumGoroutine()) for i := 0; i  1000; i++ { pool.Add(1) go func() { time.Sleep(time.Second) println(runtime.NumGoroutine()) pool.Done() }() } pool.Wait() println(runtime.NumGoroutine()) }   如何限制goroutine的同时执行数量 由于channel的阻塞机制，通过设置缓冲channel的缓冲大小来控制同时执行的协程数量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package main import ( \"fmt\" \"log\" \"math/rand\" \"time\" ) const N = 100 func HeavyWork(id int) { rand.Seed(int64(id)) interval := time.Duration(rand.Intn(3)+1) * time.Second time.Sleep(interval) fmt.Printf(\"HeavyWork %-3d cost %v\\n\", id, interval) } func main() { start := time.Now() ch := make(chan int, 2) for i := 0; i  N; i++ { ch  1 go func(n int) { HeavyWork(n) ch }(i) } close(ch) log.Println(\"complete\", time.Since(start).Seconds()) }   控制Goroutine的执行顺序 单核情况下的Goroutine执行顺序 单核\u0008情况下的Goroutine的执行顺序并不是顺序执行,而是以一种非常奇怪的顺序执行:在只有一个CPU工作的时候，永远是最后一个先执行 剩下的按顺序执行.\n示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  func main() { runtime.GOMAXPROCS(1) var wg sync.WaitGroup wg.Add(2) go func() { fmt.Println(\"a\") wg.Done() }() go func() { fmt.Println(\"b\") wg.Done() }() wg.Wait() }   执行的结果是先打印出b,再打印出a\n一般情况下在同一个goroutine中创建的多个任务中最后创建那个任务最可能先被执行。原因的话就要看go的实现细节了：简单说同一goroutine中2个任务被创建后 理论上会按顺序 被放在同一个任务队列，但实际上最后那个任务会被放在专一的next（下一个要被执行的任务的意思）的位置，所以优先级最高，最可能先被执行。剩下的任务如果go运行时调度器发现有空闲的core，就会把任务偷走点，让别的core执行，这样才能充分利用多核，提高并发能力。\n以下为goroutine任务放入队列的函数源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  func runqput(_p_ *p, gp *g, next bool) { if randomizeScheduler \u0026\u0026 next \u0026\u0026 fastrand()%2 == 0 { next = false } //如果可能,将G直接保存在P.runnext,作为下一个优先执行任务 \tif next { retryNext: oldnext := _p_.runnext if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) { goto retryNext } if oldnext == 0 { return } //原本的next G会被放回本地队列 \tgp = oldnext.ptr() } retry: //runghead 是一个数组实现的循环队列 \th := atomic.Load(\u0026_p_.runqhead) // load-acquire, synchronize with consumers \tt := _p_.runqtail if t-h  uint32(len(_p_.runq)) { _p_.runq[t%uint32(len(_p_.runq))].set(gp) atomic.Store(\u0026_p_.runqtail, t+1) // store-release, makes the item available for consumption \treturn } if runqputslow(_p_, gp, h, t) { return } // the queue is not full, now the put above must succeed \tgoto retry }   控制多核情况下的Goroutine执行顺序 编写一个程序，开启 N 个线程A,B,C…，这N个线程的输出分别为 A、B、C…，每个线程将自己的输出在屏幕上打印 M 遍，要求输出的结果必须按顺序显示。如：ABC…ABC…ABC… 其中 N 注意:输出要在各自的线程中输出，不能在主线程中输出\n利用 Channel 做信号量的解法 使用信号量的话，这个题的解题思路就很简单:\n 创建 N 个Goroutine 执行输出操作。 每个 Goroutine 的具体操作可用以下伪代码来表示:  1 2 3 4 5  def echo(threadNum, Upstream, Downstream): for i in range(M): wait Upstream // 等待上游的信号 print(threadNum) signal Downstream // 给下游发送信号   其中Upstream 和 Downstream 都表示信号量，A Goroutine 的 Downstream 是 B Goroutine 的 Upstream，依此类推，所有 Goroutine 会形成一个链式的关系。\n可以使用下图来表示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  package main import ( \"fmt\" \"log\" ) var ( N = 5 M = 2 ) func main() { var wait, sig, firstWait, lastSig chan struct{} wait = make(chan struct{}) firstWait = wait for i := 0; i  N; i++ { //wait与sig首尾相连 \tsig = make(chan struct{}) lastSig = sig go echo(i, wait, sig) wait = sig } for i := 0; i  M; i++ { firstWait  struct{}{} lastSig } close(firstWait) _, ok := lastSig if ok { log.Fatalln(\"Channel not closed\") } // Out \t// 0: A \t// 1: B \t// 2: C \t// 3: D \t// 4: E \t// 0: A \t// 1: B \t// 2: C \t// 3: D \t// 4: E \t// 0: A \t// 1: B \t// 2: C \t// 3: D \t// 4: E \t// Close A \t// Close B \t// Close C \t// Close D \t// Close E } func echo(threadNum int, wait chan struct{}, sig chan struct{}) { threadName := string('A' + threadNum) for _ = range wait { fmt.Printf(\"%d: %s\\n\", threadNum, threadName) sig  struct{}{} } close(sig) // 这句是我打印出来为了确认所有的 Goroutine 已经关闭了，实际不需要 \tfmt.Println(\"Close\", threadName) }   FanIn 的方式 根据题目要求来看，在主线程中输出结果，有些不符合要求，但有个答案的实现很有意思，我就也放上来了\n通过将多个输入 channel 多路复用到单个处理 channel 的方式，一个函数能够从多个输入 channel 中读取数据并处理。当所有的输出 channel 都关闭的时候，单个处理 channel 也会关闭。这就叫做扇入。\n理解了扇入的概念后，上述问题的答案也呼之欲出了。我们可以为A,B,C,…这N个 Goroutine 创建N个 channel。然后通过一个 FanIn 函数将N个 channel 的输出输入到一个 channel 中。具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package main import \"fmt\" var ( N = 5 M = 5 ) func gen(v string, times int) chan string { ch := make(chan string) go func() { defer close(ch) for i := 0; i  times; i++ { ch  v } }() return ch } func fanIn(times int, inputs []chan string) chan string { ch := make(chan string) go func() { defer close(ch) for i := 0; i  times; i++ { for _, input := range inputs { v := input ch  v } } }() return ch } func main() { times := M inputs := make([]chan string, 0, N) for i := 0; i  N; i++ { threadName := string('A' + i) inputs = append(inputs, gen(threadName, times)) } for char := range fanIn(times, inputs) { fmt.Println(char) } }   如何退出一个Goroutine 需求分析 (3个原因) 产生这个需求，通常有以下的原因：\n 这个 goroutine 的运行超出了太多预计的时间，以致后续的计算不再有意义 这个 goroutine 阻塞在某个 read/write channel 变得没有响应 这个 goroutine 阻塞在某个系统调用，外部调用或业务逻辑的死循环  这种时候很自然地就会产生“主动外部 kill goroutine”的需求 (正如手动结束掉一个无响应的进程那样)。\n然而 goroutine 被设计为不可以从外部无条件地结束掉，只能通过 channel 来与它通信。也就是说，每一个 goroutine 都需要承担自己退出的责任。(A goroutine cannot be programmatically killed. It can only commit a cooperative suicide.)\nGoroutine控制分类 以下我们分可响应 (1 \u0026 2) 和不可响应 (3) 两种情况分开讨论\n处理仍可响应 channel 的 goroutine (1 \u0026 2) 最直接的方法是关闭与这个 goroutine 通信的 channel close(ch)。如果这个 goroutine 此时阻塞在 read 上，那么阻塞会失效，并在第二个返回值中返回 false (此时可以检测并退出)；如果阻塞在 write 上，那么会 panic，这时合理的做法是在 goroutine 的顶层 recover 并退出。\n更健壮的设计一般会把 data channel (用于传递业务逻辑的数据) 和 signal channel (用于管理 goroutine 的状态) 分开。不会让 goroutine 直接读写 data channel，而是通过 select-default 或 select-timeout 来避免完全阻塞，同时周期性地在 signal channel 检查是否有结束的请求。\n以上的方法可以处理前两种情况。\n处理无法响应 channel 的 goroutine (3) 对于第三种情况，程序员能做的就是：\n 尽量使用 Non-blocking IO (正如 go runtime 那样) 尽量使用阻塞粒度较小的 sys calls (对外部调用也一样) 业务逻辑总是考虑退出机制，编码时避免潜在的死循环 在合适的地方插入响应 channel 的代码，保持一定频率的 channel 响应能力  关于 blocking syscall，需要注意的是 Go runtime 会启动新的 OS 线程去调度剩下的 goroutines，如果不能及时从阻塞中恢复并持续有新的 blocking goroutine 的话，OS 线程数量会线性地增长，这是一种非常不理想的情况.\n通过channel通知退出 这个最主要的goroutine退出方式。goroutine虽然不能强制结束另外一个goroutine，但是它是它可以通过channel通知另外一个goroutine你的表演该结束了。常用的方法到处都可以看到，这里也不详细说明了，直接上一个示例：\n下面的示例中起了一个goroutine执行cancelByChannel，但是在起它之前还通过time.After返回了一个time.Time类型的channel，该channel上在定时超时时会发送一个当前时间数据。\ncancelByChannel每隔1s会检查这个channel上是否有数据接收，如果有数据则退出goroutine，如果没有信号接收就在连接上发送一条数据。所以下面这段代码在运行10s发送10条消息后将退出。\n程序起起来后，另开一个终端执行nc localhost:8000（Linux上）或nc localhost 8000（mac 上）可以看到程序执行情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  package main import ( \"context\" \"fmt\" \"io\" \"net\" \"sync\" \"time\" ) func cancelByChannel(c net.Conn, quit chan time.Time, wg *sync.WaitGroup) { defer c.Close() defer wg.Done() for { select { case quit: fmt.Println(\"cancel goroutine by channel!\") return default: _, err := io.WriteString(c, \"hello cancelByChannel\") if err != nil { return } time.Sleep(1 * time.Second) } } } func main() { listener, err := net.Listen(\"tcp\", \"localhost:8000\") if err != nil { fmt.Println(err) return } conn, err := listener.Accept() if err != nil { fmt.Println(err) return } wg := sync.WaitGroup{} wg.Add(1) quit := time.After(time.Second * 10) go cancelByChannel(conn, quit, \u0026wg) wg.Wait() }   通过context通知goroutine退出 通过channel通知goroutine退出还有一个更好的方法就是使用context。它本质还是接收一个channel数据，只是是通过ctx.Done()获取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package main import ( \"context\" \"fmt\" \"time\" ) func main() { ctx := context.Background() ctx, cancel := context.WithCancel(ctx) go Proc(ctx, 1) go Proc(ctx, 2) go Proc(ctx, 3) go Proc(ctx, 4) time.Sleep(time.Second / 10) cancel() time.Sleep(time.Second) } func Proc(ctx context.Context, n int) { for { select { case ctx.Done(): return default: fmt.Printf(\"Proc-%d \", n) } } }   这种形式的协程关闭和自己写的区别在于自己写的话自己要记录下协程的数量，关闭的chan等等\n总结 由于Goroutine被设计为只能自己退出，而不能强制退出。在实际使用中，我们可能会因为某些原因被block在Goroutines里面，或由于设计缺陷导致一些Goroutines执行很长的时间。只是基于一些其他语言的经验，我们可能会期望有一种外部机制能够强制结束一个Goroutines。但是这就是Go和Goroutine，它的目的就是要提供一种轻量的，简单的并发方式。保证它这个特性的基础也决定了我们不能用外部方式强制关闭一个Goroutines（额外post译文或博文说明这个问题，此文不深入展开)。所以当你遇到这种情况的时候，你可能需要考虑你的设计是不是足够的Go style，或者你对一些外部依赖是否足够了解了。\n参考:\nhttps://blog.csdn.net/xingwangc2014/article/details/78998727\nhttps://gulu-dev.com/post/2016-02-02-kill-goroutine\nhttps://blog.csdn.net/soekchl521/article/details/72420535\n",
  "wordCount" : "4196",
  "inLanguage": "zh-cn",
  "datePublished": "2018-12-14T18:17:38Z",
  "dateModified": "2018-12-14T18:17:38Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8E%A7%E5%88%B6goroutine/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      如何优雅地控制goroutine
    </h1>
    <div class="post-meta">December 14, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="如何控制goroutine的数量">如何控制goroutine的数量<a hidden class="anchor" aria-hidden="true" href="#如何控制goroutine的数量">#</a></h1>
<p>用什么方法控制goroutine的数量？ 要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行。第一时间想到的就是使用通道。每次执行的go之前向通道写入值，直到通道满的时候就阻塞了，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//do something
</span><span class="c1"></span>    <span class="o">&lt;-</span><span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
       <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
       <span class="k">go</span> <span class="nf">work</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样每次同时运行的goroutine就被限制为10个了。但是新的问题出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
    <span class="c1">//do something
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
       <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
       <span class="k">go</span> <span class="nf">work</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span><span class="c1">//等待所有goroutine退出
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>综上所述，我们封装一下，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gpool</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">pool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">queue</span> <span class="kd">chan</span> <span class="kt">int</span>
	<span class="nx">wg</span>    <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">pool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">pool</span><span class="p">{</span>
		<span class="nx">queue</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span><span class="p">),</span>
		<span class="nx">wg</span><span class="p">:</span>    <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pool</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">delta</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">queue</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nx">delta</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">queue</span>
	<span class="p">}</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pool</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">queue</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pool</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>来段测试代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gpool_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;testing&#34;</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;gpool&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Test_Example</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pool</span> <span class="o">:=</span> <span class="nx">gpool</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">pool</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
			<span class="nb">println</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
			<span class="nx">pool</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">pool</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="如何限制goroutine的同时执行数量">如何限制goroutine的同时执行数量<a hidden class="anchor" aria-hidden="true" href="#如何限制goroutine的同时执行数量">#</a></h1>
<p>由于channel的阻塞机制，通过设置缓冲channel的缓冲大小来控制同时执行的协程数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">N</span> <span class="p">=</span> <span class="mi">100</span>

<span class="kd">func</span> <span class="nf">HeavyWork</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>
	<span class="nx">interval</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">interval</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;HeavyWork %-3d cost %v\n&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">interval</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">HeavyWork</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
			<span class="o">&lt;-</span><span class="nx">ch</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;complete&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">).</span><span class="nf">Seconds</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="控制goroutine的执行顺序">控制Goroutine的执行顺序<a hidden class="anchor" aria-hidden="true" href="#控制goroutine的执行顺序">#</a></h1>
<h2 id="单核情况下的goroutine执行顺序">单核情况下的Goroutine执行顺序<a hidden class="anchor" aria-hidden="true" href="#单核情况下的goroutine执行顺序">#</a></h2>
<p>单核情况下的Goroutine的执行顺序并不是顺序执行,而是以一种非常奇怪的顺序执行:在只有一个CPU工作的时候，永远是最后一个先执行 剩下的按顺序执行.</p>
<p>示例代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
    <span class="p">}()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;b&#34;</span><span class="p">)</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
    <span class="p">}()</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行的结果是先打印出b,再打印出a</p>
<p>一般情况下在同一个goroutine中创建的多个任务中最后创建那个任务最可能先被执行。原因的话就要看go的实现细节了：简单说同一goroutine中2个任务被创建后 理论上会按顺序 被放在同一个任务队列，但实际上最后那个任务会被放在专一的next（下一个要被执行的任务的意思）的位置，所以优先级最高，最可能先被执行。剩下的任务如果go运行时调度器发现有空闲的core，就会把任务偷走点，让别的core执行，这样才能充分利用多核，提高并发能力。</p>
<p>以下为goroutine任务放入队列的函数源码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
    <span class="c1">//如果可能,将G直接保存在P.runnext,作为下一个优先执行任务
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
	<span class="nx">retryNext</span><span class="p">:</span>
		<span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">retryNext</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">//原本的next G会被放回本地队列
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>

<span class="nx">retry</span><span class="p">:</span>
    <span class="c1">//runghead 是一个数组实现的循环队列
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// the queue is not full, now the put above must succeed
</span><span class="c1"></span>	<span class="k">goto</span> <span class="nx">retry</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="控制多核情况下的goroutine执行顺序">控制多核情况下的Goroutine执行顺序<a hidden class="anchor" aria-hidden="true" href="#控制多核情况下的goroutine执行顺序">#</a></h2>
<p>编写一个程序，开启 N 个线程A,B,C…，这N个线程的输出分别为 A、B、C…，每个线程将自己的输出在屏幕上打印 M 遍，要求输出的结果必须按顺序显示。如：ABC…ABC…ABC… 其中 N &lt;= 1000, M &lt;= 1000</p>
<p>注意:输出要在各自的线程中输出，不能在主线程中输出</p>
<h3 id="利用-channel-做信号量的解法">利用 Channel 做信号量的解法<a hidden class="anchor" aria-hidden="true" href="#利用-channel-做信号量的解法">#</a></h3>
<p>使用信号量的话，这个题的解题思路就很简单:</p>
<ul>
<li>创建 N 个Goroutine 执行输出操作。</li>
<li>每个 Goroutine 的具体操作可用以下伪代码来表示:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">def echo(threadNum, Upstream, Downstream):
  for i in range(M):
    wait Upstream  // 等待上游的信号
    print(threadNum)
    signal Downstream // 给下游发送信号
</code></pre></td></tr></table>
</div>
</div><p>其中Upstream 和 Downstream 都表示信号量，A Goroutine 的 Downstream 是 B Goroutine 的 Upstream，依此类推，所有 Goroutine 会形成一个链式的关系。</p>
<p>可以使用下图来表示:</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20190705173609.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">N</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="nx">M</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wait</span><span class="p">,</span> <span class="nx">sig</span><span class="p">,</span> <span class="nx">firstWait</span><span class="p">,</span> <span class="nx">lastSig</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

	<span class="nx">wait</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">firstWait</span> <span class="p">=</span> <span class="nx">wait</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">//wait与sig首尾相连
</span><span class="c1"></span>		<span class="nx">sig</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
		<span class="nx">lastSig</span> <span class="p">=</span> <span class="nx">sig</span>
		<span class="k">go</span> <span class="nf">echo</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">wait</span><span class="p">,</span> <span class="nx">sig</span><span class="p">)</span>
		<span class="nx">wait</span> <span class="p">=</span> <span class="nx">sig</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">M</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">firstWait</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="o">&lt;-</span><span class="nx">lastSig</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">firstWait</span><span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">lastSig</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="s">&#34;Channel not closed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Out
</span><span class="c1"></span>	<span class="c1">// 0: A
</span><span class="c1"></span>	<span class="c1">// 1: B
</span><span class="c1"></span>	<span class="c1">// 2: C
</span><span class="c1"></span>	<span class="c1">// 3: D
</span><span class="c1"></span>	<span class="c1">// 4: E
</span><span class="c1"></span>	<span class="c1">// 0: A
</span><span class="c1"></span>	<span class="c1">// 1: B
</span><span class="c1"></span>	<span class="c1">// 2: C
</span><span class="c1"></span>	<span class="c1">// 3: D
</span><span class="c1"></span>	<span class="c1">// 4: E
</span><span class="c1"></span>	<span class="c1">// 0: A
</span><span class="c1"></span>	<span class="c1">// 1: B
</span><span class="c1"></span>	<span class="c1">// 2: C
</span><span class="c1"></span>	<span class="c1">// 3: D
</span><span class="c1"></span>	<span class="c1">// 4: E
</span><span class="c1"></span>	<span class="c1">// Close A
</span><span class="c1"></span>	<span class="c1">// Close B
</span><span class="c1"></span>	<span class="c1">// Close C
</span><span class="c1"></span>	<span class="c1">// Close D
</span><span class="c1"></span>	<span class="c1">// Close E
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">echo</span><span class="p">(</span><span class="nx">threadNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">wait</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">sig</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">threadName</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="nx">threadNum</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span> <span class="p">=</span> <span class="k">range</span> <span class="nx">wait</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d: %s\n&#34;</span><span class="p">,</span> <span class="nx">threadNum</span><span class="p">,</span> <span class="nx">threadName</span><span class="p">)</span>
		<span class="nx">sig</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="p">}</span>

	<span class="nb">close</span><span class="p">(</span><span class="nx">sig</span><span class="p">)</span>
	<span class="c1">// 这句是我打印出来为了确认所有的 Goroutine 已经关闭了，实际不需要
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Close&#34;</span><span class="p">,</span> <span class="nx">threadName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="fanin-的方式">FanIn 的方式<a hidden class="anchor" aria-hidden="true" href="#fanin-的方式">#</a></h3>
<p>根据题目要求来看，在主线程中输出结果，有些不符合要求，但有个答案的实现很有意思，我就也放上来了</p>
<p>通过将多个输入 channel 多路复用到单个处理 channel 的方式，一个函数能够从多个输入 channel 中读取数据并处理。当所有的输出 channel 都关闭的时候，单个处理 channel 也会关闭。这就叫做扇入。</p>
<p>理解了扇入的概念后，上述问题的答案也呼之欲出了。我们可以为A,B,C,&hellip;这N个 Goroutine 创建N个 channel。然后通过一个 FanIn 函数将N个 channel 的输出输入到一个 channel 中。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">N</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="nx">M</span> <span class="p">=</span> <span class="mi">5</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">gen</span><span class="p">(</span><span class="nx">v</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">times</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">times</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nx">times</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">inputs</span> <span class="p">[]</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">times</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">input</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">inputs</span> <span class="p">{</span>
				<span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input</span>
				<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">times</span> <span class="o">:=</span> <span class="nx">M</span>
	<span class="nx">inputs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">threadName</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">inputs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">inputs</span><span class="p">,</span> <span class="nf">gen</span><span class="p">(</span><span class="nx">threadName</span><span class="p">,</span> <span class="nx">times</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nx">times</span><span class="p">,</span> <span class="nx">inputs</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="如何退出一个goroutine">如何退出一个Goroutine<a hidden class="anchor" aria-hidden="true" href="#如何退出一个goroutine">#</a></h1>
<h2 id="需求分析-3个原因">需求分析 (3个原因)<a hidden class="anchor" aria-hidden="true" href="#需求分析-3个原因">#</a></h2>
<p>产生这个需求，通常有以下的原因：</p>
<ul>
<li>这个 goroutine 的运行超出了太多预计的时间，以致后续的计算不再有意义</li>
<li>这个 goroutine 阻塞在某个 read/write channel 变得没有响应</li>
<li>这个 goroutine 阻塞在某个系统调用，外部调用或业务逻辑的死循环</li>
</ul>
<p>这种时候很自然地就会产生“主动外部 kill goroutine”的需求 (正如手动结束掉一个无响应的进程那样)。</p>
<p>然而 goroutine 被设计为不可以从外部无条件地结束掉，只能通过 channel 来与它通信。也就是说，每一个 goroutine 都需要承担自己退出的责任。(A goroutine cannot be programmatically killed. It can only commit a cooperative suicide.)</p>
<h2 id="goroutine控制分类">Goroutine控制分类<a hidden class="anchor" aria-hidden="true" href="#goroutine控制分类">#</a></h2>
<p>以下我们分可响应 (1 &amp; 2) 和不可响应 (3) 两种情况分开讨论</p>
<h3 id="处理仍可响应-channel-的-goroutine-1--2">处理仍可响应 channel 的 goroutine (1 &amp; 2)<a hidden class="anchor" aria-hidden="true" href="#处理仍可响应-channel-的-goroutine-1--2">#</a></h3>
<p>最直接的方法是关闭与这个 goroutine 通信的 channel close(ch)。如果这个 goroutine 此时阻塞在 read 上，那么阻塞会失效，并在第二个返回值中返回 false (此时可以检测并退出)；如果阻塞在 write 上，那么会 panic，这时合理的做法是在 goroutine 的顶层 recover 并退出。</p>
<p>更健壮的设计一般会把 data channel (用于传递业务逻辑的数据) 和 signal channel (用于管理 goroutine 的状态) 分开。不会让 goroutine 直接读写 data channel，而是通过 select-default 或 select-timeout 来避免完全阻塞，同时周期性地在 signal channel 检查是否有结束的请求。</p>
<p>以上的方法可以处理前两种情况。</p>
<h3 id="处理无法响应-channel-的-goroutine-3">处理无法响应 channel 的 goroutine (3)<a hidden class="anchor" aria-hidden="true" href="#处理无法响应-channel-的-goroutine-3">#</a></h3>
<p>对于第三种情况，程序员能做的就是：</p>
<ol>
<li>尽量使用 Non-blocking IO (正如 go runtime 那样)</li>
<li>尽量使用阻塞粒度较小的 sys calls (对外部调用也一样)</li>
<li>业务逻辑总是考虑退出机制，编码时避免潜在的死循环</li>
<li>在合适的地方插入响应 channel 的代码，保持一定频率的 channel 响应能力</li>
</ol>
<p>关于 blocking syscall，需要注意的是 Go runtime 会启动新的 OS 线程去调度剩下的 goroutines，如果不能及时从阻塞中恢复并持续有新的 blocking goroutine 的话，OS 线程数量会线性地增长，这是一种非常不理想的情况.</p>
<h2 id="通过channel通知退出">通过channel通知退出<a hidden class="anchor" aria-hidden="true" href="#通过channel通知退出">#</a></h2>
<p>这个最主要的goroutine退出方式。goroutine虽然不能强制结束另外一个goroutine，但是它是它可以通过channel通知另外一个goroutine你的表演该结束了。常用的方法到处都可以看到，这里也不详细说明了，直接上一个示例：</p>
<p>下面的示例中起了一个goroutine执行cancelByChannel，但是在起它之前还通过time.After返回了一个time.Time类型的channel，该channel上在定时超时时会发送一个当前时间数据。</p>
<p>cancelByChannel每隔1s会检查这个channel上是否有数据接收，如果有数据则退出goroutine，如果没有信号接收就在连接上发送一条数据。所以下面这段代码在运行10s发送10条消息后将退出。</p>
<p>程序起起来后，另开一个终端执行nc localhost:8000（Linux上）或nc localhost 8000（mac 上）可以看到程序执行情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
        <span class="s">&#34;context&#34;</span>
        <span class="s">&#34;fmt&#34;</span>
        <span class="s">&#34;io&#34;</span>
        <span class="s">&#34;net&#34;</span>
        <span class="s">&#34;sync&#34;</span>
        <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">cancelByChannel</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">quit</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
        <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

        <span class="k">for</span> <span class="p">{</span>

                <span class="k">select</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span>
                        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;cancel goroutine by channel!&#34;</span><span class="p">)</span>
                        <span class="k">return</span>
                <span class="k">default</span><span class="p">:</span>
                        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;hello cancelByChannel&#34;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                                <span class="k">return</span>
                        <span class="p">}</span>
                        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;localhost:8000&#34;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="p">}</span>

        <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="p">}</span>

        <span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>

        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">quit</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">go</span> <span class="nf">cancelByChannel</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">quit</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="通过context通知goroutine退出">通过context通知goroutine退出<a hidden class="anchor" aria-hidden="true" href="#通过context通知goroutine退出">#</a></h2>
<p>通过channel通知goroutine退出还有一个更好的方法就是使用context。它本质还是接收一个channel数据，只是是通过ctx.Done()获取。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">Proc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">Proc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">Proc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">Proc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nf">cancel</span><span class="p">()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Proc</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Proc-%d &#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>这种形式的协程关闭和自己写的区别在于自己写的话自己要记录下协程的数量，关闭的chan等等</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>由于Goroutine被设计为只能自己退出，而不能强制退出。在实际使用中，我们可能会因为某些原因被block在Goroutines里面，或由于设计缺陷导致一些Goroutines执行很长的时间。只是基于一些其他语言的经验，我们可能会期望有一种外部机制能够强制结束一个Goroutines。但是这就是Go和Goroutine，它的目的就是要提供一种轻量的，简单的并发方式。保证它这个特性的基础也决定了我们不能用外部方式强制关闭一个Goroutines（额外post译文或博文说明这个问题，此文不深入展开)。所以当你遇到这种情况的时候，你可能需要考虑你的设计是不是足够的Go style，或者你对一些外部依赖是否足够了解了。</p>
<p>参考:<br>
<a href="https://blog.csdn.net/xingwangc2014/article/details/78998727">https://blog.csdn.net/xingwangc2014/article/details/78998727</a><br>
<a href="https://gulu-dev.com/post/2016-02-02-kill-goroutine">https://gulu-dev.com/post/2016-02-02-kill-goroutine</a><br>
<a href="https://blog.csdn.net/soekchl521/article/details/72420535">https://blog.csdn.net/soekchl521/article/details/72420535</a></p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
