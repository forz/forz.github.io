<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>并发原语Sync-Pool源码剖析 | Forz Blog</title>
<meta name="keywords" content="Go源码" />
<meta name="description" content="前言 sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-pool%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="并发原语Sync-Pool源码剖析" />
<meta property="og:description" content="前言 sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-pool%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-21T14:37:59&#43;00:00" />
<meta property="article:modified_time" content="2021-05-21T14:37:59&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并发原语Sync-Pool源码剖析"/>
<meta name="twitter:description" content="前言 sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "并发原语Sync-Pool源码剖析",
      "item": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-pool%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "并发原语Sync-Pool源码剖析",
  "name": "并发原语Sync-Pool源码剖析",
  "description": "前言\u0008 sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来",
  "keywords": [
    "Go源码"
  ],
  "articleBody": "前言\u0008 sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且,如果没有别的对象引用这个被移除的对象的话,这个被移除的对象就会被垃圾回收掉.\n因为 Pool 可以有效地减少新对象的申请,从而提高程序性能,所以 Go 内部库也用到了 sync.Pool,比如 fmt 包,它会使用一个动态大小的 buffer 池做输出缓存,当大量的 goroutine 并发输出的时候,就会创建比较多的 buffer,并且在不需要的时候回收掉。\n有两个知识点你需要记住:\n sync.Pool 本身就是线程安全的,多个 goroutine 可以并发地调用它的方法存取对象; sync.Pool 不可在使用之后再复制使用。  在Go中，sync.Pool提供了对象池的功能。它对外提供了三个方法：New、Get 和 Put。下面用一个简短的例子来说明一下Pool使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var pool *sync.Pool type Person struct { Name string } func init() { pool = \u0026sync.Pool{ New: func() interface{}{ fmt.Println(\"creating a new person\") return new(Person) }, } } func main() { person := pool.Get().(*Person) fmt.Println(\"Get Pool Object：\", person) person.Name = \"first\" pool.Put(person) fmt.Println(\"Get Pool Object：\",pool.Get().(*Person)) fmt.Println(\"Get Pool Object：\",pool.Get().(*Person)) }   结果：\n1 2 3 4 5  creating a new person Get Pool Object： \u0026{} Get Pool Object： \u0026{first} creating a new person Get Pool Object： \u0026{}   这里我用了init方法初始化了一个pool，然后get了三次，put了一次到pool中，如果pool中没有对象，那么会调用New函数创建一个新的对象，否则会重put进去的对象中获取。\nsync.Pool主要在两种场景使用:\n 进程中的 inuse_objects 数过多，gc mark 消耗大量 CPU 进程中的 inuse_objects 数过多，进程 RSS 占用过高  请求生命周期开始时，pool.Get，请求结束时，pool.Put。 在 fasthttp 中有大量应用\nPool Pool 最重要的两个字段是 local 和 victim,因为它们两个主要用来存储空闲的元素。弄清楚这两个字段的处理逻辑,你就能完全掌握 sync.Pool 的实现了。下面我们来看看这两个字段的关系。\n每次垃圾回收的时候,Pool 会把 victim 中的对象移除,然后把 local 的数据给 victim, 这样的话,local 就会被清空,而 victim 就像一个垃圾分拣站,里面的东西可能会被当做垃圾丢弃了,但是里面有用的东西也可能被捡回来重新使用。\nvictim 中的元素如果被 Get 取走,那么这个元素就很幸运,因为它又“活”过来了。但是,如果这个时候 Get 的并发不是很大,元素没有被 Get 取走,那么就会被移除掉,因为没有别人引用它的话,就会被垃圾回收掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // A Pool is a set of temporary objects that may be individually saved and // retrieved. // // Any item stored in the Pool may be removed automatically at any time without // notification. If the Pool holds the only reference when this happens, the // item might be deallocated. // // A Pool is safe for use by multiple goroutines simultaneously. // // Pool's purpose is to cache allocated but unused items for later reuse, // relieving pressure on the garbage collector. That is, it makes it easy to // build efficient, thread-safe free lists. However, it is not suitable for all // free lists. // // An appropriate use of a Pool is to manage a group of temporary items // silently shared among and potentially reused by concurrent independent // clients of a package. Pool provides a way to amortize allocation overhead // across many clients. // // An example of good use of a Pool is in the fmt package, which maintains a // dynamically-sized store of temporary output buffers. The store scales under // load (when many goroutines are actively printing) and shrinks when // quiescent. // // On the other hand, a free list maintained as part of a short-lived object is // not a suitable use for a Pool, since the overhead does not amortize well in // that scenario. It is more efficient to have such objects implement their own // free list. // // A Pool must not be copied after first use. type Pool struct { // 用来标记，当前的 struct 是不能够被 copy 的 \tnoCopy noCopy // local字段存储的是一个poolLocal数组的指针，poolLocal数组大小是goroutine中P的数量，访问时，P的id对应poolLocal数组下标索引，所以Pool的最大个数runtime.GOMAXPROCS() \t// 通过这样的设计，每个P都有了自己的本地空间，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。 \t//有当前主要的空闲可用的元素都存放在 local 字段中,请求元素时也是优先从 local 字段中查找可用的元素。 \tlocal unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal \t// 上面数组的大小，即 P 的个数 \tlocalSize uintptr // size of the local array \t// 同 local 和 localSize，只是在 gc 的过程中保留一次 \tvictim unsafe.Pointer // local from previous cycle \tvictimSize uintptr // size of victims array  // New optionally specifies a function to generate \t// a value when Get would otherwise return nil. \t// It may not be changed concurrently with calls to Get. \t// New函数是在创建pool的时候设置的，当pool没有缓存对象的时候，会调用New方法生成一个新的对象 \tNew func() interface{} }   使用 sync.Pool 只需要指定 sync.Pool 对象的创建方法 New， 则在使用 sync.Pool.Get 失败的情况下，会池的内部会选择性的创建一个新的值。 因此获取到的对象可能是刚被使用完毕放回池中的对象、亦或者是由 New 创建的新对象。\n其内部本质上保存了一个 poolLocal 元素的数组，即 local，每个 poolLocal 都只被一个 P 拥有， 而 victim 则缓存了上一个垃圾回收周期的 local。\npoolLocal是每个调度器(P)存Object的结构体\n而 poolLocal 则由 private 和 shared 两个字段组成：\nprivate是每个调度器私有的，shared是所有调度器公有的，每个调度器pop时的逻辑是: 先看private，没有再看自己的shared，再没有就去其他调度器的shared偷，再没有才是空.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with \t// 128 mod (cache line size) = 0 . \t// poolLocal里面有一个pad数组用来占位用，防止在 cache line 上分配多个 poolLocalInternal从而造成false sharing \t// pad是防止伪共享 \tpad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } // Local per-P Pool appendix. // 当前调度器的内部资源 type poolLocalInternal struct { // private,代表一个缓存的元素,而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine,所以不会有并发的问题。 \t// 当前调度器的私有资源 \tprivate interface{} // Can be used only by the respective P. \t// shared,可以由任意的 P 访问,但是只有本地的 P 才能 pushHead/popHead,其它 P 可以 popTail,相当于只有一个本地的 P 作为生产者(Producer),多个 P 作为消费者(Consumer),它是使用一个 local-free 的 queue 列表实现的。 \t// 所有调度器的公有资源 \tshared poolChain // Local P can pushHead/popHead; any P can popTail. }   从前面结构体的字段不难猜测，private 是一个仅用于当前 P 进行读写的字段（即没有并发读写的问题）， 而 shared 则遵循字面意思，可以在多个 P 之间进行共享读写，是一个 poolChain 链式队列结构， 我们先记住这个结构在局部 P 上可以进行 pushHead 和 popHead 操作（队头读写）， 在所有 P 上都可以进行 popTail （队尾出队）操作，之后再来详细看它的实现细节。\nPoolChain poolChain是一个双端队列，里面的head和tail分别指向队列头尾；poolDequeue里面存放真正的数据，是一个单生产者、多消费者的固定大小的无锁的环状队列，headTail是环状队列的首位位置的指针，可以通过位运算解析出首尾的位置.\npoolChain 实际上是多个生产者消费者模型的链表。 对于一个局部 P 而言，充当了多个队头的单一生产者，它可以安全的 在整个链表中所串联的队列的队头进行操作。 而其他的多个 P 而言，则充当了多个队尾的消费者， 可以在所串联的队列的队尾进行消费（偷取）。\npopHead 操作发生在从本地 shared 队列中消费并获取对象（消费者）。 pushHead 操作发生在向本地 shared 队列中放置对象（生产者）。 popTail 操作则发生在从其他 P 的 shared 队列中偷取的过程。\n这个双端队列的模型大概是这个样子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // poolChain is a dynamically-sized version of poolDequeue. // // This is implemented as a doubly-linked list queue of poolDequeues // where each dequeue is double the size of the previous one. Once a // dequeue fills up, this allocates a new one and only ever pushes to // the latest dequeue. Pops happen from the other end of the list and // once a dequeue is exhausted, it gets removed from the list. type poolChain struct { // head is the poolDequeue to push to. This is only accessed \t// by the producer, so doesn't need to be synchronized. \t// 头指针，只能单一producer操作(push, pop) \thead *poolChainElt // tail is the poolDequeue to popTail from. This is accessed \t// by consumers, so reads and writes must be atomic. \t// 尾指针，可以被多个consumer pop，必须是原子操作 \ttail *poolChainElt }   从 poolChainElt 的结构我们可以看出，这是一个双向队列，包含 next 和 prev 指针：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type poolChainElt struct { poolDequeue // next and prev link to the adjacent poolChainElts in this \t// poolChain. \t// \t// next is written atomically by the producer and read \t// atomically by the consumer. It only transitions from nil to \t// non-nil. \t// \t// prev is written atomically by the consumer and read \t// atomically by the producer. It only transitions from \t// non-nil to nil. \tnext, prev *poolChainElt }   1 2 3 4 5 6  func storePoolChainElt(pp **poolChainElt, v *poolChainElt) { atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(pp)), unsafe.Pointer(v)) } func loadPoolChainElt(pp **poolChainElt) *poolChainElt { return (*poolChainElt)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(pp)))) }   pushHead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func (c *poolChain) pushHead(val interface{}) { d := c.head // 如果head为nil，说明队列现在是空的，那么新建一个节点，将head和tail都指向这个节点 \t// 如果链表空，则创建一个新的链表 \tif d == nil { // Initialize the chain. \t// 固定长度为 8，必须为 2 的指数 \tconst initSize = 8 // Must be a power of 2 \td = new(poolChainElt) d.vals = make([]eface, initSize) c.head = d // 设置尾指针 \tstorePoolChainElt(\u0026c.tail, d) } // 将val push到head的环形队列中，如果push成功了，可以返回了 \tif d.pushHead(val) { return } // The current dequeue is full. Allocate a new one of twice \t// the size. \t// 如果没push成功，则说明head的环形队列满了，就再创建一个两倍head大小的节点[最大(1 \tnewSize := len(d.vals) * 2 if newSize = dequeueLimit { // Can't make it any bigger. \tnewSize = dequeueLimit } // 创建一个新的poolChainElt并在链表头部插入 \td2 := \u0026poolChainElt{prev: d} d2.vals = make([]eface, newSize) // 将新节点作为head，并且处理好新head和旧head的next，prev关系 \tc.head = d2 storePoolChainElt(\u0026d.next, d2) // 将val push到head的环形队列中 \td2.pushHead(val) }   popHead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func (c *poolChain) popHead() (interface{}, bool) { // 先在head环形队列中popHead试试 \td := c.head for d != nil { // 能取到就返回，取不到说明队列空了 \t// d 是一个 poolDequeue，如果 d.popHead 是并发安全的， \t// 那么这里取 val 也是并发安全的。若 d.popHead 失败，则 \t// 说明需要重新尝试。这个过程会持续到整个链表为空。 \tif val, ok := d.popHead(); ok { return val, ok } // There may still be unconsumed elements in the \t// previous dequeue, so try backing up. \t// 如果空了，当前节点就没用了，就删掉当前节点，去prev节点并且把prev节点作为新head再取一值递归下去， \td = loadPoolChainElt(\u0026d.prev) } return nil, false }   popTail 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  func (c *poolChain) popTail() (interface{}, bool) { d := loadPoolChainElt(\u0026c.tail) // 如果tail为nil，说明队列是空的，直接返回 \tif d == nil { return nil, false } // 如果tail非nil，就取取试试，有东西就返回 \tfor { // It's important that we load the next pointer \t// *before* popping the tail. In general, d may be \t// transiently empty, but if next is non-nil before \t// the pop and the pop fails, then d is permanently \t// empty, which is the only condition under which it's \t// safe to drop d from the chain. \td2 := loadPoolChainElt(\u0026d.next) // 尝试从当前poolChainElt的队列尾部取，成功则直接返回 \tif val, ok := d.popTail(); ok { return val, ok } // 如果没取出来东西，那么说明tail节点没存东西了，递归去prev节点环形队列中popTail，并且把prev节点作为tail，能取到就返回，取不到就是空了 \tif d2 == nil { // This is the only dequeue. It's empty right \t// now, but could be pushed to in the future. \t// d2为空表明链表只有一个节点，而从该节点取对象已失败，则返回 \treturn nil, false } // The tail of the chain has been drained, so move on \t// to the next dequeue. Try to drop it from the chain \t// so the next pop doesn't have to look at the empty \t// dequeue again. \tif atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(\u0026c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) { // We won the race. Clear the prev pointer so \t// the garbage collector can collect the empty \t// dequeue and so popHead doesn't back up \t// further than necessary. \tstorePoolChainElt(\u0026d2.prev, nil) } d = d2 } }   poolDequeue poolDequeue 是一个无锁、固定大小的单生产端多消费端的环形队列，单一 producer 可以在头部 push 和 pop(可能和传统队列头部只能 push 的定义不同)，多 consumer 可以在尾部 pop.\neface 数组存储了实际的对象，其 eface 依赖运行时对 interface{} 的实现，即一个 interface{} 由 typ 和 val 两段数据组成\npoolDequeue里面的环状队列大小是固定的，当环状队列满了的时候会创建一个size是原来两倍大小的环状队列。最大扩展到 dequeueLimit = (1 ，之后就不会扩展了.\n为什么vals长度必须是2的幂?这是因为go的内存管理策略是将内存分为2的幂大小的链表，申请2的幂大小的内存可以有效减小分配内存的开销\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  // poolDequeue is a lock-free fixed-size single-producer, // multi-consumer queue. The single producer can both push and pop // from the head, and consumers can pop from the tail. // // It has the added feature that it nils out unused slots to avoid // unnecessary retention of objects. This is important for sync.Pool, // but not typically a property considered in the literature. type poolDequeue struct { // headTail packs together a 32-bit head index and a 32-bit \t// tail index. Both are indexes into vals modulo len(vals)-1. \t// \t// tail = index of oldest data in queue \t// head = index of next slot to fill \t// \t// Slots in the range [tail, head) are owned by consumers. \t// A consumer continues to own a slot outside this range until \t// it nils the slot, at which point ownership passes to the \t// producer. \t// \t// The head index is stored in the most-significant bits so \t// that we can atomically add to it and the overflow is \t// harmless. \theadTail uint64 // vals is a ring buffer of interface{} values stored in this \t// dequeue. The size of this must be a power of 2. \t// \t// vals[i].typ is nil if the slot is empty and non-nil \t// otherwise. A slot is still in use until *both* the tail \t// index has moved beyond it and typ has been set to nil. This \t// is set to nil atomically by the consumer and read \t// atomically by the producer. \tvals []eface } // 存储元素的结构体，类型指针和值指针 // Pool 底层用 eface 来存储单个 Object, 包括 typ 指针: Object 的类型，val 指针: Object 的值 type eface struct { typ, val unsafe.Pointer } // dequeueLimit is the maximum size of a poolDequeue. // // This must be at most (1// depends on wrapping around the ring buffer without wrapping around // the index. We divide by 4 so this fits in an int on 32-bit.  // 为什么dequeueLimit是(1 // dequeueLimit 必须是2的幂(上边解释过) // head和tail都是32位，最大是1 const dequeueLimit = (1  dequeueBits) / 4 // dequeueNil is used in poolDeqeue to represent interface{}(nil). // Since we use nil to represent empty slots, we need a sentinel value // to represent nil. type dequeueNil *struct{}   headTail 字段的前 32 位 表示了下一个需要被填充的对象槽的索引，而后 32 位则表示了队列中最先被插入的数据的索引\nheadTail:\n1 2 3 4 5 6  [hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh tttttttt tttttttt tttttttt tttttttt] 1. headTail表示下标，高32位表示头下标，低32位表示尾下标，poolDequeue定义了，head tail的pack和unpack函数方便转化， 实际用的时候都会mod ( len(vals) - 1 ) 来防止溢出 2. head和tail永远只用32位表示，溢出后会从0开始，这也满足循环队列的设计 3. 队列为空的条件 tail == head 4. 队列满的条件 (tail+uint32(len(d.vals)))\u0026(1dequeueBits-1) == head tail加上队列长度和head相等(实际上就是队列已有的空间都有值了,满了)   正如前面所说 poolDequeue 是一个单生产者、多消费者的固定长度的环状队列， popHead、pushHead 由局部的 P 操作队首，而 popTail 由其他并行的 P 操作队尾。 其中 headTail 字段的前 32 位表示了下一个需要被填充的对象槽的索引， 而后 32 位则表示了队列中最先被插入的数据的索引。\n通过 pack和unpack方法来实现对head和tail的读写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const dequeueBits = 32 // 将headTail分解为head和tail func (d *poolDequeue) unpack(ptrs uint64) (head, tail uint32) { const mask = 1dequeueBits - 1 head = uint32((ptrs  dequeueBits) \u0026 mask) tail = uint32(ptrs \u0026 mask) return } // 将head和tail组合成headTail func (d *poolDequeue) pack(head, tail uint32) uint64 { const mask = 1dequeueBits - 1 return (uint64(head)  dequeueBits) | uint64(tail\u0026mask) }   从 poolChain 的实现中我们可以看到，每个 poolDequeue 的 vals 长度为 8。 但由于是循环队列，实现中并不关心队列的长度，只要首尾元素的索引相等，则说明队列已满。 因此通过 CAS 原语实现单一生产者的对队头的读 popHead 和写 pushHead：\npopHead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // popHead removes and returns the element at the head of the queue. // It returns false if the queue is empty. It must only be called by a // single producer. // 获取并删除队首元素 func (d *poolDequeue) popHead() (interface{}, bool) { var slot *eface for { ptrs := atomic.LoadUint64(\u0026d.headTail) head, tail := d.unpack(ptrs) if tail == head { // Queue is empty. \t// 队列为空，获取对象失败 \treturn nil, false } // Confirm tail and decrement head. We do this before \t// reading the value to take back ownership of this \t// slot. \t// 因为head是下一个对象存储的位置，因此从队列头部获取对象需先将head-1 \thead-- ptrs2 := d.pack(head, tail) if atomic.CompareAndSwapUint64(\u0026d.headTail, ptrs, ptrs2) { // We successfully took back slot. \tslot = \u0026d.vals[head\u0026uint32(len(d.vals)-1)] break } } val := *(*interface{})(unsafe.Pointer(slot)) if val == dequeueNil(nil) { val = nil } // Zero the slot. Unlike popTail, this isn't racing with \t// pushHead, so we don't need to be careful here. \t// 重置slot \t*slot = eface{} return val, true }   pushHead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // pushHead adds val at the head of the queue. It returns false if the // queue is full. It must only be called by a single producer. // 添加元素到队首 func (d *poolDequeue) pushHead(val interface{}) bool { ptrs := atomic.LoadUint64(\u0026d.headTail) // 解析出head、tail的索引 \thead, tail := d.unpack(ptrs) if (tail+uint32(len(d.vals)))\u0026(1dequeueBits-1) == head { // 队列已满，插入失败 \t// Queue is full. \treturn false } // 找到head的槽位 \tslot := \u0026d.vals[head\u0026uint32(len(d.vals)-1)] // Check if the head slot has been released by popTail. \t// 此处可能与 popTail 发生竞争，参见 popTail \t// 检测这个槽位有没被popTail释放 \ttyp := atomic.LoadPointer(\u0026slot.typ) if typ != nil { // Another goroutine is still cleaning up the tail, so \t// the queue is actually still full. \treturn false } // The head slot is free, so we own it. \tif val == nil { val = dequeueNil(nil) } *(*interface{})(unsafe.Pointer(slot)) = val // Increment head. This passes ownership of slot to popTail \t// and acts as a store barrier for writing the slot. \tatomic.AddUint64(\u0026d.headTail, 1dequeueBits) return true }   popTail 多个消费者读的处理手段非常巧妙，通过 interface{} 的 typ 和 val 两段式 结构的读写先后顺序，在 popTail 和 pushHead 之间消除了竞争\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // popTail removes and returns the element at the tail of the queue. // It returns false if the queue is empty. It may be called by any // number of consumers. // 获取并删除队尾元素 func (d *poolDequeue) popTail() (interface{}, bool) { var slot *eface for { ptrs := atomic.LoadUint64(\u0026d.headTail) head, tail := d.unpack(ptrs) if tail == head { // Queue is empty. \t// 队列为空，直接返回 \treturn nil, false } // Confirm head and tail (for our speculative check \t// above) and increment tail. If this succeeds, then \t// we own the slot at tail. \t// tail+1，表明尾部的对象已被获取 \tptrs2 := d.pack(head, tail+1) if atomic.CompareAndSwapUint64(\u0026d.headTail, ptrs, ptrs2) { // Success. \tslot = \u0026d.vals[tail\u0026uint32(len(d.vals)-1)] break } } // We now own slot. \tval := *(*interface{})(unsafe.Pointer(slot)) if val == dequeueNil(nil) { val = nil } // Tell pushHead that we're done with this slot. Zeroing the \t// slot is also important so we don't leave behind references \t// that could keep this object live longer than necessary. \t// \t// We write to val first and then publish that we're done with \t// this slot by atomically writing to typ. \t// 注意：此处可能与 pushHead 发生竞争，解决方案是： \t// 1. 让 pushHead 先读取 typ 的值，如果 typ 值不为 nil，则说明 popTail 尚未清理完 slot \t// 2. 让 popTail 先清理掉 val 中的内容，在清理掉 typ，从而确保不会与 pushHead 对 slot 的写行为发生竞争 \t// 将slot置空 \tslot.val = nil atomic.StorePointer(\u0026slot.typ, nil) // At this point pushHead owns the slot.  return val, true }   Get 我们来看看 Get 方法的具体实现原理。\n当从池中获取对象时，会先从 per-P 的 poolLocal slice 中选取一个 poolLocal，选择策略遵循：\n 尝试从当前P的private取，成功则直接返回 private获取失败，则从当前P的share链表的头部节点取，成功则返回  从头部节点的队头获取成功，则直接返回 从头部节点获取失败，则从下一节点获取，直至获取成功或遍历完所有节点   当前P的share获取失败，则从其他P的share获取，成功则返回  遍历其他P的share链表直至获取对象成功，返回 从其他P的share链表的尾部的队尾获取对象，若成功则直接返回 若尾部节点的队尾获取对象失败，则表明该节点为空，删除该节点并遍历下一节点，直至获取对象成功或遍历完所有节点   其他P的share获取失败，则尝试从victim cache获取，成功则返回  优先尝试从private获取，成功则返回 若从private获取失败，则遍历victim的poolLocal，尝试从每一个poolLocal的链表尾部获取对象，成功则返回   vitcim获取失败，则创建一个新对象返回  首先,从本地的 private 字段中获取可用元素,因为没有锁, 获取元素的过程会非常快,如果没有获取到,就尝试从本地的 shared 获取一个,如果还没有,会使用 getSlow 方法去其它的 shared 中“偷”一个。最后,如果没有获取到,就尝试使用 New 函数创建一个新的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // Get selects an arbitrary item from the Pool, removes it from the // Pool, and returns it to the caller. // Get may choose to ignore the pool and treat it as empty. // Callers should not assume any relation between values passed to Put and // the values returned by Get. // // If Get would otherwise return nil and p.New is non-nil, Get returns // the result of calling p.New. // Get 从 Pool 中选择一个任意的对象，将其移出 Pool, 并返回给调用方。 // Get 可能会返回一个非零值对象（被其他人使用过），因此调用方不应假设 // 返回的对象具有任何形式的状态。 func (p *Pool) Get() interface{} { if race.Enabled { race.Disable() } // 把当前goroutine固定在当前的P上 \t// 获取一个 poolLocal \tl, pid := p.pin() // 优先从local的private字段取,快速 \t// 先从 private 获取对象 \tx := l.private l.private = nil if x == nil { // Try to pop the head of the local shard. We prefer \t// the head over the tail for temporal locality of \t// reuse. \t// 从当前的local.shared弹出一个,注意是从head读取并移除 \t// 尝试从 localPool 的 shared 队列队头读取， \t// 因为队头的内存局部性比队尾更好。 \tx, _ = l.shared.popHead() if x == nil { // 当前P的private和share都取不到，则去其他P的share读取 \tx = p.getSlow(pid) } } runtime_procUnpin() if race.Enabled { race.Enable() if x != nil { race.Acquire(poolRaceAddr(x)) } } // 如果没有获取到,尝试使用New函数生成一个新的 \t// 如果 getSlow 还是获取不到，则 New 一个 \tif x == nil \u0026\u0026 p.New != nil { x = p.New() } return x }   其实我们不难看出：\n private 只保存了一个对象; 第一次从 shared 中取对象时，还未涉及跨 P 读写，因此 popHead 是可用的； 当 shared 读取不到对象时，说明当前局部 P 所持有的 localPool 不包含任何对象，这时尝试从其他的 localPool 进行偷取。 实在是偷不到，才考虑新创建一个对象。  pin pin 方法会将此 goroutine 固定在当前的 P 上,避免查找元素期间被其它的 P 执行。固定的好处就是查找元素期间直接得到跟这个 P 相关的 local。有一点需要注意的是,pin 方法在执行的时候,如果跟这个 P 相关的 local 还没有创建,或者运行时 P 的数量被修改了的话,就会新创建 local。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // pin pins the current goroutine to P, disables preemption and // returns poolLocal pool for the P and the P's id. // Caller must call runtime_procUnpin() when done with the pool. // 将当前goroutine和P绑定，禁止抢占，并返回对应的poolLocal和P的id // 调用方在调用完成后必须调用runtime_procUnpin方法取消抢占 func (p *Pool) pin() (*poolLocal, int) { // 返回当前 P.id \tpid := runtime_procPin() // In pinSlow we store to local and then to localSize, here we load in opposite order. \t// Since we've disabled preemption, GC cannot happen in between. \t// Thus here we must observe local at least as large localSize. \t// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness). \t// 在 pinSlow 中会存储 localSize 后再存储 local，因此这里反过来读取 \t// 因为我们已经禁用了抢占，这时不会发生 GC \t// 因此，我们必须观察 local 和 localSize 是否对应 \t// 观察到一个全新或很大的的 local 是正常行为 \ts := atomic.LoadUintptr(\u0026p.localSize) // load-acquire \tl := p.local // load-consume \t// 因为可能存在动态的 P（运行时调整 P 的个数）procresize/GOMAXPROCS \t// 如果 P.id 没有越界，则直接返回 \tif uintptr(pid)  s { // 对应的poolLocal已创建，调用indexLocal取出对应的poolLocal返回 \treturn indexLocal(l, pid), pid } // 没有结果时，涉及全局加锁 \t// 例如重新分配数组内存，添加到全局列表 \treturn p.pinSlow() }   pin() 首先会调用运行时实现获得当前 P 的 id，将 P 设置为禁止抢占，达到固定当前 goroutine 的目的。 然后检查 pid 与 p.localSize 的值来确保从 p.local 中取值不会发生越界。 如果不会发生，则调用 indexLocal() 完成取值。否则还需要继续调用 pinSlow()。\n1 2 3 4 5  func indexLocal(l unsafe.Pointer, i int) *poolLocal { // 简单的通过 p.local 的头指针与索引来第 i 个 pooLocal \tlp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{})) return (*poolLocal)(lp) }   在这个过程中我们可以看到在运行时调整 P 的大小的代价。如果此时 P 被调大，而没有对应的 poolLocal 时， 必须在取之前创建好，从而必须依赖全局加锁，这对于以性能著称的池化概念是比较致命的。\n既然需要对全局进行加锁，pinSlow() 会首先取消 P 的禁止抢占，这是因为使用 mutex 时 P 必须为可抢占的状态。 然后使用 allPoolsMu 进行加锁。 当完成加锁后，再重新固定 P ，取其 pid。注意，因为中途可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查。 如果 pid 在 p.local 大小范围内，则不再此时创建，直接返回。\n如果 p.local 为空，则将 p 扔给 allPools 并在垃圾回收阶段回收所有 Pool 实例。 最后再完成对 p.local 的创建（彻底丢弃旧数组）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  var ( allPoolsMu Mutex // allPools 是一组 pool 的集合，具有非空主缓存。 \t// 有两种形式来保护它的读写：1. allPoolsMu 锁; 2. STW. \tallPools []*Pool ) // 对应的poolLocal不存在，则创建 func (p *Pool) pinSlow() (*poolLocal, int) { // Retry under the mutex. \t// Can not lock the mutex while pinned. \t// 这时取消 P 的禁止抢占，因为使用 mutex 时候 P 必须可抢占 \t// 加锁期间须先取消抢占 \truntime_procUnpin() // 加锁 \tallPoolsMu.Lock() defer allPoolsMu.Unlock() // 当锁住后，再次固定 P 取其 id \tpid := runtime_procPin() // poolCleanup won't be called while we are pinned. \t// 并再次检查是否符合条件，因为可能中途已被其他线程调用 \t// 当再次固定 P 时 poolCleanup 不会被调用 \ts := p.localSize l := p.local // 第二次检测，因为在加锁过程中可能别的goroutine调用创建了poolLocal \tif uintptr(pid)  s { return indexLocal(l, pid), pid } // 如果数组为空，新建 \t// 将其添加到 allPools，垃圾回收器从这里获取所有 Pool 实例 \tif p.local == nil { allPools = append(allPools, p) } // 根据 P 数量创建 slice，如果 GOMAXPROCS 在 GC 间发生变化 \t// 我们重新分配此数组并丢弃旧的 \t// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one. \tsize := runtime.GOMAXPROCS(0) local := make([]poolLocal, size) // 将底层数组起始指针保存到 p.local，并设置 p.localSize \tatomic.StorePointer(\u0026p.local, unsafe.Pointer(\u0026local[0])) // store-release \tatomic.StoreUintptr(\u0026p.localSize, uintptr(size)) // store-release \t// 返回所需的 pollLocal \treturn \u0026local[pid], pid }   getSlow 终于，我们获取到了 poolLocal，现在回到我们 Get 的取值过程。在取对象的过程中，我们仍然会面临 既不能从 private 取、也不能从 shared 中取得尴尬境地。这时候就来到了 getSlow()。\n试想，如果我们在本地的 P 中取不到值，是不是可以考虑从别人那里偷一点过来？总会比创建一个新的要快。 因此，我们再次固定 P，并取得当前的 P.id 来从其他 P 中偷值，那么我们需要先获取到其他 P 对应的 poolLocal。假设 size 为数组的大小，local 为 p.local，那么尝试遍历其他所有 P\n它首先要遍历所有的 local,尝试从它们的 shared 弹出一个元素。如果还没找到一个,那么,就开始对 victim 下手了。\n在 vintim 中查询可用元素的逻辑还是一样的,先从对应的 victim 的 private 查找,如果查不到,就再从其它 victim 的 shared 中查找。\n下面的代码是 getSlow 方法的主要逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  func (p *Pool) getSlow(pid int) interface{} { // See the comment in pin regarding ordering of the loads. \tsize := atomic.LoadUintptr(\u0026p.localSize) // load-acquire \tlocals := p.local // load-consume \t// Try to steal one element from other procs. \t// 尝试从其他P获取对象，成功则直接返回 \tfor i := 0; i  int(size); i++ { // 获取目标 poolLocal, 引入 pid 保证不是自身 \tl := indexLocal(locals, (pid+i+1)%int(size)) // 从其他的 P 中固定的 localPool 的 share 队列的队尾偷一个缓存对象 \tif x, _ := l.shared.popTail(); x != nil { return x } } // Try the victim cache. We do this after attempting to steal \t// from all primary caches because we want objects in the \t// victim cache to age out if at all possible. \t// 如果其它proc也没有可用元素,那么尝试从vintim中获取 \t// 当 local 失败后，尝试再尝试从上一个垃圾回收周期遗留下来的 victim。 \t// 如果 pid 比 victim 遗留的 localPool 还大，则说明从根据此 pid 从 \t// victim 获取 localPool 会发生越界（同时也表明此时 P 的数量已经发生变化） \t// 这时无法继续读取，直接返回 nil \t// 尝试从victim cache中获取对象 \tsize = atomic.LoadUintptr(\u0026p.victimSize) if uintptr(pid) = size { return nil } // 获取 localPool，并优先读取 private \tlocals = p.victim l := indexLocal(locals, pid) // 同样的逻辑,先从vintim中的local private获取 \tif x := l.private; x != nil { l.private = nil return x } for i := 0; i  int(size); i++ { // 从vintim其它proc尝试偷取 \tl := indexLocal(locals, (pid+i)%int(size)) // 从其他的 P 中固定的 localPool 的 share 队列的队尾偷一个缓存对象 \tif x, _ := l.shared.popTail(); x != nil { return x } } // Mark the victim cache as empty for future gets don't bother \t// with it. \t// 如果victim中都没有,则把这个victim标记为空,以后的查找可以快速跳过了 \t// 将 victim 缓存置空，从而确保之后的 get 操作不再读取此处的值 \t// 清空 victim cache。下次就不用再从这里找了 \tatomic.StoreUintptr(\u0026p.victimSize, 0) return nil }   我们来证明一下此处确实不会发生取到自身的情况，不妨设：pid = (pid+i+1)%size 则 pid+i+1 = a*size+pid。 即：a*size = i+1，其中 a 为整数。由于 i，于是 a*size = i+1 ，则： (a-1)*size size ，由于 size 为非负整数，这是不可能的。\nPut Put 的过程则相对简单，只需要将对象放回到池中。 与 Get 取出一样，放回遵循策略：\n 尝试将对象存储在当前P的private，成功则直接返回 存入private失败，则尝试存入当前P的share链表的头部节点的队头，成功则返回 若链表头部节点的队列已满存入失败，则创建一个新节点，节点队列大小为原来的两倍，将对象存入新节点， 并将该节点设置为新的头部节点  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // Put adds x to the pool. func (p *Pool) Put(x interface{}) { // 如果存入对象为nil直接返回 \tif x == nil { return } if race.Enabled { if fastrand()%4 == 0 { // Randomly drop x on floor. \treturn } race.ReleaseMerge(poolRaceAddr(x)) race.Disable() } // 获得一个 localPool \tl, _ := p.pin() // 优先放入 private \tif l.private == nil { l.private = x x = nil } // 如果不能放入 private 则放入 shared \tif x != nil { l.shared.pushHead(x) } runtime_procUnpin() if race.Enabled { race.Enable() } }   runtime_procUnpin \u0026 runtime_procPin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //go:linkname sync_runtime_procPin sync.runtime_procPin //go:nosplit func sync_runtime_procPin() int { return procPin() } //go:linkname sync_runtime_procUnpin sync.runtime_procUnpin //go:nosplit func sync_runtime_procUnpin() { procUnpin() } //go:nosplit func procPin() int { _g_ := getg() mp := _g_.m mp.locks++ return int(mp.p.ptr().id) } //go:nosplit func procUnpin() { _g_ := getg() _g_.m.locks-- }   PoolCleanup sync.Pool 的垃圾回收发生在运行时 GC 开始之前。\n在 src/sync/pool.go 中:\n1 2 3 4 5 6 7  // 将缓存清理函数注册到运行时 GC 时间段 func init() { runtime_registerPoolCleanup(poolCleanup) } // 由运行时实现 func runtime_registerPoolCleanup(cleanup func())   在 src/runtime/mgc.go 中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 开始 GC func gcStart(trigger gcTrigger) { ... clearpools() ... } // 实现缓存清理 func clearpools() { // clear sync.Pools \tif poolcleanup != nil { poolcleanup() } ... } var poolcleanup func() // 利用编译器标志将 sync 包中的清理注册到运行时 //go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup func sync_runtime_registerPoolCleanup(f func()) { poolcleanup = f }   再来看实际的清理函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  var ( allPoolsMu Mutex // allPools is the set of pools that have non-empty primary \t// caches. Protected by either 1) allPoolsMu and pinning or 2) \t// STW. \tallPools []*Pool // oldPools is the set of pools that may have non-empty victim \t// caches. Protected by STW. \t// oldPools 是一组 pool 的集合，具有非空 victim 缓存。由 STW 保护 \toldPools []*Pool ) func poolCleanup() { // 该函数会注册到运行时 GC 阶段(前)，此时为 STW 状态，不需要加锁 \t// 它必须不处理分配且不调用任何运行时函数。  // 由于此时是 STW，不存在用户态代码能尝试读取 localPool，进而所有的 P 都已固定（与 goroutine 绑定）  // 从所有的 oldPools 中删除 victim \tfor _, p := range oldPools { p.victim = nil p.victimSize = 0 } // 将主缓存移动到 victim 缓存 \tfor _, p := range allPools { p.victim = p.local p.victimSize = p.localSize p.local = nil p.localSize = 0 } // 具有非空主缓存的池现在具有非空的 victim 缓存，并且没有任何 pool 具有主缓存。 \toldPools, allPools = allPools, nil }   注意，即便是最后 p.local 已经被置换到 oldPools 的 p.victim，其中的缓存对象仍然有可能被偷取放回到 allPools 中，从而延缓了 victim 中缓存对象被回收的速度。\n小结 至此，我们完整分析了 sync.Pool 的所有代码。总结：\n1 2 3 4 5 6 7 8 9  goroutine goroutine goroutine | | | P P P | | | private private private | | | [ poolLocal poolLocal poolLocal ] sync.Pool | | | shared shared shared   一个 goroutine 固定在 P 上，从当前 P 对应的 private 取值， shared 字段作为一个优化过的链式无锁变长队列，当在 private 取不到值的情况下， 从对应的 shared 队列的队首取，若还是取不到，则尝试从其他 P 的 shared 队列队尾中偷取。 若偷不到，则尝试从上一个 GC 周期遗留到 victim 缓存中取，否则调用 New 创建一个新的对象。\n对于回收而言，池中所有临时对象在一次 GC 后会被放入 victim 缓存中， 而前一个周期被放入 victim 的缓存则会被清理掉。\n对于调用方而言，当 Get 到临时对象后，便脱离了池本身不受控制。 用方有责任将使用完的对象放回池中。\n本文中介绍的 sync.Pool 实现为 Go 1.13 优化过后的版本，相较于之前的版本，主要有以下几点优化：\n 引入了 victim （二级）缓存，每次 GC 周期不再清理所有的缓存对象，而是将 locals 中的对象暂时放入 victim ，从而延迟到下一个 GC 周期进行回收； 在下一个周期到来前，victim 中的缓存对象可能会被偷取，在 Put 操作后又重新回到 locals 中，这个过程发生在从其他 P 的 shared 队列中偷取不到、以及 New 一个新对象之前，进而是在牺牲了 New 新对象的速度的情况下换取的； poolLocal 不再使用 Mutex 这类昂贵的锁来保证并发安全，取而代之的是使用了 CAS 算法优化实现的 poolChain 变长无锁双向链式队列。  这种两级缓存的优化的优势在于：\n 显著降低了 GC 发生前清理当前周期中产生的大量缓存对象的影响：因为回收被推迟到了下个 GC 周期； 显著降低了 GC 发生后 New 对象的成本：因为密集的缓存对象读写可能从上个周期中未清理的对象中偷取。  参考 https://colobu.com/2017/07/11/dive-into-sync-Map\nhttps://segmentfault.com/a/1190000015242373\nhttps://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/\nhttp://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html\nhttp://www.gogodjzhu.com/index.php/code/basic/397/\nhttp://russellluo.com/2017/06/go-sync-map-diagram.html\n5.4 条件变量\n5.5 同步组\nGo 标准库源码分析 - sync 包的Pool\n5.7 并发安全散列表\n6.1 上下文 Context\ngo context剖析之源码分析\n5.3 原子操作\n多图详解Go的sync.Pool源码\n",
  "wordCount" : "11980",
  "inLanguage": "zh-cn",
  "datePublished": "2021-05-21T14:37:59Z",
  "dateModified": "2021-05-21T14:37:59Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADsync-pool%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      并发原语Sync-Pool源码剖析
    </h1>
    <div class="post-meta">May 21, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>sync.Pool 数据类型用来保存一组可独立访问的临时对象。请注意这里的“临时”这两个字,它说明了 sync.Pool 这个数据类型的特点,也就是说,它池化的对象会在未来的某个时候被毫无预兆地移除掉。而且,如果没有别的对象引用这个被移除的对象的话,这个被移除的对象就会被垃圾回收掉.</p>
<p>因为 Pool 可以有效地减少新对象的申请,从而提高程序性能,所以 Go 内部库也用到了 sync.Pool,比如 fmt 包,它会使用一个动态大小的 buffer 池做输出缓存,当大量的 goroutine 并发输出的时候,就会创建比较多的 buffer,并且在不需要的时候回收掉。</p>
<p>有两个知识点你需要记住:</p>
<ol>
<li>sync.Pool 本身就是线程安全的,多个 goroutine 可以并发地调用它的方法存取对象;</li>
<li>sync.Pool 不可在使用之后再复制使用。</li>
</ol>
<p>在Go中，sync.Pool提供了对象池的功能。它对外提供了三个方法：New、Get 和 Put。下面用一个简短的例子来说明一下Pool使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">pool</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Pool</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pool</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Pool</span><span class="p">{</span>
		<span class="nx">New</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;creating a new person&#34;</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Person</span><span class="p">)</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">person</span> <span class="o">:=</span> <span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">Person</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Get Pool Object：&#34;</span><span class="p">,</span> <span class="nx">person</span><span class="p">)</span>

	<span class="nx">person</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;first&#34;</span>
	<span class="nx">pool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Get Pool Object：&#34;</span><span class="p">,</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">Person</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Get Pool Object：&#34;</span><span class="p">,</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">Person</span><span class="p">))</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">creating</span> <span class="n">a</span> <span class="n">new</span> <span class="n">person</span>
<span class="n">Get</span> <span class="n">Pool</span> <span class="n">Object</span>： <span class="o">&amp;</span><span class="p">{}</span>
<span class="n">Get</span> <span class="n">Pool</span> <span class="n">Object</span>： <span class="o">&amp;</span><span class="p">{</span><span class="n">first</span><span class="p">}</span>
<span class="n">creating</span> <span class="n">a</span> <span class="n">new</span> <span class="n">person</span>
<span class="n">Get</span> <span class="n">Pool</span> <span class="n">Object</span>： <span class="o">&amp;</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里我用了init方法初始化了一个pool，然后get了三次，put了一次到pool中，如果pool中没有对象，那么会调用New函数创建一个新的对象，否则会重put进去的对象中获取。</p>
<p>sync.Pool主要在两种场景使用:</p>
<ul>
<li>进程中的 inuse_objects 数过多，gc mark 消耗大量 CPU</li>
<li>进程中的 inuse_objects 数过多，进程 RSS 占用过高</li>
</ul>
<p>请求生命周期开始时，pool.Get，请求结束时，pool.Put。 在 fasthttp 中有大量应用</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210819154912.png" alt=""  />
</p>
<h2 id="pool">Pool<a hidden class="anchor" aria-hidden="true" href="#pool">#</a></h2>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210126160150.png" alt=""  />
</p>
<p>Pool 最重要的两个字段是 local 和 victim,因为它们两个主要用来存储空闲的元素。弄清楚这两个字段的处理逻辑,你就能完全掌握 sync.Pool 的实现了。下面我们来看看这两个字段的关系。</p>
<p>每次垃圾回收的时候,Pool 会把 victim 中的对象移除,然后把 local 的数据给 victim, 这样的话,local 就会被清空,而 victim 就像一个垃圾分拣站,里面的东西可能会被当做垃圾丢弃了,但是里面有用的东西也可能被捡回来重新使用。</p>
<p>victim 中的元素如果被 Get 取走,那么这个元素就很幸运,因为它又“活”过来了。但是,如果这个时候 Get 的并发不是很大,元素没有被 Get 取走,那么就会被移除掉,因为没有别人引用它的话,就会被垃圾回收掉。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A Pool is a set of temporary objects that may be individually saved and
</span><span class="c1">// retrieved.
</span><span class="c1">//
</span><span class="c1">// Any item stored in the Pool may be removed automatically at any time without
</span><span class="c1">// notification. If the Pool holds the only reference when this happens, the
</span><span class="c1">// item might be deallocated.
</span><span class="c1">//
</span><span class="c1">// A Pool is safe for use by multiple goroutines simultaneously.
</span><span class="c1">//
</span><span class="c1">// Pool&#39;s purpose is to cache allocated but unused items for later reuse,
</span><span class="c1">// relieving pressure on the garbage collector. That is, it makes it easy to
</span><span class="c1">// build efficient, thread-safe free lists. However, it is not suitable for all
</span><span class="c1">// free lists.
</span><span class="c1">//
</span><span class="c1">// An appropriate use of a Pool is to manage a group of temporary items
</span><span class="c1">// silently shared among and potentially reused by concurrent independent
</span><span class="c1">// clients of a package. Pool provides a way to amortize allocation overhead
</span><span class="c1">// across many clients.
</span><span class="c1">//
</span><span class="c1">// An example of good use of a Pool is in the fmt package, which maintains a
</span><span class="c1">// dynamically-sized store of temporary output buffers. The store scales under
</span><span class="c1">// load (when many goroutines are actively printing) and shrinks when
</span><span class="c1">// quiescent.
</span><span class="c1">//
</span><span class="c1">// On the other hand, a free list maintained as part of a short-lived object is
</span><span class="c1">// not a suitable use for a Pool, since the overhead does not amortize well in
</span><span class="c1">// that scenario. It is more efficient to have such objects implement their own
</span><span class="c1">// free list.
</span><span class="c1">//
</span><span class="c1">// A Pool must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 用来标记，当前的 struct 是不能够被 copy 的
</span><span class="c1"></span>	<span class="nx">noCopy</span> <span class="nx">noCopy</span>
	<span class="c1">// local字段存储的是一个poolLocal数组的指针，poolLocal数组大小是goroutine中P的数量，访问时，P的id对应poolLocal数组下标索引，所以Pool的最大个数runtime.GOMAXPROCS()
</span><span class="c1"></span>	<span class="c1">// 通过这样的设计，每个P都有了自己的本地空间，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。
</span><span class="c1"></span>	<span class="c1">//有当前主要的空闲可用的元素都存放在 local 字段中,请求元素时也是优先从 local 字段中查找可用的元素。
</span><span class="c1"></span>	<span class="nx">local</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local fixed-size per-P pool, actual type is [P]poolLocal
</span><span class="c1"></span>	<span class="c1">// 上面数组的大小，即 P 的个数
</span><span class="c1"></span>	<span class="nx">localSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of the local array
</span><span class="c1"></span>	<span class="c1">// 同 local 和 localSize，只是在 gc 的过程中保留一次
</span><span class="c1"></span>	<span class="nx">victim</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local from previous cycle
</span><span class="c1"></span>	<span class="nx">victimSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of victims array
</span><span class="c1"></span>
	<span class="c1">// New optionally specifies a function to generate
</span><span class="c1"></span>	<span class="c1">// a value when Get would otherwise return nil.
</span><span class="c1"></span>	<span class="c1">// It may not be changed concurrently with calls to Get.
</span><span class="c1"></span>	<span class="c1">// New函数是在创建pool的时候设置的，当pool没有缓存对象的时候，会调用New方法生成一个新的对象
</span><span class="c1"></span>	<span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 sync.Pool 只需要指定 sync.Pool 对象的创建方法 New， 则在使用 sync.Pool.Get 失败的情况下，会池的内部会选择性的创建一个新的值。 因此获取到的对象可能是刚被使用完毕放回池中的对象、亦或者是由 New 创建的新对象。</p>
<p>其内部本质上保存了一个 poolLocal 元素的数组，即 local，每个 poolLocal 都只被一个 P 拥有， 而 victim 则缓存了上一个垃圾回收周期的 local。</p>
<p>poolLocal是每个调度器(P)存Object的结构体</p>
<p>而 poolLocal 则由 private 和 shared 两个字段组成：</p>
<p>private是每个调度器私有的，shared是所有调度器公有的，每个调度器pop时的逻辑是: 先看private，没有再看自己的shared，再没有就去其他调度器的shared偷，再没有才是空.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolLocal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolLocalInternal</span>

	<span class="c1">// Prevents false sharing on widespread platforms with
</span><span class="c1"></span>	<span class="c1">// 128 mod (cache line size) = 0 .
</span><span class="c1"></span>	<span class="c1">// poolLocal里面有一个pad数组用来占位用，防止在 cache line 上分配多个 poolLocalInternal从而造成false sharing
</span><span class="c1"></span>	<span class="c1">// pad是防止伪共享
</span><span class="c1"></span>	<span class="nx">pad</span> <span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocalInternal</span><span class="p">{})</span><span class="o">%</span><span class="mi">128</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="c1">// Local per-P Pool appendix.
</span><span class="c1">// 当前调度器的内部资源
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolLocalInternal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// private,代表一个缓存的元素,而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine,所以不会有并发的问题。
</span><span class="c1"></span>	<span class="c1">// 当前调度器的私有资源
</span><span class="c1"></span>	<span class="nx">private</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// Can be used only by the respective P.
</span><span class="c1"></span>	<span class="c1">// shared,可以由任意的 P 访问,但是只有本地的 P 才能 pushHead/popHead,其它 P 可以 popTail,相当于只有一个本地的 P 作为生产者(Producer),多个 P 作为消费者(Consumer),它是使用一个 local-free 的 queue 列表实现的。
</span><span class="c1"></span>	<span class="c1">// 所有调度器的公有资源
</span><span class="c1"></span>	<span class="nx">shared</span>  <span class="nx">poolChain</span>   <span class="c1">// Local P can pushHead/popHead; any P can popTail.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从前面结构体的字段不难猜测，private 是一个仅用于当前 P 进行读写的字段（即没有并发读写的问题）， 而 shared 则遵循字面意思，可以在多个 P 之间进行共享读写，是一个 poolChain 链式队列结构， 我们先记住这个结构在局部 P 上可以进行 pushHead 和 popHead 操作（队头读写）， 在所有 P 上都可以进行 popTail （队尾出队）操作，之后再来详细看它的实现细节。</p>
<h2 id="poolchain">PoolChain<a hidden class="anchor" aria-hidden="true" href="#poolchain">#</a></h2>
<p>poolChain是一个双端队列，里面的head和tail分别指向队列头尾；poolDequeue里面存放真正的数据，是一个单生产者、多消费者的固定大小的无锁的环状队列，headTail是环状队列的首位位置的指针，可以通过位运算解析出首尾的位置.</p>
<p>poolChain 实际上是多个生产者消费者模型的链表。 对于一个局部 P 而言，充当了多个队头的单一生产者，它可以安全的 在整个链表中所串联的队列的队头进行操作。 而其他的多个 P 而言，则充当了多个队尾的消费者， 可以在所串联的队列的队尾进行消费（偷取）。</p>
<p>popHead 操作发生在从本地 shared 队列中消费并获取对象（消费者）。 pushHead 操作发生在向本地 shared 队列中放置对象（生产者）。 popTail 操作则发生在从其他 P 的 shared 队列中偷取的过程。</p>
<p>这个双端队列的模型大概是这个样子：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210126155840.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// poolChain is a dynamically-sized version of poolDequeue.
</span><span class="c1">//
</span><span class="c1">// This is implemented as a doubly-linked list queue of poolDequeues
</span><span class="c1">// where each dequeue is double the size of the previous one. Once a
</span><span class="c1">// dequeue fills up, this allocates a new one and only ever pushes to
</span><span class="c1">// the latest dequeue. Pops happen from the other end of the list and
</span><span class="c1">// once a dequeue is exhausted, it gets removed from the list.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolChain</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// head is the poolDequeue to push to. This is only accessed
</span><span class="c1"></span>	<span class="c1">// by the producer, so doesn&#39;t need to be synchronized.
</span><span class="c1"></span>	<span class="c1">// 头指针，只能单一producer操作(push, pop)
</span><span class="c1"></span>	<span class="nx">head</span> <span class="o">*</span><span class="nx">poolChainElt</span>

	<span class="c1">// tail is the poolDequeue to popTail from. This is accessed
</span><span class="c1"></span>	<span class="c1">// by consumers, so reads and writes must be atomic.
</span><span class="c1"></span>	<span class="c1">// 尾指针，可以被多个consumer pop，必须是原子操作
</span><span class="c1"></span>	<span class="nx">tail</span> <span class="o">*</span><span class="nx">poolChainElt</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从 poolChainElt 的结构我们可以看出，这是一个双向队列，包含 next 和 prev 指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolChainElt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolDequeue</span>

	<span class="c1">// next and prev link to the adjacent poolChainElts in this
</span><span class="c1"></span>	<span class="c1">// poolChain.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// next is written atomically by the producer and read
</span><span class="c1"></span>	<span class="c1">// atomically by the consumer. It only transitions from nil to
</span><span class="c1"></span>	<span class="c1">// non-nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// prev is written atomically by the consumer and read
</span><span class="c1"></span>	<span class="c1">// atomically by the producer. It only transitions from
</span><span class="c1"></span>	<span class="c1">// non-nil to nil.
</span><span class="c1"></span>	<span class="nx">next</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">poolChainElt</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">storePoolChainElt</span><span class="p">(</span><span class="nx">pp</span> <span class="o">**</span><span class="nx">poolChainElt</span><span class="p">,</span> <span class="nx">v</span> <span class="o">*</span><span class="nx">poolChainElt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">)),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="nx">pp</span> <span class="o">**</span><span class="nx">poolChainElt</span><span class="p">)</span> <span class="o">*</span><span class="nx">poolChainElt</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolChainElt</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="pushhead">pushHead<a hidden class="anchor" aria-hidden="true" href="#pushhead">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">poolChain</span><span class="p">)</span> <span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">head</span>
	<span class="c1">// 如果head为nil，说明队列现在是空的，那么新建一个节点，将head和tail都指向这个节点
</span><span class="c1"></span>	<span class="c1">// 如果链表空，则创建一个新的链表
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Initialize the chain.
</span><span class="c1"></span>		<span class="c1">// 固定长度为 8，必须为 2 的指数
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">initSize</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// Must be a power of 2
</span><span class="c1"></span>		<span class="nx">d</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">poolChainElt</span><span class="p">)</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">vals</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">eface</span><span class="p">,</span> <span class="nx">initSize</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">d</span>
		<span class="c1">// 设置尾指针
</span><span class="c1"></span>		<span class="nf">storePoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 将val push到head的环形队列中，如果push成功了，可以返回了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// The current dequeue is full. Allocate a new one of twice
</span><span class="c1"></span>	<span class="c1">// the size.
</span><span class="c1"></span>	<span class="c1">// 如果没push成功，则说明head的环形队列满了，就再创建一个两倍head大小的节点[最大(1 &lt;&lt; 32) / 4]，
</span><span class="c1"></span>	<span class="nx">newSize</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
	<span class="k">if</span> <span class="nx">newSize</span> <span class="o">&gt;=</span> <span class="nx">dequeueLimit</span> <span class="p">{</span>
		<span class="c1">// Can&#39;t make it any bigger.
</span><span class="c1"></span>		<span class="nx">newSize</span> <span class="p">=</span> <span class="nx">dequeueLimit</span>
	<span class="p">}</span>
	<span class="c1">// 创建一个新的poolChainElt并在链表头部插入
</span><span class="c1"></span>	<span class="nx">d2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">poolChainElt</span><span class="p">{</span><span class="nx">prev</span><span class="p">:</span> <span class="nx">d</span><span class="p">}</span>
	<span class="nx">d2</span><span class="p">.</span><span class="nx">vals</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">eface</span><span class="p">,</span> <span class="nx">newSize</span><span class="p">)</span>
	<span class="c1">// 将新节点作为head，并且处理好新head和旧head的next，prev关系
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">d2</span>
	<span class="nf">storePoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">d2</span><span class="p">)</span>
	<span class="c1">// 将val push到head的环形队列中
</span><span class="c1"></span>	<span class="nx">d2</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="pophead">popHead<a hidden class="anchor" aria-hidden="true" href="#pophead">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">poolChain</span><span class="p">)</span> <span class="nf">popHead</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 先在head环形队列中popHead试试
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 能取到就返回，取不到说明队列空了
</span><span class="c1"></span>		<span class="c1">// d 是一个 poolDequeue，如果 d.popHead 是并发安全的，
</span><span class="c1"></span>		<span class="c1">// 那么这里取 val 也是并发安全的。若 d.popHead 失败，则
</span><span class="c1"></span>		<span class="c1">// 说明需要重新尝试。这个过程会持续到整个链表为空。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">popHead</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span>
		<span class="p">}</span>
		<span class="c1">// There may still be unconsumed elements in the
</span><span class="c1"></span>		<span class="c1">// previous dequeue, so try backing up.
</span><span class="c1"></span>		<span class="c1">// 如果空了，当前节点就没用了，就删掉当前节点，去prev节点并且把prev节点作为新head再取一值递归下去，
</span><span class="c1"></span>		<span class="nx">d</span> <span class="p">=</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">prev</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="poptail">popTail<a hidden class="anchor" aria-hidden="true" href="#poptail">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">poolChain</span><span class="p">)</span> <span class="nf">popTail</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span>
	<span class="c1">// 如果tail为nil，说明队列是空的，直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 如果tail非nil，就取取试试，有东西就返回
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// It&#39;s important that we load the next pointer
</span><span class="c1"></span>		<span class="c1">// *before* popping the tail. In general, d may be
</span><span class="c1"></span>		<span class="c1">// transiently empty, but if next is non-nil before
</span><span class="c1"></span>		<span class="c1">// the pop and the pop fails, then d is permanently
</span><span class="c1"></span>		<span class="c1">// empty, which is the only condition under which it&#39;s
</span><span class="c1"></span>		<span class="c1">// safe to drop d from the chain.
</span><span class="c1"></span>		<span class="nx">d2</span> <span class="o">:=</span> <span class="nf">loadPoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
		<span class="c1">// 尝试从当前poolChainElt的队列尾部取，成功则直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span>
		<span class="p">}</span>
		<span class="c1">// 如果没取出来东西，那么说明tail节点没存东西了，递归去prev节点环形队列中popTail，并且把prev节点作为tail，能取到就返回，取不到就是空了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// This is the only dequeue. It&#39;s empty right
</span><span class="c1"></span>			<span class="c1">// now, but could be pushed to in the future.
</span><span class="c1"></span>			<span class="c1">// d2为空表明链表只有一个节点，而从该节点取对象已失败，则返回
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="c1">// The tail of the chain has been drained, so move on
</span><span class="c1"></span>		<span class="c1">// to the next dequeue. Try to drop it from the chain
</span><span class="c1"></span>		<span class="c1">// so the next pop doesn&#39;t have to look at the empty
</span><span class="c1"></span>		<span class="c1">// dequeue again.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">tail</span><span class="p">)),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d2</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// We won the race. Clear the prev pointer so
</span><span class="c1"></span>			<span class="c1">// the garbage collector can collect the empty
</span><span class="c1"></span>			<span class="c1">// dequeue and so popHead doesn&#39;t back up
</span><span class="c1"></span>			<span class="c1">// further than necessary.
</span><span class="c1"></span>			<span class="nf">storePoolChainElt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d2</span><span class="p">.</span><span class="nx">prev</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">d</span> <span class="p">=</span> <span class="nx">d2</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="pooldequeue">poolDequeue<a hidden class="anchor" aria-hidden="true" href="#pooldequeue">#</a></h2>
<p>poolDequeue 是一个无锁、固定大小的单生产端多消费端的环形队列，单一 producer 可以在头部 push 和 pop(可能和传统队列头部只能 push 的定义不同)，多 consumer 可以在尾部 pop.</p>
<p>eface 数组存储了实际的对象，其 eface 依赖运行时对 interface{} 的实现，即一个 interface{} 由 typ 和 val 两段数据组成</p>
<p>poolDequeue里面的环状队列大小是固定的，当环状队列满了的时候会创建一个size是原来两倍大小的环状队列。最大扩展到 <code>dequeueLimit = (1 &lt;&lt; 32) / 4 = (1 &lt;&lt; 30)</code>，之后就不会扩展了.</p>
<p>为什么vals长度必须是2的幂?这是因为go的内存管理策略是将内存分为2的幂大小的链表，申请2的幂大小的内存可以有效减小分配内存的开销</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// poolDequeue is a lock-free fixed-size single-producer,
</span><span class="c1">// multi-consumer queue. The single producer can both push and pop
</span><span class="c1">// from the head, and consumers can pop from the tail.
</span><span class="c1">//
</span><span class="c1">// It has the added feature that it nils out unused slots to avoid
</span><span class="c1">// unnecessary retention of objects. This is important for sync.Pool,
</span><span class="c1">// but not typically a property considered in the literature.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolDequeue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// headTail packs together a 32-bit head index and a 32-bit
</span><span class="c1"></span>	<span class="c1">// tail index. Both are indexes into vals modulo len(vals)-1.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// tail = index of oldest data in queue
</span><span class="c1"></span>	<span class="c1">// head = index of next slot to fill
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Slots in the range [tail, head) are owned by consumers.
</span><span class="c1"></span>	<span class="c1">// A consumer continues to own a slot outside this range until
</span><span class="c1"></span>	<span class="c1">// it nils the slot, at which point ownership passes to the
</span><span class="c1"></span>	<span class="c1">// producer.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The head index is stored in the most-significant bits so
</span><span class="c1"></span>	<span class="c1">// that we can atomically add to it and the overflow is
</span><span class="c1"></span>	<span class="c1">// harmless.
</span><span class="c1"></span>	<span class="nx">headTail</span> <span class="kt">uint64</span>

	<span class="c1">// vals is a ring buffer of interface{} values stored in this
</span><span class="c1"></span>	<span class="c1">// dequeue. The size of this must be a power of 2.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// vals[i].typ is nil if the slot is empty and non-nil
</span><span class="c1"></span>	<span class="c1">// otherwise. A slot is still in use until *both* the tail
</span><span class="c1"></span>	<span class="c1">// index has moved beyond it and typ has been set to nil. This
</span><span class="c1"></span>	<span class="c1">// is set to nil atomically by the consumer and read
</span><span class="c1"></span>	<span class="c1">// atomically by the producer.
</span><span class="c1"></span>	<span class="nx">vals</span> <span class="p">[]</span><span class="nx">eface</span>
<span class="p">}</span>
<span class="c1">// 存储元素的结构体，类型指针和值指针
</span><span class="c1">// Pool 底层用 eface 来存储单个 Object, 包括 typ 指针: Object 的类型，val 指针: Object 的值
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>



<span class="c1">// dequeueLimit is the maximum size of a poolDequeue.
</span><span class="c1">//
</span><span class="c1">// This must be at most (1&lt;&lt;dequeueBits)/2 because detecting fullness
</span><span class="c1">// depends on wrapping around the ring buffer without wrapping around
</span><span class="c1">// the index. We divide by 4 so this fits in an int on 32-bit.
</span><span class="c1"></span>
<span class="c1">// 为什么dequeueLimit是(1 &lt;&lt; 32) / 4 = 1 &lt;&lt; 30 ?
</span><span class="c1">// dequeueLimit 必须是2的幂(上边解释过)
</span><span class="c1">// head和tail都是32位，最大是1 &lt;&lt; 31，如果都用的话，head和tail就是无符号整型，无符号整型使用的时候会有很多上溢的错误，这类错误是不容易检测的，所以相比之下还不如用31位有符号整型，有错就报出来
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">dequeueLimit</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">dequeueBits</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>

<span class="c1">// dequeueNil is used in poolDeqeue to represent interface{}(nil).
</span><span class="c1">// Since we use nil to represent empty slots, we need a sentinel value
</span><span class="c1">// to represent nil.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">dequeueNil</span> <span class="o">*</span><span class="kd">struct</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>headTail 字段的前 32 位 表示了下一个需要被填充的对象槽的索引，而后 32 位则表示了队列中最先被插入的数据的索引</p>
<p>headTail:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">[hhhhhhhh</span> <span class="n">hhhhhhhh</span> <span class="n">hhhhhhhh</span> <span class="n">hhhhhhhh</span> <span class="n">tttttttt</span> <span class="n">tttttttt</span> <span class="n">tttttttt</span> <span class="n">tttttttt]</span>
<span class="m">1</span><span class="n">. headTail表示下标</span>，高<span class="m">32</span>位表示头下标，低<span class="m">32</span>位表示尾下标，<span class="n">poolDequeue定义了</span>，<span class="n">head</span> <span class="n">tail的pack和unpack函数方便转化</span>，
实际用的时候都会<span class="nf">mod </span><span class="p">(</span> <span class="nf">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span> <span class="p">)</span> 来防止溢出
<span class="m">2</span><span class="n">. head和tail永远只用32位表示</span>，溢出后会从<span class="m">0</span>开始，这也满足循环队列的设计
<span class="m">3</span><span class="n">. 队列为空的条件</span>  <span class="n">tail</span> <span class="o">==</span> <span class="n">head</span>
<span class="m">4</span><span class="nf">. 队列满的条件    </span><span class="p">(</span><span class="n">tail</span><span class="o">+</span><span class="nf">uint32</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">d.vals</span><span class="p">)))</span><span class="o">&amp;</span><span class="p">(</span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="n">dequeueBits</span><span class="m">-1</span><span class="p">)</span> <span class="o">==</span> <span class="n">head</span> <span class="nf">tail加上队列长度和head相等</span><span class="p">(</span>实际上就是队列已有的空间都有值了<span class="p">,</span>满了<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>正如前面所说 poolDequeue 是一个单生产者、多消费者的固定长度的环状队列， popHead、pushHead 由局部的 P 操作队首，而 popTail 由其他并行的 P 操作队尾。 其中 headTail 字段的前 32 位表示了下一个需要被填充的对象槽的索引， 而后 32 位则表示了队列中最先被插入的数据的索引。</p>
<p>通过 pack和unpack方法来实现对head和tail的读写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">dequeueBits</span> <span class="p">=</span> <span class="mi">32</span>

<span class="c1">// 将headTail分解为head和tail
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">mask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">head</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">((</span><span class="nx">ptrs</span> <span class="o">&gt;&gt;</span> <span class="nx">dequeueBits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">mask</span><span class="p">)</span>
	<span class="nx">tail</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">ptrs</span> <span class="o">&amp;</span> <span class="nx">mask</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 将head和tail组合成headTail
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">pack</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">mask</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">dequeueBits</span><span class="p">)</span> <span class="p">|</span>
		<span class="nb">uint64</span><span class="p">(</span><span class="nx">tail</span><span class="o">&amp;</span><span class="nx">mask</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从 poolChain 的实现中我们可以看到，每个 poolDequeue 的 vals 长度为 8。 但由于是循环队列，实现中并不关心队列的长度，只要首尾元素的索引相等，则说明队列已满。 因此通过 CAS 原语实现单一生产者的对队头的读 popHead 和写 pushHead：</p>
<h3 id="pophead-1">popHead<a hidden class="anchor" aria-hidden="true" href="#pophead-1">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// popHead removes and returns the element at the head of the queue.
</span><span class="c1">// It returns false if the queue is empty. It must only be called by a
</span><span class="c1">// single producer.
</span><span class="c1">// 获取并删除队首元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">popHead</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">slot</span> <span class="o">*</span><span class="nx">eface</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">)</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
			<span class="c1">// Queue is empty.
</span><span class="c1"></span>			<span class="c1">// 队列为空，获取对象失败
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="c1">// Confirm tail and decrement head. We do this before
</span><span class="c1"></span>		<span class="c1">// reading the value to take back ownership of this
</span><span class="c1"></span>		<span class="c1">// slot.
</span><span class="c1"></span>		<span class="c1">// 因为head是下一个对象存储的位置，因此从队列头部获取对象需先将head-1
</span><span class="c1"></span>		<span class="nx">head</span><span class="o">--</span>
		<span class="nx">ptrs2</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="nx">ptrs</span><span class="p">,</span> <span class="nx">ptrs2</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// We successfully took back slot.
</span><span class="c1"></span>			<span class="nx">slot</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">head</span><span class="o">&amp;</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">val</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">val</span> <span class="o">==</span> <span class="nf">dequeueNil</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// Zero the slot. Unlike popTail, this isn&#39;t racing with
</span><span class="c1"></span>	<span class="c1">// pushHead, so we don&#39;t need to be careful here.
</span><span class="c1"></span>	<span class="c1">// 重置slot
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">eface</span><span class="p">{}</span>
	<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="pushhead-1">pushHead<a hidden class="anchor" aria-hidden="true" href="#pushhead-1">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pushHead adds val at the head of the queue. It returns false if the
</span><span class="c1">// queue is full. It must only be called by a single producer.
</span><span class="c1">// 添加元素到队首
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">pushHead</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">)</span>
	<span class="c1">// 解析出head、tail的索引
</span><span class="c1"></span>	<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">tail</span><span class="o">+</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)))</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
		<span class="c1">// 队列已满，插入失败
</span><span class="c1"></span>		<span class="c1">// Queue is full.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 找到head的槽位
</span><span class="c1"></span>	<span class="nx">slot</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">head</span><span class="o">&amp;</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

	<span class="c1">// Check if the head slot has been released by popTail.
</span><span class="c1"></span>	<span class="c1">// 此处可能与 popTail 发生竞争，参见 popTail
</span><span class="c1"></span>	<span class="c1">// 检测这个槽位有没被popTail释放
</span><span class="c1"></span>	<span class="nx">typ</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">slot</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">typ</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Another goroutine is still cleaning up the tail, so
</span><span class="c1"></span>		<span class="c1">// the queue is actually still full.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// The head slot is free, so we own it.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">val</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="nf">dequeueNil</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span> <span class="p">=</span> <span class="nx">val</span>

	<span class="c1">// Increment head. This passes ownership of slot to popTail
</span><span class="c1"></span>	<span class="c1">// and acts as a store barrier for writing the slot.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="poptail-1">popTail<a hidden class="anchor" aria-hidden="true" href="#poptail-1">#</a></h3>
<p>多个消费者读的处理手段非常巧妙，通过 interface{} 的 typ 和 val 两段式 结构的读写先后顺序，在 popTail 和 pushHead 之间消除了竞争</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// popTail removes and returns the element at the tail of the queue.
</span><span class="c1">// It returns false if the queue is empty. It may be called by any
</span><span class="c1">// number of consumers.
</span><span class="c1">// 获取并删除队尾元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">poolDequeue</span><span class="p">)</span> <span class="nf">popTail</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">slot</span> <span class="o">*</span><span class="nx">eface</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">)</span>
		<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">tail</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
			<span class="c1">// Queue is empty.
</span><span class="c1"></span>			<span class="c1">// 队列为空，直接返回
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="c1">// Confirm head and tail (for our speculative check
</span><span class="c1"></span>		<span class="c1">// above) and increment tail. If this succeeds, then
</span><span class="c1"></span>		<span class="c1">// we own the slot at tail.
</span><span class="c1"></span>		<span class="c1">// tail+1，表明尾部的对象已被获取
</span><span class="c1"></span>		<span class="nx">ptrs2</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="nx">ptrs</span><span class="p">,</span> <span class="nx">ptrs2</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Success.
</span><span class="c1"></span>			<span class="nx">slot</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">tail</span><span class="o">&amp;</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// We now own slot.
</span><span class="c1"></span>	<span class="nx">val</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">val</span> <span class="o">==</span> <span class="nf">dequeueNil</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Tell pushHead that we&#39;re done with this slot. Zeroing the
</span><span class="c1"></span>	<span class="c1">// slot is also important so we don&#39;t leave behind references
</span><span class="c1"></span>	<span class="c1">// that could keep this object live longer than necessary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We write to val first and then publish that we&#39;re done with
</span><span class="c1"></span>	<span class="c1">// this slot by atomically writing to typ.
</span><span class="c1"></span>	<span class="c1">// 注意：此处可能与 pushHead 发生竞争，解决方案是：
</span><span class="c1"></span>	<span class="c1">// 1. 让 pushHead 先读取 typ 的值，如果 typ 值不为 nil，则说明 popTail 尚未清理完 slot
</span><span class="c1"></span>	<span class="c1">// 2. 让 popTail 先清理掉 val 中的内容，在清理掉 typ，从而确保不会与 pushHead 对 slot 的写行为发生竞争
</span><span class="c1"></span>	<span class="c1">// 将slot置空
</span><span class="c1"></span>	<span class="nx">slot</span><span class="p">.</span><span class="nx">val</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">slot</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="c1">// At this point pushHead owns the slot.
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="get">Get<a hidden class="anchor" aria-hidden="true" href="#get">#</a></h2>
<p>我们来看看 Get 方法的具体实现原理。</p>
<p>当从池中获取对象时，会先从 per-P 的 poolLocal slice 中选取一个 poolLocal，选择策略遵循：</p>
<ul>
<li>尝试从当前P的private取，成功则直接返回</li>
<li>private获取失败，则从当前P的share链表的头部节点取，成功则返回
<ul>
<li>从头部节点的队头获取成功，则直接返回</li>
<li>从头部节点获取失败，则从下一节点获取，直至获取成功或遍历完所有节点</li>
</ul>
</li>
<li>当前P的share获取失败，则从其他P的share获取，成功则返回
<ul>
<li>遍历其他P的share链表直至获取对象成功，返回</li>
<li>从其他P的share链表的尾部的队尾获取对象，若成功则直接返回</li>
<li>若尾部节点的队尾获取对象失败，则表明该节点为空，删除该节点并遍历下一节点，直至获取对象成功或遍历完所有节点</li>
</ul>
</li>
<li>其他P的share获取失败，则尝试从victim cache获取，成功则返回
<ul>
<li>优先尝试从private获取，成功则返回</li>
<li>若从private获取失败，则遍历victim的poolLocal，尝试从每一个poolLocal的链表尾部获取对象，成功则返回</li>
</ul>
</li>
<li>vitcim获取失败，则创建一个新对象返回</li>
</ul>
<p>首先,从本地的 private 字段中获取可用元素,因为没有锁, 获取元素的过程会非常快,如果没有获取到,就尝试从本地的 shared 获取一个,如果还没有,会使用 getSlow 方法去其它的 shared 中“偷”一个。最后,如果没有获取到,就尝试使用 New 函数创建一个新的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get selects an arbitrary item from the Pool, removes it from the
</span><span class="c1">// Pool, and returns it to the caller.
</span><span class="c1">// Get may choose to ignore the pool and treat it as empty.
</span><span class="c1">// Callers should not assume any relation between values passed to Put and
</span><span class="c1">// the values returned by Get.
</span><span class="c1">//
</span><span class="c1">// If Get would otherwise return nil and p.New is non-nil, Get returns
</span><span class="c1">// the result of calling p.New.
</span><span class="c1">// Get 从 Pool 中选择一个任意的对象，将其移出 Pool, 并返回给调用方。
</span><span class="c1">// Get 可能会返回一个非零值对象（被其他人使用过），因此调用方不应假设
</span><span class="c1">// 返回的对象具有任何形式的状态。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 把当前goroutine固定在当前的P上
</span><span class="c1"></span>	<span class="c1">// 获取一个 poolLocal
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
	<span class="c1">// 优先从local的private字段取,快速
</span><span class="c1"></span>	<span class="c1">// 先从 private 获取对象
</span><span class="c1"></span>	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Try to pop the head of the local shard. We prefer
</span><span class="c1"></span>		<span class="c1">// the head over the tail for temporal locality of
</span><span class="c1"></span>		<span class="c1">// reuse.
</span><span class="c1"></span>		<span class="c1">// 从当前的local.shared弹出一个,注意是从head读取并移除
</span><span class="c1"></span>		<span class="c1">// 尝试从 localPool 的 shared 队列队头读取，
</span><span class="c1"></span>		<span class="c1">// 因为队头的内存局部性比队尾更好。
</span><span class="c1"></span>		<span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popHead</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 当前P的private和share都取不到，则去其他P的share读取
</span><span class="c1"></span>			<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nf">poolRaceAddr</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果没有获取到,尝试使用New函数生成一个新的
</span><span class="c1"></span>	<span class="c1">// 如果 getSlow 还是获取不到，则 New 一个
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">New</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实我们不难看出：</p>
<ol>
<li>private 只保存了一个对象;</li>
<li>第一次从 shared 中取对象时，还未涉及跨 P 读写，因此 popHead 是可用的；</li>
<li>当 shared 读取不到对象时，说明当前局部 P 所持有的 localPool 不包含任何对象，这时尝试从其他的 localPool 进行偷取。</li>
<li>实在是偷不到，才考虑新创建一个对象。</li>
</ol>
<h3 id="pin">pin<a hidden class="anchor" aria-hidden="true" href="#pin">#</a></h3>
<p>pin 方法会将此 goroutine 固定在当前的 P 上,避免查找元素期间被其它的 P 执行。固定的好处就是查找元素期间直接得到跟这个 P 相关的 local。有一点需要注意的是,pin 方法在执行的时候,如果跟这个 P 相关的 local 还没有创建,或者运行时 P 的数量被修改了的话,就会新创建 local。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pin pins the current goroutine to P, disables preemption and
</span><span class="c1">// returns poolLocal pool for the P and the P&#39;s id.
</span><span class="c1">// Caller must call runtime_procUnpin() when done with the pool.
</span><span class="c1">// 将当前goroutine和P绑定，禁止抢占，并返回对应的poolLocal和P的id
</span><span class="c1">// 调用方在调用完成后必须调用runtime_procUnpin方法取消抢占
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">pin</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// 返回当前 P.id
</span><span class="c1"></span>	<span class="nx">pid</span> <span class="o">:=</span> <span class="nf">runtime_procPin</span><span class="p">()</span>
	<span class="c1">// In pinSlow we store to local and then to localSize, here we load in opposite order.
</span><span class="c1"></span>	<span class="c1">// Since we&#39;ve disabled preemption, GC cannot happen in between.
</span><span class="c1"></span>	<span class="c1">// Thus here we must observe local at least as large localSize.
</span><span class="c1"></span>	<span class="c1">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).
</span><span class="c1"></span>	<span class="c1">// 在 pinSlow 中会存储 localSize 后再存储 local，因此这里反过来读取
</span><span class="c1"></span>	<span class="c1">// 因为我们已经禁用了抢占，这时不会发生 GC
</span><span class="c1"></span>	<span class="c1">// 因此，我们必须观察 local 和 localSize 是否对应
</span><span class="c1"></span>	<span class="c1">// 观察到一个全新或很大的的 local 是正常行为
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">)</span> <span class="c1">// load-acquire
</span><span class="c1"></span>	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>                          <span class="c1">// load-consume
</span><span class="c1"></span>	<span class="c1">// 因为可能存在动态的 P（运行时调整 P 的个数）procresize/GOMAXPROCS
</span><span class="c1"></span>	<span class="c1">// 如果 P.id 没有越界，则直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// 对应的poolLocal已创建，调用indexLocal取出对应的poolLocal返回
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span><span class="p">),</span> <span class="nx">pid</span>
	<span class="p">}</span>
	<span class="c1">// 没有结果时，涉及全局加锁
</span><span class="c1"></span>	<span class="c1">// 例如重新分配数组内存，添加到全局列表
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pinSlow</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>pin() 首先会调用运行时实现获得当前 P 的 id，将 P 设置为禁止抢占，达到固定当前 goroutine 的目的。 然后检查 pid 与 p.localSize 的值来确保从 p.local 中取值不会发生越界。 如果不会发生，则调用 indexLocal() 完成取值。否则还需要继续调用 pinSlow()。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">poolLocal</span> <span class="p">{</span>
	<span class="c1">// 简单的通过 p.local 的头指针与索引来第 i 个 pooLocal
</span><span class="c1"></span>	<span class="nx">lp</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocal</span><span class="p">{}))</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">)(</span><span class="nx">lp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个过程中我们可以看到在运行时调整 P 的大小的代价。如果此时 P 被调大，而没有对应的 poolLocal 时， 必须在取之前创建好，从而必须依赖全局加锁，这对于以性能著称的池化概念是比较致命的。</p>
<p>既然需要对全局进行加锁，pinSlow() 会首先取消 P 的禁止抢占，这是因为使用 mutex 时 P 必须为可抢占的状态。 然后使用 allPoolsMu 进行加锁。 当完成加锁后，再重新固定 P ，取其 pid。注意，因为中途可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查。 如果 pid 在 p.local 大小范围内，则不再此时创建，直接返回。</p>
<p>如果 p.local 为空，则将 p 扔给 allPools 并在垃圾回收阶段回收所有 Pool 实例。 最后再完成对 p.local 的创建（彻底丢弃旧数组）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">allPoolsMu</span> <span class="nx">Mutex</span>
	<span class="c1">// allPools 是一组 pool 的集合，具有非空主缓存。
</span><span class="c1"></span>	<span class="c1">// 有两种形式来保护它的读写：1. allPoolsMu 锁; 2. STW.
</span><span class="c1"></span>	<span class="nx">allPools</span>   <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span>
<span class="p">)</span>
<span class="c1">// 对应的poolLocal不存在，则创建
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">pinSlow</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Retry under the mutex.
</span><span class="c1"></span>	<span class="c1">// Can not lock the mutex while pinned.
</span><span class="c1"></span>	<span class="c1">// 这时取消 P 的禁止抢占，因为使用 mutex 时候 P 必须可抢占
</span><span class="c1"></span>	<span class="c1">// 加锁期间须先取消抢占
</span><span class="c1"></span>	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nx">allPoolsMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">allPoolsMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 当锁住后，再次固定 P 取其 id
</span><span class="c1"></span>	<span class="nx">pid</span> <span class="o">:=</span> <span class="nf">runtime_procPin</span><span class="p">()</span>
	<span class="c1">// poolCleanup won&#39;t be called while we are pinned.
</span><span class="c1"></span>	<span class="c1">// 并再次检查是否符合条件，因为可能中途已被其他线程调用
</span><span class="c1"></span>	<span class="c1">// 当再次固定 P 时 poolCleanup 不会被调用
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
	<span class="c1">// 第二次检测，因为在加锁过程中可能别的goroutine调用创建了poolLocal
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span><span class="p">),</span> <span class="nx">pid</span>
	<span class="p">}</span>
	<span class="c1">// 如果数组为空，新建
</span><span class="c1"></span>	<span class="c1">// 将其添加到 allPools，垃圾回收器从这里获取所有 Pool 实例
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">allPools</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">allPools</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 根据 P 数量创建 slice，如果 GOMAXPROCS 在 GC 间发生变化
</span><span class="c1"></span>	<span class="c1">// 我们重新分配此数组并丢弃旧的
</span><span class="c1"></span>	<span class="c1">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.
</span><span class="c1"></span>	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">local</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="c1">// 将底层数组起始指针保存到 p.local，并设置 p.localSize
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">local</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">local</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">// store-release
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>         <span class="c1">// store-release
</span><span class="c1"></span>	<span class="c1">// 返回所需的 pollLocal
</span><span class="c1"></span>	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">local</span><span class="p">[</span><span class="nx">pid</span><span class="p">],</span> <span class="nx">pid</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="getslow">getSlow<a hidden class="anchor" aria-hidden="true" href="#getslow">#</a></h3>
<p>终于，我们获取到了 poolLocal，现在回到我们 Get 的取值过程。在取对象的过程中，我们仍然会面临 既不能从 private 取、也不能从 shared 中取得尴尬境地。这时候就来到了 getSlow()。</p>
<p>试想，如果我们在本地的 P 中取不到值，是不是可以考虑从别人那里偷一点过来？总会比创建一个新的要快。 因此，我们再次固定 P，并取得当前的 P.id 来从其他 P 中偷值，那么我们需要先获取到其他 P 对应的 poolLocal。假设 size 为数组的大小，local 为 p.local，那么尝试遍历其他所有 P</p>
<p>它首先要遍历所有的 local,尝试从它们的 shared 弹出一个元素。如果还没找到一个,那么,就开始对 victim 下手了。</p>
<p>在 vintim 中查询可用元素的逻辑还是一样的,先从对应的 victim 的 private 查找,如果查不到,就再从其它 victim 的 shared 中查找。</p>
<p>下面的代码是 getSlow 方法的主要逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="c1">// See the comment in pin regarding ordering of the loads.
</span><span class="c1"></span>	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">)</span> <span class="c1">// load-acquire
</span><span class="c1"></span>	<span class="nx">locals</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>                        <span class="c1">// load-consume
</span><span class="c1"></span>	<span class="c1">// Try to steal one element from other procs.
</span><span class="c1"></span>	<span class="c1">// 尝试从其他P获取对象，成功则直接返回
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 获取目标 poolLocal, 引入 pid 保证不是自身
</span><span class="c1"></span>		<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
		<span class="c1">// 从其他的 P 中固定的 localPool 的 share 队列的队尾偷一个缓存对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">x</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Try the victim cache. We do this after attempting to steal
</span><span class="c1"></span>	<span class="c1">// from all primary caches because we want objects in the
</span><span class="c1"></span>	<span class="c1">// victim cache to age out if at all possible.
</span><span class="c1"></span>	<span class="c1">// 如果其它proc也没有可用元素,那么尝试从vintim中获取
</span><span class="c1"></span>	<span class="c1">// 当 local 失败后，尝试再尝试从上一个垃圾回收周期遗留下来的 victim。
</span><span class="c1"></span>	<span class="c1">// 如果 pid 比 victim 遗留的 localPool 还大，则说明从根据此 pid 从
</span><span class="c1"></span>	<span class="c1">// victim 获取 localPool 会发生越界（同时也表明此时 P 的数量已经发生变化）
</span><span class="c1"></span>	<span class="c1">// 这时无法继续读取，直接返回 nil
</span><span class="c1"></span>	<span class="c1">// 尝试从victim cache中获取对象
</span><span class="c1"></span>	<span class="nx">size</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 获取 localPool，并优先读取 private
</span><span class="c1"></span>	<span class="nx">locals</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">victim</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="nx">pid</span><span class="p">)</span>
	<span class="c1">// 同样的逻辑,先从vintim中的local private获取
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span><span class="p">;</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// 从vintim其它proc尝试偷取
</span><span class="c1"></span>		<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
		<span class="c1">// 从其他的 P 中固定的 localPool 的 share 队列的队尾偷一个缓存对象
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">x</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Mark the victim cache as empty for future gets don&#39;t bother
</span><span class="c1"></span>	<span class="c1">// with it.
</span><span class="c1"></span>	<span class="c1">// 如果victim中都没有,则把这个victim标记为空,以后的查找可以快速跳过了
</span><span class="c1"></span>	<span class="c1">// 将 victim 缓存置空，从而确保之后的 get 操作不再读取此处的值
</span><span class="c1"></span>	<span class="c1">// 清空 victim cache。下次就不用再从这里找了
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>我们来证明一下此处确实不会发生取到自身的情况，不妨设：<code>pid = (pid+i+1)%size</code> 则 <code>pid+i+1 = a*size+pid</code>。 即：<code>a*size = i+1</code>，其中 a 为整数。由于 <code>i&lt;size</code>，于是 <code>a*size = i+1 &lt; size+1</code>，则： <code>(a-1)*size &lt; 1 ==&gt; size &lt; 1 / (a-1)</code>，由于 size 为非负整数，这是不可能的。</p>
<h2 id="put">Put<a hidden class="anchor" aria-hidden="true" href="#put">#</a></h2>
<p>Put 的过程则相对简单，只需要将对象放回到池中。 与 Get 取出一样，放回遵循策略：</p>
<ol>
<li>尝试将对象存储在当前P的private，成功则直接返回</li>
<li>存入private失败，则尝试存入当前P的share链表的头部节点的队头，成功则返回</li>
<li>若链表头部节点的队列已满存入失败，则创建一个新节点，节点队列大小为原来的两倍，将对象存入新节点， 并将该节点设置为新的头部节点</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Put adds x to the pool.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// 如果存入对象为nil直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Randomly drop x on floor.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nf">poolRaceAddr</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 获得一个 localPool
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
	<span class="c1">// 优先放入 private
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 如果不能放入 private 则放入 shared
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="runtime_procunpin--runtime_procpin">runtime_procUnpin &amp; runtime_procPin<a hidden class="anchor" aria-hidden="true" href="#runtime_procunpin--runtime_procpin">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname sync_runtime_procPin sync.runtime_procPin
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_procPin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">procPin</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_procUnpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">procUnpin</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procPin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>

	<span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procUnpin</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="poolcleanup">PoolCleanup<a hidden class="anchor" aria-hidden="true" href="#poolcleanup">#</a></h2>
<p>sync.Pool 的垃圾回收发生在运行时 GC 开始之前。</p>
<p>在 src/sync/pool.go 中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 将缓存清理函数注册到运行时 GC 时间段
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">runtime_registerPoolCleanup</span><span class="p">(</span><span class="nx">poolCleanup</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 由运行时实现
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_registerPoolCleanup</span><span class="p">(</span><span class="nx">cleanup</span> <span class="kd">func</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>在 src/runtime/mgc.go 中:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 开始 GC
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">clearpools</span><span class="p">()</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="c1">// 实现缓存清理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">clearpools</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// clear sync.Pools
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">poolcleanup</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">poolcleanup</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">poolcleanup</span> <span class="kd">func</span><span class="p">()</span>

<span class="c1">// 利用编译器标志将 sync 包中的清理注册到运行时
</span><span class="c1">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sync_runtime_registerPoolCleanup</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="nx">poolcleanup</span> <span class="p">=</span> <span class="nx">f</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再来看实际的清理函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">allPoolsMu</span> <span class="nx">Mutex</span>

	<span class="c1">// allPools is the set of pools that have non-empty primary
</span><span class="c1"></span>	<span class="c1">// caches. Protected by either 1) allPoolsMu and pinning or 2)
</span><span class="c1"></span>	<span class="c1">// STW.
</span><span class="c1"></span>	<span class="nx">allPools</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span>

	<span class="c1">// oldPools is the set of pools that may have non-empty victim
</span><span class="c1"></span>	<span class="c1">// caches. Protected by STW.
</span><span class="c1"></span>	<span class="c1">// oldPools 是一组 pool 的集合，具有非空 victim 缓存。由 STW 保护
</span><span class="c1"></span>	<span class="nx">oldPools</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">poolCleanup</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 该函数会注册到运行时 GC 阶段(前)，此时为 STW 状态，不需要加锁
</span><span class="c1"></span>	<span class="c1">// 它必须不处理分配且不调用任何运行时函数。
</span><span class="c1"></span>
	<span class="c1">// 由于此时是 STW，不存在用户态代码能尝试读取 localPool，进而所有的 P 都已固定（与 goroutine 绑定）
</span><span class="c1"></span>
	<span class="c1">// 从所有的 oldPools 中删除 victim
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 将主缓存移动到 victim 缓存
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>

		<span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 具有非空主缓存的池现在具有非空的 victim 缓存，并且没有任何 pool 具有主缓存。
</span><span class="c1"></span>	<span class="nx">oldPools</span><span class="p">,</span> <span class="nx">allPools</span> <span class="p">=</span> <span class="nx">allPools</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，即便是最后 p.local 已经被置换到 oldPools 的 p.victim，其中的缓存对象仍然有可能被偷取放回到 allPools 中，从而延缓了 victim 中缓存对象被回收的速度。</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>至此，我们完整分析了 sync.Pool 的所有代码。总结：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s">        <span class="n">goroutine</span>      <span class="n">goroutine</span>       <span class="n">goroutine</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
           <span class="n">P</span>               <span class="n">P</span>               <span class="n">P</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
         <span class="n">private</span>        <span class="n">private</span>          <span class="n">private</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
    <span class="n">[</span>   <span class="n">poolLocal</span>      <span class="n">poolLocal</span>        <span class="n">poolLocal</span>  <span class="n">]</span>    <span class="n">sync.Pool</span>
           <span class="o">|</span>               <span class="o">|</span>               <span class="o">|</span>
         <span class="n">shared</span>          <span class="n">shared</span>          <span class="n">shared</span>
</code></pre></td></tr></table>
</div>
</div><p>一个 goroutine 固定在 P 上，从当前 P 对应的 private 取值， shared 字段作为一个优化过的链式无锁变长队列，当在 private 取不到值的情况下， 从对应的 shared 队列的队首取，若还是取不到，则尝试从其他 P 的 shared 队列队尾中偷取。 若偷不到，则尝试从上一个 GC 周期遗留到 victim 缓存中取，否则调用 New 创建一个新的对象。</p>
<p>对于回收而言，池中所有临时对象在一次 GC 后会被放入 victim 缓存中， 而前一个周期被放入 victim 的缓存则会被清理掉。</p>
<p>对于调用方而言，当 Get 到临时对象后，便脱离了池本身不受控制。 用方有责任将使用完的对象放回池中。</p>
<p>本文中介绍的 sync.Pool 实现为 Go 1.13 优化过后的版本，相较于之前的版本，主要有以下几点优化：</p>
<ol>
<li>引入了 victim （二级）缓存，每次 GC 周期不再清理所有的缓存对象，而是将 locals 中的对象暂时放入 victim ，从而延迟到下一个 GC 周期进行回收；</li>
<li>在下一个周期到来前，victim 中的缓存对象可能会被偷取，在 Put 操作后又重新回到 locals 中，这个过程发生在从其他 P 的 shared 队列中偷取不到、以及 New 一个新对象之前，进而是在牺牲了 New 新对象的速度的情况下换取的；</li>
<li>poolLocal 不再使用 Mutex 这类昂贵的锁来保证并发安全，取而代之的是使用了 CAS 算法优化实现的 poolChain 变长无锁双向链式队列。</li>
</ol>
<p>这种两级缓存的优化的优势在于：</p>
<ol>
<li>显著降低了 GC 发生前清理当前周期中产生的大量缓存对象的影响：因为回收被推迟到了下个 GC 周期；</li>
<li>显著降低了 GC 发生后 New 对象的成本：因为密集的缓存对象读写可能从上个周期中未清理的对象中偷取。</li>
</ol>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://colobu.com/2017/07/11/dive-into-sync-Map">https://colobu.com/2017/07/11/dive-into-sync-Map</a></p>
<p><a href="https://segmentfault.com/a/1190000015242373">https://segmentfault.com/a/1190000015242373</a></p>
<p><a href="https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/">https://pathbox.github.io/2018/04/05/understand-sync.Map-in-Goalng/</a></p>
<p><a href="http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html">http://www.qiuxiaobing.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/03/09/go-sync-map.html</a></p>
<p><a href="http://www.gogodjzhu.com/index.php/code/basic/397/">http://www.gogodjzhu.com/index.php/code/basic/397/</a></p>
<p><a href="http://russellluo.com/2017/06/go-sync-map-diagram.html">http://russellluo.com/2017/06/go-sync-map-diagram.html</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/cond/">5.4 条件变量</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/waitgroup/">5.5 同步组</a></p>
<p><a href="https://blog.csdn.net/sinat_41790904/article/details/115416237">Go 标准库源码分析 - sync 包的Pool</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/map/">5.7 并发安全散列表</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">6.1 上下文 Context</a></p>
<p><a href="https://juejin.cn/post/6844903741842259975">go context剖析之源码分析</a></p>
<p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/atomic/">5.3 原子操作</a></p>
<p><a href="https://www.cnblogs.com/luozhiyun/p/14194872.html">多图详解Go的sync.Pool源码</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
