<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>子数组的最大累加和/累乘积 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="子数组的最大累加和/累乘积" />
<meta property="og:description" content="LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T00:00:10+00:00" />
<meta property="article:modified_time" content="2017-06-25T00:00:10+00:00" />

<meta itemprop="name" content="子数组的最大累加和/累乘积">
<meta itemprop="description" content="LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新"><meta itemprop="datePublished" content="2017-06-25T00:00:10+00:00" />
<meta itemprop="dateModified" content="2017-06-25T00:00:10+00:00" />
<meta itemprop="wordCount" content="4401">
<meta itemprop="keywords" content="Array,DP,Binary Search,Matrix," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="子数组的最大累加和/累乘积"/>
<meta name="twitter:description" content="LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">子数组的最大累加和/累乘积</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-25 </span>
        <div class="post-category">
            <a href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"> 解题报告 </a>
            </div>
          <span class="more-meta"> 约 4401 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="leetcode-53-maximum-subarray">LeetCode 53. Maximum Subarray</h1>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<p>解析：动态规划</p>
<p>每个元素有2种选择：加入之前的连续子序列；创建一个新连续子序列 这取决于之前的连续子序列是否大于0。因为递推公式只与前面第一个结果有关，可以用滚动数组来优化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//f表示当前元素所在的子序列和
</span><span class="c1"></span>            <span class="n">result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span><span class="c1">//result表示最终结果
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="子矩阵的最大累加和">子矩阵的最大累加和</h1>
<p>题目:</p>
<p>给定一个矩阵matrix，其中的值有正、有负、有0,返回子矩阵的最大累加和。</p>
<p>例如，矩阵matrix为：</p>
<pre><code>-90 48 78
64 -40 64
-81	-7	66
</code></pre>
<p>其中，最大累加和的子矩阵为:</p>
<pre><code>48 78
-40 64
-7	66
</code></pre>
<p>所以返回累加和209。</p>
<p>解析:</p>
<p>在阅读本题的解释之前，请先阅读上一道题“子数组的最大累加和问题”，因为本题的最优解深度利用了上一题的解法。首先来看这样一个例子，假设一个2行4列的矩阵如下:</p>
<pre><code>-2 3-5 7
14-1-3
</code></pre>
<p>如何求必须含有2行元素的子矩阵中的最大累加和？可以把两列的元素累加，然后得
到累加数组[-1，7，-6,4],接下来求这个累加数组的最大累加和，结果是7。也就是说，必须含有2行元素的子矩阵中的最大和为7,且这个子矩阵是：</p>
<pre><code>3
4
</code></pre>
<p>也就是说，如果一个矩阵一共有k行且限定必须含有k行元素的情况下，我们只要把矩阵中每一列的k个元素累加生成一个累加数组，然后求出这个数组的最大累加和，这个最大累加和就是必须含有A行元素的子矩阵中的最大累加和。</p>
<p>为了方便讲述，我们用题目的例子来展示求解过程.</p>
<p>首先考虑只有一行的矩阵[-90,48,78],因为只有一行，所以累加数组arr就是[-90,48,78],这个数组的最大累加和为126。</p>
<p>接下来考虑含有两行的矩阵：</p>
<pre><code>-90 48 78
64 -40 64
</code></pre>
<p>这个矩阵的累加数组就是在上一步的累加数组[-90,48,78]的基础上，依次在每个位置上加上矩阵最新一行[64,-40, 64]的结果，即[-26,8，142],这个数组的最大累加和为150。</p>
<p>接下来考虑含有三行的矩阵：</p>
<pre><code>-90		48		78
64		-40		64
-81		-7		66
</code></pre>
<p>这个矩阵的累加数组就是在上一步累加数组[-26,8,142]的基础上，依次在每个位置上加上矩阵最新一行[-81,-7,66]的结果，即[-107,1,208],这个数组的最大累加和为209。</p>
<p>此时，必须从矩阵的第一行元素开始，并往下的所有子矩阵己经查找完毕，接下来从矩阵的第二行开始，继续这样的过程，含有一行矩阵：</p>
<pre><code>64 -40 64
</code></pre>
<p>因为只有一行，所以累加数组就是[64,-40,64],这个数组的最大累加和为88。</p>
<p>接下来考虑含有两行的矩阵：</p>
<pre><code>64 -40 64
-81	-7	66
</code></pre>
<p>这个矩阵的累加数组就是在上一步累加数组[64,-40,64]的基础上，依次在每个位置上加上矩阵最新一行[-81,-7,66]的结果，即[-17,-47,130],这个数组的最大累加和为130。</p>
<p>此时，必须从矩阵的第二行元素开始，并往下的所有子矩阵己经查找完毕，接下来从矩阵的第三行开始，继续这样的过程，含有一行矩阵：</p>
<pre><code>-81	-7	66
</code></pre>
<p>因为只有一行，所以累加数组就是[-81,-7,66],这个数组的最大累加和为66。</p>
<p>全部过程结束，所有的子矩阵都己经考虑到了，结果为以上所有最大累加和中最大的</p>
<pre><code>209。
</code></pre>
<p>整个过程最关键的地方有两处:</p>
<ol>
<li>用求累加数组的最大累加和的方式得到每一步的最大子矩阵的累加和</li>
<li>每一步的累加数组可以利用前一步求出的累加数组很方便地更新得到^</li>
</ol>
<p>如果矩阵大小为N*N，以上全部过程的时间复杂度为O(N^3)，具体请参看如下代码中的maxSum方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">m</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">0</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ÀÛ¼ÓÊý×é
</span><span class="c1"></span>		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
				<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
					<span class="n">s</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">+=</span> <span class="n">m</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
					<span class="n">cur</span> <span class="o">+=</span> <span class="n">s</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
					<span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>
					<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">cur</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">max</span><span class="o">;</span>
	<span class="o">}</span>


</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-410-split-array-largest-sum">LeetCode 410. Split Array Largest Sum</h1>
<p>Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.</p>
<p>Note:</p>
<p>If n is the length of array, assume the following constraints are satisfied:</p>
<p>1 ≤ n ≤ 1000
1 ≤ m ≤ min(50, n)</p>
<p>Examples:</p>
<pre><code>Input:
nums = [7,2,5,10,8]
m = 2

Output:
18
</code></pre>
<p>Explanation:</p>
<p>There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.</p>
<p>解析：</p>
<p>如果m和数组nums的个数相等，那么每个数组都是一个子数组，所以返回nums中最大的数字即可，如果m为1，那么整个nums数组就是一个子数组，返回nums所有数字之和，所以对于其他有效的m值，返回的值必定在上面两个值之间，所以我们可以用二分搜索法来枚举答案，然后扫描数组来判断该答案是否合法。</p>
<p>我们用一个例子来分析，nums = [1, 2, 3, 4, 5], m = 3，我们将left设为数组中的最大值5，right设为数字之和15，然后我们算出中间数为10，我们接下来要做的是找出和最大且小于等于10的子数组的个数，[1, 2, 3, 4], [5]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">doable</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cuts</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//将数组分成最大值为max的m个区间，判断能否成功
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span> <span class="n">acc</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
        <span class="c1">//贪心法，令每个区间容纳的元素尽可能多
</span><span class="c1"></span>        <span class="k">else</span> <span class="p">{</span><span class="c1">//开新区间
</span><span class="c1"></span>            <span class="o">--</span><span class="n">cuts</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cuts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>    
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">splitArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">num</span><span class="p">);</span>
        <span class="n">right</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">doable</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span><span class="p">))</span> 
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span><span class="c1">//不能让mid-1，因为当前mid可能就是最终结果
</span><span class="c1"></span>        <span class="k">else</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-152-maximum-product-subarray">LeetCode 152. Maximum Product Subarray</h1>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.</p>
<p>解析：因为求得是最大乘积的子连续和，和第一题的差距在于增加一个数，其增加的量不是线性的，因为会负负得正。所以不光要动态维护最大值，还要动态维护最小值。当前值为负数时，最大值最小值互换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxProduct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imax</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">imin</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">imax</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">imax</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">imin</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">imax</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-363-max-sum-of-rectangle-no-larger-than-k">LeetCode 363. Max Sum of Rectangle No Larger Than K</h1>
<p>Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.</p>
<p>Example:</p>
<pre><code>Given matrix = [  
  [1,  0, 1],
  [0, -2, 3]
]

k = 2
</code></pre>
<p>The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2).</p>
<p>Note:</p>
<p>The rectangle inside the matrix must have an area &gt; 0.</p>
<p>What if the number of rows is much larger than the number of columns?</p>
<p>解析：</p>
<p>根据题意，寻找二维数组中所有可以组成的矩形中面积不超过k的最大值，所以必须要求出可能组成的矩形的面积并与k比较求出最终结果。</p>
<p>把二维数组按行或列拆成多个一维数组，然后利用一维数组的累加和来找符合要求的数字，因为行数远大于列数，所以枚举列的左右边界l和r，将二维数组拆成（r-l）个sum数组，这样可以让接下来求最大子段和的次数减少。sum[i]表示第i行的前缀和。现在问题就转换成如何求sum数组的最大子段和。</p>
<p>建立一个集合set来保存所有前缀和，然后开始先放个0进去，如果我们要找lower_bound(curSum - k)，当curSum和k相等时，0就可以被返回了，这样我们就能更新结果了。</p>
<p>由于我们对于一维数组建立了累积和，那么sum[i,j] = sum[i] - sum[j]，其中sums[i,j]就是目标子数组需要其和小于等于k，然后sums[j]是curSum，而sum[i]就是我们要找值，当我们使用二分搜索法找sum[i]时，sum[i]的和需要&gt;=sum[j] - k，所以也可以使用lower_bound来找</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxSumSubmatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">col</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">res</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">col</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举左边界
</span><span class="c1"></span>            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sums</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//保存每一行的累积和
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">col</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举右边界
</span><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//将该列的所有元素求和累积到sum中
</span><span class="c1"></span>                    <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">r</span><span class="p">];</span>
                <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accuSet</span><span class="p">;</span>
                <span class="n">accuSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">curSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curMax</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">sum</span> <span class="p">:</span> <span class="n">sums</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//按行扫描，找出该以该行为结尾的最大字段和
</span><span class="c1"></span>                    <span class="n">curSum</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span><span class="c1">//记录以该行为结尾的前缀和
</span><span class="c1"></span>                    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">accuSet</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">curSum</span> <span class="o">-</span> <span class="n">k</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">accuSet</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="c1">//查找成功
</span><span class="c1"></span>                        <span class="n">curMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">curMax</span><span class="p">,</span> <span class="n">curSum</span> <span class="o">-</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span><span class="c1">//维护结果
</span><span class="c1"></span>                <span class="c1">//将当前前缀和放入set中，等待下一次循环
</span><span class="c1"></span>                    <span class="n">accuSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">curSum</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">curMax</span><span class="p">);</span><span class="c1">//用当前左右边界下的最优结果来维护全局结果
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-198-house-robber">LeetCode 198. House Robber</h1>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>解析：</p>
<p>这道题的本质相当于在一列数组中取出一个或多个不相邻数，使其和最大。</p>
<p>这是一道动态规划问题。</p>
<p>我们维护一个一位数组dp，其中dp[i]表示到i位置时不相邻数能形成的最大和。 元素i可取可不取，如果取的话，那么就是num[i] + dp[i - 2]，如果不取的话，那么就是dp[i-1]</p>
<p>状态转移方程：</p>
<p>dp[0] = num[0] （当i=0时）</p>
<p>dp[1] = max(num[0], num[1]) （当i=1时）</p>
<p>dp[i] = max(num[i] + dp[i - 2], dp[i - 1]) （当i !=0 and i != 1时）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-213-house-robber-ii">LeetCode 213. House Robber II</h1>
<p>Note: This is an extension of House Robber.</p>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>解析：</p>
<p>和上一题类似，只是多了一个“环”的条件，就是抢了第一家，就不能抢最后一家。</p>
<p>可以做两次动归，第一次不抢第一家的钱，则可以抢最后一家的钱。第二次抢第一家的钱，然后就不可以抢最后一家的钱，因此最后把各自最大值比较一下，返回最大的一个即是能够抢到的最多的钱。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">//抢第一家到倒数第二家得到的金钱最大值
</span><span class="c1"></span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>  <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="o">?</span> <span class="mi">0</span><span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
    <span class="kt">int</span> <span class="n">res1</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
    <span class="c1">//抢第二家到最后一家得到的金钱最大值
</span><span class="c1"></span>    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">);</span><span class="c1">//返回二者的较大值
</span><span class="c1"></span><span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-337-house-robber-iii">LeetCode 337. House Robber III</h1>
<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<pre><code>  3
 / \
2   3
 \   \ 
  3   1
</code></pre>
<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Example 2:</p>
<pre><code>    3
   / \
  4   5
 / \   \ 
1   3   1
</code></pre>
<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>
<p>解析：</p>
<p>和上面提到的两题不同，那两道题用到了动态规划，而这道题其实是深度优先遍历二叉树。拿root（第0层）为例，如果取第0层的节点，则第1层的节点不能取；如果不取第0层的节点，则第1层的节点可取可不取。这样我们需要记录下每个节点取与不取时能够获取的最大钱数，通过深度优先遍历二叉树，最后取root节点返回的两个数值中大的就可以了。</p>
<p>每次递归都默认取当前root点，l和r分别表示取左孩子和右孩子时的最大值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">tryRob</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">tryRob</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="n">lr</span><span class="p">);</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">tryRob</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">rr</span><span class="p">);</span>            
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">ll</span> <span class="o">+</span> <span class="n">lr</span> <span class="o">+</span> <span class="n">rl</span> <span class="o">+</span> <span class="n">rr</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">tryRob</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/array/">Array</a>
          <a href="/tags/dp/">DP</a>
          <a href="/tags/binary-search/">Binary Search</a>
          <a href="/tags/matrix/">Matrix</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">找到无序数组中某一频率的数</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%9F%90%E4%BD%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">
            <span class="next-text nav-default">与数字的某位相关问题</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
