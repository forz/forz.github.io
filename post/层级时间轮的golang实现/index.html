<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>层级时间轮的Golang实现 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author"
  content="Forz" /><meta name="description" content="引言 最近在工作中负责制定重构计划，需要将部分业务代码从 Python 迁移到 Golang。其中一些功能涉及到 Celery 延时任务，所以一直在思考 Golang 中处理延时任务的有" /><meta name="keywords"
  content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.84.4 with theme even" />


<link rel="canonical" href="/post/%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84golang%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link rel="stylesheet" href="/css/search.css" />


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="层级时间轮的Golang实现" />
<meta property="og:description" content="引言 最近在工作中负责制定重构计划，需要将部分业务代码从 Python 迁移到 Golang。其中一些功能涉及到 Celery 延时任务，所以一直在思考 Golang 中处理延时任务的有" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%B1%82%E7%BA%A7%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84golang%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-23T17:21:10+00:00" />
<meta property="article:modified_time" content="2019-10-23T17:21:10+00:00" />

<meta itemprop="name" content="层级时间轮的Golang实现">
<meta itemprop="description" content="引言 最近在工作中负责制定重构计划，需要将部分业务代码从 Python 迁移到 Golang。其中一些功能涉及到 Celery 延时任务，所以一直在思考 Golang 中处理延时任务的有"><meta itemprop="datePublished" content="2019-10-23T17:21:10+00:00" />
<meta itemprop="dateModified" content="2019-10-23T17:21:10+00:00" />
<meta itemprop="wordCount" content="7750">
<meta itemprop="keywords" content="Go,时间轮," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="层级时间轮的Golang实现"/>
<meta name="twitter:description" content="引言 最近在工作中负责制定重构计划，需要将部分业务代码从 Python 迁移到 Golang。其中一些功能涉及到 Celery 延时任务，所以一直在思考 Golang 中处理延时任务的有"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="clearfix">
  <div class="logo-wrapper">
    <a href="/" class="logo">Forz Blog</a>
  </div>

  <nav class="site-navbar">
    <ul id="menu" class="menu">
      <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
    </ul>
  </nav>
</div>


<div class="search-container">
  <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..."
        name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script
    src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
    var client = algoliasearch("IAR2EF5L65", "b4b9da2eba53aa6dabe4b8ac9e8676e1");
    var index = client.initIndex('forz.forzvina.com');
    autocomplete('#aa-search-input',
        { hint: false }, {
        source: autocomplete.sources.hits(index, { hitsPerPage: 8 }),
        displayKey: 'name',
        templates: {
            suggestion: function (suggestion) {
                var reg = /([A-Z]+)/ig
                var title = suggestion.uri.replace(reg, function (m) {
                    return m.toLowerCase()
                })
                return '<span class="search-item">' + '<a href="\/' + title + '">' +
                    suggestion._highlightResult.title.value + '</a></span>';
            }
        }
    });
</script>
</div>


    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">层级时间轮的Golang实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-23 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 7750 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#简单时间轮">简单时间轮</a></li>
    <li><a href="#层级时间轮">层级时间轮</a></li>
    <li><a href="#kafka-的变体实现">Kafka 的变体实现</a>
      <ul>
        <li><a href="#时间轮表示">时间轮表示</a></li>
        <li><a href="#时钟驱动方式">时钟驱动方式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#utils">utils</a></li>
    <li><a href="#delayqueue">DelayQueue</a></li>
    <li><a href="#bucket">bucket</a></li>
    <li><a href="#timingwheel">timingwheel</a></li>
    <li><a href="#examples">examples</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="引言">引言</h1>
<p>最近在工作中负责制定重构计划，需要将部分业务代码从 Python 迁移到 Golang。其中一些功能涉及到 Celery 延时任务，所以一直在思考 Golang 中处理延时任务的有效方案。</p>
<p>其实在软件系统中，“在一段时间后执行一个任务” 的需求比比皆是。比如：</p>
<ul>
<li>客户端发起 HTTP 请求后，如果在指定时间内没有收到服务器的响应，则自动断开连接。</li>
</ul>
<p>为了实现上述功能，通常我们会使用定时器 Timer：</p>
<ol>
<li>客户端发起请求后，立即创建（启动）一个 Timer：到期间隔为 d，到期后执行 “断开连接” 的操作。</li>
<li>如果到期间隔 d 以内收到了服务器的响应，客户端就删除（停止）这个 Timer。</li>
<li>如果一直没有收到响应，则 Timer 最终会到期，然后执行 “断开连接” 的操作。</li>
</ol>
<p>Golang 内置的 Timer是采用最小堆来实现的，创建和删除的时间复杂度都为 O(log n)。现代的 Web 服务动辄管理 100w+ 的连接，每个连接都会有很多超时任务（比如发送超时、心跳检测等），如果每个超时任务都对应一个 Timer，性能会比较低下。</p>
<p>论文 Hashed and Hierarchical Timing Wheels提出了一种用于实现 Timer 的高效数据结构：时间轮。采用时间轮实现的 Timer，创建和删除的时间复杂度为 O(1)。</p>
<p>常见的时间轮实现有两种：</p>
<ul>
<li>简单时间轮（Simple Timing Wheel）—— 比如 Netty4 的 HashedWheelTimer。</li>
<li>层级时间轮（Hierarchical Timing Wheels）—— 比如 Kafka 的 Purgatory。</li>
</ul>
<p>下面我们来看看简单时间轮、层级时间轮、Kafka 的层级时间轮变体的实现原理，以及 Golang 实现中的一些要点。</p>
<h1 id="理论">理论</h1>
<h2 id="简单时间轮">简单时间轮</h2>
<p>一个 <strong>简单时间轮</strong> 就是一个循环列表，列表中的每一格包含一个定时任务列表（双向链表）。一个时间单位为 u、大小为 n 的简单时间轮，可以包含的定时任务的最大到期间隔为 n*u。</p>
<p>以 u 为 1ms、n 为 3 的简单时间轮为例，可以包含的定时任务的最大到期间隔为 3ms。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191023174824.png" alt=""></p>
<p>如上图所示，该简单时间轮的运行原理如下：</p>
<ol>
<li>初始时，假设当前时间（蓝色箭头）指向第 1 格（此时：到期间隔为 [0ms, 1ms) 的定时任务放第 1 格，[1ms, 2ms) 的放第 2 格，[2ms, 3ms) 的放第 3 格）。</li>
<li>此时我们创建一个到期间隔为 1ms 的定时任务 task1，按规则该任务会被插入到第 2 格。</li>
<li>随着时间的流逝，过了 1ms 后当前时间指向第 2 格，这一格包含的定时任务 task1 会被删除并执行。</li>
<li>当前时间指向第 2 格（此时：到期间隔为 [0ms, 1ms) 的定时任务放第 2 格，[1ms, 2ms) 的放第 3 格，[2ms, 3ms) 的放第 1 格），我们继续创建一个到期间隔为 2ms 的定时任务 task2，按规则该任务被插入到第 1 格。</li>
</ol>
<p>简单时间轮的优点是实现简单，缺点是：</p>
<ul>
<li>一旦选定 n，就不能包含到期间隔超过 n*u 的定时任务。</li>
<li>如果定时任务的到期时间跨度较大，就会选择较大的 n，在定时任务较少时会造成很大的空间浪费。</li>
</ul>
<p>有一些简单时间轮的变体实现，它们通过在定时任务中增加记录 round 轮次信息，可以有效弥补上述两个缺点。同样以上面 u 为 1ms、n 为 3 的简单时间轮为例，初始时间指向第 1 格；此时如果要创建到期时间为 4ms 的定时任务，可以在该任务中设置 round 为 1（4/3 取整），剩余到期时间用 4ms 减去 round*3ms 等于 1ms，因此放到第 2 格；等到当前时间指向第 2 格时，判断任务中的 round 大于 0，所以不会删除并执行该任务，而是对其 round 减一（于是 round 变为 0）；等到再过 3ms 后，当前时间再次指向第 2 格，判断任务中的 round 为 0，进而删除并执行该任务。</p>
<p>然而，这些变体实现因为只使用了一个时间轮，所以仍然存在一个缺点：处理每一格的定时任务列表的时间复杂度是 O(n)，如果定时任务数量很大，分摊到每一格的定时任务列表就会很长，这样的处理性能显然是让人无法接受的。</p>
<h2 id="层级时间轮">层级时间轮</h2>
<p><strong>层级时间轮</strong> 通过使用多个时间轮，并且对每个时间轮采用不同的 u，可以有效地解决简单时间轮及其变体实现的问题。</p>
<p>参考 Kafka 的 Purgatory中的层级时间轮实现：</p>
<ul>
<li>每一层时间轮的大小都固定为 n，第一层时间轮的时间单位为 u，那么第二层时间轮（我们称之为第一层时间轮的溢出时间轮 Overflow Wheel）的时间单位就为 n*u，以此类推。</li>
<li>除了第一层时间轮是固定创建的，其他层的时间轮（均为溢出时间轮）都是按需创建的。</li>
<li>原先插入到高层时间轮（溢出时间轮）的定时任务，随着时间的流逝，会被降级重新插入到低层时间轮中。</li>
</ul>
<p>以 u 为 1ms、n 为 3 的层级时间轮为例，第一层时间轮的时间单位为 1ms、大小为 3，第二层时间轮的时间单位为 3ms、大小为 3，以此类推。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191023174857.png" alt=""></p>
<p>如上图所示，该层级时间轮的运行原理如下：</p>
<ol>
<li>初始时，只有第一层（Level 1）时间轮，假设当前时间（蓝色箭头）指向第 1 格（此时：到期间隔为 [0ms, 1ms) 的定时任务放第 1 格，[1ms, 2ms) 的放第 2 格，[2ms, 3ms) 的放第 3 格）。</li>
<li>此时我们创建一个到期间隔为 2ms 的定时任务 task1，按规则该任务会被插入到第一层时间轮的第 3 格。</li>
<li>同一时刻，我们再次创建一个到期间隔为 4ms 的定时任务 task2，因为到期间隔超过了第一层时间轮的间隔范围，所以会创建第二层（Level 2）时间轮；第二层时间轮中的当前时间（蓝色箭头）也指向第 1 格，按规则该任务会被插入到第二层时间轮的第 2 格。</li>
<li>随着时间的流逝，过了 2ms 后，第一层时间轮中的当前时间指向第 3 格，这一格包含的任务 task1 会被删除并执行；此时，第二层时间轮的当前时间没有变化，依然指向第 1 格。</li>
<li>随着时间的流逝，又过了 1ms 后，第一层时间轮中的当期时间指向第 1 格，这一格中没有任务；此时，第二层当前时间指向第 2 格，这一格包含的任务 task2 会被删除并重新插入时间轮，因为剩余到期时间为 1ms，所以 task2 会被插入到第一层时间轮的第 2 格。</li>
<li>随着时间的流逝，又过了 1ms 后，第一层时间轮中的当前时间指向第 2 格，这一格包含的定时任务 task2 会被删除并执行；此时，第二层时间轮的当前时间没有变化，依然指向第 2 格。</li>
</ol>
<h2 id="kafka-的变体实现">Kafka 的变体实现</h2>
<p>在具体实现层面 Kafka Timer 实现源码，Kafka 的层级时间轮与上面描述的原理有一些差别。</p>
<h3 id="时间轮表示">时间轮表示</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191023174920.png" alt=""></p>
<p>如上图所示，在时间轮的表示上面：</p>
<ul>
<li>使用大小为 wheelSize 的数组来表示一层时间轮，其中每一格是一个 bucket，每个 bucket 的时间单位为 tick。</li>
<li>这个时间轮数组并没有模拟循环列表的行为（如图左所示），而是模拟了哈希表的行为。</li>
</ul>
<p>我们用数组模拟时间轮（数组的每个元素是一个列表头，添加任务就是往列表头后面挂任务而已），数组的大小代表时间的格子数，添加过程中我们会通过 过期时间/时间轮格子代表时间 % 时间轮格子总数 算出的格子位置，然后通过挂链的方法添加到时间轮格子当中。</p>
<p>在这个过程中我们需要注意的是任务首先需要判断当前时间轮是否放的下，判断放得下的标准就是时间轮当前时间 + 一圈时间轮时间是否大于任务过期时间，如果大于就代表放的下，如果小于就代表无法放置那么就需要往上一层时间轮放置。</p>
<h3 id="时钟驱动方式">时钟驱动方式</h3>
<p>常规的时间轮实现中，会在一个线程中每隔一个时间单位 tick 就醒来一次，并驱动时钟走向下一格，然后检查这一格中是否包含定时任务。如果时间单位 tick 很小（比如 Kafka 中 tick 为 1ms）并且（在最低层时间轮的）定时任务很少，那么这种驱动方式将会非常低效。</p>
<p>Kafka 的层级时间轮实现中，利用了 Java 内置的 DelayQueue 结构，将每一层时间轮中所有 “包含有定时任务的 bucket” 都加入到同一个 DelayQueue 中，然后 <strong>等到有 bucket 到期后再驱动时钟往前走</strong>，并逐个处理该 bucket 中的定时任务。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20191023174942.png" alt=""></p>
<p>如上图所示：</p>
<ol>
<li>往层级时间轮中添加一个定时任务 task1 后，会将该任务所属的 bucket2 的到期时间设置为 task1 的到期时间 expiration（= 当前时间 currentTime + 定时任务到期间隔 duration），并将这个 bucket2 添加（Offer）到 DelayQueue 中。</li>
<li>DelayQueue（内部有一个线程）会等待 “到期时间最早（earliest）的 bucket” 到期，图中等到的是排在队首的 bucket2，于是经由 poll 返回并删除这个 bucket2；随后，时间轮会将当前时间 currentTime 往前移动到 bucket2 的 expiration 所指向的时间（图中是 1ms 所在的位置）；最后，bucket2 中包含的 task1 会被删除并执行。</li>
</ol>
<p>上述 Kafka 层级时间轮的驱动方式是非常高效的。虽然 DelayQueue 中 offer（添加）和 poll（获取并删除）操作的时间复杂度为 O(log n)，但是相比定时任务的个数而言，bucket 的个数其实是非常小的（也就是 O(log n) 中的 n 很小），因此性能也是没有问题的。</p>
<h1 id="源码分析">源码分析</h1>
<p>代码源自RussellLuo的Github,链接为:<a href="https://github.com/RussellLuo/timingwheel">https://github.com/RussellLuo/timingwheel</a></p>
<p>timingwheel中的 Golang 实现，基本上都是参考 Kafka 的层级时间轮的原理来实现的。</p>
<h2 id="utils">utils</h2>
<p>基础工具方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">timingwheel</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="c1">// truncate returns the result of rounding x toward zero to a multiple of m.
</span><span class="c1">// If m &lt;= 0, Truncate returns x unchanged.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">truncate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">x</span><span class="o">%</span><span class="nx">m</span>
<span class="p">}</span>

<span class="c1">// timeToMs returns an integer number, which represents t in milliseconds.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">UnixNano</span><span class="p">()</span> <span class="o">/</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// msToTime returns the UTC time corresponding to the given Unix time,
</span><span class="c1">// t milliseconds since January 1, 1970 UTC.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">msToTime</span><span class="p">(</span><span class="nx">t</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Unix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">t</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)).</span><span class="nf">UTC</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">waitGroupWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">waitGroupWrapper</span><span class="p">)</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">cb</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">cb</span><span class="p">()</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="delayqueue">DelayQueue</h2>
<p>因为 Golang 中没有现成的 DelayQueue 结构，所以实现了一个 DelayQueue，其中：</p>
<ul>
<li>PriorityQueue —— 从 NSQ 借用过来的 优先级队列（基于最小堆实现）。</li>
<li>DelayQueue —— Offer（添加 bucket）和 Poll（获取并删除 bucket）的运作方式，跟 Golang Timer 运行时中 addtimerLocked和 timerproc 的运作方式如出一辙，因此参考了其中的实现方式.</li>
</ul>
<p>先实现优先队列:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">delayqueue</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;container/heap&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="c1">// The start of PriorityQueue implementation.
</span><span class="c1">// Borrowed from https://github.com/nsqio/nsq/blob/master/internal/pqueue/pqueue.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Value</span>    <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">Priority</span> <span class="kt">int64</span>
	<span class="nx">Index</span>    <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// this is a priority queue as implemented by a min heap
</span><span class="c1">// ie. the 0th element is the *lowest* value
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">priorityQueue</span> <span class="p">[]</span><span class="o">*</span><span class="nx">item</span>

<span class="kd">func</span> <span class="nf">newPriorityQueue</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">priorityQueue</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">make</span><span class="p">(</span><span class="nx">priorityQueue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="nx">priorityQueue</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pq</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="nx">priorityQueue</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Priority</span> <span class="p">&lt;</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Priority</span>
<span class="p">}</span>
<span class="c1">//交换两个元素的位置
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="nx">priorityQueue</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">j</span>
<span class="p">}</span>

<span class="c1">// 向Queue中添加元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">priorityQueue</span><span class="p">)</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
    <span class="c1">// 当前容量+1超过cap的时候，会进行扩容，
</span><span class="c1"></span>	<span class="c1">// 这里扩容扩的是cap，不是length
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="p">&gt;</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="nx">npq</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">priorityQueue</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">c</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">npq</span><span class="p">,</span> <span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
		<span class="o">*</span><span class="nx">pq</span> <span class="p">=</span> <span class="nx">npq</span>
    <span class="p">}</span>
    <span class="c1">// 把length的指针向右移动一位，扩充一个空白元素用来填充x
</span><span class="c1"></span>    <span class="c1">// 把x放入到队列的末尾
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">pq</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="mi">0</span> <span class="p">:</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">item</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="o">*</span><span class="nx">item</span><span class="p">)</span>
	<span class="nx">item</span><span class="p">.</span><span class="nx">Index</span> <span class="p">=</span> <span class="nf">n</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">item</span>
<span class="p">}</span>
<span class="c1">// 弹出堆尾元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">priorityQueue</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
    <span class="c1">// 当符合条件时进行缩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">c</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="p">{</span>
		<span class="nx">npq</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">priorityQueue</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">c</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">npq</span><span class="p">,</span> <span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
		<span class="o">*</span><span class="nx">pq</span> <span class="p">=</span> <span class="nx">npq</span>
    <span class="p">}</span>
    <span class="c1">// 移除最后一个元素，将移除的元素返回
</span><span class="c1"></span>	<span class="nx">item</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">item</span><span class="p">.</span><span class="nx">Index</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="o">*</span><span class="nx">pq</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="mi">0</span> <span class="p">:</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">item</span>
<span class="p">}</span>

<span class="c1">// 如果堆顶元素大于max，则返回nil和堆顶元素与max之间的差值
</span><span class="c1">// 如果堆顶元素小于max，则返回堆顶元素，并将堆顶元素删除。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">priorityQueue</span><span class="p">)</span> <span class="nf">PeekAndShift</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">item</span><span class="p">,</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="c1">// 取出堆顶元素
</span><span class="c1"></span>    <span class="nx">item</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">// 若堆顶元素大于max，则return nil，并返回和max的差值
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Priority</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Priority</span> <span class="o">-</span> <span class="nx">max</span>
    <span class="p">}</span>
    <span class="c1">// 移除堆顶元素
</span><span class="c1"></span>	<span class="nx">heap</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">pq</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">// 将item返回
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">item</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// The end of PriorityQueue implementation.
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><p>再实现延迟队列:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">delayqueue</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;container/heap&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="c1">// DelayQueue is an unbounded blocking queue of *Delayed* elements, in which
</span><span class="c1">// an element can only be taken when its delay has expired. The head of the
</span><span class="c1">// queue is the *Delayed* element whose delay expired furthest in the past.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DelayQueue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">C</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>

	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">pq</span> <span class="nx">priorityQueue</span>

	<span class="c1">// Similar to the sleeping state of runtime.timers.
</span><span class="c1"></span>	<span class="nx">sleeping</span> <span class="kt">int32</span>
	<span class="nx">wakeupC</span>  <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// New creates an instance of delayQueue with the specified size.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">DelayQueue</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">DelayQueue</span><span class="p">{</span>
		<span class="nx">C</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}),</span>
		<span class="nx">pq</span><span class="p">:</span>      <span class="nf">newPriorityQueue</span><span class="p">(</span><span class="nx">size</span><span class="p">),</span>
		<span class="nx">wakeupC</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Offer inserts the element into the current queue.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DelayQueue</span><span class="p">)</span> <span class="nf">Offer</span><span class="p">(</span><span class="nx">elem</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">expiration</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">item</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">item</span><span class="p">{</span><span class="nx">Value</span><span class="p">:</span> <span class="nx">elem</span><span class="p">,</span> <span class="nx">Priority</span><span class="p">:</span> <span class="nx">expiration</span><span class="p">}</span>

	<span class="nx">dq</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">heap</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dq</span><span class="p">.</span><span class="nx">pq</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
	<span class="nx">index</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Index</span>
	<span class="nx">dq</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// A new item with the earliest expiration is added.
</span><span class="c1"></span>        <span class="c1">//注意此时已经不持有锁,需要使用atomic避免竞争
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dq</span><span class="p">.</span><span class="nx">sleeping</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">dq</span><span class="p">.</span><span class="nx">wakeupC</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Poll starts an infinite loop, in which it continually waits for an element to
</span><span class="c1">// expire and then send the expired element to the timing wheel via the channel C.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DelayQueue</span><span class="p">)</span> <span class="nf">Poll</span><span class="p">(</span><span class="nx">exitC</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">nowF</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//轮询,进行延迟队列的运行
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nowF</span><span class="p">()</span>

		<span class="nx">dq</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">item</span><span class="p">,</span> <span class="nx">delta</span> <span class="o">:=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">pq</span><span class="p">.</span><span class="nf">PeekAndShift</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">item</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// No items left or at least one item is pending.
</span><span class="c1"></span>
            <span class="c1">//我们必须确保整个操作的原子性
</span><span class="c1"></span>            <span class="c1">//由上面的PeekAndShift和下面的StoreInt32组成，
</span><span class="c1"></span>            <span class="c1">//避免在offer和poll之间可能出现的竞争情况。
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dq</span><span class="p">.</span><span class="nx">sleeping</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">dq</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="c1">//注意下面有大量的select-case,目的是无阻塞IO
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">item</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">delta</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// No items left.
</span><span class="c1"></span>				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">dq</span><span class="p">.</span><span class="nx">wakeupC</span><span class="p">:</span>
					<span class="c1">// Wait until a new item is added.
</span><span class="c1"></span>					<span class="k">continue</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">exitC</span><span class="p">:</span>
					<span class="k">goto</span> <span class="nx">exit</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// At least one item is pending.
</span><span class="c1"></span>				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">dq</span><span class="p">.</span><span class="nx">wakeupC</span><span class="p">:</span>
					<span class="c1">// A new item with an &#34;earlier&#34; expiration than the current &#34;earliest&#34; one is added.
</span><span class="c1"></span>					<span class="k">continue</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">):</span>
					<span class="c1">// The current &#34;earliest&#34; item expires.
</span><span class="c1"></span>
					<span class="c1">// Reset the sleeping state since there&#39;s no need to receive from wakeupC.
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">SwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dq</span><span class="p">.</span><span class="nx">sleeping</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="c1">// A caller of Offer() is being blocked on sending to wakeupC,
</span><span class="c1"></span>						<span class="c1">// drain wakeupC to unblock the caller.
</span><span class="c1"></span>						<span class="o">&lt;-</span><span class="nx">dq</span><span class="p">.</span><span class="nx">wakeupC</span>
					<span class="p">}</span>
					<span class="k">continue</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">exitC</span><span class="p">:</span>
					<span class="k">goto</span> <span class="nx">exit</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">C</span> <span class="o">&lt;-</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Value</span><span class="p">:</span>
			<span class="c1">// Send the expired element to the timing wheel.
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">exitC</span><span class="p">:</span>
			<span class="k">goto</span> <span class="nx">exit</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">exit</span><span class="p">:</span>
	<span class="c1">// Reset the states
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">dq</span><span class="p">.</span><span class="nx">sleeping</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="bucket">bucket</h2>
<p>时间轮我们是用数组也就是buckets来实现的，也就是说一个数组代表时间轮。</p>
<p>时间轮中每个格子用来保存任务的数据结构是TimeTaskList的数据结构，其实就是一个双向链表，然后每次在往某个时间轮格子里面放置任务也就是timerTaskEntry的时候就会挂置到TimeTaskList的这个对象当中去。</p>
<p>所以说我们放置到DelayedQueue当中其实是TimeTaskList对象，这个对象包含了同一过期时间的所有任务而已。减少了DelayedQueue的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">timingwheel</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;container/list&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="c1">//Timer是定时任务实体
</span><span class="c1">// Timer represents a single event. When the Timer expires, the given
</span><span class="c1">// task will be executed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">expiration</span> <span class="kt">int64</span> <span class="c1">// in milliseconds
</span><span class="c1"></span>	<span class="nx">task</span>       <span class="kd">func</span><span class="p">()</span>

	<span class="c1">// The bucket that holds the list to which this timer&#39;s element belongs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: This field may be updated and read concurrently,
</span><span class="c1"></span>    <span class="c1">// through Timer.Stop() and Bucket.Flush().
</span><span class="c1"></span>    <span class="c1">//定时任务所在的时间槽
</span><span class="c1"></span>	<span class="nx">b</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// type: *bucket
</span><span class="c1"></span>
	<span class="c1">// The timer&#39;s element.
</span><span class="c1"></span>	<span class="nx">element</span> <span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">getBucket</span><span class="p">()</span> <span class="o">*</span><span class="nx">bucket</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">bucket</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">setBucket</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Stop prevents the Timer from firing. It returns true if the call
</span><span class="c1">// stops the timer, false if the timer has already expired or been stopped.
</span><span class="c1">//
</span><span class="c1">// If the timer t has already expired and the t.task has been started in its own
</span><span class="c1">// goroutine; Stop does not wait for t.task to complete before returning. If the caller
</span><span class="c1">// needs to know whether t.task is completed, it must coordinate with t.task explicitly.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">stopped</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">for</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getBucket</span><span class="p">();</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getBucket</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// If b.Remove is called just after the timing wheel&#39;s goroutine has:
</span><span class="c1"></span>		<span class="c1">//     1. removed t from b (through b.Flush -&gt; b.remove)
</span><span class="c1"></span>		<span class="c1">//     2. moved t from b to another bucket ab (through b.Flush -&gt; b.remove and ab.Add)
</span><span class="c1"></span>		<span class="c1">// this may fail to remove t due to the change of t&#39;s bucket.
</span><span class="c1"></span>		<span class="nx">stopped</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

		<span class="c1">// Thus, here we re-get t&#39;s possibly new bucket (nil for case 1, or ab (non-nil) for case 2),
</span><span class="c1"></span>		<span class="c1">// and retry until the bucket becomes nil, which indicates that t has finally been removed.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">stopped</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">bucket</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 64-bit atomic operations require 64-bit alignment, but 32-bit
</span><span class="c1"></span>	<span class="c1">// compilers do not ensure it. So we must keep the 64-bit field
</span><span class="c1"></span>	<span class="c1">// as the first field of the struct.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For more explanations, see https://golang.org/pkg/sync/atomic/#pkg-note-BUG
</span><span class="c1"></span>	<span class="c1">// and https://go101.org/article/memory-layout.html.
</span><span class="c1"></span>	<span class="nx">expiration</span> <span class="kt">int64</span>

	<span class="nx">mu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">timers</span> <span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">List</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newBucket</span><span class="p">()</span> <span class="o">*</span><span class="nx">bucket</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{</span>
		<span class="nx">timers</span><span class="p">:</span>     <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span>
		<span class="nx">expiration</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">Expiration</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">expiration</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">SetExpiration</span><span class="p">(</span><span class="nx">expiration</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">SwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">expiration</span><span class="p">,</span> <span class="nx">expiration</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">expiration</span>
<span class="p">}</span>

<span class="c1">//时间槽内添加任务
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="c1">//添加新Timer到当前时间槽的List中
</span><span class="c1"></span>    <span class="nx">e</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">timers</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="c1">//在Timer中记录所在的时间槽和List中的element
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nf">setBucket</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">element</span> <span class="p">=</span> <span class="nx">e</span>

	<span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">remove</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getBucket</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="c1">// If remove is called from t.Stop, and this happens just after the timing wheel&#39;s goroutine has:
</span><span class="c1"></span>		<span class="c1">//     1. removed t from b (through b.Flush -&gt; b.remove)
</span><span class="c1"></span>		<span class="c1">//     2. moved t from b to another bucket ab (through b.Flush -&gt; b.remove and ab.Add)
</span><span class="c1"></span>		<span class="c1">// then t.getBucket will return nil for case 1, or ab (non-nil) for case 2.
</span><span class="c1"></span>		<span class="c1">// In either case, the returned value does not equal to b.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">timers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">element</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">setBucket</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">element</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//遍历bucket的链表,将bucket的所有任务删除并执行.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">Flush</span><span class="p">(</span><span class="nx">reinsert</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Timer</span><span class="p">))</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">timers</span><span class="p">.</span><span class="nf">Front</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">Timer</span><span class="p">)</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="nf">reinsert</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="nx">e</span> <span class="p">=</span> <span class="nx">next</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">b</span><span class="p">.</span><span class="nf">SetExpiration</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="timingwheel">timingwheel</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">timingwheel</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>

	<span class="s">&#34;./delayqueue&#34;</span>
<span class="p">)</span>

<span class="c1">// TimingWheel is an implementation of Hierarchical Timing Wheels.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TimingWheel</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tick</span>      <span class="kt">int64</span> <span class="c1">// in milliseconds 时间槽的刻度
</span><span class="c1"></span>	<span class="nx">wheelSize</span> <span class="kt">int64</span> <span class="c1">//一圈有多少刻度
</span><span class="c1"></span>
	<span class="nx">interval</span>    <span class="kt">int64</span> <span class="c1">// in milliseconds  一圈能表示多长时间
</span><span class="c1"></span>	<span class="nx">currentTime</span> <span class="kt">int64</span> <span class="c1">// in milliseconds /** 时间轮指针 */
</span><span class="c1"></span>	<span class="nx">buckets</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">bucket</span>   <span class="cm">/** 槽 */</span>
	<span class="nx">queue</span>       <span class="o">*</span><span class="nx">delayqueue</span><span class="p">.</span><span class="nx">DelayQueue</span>

	<span class="c1">// The higher-level overflow wheel.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// NOTE: This field may be updated and read concurrently, through Add().
</span><span class="c1"></span>    <span class="cm">/** 上层时间轮 */</span>
	<span class="nx">overflowWheel</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// type: *TimingWheel
</span><span class="c1"></span>
	<span class="nx">exitC</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">//退出用channel,全程select监控
</span><span class="c1"></span>	<span class="nx">waitGroup</span> <span class="nx">waitGroupWrapper</span> <span class="c1">//waitGroup里记录时间轮正在执行的并发任务,只有当waitGroup中没有了任务,时间轮的Stop才是安全的
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// NewTimingWheel creates an instance of TimingWheel with the given tick and wheelSize.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">tick</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">wheelSize</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">TimingWheel</span> <span class="p">{</span>
	<span class="nx">tickMs</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">tick</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span><span class="c1">//每格代表的时间
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tickMs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;tick must be greater than or equal to 1ms&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">startMs</span> <span class="o">:=</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">())</span>

	<span class="k">return</span> <span class="nf">newTimingWheel</span><span class="p">(</span>
		<span class="nx">tickMs</span><span class="p">,</span>
		<span class="nx">wheelSize</span><span class="p">,</span>
		<span class="nx">startMs</span><span class="p">,</span>
		<span class="nx">delayqueue</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">wheelSize</span><span class="p">)),</span>
	<span class="p">)</span>
<span class="p">}</span>

<span class="c1">// newTimingWheel is an internal helper function that really creates an instance of TimingWheel.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newTimingWheel</span><span class="p">(</span><span class="nx">tickMs</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">wheelSize</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">startMs</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">queue</span> <span class="o">*</span><span class="nx">delayqueue</span><span class="p">.</span><span class="nx">DelayQueue</span><span class="p">)</span> <span class="o">*</span><span class="nx">TimingWheel</span> <span class="p">{</span>
    <span class="c1">//按照时间轮一圈的刻度数创建时间槽
</span><span class="c1"></span>	<span class="nx">buckets</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">bucket</span><span class="p">,</span> <span class="nx">wheelSize</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buckets</span> <span class="p">{</span>
		<span class="nx">buckets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">TimingWheel</span><span class="p">{</span>
		<span class="nx">tick</span><span class="p">:</span>        <span class="nx">tickMs</span><span class="p">,</span>
		<span class="nx">wheelSize</span><span class="p">:</span>   <span class="nx">wheelSize</span><span class="p">,</span>
		<span class="nx">currentTime</span><span class="p">:</span> <span class="nf">truncate</span><span class="p">(</span><span class="nx">startMs</span><span class="p">,</span> <span class="nx">tickMs</span><span class="p">),</span>
		<span class="nx">interval</span><span class="p">:</span>    <span class="nx">tickMs</span> <span class="o">*</span> <span class="nx">wheelSize</span><span class="p">,</span>
		<span class="nx">buckets</span><span class="p">:</span>     <span class="nx">buckets</span><span class="p">,</span>
		<span class="nx">queue</span><span class="p">:</span>       <span class="nx">queue</span><span class="p">,</span>
		<span class="nx">exitC</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// add inserts the timer t into the current timing wheel.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">currentTime</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">currentTime</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="p">&lt;</span> <span class="nx">currentTime</span><span class="o">+</span><span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span> <span class="p">{</span>
        <span class="c1">//该Timer已经过期
</span><span class="c1"></span>		<span class="c1">// Already expired
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="p">&lt;</span> <span class="nx">currentTime</span><span class="o">+</span><span class="nx">tw</span><span class="p">.</span><span class="nx">interval</span> <span class="p">{</span>
        <span class="c1">//该Timer应该放在本时间轮中,
</span><span class="c1"></span>        <span class="c1">// Put it into its own bucket
</span><span class="c1"></span>
        <span class="c1">//前提先保证当前时间轮能够保存这个过期任务
</span><span class="c1"></span>        <span class="c1">//1. 拿过期时间/过期格子时间大小确认位置
</span><span class="c1"></span>        <span class="c1">//2. 由于转了多轮,所以需要通过hash确认位置
</span><span class="c1"></span>        <span class="c1">//3. 以时间格子代表的时间确认过期时间
</span><span class="c1"></span>		<span class="nx">virtualID</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="o">/</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">virtualID</span><span class="o">%</span><span class="nx">tw</span><span class="p">.</span><span class="nx">wheelSize</span><span class="p">]</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

        <span class="c1">// Set the bucket expiration time
</span><span class="c1"></span>        <span class="c1">//除非该bucekt被重用，否则一个bucket只会有1个过期时间
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">SetExpiration</span><span class="p">(</span><span class="nx">virtualID</span> <span class="o">*</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// The bucket needs to be enqueued since it was an expired bucket.
</span><span class="c1"></span>			<span class="c1">// We only need to enqueue the bucket when its expiration time has changed,
</span><span class="c1"></span>			<span class="c1">// i.e. the wheel has advanced and this bucket get reused with a new expiration.
</span><span class="c1"></span>			<span class="c1">// Any further calls to set the expiration within the same wheel cycle will
</span><span class="c1"></span>			<span class="c1">// pass in the same value and hence return false, thus the bucket with the
</span><span class="c1"></span>			<span class="c1">// same expiration will not be enqueued multiple times.
</span><span class="c1"></span>			<span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Offer</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Expiration</span><span class="p">())</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Out of the interval. Put it into the overflow wheel
</span><span class="c1"></span>        <span class="c1">//该Timer应该放在上层时间轮中
</span><span class="c1"></span>        <span class="nx">overflowWheel</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">)</span>
        <span class="c1">//如果上层时间轮不存在,创建一个新时间轮
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">overflowWheel</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">,</span>
				<span class="kc">nil</span><span class="p">,</span>
				<span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">newTimingWheel</span><span class="p">(</span>
					<span class="nx">tw</span><span class="p">.</span><span class="nx">interval</span><span class="p">,</span> <span class="c1">//上层时间轮的时间刻度是当前时间轮一整圈的时间
</span><span class="c1"></span>					<span class="nx">tw</span><span class="p">.</span><span class="nx">wheelSize</span><span class="p">,</span>
					<span class="nx">currentTime</span><span class="p">,</span>
					<span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">,</span>
				<span class="p">)),</span>
			<span class="p">)</span>
			<span class="nx">overflowWheel</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)(</span><span class="nx">overflowWheel</span><span class="p">).</span><span class="nf">add</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// addOrRun inserts the timer t into the current timing wheel, or run the
</span><span class="c1">// timer&#39;s task if it has already expired.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">addOrRun</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">tw</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Already expired
</span><span class="c1"></span>
		<span class="c1">// Like the standard time.AfterFunc (https://golang.org/pkg/time/#AfterFunc),
</span><span class="c1"></span>		<span class="c1">// always execute the timer&#39;s task in its own goroutine.
</span><span class="c1"></span>		<span class="k">go</span> <span class="nx">t</span><span class="p">.</span><span class="nf">task</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//向前移动时间格:expiration
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">advanceClock</span><span class="p">(</span><span class="nx">expiration</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">currentTime</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">currentTime</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">expiration</span> <span class="o">&gt;=</span> <span class="nx">currentTime</span><span class="o">+</span><span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span> <span class="p">{</span>
		<span class="nx">currentTime</span> <span class="p">=</span> <span class="nf">truncate</span><span class="p">(</span><span class="nx">expiration</span><span class="p">,</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">currentTime</span><span class="p">,</span> <span class="nx">currentTime</span><span class="p">)</span>

		<span class="c1">// Try to advance the clock of the overflow wheel if present
</span><span class="c1"></span>		<span class="nx">overflowWheel</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">overflowWheel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="p">(</span><span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)(</span><span class="nx">overflowWheel</span><span class="p">).</span><span class="nf">advanceClock</span><span class="p">(</span><span class="nx">currentTime</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Start starts the current timing wheel.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nx">waitGroup</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Poll</span><span class="p">(</span><span class="nx">tw</span><span class="p">.</span><span class="nx">exitC</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">())</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="nx">tw</span><span class="p">.</span><span class="nx">waitGroup</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//轮询,对延迟队列的弹出bucket进行处理,并移动当前时间
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">elem</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
                <span class="c1">//实际延迟队列弹出的是一个bucket
</span><span class="c1"></span>                <span class="nx">b</span> <span class="o">:=</span> <span class="nx">elem</span><span class="p">.(</span><span class="o">*</span><span class="nx">bucket</span><span class="p">)</span>
                <span class="c1">//向前移动时间格
</span><span class="c1"></span>                <span class="nx">tw</span><span class="p">.</span><span class="nf">advanceClock</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Expiration</span><span class="p">())</span>
                <span class="c1">//执行Timer任务,并删除Timer
</span><span class="c1"></span>				<span class="nx">b</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nx">tw</span><span class="p">.</span><span class="nx">addOrRun</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tw</span><span class="p">.</span><span class="nx">exitC</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Stop stops the current timing wheel.
</span><span class="c1">//
</span><span class="c1">// If there is any timer&#39;s task being running in its own goroutine, Stop does
</span><span class="c1">// not wait for the task to complete before returning. If the caller needs to
</span><span class="c1">// know whether the task is completed, it must coordinate with the task explicitly.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">tw</span><span class="p">.</span><span class="nx">exitC</span><span class="p">)</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nx">waitGroup</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// AfterFunc waits for the duration to elapse and then calls f in its own goroutine.
</span><span class="c1">// It returns a Timer that can be used to cancel the call using its Stop method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
		<span class="nx">expiration</span><span class="p">:</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">)),</span>
		<span class="nx">task</span><span class="p">:</span>       <span class="nx">f</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nf">addOrRun</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="c1">// Scheduler determines the execution plan of a task.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Scheduler</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Next returns the next execution time after the given (previous) time.
</span><span class="c1"></span>	<span class="c1">// It will return a zero time if no next time is scheduled.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// All times must be UTC.
</span><span class="c1"></span>	<span class="nf">Next</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>

<span class="c1">// ScheduleFunc calls f (in its own goroutine) according to the execution
</span><span class="c1">// plan scheduled by s. It returns a Timer that can be used to cancel the
</span><span class="c1">// call using its Stop method.
</span><span class="c1">//
</span><span class="c1">// If the caller want to terminate the execution plan halfway, it must
</span><span class="c1">// stop the timer and ensure that the timer is stopped actually, since in
</span><span class="c1">// the current implementation, there is a gap between the expiring and the
</span><span class="c1">// restarting of the timer. The wait time for ensuring is short since the
</span><span class="c1">// gap is very small.
</span><span class="c1">//
</span><span class="c1">// Internally, ScheduleFunc will ask the first execution time (by calling
</span><span class="c1">// s.Next()) initially, and create a timer if the execution time is non-zero.
</span><span class="c1">// Afterwards, it will ask the next execution time each time f is about to
</span><span class="c1">// be executed, and f will be called at the next execution time if the time
</span><span class="c1">// is non-zero.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">ScheduleFunc</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Scheduler</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">expiration</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">expiration</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// No time is scheduled, return nil.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">t</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
		<span class="nx">expiration</span><span class="p">:</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">expiration</span><span class="p">),</span>
		<span class="nx">task</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Schedule the task to execute at the next time if possible.
</span><span class="c1"></span>			<span class="nx">expiration</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="nf">msToTime</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">expiration</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="p">=</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">expiration</span><span class="p">)</span>
				<span class="nx">tw</span><span class="p">.</span><span class="nf">addOrRun</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="c1">// Actually execute the task.
</span><span class="c1"></span>			<span class="nf">f</span><span class="p">()</span>
		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nf">addOrRun</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="examples">examples</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">timingwheel_test</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/RussellLuo/timingwheel&#34;</span>
<span class="p">)</span>


<span class="kd">func</span> <span class="nf">Example_startTimer</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">tw</span> <span class="o">:=</span> <span class="nx">timingwheel</span><span class="p">.</span><span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">tw</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">exitC</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The timer fires&#34;</span><span class="p">)</span>
		<span class="nx">exitC</span> <span class="o">&lt;-</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="o">&lt;-</span><span class="nx">exitC</span>

	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// The timer fires
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Example_stopTimer</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">tw</span> <span class="o">:=</span> <span class="nx">timingwheel</span><span class="p">.</span><span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">tw</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">tw</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The timer fires&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">900</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="c1">// Stop the timer before it fires
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span><span class="p">}</span>


<span class="kd">type</span> <span class="nx">EveryScheduler</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Interval</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">EveryScheduler</span><span class="p">)</span> <span class="nf">Next</span><span class="p">(</span><span class="nx">prev</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">prev</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Interval</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Example_scheduleTimer</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">tw</span> <span class="o">:=</span> <span class="nx">timingwheel</span><span class="p">.</span><span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
	<span class="nx">tw</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">tw</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">exitC</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">tw</span><span class="p">.</span><span class="nf">ScheduleFunc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">EveryScheduler</span><span class="p">{</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">},</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The timer fires&#34;</span><span class="p">)</span>
		<span class="nx">exitC</span> <span class="o">&lt;-</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="o">&lt;-</span><span class="nx">exitC</span>
	<span class="o">&lt;-</span><span class="nx">exitC</span>

	<span class="c1">// We need to stop the timer since it will be restarted again and again.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">}</span>

	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// The timer fires
</span><span class="c1"></span>	<span class="c1">// The timer fires
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>参考:
<a href="http://russellluo.com/2018/10/golang-implementation-of-hierarchical-timing-wheels.html">http://russellluo.com/2018/10/golang-implementation-of-hierarchical-timing-wheels.html</a>
<a href="https://www.jianshu.com/p/87240220097b">https://www.jianshu.com/p/87240220097b</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-10-23
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          <a href="/tags/%E6%97%B6%E9%97%B4%E8%BD%AE/">时间轮</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/container%E5%8C%85%E8%A7%A3%E6%9E%90-1-13/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">container包解析(1.13)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/golang%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96mysql%E7%9A%84%E5%90%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/">
            <span class="next-text nav-default">Golang如何获取MySQL的各类型数据</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Forz</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
