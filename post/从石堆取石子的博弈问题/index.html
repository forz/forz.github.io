<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>从石堆取石子的博弈问题 | Forz Blog</title>
<meta name="keywords" content="Math, 博弈DP" />
<meta name="description" content="LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game.">
<meta name="author" content="">
<link rel="canonical" href="/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="从石堆取石子的博弈问题" />
<meta property="og:description" content="LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T22:11:34&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T22:11:34&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从石堆取石子的博弈问题"/>
<meta name="twitter:description" content="LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "从石堆取石子的博弈问题",
      "item": "/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从石堆取石子的博弈问题",
  "name": "从石堆取石子的博弈问题",
  "description": "LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game.",
  "keywords": [
    "Math", "博弈DP"
  ],
  "articleBody": "LeetCode 292. Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\nHint:\nIf there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?\n解析：\n题目说给我们一堆石子，每次可以拿一个两个或三个，两个人轮流拿，拿到最后一个石子的人获胜，现在给我们一堆石子的个数，问我们能不能赢。那么我们就从最开始分析，由于是我们先拿，那么3个以内(包括3个)的石子，我们直接赢，如果共4个，那么我们一定输，因为不管我们取几个，下一个人一次都能取完。如果共5个，我们赢，因为我们可以取一个，然后变成4个让别人取，根据上面的分析我们赢，所以我们列出1到10个的情况如下：\n1 Win\n2 Win\n3 Win\n4 Lost\n5 Win\n6 Win\n7 Win\n8 Lost\n9 Win\n10 Win\n由此我们可以发现规律，只要是4的倍数个，我们一定会输，所以对4取余即可，参见代码如下：\n1 2 3 4 5 6  class Solution { public: bool canWinNim(int n) { return n % 4; } };   LeetCode 464. Can I Win In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.\nWhat if we change the game so that players cannot re-use integers?\nFor example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total = 100.\nGiven an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.\nYou can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\nExample\nInput:\nmaxChoosableInteger = 10 desiredTotal = 11  Output:\nfalse  Explanation:\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is = desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n题意： 两个人玩游戏，给了两个数maxChoosableInteger ，desiredTotal，从第一个人开始，可以从1到maxChoosableInteger 当中选一个数字（不能用用过的，第一个人第一轮可以随便选），加到当前的累计和当中（这个从0开始），若此时超过desiredTotal，那么第一个人赢，不然换第二个人，每个人开始前都不能选前面已经用过的数字，第二个人选一个数同样累加，若超过desiredTotal第二个人赢，不然交给第一个人，重复这个步骤 有没有什么策略可以保证第一个一定赢？\n解析：\n博弈DP，用记忆化搜索来做。保证一定赢就是当前选中某个数，不管对方选什么都一定会赢\n因为可选的数字不超过20，所以可用int的某一位来代表是否该数已被选中（状态压缩），然后用map建立一个visit数组来表示这种情况是否已访问。\n赢的方法：\n如果要选的这个i大于target，此时选择i，赢了\n对方输了\ncanWin(target - i, mask | visited) == false，//（mask | visited表示把i那位也标记为1）  这个时候把visited情况存起来并且return true，表示赢了\n输的方法：\n如果所有数字都遍历完还是没有return true，那就最后return false，\n把当前状态存储起来，也就是m[visited] = false;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { private: int maxn; mapint, bool m; //用map标记当前情况在map表中是否存在，存在的话结果保存在map里面 public: bool canIWin(int maxChoosableInteger, int desiredTotal) { maxn = maxChoosableInteger; if(maxn = desiredTotal) return true;//先手必胜  if((1 + maxn) * maxn / 2  desiredTotal) return false;//后手必胜（所有数的和都没超过desiredTotal）  return canWin(desiredTotal, 0);//dfs需要目标值和当前选择情况 } bool canWin(int target, int visited) {//状态压缩 //需要用visited标记某个数字是否被选过～因为可选的数字最大不超过20，则可以用一个整型数标记，因为整型有32位  if(m.count(visited)) return m[visited];//直接返回当前情况  for(int i = 1; i  maxn; i++) {//枚举数  int mask = (1  i);//标记visit //如果mask和visited进行与运算，如果等于0说明当前的visited没有被访问过，就可以考虑这个i的情况。  if((mask \u0026 visited) == 0 \u0026\u0026 (i = target || canWin(target - i, mask | visited) == false)) { m[visited] = true; return true; } } m[visited] = false; return false; } };   ",
  "wordCount" : "1577",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T22:11:34Z",
  "dateModified": "2017-06-24T22:11:34Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E4%BB%8E%E7%9F%B3%E5%A0%86%E5%8F%96%E7%9F%B3%E5%AD%90%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      从石堆取石子的博弈问题
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-292-nim-game">LeetCode 292. Nim Game<a hidden class="anchor" aria-hidden="true" href="#leetcode-292-nim-game">#</a></h1>
<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<p>Hint:</p>
<p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p>
<p>解析：</p>
<p>题目说给我们一堆石子，每次可以拿一个两个或三个，两个人轮流拿，拿到最后一个石子的人获胜，现在给我们一堆石子的个数，问我们能不能赢。那么我们就从最开始分析，由于是我们先拿，那么3个以内(包括3个)的石子，我们直接赢，如果共4个，那么我们一定输，因为不管我们取几个，下一个人一次都能取完。如果共5个，我们赢，因为我们可以取一个，然后变成4个让别人取，根据上面的分析我们赢，所以我们列出1到10个的情况如下：</p>
<p>1 Win</p>
<p>2 Win</p>
<p>3 Win</p>
<p>4 Lost</p>
<p>5 Win</p>
<p>6 Win</p>
<p>7 Win</p>
<p>8 Lost</p>
<p>9 Win</p>
<p>10 Win</p>
<p>由此我们可以发现规律，只要是4的倍数个，我们一定会输，所以对4取余即可，参见代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">canWinNim</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-464-can-i-win">LeetCode 464. Can I Win<a hidden class="anchor" aria-hidden="true" href="#leetcode-464-can-i-win">#</a></h1>
<p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.</p>
<p>Example</p>
<p>Input:</p>
<pre><code>maxChoosableInteger = 10
desiredTotal = 11
</code></pre>
<p>Output:</p>
<pre><code>false
</code></pre>
<p>Explanation:</p>
<p>No matter which integer the first player choose, the first player will lose.</p>
<p>The first player can choose an integer from 1 up to 10.</p>
<p>If the first player choose 1, the second player can only choose integers from 2 up to 10.</p>
<p>The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</p>
<p>Same with other integers chosen by the first player, the second player will always win.</p>
<p>题意：
两个人玩游戏，给了两个数maxChoosableInteger ，desiredTotal，从第一个人开始，可以从1到maxChoosableInteger 当中选一个数字（不能用用过的，第一个人第一轮可以随便选），加到当前的累计和当中（这个从0开始），若此时超过desiredTotal，那么第一个人赢，不然换第二个人，每个人开始前都不能选前面已经用过的数字，第二个人选一个数同样累加，若超过desiredTotal第二个人赢，不然交给第一个人，重复这个步骤 有没有什么策略可以保证第一个一定赢？</p>
<p>解析：</p>
<p>博弈DP，用记忆化搜索来做。保证一定赢就是当前选中某个数，不管对方选什么都一定会赢</p>
<p>因为可选的数字不超过20，所以可用int的某一位来代表是否该数已被选中（状态压缩），然后用map建立一个visit数组来表示这种情况是否已访问。</p>
<p>赢的方法：</p>
<p>如果要选的这个i大于target，此时选择i，赢了</p>
<p>对方输了</p>
<pre><code>canWin(target - i, mask | visited) == false，//（mask | visited表示把i那位也标记为1）
</code></pre>
<p>这个时候把visited情况存起来并且return true，表示赢了</p>
<p>输的方法：</p>
<p>如果所有数字都遍历完还是没有return true，那就最后return false，</p>
<p>把当前状态存储起来，也就是m[visited] = false;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">private</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">maxn</span><span class="p">;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="c1">//用map标记当前情况在map表中是否存在，存在的话结果保存在map里面
</span><span class="c1"></span><span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">canIWin</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxChoosableInteger</span><span class="p">,</span> <span class="kt">int</span> <span class="n">desiredTotal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">maxn</span> <span class="o">=</span> <span class="n">maxChoosableInteger</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">maxn</span> <span class="o">&gt;=</span> <span class="n">desiredTotal</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//先手必胜
</span><span class="c1"></span>    <span class="k">if</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">maxn</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxn</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">desiredTotal</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//后手必胜（所有数的和都没超过desiredTotal）
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">canWin</span><span class="p">(</span><span class="n">desiredTotal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//dfs需要目标值和当前选择情况
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">bool</span> <span class="n">canWin</span><span class="p">(</span><span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">visited</span><span class="p">)</span> <span class="p">{</span><span class="c1">//状态压缩
</span><span class="c1">//需要用visited标记某个数字是否被选过～因为可选的数字最大不超过20，则可以用一个整型数标记，因为整型有32位
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">visited</span><span class="p">))</span> <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">visited</span><span class="p">];</span><span class="c1">//直接返回当前情况
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//枚举数
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span><span class="c1">//标记visit
</span><span class="c1">//如果mask和visited进行与运算，如果等于0说明当前的visited没有被访问过，就可以考虑这个i的情况。
</span><span class="c1"></span>        <span class="k">if</span><span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">target</span> <span class="o">||</span> <span class="n">canWin</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="o">|</span> <span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">[</span><span class="n">visited</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">m</span><span class="p">[</span><span class="n">visited</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/math/">Math</a></li>
      <li><a href="/tags/%E5%8D%9A%E5%BC%88dp/">博弈DP</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
