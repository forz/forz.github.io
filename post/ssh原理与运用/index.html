<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SSH原理与运用 | Forz Blog</title>
<meta name="keywords" content="Shell" />
<meta name="description" content="一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输">
<meta name="author" content="">
<link rel="canonical" href="/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="SSH原理与运用" />
<meta property="og:description" content="一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-15T18:43:05&#43;00:00" />
<meta property="article:modified_time" content="2018-11-15T18:43:05&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SSH原理与运用"/>
<meta name="twitter:description" content="一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "SSH原理与运用",
      "item": "/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSH原理与运用",
  "name": "SSH原理与运用",
  "description": "一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输",
  "keywords": [
    "Shell"
  ],
  "articleBody": "一、什么是SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。\n传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。\nSSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。\n二、最基本的用法 SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。\n　$ ssh user@host\n如果本地用户名与远程用户名一致，登录时可以省略用户名。\n　$ ssh host\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。\n　$ ssh -p 2222 user@host\n上面这条命令表示，ssh直接连接远程主机的2222端口。\n三、中间人攻击 SSH之所以能够保证安全，原因在于它采用了公钥加密。\n整个过程是这样的：\n（1）远程主机收到用户的登录请求，把自己的公钥发给用户。\n（2）用户使用这个公钥，将登录密码加密后，发送回来。\n（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。\n这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。\n可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的\"中间人攻击\"（Man-in-the-middle attack）。\nSSH协议是如何应对的呢？\n四、口令登录 如果你是第一次登录对方主机，系统会出现下面的提示：\n　$ ssh user@host\n　The authenticity of host ‘host (12.18.429.21)’ can’t be established.\n　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n　Are you sure you want to continue connecting (yes/no)?\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？\n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。\n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。\n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。\n　Are you sure you want to continue connecting (yes/no)? yes\n系统会出现一句提示，表示host主机已经得到认可。\n　Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.\n然后，会要求输入密码。\n　Password: (enter password)\n如果密码正确，就可以登录了。\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n五、公钥登录 使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n　$ ssh-keygen\n运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n　$ ssh-copy-id user@host\n好了，从此你再登录，就不需要输入密码了。\n如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面\"#“注释是否取掉。\nRSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys  然后，重启远程主机的ssh服务。\n　// ubuntu系统 service ssh restart\n　// debian系统 /etc/init.d/ssh restart\n六、authorized_keys文件 远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\\$ ssh user@host 'mkdir -p .ssh \u0026\u0026 cat  .ssh/authorized_keys'  这条命令由多个语句组成，依次分解开来看：\n（1）\"$ ssh user@host”，表示登录远程主机；\n（2）单引号中的mkdir .ssh \u0026\u0026 cat » .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n（4）‘cat » .ssh/authorized_keys’ 写入authorized_keys文件后，公钥登录的设置就完成了。\n七、远程操作 SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。\n上一节的操作，就是一个例子：\n$ ssh user@host 'mkdir -p .ssh \u0026\u0026 cat  .ssh/authorized_keys'  单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。\n这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。\n下面看几个例子。\n【例1】\n将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。\n$ cd \u0026\u0026 tar czv src | ssh user@host 'tar xz'  【例2】\n将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。\n$ ssh user@host 'tar cz src' | tar xzv  【例3】\n查看远程主机是否运行进程httpd。\n$ ssh user@host 'ps ax | grep [h]ttpd'  八、绑定本地端口 既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。\n假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：\n$ ssh -D 8080 user@host  SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。\n九、端口转发 什么是SSH端口转发？ SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是， SSH 还能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做“隧道”（ tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如， Telnet， SMTP， LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时， 如果工作环境中的防火墙限制了一些网络端口的使用，但是允许SSH的连接，也能够通过将 TCP 端口转发来使用 SSH 进行通讯。\nSSH 端口转发能够提供两大功能：\n加密 SSH Client 端至 SSH Server 端之间的通讯数据\n突破防火墙的限制完成一些之前无法建立的 TCP 连接\n1、本地端口转发 主机A 地址 172.16.250.90/16\n主机B 地址 172.16.33.166/16\n主机C 地址 172.16.250.240/16 (mysql 服务器)\n以上有主机A、B、C三台服务器现在A要求访问C的mysql服务但是因为各种原因暂时无法访问（你可以把它理解为三台主机并联不同网段，由于我是实验环境所有没有设置不同网段所以各位见谅），但现在主机B可以访问，要求利用ssh的端口转发实现（iptables端口映射也是可以实现的。）\n注意:在做下面的实验时请把防火墙关掉（当然你如果不怕麻烦又可以自己配置iptables则另当别论）。\n在主机A上执行以下命令：\n ssh -L 13306:172.16.250.240:3306 root@172.16.33.166  以上命令的意思是绑定本地（主机A）的13306端口，然后指定主机B将所有的数据转发到目的主机C的3306端口。（如上命令只能是绑定主机A的环回地址）\n2、远程转发 主机A 地址 172.16.250.90/16\n主机B 地址 172.16.33.166/16\n主机C 地址 172.16.250.240/16 (mysql 服务器)\n还是看上面的例子，如果此时主机B是一台内网地址，主机B可以连接主机A，相反主机A却不能连接主机B，所以此时本地端口转发就不能用了。\n解决办法是，先让主机B连接主机A，再让主机A利用这条连接去做端口转发，便可以实现主机A连接主机C。\n在主机B上执行以下命令：\nssh –R 13306:172.16.250.16:3306 172.16.250.90  以上命令R参数接收3个值，分别为远程主机端口：目标主机：目标主机端口。意思是让主机A监听它13306端口，然后所有数据经过主机B转发到主机C的3306端口，对于主机B来说主机A为远程端口，所以此种方法被称为“远程端口转发”.\n3、动态端口转发 假设此时需要翻墙访问facebook等网站，但现在没有好的翻墙软件恰巧你有一台国外的虚拟主机主机B此时只需在主机A上做一个动态端口转发即可。\n在主机A上执行以下命令\nssh –L 8080 root@172.16.250.240  此时只需在浏览器中配置主机A的ip地址为代理服务器则即可访问facebook。\n十、SSH的其他参数 SSH还有一些别的参数，也值得介绍。\nN参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。\n　$ ssh -NT -D 8080 host\nf参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。\n　$ ssh -f -D 8080 host\n要关闭这个后台连接，就只有用kill命令去杀掉进程。\n十一、ssh服务器端配置文件 配置文件 /ect/ssh/sshd_config\n常用参数：\nPort # 可修改ssh访问端口 ListenAddress ip #监听IP PermitRootLogin yes #是否允许ssh远程登录root帐号 ClientAliveInterval 0 #客户端连接数 UseDNS yes\t#DNS解析  限制可登录用户的办法：\nAllowUsers user1 user2 user3 #允许ssh登录用户 DenyUsers\t#禁止ssh登陆用户 AllowGroups\t#允许ssh登录用户组 DenyGroups\t##禁止ssh登陆用户组  十二、SSH关闭 经常出现ssh连接由于网络问题，“卡住”了。不能进行任何操作，也不能退出。\n这里有一个更加优雅的退出ssh客户端的方法：\n~.\n是的，在一行的开始，输入『～』跟着『.』就可以结束ssh了。\n如果不在一行的开始，这个命令是无效的，这个时候可以先按一下回车，再输入上面的命令。\n参考:\nhttp://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\nhttp://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html\nhttps://www.robberphex.com/2017/10/768\n",
  "wordCount" : "4644",
  "inLanguage": "zh-cn",
  "datePublished": "2018-11-15T18:43:05Z",
  "dateModified": "2018-11-15T18:43:05Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%90%E7%94%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      SSH原理与运用
    </h1>
    <div class="post-meta">November 15, 2018
</div>
  </header> 
  <div class="post-content"><h1 id="一什么是ssh">一、什么是SSH？<a hidden class="anchor" aria-hidden="true" href="#一什么是ssh">#</a></h1>
<p>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。</p>
<p>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。</p>
<p>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。</p>
<h1 id="二最基本的用法">二、最基本的用法<a hidden class="anchor" aria-hidden="true" href="#二最基本的用法">#</a></h1>
<p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p>
<p>　　$ ssh user@host</p>
<p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>
<p>　　$ ssh host</p>
<p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p>
<p>　　$ ssh -p 2222 user@host</p>
<p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p>
<h1 id="三中间人攻击">三、中间人攻击<a hidden class="anchor" aria-hidden="true" href="#三中间人攻击">#</a></h1>
<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>
<p>整个过程是这样的：</p>
<p>（1）远程主机收到用户的登录请求，把自己的公钥发给用户。</p>
<p>（2）用户使用这个公钥，将登录密码加密后，发送回来。</p>
<p>（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>
<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的&quot;中间人攻击&quot;（Man-in-the-middle attack）。</p>
<p>SSH协议是如何应对的呢？</p>
<h1 id="四口令登录">四、口令登录<a hidden class="anchor" aria-hidden="true" href="#四口令登录">#</a></h1>
<p>如果你是第一次登录对方主机，系统会出现下面的提示：</p>
<p>　　$ ssh user@host</p>
<p>　　The authenticity of host &lsquo;host (12.18.429.21)&rsquo; can&rsquo;t be established.</p>
<p>　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</p>
<p>　　Are you sure you want to continue connecting (yes/no)?</p>
<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p>
<p>所谓&quot;公钥指纹&quot;，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p>
<p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>
<p>　　Are you sure you want to continue connecting (yes/no)? yes</p>
<p>系统会出现一句提示，表示host主机已经得到认可。</p>
<p>　　Warning: Permanently added &lsquo;host,12.18.429.21&rsquo; (RSA) to the list of known hosts.</p>
<p>然后，会要求输入密码。</p>
<p>　　Password: (enter password)</p>
<p>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>
<h1 id="五公钥登录">五、公钥登录<a hidden class="anchor" aria-hidden="true" href="#五公钥登录">#</a></h1>
<p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p>
<p>所谓&quot;公钥登录&quot;，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>
<p>　　$ ssh-keygen</p>
<p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p>
<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</p>
<p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>
<p>　　$ ssh-copy-id user@host</p>
<p>好了，从此你再登录，就不需要输入密码了。</p>
<p>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面&quot;#&ldquo;注释是否取掉。</p>
<pre><code>RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
</code></pre>
<p>然后，重启远程主机的ssh服务。</p>
<p>　　// ubuntu系统
　　service ssh restart</p>
<p>　　// debian系统
　　/etc/init.d/ssh restart</p>
<h1 id="六authorized_keys文件">六、authorized_keys文件<a hidden class="anchor" aria-hidden="true" href="#六authorized_keys文件">#</a></h1>
<p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>
<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>
<pre><code>\$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub
</code></pre>
<p>这条命令由多个语句组成，依次分解开来看：</p>
<p>（1）&quot;$ ssh user@host&rdquo;，表示登录远程主机；</p>
<p>（2）单引号中的mkdir .ssh &amp;&amp; cat &raquo; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</p>
<p>（3）&quot;$ mkdir -p .ssh&quot;的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</p>
<p>（4）&lsquo;cat &raquo; .ssh/authorized_keys&rsquo; &lt; ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</p>
<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>
<h1 id="七远程操作">七、远程操作<a hidden class="anchor" aria-hidden="true" href="#七远程操作">#</a></h1>
<p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。</p>
<p>上一节的操作，就是一个例子：</p>
<pre><code>$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub
</code></pre>
<p>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。</p>
<p>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p>
<p>下面看几个例子。</p>
<p>【例1】</p>
<p>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。</p>
<pre><code>$ cd &amp;&amp; tar czv src | ssh user@host 'tar xz'
</code></pre>
<p>【例2】</p>
<p>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。</p>
<pre><code>$ ssh user@host 'tar cz src' | tar xzv
</code></pre>
<p>【例3】</p>
<p>查看远程主机是否运行进程httpd。</p>
<pre><code>$ ssh user@host 'ps ax | grep [h]ttpd'
</code></pre>
<h1 id="八绑定本地端口">八、绑定本地端口<a hidden class="anchor" aria-hidden="true" href="#八绑定本地端口">#</a></h1>
<p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。</p>
<p>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：</p>
<pre><code>$ ssh -D 8080 user@host
</code></pre>
<p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p>
<h1 id="九端口转发">九、端口转发<a hidden class="anchor" aria-hidden="true" href="#九端口转发">#</a></h1>
<h2 id="什么是ssh端口转发">什么是SSH端口转发？<a hidden class="anchor" aria-hidden="true" href="#什么是ssh端口转发">#</a></h2>
<p>SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是， SSH 还能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做“隧道”（ tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如， Telnet， SMTP， LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时， 如果工作环境中的防火墙限制了一些网络端口的使用，但是允许SSH的连接，也能够通过将 TCP 端口转发来使用 SSH 进行通讯。</p>
<p>SSH 端口转发能够提供两大功能：</p>
<p>加密 SSH Client 端至 SSH Server 端之间的通讯数据</p>
<p>突破防火墙的限制完成一些之前无法建立的 TCP 连接</p>
<h2 id="1本地端口转发">1、本地端口转发<a hidden class="anchor" aria-hidden="true" href="#1本地端口转发">#</a></h2>
<p>主机A 地址 172.16.250.90/16</p>
<p>主机B 地址 172.16.33.166/16</p>
<p>主机C 地址 172.16.250.240/16 (mysql 服务器)</p>
<p>以上有主机A、B、C三台服务器现在A要求访问C的mysql服务但是因为各种原因暂时无法访问（你可以把它理解为三台主机并联不同网段，由于我是实验环境所有没有设置不同网段所以各位见谅），但现在主机B可以访问，要求利用ssh的端口转发实现（iptables端口映射也是可以实现的。）</p>
<p>注意:在做下面的实验时请把防火墙关掉（当然你如果不怕麻烦又可以自己配置iptables则另当别论）。</p>
<p>在主机A上执行以下命令：</p>
<pre><code>  ssh  -L  13306:172.16.250.240:3306 root@172.16.33.166 
</code></pre>
<p>以上命令的意思是绑定本地（主机A）的13306端口，然后指定主机B将所有的数据转发到目的主机C的3306端口。（如上命令只能是绑定主机A的环回地址）</p>
<h2 id="2远程转发">2、远程转发<a hidden class="anchor" aria-hidden="true" href="#2远程转发">#</a></h2>
<p>主机A 地址 172.16.250.90/16</p>
<p>主机B 地址 172.16.33.166/16</p>
<p>主机C 地址 172.16.250.240/16 (mysql 服务器)</p>
<p>还是看上面的例子，如果此时主机B是一台内网地址，主机B可以连接主机A，相反主机A却不能连接主机B，所以此时本地端口转发就不能用了。</p>
<p>解决办法是，先让主机B连接主机A，再让主机A利用这条连接去做端口转发，便可以实现主机A连接主机C。</p>
<p>在主机B上执行以下命令：</p>
<pre><code>ssh –R 13306:172.16.250.16:3306 172.16.250.90 
</code></pre>
<p>以上命令R参数接收3个值，分别为远程主机端口：目标主机：目标主机端口。意思是让主机A监听它13306端口，然后所有数据经过主机B转发到主机C的3306端口，对于主机B来说主机A为远程端口，所以此种方法被称为“远程端口转发”.</p>
<h2 id="3动态端口转发">3、动态端口转发<a hidden class="anchor" aria-hidden="true" href="#3动态端口转发">#</a></h2>
<p>假设此时需要翻墙访问facebook等网站，但现在没有好的翻墙软件恰巧你有一台国外的虚拟主机主机B此时只需在主机A上做一个动态端口转发即可。</p>
<p>在主机A上执行以下命令</p>
<pre><code>ssh –L 8080 root@172.16.250.240 
</code></pre>
<p>此时只需在浏览器中配置主机A的ip地址为代理服务器则即可访问facebook。</p>
<h1 id="十ssh的其他参数">十、SSH的其他参数<a hidden class="anchor" aria-hidden="true" href="#十ssh的其他参数">#</a></h1>
<p>SSH还有一些别的参数，也值得介绍。</p>
<p>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p>
<p>　　$ ssh -NT -D 8080 host</p>
<p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p>
<p>　　$ ssh -f -D 8080 host</p>
<p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p>
<h1 id="十一ssh服务器端配置文件">十一、ssh服务器端配置文件<a hidden class="anchor" aria-hidden="true" href="#十一ssh服务器端配置文件">#</a></h1>
<p>配置文件 /ect/ssh/sshd_config</p>
<p>常用参数：</p>
<pre><code>Port  # 可修改ssh访问端口

ListenAddress ip   #监听IP

PermitRootLogin yes  #是否允许ssh远程登录root帐号

ClientAliveInterval 0   #客户端连接数

UseDNS yes		#DNS解析
</code></pre>
<p>限制可登录用户的办法：</p>
<pre><code>AllowUsers user1 user2 user3    #允许ssh登录用户

DenyUsers			#禁止ssh登陆用户

AllowGroups		#允许ssh登录用户组

DenyGroups		##禁止ssh登陆用户组
</code></pre>
<h1 id="十二ssh关闭">十二、SSH关闭<a hidden class="anchor" aria-hidden="true" href="#十二ssh关闭">#</a></h1>
<p>经常出现ssh连接由于网络问题，“卡住”了。不能进行任何操作，也不能退出。</p>
<p>这里有一个更加优雅的退出ssh客户端的方法：</p>
<p>~.</p>
<p>是的，在一行的开始，输入『～』跟着『.』就可以结束ssh了。</p>
<p>如果不在一行的开始，这个命令是无效的，这个时候可以先按一下回车，再输入上面的命令。</p>
<p>参考:</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>
<p><a href="https://www.robberphex.com/2017/10/768">https://www.robberphex.com/2017/10/768</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/shell/">Shell</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
