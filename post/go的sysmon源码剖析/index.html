<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的sysmon源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.89.3 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84sysmon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的sysmon源码剖析" />
<meta property="og:description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84sysmon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-12T19:32:21+00:00" />
<meta property="article:modified_time" content="2020-11-12T19:32:21+00:00" />

<meta itemprop="name" content="Go的sysmon源码剖析">
<meta itemprop="description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触"><meta itemprop="datePublished" content="2020-11-12T19:32:21+00:00" />
<meta itemprop="dateModified" content="2020-11-12T19:32:21+00:00" />
<meta itemprop="wordCount" content="9159">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的sysmon源码剖析"/>
<meta name="twitter:description" content="设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的sysmon源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-11-12 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 9159 字 </span>
          <span class="more-meta"> 预计阅读 19 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原理">设计原理</a></li>
    <li><a href="#sysmon启动">sysmon启动</a></li>
    <li><a href="#sysmon">sysmon</a></li>
    <li><a href="#checkdead">checkdead</a></li>
    <li><a href="#incidlelocked">incidlelocked</a></li>
    <li><a href="#injectglist">injectglist</a></li>
    <li><a href="#retake">retake</a>
      <ul>
        <li><a href="#抢占进行系统调用的-p">抢占进行系统调用的 P</a></li>
        <li><a href="#抢占长时间运行的-p">抢占长时间运行的 P</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计原理">设计原理</h2>
<p>Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收，通过这些行为，它能够让系统的运行状态变得更健康。</p>
<p>Go程序启动时，runtime会去启动一个名为sysmon的m(一般称为监控线程)，它自身通过 newm 在一个 M 上独立运行， 自身永远保持在一个循环内直到应用结束。</p>
<p>高优先级，在专有线程中执行 不需要绑定 P 就可以执行</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810193647.png" alt=""></p>
<p>负责:</p>
<ul>
<li>检查是否已经没有活动线程，如果是，则崩溃</li>
<li>轮询 netpoll</li>
<li>剥离在 syscall 上阻塞的 M 的 P 发信号</li>
<li>抢占已经执行时间过⻓的 G</li>
</ul>
<p>这里需要注意的是,在写网络应用的时候,其实并没有办法检查死锁,因为至少有一个线程等待fd ready事件</p>
<p>下图为sysmon执行的时间:</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210810193706.png" alt=""></p>
<h2 id="sysmon启动">sysmon启动</h2>
<p>当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">!=</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="nx">sysmon</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.newm 会创建一个存储待执行函数和处理器的新结构体 runtime.m。运行时执行系统监控不需要处理器，系统监控的 Goroutine 会直接在创建的线程上运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 创建 m 对象
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="c1">// 暂存 m
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">sigmask</span> <span class="p">=</span> <span class="nx">initSigmask</span>
	<span class="o">...</span>
	<span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime.newm1 会调用特定平台的 runtime.newsproc 通过系统调用 clone 创建一个新的线程并在新的线程中执行 runtime.mstart：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">stk</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">oset</span> <span class="nx">sigset</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sigset_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nf">clone</span><span class="p">(</span><span class="nx">cloneFlags</span><span class="p">,</span> <span class="nx">stk</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">mstart</span><span class="p">)))</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后执行 mstart 函数，这是在 newosproc 函数传递进来的。mstart 函数再调用 mstart1，在 mstart1 里会执行这一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 执行启动函数。初始化过程中，fn == nil
</span><span class="c1"></span><span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nf">fn</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>之前我们在讲初始化的时候，这里的 fn 是空，会跳过的。但在这里，fn 就是最开始在 runtime.main 里设置的 sysmon 函数，因此这里会执行 sysmon，而它又是一个无限循环，永不返回。</p>
<p>所以，这里不会执行到 mstart1 函数后面的 schedule 函数，也就不会进入 schedule 循环。因此这是一个不用和 p 结合的 m，它直接在后台执行，默默地执行监控任务。</p>
<h2 id="sysmon">sysmon</h2>
<p>sysmon 执行一个无限循环，一开始每次循环休眠 20us，之后（1 ms 后）每次休眠时间倍增，最终每一轮都会休眠 10ms。</p>
<p>sysmon 中会进行 netpool（获取 fd 事件）、retake（抢占）、forcegc（按时间强制执行 gc），scavenge heap（释放自由列表中多余的项减少内存占用）等处理。</p>
<p>在新创建的线程中，我们会执行存储在 runtime.m 结构体中的 runtime.sysmon 函数启动系统监控：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Always runs without a P, so write barriers are not allowed.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1">//首先注意，forcegcperiod是定义在sysmon函数外边的。它的含义是强制执行GC的时间间隔，默认是2分钟。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">forcegcperiod</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mf">1e9</span>  <span class="c1">//强制GC的时间间隔/2分钟/
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

    <span class="nx">lasttrace</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">//idle表示最近已连续有多少次系统监测任务执行但未能成功夺取P。一旦某次执行过程中成功夺取P，其值就会清零。
</span><span class="c1"></span>    <span class="nx">idle</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// how many cycles in succession we had not wokeup somebody
</span><span class="c1"></span>    <span class="c1">//delay表示系统监测任务具体的睡眠时间，单位为微秒。最大值为10000us，即10ms。
</span><span class="c1"></span>	<span class="nx">delay</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">idle</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// start with 20us sleep...
</span><span class="c1"></span>			<span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">idle</span> <span class="p">&gt;</span> <span class="mi">50</span> <span class="p">{</span> <span class="c1">// start doubling the sleep after 1ms...
</span><span class="c1"></span>			<span class="nx">delay</span> <span class="o">*=</span> <span class="mi">2</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">delay</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="mi">1000</span> <span class="p">{</span> <span class="c1">// up to 10ms
</span><span class="c1"></span>			<span class="nx">delay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>
		<span class="p">}</span>
		<span class="nf">usleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
		<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
        <span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
        <span class="c1">//STW时休眠sysmon
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span> <span class="p">{</span>
            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
            <span class="c1">//如果发现有串行运行时任务等待执行，或所有P都已空闲，也就是没活干了，那么就继续睡。
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">next</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
                <span class="c1">//设置休眠标志,休眠(有个超时,苏醒保障)
</span><span class="c1"></span>                <span class="c1">//睡之前将调度器的sysmonwait字段设置为1，表示系统监测任务已停止。
</span><span class="c1"></span>					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="c1">// Make wake-up period small enough
</span><span class="c1"></span>                    <span class="c1">// for the sampling to be correct.
</span><span class="c1"></span>                    <span class="c1">//这次睡的时间是forcegcperiod和scavengelimit中较小值的一半。
</span><span class="c1"></span>                    <span class="c1">//也就是说，是强制GC时间间隔和清扫堆时间间隔中较短时间间隔的一半。
</span><span class="c1"></span>					<span class="nx">sleep</span> <span class="o">:=</span> <span class="nx">forcegcperiod</span> <span class="o">/</span> <span class="mi">2</span>
					<span class="k">if</span> <span class="nx">next</span><span class="o">-</span><span class="nx">now</span> <span class="p">&lt;</span> <span class="nx">sleep</span> <span class="p">{</span>
						<span class="nx">sleep</span> <span class="p">=</span> <span class="nx">next</span> <span class="o">-</span> <span class="nx">now</span>
					<span class="p">}</span>
					<span class="nx">shouldRelax</span> <span class="o">:=</span> <span class="nx">sleep</span> <span class="o">&gt;=</span> <span class="nx">osRelaxMinNS</span>
					<span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
						<span class="nf">osRelax</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
                    <span class="p">}</span>
                    <span class="c1">//runtime.notesleep 会使用信号量同步系统监控即将进入休眠的状态。
</span><span class="c1"></span>					<span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">,</span> <span class="nx">sleep</span><span class="p">)</span>
					<span class="k">if</span> <span class="nx">shouldRelax</span> <span class="p">{</span>
						<span class="nf">osRelax</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
                    <span class="p">}</span>

					<span class="nx">now</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span>
					<span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
                    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                    <span class="c1">//睡完之后调度器的sysmonwait字段要清零
</span><span class="c1"></span>                    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="c1">//调用 runtime.noteclear 通知系统监控被唤醒并重置休眠的间隔。
</span><span class="c1"></span>					<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="c1">//把idle清零，并将delay设为初始值20。
</span><span class="c1"></span>				<span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
			<span class="p">}</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// If we spent a long time blocked on sysmonlock
</span><span class="c1"></span>			<span class="c1">// then we want to update now and next since it&#39;s
</span><span class="c1"></span>			<span class="c1">// likely stale.
</span><span class="c1"></span>			<span class="nx">now1</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">now1</span><span class="o">-</span><span class="nx">now</span> <span class="p">&gt;</span> <span class="mi">50</span><span class="o">*</span><span class="mi">1000</span> <span class="cm">/* 50µs */</span> <span class="p">{</span>
				<span class="nx">next</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">now</span> <span class="p">=</span> <span class="nx">now1</span>
		<span class="p">}</span>

		<span class="c1">// trigger libc interceptors if needed
</span><span class="c1"></span>		<span class="c1">// 需要时触发 libc interceptor
</span><span class="c1"></span>		<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
        <span class="c1">//接下来就是抢夺P和G的过程。
</span><span class="c1"></span>        <span class="c1">//首先如果网络I/O轮询器已经初始化，并且距上次通过网络轮询器获取G的时间已超过10ms，那么就记录此次获取的时间并通过网络I/O轮询器获取一个可运行G，否则跳过此步。
</span><span class="c1"></span>        <span class="c1">// poll network if not polled for more than 10ms
</span><span class="c1"></span>        <span class="c1">//从网络I/O轮询器获取一个可运行G
</span><span class="c1"></span>        <span class="c1">//上次从网络轮询器获取G的时间
</span><span class="c1"></span>        <span class="nx">lastpoll</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">))</span>
        <span class="c1">//获取超过10ms的netpoll结果
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
            <span class="c1">//更新调度器的lastpoll值
</span><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lastpoll</span><span class="p">),</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
            <span class="c1">// 非阻塞 - 返回一个goroutine列表
</span><span class="c1"></span>			<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// non-blocking - returns list of goroutines
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// Need to decrement number of idle locked M&#39;s
</span><span class="c1"></span>				<span class="c1">// (pretending that one more is running) before injectglist.
</span><span class="c1"></span>				<span class="c1">// Otherwise it can lead to the following situation:
</span><span class="c1"></span>				<span class="c1">// injectglist grabs all P&#39;s but before it starts M&#39;s to run the P&#39;s,
</span><span class="c1"></span>				<span class="c1">// another M returns from syscall, finishes running its G,
</span><span class="c1"></span>				<span class="c1">// observes that there is no work to do and no other running M&#39;s
</span><span class="c1"></span>                <span class="c1">// and reports deadlock.
</span><span class="c1"></span>                <span class="c1">//incidlelocked是”inc idle locked “这三个单词组合而成，意思是增加因锁定而空闲的M的数量。这个数量其实是调度器的nmidlelocked字段
</span><span class="c1"></span>                <span class="c1">//在通过网络轮询器获得G之后，将这些G放入调度器的全局G队列前后两次调用incidlelocked函数到底有什么用呢？
</span><span class="c1"></span>                <span class="c1">//想象一下，如果在injectglist函数在完成它的工作之前，某个M从系统调用返回并执行完了它的G，此时它掐指一算，系统中没有工作可做了，也没有运行的M了，于是死锁就发生了。然而这时的injectglist函数就是有冤无处述，有苦说不出了。就因为送货（G）慢了点，人家就关门了，也不等等它。所以现在你应该知道了incidlelockd(-1)的作用就是为了避免这种死锁的情况。将nmidlelocked减一后，run的值怎么都是大于等于1，不会小于0。从而避免从网络轮询器获得的G在运行之前发生死锁。也就是说假装还有一个M在运行，但是真实的情况肯定不是这样，所以等到injectglist函数完成它的工作后，就要再次调用incidlelocked(1)来恢复系统真实的样子。
</span><span class="c1"></span>                <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">//它会把G都加入到调度器的可运行G队列，并启动一个空闲的P来运行G。
</span><span class="c1"></span>				<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
				<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//如果在这之后，我们发现下一个计时器需要触发的时间小于当前时间，这也就说明所有的线程可能正在忙于运行 Goroutine，系统监控会启动新的线程来触发计时器，避免计时器的到期时间有较大的偏差。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">next</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
			<span class="c1">// There are timers that should have already run,
</span><span class="c1"></span>			<span class="c1">// perhaps because there is an unpreemptible P.
</span><span class="c1"></span>			<span class="c1">// Try to start an M to run them.
</span><span class="c1"></span>			<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">scavenge</span><span class="p">.</span><span class="nx">sysmonWake</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Kick the scavenger awake if someone requested it.
</span><span class="c1"></span>			<span class="nf">wakeScavenger</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// retake P&#39;s blocked in syscalls
</span><span class="c1"></span>        <span class="c1">// and preempt long running G&#39;s
</span><span class="c1"></span>        <span class="c1">//其次是从调度器那里抢夺符合条件的P和G，这一步由retake函数完成，抢夺成功则idle会清零，失败则idle自加一.
</span><span class="c1"></span>        <span class="c1">//抢夺syscall长时间阻塞的P
</span><span class="c1"></span>        <span class="c1">//向长时间运行的G发出抢占调度
</span><span class="c1"></span>        <span class="c1">//从调度器那里抢夺符合条件的P和G
</span><span class="c1"></span>		<span class="k">if</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">idle</span><span class="o">++</span>
		<span class="p">}</span>
        <span class="c1">// check if we need to force a GC
</span><span class="c1"></span>        <span class="c1">//在最后，系统监控还会决定是否需要触发强制垃圾回收，runtime.sysmon 会构建 runtime.gcTrigger 结构体并调用 runtime.gcTrigger.test 函数判断是否需要触发垃圾回收
</span><span class="c1"></span>        <span class="c1">//如果当前GC未执行，且距上一次执行已超过GC最大时间间隔，系统监测程序就会恢复专用于强制GC的G，并把它放入调度器的可运行G队列。GC最大时间间隔就是forcegcperiod的值，初始值为2分钟，
</span><span class="c1"></span>        <span class="c1">//用于强制GC的G是一个专用G，它在调度器初始化时就开始运行了，只不过一般处于暂停状态，只有系统监测程序可以恢复它。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerTime</span><span class="p">,</span> <span class="nx">now</span><span class="p">:</span> <span class="nx">now</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="kd">var</span> <span class="nx">list</span> <span class="nx">gList</span>
			<span class="nx">list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span><span class="p">)</span>
            <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
            <span class="c1">//forcegc就是强制GC的专用G。它在runtime2.go中定义，类型是forcegcstate。
</span><span class="c1"></span>            <span class="c1">//forcegcstate是一个结构体类型，其中封装了一个G。
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">//如果程序运行之前设置了GODEBUG环境变量，并且包含schedtrace=x，那么系统监测程序就会每过x毫秒打印一次调度器跟踪信息。这的x就是打印周期。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lasttrace</span><span class="o">+</span><span class="nb">int64</span><span class="p">(</span><span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span><span class="p">)</span><span class="o">*</span><span class="mi">1000000</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
			<span class="nx">lasttrace</span> <span class="p">=</span> <span class="nx">now</span>
			<span class="nf">schedtrace</span><span class="p">(</span><span class="nx">debug</span><span class="p">.</span><span class="nx">scheddetail</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonlock</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>当运行时刚刚调用上述函数时，会先通过 runtime.checkdead 检查是否存在死锁，然后进入核心的监控循环；系统监控在每次循环开始时都会通过 usleep 挂起当前线程，该函数的参数是微秒，运行时会遵循以下的规则决定休眠时间：</p>
<ul>
<li>初始的休眠时间是 20μs；</li>
<li>最长的休眠时间是 10ms；</li>
<li>当系统监控在 50 个循环中都没有唤醒 Goroutine 时，休眠时间在每个循环都会倍增；</li>
</ul>
<p>当程序趋于稳定之后，系统监控的触发时间就会稳定在 10ms。它除了会检查死锁之外，还会在循环中完成以下的工作：</p>
<ul>
<li>运行计时器 — 获取下一个需要被触发的计时器；</li>
<li>轮询网络 — 获取需要处理的到期文件描述符；</li>
<li>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</li>
<li>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</li>
</ul>
<p>我们在这一节中会依次介绍系统监控是如何处理五种不同工作的。</p>
<h2 id="checkdead">checkdead</h2>
<p>系统监控通过 runtime.checkdead 检查运行时是否发生了死锁，我们可以将检查死锁的过程分成以下三个步骤：</p>
<ol>
<li>检查是否存在正在运行的线程；</li>
<li>检查是否存在正在运行的 Goroutine；</li>
<li>检查处理器上是否存在计时器；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Check for deadlock situation.
</span><span class="c1">// The check is based on number of running M&#39;s, if 0 -&gt; deadlock.
</span><span class="c1">// sched.lock must be held.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkdead</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// For -buildmode=c-shared or -buildmode=c-archive it&#39;s OK if
</span><span class="c1"></span>	<span class="c1">// there are no running goroutines. The calling program is
</span><span class="c1"></span>	<span class="c1">// assumed to be running.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">islibrary</span> <span class="o">||</span> <span class="nx">isarchive</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// If we are dying because of a signal caught on an already idle thread,
</span><span class="c1"></span>	<span class="c1">// freezetheworld will cause all running threads to block.
</span><span class="c1"></span>	<span class="c1">// And runtime will essentially enter into deadlock state,
</span><span class="c1"></span>	<span class="c1">// except that there is a thread that will call exit soon.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">panicking</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// If we are not running under cgo, but we have an extra M then account
</span><span class="c1"></span>	<span class="c1">// for it. (It is possible to have an extra M on Windows without cgo to
</span><span class="c1"></span>	<span class="c1">// accommodate callbacks created by syscall.NewCallback. See issue #6751
</span><span class="c1"></span>	<span class="c1">// for details.)
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">run0</span> <span class="kt">int32</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">iscgo</span> <span class="o">&amp;&amp;</span> <span class="nx">cgoHasExtraM</span> <span class="p">{</span>
		<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">lockextra</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
		<span class="nx">haveExtraM</span> <span class="o">:=</span> <span class="nx">extraMCount</span> <span class="p">&gt;</span> <span class="mi">0</span>
		<span class="nf">unlockextra</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">haveExtraM</span> <span class="p">{</span>
			<span class="nx">run0</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">//首先会检查 Go 语言运行时中正在运行的线程数量，我们通过调度器中的多个字段计算该值的结果：
</span><span class="c1"></span>    <span class="c1">//1. runtime.mcount返回的是目前系统中存在的M的数量:根据下一个待创建的线程 id 和释放的线程数得到系统中存在的线程数；
</span><span class="c1"></span>    <span class="c1">//2. nmidle 是处于空闲状态的线程数量；
</span><span class="c1"></span>    <span class="c1">//3. nmidlelocked 是处于锁定状态的线程数量；
</span><span class="c1"></span>    <span class="c1">//4. nmsys 是处于系统调用的线程数量；
</span><span class="c1"></span>    <span class="c1">//run代表的就是还在运行的M的数量。如果线程数量大于 0，说明当前程序不存在死锁；如果线程数小于 0，说明当前程序的状态不一致；如果线程数等于 0，我们需要进一步检查程序的运行状态
</span><span class="c1"></span>    <span class="nx">run</span> <span class="o">:=</span> <span class="nf">mcount</span><span class="p">()</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span> <span class="o">-</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span>
	<span class="k">if</span> <span class="nx">run</span> <span class="p">&gt;</span> <span class="nx">run0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">run</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: checkdead: nmidle=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidle</span><span class="p">,</span> <span class="s">&#34; nmidlelocked=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span><span class="p">,</span> <span class="s">&#34; mcount=&#34;</span><span class="p">,</span> <span class="nf">mcount</span><span class="p">(),</span> <span class="s">&#34; nmsys=&#34;</span><span class="p">,</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: inconsistent counts&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="c1">//当存在 Goroutine 处于 _Grunnable、_Grunning 和 _Gsyscall 状态时，意味着程序发生了死锁；
</span><span class="c1"></span>    <span class="c1">//当所有的 Goroutine 都处于 _Gidle、_Gdead 和 _Gcopystack 状态时，意味着主程序调用了 runtime.goexit；
</span><span class="c1"></span>	<span class="nx">grunning</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allgs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">allgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">&amp;^</span> <span class="nx">_Gscan</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">_Gwaiting</span><span class="p">,</span>
			<span class="nx">_Gpreempted</span><span class="p">:</span>
			<span class="nx">grunning</span><span class="o">++</span>
		<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span>
			<span class="nx">_Grunning</span><span class="p">,</span>
			<span class="nx">_Gsyscall</span><span class="p">:</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: checkdead: find g &#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34; in status &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: runnable g&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">grunning</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// possible if main goroutine calls runtime·Goexit()
</span><span class="c1"></span>		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// unlock so that GODEBUG=scheddetail=1 doesn&#39;t hang
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;no goroutines (main called runtime.Goexit) - deadlock!&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Maybe jump time forward for playground.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">faketime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">when</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">timeSleepUntil</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">faketime</span> <span class="p">=</span> <span class="nx">when</span>
			<span class="k">for</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pidle</span><span class="p">;</span> <span class="o">*</span><span class="nx">pp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">pp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pp</span><span class="p">).</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">link</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pp</span><span class="p">).</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">_p_</span> <span class="p">{</span>
					<span class="o">*</span><span class="nx">pp</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">link</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">mget</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// There should always be a free M since
</span><span class="c1"></span>				<span class="c1">// nothing is running.
</span><span class="c1"></span>				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkdead: no m for timer&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">//当运行时存在等待的 Goroutine 并且不存在正在运行的 Goroutine 时，我们会检查处理器中存在的计时器：
</span><span class="c1"></span>    <span class="c1">//如果处理器中存在等待的计时器，那么所有的 Goroutine 陷入休眠状态是合理的，不过如果不存在等待的计时器，运行时就会直接报错并退出程序。
</span><span class="c1"></span>	<span class="c1">// There are no goroutines running, so we can look at the P&#39;s.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">timers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>    <span class="c1">// unlock so that GODEBUG=scheddetail=1 doesn&#39;t hang
</span><span class="c1"></span>	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;all goroutines are asleep - deadlock!&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="incidlelocked">incidlelocked</h2>
<p>incidlelocked函数十分简单，它就做了两件事：</p>
<ol>
<li>将参数加到调度器的nmidlelocked字段上</li>
<li>如果参数大于0，就调用checkdead函数检查是否发生死锁。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">incidlelocked</span><span class="p">(</span><span class="nx">v</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span><span class="c1">//加锁
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmidlelocked</span> <span class="o">+=</span> <span class="nx">v</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">checkdead</span><span class="p">()</span><span class="c1">//检查死锁
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span><span class="c1">//解锁
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那么为什么只在参数大于0的情况下才去检查死锁呢？因为参数大于0时，nmidlelocked值会增大，这时就有可能使run的值变成负数。也就是说这个M的锁定可能使系统中没有运行的M而发生死锁，当然有必要查看一下是否发生了死锁。如果incidlelocked函数的参数小于0，那么nmidlelocked的值会变小，而run的值只会更大，如果run本来就大于0，那么更不可能因此而发生死锁了，当然也就没必要检查了。</p>
<h2 id="injectglist">injectglist</h2>
<p>injectglist函数会非阻塞地调用 runtime.netpoll 检查待执行的文件描述符并通过 runtime.injectglist 将所有处于就绪状态的 Goroutine 加入全局运行队列中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">injectglist</span><span class="p">(</span><span class="nx">glist</span> <span class="o">*</span><span class="nx">gList</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">();</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
		<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="nx">glist</span> <span class="p">=</span> <span class="nx">gList</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数会将所有 Goroutine 的状态从 _Gwaiting 切换至_Grunnable 并加入全局运行队列等待运行，如果当前程序中存在空闲的处理器，就会通过 runtime.startm 函数启动线程来执行这些任务。</p>
<h2 id="retake">retake</h2>
<p>系统监控通过在循环中抢占处理器来避免同一个 Goroutine 占用线程太长时间造成饥饿问题。</p>
<p>系统监控在循环中调用 runtime.retake 函数抢占处于运行或者系统调用中的处理器，该函数会遍历运行时的全局处理器，</p>
<p>runtime.retake 中的循环包含了两种不同的抢占逻辑：</p>
<ol>
<li>当处理器处于 _Prunning 状态时，如果上一次触发调度的时间已经过去了 10ms，我们就会通过 runtime.preemptone 抢占当前处理器；</li>
<li>当处理器处于 _Psyscall 状态时，在满足以下两种情况下会调用 runtime.handoffp 让出处理器的使用权：
<ol>
<li>当处理器的运行队列不为空或者不存在空闲处理器时；</li>
<li>当系统调用时间超过了 10ms 时；</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="c1">//在retake函数开始处，首先初始化了一个变量n := 0，它用来记录成功抢夺到P的次数
</span><span class="c1"></span>    <span class="c1">//而最后retake函数的返回值也是这个n，所以在sysmon函数中我们能够用retake函数的返回值是否大于0来判断抢夺P是否成功。
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// Prevent allp slice changes. This lock will be completely
</span><span class="c1"></span>	<span class="c1">// uncontended unless we&#39;re already stopping the world.
</span><span class="c1"></span>	<span class="c1">// 防止 allp 数组发生变化，除非我们已经 STW，此锁将完全没有人竞争
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="c1">// We can&#39;t use a range loop over allp because we may
</span><span class="c1"></span>	<span class="c1">// temporarily drop the allpLock. Hence, we need to re-fetch
</span><span class="c1"></span>	<span class="c1">// allp each time around the loop.
</span><span class="c1"></span>	<span class="c1">//接下来是对全局P列表中所有P进行迭代，并在可以抢夺的时候将P抢过来。不过在这之前，首先要初始化一些变量。
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="c1">//为什么从全局P列表取出的P还要进行为空判断呢？这是为了防止此时调用了procresize函数增加了P的最大数量，虽然数量已经涨上去了，但实际上P还没有被创建出来，导致获取的P为空。
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// This can happen if procresize has grown
</span><span class="c1"></span>			<span class="c1">// allp but not yet created new Ps.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间
</span><span class="c1"></span>		<span class="nx">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">sysmontick</span>
		<span class="c1">// p 的状态
</span><span class="c1"></span>		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span>
		<span class="nx">sysretake</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="o">||</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
			<span class="c1">// 如果 G 运行时时间太长则进行抢占
</span><span class="c1"></span>			<span class="c1">// Preempt G if it&#39;s running for too long.
</span><span class="c1"></span>			<span class="c1">// 每发生一次调度，调度器 ++ 该值
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span>
			<span class="c1">//pd.schedtick == t 说明(pd.schedwhen ～ now)这段时间未发生过调度
</span><span class="c1"></span>			<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span> <span class="p">=</span> <span class="nx">now</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span><span class="o">+</span><span class="nx">forcePreemptNS</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="c1">//如果没超过10ms,则忽略
</span><span class="c1"></span>				<span class="c1">//forcepreemptNS，它是有” force preempt NS “组成，意思是强制抢占P的纳秒数，NS是单位，纳秒。它在retake函数外面定义，是一个常量。这一步是说距上次系统调用的时间间隔不足强制抢占P的时间间隔，就放弃抢占P。换句话说，当这个条件不满足时，说明这个P（准确的说是这个P当前运行的G）已经运行太长时间了，应该把它停止，并把运行机会让给其他G，以保证公平。
</span><span class="c1"></span>				<span class="c1">// 这段时间是同一个goroutine一直在运行，检查是否连续运行超过了 10 毫秒
</span><span class="c1"></span>				<span class="c1">// 连续运行超过 10 毫秒了，发起抢占请求
</span><span class="c1"></span>				<span class="c1">// 对于 syscall 的情况，因为 M 没有与 P 绑定，
</span><span class="c1"></span>				<span class="c1">// preemptone() 不工作
</span><span class="c1"></span>				<span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="c1">// In case of syscall, preemptone() doesn&#39;t
</span><span class="c1"></span>				<span class="c1">// work, because there is no M wired to P.
</span><span class="c1"></span>				<span class="nx">sysretake</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 对阻塞在系统调用上的 P 进行抢占
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
			<span class="c1">// Retake P from syscall if it&#39;s there for more than 1 sysmon tick (at least 20us).
</span><span class="c1"></span>			<span class="c1">//第一小步：判断当前P的系统调用计数和备份的系统调用计数是否相等。如果相等就继续后面的小步骤，如果不相等，要更新备份，并更新最近一次系统调用的时刻。
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span>
			<span class="c1">// _p_.syscalltick 用于记录系统调用的次数，在完成系统调用之后加 1
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">sysretake</span> <span class="o">&amp;&amp;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
				<span class="c1">// pd.syscalltick != _p_.syscalltick，说明已经不是上次观察到的系统调用了，
</span><span class="c1"></span>                	<span class="c1">// 而是另外一次系统调用，所以需要重新记录 tick 和 when 值
</span><span class="c1"></span>				<span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span> <span class="p">=</span> <span class="nx">now</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">//这一步的目的很明显，就是要在某些条件下放弃对P的抢夺。要想放弃对P的抢夺，条件还是很严苛的，要同时满足三个条件：
</span><span class="c1"></span>            		<span class="c1">//一是P的可运行G队列为空不抢，因为没活干的P抢过来也没用.
</span><span class="c1"></span>            		<span class="c1">//二是有自旋的M或者有休息的P不抢，因为有自旋的M说明有M正在全力查找可运行的G，该P的可运行G队列一定会被全力查找可运行G的流程找到，就不用系统监测程序插手了
</span><span class="c1"></span>            		<span class="c1">//三是距离上一次系统调用的时间不足10ms不抢
</span><span class="c1"></span>            		<span class="c1">//这个条件中用到的上次系统调用时间正是备份中的syscallwhen字段，因为如果P的系统调用计数和备份中的不同步，说明在此次系统调用之前，已经有人捷足先登进行过系统调用了，那么最新的系统调用的时间也就必定不是备份中syscallwhen字段记录的时刻，这就会导致这里我们用备份中的syscallwhen字段来判断距离上次系统调用的时间间隔是否大于10ms是不准确的。
</span><span class="c1"></span>            		<span class="c1">//所以在第一小步中一旦发现P的系统调用计数和备份中的不同步，就应该更新备份，并且忽略后面的步骤。
</span><span class="c1"></span>			<span class="c1">// On the one hand we don&#39;t want to retake Ps if there is no other work to do,
</span><span class="c1"></span>			<span class="c1">// but on the other hand we want to retake them eventually
</span><span class="c1"></span>			<span class="c1">// because they can prevent the sysmon thread from deep sleep.
</span><span class="c1"></span>			<span class="c1">//检查是否有其他任务需要P,是否超出时间限制,是否有必要抢夺P
</span><span class="c1"></span>			<span class="c1">// 一方面，在没有其他 work 的情况下，我们不希望抢夺 P
</span><span class="c1"></span>			<span class="c1">// 另一方面，因为它可能阻止 sysmon 线程从深度睡眠中唤醒，所以最终我们仍希望抢夺 P
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// Drop allpLock so we can take sched.lock.
</span><span class="c1"></span>			<span class="c1">// 解除 allpLock，从而可以获取 sched.lock
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
			<span class="c1">//抢夺P的过程就是将P转手。
</span><span class="c1"></span>			<span class="c1">//抢夺过程包裹在incidlelocked函数调用之间。然后要将P的状态转换为空闲状态（Pidle），并自增记录成功抢夺P次数的变量n以及P系统调用计数，最后通过handoffp函数转手这个P。
</span><span class="c1"></span>			<span class="c1">// 在 CAS 之前需要减少空闲 M 的数量（假装某个还在运行）
</span><span class="c1"></span>			<span class="c1">// 否则发生抢夺的 M 可能退出 syscall 然后再增加 nmidle ，进而发生死锁
</span><span class="c1"></span>			<span class="c1">// 这个过程发生在 stoplockedm 中
</span><span class="c1"></span>			<span class="c1">// Need to decrement number of idle locked M&#39;s
</span><span class="c1"></span>			<span class="c1">// (pretending that one more is running) before the CAS.
</span><span class="c1"></span>			<span class="c1">// Otherwise the M from which we retake can exit the syscall,
</span><span class="c1"></span>			<span class="c1">// increment nmidle and report deadlock.
</span><span class="c1"></span>			<span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">//抢夺P
</span><span class="c1"></span>			<span class="c1">// 将 P 设为 idle，从而交于其他 M 使用
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
					<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
					<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">n</span><span class="o">++</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
				<span class="c1">// 寻找一新的 m 接管 p
</span><span class="c1"></span>				<span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从代码来看，主要会对处于 _Psyscall 和_Prunning 状态的 p 进行抢占。</p>
<h3 id="抢占进行系统调用的-p">抢占进行系统调用的 P</h3>
<p>我们先来看抢占阻塞在系统调用上的 G 这种情况。这种抢占的实现方法非常的自然，因为 Goroutine 已经阻塞在了系统调用上，我们可以非常安全的将 M 与 P 进行解绑，即便是 Goroutine 从阻塞中恢复，也会检查自身所在的 M 是否仍然持有 P，如果没有 P 则重新考虑 与可用的 P 进行绑定。这种异步抢占的本质是：抢占 P。</p>
<p>当 P 处于 _Psyscall 状态时，表明对应的 goroutine 正在进行系统调用。如果抢占 p，需要满足几个条件：</p>
<ol>
<li>p 的本地运行队列里面有等待运行的 goroutine。这时 p 绑定的 g 正在进行系统调用，无法去执行其他的 g，因此需要接管 p 来执行其他的 g。</li>
<li>没有“无所事事”的 p。sched.nmspinning 和 sched.npidle 都为 0，这就意味着没有“找工作”的 m，也没有空闲的 p，大家都在“忙”，可能有很多工作要做。因此要抢占当前的 p，让它来承担一部分工作。</li>
<li>从上一次监控线程观察到 p 对应的 m 处于系统调用之中到现在已经超过 10 毫秒。这说明系统调用所花费的时间较长，需要对其进行抢占，以此来使得 retake 函数返回值不为 0，这样，会保持 sysmon 线程 20 us 的检查周期，提高 sysmon 监控的实时性。</li>
</ol>
<p>注意，原代码是用的三个与条件，三者都要满足才会执行下面的 continue，也就是不进行抢占。因此要想进行抢占的话，只需要三个条件有一个不满足就行了。于是就有了上述三种情况。</p>
<p>确定要抢占当前 p 后，先使用原子操作将 p 的状态修改为 _Pidle，最后调用 handoffp 进行抢占。</p>
<p>handoffp 再次进行场景判断，以调用 startm 启动一个工作线程来绑定 p，使得整体工作继续推进。</p>
<p>在抢占 P 的过程中，有两个非常小心的处理方式：</p>
<ol>
<li>如果此时队列为空，那么完全没有必要进行抢占，这时候似乎可以继续遍历其他的 P， 但必须在调度器中自旋的 M 和 空闲的 P 同时存在时、且系统调用阻塞时间非常长的情况下 才能这么做。否则，这个 retake 过程可能返回 0，进而系统监控可能看起来像是什么事情 也没做的情况下调整自己的步调进入深度睡眠。</li>
<li>在将 P 设置为空闲状态前，必须先将 M 的数量减少，否则当 M 退出系统调用时， 会在 exitsyscall0 中调用 stoplockedm 从而增加空闲 M 的数量，进而发生死锁。</li>
</ol>
<h3 id="抢占长时间运行的-p">抢占长时间运行的 P</h3>
<p>在检查 P 的状态时，P 如果是运行状态会调用 preemptone，来通过系统信号来完成抢占.之所以没有在之前提及的原因在于该调用 在 M 不与 P 绑定的情况下是不起任何作用直接返回的。这种异步抢占的本质是：抢占 M。</p>
<p>接下来我们就来分析当 P 处于 _Prunning 状态的情况。sysmon 扫描每个 p 时，都会记录下当前调度器调度的次数和当前时间，数据记录在结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">sysmontick</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">schedtick</span>   <span class="kt">uint32</span><span class="c1">//调度计数
</span><span class="c1"></span>	<span class="nx">schedwhen</span>   <span class="kt">int64</span><span class="c1">//调度时刻
</span><span class="c1"></span>	<span class="nx">syscalltick</span> <span class="kt">uint32</span><span class="c1">//系统调用计数
</span><span class="c1"></span>	<span class="nx">syscallwhen</span> <span class="kt">int64</span><span class="c1">//系统调用时刻
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>前面两个字段记录调度器调度的次数和时间，后面两个字段记录系统调用的次数和时间。</p>
<p>其实sysmontick结构中的syscalltick字段和syscallwhen字段在P结构体中也有，那么为什么这里还要重复存一份呢？目的就是为了备份，当发现sysmontick中的syscalltick值与P中的不一样是，就说明新的系统调用发生了，此时就可以更新syscallwhen字段为当前时间，记录下此次系统调用的时刻了。</p>
<p>在下一次扫描时，对比 sysmon 记录下的 p 的调度次数和时间，与当前 p 自己记录下的调度次数和时间对比，如果一致。说明 P 在这一段时间内一直在运行同一个 goroutine。那就来计算一下运行时间是否太长了。</p>
<p>如果发现运行时间超过了 10 ms，则要调用 preemptone(<em>p</em>) 发起抢占的请求</p>
<h2 id="参考">参考</h2>
<p><a href="https://blog.csdn.net/puss0/article/details/80627753#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">地鼠宝宝的秩事异闻之调度器</a>
<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">6.7 系统监控</a>
<a href="https://qcrao91.gitbook.io/go/goroutine-tiao-du-qi/sysmon-hou-tai-jian-kong-xian-cheng-zuo-le-shi-mo">sysmon 后台监控线程做了什么</a>
<a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/#heading">6.8 协作与抢占</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-11-12
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84netpoller%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的netpoller源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/">
            <span class="next-text nav-default">Opentracing包解析</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
