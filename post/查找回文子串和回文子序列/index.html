<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>查找回文子串和回文子序列 | Forz Blog</title>
<meta name="keywords" content="区间DP, Backtracking" />
<meta name="description" content="LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: &ldquo;abccccdd&rdquo; Output: 7 Explanation: One longest palindrome that can be built is “">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="查找回文子串和回文子序列" />
<meta property="og:description" content="LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: &ldquo;abccccdd&rdquo; Output: 7 Explanation: One longest palindrome that can be built is “" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T02:28:08&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T02:28:08&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="查找回文子串和回文子序列"/>
<meta name="twitter:description" content="LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: &ldquo;abccccdd&rdquo; Output: 7 Explanation: One longest palindrome that can be built is “"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "查找回文子串和回文子序列",
      "item": "/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "查找回文子串和回文子序列",
  "name": "查找回文子串和回文子序列",
  "description": "LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: \u0026ldquo;abccccdd\u0026rdquo; Output: 7 Explanation: One longest palindrome that can be built is “",
  "keywords": [
    "区间DP", "Backtracking"
  ],
  "articleBody": "LeetCode 409. Longest Palindrome Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\nThis is case sensitive, for example “Aa” is not considered a palindrome here.\nNote:\nAssume the length of given string will not exceed 1,010.\nExample:\nInput:\n“abccccdd”\nOutput:\n7\nExplanation:\nOne longest palindrome that can be built is “dccaccd”, whose length is 7.\n解析：\n用字符串中的字符组成一个回文串，求符合要求的回文串的最大长度。因为可以重新排序，只需考虑相应字符的出现次数的奇偶问题。\n回文字符串若有奇数个元素，则该元素只能出现一次且在中间，全是偶数个元素，肯定能组成回文字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: int longestPalindrome(string s) { int sum=s.size(); vectorint hash(52);//用来存储频率  for(char c:s) { if(c'z'\u0026\u0026c='a') hash[c-'a']++; else hash[(c-'A')+26]++; } int count=0; for(auto it:hash) { if(it%2) count++;//数量为奇数的元素的种数  } return count0?sum-count+1:sum; } };   LeetCode 5. Longest Palindromic Substring 给定一个字符串s，在s中找到最长的回文子串。您可以假定s的最大长度为1000。\n解析：此题用动态规划算法容易理解，但是卡时间过的，并不是最优解法。\ndp[i][j]代表从s[i]到s[j]是否为回文串，然后利用max_len来维护结果，也可以直接在dp数组中保存结果，没有区别。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: string longestPalindrome(string s) { const int n = s.size(); dequedequebool  f(n, dequebool(n, false)); int max_len = 1, start = 0; // 最长回文子串的长度，起点  for (int j = 0; j  s.size(); j++) { f[j][j] = true;//单字符都是回文串  for (int i = 0; i  j; i++) { // [k, i]  f[i][j] = (s[i] == s[j] \u0026\u0026 (j - i  2 || f[i + 1][j - 1]));//判断是否能构成回文串  if (f[i][j] \u0026\u0026 max_len  (j - i + 1)) {//维护最大值  max_len = j - i + 1; start = i; } } } return s.substr(start, max_len); } };   补充\n此题最高效解法：manacher算法\n516. Longest Palindromic Subsequence 给定一个字符串s，在s中找到最长的回文子序列的长度。您可以假定s的最大长度为1000。\n解析：\n每个回文子序列的子序列都是回文的，存在最优子结构和重叠子问题，所以可以DP来解。\n确定一个子序列需要找到左右边界，所以dp需要二维数组\ndp[i][j]代表从s[i]到s[j]的最大回文子序列长度\n枚举右边界j，逆序扫描其左边界i，如果碰到i和j元素相同，那么做判断\n如果i和j之间只有2个数，那么这是一个新结果，dp值为2\n如果i和j之间大于2个数，那么可以依靠之前的结果，2 + dp[i + 1][j - 1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: int longestPalindromeSubseq(string s) { int n = s.size(); int dp[n][n]; for(int i = 0; i  n; i++) dp[i][i] = 1;//单个字符是回文，初始化dp边界值 for(int j = 1; j  n; j++){//j从1开始，防越界  for(int i = j - 1; i = 0; i--){ if(s[i] == s[j]){//出现新的相等值，加入已有结果或者变为新结果  dp[i][j] = i + 1  j - 1 ? 2 + dp[i + 1][j - 1] : 2;//可以不连续 所以是2  }else{//依靠之前的两种情况更新dp值  dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][n - 1]; } };   131. Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn all possible palindrome partitioning of s.\nFor example, given s = “aab”,\nReturn\n[ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ]  解析：\n回溯法求所有可行解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution{ public: vectorvectorstring partition(string s) { vectorstring path;//保存路径  vectorvectorstring result;//保存结果  DFS(s, path, result, 0); return result; } void DFS(string \u0026 s, vectorstring\u0026 path, vectorvectorstring\u0026 result, int begin) { //搜索以s[begin]开头的partition方案  if (begin == s.size())//递归终止条件  { result.push_back(path); return; } for (int i = begin; i  s.size(); ++i)//枚举终点  if (ispalindrome(s, begin, i)) { //从i位置砍一刀  path.push_back(s.substr(begin, i - begin + 1));//记录当前划分  DFS(s, path, result, i + 1); //枚举下一个起点  path.pop_back(); //回溯当前划分  } } bool ispalindrome(const string \u0026s, int start, int end)//判断子串是否为回文  { while (start  end \u0026\u0026 s[start] == s[end]) { ++start; --end; } return start = end;//如果发生交错，说明遍历结束  } };   132. Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn the minimum cuts needed for a palindrome partitioning of s.\nFor example, given s = “aab”,\nReturn 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.\n解析：\n求将一个字符串划分为多个子回文字符串的最少的隔板数，因为单字符是回文数，所以必定有解，采用区间DP。\n定义状态{f(i,j)}表示区间{[i,j]}之间最小的cut数，则状态转移方程为\nf(i,j)=min{f(i,k)+f(k+1,j)，f(i,j)},i≤k≤j,0≤i≤j 结果值为f(0,n-1),这种DP也有降维优化方式\n如果每次，从i往右扫描，每找到一个回文子字符串就算一次DP的话，就可以转换为{f(i)=区间[i, n-1]之间最小的cut数}，n为字符串长度，则状态转移方程为\nf(i)=min{f(j+1)+1，f(i)},i≤j 此时j起到k的划分作用.\nDP过程先要判断[i,j]是否为回文串，然后维护f[i]的DP值。\n虚设一个size()节点，令其值为-1，这样就不会在dp过程中越界。\n考虑i到s.size()是一个回文串的情况\nif(j == s.size()){dp[i] = 0;}  但是因为虚设了节点dp[s.size]=-1，省去判断步骤,而直接可以用统一的推导公式\nf(i)=min{f(j+1)+1，f(i)},i≤j DP方式也可以让{f(i)=区间[0, i-1]之间最小的cut数}，扫描i和j的方式发生改变，让dp[0]=-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: int minCut(string s) { vectorvectorbool palindrome(s.size(), vectorbool(s.size(), false)); vectorint dp(s.size()+1); for (int i = 0; i  s.size()+1; ++ i) dp[i] = s.size() - i - 1; //dp边界值(最大划分数)  for (int i = s.size()-1; i = 0; -- i) for (int j = i; j  s.size(); ++ j) if (s[i]==s[j] \u0026\u0026 (j-i2 || palindrome[i+1][j-1])) { palindrome[i][j] = true; dp[i] = min(dp[i], dp[j+1] + 1); } return dp[0]; } };   补充：正序扫描i方式\ndp[0]=-1; for(int i=1; i=0; j–) if(isPal[j][i-1]) dp[i] = min(dp[i], dp[j]+1);  ",
  "wordCount" : "2083",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T02:28:08Z",
  "dateModified": "2017-06-25T02:28:08Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%9F%A5%E6%89%BE%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E5%92%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      查找回文子串和回文子序列
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-409-longest-palindrome">LeetCode 409. Longest Palindrome<a hidden class="anchor" aria-hidden="true" href="#leetcode-409-longest-palindrome">#</a></h1>
<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:</p>
<p>Assume the length of given string will not exceed 1,010.</p>
<p>Example:</p>
<p>Input:</p>
<p>&ldquo;abccccdd&rdquo;</p>
<p>Output:</p>
<p>7</p>
<p>Explanation:</p>
<p>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>
<p>解析：</p>
<p>用字符串中的字符组成一个回文串，求符合要求的回文串的最大长度。因为可以重新排序，只需考虑相应字符的出现次数的奇偶问题。</p>
<p>回文字符串若有奇数个元素，则该元素只能出现一次且在中间，全是偶数个元素，肯定能组成回文字符串</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">(</span><span class="mi">52</span><span class="p">);</span><span class="c1">//用来存储频率
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="nl">c</span><span class="p">:</span><span class="n">s</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">&lt;=</span><span class="sc">&#39;z&#39;</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&gt;=</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
         <span class="n">hash</span><span class="p">[</span><span class="n">c</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
         <span class="k">else</span> <span class="n">hash</span><span class="p">[(</span><span class="n">c</span><span class="o">-</span><span class="sc">&#39;A&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">26</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>
    <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">it</span><span class="p">:</span><span class="n">hash</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="c1">//数量为奇数的元素的种数
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">sum</span><span class="o">-</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-5-longest-palindromic-substring">LeetCode 5. Longest Palindromic Substring<a hidden class="anchor" aria-hidden="true" href="#leetcode-5-longest-palindromic-substring">#</a></h1>
<p>给定一个字符串s，在s中找到最长的回文子串。您可以假定s的最大长度为1000。</p>
<p>解析：此题用动态规划算法容易理解，但是卡时间过的，并不是最优解法。</p>
<p>dp[i][j]代表从s[i]到s[j]是否为回文串，然后利用max_len来维护结果，也可以直接在dp数组中保存结果，没有区别。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">deque</span><span class="o">&lt;</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 最长回文子串的长度，起点
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//单字符都是回文串
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// [k, i]
</span><span class="c1"></span>            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span><span class="c1">//判断是否能构成回文串
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">max_len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span><span class="c1">//维护最大值
</span><span class="c1"></span>                <span class="n">max_len</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">max_len</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>补充</p>
<p>此题最高效解法：manacher算法</p>
<h1 id="516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence<a hidden class="anchor" aria-hidden="true" href="#516-longest-palindromic-subsequence">#</a></h1>
<p>给定一个字符串s，在s中找到最长的回文子序列的长度。您可以假定s的最大长度为1000。</p>
<p>解析：</p>
<p>每个回文子序列的子序列都是回文的，存在最优子结构和重叠子问题，所以可以DP来解。</p>
<p>确定一个子序列需要找到左右边界，所以dp需要二维数组</p>
<p>dp[i][j]代表从s[i]到s[j]的最大回文子序列长度</p>
<p>枚举右边界j，逆序扫描其左边界i，如果碰到i和j元素相同，那么做判断</p>
<p>如果i和j之间只有2个数，那么这是一个新结果，dp值为2</p>
<p>如果i和j之间大于2个数，那么可以依靠之前的结果，2 + dp[i + 1][j - 1]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">longestPalindromeSubseq</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>

<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//单个字符是回文，初始化dp边界值
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="c1">//j从1开始，防越界
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="c1">//出现新的相等值，加入已有结果或者变为新结果
</span><span class="c1"></span>            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//可以不连续 所以是2
</span><span class="c1"></span>        <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//依靠之前的两种情况更新dp值
</span><span class="c1"></span>            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="131-palindrome-partitioning">131. Palindrome Partitioning<a hidden class="anchor" aria-hidden="true" href="#131-palindrome-partitioning">#</a></h1>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,</p>
<p>Return</p>
<pre><code>[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</code></pre>
<p>解析：</p>
<p>回溯法求所有可行解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span><span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">partition</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span><span class="c1">//保存路径
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span><span class="c1">//保存结果
</span><span class="c1"></span>    <span class="n">DFS</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">begin</span><span class="p">)</span>
<span class="p">{</span>    <span class="c1">//搜索以s[begin]开头的partition方案
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="c1">//递归终止条件
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//枚举终点
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">ispalindrome</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="p">{</span> <span class="c1">//从i位置砍一刀
</span><span class="c1"></span>            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">begin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span><span class="c1">//记录当前划分
</span><span class="c1"></span>            <span class="n">DFS</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//枚举下一个起点
</span><span class="c1"></span>            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">//回溯当前划分
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
    <span class="kt">bool</span> <span class="n">ispalindrome</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span><span class="c1">//判断子串是否为回文
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">start</span><span class="p">;</span>
            <span class="o">--</span><span class="n">end</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">;</span><span class="c1">//如果发生交错，说明遍历结束
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="132-palindrome-partitioning-ii">132. Palindrome Partitioning II<a hidden class="anchor" aria-hidden="true" href="#132-palindrome-partitioning-ii">#</a></h1>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,</p>
<p>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
<p>解析：</p>
<p>求将一个字符串划分为多个子回文字符串的最少的隔板数，因为单字符是回文数，所以必定有解，采用区间DP。</p>
<p>定义状态{f(i,j)}表示区间{[i,j]}之间最小的cut数，则状态转移方程为</p>
<pre><code>f(i,j)=min{f(i,k)+f(k+1,j)，f(i,j)},i≤k≤j,0≤i≤j&lt;n
</code></pre>
<p>结果值为f(0,n-1),<strong>这种DP也有降维优化方式</strong></p>
<p>如果每次，从i往右扫描，每找到一个回文子字符串就算一次DP的话，就可以转换为{f(i)=区间[i, n-1]之间最小的cut数}，n为字符串长度，则状态转移方程为</p>
<pre><code>f(i)=min{f(j+1)+1，f(i)},i≤j&lt;n
</code></pre>
<p><strong>此时j起到k的划分作用.</strong></p>
<p>DP过程先要判断[i,j]是否为回文串，然后维护f[i]的DP值。</p>
<p>虚设一个size()节点，令其值为-1，这样就不会在dp过程中越界。</p>
<p>考虑i到s.size()是一个回文串的情况</p>
<pre><code>if(j == s.size()){dp[i] = 0;}
</code></pre>
<p>但是因为虚设了节点dp[s.size]=-1，省去判断步骤,而直接可以用统一的推导公式</p>
<pre><code>f(i)=min{f(j+1)+1，f(i)},i≤j&lt;n
</code></pre>
<p>DP方式也可以让{f(i)=区间[0, i-1]之间最小的cut数}，扫描i和j的方式发生改变，让dp[0]=-1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span>   
<span class="p">{</span> 
<span class="nl">public</span><span class="p">:</span>  
    <span class="kt">int</span> <span class="n">minCut</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">));</span>  
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span>  
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//dp边界值(最大划分数)
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span> <span class="n">i</span><span class="p">)</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span> <span class="n">j</span><span class="p">)</span>  
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span> <span class="o">||</span> <span class="n">palindrome</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> 
                <span class="p">{</span>
                    <span class="n">palindrome</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  
                <span class="p">}</span>  
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
    <span class="p">}</span>  
<span class="p">};</span>  
</code></pre></td></tr></table>
</div>
</div><p>补充：正序扫描i方式</p>
<pre><code>dp[0]=-1;
for(int i=1; i&lt;=n; i++)
for(int j=i-1; j&gt;=0; j–)
if(isPal[j][i-1])
dp[i] = min(dp[i], dp[j]+1);
</code></pre>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E5%8C%BA%E9%97%B4dp/">区间DP</a></li>
      <li><a href="/tags/backtracking/">Backtracking</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
