<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Opentracing包解析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&amp;#34;opentracing: Unknown or unsupported Inject/Extract format&amp;#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.88.1 with theme even" />


<link rel="canonical" href="/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Opentracing包解析" />
<meta property="og:description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-09T16:40:11+00:00" />
<meta property="article:modified_time" content="2020-10-09T16:40:11+00:00" />

<meta itemprop="name" content="Opentracing包解析">
<meta itemprop="description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but"><meta itemprop="datePublished" content="2020-10-09T16:40:11+00:00" />
<meta itemprop="dateModified" content="2020-10-09T16:40:11+00:00" />
<meta itemprop="wordCount" content="6532">
<meta itemprop="keywords" content="opentracing," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Opentracing包解析"/>
<meta name="twitter:description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Opentracing包解析</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-10-09 </span>
        <div class="post-category">
            <a href="/categories/opentracing/"> opentracing </a>
            </div>
          <span class="more-meta"> 约 6532 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#variables">Variables</a></li>
    <li><a href="#func-contextwithspan">func ContextWithSpan</a></li>
    <li><a href="#func-initglobaltracer">func InitGlobalTracer</a></li>
    <li><a href="#func-isglobaltracerregistered">func IsGlobalTracerRegistered</a></li>
    <li><a href="#func-setglobaltracer">func SetGlobalTracer</a></li>
    <li><a href="#type-builtinformat">type BuiltinFormat</a></li>
    <li><a href="#type-finishoptions">type FinishOptions</a></li>
    <li><a href="#type-httpheaderscarrier">type HTTPHeadersCarrier</a></li>
    <li><a href="#func-httpheaderscarrier-foreachkey">func (HTTPHeadersCarrier) ForeachKey</a></li>
    <li><a href="#func-httpheaderscarrier-set">func (HTTPHeadersCarrier) Set</a></li>
    <li><a href="#type-logdata">type LogData</a></li>
    <li><a href="#func-logdata-tologrecord">func (*LogData) ToLogRecord</a></li>
    <li><a href="#type-logrecord">type LogRecord</a></li>
    <li><a href="#type-nooptracer">type NoopTracer</a></li>
    <li><a href="#func-nooptracer-extract">func (NoopTracer) Extract</a></li>
    <li><a href="#func-nooptracer-inject">func (NoopTracer) Inject</a></li>
    <li><a href="#func-nooptracer-startspan">func (NoopTracer) StartSpan</a></li>
    <li><a href="#type-span">type Span</a></li>
    <li><a href="#func-spanfromcontext">func SpanFromContext</a></li>
    <li><a href="#func-startspan">func StartSpan</a></li>
    <li><a href="#func-startspanfromcontext">func StartSpanFromContext</a></li>
    <li><a href="#func-startspanfromcontextwithtracer">func StartSpanFromContextWithTracer</a></li>
    <li><a href="#type-spancontext">type SpanContext</a></li>
    <li><a href="#type-spanreference">type SpanReference</a></li>
    <li><a href="#func-childof">func ChildOf</a></li>
    <li><a href="#func-followsfrom">func FollowsFrom</a></li>
    <li><a href="#func-spanreference-apply">func (SpanReference) Apply</a></li>
    <li><a href="#type-spanreferencetype">type SpanReferenceType</a></li>
    <li><a href="#type-startspanoption">type StartSpanOption</a></li>
    <li><a href="#type-startspanoptions">type StartSpanOptions</a></li>
    <li><a href="#type-starttime">type StartTime</a></li>
    <li><a href="#func-starttime-apply">func (StartTime) Apply</a></li>
    <li><a href="#type-tag">type Tag</a></li>
    <li><a href="#func-tag-apply">func (Tag) Apply</a></li>
    <li><a href="#func-tag-set">func (Tag) Set</a></li>
    <li><a href="#type-tags">type Tags</a></li>
    <li><a href="#func-tags-apply">func (Tags) Apply</a></li>
    <li><a href="#type-textmapcarrier">type TextMapCarrier</a></li>
    <li><a href="#func-textmapcarrier-foreachkey">func (TextMapCarrier) ForeachKey</a></li>
    <li><a href="#func-textmapcarrier-set">func (TextMapCarrier) Set</a></li>
    <li><a href="#type-textmapreader">type TextMapReader</a></li>
    <li><a href="#type-textmapwriter">type TextMapWriter</a></li>
    <li><a href="#type-tracer">type Tracer</a></li>
    <li><a href="#func-globaltracer">func GlobalTracer</a></li>
    <li><a href="#type-tracercontextwithspanextension">type TracerContextWithSpanExtension</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="variables">Variables</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>

<span class="c1">// ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or
</span><span class="c1"></span>	<span class="c1">// Tracer.Extract() is not recognized by the Tracer implementation.
</span><span class="c1"></span>	<span class="nx">ErrUnsupportedFormat</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;</span><span class="p">)</span>

	<span class="c1">// ErrSpanContextNotFound occurs when the `carrier` passed to
</span><span class="c1"></span>	<span class="c1">// Tracer.Extract() is valid and uncorrupted but has insufficient
</span><span class="c1"></span>	<span class="c1">// information to extract a SpanContext.
</span><span class="c1"></span>	<span class="nx">ErrSpanContextNotFound</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: SpanContext not found in Extract carrier&#34;</span><span class="p">)</span>

	<span class="c1">// ErrInvalidSpanContext errors occur when Tracer.Inject() is asked to
</span><span class="c1"></span>	<span class="c1">// operate on a SpanContext which it is not prepared to handle (for
</span><span class="c1"></span>	<span class="c1">// example, since it was created by a different tracer implementation).
</span><span class="c1"></span>	<span class="nx">ErrInvalidSpanContext</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: SpanContext type incompatible with tracer&#34;</span><span class="p">)</span>

	<span class="c1">// ErrInvalidCarrier errors occur when Tracer.Inject() or Tracer.Extract()
</span><span class="c1"></span>	<span class="c1">// implementations expect a different type of `carrier` than they are
</span><span class="c1"></span>	<span class="c1">// given.
</span><span class="c1"></span>	<span class="nx">ErrInvalidCarrier</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: Invalid Inject/Extract carrier&#34;</span><span class="p">)</span>

	<span class="c1">// ErrSpanContextCorrupted occurs when the `carrier` passed to
</span><span class="c1"></span>	<span class="c1">// Tracer.Extract() is of the expected type but is corrupted.
</span><span class="c1"></span>	<span class="nx">ErrSpanContextCorrupted</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: SpanContext data corrupted in Extract carrier&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-contextwithspan">func ContextWithSpan</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">span</span> <span class="nx">Span</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
</code></pre></td></tr></table>
</div>
</div><p>ContextWithSpan返回一个新的“ context.Context”，其中包含对span的引用。如果span为nil，则返回没有活动span的新context。</p>
<h2 id="func-initglobaltracer">func InitGlobalTracer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InitGlobalTracer</span><span class="p">(</span><span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>不建议使用InitGlobalTracer。请使用SetGlobalTracer。</p>
<h2 id="func-isglobaltracerregistered">func IsGlobalTracerRegistered</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsGlobalTracerRegistered</span><span class="p">()</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>IsGlobalTracerRegistered返回“bool”，以指示是否已全局注册跟踪器</p>
<h2 id="func-setglobaltracer">func SetGlobalTracer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SetGlobalTracer</span><span class="p">(</span><span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>SetGlobalTracer sets the [singleton] opentracing.Tracer returned by GlobalTracer(). Those who use GlobalTracer (rather than directly manage an opentracing.Tracer instance) should call SetGlobalTracer as early as possible in main(), prior to calling the <code>StartSpan</code> global func below. Prior to calling <code>SetGlobalTracer</code>, any Spans started via the <code>StartSpan</code> (etc) globals are noops.</p>
<p>SetGlobalTracer设置由GlobalTracer（）返回的单例opentracing.Tracer。那些使用GlobalTracer（而不是直接管理opentracing.Tracer实例）的用户应在main（）之前尽早调用SetGlobalTracer，然后再调用下面的<code>StartSpan</code>全局函数。在调用SetGlobalTracer之前，通过StartSpan等全局变量启动的所有Span都是noop。</p>
<h2 id="type-builtinformat">type BuiltinFormat</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BuiltinFormat</span> <span class="kt">byte</span>
</code></pre></td></tr></table>
</div>
</div><p>BuiltinFormat用于在“opentracing”包中划分与Tracer.Inject（）和Tracer.Extract（）方法一起使用的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// Binary represents SpanContexts as opaque binary data.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Inject(): the carrier must be an `io.Writer`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Extract(): the carrier must be an `io.Reader`.
</span><span class="c1"></span>	<span class="nx">Binary</span> <span class="nx">BuiltinFormat</span> <span class="p">=</span> <span class="kc">iota</span>

	<span class="c1">// TextMap represents SpanContexts as key:value string pairs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Unlike HTTPHeaders, the TextMap format does not restrict the key or
</span><span class="c1"></span>	<span class="c1">// value character sets in any way.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Inject(): the carrier must be a `TextMapWriter`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Extract(): the carrier must be a `TextMapReader`.
</span><span class="c1"></span>	<span class="nx">TextMap</span>

	<span class="c1">// HTTPHeaders represents SpanContexts as HTTP header string pairs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Unlike TextMap, the HTTPHeaders format requires that the keys and values
</span><span class="c1"></span>	<span class="c1">// be valid as HTTP headers as-is (i.e., character casing may be unstable
</span><span class="c1"></span>	<span class="c1">// and special characters are disallowed in keys, values should be
</span><span class="c1"></span>	<span class="c1">// URL-escaped, etc).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Inject(): the carrier must be a `TextMapWriter`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Extract(): the carrier must be a `TextMapReader`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See HTTPHeadersCarrier for an implementation of both TextMapWriter
</span><span class="c1"></span>	<span class="c1">// and TextMapReader that defers to an http.Header instance for storage.
</span><span class="c1"></span>	<span class="c1">// For example, Inject():
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//    err := span.Tracer().Inject(
</span><span class="c1"></span>	<span class="c1">//        span.Context(), opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Or Extract():
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//    clientContext, err := tracer.Extract(
</span><span class="c1"></span>	<span class="c1">//        opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">HTTPHeaders</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-finishoptions">type FinishOptions</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FinishOptions</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="c1">// FinishTime overrides the Span&#39;s finish time, or implicitly becomes
</span><span class="c1"></span>	<span class="c1">// time.Now() if FinishTime.IsZero().
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// FinishTime must resolve to a timestamp that&#39;s &gt;= the Span&#39;s StartTime
</span><span class="c1"></span>	<span class="c1">// (per StartSpanOptions).
</span><span class="c1"></span>	<span class="nx">FinishTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

	<span class="c1">// LogRecords allows the caller to specify the contents of many LogFields()
</span><span class="c1"></span>	<span class="c1">// calls with a single slice. May be nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// None of the LogRecord.Timestamp values may be .IsZero() (i.e., they must
</span><span class="c1"></span>	<span class="c1">// be set explicitly). Also, they must be &gt;= the Span&#39;s start timestamp and
</span><span class="c1"></span>	<span class="c1">// &lt;= the FinishTime (or time.Now() if FinishTime.IsZero()). Otherwise the
</span><span class="c1"></span>	<span class="c1">// behavior of FinishWithOptions() is undefined.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If specified, the caller hands off ownership of LogRecords at
</span><span class="c1"></span>	<span class="c1">// FinishWithOptions() invocation time.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If specified, the (deprecated) BulkLogData must be nil or empty.
</span><span class="c1"></span>	<span class="nx">LogRecords</span> <span class="p">[]</span><span class="nx">LogRecord</span>

	<span class="c1">// BulkLogData is DEPRECATED.
</span><span class="c1"></span>	<span class="nx">BulkLogData</span> <span class="p">[]</span><span class="nx">LogData</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>FinishOptions允许Span.FinishWithOptions调用方覆盖完成时间戳，并通过批量接口提供日志数据。</p>
<h2 id="type-httpheaderscarrier">type HTTPHeadersCarrier</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HTTPHeadersCarrier</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Header</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTPHeadersCarrier同时满足TextMapWriter和TextMapReader。</p>
<p>服务器端用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">carrier</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">httpReq</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
<span class="nx">clientContext</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nx">carrier</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>客户端的用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">carrier</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">httpReq</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Inject</span><span class="p">(</span>
    <span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span>
    <span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span>
    <span class="nx">carrier</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-httpheaderscarrier-foreachkey">func (HTTPHeadersCarrier) ForeachKey</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">HTTPHeadersCarrier</span><span class="p">)</span> <span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>ForeachKey符合TextMapReader接口。</p>
<h2 id="func-httpheaderscarrier-set">func (HTTPHeadersCarrier) Set</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">HTTPHeadersCarrier</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Set符合TextMapWriter接口。</p>
<h2 id="type-logdata">type LogData</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogData</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Timestamp</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">Event</span>     <span class="kt">string</span>
	<span class="nx">Payload</span>   <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LogData已弃用</p>
<h2 id="func-logdata-tologrecord">func (*LogData) ToLogRecord</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ld</span> <span class="o">*</span><span class="nx">LogData</span><span class="p">)</span> <span class="nf">ToLogRecord</span><span class="p">()</span> <span class="nx">LogRecord</span>
</code></pre></td></tr></table>
</div>
</div><p>ToLogRecord将不推荐使用的LogData转换为推荐使用的LogRecord</p>
<h2 id="type-logrecord">type LogRecord</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogRecord</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Timestamp</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">Fields</span>    <span class="p">[]</span><span class="nx">log</span><span class="p">.</span><span class="nx">Field</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LogRecord是与单个Span日志关联的数据。每个LogRecord实例必须至少指定一个字段。</p>
<h2 id="type-nooptracer">type NoopTracer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">NoopTracer</span> <span class="kd">struct</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>NoopTracer是Tracer的一个琐碎的，最小开销的实现，所有操作均禁止操作。</p>
<p>此实现的主要用途是在诸如RPC框架之类的库中，这些库使跟踪由最终用户控制的可选功能成为可能。无操作实现允许所述库将其用作默认跟踪程序，不需要编写继续检查跟踪程序实例是否为nil的工具。</p>
<p>出于相同的原因，NoopTracer是默认的“全局”跟踪器（请参阅GlobalTracer和SetGlobalTracer函数）。</p>
<p>警告：NoopTracer不支持baggage运输。</p>
<h2 id="func-nooptracer-extract">func (NoopTracer) Extract</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">NoopTracer</span><span class="p">)</span> <span class="nf">Extract</span><span class="p">(</span><span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">SpanContext</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>提取属于Tracer接口。</p>
<h2 id="func-nooptracer-inject">func (NoopTracer) Inject</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">NoopTracer</span><span class="p">)</span> <span class="nf">Inject</span><span class="p">(</span><span class="nx">sp</span> <span class="nx">SpanContext</span><span class="p">,</span> <span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>注入属于Tracer接口。</p>
<h2 id="func-nooptracer-startspan">func (NoopTracer) StartSpan</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">NoopTracer</span><span class="p">)</span> <span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpan属于Tracer接口。</p>
<h2 id="type-span">type Span</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Span</span> <span class="kd">interface</span> <span class="p">{</span>

<span class="c1">// Sets the end timestamp and finalizes Span state.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// With the exception of calls to Context() (which are always allowed),
</span><span class="c1"></span>	<span class="c1">// Finish() must be the last call made to any span instance, and to do
</span><span class="c1"></span>	<span class="c1">// otherwise leads to undefined behavior.
</span><span class="c1"></span>	<span class="nf">Finish</span><span class="p">()</span>
	<span class="c1">// FinishWithOptions is like Finish() but with explicit control over
</span><span class="c1"></span>	<span class="c1">// timestamps and log data.
</span><span class="c1"></span>	<span class="nf">FinishWithOptions</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">FinishOptions</span><span class="p">)</span>

	<span class="c1">// Context() yields the SpanContext for this Span. Note that the return
</span><span class="c1"></span>	<span class="c1">// value of Context() is still valid after a call to Span.Finish(), as is
</span><span class="c1"></span>	<span class="c1">// a call to Span.Context() after a call to Span.Finish().
</span><span class="c1"></span>	<span class="nf">Context</span><span class="p">()</span> <span class="nx">SpanContext</span>

	<span class="c1">// Sets or changes the operation name.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Returns a reference to this Span for chaining.
</span><span class="c1"></span>	<span class="nf">SetOperationName</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Adds a tag to the span.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If there is a pre-existing tag set for `key`, it is overwritten.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Tag values can be numeric types, strings, or bools. The behavior of
</span><span class="c1"></span>	<span class="c1">// other tag value types is undefined at the OpenTracing level. If a
</span><span class="c1"></span>	<span class="c1">// tracing system does not know how to handle a particular value type, it
</span><span class="c1"></span>	<span class="c1">// may ignore the tag, but shall not panic.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Returns a reference to this Span for chaining.
</span><span class="c1"></span>	<span class="nf">SetTag</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Span</span>

	<span class="c1">// LogFields is an efficient and type-checked way to record key:value
</span><span class="c1"></span>	<span class="c1">// logging data about a Span, though the programming interface is a little
</span><span class="c1"></span>	<span class="c1">// more verbose than LogKV(). Here&#39;s an example:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    span.LogFields(
</span><span class="c1"></span>	<span class="c1">//        log.String(&#34;event&#34;, &#34;soft error&#34;),
</span><span class="c1"></span>	<span class="c1">//        log.String(&#34;type&#34;, &#34;cache timeout&#34;),
</span><span class="c1"></span>	<span class="c1">//        log.Int(&#34;waited.millis&#34;, 1500))
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Also see Span.FinishWithOptions() and FinishOptions.BulkLogData.
</span><span class="c1"></span>	<span class="nf">LogFields</span><span class="p">(</span><span class="nx">fields</span> <span class="o">...</span><span class="nx">log</span><span class="p">.</span><span class="nx">Field</span><span class="p">)</span>

	<span class="c1">// LogKV is a concise, readable way to record key:value logging data about
</span><span class="c1"></span>	<span class="c1">// a Span, though unfortunately this also makes it less efficient and less
</span><span class="c1"></span>	<span class="c1">// type-safe than LogFields(). Here&#39;s an example:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    span.LogKV(
</span><span class="c1"></span>	<span class="c1">//        &#34;event&#34;, &#34;soft error&#34;,
</span><span class="c1"></span>	<span class="c1">//        &#34;type&#34;, &#34;cache timeout&#34;,
</span><span class="c1"></span>	<span class="c1">//        &#34;waited.millis&#34;, 1500)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For LogKV (as opposed to LogFields()), the parameters must appear as
</span><span class="c1"></span>	<span class="c1">// key-value pairs, like
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    span.LogKV(key1, val1, key2, val2, key3, val3, ...)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The keys must all be strings. The values may be strings, numeric types,
</span><span class="c1"></span>	<span class="c1">// bools, Go error instances, or arbitrary structs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// (Note to implementors: consider the log.InterleavedKVToFields() helper)
</span><span class="c1"></span>	<span class="nf">LogKV</span><span class="p">(</span><span class="nx">alternatingKeyValues</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>

	<span class="c1">// SetBaggageItem sets a key:value pair on this Span and its SpanContext
</span><span class="c1"></span>	<span class="c1">// that also propagates to descendants of this Span.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// SetBaggageItem() enables powerful functionality given a full-stack
</span><span class="c1"></span>	<span class="c1">// opentracing integration (e.g., arbitrary application data from a mobile
</span><span class="c1"></span>	<span class="c1">// app can make it, transparently, all the way into the depths of a storage
</span><span class="c1"></span>	<span class="c1">// system), and with it some powerful costs: use this feature with care.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// IMPORTANT NOTE #1: SetBaggageItem() will only propagate baggage items to
</span><span class="c1"></span>	<span class="c1">// *future* causal descendants of the associated Span.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and
</span><span class="c1"></span>	<span class="c1">// value is copied into every local *and remote* child of the associated
</span><span class="c1"></span>	<span class="c1">// Span, and that can add up to a lot of network and cpu overhead.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Returns a reference to this Span for chaining.
</span><span class="c1"></span>	<span class="nf">SetBaggageItem</span><span class="p">(</span><span class="nx">restrictedKey</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Gets the value for a baggage item given its key. Returns the empty string
</span><span class="c1"></span>	<span class="c1">// if the value isn&#39;t found in this Span.
</span><span class="c1"></span>	<span class="nf">BaggageItem</span><span class="p">(</span><span class="nx">restrictedKey</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>

	<span class="c1">// Provides access to the Tracer that created this Span.
</span><span class="c1"></span>	<span class="nf">Tracer</span><span class="p">()</span> <span class="nx">Tracer</span>

	<span class="c1">// Deprecated: use LogFields or LogKV
</span><span class="c1"></span>	<span class="nf">LogEvent</span><span class="p">(</span><span class="nx">event</span> <span class="kt">string</span><span class="p">)</span>
	<span class="c1">// Deprecated: use LogFields or LogKV
</span><span class="c1"></span>	<span class="nf">LogEventWithPayload</span><span class="p">(</span><span class="nx">event</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">payload</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="c1">// Deprecated: use LogFields or LogKV
</span><span class="c1"></span>	<span class="nf">Log</span><span class="p">(</span><span class="nx">data</span> <span class="nx">LogData</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Span表示OpenTracing系统中活动的未完成的span。</p>
<p>Span由Tracer接口创建。</p>
<h2 id="func-spanfromcontext">func SpanFromContext</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SpanFromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>SpanFromContext返回以前与<code>ctx</code>关联的<code>Span</code>，如果找不到这样的<code>Span</code>，则返回nil。</p>
<p>注意：context.Context！= SpanContext：前者是Go的进程内上下文传播机制，后者是OpenTracing的每span标识和行李信息。</p>
<h2 id="func-startspan">func StartSpan</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpan遵循<code>Tracer.StartSpan</code>。参见<code>GlobalTracer（）</code>。</p>
<h2 id="func-startspanfromcontext">func StartSpanFromContext</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpanFromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Span</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanFromContext启动并返回带有“operationName”的Span，使用在“ctx”中找到的任何Span作为ChildOfRef。如果找不到此类父级，则StartSpanFromContext将创建一个根（无父级）span。</p>
<p>第二个返回值是围绕返回的Span构建的context.Context对象。</p>
<p>用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">SomeFunction</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sp</span><span class="p">,</span> <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartSpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;SomeFunction&#34;</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">sp</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-startspanfromcontextwithtracer">func StartSpanFromContextWithTracer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpanFromContextWithTracer</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">,</span> <span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Span</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanFromContextWithTracer使用在context中找到的span作为ChildOfRef来启动并返回带有“ operationName”的span。如果不存在，则会创建一个根范围。它还返回一个context.Context对象，该对象围绕返回的范围构建。</p>
<p>它的行为与StartSpanFromContext相同，除了它使用显式跟踪程序而不是使用全局跟踪程序。</p>
<h2 id="type-spancontext">type SpanContext</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SpanContext</span> <span class="kd">interface</span> <span class="p">{</span>

<span class="c1">// ForeachBaggageItem grants access to all baggage items stored in the
</span><span class="c1"></span>	<span class="c1">// SpanContext.
</span><span class="c1"></span>	<span class="c1">// The handler function will be called for each baggage key/value pair.
</span><span class="c1"></span>	<span class="c1">// The ordering of items is not guaranteed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The bool return value indicates if the handler wants to continue iterating
</span><span class="c1"></span>	<span class="c1">// through the rest of the baggage items; for example if the handler is trying to
</span><span class="c1"></span>	<span class="c1">// find some baggage item by pattern matching the name, it can return false
</span><span class="c1"></span>	<span class="c1">// as soon as the item is found to stop further iterations.
</span><span class="c1"></span>	<span class="nf">ForeachBaggageItem</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SpanContext表示必须传播到后代Span并跨越进程边界的Span状态（例如，<code>&lt;trace_id，span_id，sampled&gt;</code>元组）。</p>
<h2 id="type-spanreference">type SpanReference</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SpanReference</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>              <span class="nx">SpanReferenceType</span>
	<span class="nx">ReferencedContext</span> <span class="nx">SpanContext</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SpanReference是将SpanReferenceType和引用的SpanContext配对的StartSpanOption。有关受支持的关系，请参见SpanReferenceType文档。如果SpanReference是使用ReferencedContext == nil创建的，则无效。因此，它为开始span提供了更简洁的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sc</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">someFormat</span><span class="p">,</span> <span class="nx">someCarrier</span><span class="p">)</span>
<span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;operation&#34;</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">sc</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>如果sc == nil，则上面的ChildOf（sc）选项不会惊慌，只会将父级span引用添加到选项中。</p>
<h2 id="func-childof">func ChildOf</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChildOf</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">SpanContext</span><span class="p">)</span> <span class="nx">SpanReference</span>
</code></pre></td></tr></table>
</div>
</div><p>ChildOf返回一个StartSpanOption，它指向一个依赖的父范围。如果sc == nil，则该选项无效。</p>
<p>参见ChildOfRef，SpanReference</p>
<h2 id="func-followsfrom">func FollowsFrom</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">FollowsFrom</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">SpanContext</span><span class="p">)</span> <span class="nx">SpanReference</span>
</code></pre></td></tr></table>
</div>
</div><p>FollowsFrom返回一个StartSpanOption，它指向导致子Span的父Span，但不以任何方式直接取决于其结果。如果sc == nil，则该选项无效。</p>
<p>请参见FollowsFromRef，SpanReference</p>
<h2 id="func-spanreference-apply">func (SpanReference) Apply</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">SpanReference</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="type-spanreferencetype">type SpanReferenceType</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SpanReferenceType</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>panReferenceType是一个枚举类型，描述了两个Span之间关系的不同类别。如果Span-2引用Span-1，则SpanReferenceType从Span-2的角度描述Span-1。例如，ChildOfRef表示Span-1创建了Span-2。</p>
<p>注意：Span-1和Span-2不一定*彼此依赖才能完成；例如，Span-2可能是Span-1排队的后台作业的一部分，或者Span-2可能坐在Span-1后面的分布式队列中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// ChildOfRef refers to a parent Span that caused *and* somehow depends
</span><span class="c1"></span>	<span class="c1">// upon the new child Span. Often (but not always), the parent Span cannot
</span><span class="c1"></span>	<span class="c1">// finish until the child Span does.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// An timing diagram for a ChildOfRef that&#39;s blocked on the new Span:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span---------]
</span><span class="c1"></span>	<span class="c1">//          [-Child Span----]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See &lt;http://opentracing.io/spec/&gt;
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See opentracing.ChildOf()
</span><span class="c1"></span>	<span class="nx">ChildOfRef</span> <span class="nx">SpanReferenceType</span> <span class="p">=</span> <span class="kc">iota</span>

	<span class="c1">// FollowsFromRef refers to a parent Span that does not depend in any way
</span><span class="c1"></span>	<span class="c1">// on the result of the new child Span. For instance, one might use
</span><span class="c1"></span>	<span class="c1">// FollowsFromRefs to describe pipeline stages separated by queues,
</span><span class="c1"></span>	<span class="c1">// or a fire-and-forget cache insert at the tail end of a web request.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A FollowsFromRef Span is part of the same logical trace as the new Span:
</span><span class="c1"></span>	<span class="c1">// i.e., the new Span is somehow caused by the work of its FollowsFromRef.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// All of the following could be valid timing diagrams for children that
</span><span class="c1"></span>	<span class="c1">// &#34;FollowFrom&#34; a parent.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span-]  [-Child Span-]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span--]
</span><span class="c1"></span>	<span class="c1">//      [-Child Span-]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span-]
</span><span class="c1"></span>	<span class="c1">//                 [-Child Span-]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See http://opentracing.io/spec/
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See opentracing.FollowsFrom()
</span><span class="c1"></span>	<span class="nx">FollowsFromRef</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-startspanoption">type StartSpanOption</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StartSpanOption</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Apply</span><span class="p">(</span><span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanOption实例（零个或多个）可以传递给Tracer.StartSpan。</p>
<p>根据<a href="http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis%EF%BC%8CStartSpanOption">http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis，StartSpanOption</a>借鉴了“功能选项”模式</p>
<h2 id="type-startspanoptions">type StartSpanOptions</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StartSpanOptions</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Zero or more causal references to other Spans (via their SpanContext).
</span><span class="c1"></span>	<span class="c1">// If empty, start a &#34;root&#34; Span (i.e., start a new trace).
</span><span class="c1"></span>	<span class="nx">References</span> <span class="p">[]</span><span class="nx">SpanReference</span>

	<span class="c1">// StartTime overrides the Span&#39;s start time, or implicitly becomes
</span><span class="c1"></span>	<span class="c1">// time.Now() if StartTime.IsZero().
</span><span class="c1"></span>	<span class="nx">StartTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

	<span class="c1">// Tags may have zero or more entries; the restrictions on map values are
</span><span class="c1"></span>	<span class="c1">// identical to those for Span.SetTag(). May be nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If specified, the caller hands off ownership of Tags at
</span><span class="c1"></span>	<span class="c1">// StartSpan() invocation time.
</span><span class="c1"></span>	<span class="nx">Tags</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanOptions允许Tracer.StartSpan（）调用者和实现者一种机制来覆盖开始时间戳，指定Span引用以及在Span开始时提供单个或多个Tag。</p>
<p>StartSpan（）调用者应查看此包中可用的StartSpanOption接口和实现。</p>
<p>跟踪程序的实现可以将StartSpanOption实例的一部分转换为StartSpanOptions结构，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpan</span><span class="p">(</span><span class="nx">opName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sso</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">StartSpanOptions</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nx">o</span><span class="p">.</span><span class="nf">Apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sso</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-starttime">type StartTime</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StartTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</code></pre></td></tr></table>
</div>
</div><p>StartTime是一个StartSpanOption，它为新Span设置了明确的开始时间戳。</p>
<h2 id="func-starttime-apply">func (StartTime) Apply</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">StartTime</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="type-tag">type Tag</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tag</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Key</span>   <span class="kt">string</span>
	<span class="nx">Value</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>标记可以作为StartSpanOption传递，以将标记添加到新的span，或者可以使用其Set方法将标记应用于现有Span，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;opName&#34;</span><span class="p">,</span> <span class="nx">Tag</span><span class="p">{</span><span class="s">&#34;Key&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Tag</span><span class="p">{</span><span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">}.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-tag-apply">func (Tag) Apply</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Tag</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="func-tag-set">func (Tag) Set</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Tag</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Span</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Set将标签应用于现有的Span。</p>
<h2 id="type-tags">type Tags</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tags</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>标签是从任意字符串键到不透明值类型的通用映射。基础跟踪系统负责解释和序列化值。</p>
<h2 id="func-tags-apply">func (Tags) Apply</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Tags</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="type-textmapcarrier">type TextMapCarrier</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TextMapCarrier</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>TextMapCarrier允许将常规<code>map[string]string</code>用作TextMapWriter和TextMapReader。</p>
<h2 id="func-textmapcarrier-foreachkey">func (TextMapCarrier) ForeachKey</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">TextMapCarrier</span><span class="p">)</span> <span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>ForeachKey符合TextMapReader接口。</p>
<h2 id="func-textmapcarrier-set">func (TextMapCarrier) Set</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">TextMapCarrier</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Set实现opentracing.TextMapWriter的Set（）</p>
<h2 id="type-textmapreader">type TextMapReader</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TextMapReader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// ForeachKey returns TextMap contents via repeated calls to the `handler`
</span><span class="c1"></span>	<span class="c1">// function. If any call to `handler` returns a non-nil error, ForeachKey
</span><span class="c1"></span>	<span class="c1">// terminates and returns that error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: The backing store for the TextMapReader may contain data unrelated
</span><span class="c1"></span>	<span class="c1">// to SpanContext. As such, Inject() and Extract() implementations that
</span><span class="c1"></span>	<span class="c1">// call the TextMapWriter and TextMapReader interfaces must agree on a
</span><span class="c1"></span>	<span class="c1">// prefix or other convention to distinguish their own key:value pairs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The &#34;foreach&#34; callback pattern reduces unnecessary copying in some cases
</span><span class="c1"></span>	<span class="c1">// and also allows implementations to hold locks while the map is read.
</span><span class="c1"></span>	<span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TextMapReader是TextMap内置格式的Extract（）载体。使用它，调用方可以将传播的SpanContext解码为unicode字符串映射中的条目。</p>
<h2 id="type-textmapwriter">type TextMapWriter</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TextMapWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Set a key:value pair to the carrier. Multiple calls to Set() for the
</span><span class="c1"></span>	<span class="c1">// same key leads to undefined behavior.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: The backing store for the TextMapWriter may contain data unrelated
</span><span class="c1"></span>	<span class="c1">// to SpanContext. As such, Inject() and Extract() implementations that
</span><span class="c1"></span>	<span class="c1">// call the TextMapWriter and TextMapReader interfaces must agree on a
</span><span class="c1"></span>	<span class="c1">// prefix or other convention to distinguish their own key:value pairs.
</span><span class="c1"></span>	<span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TextMapWriter是TextMap内置格式的Inject（）载体。有了它，调用者可以对SpanContext进行编码，以作为unicode字符串映射中的条目传播。</p>
<h2 id="type-tracer">type Tracer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tracer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Create, start, and return a new Span with the given `operationName` and
</span><span class="c1"></span>	<span class="c1">// incorporate the given StartSpanOption `opts`. (Note that `opts` borrows
</span><span class="c1"></span>	<span class="c1">// from the &#34;functional options&#34; pattern, per
</span><span class="c1"></span>	<span class="c1">// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A Span with no SpanReference options (e.g., opentracing.ChildOf() or
</span><span class="c1"></span>	<span class="c1">// opentracing.FollowsFrom()) becomes the root of its own trace.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Examples:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     var tracer opentracing.Tracer = ...
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // The root-span case:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(&#34;GetFeed&#34;)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // The vanilla child span case:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//         &#34;GetFeed&#34;,
</span><span class="c1"></span>	<span class="c1">//         opentracing.ChildOf(parentSpan.Context()))
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // All the bells and whistles:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//         &#34;GetFeed&#34;,
</span><span class="c1"></span>	<span class="c1">//         opentracing.ChildOf(parentSpan.Context()),
</span><span class="c1"></span>	<span class="c1">//         opentracing.Tag{&#34;user_agent&#34;, loggedReq.UserAgent},
</span><span class="c1"></span>	<span class="c1">//         opentracing.StartTime(loggedReq.Timestamp),
</span><span class="c1"></span>	<span class="c1">//     )
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Inject() takes the `sm` SpanContext instance and injects it for
</span><span class="c1"></span>	<span class="c1">// propagation within `carrier`. The actual type of `carrier` depends on
</span><span class="c1"></span>	<span class="c1">// the value of `format`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// OpenTracing defines a common set of `format` values (see BuiltinFormat),
</span><span class="c1"></span>	<span class="c1">// and each has an expected carrier type.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Other packages may declare their own `format` values, much like the keys
</span><span class="c1"></span>	<span class="c1">// used by `context.Context` (see https://godoc.org/context#WithValue).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Example usage (sans error handling):
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//     err := tracer.Inject(
</span><span class="c1"></span>	<span class="c1">//         span.Context(),
</span><span class="c1"></span>	<span class="c1">//         opentracing.HTTPHeaders,
</span><span class="c1"></span>	<span class="c1">//         carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: All opentracing.Tracer implementations MUST support all
</span><span class="c1"></span>	<span class="c1">// BuiltinFormats.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Implementations may return opentracing.ErrUnsupportedFormat if `format`
</span><span class="c1"></span>	<span class="c1">// is not supported by (or not known by) the implementation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Implementations may return opentracing.ErrInvalidCarrier or any other
</span><span class="c1"></span>	<span class="c1">// implementation-specific error if the format is supported but injection
</span><span class="c1"></span>	<span class="c1">// fails anyway.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See Tracer.Extract().
</span><span class="c1"></span>	<span class="nf">Inject</span><span class="p">(</span><span class="nx">sm</span> <span class="nx">SpanContext</span><span class="p">,</span> <span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>

	<span class="c1">// Extract() returns a SpanContext instance given `format` and `carrier`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// OpenTracing defines a common set of `format` values (see BuiltinFormat),
</span><span class="c1"></span>	<span class="c1">// and each has an expected carrier type.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Other packages may declare their own `format` values, much like the keys
</span><span class="c1"></span>	<span class="c1">// used by `context.Context` (see
</span><span class="c1"></span>	<span class="c1">// https://godoc.org/golang.org/x/net/context#WithValue).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Example usage (with StartSpan):
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//     clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // ... assuming the ultimate goal here is to resume the trace with a
</span><span class="c1"></span>	<span class="c1">//     // server-side Span:
</span><span class="c1"></span>	<span class="c1">//     var serverSpan opentracing.Span
</span><span class="c1"></span>	<span class="c1">//     if err == nil {
</span><span class="c1"></span>	<span class="c1">//         span = tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//             rpcMethodName, ext.RPCServerOption(clientContext))
</span><span class="c1"></span>	<span class="c1">//     } else {
</span><span class="c1"></span>	<span class="c1">//         span = tracer.StartSpan(rpcMethodName)
</span><span class="c1"></span>	<span class="c1">//     }
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: All opentracing.Tracer implementations MUST support all
</span><span class="c1"></span>	<span class="c1">// BuiltinFormats.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Return values:
</span><span class="c1"></span>	<span class="c1">//  - A successful Extract returns a SpanContext instance and a nil error
</span><span class="c1"></span>	<span class="c1">//  - If there was simply no SpanContext to extract in `carrier`, Extract()
</span><span class="c1"></span>	<span class="c1">//    returns (nil, opentracing.ErrSpanContextNotFound)
</span><span class="c1"></span>	<span class="c1">//  - If `format` is unsupported or unrecognized, Extract() returns (nil,
</span><span class="c1"></span>	<span class="c1">//    opentracing.ErrUnsupportedFormat)
</span><span class="c1"></span>	<span class="c1">//  - If there are more fundamental problems with the `carrier` object,
</span><span class="c1"></span>	<span class="c1">//    Extract() may return opentracing.ErrInvalidCarrier,
</span><span class="c1"></span>	<span class="c1">//    opentracing.ErrSpanContextCorrupted, or implementation-specific
</span><span class="c1"></span>	<span class="c1">//    errors.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See Tracer.Inject().
</span><span class="c1"></span>	<span class="nf">Extract</span><span class="p">(</span><span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">SpanContext</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Tracer是用于Span创建和SpanContext传播的简单的接口。</p>
<h2 id="func-globaltracer">func GlobalTracer</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GlobalTracer</span><span class="p">()</span> <span class="nx">Tracer</span>
</code></pre></td></tr></table>
</div>
</div><p>GlobalTracer返回全局单例“Tracer”实现。在调用SetGlobalTracer（）之前，GlobalTracer（）是一个noop实现，它将丢弃传递给它的所有数据。</p>
<h2 id="type-tracercontextwithspanextension">type TracerContextWithSpanExtension</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TracerContextWithSpanExtension</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// ContextWithSpanHook gets called by the ContextWithSpan
</span><span class="c1"></span>	<span class="c1">// function, when the Tracer implementation also implements
</span><span class="c1"></span>	<span class="c1">// this interface. It allows to put extra information into the
</span><span class="c1"></span>	<span class="c1">// context and make it available to the callers of the
</span><span class="c1"></span>	<span class="c1">// ContextWithSpan.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This hook is invoked before the ContextWithSpan function
</span><span class="c1"></span>	<span class="c1">// actually puts the span into the context.
</span><span class="c1"></span>	<span class="nf">ContextWithSpanHook</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">span</span> <span class="nx">Span</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TracerContextWithSpanExtension是Tracer接口的实现可能想要实现的扩展接口。当调用ContextWithSpan时，它可以对go上下文进行一些控制。</p>
<p>此扩展的主要目的是从opentracing API到其他一些跟踪API的适配器。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-10-09
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/opentracing/">opentracing</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E7%9A%84sysmon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go的sysmon源码剖析</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/http2%E4%B8%8Eh2c/">
            <span class="next-text nav-default">Http2与h2c</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
