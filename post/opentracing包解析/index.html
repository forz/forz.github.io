<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Opentracing包解析 | Forz Blog</title>
<meta name="keywords" content="opentracing" />
<meta name="description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but">
<meta name="author" content="">
<link rel="canonical" href="/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Opentracing包解析" />
<meta property="og:description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-09T16:40:11&#43;00:00" />
<meta property="article:modified_time" content="2020-10-09T16:40:11&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Opentracing包解析"/>
<meta name="twitter:description" content="Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Opentracing包解析",
      "item": "/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Opentracing包解析",
  "name": "Opentracing包解析",
  "description": "Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or // Tracer.Extract() is not recognized by the Tracer implementation. ErrUnsupportedFormat = errors.New(\u0026#34;opentracing: Unknown or unsupported Inject/Extract format\u0026#34;) // ErrSpanContextNotFound occurs when the `carrier` passed to // Tracer.Extract() is valid and uncorrupted but",
  "keywords": [
    "opentracing"
  ],
  "articleBody": "Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var ( // ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or \t// Tracer.Extract() is not recognized by the Tracer implementation. \tErrUnsupportedFormat = errors.New(\"opentracing: Unknown or unsupported Inject/Extract format\") // ErrSpanContextNotFound occurs when the `carrier` passed to \t// Tracer.Extract() is valid and uncorrupted but has insufficient \t// information to extract a SpanContext. \tErrSpanContextNotFound = errors.New(\"opentracing: SpanContext not found in Extract carrier\") // ErrInvalidSpanContext errors occur when Tracer.Inject() is asked to \t// operate on a SpanContext which it is not prepared to handle (for \t// example, since it was created by a different tracer implementation). \tErrInvalidSpanContext = errors.New(\"opentracing: SpanContext type incompatible with tracer\") // ErrInvalidCarrier errors occur when Tracer.Inject() or Tracer.Extract() \t// implementations expect a different type of `carrier` than they are \t// given. \tErrInvalidCarrier = errors.New(\"opentracing: Invalid Inject/Extract carrier\") // ErrSpanContextCorrupted occurs when the `carrier` passed to \t// Tracer.Extract() is of the expected type but is corrupted. \tErrSpanContextCorrupted = errors.New(\"opentracing: SpanContext data corrupted in Extract carrier\") )   func ContextWithSpan 1  func ContextWithSpan(ctx context.Context, span Span) context.Context   ContextWithSpan返回一个新的“ context.Context”，其中包含对span的引用。如果span为nil，则返回没有活动span的新context。\nfunc InitGlobalTracer 1  func InitGlobalTracer(tracer Tracer)   不建议使用InitGlobalTracer。请使用SetGlobalTracer。\nfunc IsGlobalTracerRegistered 1  func IsGlobalTracerRegistered() bool   IsGlobalTracerRegistered返回“bool”，以指示是否已全局注册跟踪器\nfunc SetGlobalTracer 1  func SetGlobalTracer(tracer Tracer)   SetGlobalTracer sets the [singleton] opentracing.Tracer returned by GlobalTracer(). Those who use GlobalTracer (rather than directly manage an opentracing.Tracer instance) should call SetGlobalTracer as early as possible in main(), prior to calling the StartSpan global func below. Prior to calling SetGlobalTracer, any Spans started via the StartSpan (etc) globals are noops.\nSetGlobalTracer设置由GlobalTracer（）返回的单例opentracing.Tracer。那些使用GlobalTracer（而不是直接管理opentracing.Tracer实例）的用户应在main（）之前尽早调用SetGlobalTracer，然后再调用下面的StartSpan全局函数。在调用SetGlobalTracer之前，通过StartSpan等全局变量启动的所有Span都是noop。\ntype BuiltinFormat 1  type BuiltinFormat byte   BuiltinFormat用于在“opentracing”包中划分与Tracer.Inject（）和Tracer.Extract（）方法一起使用的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  const ( // Binary represents SpanContexts as opaque binary data. \t// \t// For Tracer.Inject(): the carrier must be an `io.Writer`. \t// \t// For Tracer.Extract(): the carrier must be an `io.Reader`. \tBinary BuiltinFormat = iota // TextMap represents SpanContexts as key:value string pairs. \t// \t// Unlike HTTPHeaders, the TextMap format does not restrict the key or \t// value character sets in any way. \t// \t// For Tracer.Inject(): the carrier must be a `TextMapWriter`. \t// \t// For Tracer.Extract(): the carrier must be a `TextMapReader`. \tTextMap // HTTPHeaders represents SpanContexts as HTTP header string pairs. \t// \t// Unlike TextMap, the HTTPHeaders format requires that the keys and values \t// be valid as HTTP headers as-is (i.e., character casing may be unstable \t// and special characters are disallowed in keys, values should be \t// URL-escaped, etc). \t// \t// For Tracer.Inject(): the carrier must be a `TextMapWriter`. \t// \t// For Tracer.Extract(): the carrier must be a `TextMapReader`. \t// \t// See HTTPHeadersCarrier for an implementation of both TextMapWriter \t// and TextMapReader that defers to an http.Header instance for storage. \t// For example, Inject(): \t// \t// carrier := opentracing.HTTPHeadersCarrier(httpReq.Header) \t// err := span.Tracer().Inject( \t// span.Context(), opentracing.HTTPHeaders, carrier) \t// \t// Or Extract(): \t// \t// carrier := opentracing.HTTPHeadersCarrier(httpReq.Header) \t// clientContext, err := tracer.Extract( \t// opentracing.HTTPHeaders, carrier) \t// \tHTTPHeaders )   type FinishOptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  type FinishOptions struct { // FinishTime overrides the Span's finish time, or implicitly becomes \t// time.Now() if FinishTime.IsZero(). \t// \t// FinishTime must resolve to a timestamp that's = the Span's StartTime \t// (per StartSpanOptions). \tFinishTime time.Time // LogRecords allows the caller to specify the contents of many LogFields() \t// calls with a single slice. May be nil. \t// \t// None of the LogRecord.Timestamp values may be .IsZero() (i.e., they must \t// be set explicitly). Also, they must be = the Span's start timestamp and \t// \t// behavior of FinishWithOptions() is undefined. \t// \t// If specified, the caller hands off ownership of LogRecords at \t// FinishWithOptions() invocation time. \t// \t// If specified, the (deprecated) BulkLogData must be nil or empty. \tLogRecords []LogRecord // BulkLogData is DEPRECATED. \tBulkLogData []LogData }   FinishOptions允许Span.FinishWithOptions调用方覆盖完成时间戳，并通过批量接口提供日志数据。\ntype HTTPHeadersCarrier 1  type HTTPHeadersCarrier http.Header   HTTPHeadersCarrier同时满足TextMapWriter和TextMapReader。\n服务器端用法示例：\n1 2  carrier := opentracing.HTTPHeadersCarrier(httpReq.Header) clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier)   客户端的用法示例：\n1 2 3 4 5  carrier := opentracing.HTTPHeadersCarrier(httpReq.Header) err := tracer.Inject( span.Context(), opentracing.HTTPHeaders, carrier)   func (HTTPHeadersCarrier) ForeachKey 1  func (c HTTPHeadersCarrier) ForeachKey(handler func(key, val string) error) error   ForeachKey符合TextMapReader接口。\nfunc (HTTPHeadersCarrier) Set 1  func (c HTTPHeadersCarrier) Set(key, val string)   Set符合TextMapWriter接口。\ntype LogData 1 2 3 4 5  type LogData struct { Timestamp time.Time Event string Payload interface{} }   LogData已弃用\nfunc (*LogData) ToLogRecord 1  func (ld *LogData) ToLogRecord() LogRecord   ToLogRecord将不推荐使用的LogData转换为推荐使用的LogRecord\ntype LogRecord 1 2 3 4  type LogRecord struct { Timestamp time.Time Fields []log.Field }   LogRecord是与单个Span日志关联的数据。每个LogRecord实例必须至少指定一个字段。\ntype NoopTracer 1  type NoopTracer struct{}   NoopTracer是Tracer的一个琐碎的，最小开销的实现，所有操作均禁止操作。\n此实现的主要用途是在诸如RPC框架之类的库中，这些库使跟踪由最终用户控制的可选功能成为可能。无操作实现允许所述库将其用作默认跟踪程序，不需要编写继续检查跟踪程序实例是否为nil的工具。\n出于相同的原因，NoopTracer是默认的“全局”跟踪器（请参阅GlobalTracer和SetGlobalTracer函数）。\n警告：NoopTracer不支持baggage运输。\nfunc (NoopTracer) Extract 1  func (n NoopTracer) Extract(format interface{}, carrier interface{}) (SpanContext, error)   提取属于Tracer接口。\nfunc (NoopTracer) Inject 1  func (n NoopTracer) Inject(sp SpanContext, format interface{}, carrier interface{}) error   注入属于Tracer接口。\nfunc (NoopTracer) StartSpan 1  func (n NoopTracer) StartSpan(operationName string, opts ...StartSpanOption) Span   StartSpan属于Tracer接口。\ntype Span 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  type Span interface { // Sets the end timestamp and finalizes Span state. \t// \t// With the exception of calls to Context() (which are always allowed), \t// Finish() must be the last call made to any span instance, and to do \t// otherwise leads to undefined behavior. \tFinish() // FinishWithOptions is like Finish() but with explicit control over \t// timestamps and log data. \tFinishWithOptions(opts FinishOptions) // Context() yields the SpanContext for this Span. Note that the return \t// value of Context() is still valid after a call to Span.Finish(), as is \t// a call to Span.Context() after a call to Span.Finish(). \tContext() SpanContext // Sets or changes the operation name. \t// \t// Returns a reference to this Span for chaining. \tSetOperationName(operationName string) Span // Adds a tag to the span. \t// \t// If there is a pre-existing tag set for `key`, it is overwritten. \t// \t// Tag values can be numeric types, strings, or bools. The behavior of \t// other tag value types is undefined at the OpenTracing level. If a \t// tracing system does not know how to handle a particular value type, it \t// may ignore the tag, but shall not panic. \t// \t// Returns a reference to this Span for chaining. \tSetTag(key string, value interface{}) Span // LogFields is an efficient and type-checked way to record key:value \t// logging data about a Span, though the programming interface is a little \t// more verbose than LogKV(). Here's an example: \t// \t// span.LogFields( \t// log.String(\"event\", \"soft error\"), \t// log.String(\"type\", \"cache timeout\"), \t// log.Int(\"waited.millis\", 1500)) \t// \t// Also see Span.FinishWithOptions() and FinishOptions.BulkLogData. \tLogFields(fields ...log.Field) // LogKV is a concise, readable way to record key:value logging data about \t// a Span, though unfortunately this also makes it less efficient and less \t// type-safe than LogFields(). Here's an example: \t// \t// span.LogKV( \t// \"event\", \"soft error\", \t// \"type\", \"cache timeout\", \t// \"waited.millis\", 1500) \t// \t// For LogKV (as opposed to LogFields()), the parameters must appear as \t// key-value pairs, like \t// \t// span.LogKV(key1, val1, key2, val2, key3, val3, ...) \t// \t// The keys must all be strings. The values may be strings, numeric types, \t// bools, Go error instances, or arbitrary structs. \t// \t// (Note to implementors: consider the log.InterleavedKVToFields() helper) \tLogKV(alternatingKeyValues ...interface{}) // SetBaggageItem sets a key:value pair on this Span and its SpanContext \t// that also propagates to descendants of this Span. \t// \t// SetBaggageItem() enables powerful functionality given a full-stack \t// opentracing integration (e.g., arbitrary application data from a mobile \t// app can make it, transparently, all the way into the depths of a storage \t// system), and with it some powerful costs: use this feature with care. \t// \t// IMPORTANT NOTE #1: SetBaggageItem() will only propagate baggage items to \t// *future* causal descendants of the associated Span. \t// \t// IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and \t// value is copied into every local *and remote* child of the associated \t// Span, and that can add up to a lot of network and cpu overhead. \t// \t// Returns a reference to this Span for chaining. \tSetBaggageItem(restrictedKey, value string) Span // Gets the value for a baggage item given its key. Returns the empty string \t// if the value isn't found in this Span. \tBaggageItem(restrictedKey string) string // Provides access to the Tracer that created this Span. \tTracer() Tracer // Deprecated: use LogFields or LogKV \tLogEvent(event string) // Deprecated: use LogFields or LogKV \tLogEventWithPayload(event string, payload interface{}) // Deprecated: use LogFields or LogKV \tLog(data LogData) }   Span表示OpenTracing系统中活动的未完成的span。\nSpan由Tracer接口创建。\nfunc SpanFromContext 1  func SpanFromContext(ctx context.Context) Span   SpanFromContext返回以前与ctx关联的Span，如果找不到这样的Span，则返回nil。\n注意：context.Context！= SpanContext：前者是Go的进程内上下文传播机制，后者是OpenTracing的每span标识和行李信息。\nfunc StartSpan 1  func StartSpan(operationName string, opts ...StartSpanOption) Span   StartSpan遵循Tracer.StartSpan。参见GlobalTracer（）。\nfunc StartSpanFromContext 1  func StartSpanFromContext(ctx context.Context, operationName string, opts ...StartSpanOption) (Span, context.Context)   StartSpanFromContext启动并返回带有“operationName”的Span，使用在“ctx”中找到的任何Span作为ChildOfRef。如果找不到此类父级，则StartSpanFromContext将创建一个根（无父级）span。\n第二个返回值是围绕返回的Span构建的context.Context对象。\n用法示例：\n1 2 3 4 5  SomeFunction(ctx context.Context, ...) { sp, ctx := opentracing.StartSpanFromContext(ctx, \"SomeFunction\") defer sp.Finish() ... }   func StartSpanFromContextWithTracer 1  func StartSpanFromContextWithTracer(ctx context.Context, tracer Tracer, operationName string, opts ...StartSpanOption) (Span, context.Context)   StartSpanFromContextWithTracer使用在context中找到的span作为ChildOfRef来启动并返回带有“ operationName”的span。如果不存在，则会创建一个根范围。它还返回一个context.Context对象，该对象围绕返回的范围构建。\n它的行为与StartSpanFromContext相同，除了它使用显式跟踪程序而不是使用全局跟踪程序。\ntype SpanContext 1 2 3 4 5 6 7 8 9 10 11 12 13  type SpanContext interface { // ForeachBaggageItem grants access to all baggage items stored in the \t// SpanContext. \t// The handler function will be called for each baggage key/value pair. \t// The ordering of items is not guaranteed. \t// \t// The bool return value indicates if the handler wants to continue iterating \t// through the rest of the baggage items; for example if the handler is trying to \t// find some baggage item by pattern matching the name, it can return false \t// as soon as the item is found to stop further iterations. \tForeachBaggageItem(handler func(k, v string) bool) }   SpanContext表示必须传播到后代Span并跨越进程边界的Span状态（例如，元组）。\ntype SpanReference 1 2 3 4  type SpanReference struct { Type SpanReferenceType ReferencedContext SpanContext }   SpanReference是将SpanReferenceType和引用的SpanContext配对的StartSpanOption。有关受支持的关系，请参见SpanReferenceType文档。如果SpanReference是使用ReferencedContext == nil创建的，则无效。因此，它为开始span提供了更简洁的语法：\n1 2  sc, _ := tracer.Extract(someFormat, someCarrier) span := tracer.StartSpan(\"operation\", opentracing.ChildOf(sc))   如果sc == nil，则上面的ChildOf（sc）选项不会惊慌，只会将父级span引用添加到选项中。\nfunc ChildOf 1  func ChildOf(sc SpanContext) SpanReference   ChildOf返回一个StartSpanOption，它指向一个依赖的父范围。如果sc == nil，则该选项无效。\n参见ChildOfRef，SpanReference\nfunc FollowsFrom 1  func FollowsFrom(sc SpanContext) SpanReference   FollowsFrom返回一个StartSpanOption，它指向导致子Span的父Span，但不以任何方式直接取决于其结果。如果sc == nil，则该选项无效。\n请参见FollowsFromRef，SpanReference\nfunc (SpanReference) Apply 1  func (r SpanReference) Apply(o *StartSpanOptions)   Apply 满足StartSpanOption接口.\ntype SpanReferenceType 1  type SpanReferenceType int   panReferenceType是一个枚举类型，描述了两个Span之间关系的不同类别。如果Span-2引用Span-1，则SpanReferenceType从Span-2的角度描述Span-1。例如，ChildOfRef表示Span-1创建了Span-2。\n注意：Span-1和Span-2不一定*彼此依赖才能完成；例如，Span-2可能是Span-1排队的后台作业的一部分，或者Span-2可能坐在Span-1后面的分布式队列中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  const ( // ChildOfRef refers to a parent Span that caused *and* somehow depends \t// upon the new child Span. Often (but not always), the parent Span cannot \t// finish until the child Span does. \t// \t// An timing diagram for a ChildOfRef that's blocked on the new Span: \t// \t// [-Parent Span---------] \t// [-Child Span----] \t// \t// See  \t// \t// See opentracing.ChildOf() \tChildOfRef SpanReferenceType = iota // FollowsFromRef refers to a parent Span that does not depend in any way \t// on the result of the new child Span. For instance, one might use \t// FollowsFromRefs to describe pipeline stages separated by queues, \t// or a fire-and-forget cache insert at the tail end of a web request. \t// \t// A FollowsFromRef Span is part of the same logical trace as the new Span: \t// i.e., the new Span is somehow caused by the work of its FollowsFromRef. \t// \t// All of the following could be valid timing diagrams for children that \t// \"FollowFrom\" a parent. \t// \t// [-Parent Span-] [-Child Span-] \t// \t// \t// [-Parent Span--] \t// [-Child Span-] \t// \t// \t// [-Parent Span-] \t// [-Child Span-] \t// \t// See http://opentracing.io/spec/ \t// \t// See opentracing.FollowsFrom() \tFollowsFromRef )   type StartSpanOption 1 2 3  type StartSpanOption interface { Apply(*StartSpanOptions) }   StartSpanOption实例（零个或多个）可以传递给Tracer.StartSpan。\n根据http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis，StartSpanOption借鉴了“功能选项”模式\ntype StartSpanOptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type StartSpanOptions struct { // Zero or more causal references to other Spans (via their SpanContext). \t// If empty, start a \"root\" Span (i.e., start a new trace). \tReferences []SpanReference // StartTime overrides the Span's start time, or implicitly becomes \t// time.Now() if StartTime.IsZero(). \tStartTime time.Time // Tags may have zero or more entries; the restrictions on map values are \t// identical to those for Span.SetTag(). May be nil. \t// \t// If specified, the caller hands off ownership of Tags at \t// StartSpan() invocation time. \tTags map[string]interface{} }   StartSpanOptions允许Tracer.StartSpan（）调用者和实现者一种机制来覆盖开始时间戳，指定Span引用以及在Span开始时提供单个或多个Tag。\nStartSpan（）调用者应查看此包中可用的StartSpanOption接口和实现。\n跟踪程序的实现可以将StartSpanOption实例的一部分转换为StartSpanOptions结构，如下所示：\n1 2 3 4 5 6 7  func StartSpan(opName string, opts ...opentracing.StartSpanOption) { sso := opentracing.StartSpanOptions{} for _, o := range opts { o.Apply(\u0026sso) } ... }   type StartTime 1  type StartTime time.Time   StartTime是一个StartSpanOption，它为新Span设置了明确的开始时间戳。\nfunc (StartTime) Apply 1  func (t StartTime) Apply(o *StartSpanOptions)   Apply 满足StartSpanOption接口.\ntype Tag 1 2 3 4  type Tag struct { Key string Value interface{} }   标记可以作为StartSpanOption传递，以将标记添加到新的span，或者可以使用其Set方法将标记应用于现有Span，例如：\n1  tracer.StartSpan(\"opName\", Tag{\"Key\", value})   or\n1  Tag{\"key\", value}.Set(span)   func (Tag) Apply 1  func (t Tag) Apply(o *StartSpanOptions)   Apply 满足StartSpanOption接口.\nfunc (Tag) Set 1  func (t Tag) Set(s Span)   Set将标签应用于现有的Span。\ntype Tags 1  type Tags map[string]interface{}   标签是从任意字符串键到不透明值类型的通用映射。基础跟踪系统负责解释和序列化值。\nfunc (Tags) Apply 1  func (t Tags) Apply(o *StartSpanOptions)   Apply 满足StartSpanOption接口.\ntype TextMapCarrier 1  type TextMapCarrier map[string]string   TextMapCarrier允许将常规map[string]string用作TextMapWriter和TextMapReader。\nfunc (TextMapCarrier) ForeachKey 1  func (c TextMapCarrier) ForeachKey(handler func(key, val string) error) error   ForeachKey符合TextMapReader接口。\nfunc (TextMapCarrier) Set 1  func (c TextMapCarrier) Set(key, val string)   Set实现opentracing.TextMapWriter的Set（）\ntype TextMapReader 1 2 3 4 5 6 7 8 9 10 11 12 13 14  type TextMapReader interface { // ForeachKey returns TextMap contents via repeated calls to the `handler` \t// function. If any call to `handler` returns a non-nil error, ForeachKey \t// terminates and returns that error. \t// \t// NOTE: The backing store for the TextMapReader may contain data unrelated \t// to SpanContext. As such, Inject() and Extract() implementations that \t// call the TextMapWriter and TextMapReader interfaces must agree on a \t// prefix or other convention to distinguish their own key:value pairs. \t// \t// The \"foreach\" callback pattern reduces unnecessary copying in some cases \t// and also allows implementations to hold locks while the map is read. \tForeachKey(handler func(key, val string) error) error }   TextMapReader是TextMap内置格式的Extract（）载体。使用它，调用方可以将传播的SpanContext解码为unicode字符串映射中的条目。\ntype TextMapWriter 1 2 3 4 5 6 7 8 9 10  type TextMapWriter interface { // Set a key:value pair to the carrier. Multiple calls to Set() for the \t// same key leads to undefined behavior. \t// \t// NOTE: The backing store for the TextMapWriter may contain data unrelated \t// to SpanContext. As such, Inject() and Extract() implementations that \t// call the TextMapWriter and TextMapReader interfaces must agree on a \t// prefix or other convention to distinguish their own key:value pairs. \tSet(key, val string) }   TextMapWriter是TextMap内置格式的Inject（）载体。有了它，调用者可以对SpanContext进行编码，以作为unicode字符串映射中的条目传播。\ntype Tracer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  type Tracer interface { // Create, start, and return a new Span with the given `operationName` and \t// incorporate the given StartSpanOption `opts`. (Note that `opts` borrows \t// from the \"functional options\" pattern, per \t// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis) \t// \t// A Span with no SpanReference options (e.g., opentracing.ChildOf() or \t// opentracing.FollowsFrom()) becomes the root of its own trace. \t// \t// Examples: \t// \t// var tracer opentracing.Tracer = ... \t// \t// // The root-span case: \t// sp := tracer.StartSpan(\"GetFeed\") \t// \t// // The vanilla child span case: \t// sp := tracer.StartSpan( \t// \"GetFeed\", \t// opentracing.ChildOf(parentSpan.Context())) \t// \t// // All the bells and whistles: \t// sp := tracer.StartSpan( \t// \"GetFeed\", \t// opentracing.ChildOf(parentSpan.Context()), \t// opentracing.Tag{\"user_agent\", loggedReq.UserAgent}, \t// opentracing.StartTime(loggedReq.Timestamp), \t// ) \t// \tStartSpan(operationName string, opts ...StartSpanOption) Span // Inject() takes the `sm` SpanContext instance and injects it for \t// propagation within `carrier`. The actual type of `carrier` depends on \t// the value of `format`. \t// \t// OpenTracing defines a common set of `format` values (see BuiltinFormat), \t// and each has an expected carrier type. \t// \t// Other packages may declare their own `format` values, much like the keys \t// used by `context.Context` (see https://godoc.org/context#WithValue). \t// \t// Example usage (sans error handling): \t// \t// carrier := opentracing.HTTPHeadersCarrier(httpReq.Header) \t// err := tracer.Inject( \t// span.Context(), \t// opentracing.HTTPHeaders, \t// carrier) \t// \t// NOTE: All opentracing.Tracer implementations MUST support all \t// BuiltinFormats. \t// \t// Implementations may return opentracing.ErrUnsupportedFormat if `format` \t// is not supported by (or not known by) the implementation. \t// \t// Implementations may return opentracing.ErrInvalidCarrier or any other \t// implementation-specific error if the format is supported but injection \t// fails anyway. \t// \t// See Tracer.Extract(). \tInject(sm SpanContext, format interface{}, carrier interface{}) error // Extract() returns a SpanContext instance given `format` and `carrier`. \t// \t// OpenTracing defines a common set of `format` values (see BuiltinFormat), \t// and each has an expected carrier type. \t// \t// Other packages may declare their own `format` values, much like the keys \t// used by `context.Context` (see \t// https://godoc.org/golang.org/x/net/context#WithValue). \t// \t// Example usage (with StartSpan): \t// \t// \t// carrier := opentracing.HTTPHeadersCarrier(httpReq.Header) \t// clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier) \t// \t// // ... assuming the ultimate goal here is to resume the trace with a \t// // server-side Span: \t// var serverSpan opentracing.Span \t// if err == nil { \t// span = tracer.StartSpan( \t// rpcMethodName, ext.RPCServerOption(clientContext)) \t// } else { \t// span = tracer.StartSpan(rpcMethodName) \t// } \t// \t// \t// NOTE: All opentracing.Tracer implementations MUST support all \t// BuiltinFormats. \t// \t// Return values: \t// - A successful Extract returns a SpanContext instance and a nil error \t// - If there was simply no SpanContext to extract in `carrier`, Extract() \t// returns (nil, opentracing.ErrSpanContextNotFound) \t// - If `format` is unsupported or unrecognized, Extract() returns (nil, \t// opentracing.ErrUnsupportedFormat) \t// - If there are more fundamental problems with the `carrier` object, \t// Extract() may return opentracing.ErrInvalidCarrier, \t// opentracing.ErrSpanContextCorrupted, or implementation-specific \t// errors. \t// \t// See Tracer.Inject(). \tExtract(format interface{}, carrier interface{}) (SpanContext, error) }   Tracer是用于Span创建和SpanContext传播的简单的接口。\nfunc GlobalTracer 1  func GlobalTracer() Tracer   GlobalTracer返回全局单例“Tracer”实现。在调用SetGlobalTracer（）之前，GlobalTracer（）是一个noop实现，它将丢弃传递给它的所有数据。\ntype TracerContextWithSpanExtension 1 2 3 4 5 6 7 8 9 10 11  type TracerContextWithSpanExtension interface { // ContextWithSpanHook gets called by the ContextWithSpan \t// function, when the Tracer implementation also implements \t// this interface. It allows to put extra information into the \t// context and make it available to the callers of the \t// ContextWithSpan. \t// \t// This hook is invoked before the ContextWithSpan function \t// actually puts the span into the context. \tContextWithSpanHook(ctx context.Context, span Span) context.Context }   TracerContextWithSpanExtension是Tracer接口的实现可能想要实现的扩展接口。当调用ContextWithSpan时，它可以对go上下文进行一些控制。\n此扩展的主要目的是从opentracing API到其他一些跟踪API的适配器。\n",
  "wordCount" : "6532",
  "inLanguage": "zh-cn",
  "datePublished": "2020-10-09T16:40:11Z",
  "dateModified": "2020-10-09T16:40:11Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/opentracing%E5%8C%85%E8%A7%A3%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Opentracing包解析
    </h1>
    <div class="post-meta">October 9, 2020
</div>
  </header> 
  <div class="post-content"><h2 id="variables">Variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>

<span class="c1">// ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or
</span><span class="c1"></span>	<span class="c1">// Tracer.Extract() is not recognized by the Tracer implementation.
</span><span class="c1"></span>	<span class="nx">ErrUnsupportedFormat</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: Unknown or unsupported Inject/Extract format&#34;</span><span class="p">)</span>

	<span class="c1">// ErrSpanContextNotFound occurs when the `carrier` passed to
</span><span class="c1"></span>	<span class="c1">// Tracer.Extract() is valid and uncorrupted but has insufficient
</span><span class="c1"></span>	<span class="c1">// information to extract a SpanContext.
</span><span class="c1"></span>	<span class="nx">ErrSpanContextNotFound</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: SpanContext not found in Extract carrier&#34;</span><span class="p">)</span>

	<span class="c1">// ErrInvalidSpanContext errors occur when Tracer.Inject() is asked to
</span><span class="c1"></span>	<span class="c1">// operate on a SpanContext which it is not prepared to handle (for
</span><span class="c1"></span>	<span class="c1">// example, since it was created by a different tracer implementation).
</span><span class="c1"></span>	<span class="nx">ErrInvalidSpanContext</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: SpanContext type incompatible with tracer&#34;</span><span class="p">)</span>

	<span class="c1">// ErrInvalidCarrier errors occur when Tracer.Inject() or Tracer.Extract()
</span><span class="c1"></span>	<span class="c1">// implementations expect a different type of `carrier` than they are
</span><span class="c1"></span>	<span class="c1">// given.
</span><span class="c1"></span>	<span class="nx">ErrInvalidCarrier</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: Invalid Inject/Extract carrier&#34;</span><span class="p">)</span>

	<span class="c1">// ErrSpanContextCorrupted occurs when the `carrier` passed to
</span><span class="c1"></span>	<span class="c1">// Tracer.Extract() is of the expected type but is corrupted.
</span><span class="c1"></span>	<span class="nx">ErrSpanContextCorrupted</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;opentracing: SpanContext data corrupted in Extract carrier&#34;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-contextwithspan">func ContextWithSpan<a hidden class="anchor" aria-hidden="true" href="#func-contextwithspan">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ContextWithSpan</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">span</span> <span class="nx">Span</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
</code></pre></td></tr></table>
</div>
</div><p>ContextWithSpan返回一个新的“ context.Context”，其中包含对span的引用。如果span为nil，则返回没有活动span的新context。</p>
<h2 id="func-initglobaltracer">func InitGlobalTracer<a hidden class="anchor" aria-hidden="true" href="#func-initglobaltracer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InitGlobalTracer</span><span class="p">(</span><span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>不建议使用InitGlobalTracer。请使用SetGlobalTracer。</p>
<h2 id="func-isglobaltracerregistered">func IsGlobalTracerRegistered<a hidden class="anchor" aria-hidden="true" href="#func-isglobaltracerregistered">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsGlobalTracerRegistered</span><span class="p">()</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>IsGlobalTracerRegistered返回“bool”，以指示是否已全局注册跟踪器</p>
<h2 id="func-setglobaltracer">func SetGlobalTracer<a hidden class="anchor" aria-hidden="true" href="#func-setglobaltracer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SetGlobalTracer</span><span class="p">(</span><span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>SetGlobalTracer sets the [singleton] opentracing.Tracer returned by GlobalTracer(). Those who use GlobalTracer (rather than directly manage an opentracing.Tracer instance) should call SetGlobalTracer as early as possible in main(), prior to calling the <code>StartSpan</code> global func below. Prior to calling <code>SetGlobalTracer</code>, any Spans started via the <code>StartSpan</code> (etc) globals are noops.</p>
<p>SetGlobalTracer设置由GlobalTracer（）返回的单例opentracing.Tracer。那些使用GlobalTracer（而不是直接管理opentracing.Tracer实例）的用户应在main（）之前尽早调用SetGlobalTracer，然后再调用下面的<code>StartSpan</code>全局函数。在调用SetGlobalTracer之前，通过StartSpan等全局变量启动的所有Span都是noop。</p>
<h2 id="type-builtinformat">type BuiltinFormat<a hidden class="anchor" aria-hidden="true" href="#type-builtinformat">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BuiltinFormat</span> <span class="kt">byte</span>
</code></pre></td></tr></table>
</div>
</div><p>BuiltinFormat用于在“opentracing”包中划分与Tracer.Inject（）和Tracer.Extract（）方法一起使用的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// Binary represents SpanContexts as opaque binary data.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Inject(): the carrier must be an `io.Writer`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Extract(): the carrier must be an `io.Reader`.
</span><span class="c1"></span>	<span class="nx">Binary</span> <span class="nx">BuiltinFormat</span> <span class="p">=</span> <span class="kc">iota</span>

	<span class="c1">// TextMap represents SpanContexts as key:value string pairs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Unlike HTTPHeaders, the TextMap format does not restrict the key or
</span><span class="c1"></span>	<span class="c1">// value character sets in any way.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Inject(): the carrier must be a `TextMapWriter`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Extract(): the carrier must be a `TextMapReader`.
</span><span class="c1"></span>	<span class="nx">TextMap</span>

	<span class="c1">// HTTPHeaders represents SpanContexts as HTTP header string pairs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Unlike TextMap, the HTTPHeaders format requires that the keys and values
</span><span class="c1"></span>	<span class="c1">// be valid as HTTP headers as-is (i.e., character casing may be unstable
</span><span class="c1"></span>	<span class="c1">// and special characters are disallowed in keys, values should be
</span><span class="c1"></span>	<span class="c1">// URL-escaped, etc).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Inject(): the carrier must be a `TextMapWriter`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For Tracer.Extract(): the carrier must be a `TextMapReader`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See HTTPHeadersCarrier for an implementation of both TextMapWriter
</span><span class="c1"></span>	<span class="c1">// and TextMapReader that defers to an http.Header instance for storage.
</span><span class="c1"></span>	<span class="c1">// For example, Inject():
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//    err := span.Tracer().Inject(
</span><span class="c1"></span>	<span class="c1">//        span.Context(), opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Or Extract():
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//    clientContext, err := tracer.Extract(
</span><span class="c1"></span>	<span class="c1">//        opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">HTTPHeaders</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-finishoptions">type FinishOptions<a hidden class="anchor" aria-hidden="true" href="#type-finishoptions">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FinishOptions</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="c1">// FinishTime overrides the Span&#39;s finish time, or implicitly becomes
</span><span class="c1"></span>	<span class="c1">// time.Now() if FinishTime.IsZero().
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// FinishTime must resolve to a timestamp that&#39;s &gt;= the Span&#39;s StartTime
</span><span class="c1"></span>	<span class="c1">// (per StartSpanOptions).
</span><span class="c1"></span>	<span class="nx">FinishTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

	<span class="c1">// LogRecords allows the caller to specify the contents of many LogFields()
</span><span class="c1"></span>	<span class="c1">// calls with a single slice. May be nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// None of the LogRecord.Timestamp values may be .IsZero() (i.e., they must
</span><span class="c1"></span>	<span class="c1">// be set explicitly). Also, they must be &gt;= the Span&#39;s start timestamp and
</span><span class="c1"></span>	<span class="c1">// &lt;= the FinishTime (or time.Now() if FinishTime.IsZero()). Otherwise the
</span><span class="c1"></span>	<span class="c1">// behavior of FinishWithOptions() is undefined.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If specified, the caller hands off ownership of LogRecords at
</span><span class="c1"></span>	<span class="c1">// FinishWithOptions() invocation time.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If specified, the (deprecated) BulkLogData must be nil or empty.
</span><span class="c1"></span>	<span class="nx">LogRecords</span> <span class="p">[]</span><span class="nx">LogRecord</span>

	<span class="c1">// BulkLogData is DEPRECATED.
</span><span class="c1"></span>	<span class="nx">BulkLogData</span> <span class="p">[]</span><span class="nx">LogData</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>FinishOptions允许Span.FinishWithOptions调用方覆盖完成时间戳，并通过批量接口提供日志数据。</p>
<h2 id="type-httpheaderscarrier">type HTTPHeadersCarrier<a hidden class="anchor" aria-hidden="true" href="#type-httpheaderscarrier">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HTTPHeadersCarrier</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Header</span>
</code></pre></td></tr></table>
</div>
</div><p>HTTPHeadersCarrier同时满足TextMapWriter和TextMapReader。</p>
<p>服务器端用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">carrier</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">httpReq</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
<span class="nx">clientContext</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span> <span class="nx">carrier</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>客户端的用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">carrier</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">HTTPHeadersCarrier</span><span class="p">(</span><span class="nx">httpReq</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Inject</span><span class="p">(</span>
    <span class="nx">span</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span>
    <span class="nx">opentracing</span><span class="p">.</span><span class="nx">HTTPHeaders</span><span class="p">,</span>
    <span class="nx">carrier</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-httpheaderscarrier-foreachkey">func (HTTPHeadersCarrier) ForeachKey<a hidden class="anchor" aria-hidden="true" href="#func-httpheaderscarrier-foreachkey">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">HTTPHeadersCarrier</span><span class="p">)</span> <span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>ForeachKey符合TextMapReader接口。</p>
<h2 id="func-httpheaderscarrier-set">func (HTTPHeadersCarrier) Set<a hidden class="anchor" aria-hidden="true" href="#func-httpheaderscarrier-set">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">HTTPHeadersCarrier</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Set符合TextMapWriter接口。</p>
<h2 id="type-logdata">type LogData<a hidden class="anchor" aria-hidden="true" href="#type-logdata">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogData</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Timestamp</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">Event</span>     <span class="kt">string</span>
	<span class="nx">Payload</span>   <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LogData已弃用</p>
<h2 id="func-logdata-tologrecord">func (*LogData) ToLogRecord<a hidden class="anchor" aria-hidden="true" href="#func-logdata-tologrecord">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ld</span> <span class="o">*</span><span class="nx">LogData</span><span class="p">)</span> <span class="nf">ToLogRecord</span><span class="p">()</span> <span class="nx">LogRecord</span>
</code></pre></td></tr></table>
</div>
</div><p>ToLogRecord将不推荐使用的LogData转换为推荐使用的LogRecord</p>
<h2 id="type-logrecord">type LogRecord<a hidden class="anchor" aria-hidden="true" href="#type-logrecord">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LogRecord</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Timestamp</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">Fields</span>    <span class="p">[]</span><span class="nx">log</span><span class="p">.</span><span class="nx">Field</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LogRecord是与单个Span日志关联的数据。每个LogRecord实例必须至少指定一个字段。</p>
<h2 id="type-nooptracer">type NoopTracer<a hidden class="anchor" aria-hidden="true" href="#type-nooptracer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">NoopTracer</span> <span class="kd">struct</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>NoopTracer是Tracer的一个琐碎的，最小开销的实现，所有操作均禁止操作。</p>
<p>此实现的主要用途是在诸如RPC框架之类的库中，这些库使跟踪由最终用户控制的可选功能成为可能。无操作实现允许所述库将其用作默认跟踪程序，不需要编写继续检查跟踪程序实例是否为nil的工具。</p>
<p>出于相同的原因，NoopTracer是默认的“全局”跟踪器（请参阅GlobalTracer和SetGlobalTracer函数）。</p>
<p>警告：NoopTracer不支持baggage运输。</p>
<h2 id="func-nooptracer-extract">func (NoopTracer) Extract<a hidden class="anchor" aria-hidden="true" href="#func-nooptracer-extract">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">NoopTracer</span><span class="p">)</span> <span class="nf">Extract</span><span class="p">(</span><span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">SpanContext</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>提取属于Tracer接口。</p>
<h2 id="func-nooptracer-inject">func (NoopTracer) Inject<a hidden class="anchor" aria-hidden="true" href="#func-nooptracer-inject">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">NoopTracer</span><span class="p">)</span> <span class="nf">Inject</span><span class="p">(</span><span class="nx">sp</span> <span class="nx">SpanContext</span><span class="p">,</span> <span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>注入属于Tracer接口。</p>
<h2 id="func-nooptracer-startspan">func (NoopTracer) StartSpan<a hidden class="anchor" aria-hidden="true" href="#func-nooptracer-startspan">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">NoopTracer</span><span class="p">)</span> <span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpan属于Tracer接口。</p>
<h2 id="type-span">type Span<a hidden class="anchor" aria-hidden="true" href="#type-span">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Span</span> <span class="kd">interface</span> <span class="p">{</span>

<span class="c1">// Sets the end timestamp and finalizes Span state.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// With the exception of calls to Context() (which are always allowed),
</span><span class="c1"></span>	<span class="c1">// Finish() must be the last call made to any span instance, and to do
</span><span class="c1"></span>	<span class="c1">// otherwise leads to undefined behavior.
</span><span class="c1"></span>	<span class="nf">Finish</span><span class="p">()</span>
	<span class="c1">// FinishWithOptions is like Finish() but with explicit control over
</span><span class="c1"></span>	<span class="c1">// timestamps and log data.
</span><span class="c1"></span>	<span class="nf">FinishWithOptions</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">FinishOptions</span><span class="p">)</span>

	<span class="c1">// Context() yields the SpanContext for this Span. Note that the return
</span><span class="c1"></span>	<span class="c1">// value of Context() is still valid after a call to Span.Finish(), as is
</span><span class="c1"></span>	<span class="c1">// a call to Span.Context() after a call to Span.Finish().
</span><span class="c1"></span>	<span class="nf">Context</span><span class="p">()</span> <span class="nx">SpanContext</span>

	<span class="c1">// Sets or changes the operation name.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Returns a reference to this Span for chaining.
</span><span class="c1"></span>	<span class="nf">SetOperationName</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Adds a tag to the span.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If there is a pre-existing tag set for `key`, it is overwritten.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Tag values can be numeric types, strings, or bools. The behavior of
</span><span class="c1"></span>	<span class="c1">// other tag value types is undefined at the OpenTracing level. If a
</span><span class="c1"></span>	<span class="c1">// tracing system does not know how to handle a particular value type, it
</span><span class="c1"></span>	<span class="c1">// may ignore the tag, but shall not panic.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Returns a reference to this Span for chaining.
</span><span class="c1"></span>	<span class="nf">SetTag</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Span</span>

	<span class="c1">// LogFields is an efficient and type-checked way to record key:value
</span><span class="c1"></span>	<span class="c1">// logging data about a Span, though the programming interface is a little
</span><span class="c1"></span>	<span class="c1">// more verbose than LogKV(). Here&#39;s an example:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    span.LogFields(
</span><span class="c1"></span>	<span class="c1">//        log.String(&#34;event&#34;, &#34;soft error&#34;),
</span><span class="c1"></span>	<span class="c1">//        log.String(&#34;type&#34;, &#34;cache timeout&#34;),
</span><span class="c1"></span>	<span class="c1">//        log.Int(&#34;waited.millis&#34;, 1500))
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Also see Span.FinishWithOptions() and FinishOptions.BulkLogData.
</span><span class="c1"></span>	<span class="nf">LogFields</span><span class="p">(</span><span class="nx">fields</span> <span class="o">...</span><span class="nx">log</span><span class="p">.</span><span class="nx">Field</span><span class="p">)</span>

	<span class="c1">// LogKV is a concise, readable way to record key:value logging data about
</span><span class="c1"></span>	<span class="c1">// a Span, though unfortunately this also makes it less efficient and less
</span><span class="c1"></span>	<span class="c1">// type-safe than LogFields(). Here&#39;s an example:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    span.LogKV(
</span><span class="c1"></span>	<span class="c1">//        &#34;event&#34;, &#34;soft error&#34;,
</span><span class="c1"></span>	<span class="c1">//        &#34;type&#34;, &#34;cache timeout&#34;,
</span><span class="c1"></span>	<span class="c1">//        &#34;waited.millis&#34;, 1500)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For LogKV (as opposed to LogFields()), the parameters must appear as
</span><span class="c1"></span>	<span class="c1">// key-value pairs, like
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//    span.LogKV(key1, val1, key2, val2, key3, val3, ...)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The keys must all be strings. The values may be strings, numeric types,
</span><span class="c1"></span>	<span class="c1">// bools, Go error instances, or arbitrary structs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// (Note to implementors: consider the log.InterleavedKVToFields() helper)
</span><span class="c1"></span>	<span class="nf">LogKV</span><span class="p">(</span><span class="nx">alternatingKeyValues</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>

	<span class="c1">// SetBaggageItem sets a key:value pair on this Span and its SpanContext
</span><span class="c1"></span>	<span class="c1">// that also propagates to descendants of this Span.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// SetBaggageItem() enables powerful functionality given a full-stack
</span><span class="c1"></span>	<span class="c1">// opentracing integration (e.g., arbitrary application data from a mobile
</span><span class="c1"></span>	<span class="c1">// app can make it, transparently, all the way into the depths of a storage
</span><span class="c1"></span>	<span class="c1">// system), and with it some powerful costs: use this feature with care.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// IMPORTANT NOTE #1: SetBaggageItem() will only propagate baggage items to
</span><span class="c1"></span>	<span class="c1">// *future* causal descendants of the associated Span.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and
</span><span class="c1"></span>	<span class="c1">// value is copied into every local *and remote* child of the associated
</span><span class="c1"></span>	<span class="c1">// Span, and that can add up to a lot of network and cpu overhead.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Returns a reference to this Span for chaining.
</span><span class="c1"></span>	<span class="nf">SetBaggageItem</span><span class="p">(</span><span class="nx">restrictedKey</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Gets the value for a baggage item given its key. Returns the empty string
</span><span class="c1"></span>	<span class="c1">// if the value isn&#39;t found in this Span.
</span><span class="c1"></span>	<span class="nf">BaggageItem</span><span class="p">(</span><span class="nx">restrictedKey</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>

	<span class="c1">// Provides access to the Tracer that created this Span.
</span><span class="c1"></span>	<span class="nf">Tracer</span><span class="p">()</span> <span class="nx">Tracer</span>

	<span class="c1">// Deprecated: use LogFields or LogKV
</span><span class="c1"></span>	<span class="nf">LogEvent</span><span class="p">(</span><span class="nx">event</span> <span class="kt">string</span><span class="p">)</span>
	<span class="c1">// Deprecated: use LogFields or LogKV
</span><span class="c1"></span>	<span class="nf">LogEventWithPayload</span><span class="p">(</span><span class="nx">event</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">payload</span> <span class="kd">interface</span><span class="p">{})</span>
	<span class="c1">// Deprecated: use LogFields or LogKV
</span><span class="c1"></span>	<span class="nf">Log</span><span class="p">(</span><span class="nx">data</span> <span class="nx">LogData</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Span表示OpenTracing系统中活动的未完成的span。</p>
<p>Span由Tracer接口创建。</p>
<h2 id="func-spanfromcontext">func SpanFromContext<a hidden class="anchor" aria-hidden="true" href="#func-spanfromcontext">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SpanFromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>SpanFromContext返回以前与<code>ctx</code>关联的<code>Span</code>，如果找不到这样的<code>Span</code>，则返回nil。</p>
<p>注意：context.Context！= SpanContext：前者是Go的进程内上下文传播机制，后者是OpenTracing的每span标识和行李信息。</p>
<h2 id="func-startspan">func StartSpan<a hidden class="anchor" aria-hidden="true" href="#func-startspan">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpan遵循<code>Tracer.StartSpan</code>。参见<code>GlobalTracer（）</code>。</p>
<h2 id="func-startspanfromcontext">func StartSpanFromContext<a hidden class="anchor" aria-hidden="true" href="#func-startspanfromcontext">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpanFromContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Span</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanFromContext启动并返回带有“operationName”的Span，使用在“ctx”中找到的任何Span作为ChildOfRef。如果找不到此类父级，则StartSpanFromContext将创建一个根（无父级）span。</p>
<p>第二个返回值是围绕返回的Span构建的context.Context对象。</p>
<p>用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">SomeFunction</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sp</span><span class="p">,</span> <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">StartSpanFromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;SomeFunction&#34;</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">sp</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-startspanfromcontextwithtracer">func StartSpanFromContextWithTracer<a hidden class="anchor" aria-hidden="true" href="#func-startspanfromcontextwithtracer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpanFromContextWithTracer</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">tracer</span> <span class="nx">Tracer</span><span class="p">,</span> <span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">Span</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanFromContextWithTracer使用在context中找到的span作为ChildOfRef来启动并返回带有“ operationName”的span。如果不存在，则会创建一个根范围。它还返回一个context.Context对象，该对象围绕返回的范围构建。</p>
<p>它的行为与StartSpanFromContext相同，除了它使用显式跟踪程序而不是使用全局跟踪程序。</p>
<h2 id="type-spancontext">type SpanContext<a hidden class="anchor" aria-hidden="true" href="#type-spancontext">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SpanContext</span> <span class="kd">interface</span> <span class="p">{</span>

<span class="c1">// ForeachBaggageItem grants access to all baggage items stored in the
</span><span class="c1"></span>	<span class="c1">// SpanContext.
</span><span class="c1"></span>	<span class="c1">// The handler function will be called for each baggage key/value pair.
</span><span class="c1"></span>	<span class="c1">// The ordering of items is not guaranteed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The bool return value indicates if the handler wants to continue iterating
</span><span class="c1"></span>	<span class="c1">// through the rest of the baggage items; for example if the handler is trying to
</span><span class="c1"></span>	<span class="c1">// find some baggage item by pattern matching the name, it can return false
</span><span class="c1"></span>	<span class="c1">// as soon as the item is found to stop further iterations.
</span><span class="c1"></span>	<span class="nf">ForeachBaggageItem</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SpanContext表示必须传播到后代Span并跨越进程边界的Span状态（例如，<code>&lt;trace_id，span_id，sampled&gt;</code>元组）。</p>
<h2 id="type-spanreference">type SpanReference<a hidden class="anchor" aria-hidden="true" href="#type-spanreference">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SpanReference</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>              <span class="nx">SpanReferenceType</span>
	<span class="nx">ReferencedContext</span> <span class="nx">SpanContext</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>SpanReference是将SpanReferenceType和引用的SpanContext配对的StartSpanOption。有关受支持的关系，请参见SpanReferenceType文档。如果SpanReference是使用ReferencedContext == nil创建的，则无效。因此，它为开始span提供了更简洁的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sc</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">Extract</span><span class="p">(</span><span class="nx">someFormat</span><span class="p">,</span> <span class="nx">someCarrier</span><span class="p">)</span>
<span class="nx">span</span> <span class="o">:=</span> <span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;operation&#34;</span><span class="p">,</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nf">ChildOf</span><span class="p">(</span><span class="nx">sc</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>如果sc == nil，则上面的ChildOf（sc）选项不会惊慌，只会将父级span引用添加到选项中。</p>
<h2 id="func-childof">func ChildOf<a hidden class="anchor" aria-hidden="true" href="#func-childof">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChildOf</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">SpanContext</span><span class="p">)</span> <span class="nx">SpanReference</span>
</code></pre></td></tr></table>
</div>
</div><p>ChildOf返回一个StartSpanOption，它指向一个依赖的父范围。如果sc == nil，则该选项无效。</p>
<p>参见ChildOfRef，SpanReference</p>
<h2 id="func-followsfrom">func FollowsFrom<a hidden class="anchor" aria-hidden="true" href="#func-followsfrom">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">FollowsFrom</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">SpanContext</span><span class="p">)</span> <span class="nx">SpanReference</span>
</code></pre></td></tr></table>
</div>
</div><p>FollowsFrom返回一个StartSpanOption，它指向导致子Span的父Span，但不以任何方式直接取决于其结果。如果sc == nil，则该选项无效。</p>
<p>请参见FollowsFromRef，SpanReference</p>
<h2 id="func-spanreference-apply">func (SpanReference) Apply<a hidden class="anchor" aria-hidden="true" href="#func-spanreference-apply">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">SpanReference</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="type-spanreferencetype">type SpanReferenceType<a hidden class="anchor" aria-hidden="true" href="#type-spanreferencetype">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SpanReferenceType</span> <span class="kt">int</span>
</code></pre></td></tr></table>
</div>
</div><p>panReferenceType是一个枚举类型，描述了两个Span之间关系的不同类别。如果Span-2引用Span-1，则SpanReferenceType从Span-2的角度描述Span-1。例如，ChildOfRef表示Span-1创建了Span-2。</p>
<p>注意：Span-1和Span-2不一定*彼此依赖才能完成；例如，Span-2可能是Span-1排队的后台作业的一部分，或者Span-2可能坐在Span-1后面的分布式队列中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// ChildOfRef refers to a parent Span that caused *and* somehow depends
</span><span class="c1"></span>	<span class="c1">// upon the new child Span. Often (but not always), the parent Span cannot
</span><span class="c1"></span>	<span class="c1">// finish until the child Span does.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// An timing diagram for a ChildOfRef that&#39;s blocked on the new Span:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span---------]
</span><span class="c1"></span>	<span class="c1">//          [-Child Span----]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See &lt;http://opentracing.io/spec/&gt;
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See opentracing.ChildOf()
</span><span class="c1"></span>	<span class="nx">ChildOfRef</span> <span class="nx">SpanReferenceType</span> <span class="p">=</span> <span class="kc">iota</span>

	<span class="c1">// FollowsFromRef refers to a parent Span that does not depend in any way
</span><span class="c1"></span>	<span class="c1">// on the result of the new child Span. For instance, one might use
</span><span class="c1"></span>	<span class="c1">// FollowsFromRefs to describe pipeline stages separated by queues,
</span><span class="c1"></span>	<span class="c1">// or a fire-and-forget cache insert at the tail end of a web request.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A FollowsFromRef Span is part of the same logical trace as the new Span:
</span><span class="c1"></span>	<span class="c1">// i.e., the new Span is somehow caused by the work of its FollowsFromRef.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// All of the following could be valid timing diagrams for children that
</span><span class="c1"></span>	<span class="c1">// &#34;FollowFrom&#34; a parent.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span-]  [-Child Span-]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span--]
</span><span class="c1"></span>	<span class="c1">//      [-Child Span-]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     [-Parent Span-]
</span><span class="c1"></span>	<span class="c1">//                 [-Child Span-]
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See http://opentracing.io/spec/
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See opentracing.FollowsFrom()
</span><span class="c1"></span>	<span class="nx">FollowsFromRef</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-startspanoption">type StartSpanOption<a hidden class="anchor" aria-hidden="true" href="#type-startspanoption">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StartSpanOption</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Apply</span><span class="p">(</span><span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanOption实例（零个或多个）可以传递给Tracer.StartSpan。</p>
<p>根据<a href="http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis%EF%BC%8CStartSpanOption">http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis，StartSpanOption</a>借鉴了“功能选项”模式</p>
<h2 id="type-startspanoptions">type StartSpanOptions<a hidden class="anchor" aria-hidden="true" href="#type-startspanoptions">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StartSpanOptions</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Zero or more causal references to other Spans (via their SpanContext).
</span><span class="c1"></span>	<span class="c1">// If empty, start a &#34;root&#34; Span (i.e., start a new trace).
</span><span class="c1"></span>	<span class="nx">References</span> <span class="p">[]</span><span class="nx">SpanReference</span>

	<span class="c1">// StartTime overrides the Span&#39;s start time, or implicitly becomes
</span><span class="c1"></span>	<span class="c1">// time.Now() if StartTime.IsZero().
</span><span class="c1"></span>	<span class="nx">StartTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>

	<span class="c1">// Tags may have zero or more entries; the restrictions on map values are
</span><span class="c1"></span>	<span class="c1">// identical to those for Span.SetTag(). May be nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If specified, the caller hands off ownership of Tags at
</span><span class="c1"></span>	<span class="c1">// StartSpan() invocation time.
</span><span class="c1"></span>	<span class="nx">Tags</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StartSpanOptions允许Tracer.StartSpan（）调用者和实现者一种机制来覆盖开始时间戳，指定Span引用以及在Span开始时提供单个或多个Tag。</p>
<p>StartSpan（）调用者应查看此包中可用的StartSpanOption接口和实现。</p>
<p>跟踪程序的实现可以将StartSpanOption实例的一部分转换为StartSpanOptions结构，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StartSpan</span><span class="p">(</span><span class="nx">opName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">opentracing</span><span class="p">.</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sso</span> <span class="o">:=</span> <span class="nx">opentracing</span><span class="p">.</span><span class="nx">StartSpanOptions</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nx">o</span><span class="p">.</span><span class="nf">Apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sso</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="type-starttime">type StartTime<a hidden class="anchor" aria-hidden="true" href="#type-starttime">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StartTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</code></pre></td></tr></table>
</div>
</div><p>StartTime是一个StartSpanOption，它为新Span设置了明确的开始时间戳。</p>
<h2 id="func-starttime-apply">func (StartTime) Apply<a hidden class="anchor" aria-hidden="true" href="#func-starttime-apply">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">StartTime</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="type-tag">type Tag<a hidden class="anchor" aria-hidden="true" href="#type-tag">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tag</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Key</span>   <span class="kt">string</span>
	<span class="nx">Value</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>标记可以作为StartSpanOption传递，以将标记添加到新的span，或者可以使用其Set方法将标记应用于现有Span，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tracer</span><span class="p">.</span><span class="nf">StartSpan</span><span class="p">(</span><span class="s">&#34;opName&#34;</span><span class="p">,</span> <span class="nx">Tag</span><span class="p">{</span><span class="s">&#34;Key&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Tag</span><span class="p">{</span><span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">}.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="func-tag-apply">func (Tag) Apply<a hidden class="anchor" aria-hidden="true" href="#func-tag-apply">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Tag</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="func-tag-set">func (Tag) Set<a hidden class="anchor" aria-hidden="true" href="#func-tag-set">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Tag</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Span</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Set将标签应用于现有的Span。</p>
<h2 id="type-tags">type Tags<a hidden class="anchor" aria-hidden="true" href="#type-tags">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tags</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>标签是从任意字符串键到不透明值类型的通用映射。基础跟踪系统负责解释和序列化值。</p>
<h2 id="func-tags-apply">func (Tags) Apply<a hidden class="anchor" aria-hidden="true" href="#func-tags-apply">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Tags</span><span class="p">)</span> <span class="nf">Apply</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">StartSpanOptions</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Apply 满足StartSpanOption接口.</p>
<h2 id="type-textmapcarrier">type TextMapCarrier<a hidden class="anchor" aria-hidden="true" href="#type-textmapcarrier">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TextMapCarrier</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>TextMapCarrier允许将常规<code>map[string]string</code>用作TextMapWriter和TextMapReader。</p>
<h2 id="func-textmapcarrier-foreachkey">func (TextMapCarrier) ForeachKey<a hidden class="anchor" aria-hidden="true" href="#func-textmapcarrier-foreachkey">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">TextMapCarrier</span><span class="p">)</span> <span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>ForeachKey符合TextMapReader接口。</p>
<h2 id="func-textmapcarrier-set">func (TextMapCarrier) Set<a hidden class="anchor" aria-hidden="true" href="#func-textmapcarrier-set">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">TextMapCarrier</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Set实现opentracing.TextMapWriter的Set（）</p>
<h2 id="type-textmapreader">type TextMapReader<a hidden class="anchor" aria-hidden="true" href="#type-textmapreader">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TextMapReader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// ForeachKey returns TextMap contents via repeated calls to the `handler`
</span><span class="c1"></span>	<span class="c1">// function. If any call to `handler` returns a non-nil error, ForeachKey
</span><span class="c1"></span>	<span class="c1">// terminates and returns that error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: The backing store for the TextMapReader may contain data unrelated
</span><span class="c1"></span>	<span class="c1">// to SpanContext. As such, Inject() and Extract() implementations that
</span><span class="c1"></span>	<span class="c1">// call the TextMapWriter and TextMapReader interfaces must agree on a
</span><span class="c1"></span>	<span class="c1">// prefix or other convention to distinguish their own key:value pairs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The &#34;foreach&#34; callback pattern reduces unnecessary copying in some cases
</span><span class="c1"></span>	<span class="c1">// and also allows implementations to hold locks while the map is read.
</span><span class="c1"></span>	<span class="nf">ForeachKey</span><span class="p">(</span><span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TextMapReader是TextMap内置格式的Extract（）载体。使用它，调用方可以将传播的SpanContext解码为unicode字符串映射中的条目。</p>
<h2 id="type-textmapwriter">type TextMapWriter<a hidden class="anchor" aria-hidden="true" href="#type-textmapwriter">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TextMapWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Set a key:value pair to the carrier. Multiple calls to Set() for the
</span><span class="c1"></span>	<span class="c1">// same key leads to undefined behavior.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: The backing store for the TextMapWriter may contain data unrelated
</span><span class="c1"></span>	<span class="c1">// to SpanContext. As such, Inject() and Extract() implementations that
</span><span class="c1"></span>	<span class="c1">// call the TextMapWriter and TextMapReader interfaces must agree on a
</span><span class="c1"></span>	<span class="c1">// prefix or other convention to distinguish their own key:value pairs.
</span><span class="c1"></span>	<span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TextMapWriter是TextMap内置格式的Inject（）载体。有了它，调用者可以对SpanContext进行编码，以作为unicode字符串映射中的条目传播。</p>
<h2 id="type-tracer">type Tracer<a hidden class="anchor" aria-hidden="true" href="#type-tracer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tracer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Create, start, and return a new Span with the given `operationName` and
</span><span class="c1"></span>	<span class="c1">// incorporate the given StartSpanOption `opts`. (Note that `opts` borrows
</span><span class="c1"></span>	<span class="c1">// from the &#34;functional options&#34; pattern, per
</span><span class="c1"></span>	<span class="c1">// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// A Span with no SpanReference options (e.g., opentracing.ChildOf() or
</span><span class="c1"></span>	<span class="c1">// opentracing.FollowsFrom()) becomes the root of its own trace.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Examples:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     var tracer opentracing.Tracer = ...
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // The root-span case:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(&#34;GetFeed&#34;)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // The vanilla child span case:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//         &#34;GetFeed&#34;,
</span><span class="c1"></span>	<span class="c1">//         opentracing.ChildOf(parentSpan.Context()))
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // All the bells and whistles:
</span><span class="c1"></span>	<span class="c1">//     sp := tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//         &#34;GetFeed&#34;,
</span><span class="c1"></span>	<span class="c1">//         opentracing.ChildOf(parentSpan.Context()),
</span><span class="c1"></span>	<span class="c1">//         opentracing.Tag{&#34;user_agent&#34;, loggedReq.UserAgent},
</span><span class="c1"></span>	<span class="c1">//         opentracing.StartTime(loggedReq.Timestamp),
</span><span class="c1"></span>	<span class="c1">//     )
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">StartSpan</span><span class="p">(</span><span class="nx">operationName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">StartSpanOption</span><span class="p">)</span> <span class="nx">Span</span>

	<span class="c1">// Inject() takes the `sm` SpanContext instance and injects it for
</span><span class="c1"></span>	<span class="c1">// propagation within `carrier`. The actual type of `carrier` depends on
</span><span class="c1"></span>	<span class="c1">// the value of `format`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// OpenTracing defines a common set of `format` values (see BuiltinFormat),
</span><span class="c1"></span>	<span class="c1">// and each has an expected carrier type.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Other packages may declare their own `format` values, much like the keys
</span><span class="c1"></span>	<span class="c1">// used by `context.Context` (see https://godoc.org/context#WithValue).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Example usage (sans error handling):
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//     err := tracer.Inject(
</span><span class="c1"></span>	<span class="c1">//         span.Context(),
</span><span class="c1"></span>	<span class="c1">//         opentracing.HTTPHeaders,
</span><span class="c1"></span>	<span class="c1">//         carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: All opentracing.Tracer implementations MUST support all
</span><span class="c1"></span>	<span class="c1">// BuiltinFormats.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Implementations may return opentracing.ErrUnsupportedFormat if `format`
</span><span class="c1"></span>	<span class="c1">// is not supported by (or not known by) the implementation.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Implementations may return opentracing.ErrInvalidCarrier or any other
</span><span class="c1"></span>	<span class="c1">// implementation-specific error if the format is supported but injection
</span><span class="c1"></span>	<span class="c1">// fails anyway.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See Tracer.Extract().
</span><span class="c1"></span>	<span class="nf">Inject</span><span class="p">(</span><span class="nx">sm</span> <span class="nx">SpanContext</span><span class="p">,</span> <span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>

	<span class="c1">// Extract() returns a SpanContext instance given `format` and `carrier`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// OpenTracing defines a common set of `format` values (see BuiltinFormat),
</span><span class="c1"></span>	<span class="c1">// and each has an expected carrier type.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Other packages may declare their own `format` values, much like the keys
</span><span class="c1"></span>	<span class="c1">// used by `context.Context` (see
</span><span class="c1"></span>	<span class="c1">// https://godoc.org/golang.org/x/net/context#WithValue).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Example usage (with StartSpan):
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)
</span><span class="c1"></span>	<span class="c1">//     clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//     // ... assuming the ultimate goal here is to resume the trace with a
</span><span class="c1"></span>	<span class="c1">//     // server-side Span:
</span><span class="c1"></span>	<span class="c1">//     var serverSpan opentracing.Span
</span><span class="c1"></span>	<span class="c1">//     if err == nil {
</span><span class="c1"></span>	<span class="c1">//         span = tracer.StartSpan(
</span><span class="c1"></span>	<span class="c1">//             rpcMethodName, ext.RPCServerOption(clientContext))
</span><span class="c1"></span>	<span class="c1">//     } else {
</span><span class="c1"></span>	<span class="c1">//         span = tracer.StartSpan(rpcMethodName)
</span><span class="c1"></span>	<span class="c1">//     }
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// NOTE: All opentracing.Tracer implementations MUST support all
</span><span class="c1"></span>	<span class="c1">// BuiltinFormats.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Return values:
</span><span class="c1"></span>	<span class="c1">//  - A successful Extract returns a SpanContext instance and a nil error
</span><span class="c1"></span>	<span class="c1">//  - If there was simply no SpanContext to extract in `carrier`, Extract()
</span><span class="c1"></span>	<span class="c1">//    returns (nil, opentracing.ErrSpanContextNotFound)
</span><span class="c1"></span>	<span class="c1">//  - If `format` is unsupported or unrecognized, Extract() returns (nil,
</span><span class="c1"></span>	<span class="c1">//    opentracing.ErrUnsupportedFormat)
</span><span class="c1"></span>	<span class="c1">//  - If there are more fundamental problems with the `carrier` object,
</span><span class="c1"></span>	<span class="c1">//    Extract() may return opentracing.ErrInvalidCarrier,
</span><span class="c1"></span>	<span class="c1">//    opentracing.ErrSpanContextCorrupted, or implementation-specific
</span><span class="c1"></span>	<span class="c1">//    errors.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// See Tracer.Inject().
</span><span class="c1"></span>	<span class="nf">Extract</span><span class="p">(</span><span class="nx">format</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">carrier</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">SpanContext</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Tracer是用于Span创建和SpanContext传播的简单的接口。</p>
<h2 id="func-globaltracer">func GlobalTracer<a hidden class="anchor" aria-hidden="true" href="#func-globaltracer">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GlobalTracer</span><span class="p">()</span> <span class="nx">Tracer</span>
</code></pre></td></tr></table>
</div>
</div><p>GlobalTracer返回全局单例“Tracer”实现。在调用SetGlobalTracer（）之前，GlobalTracer（）是一个noop实现，它将丢弃传递给它的所有数据。</p>
<h2 id="type-tracercontextwithspanextension">type TracerContextWithSpanExtension<a hidden class="anchor" aria-hidden="true" href="#type-tracercontextwithspanextension">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TracerContextWithSpanExtension</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// ContextWithSpanHook gets called by the ContextWithSpan
</span><span class="c1"></span>	<span class="c1">// function, when the Tracer implementation also implements
</span><span class="c1"></span>	<span class="c1">// this interface. It allows to put extra information into the
</span><span class="c1"></span>	<span class="c1">// context and make it available to the callers of the
</span><span class="c1"></span>	<span class="c1">// ContextWithSpan.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This hook is invoked before the ContextWithSpan function
</span><span class="c1"></span>	<span class="c1">// actually puts the span into the context.
</span><span class="c1"></span>	<span class="nf">ContextWithSpanHook</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">span</span> <span class="nx">Span</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>TracerContextWithSpanExtension是Tracer接口的实现可能想要实现的扩展接口。当调用ContextWithSpan时，它可以对go上下文进行一些控制。</p>
<p>此扩展的主要目的是从opentracing API到其他一些跟踪API的适配器。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/opentracing/">opentracing</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
