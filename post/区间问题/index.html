<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>区间问题 | Forz Blog</title>
<meta name="keywords" content="Binary Search, STL, Heap" />
<meta name="description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="区间问题" />
<meta property="og:description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T22:07:55&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T22:07:55&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="区间问题"/>
<meta name="twitter:description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "区间问题",
      "item": "/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "区间问题",
  "name": "区间问题",
  "description": "LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-\u0026gt;2”,”4-\u0026gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别",
  "keywords": [
    "Binary Search", "STL", "Heap"
  ],
  "articleBody": "LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges.\nFor example, given [0,1,2,4,5,7], return [“0-2”,”4-5”,”7”].\n解析：\n将一组数划分成若干的区间，用双指针分别代表区间的起点和终点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution { public: vectorstring summaryRanges(vectorint\u0026 nums) { vectorstring result; if(!nums.size()) return result; int low = nums[0], high = nums[0];//初始双指针重合 for(int i = 1; i  nums.size(); i++){ if (nums[i] == high + 1)//high指针继续往下走  high++; else{//输出  result.push_back(low == high ? to_string(low) : to_string(low) + \"-\" + to_string(high)); low = high = nums[i];//更新low指针  } } result.push_back(low == high ? to_string(low) : to_string(low) + \"-\" + to_string(high)); //最后一个区间或数 return result; } };   LeetCode 56. Merge Intervals Given a collection of intervals, merge all overlapping intervals.\nFor example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].\n解析：合并区间问题，先把区间按照起点排序，如果当前区间的终点比后继区间的起点大，那么需要合并区间，起点不变，选择当前区间的终点和后继区间的终点两者之间的最大值作为新的区间的终点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public: bool comp(const Interval \u0026a, const Interval \u0026b) {//区间按照起点排序  return (a.start  b.start); } vectorInterval merge(vectorInterval \u0026intervals) { vectorInterval res; if (intervals.empty()) return res; sort(intervals.begin(), intervals.end(), comp); res.push_back(intervals[0]); for (int i = 1; i  intervals.size(); ++i) { if (res.back().end = intervals[i].start) {//合并区间  res.back().end = max(res.back().end, intervals[i].end); } else { res.push_back(intervals[i]); } } return res; } };   LeetCode 57. Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\nExample 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2], [3,10],[12,16].\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\n解析：\n该区间集合已经按起点排序。插入一个区间到区间集合中。本题不保证必定出现区间合并。 设l=-1，r=n。 整个区间集合可以分为三部分：\n 终点比新区间起点小的区间 （0~l） 和新区间合并的区间（可以没有） 起点比新区间终点大的区间（r~n-1）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* Definition for an interval. struct Interval { int start; int end; Interval() : start(0), end(0) {} Interval(int s, int e) : start(s), end(e) {} }; */ class Solution { public: vector insert(vector\u0026 intervals, Interval newInterval) { int n = intervals.size(); // 计算参与合并的区间范围 int l = -1, r = n; //直到新区间的起点小于等于l+1区间的终点，新区间可以合并该区间，成为新的l+1区间 while (l  n - 1 \u0026\u0026 intervals[l + 1].end  newInterval.start) l ++; //直到新区间的终点大于等于r-1区间的起点，新区间可以合并该区间，成为新的r-1区间 while (r  0 \u0026\u0026 intervals[r - 1].start  newInterval.end) r –; //如果找到能够进行合并的区间的话，将区间合并到新区间 if (r  0) newInterval.end = max(newInterval.end, intervals[r - 1].end); if (l  n - 1) newInterval.start = min(newInterval.start, intervals[l + 1].start); vector ans; for (int i = 0; i  l; i++) ans.push_back(intervals[i]); ans.push_back(newInterval);//放入新区间 for (int i = r; i  n-1; i++) ans.push_back(intervals[i]); return ans; } };   LeetCode 495. Teemo Attacking In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.\nYou may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\nExample 1: Input: [1,4], 2.\nOutput: 4.\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\nExample 2: Input: [1,2], 2.\nOutput: 3.\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won’t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\nNote:\nYou may assume the length of given time series array won’t exceed 10000.\nYou may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.\n解析：给出了每个区间的起点和所有区间的长度，求区间有效长度（空位不算）。如果长度为0，输出-1。扫描数组，计算当前区间的终点，计算该区间增加的有效长度（当前终点减上一个终点）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public: int findPoisonedDuration(vectorint\u0026 timeSeries, int duration) { int result = 0, oldEnd = -1; for (int i = 0; i  timeSeries.size(); i++) { int newEnd = timeSeries[i] + duration - 1; if (newEnd  oldEnd) { result += min(duration, newEnd - oldEnd); oldEnd = newEnd; } } return result; } };   LeetCode 436. Find Right Interval Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.\nFor any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\nNote:\nYou may assume the interval’s end point is always bigger than its start point.\nYou may assume none of these intervals have the same start point.\nExample 1:\nInput: [ [1,2] ]\nOutput: [-1]\nExplanation: There is only one interval in the collection, so it outputs -1.\nExample 2:\nInput: [ [3,4], [2,3], [1,2] ]\nOutput: [-1, 0, 1]\nExplanation: There is no satisfied “right” interval for [3,4]. For [2,3], the interval [3,4] has minimum-“right” start point; For [1,2], the interval [2,3] has minimum-“right” start point.\nExample 3:\nInput: [ [1,4], [2,3], [3,4] ] Output: [-1, 2, -1].\nExplanation: There is no satisfied “right” interval for [1,4] and [3,4]. For [2,3], the interval [3,4] has minimum-“right” start point.\n解析：\n这个题目的意思是：给定一系列的区间，对于任意一个区间，在所有区间中找到一个区间的起始点大于等于当前区间的结束点，并且要求这两个点最接近。\n用哈希表保存区间的起点和对应的区间号，然后枚举每个区间，在哈希表中查找终点大于等于该区间终点的迭代器。\n因为要求两个区间最接近，所以哈希表使用map，自带排序功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public: vectorint findRightInterval(vectorInterval\u0026 intervals) { mapint, int hash;//利用map给区间起点排序。  vectorint res; int n = intervals.size(); for (int i = 0; i  n; ++i)//记录区间起点所属的区间  hash[intervals[i].start] = i; for (auto in : intervals) { auto itr = hash.lower_bound(in.end); if (itr == hash.end()) res.push_back(-1);//如果找不到，返回-1  else res.push_back(itr-second);//找到的话，加入结果  } return res; } };   LeetCode 352. Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, …, an, …, summarize the numbers seen so far as a list of disjoint intervals.\nFor example, suppose the integers from the data stream are 1, 3, 7, 2, 6, …, then the summary will be:\n[1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7]  Follow up:\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream’s size?\n解析：\n如果合并的操作非常多但是最后区间可能很少, 这种情况下不适合直接用vector, 因为他的合并操作需要移位,故时间复杂度是O(n), 频繁的移位会造成时间复杂度大大增加. 一个更好的解决办法是使用set, 因为二叉搜索树插入查找都可以在O(log n)完成, 只需要在返回结果的时候将set中的值放到vector中即可.\nif(it != st.begin() \u0026\u0026 (--it)-end+1  这是一个技巧，set迭代器支持自加自减，但不支持随机访问，所以不能用it-1，这个语句其实表达的意思和下面的语句相同，但下面的语句无法通过编译。\nif(it != st.begin() \u0026\u0026 (it-1)-end+1 = val) it--;  如果符合条件，就it++，将it之前减的补回来，如果不符合条件，it-1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class SummaryRanges { public: /** Initialize your data structure here. */ void addNum(int val) { auto it = st.lower_bound(Interval(val, val));//找到第一个大于等于要插入的值的区间  int start = val, end = val; //当前要插入的值可能会正好等于上个区间的end+1, 所以要考虑前一个区间。  if(it != st.begin() \u0026\u0026 (--it)-end+1  val) it++; while(it != st.end() \u0026\u0026 val+1 = it-start \u0026\u0026 val-1  it-end)//如果找到了it，并且it可以将val吞并  { start = min(start, it-start);//新区间的起点和终点  end = max(end, it-end); it = st.erase(it); //将it删除，并返回迭代器，该迭代器指向被删除元素后面的元素  } st.insert(it,Interval(start, end));//插入新区间 } vectorInterval getIntervals() {//输出结果  vectorInterval result; for(auto val: st) result.push_back(val); return result; } private: struct Cmp{//仿函数，使set中元素按照起点升序排列  bool operator()(Interval a, Interval b){ return a.start  b.start; } }; setInterval, Cmp st; }; /** * Your SummaryRanges object will be instantiated and called as such: * SummaryRanges obj = new SummaryRanges(); * obj.addNum(val); * vector param_2 = obj.getIntervals(); */   ",
  "wordCount" : "2885",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T22:07:55Z",
  "dateModified": "2017-06-24T22:07:55Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      区间问题
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-228-summary-ranges">LeetCode 228. Summary Ranges<a hidden class="anchor" aria-hidden="true" href="#leetcode-228-summary-ranges">#</a></h1>
<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<p>解析：</p>
<p>将一组数划分成若干的区间，用双指针分别代表区间的起点和终点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">summaryRanges</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//初始双指针重合
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="c1">//high指针继续往下走
</span><span class="c1"></span>        <span class="n">high</span><span class="o">++</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span><span class="c1">//输出
</span><span class="c1"></span>        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">low</span> <span class="o">==</span> <span class="n">high</span> <span class="o">?</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">:</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">high</span><span class="p">));</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//更新low指针
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">low</span> <span class="o">==</span> <span class="n">high</span> <span class="o">?</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">:</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">high</span><span class="p">));</span>        <span class="c1">//最后一个区间或数
</span><span class="c1"></span><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-56-merge-intervals">LeetCode 56. Merge Intervals<a hidden class="anchor" aria-hidden="true" href="#leetcode-56-merge-intervals">#</a></h1>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example, <br>
Given [1,3],[2,6],[8,10],[15,18], <br>
return [1,6],[8,10],[15,18].</p>
<p>解析：合并区间问题，先把区间按照起点排序，如果当前区间的终点比后继区间的起点大，那么需要合并区间，起点不变，选择当前区间的终点和后继区间的终点两者之间的最大值作为新的区间的终点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for an interval.
</span><span class="cm"> * struct Interval {
</span><span class="cm"> *     int start;
</span><span class="cm"> *     int end;
</span><span class="cm"> *     Interval() : start(0), end(0) {}
</span><span class="cm"> *     Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Interval</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Interval</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="c1">//区间按照起点排序
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">intervals</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span><span class="c1">//合并区间
</span><span class="c1"></span>            <span class="n">res</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">end</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-57-insert-interval">LeetCode 57. Insert Interval<a hidden class="anchor" aria-hidden="true" href="#leetcode-57-insert-interval">#</a></h1>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2], [3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<p>解析：</p>
<p>该区间集合已经按起点排序。插入一个区间到区间集合中。本题不保证必定出现区间合并。
设l=-1，r=n。
整个区间集合可以分为三部分：</p>
<ol>
<li>终点比新区间起点小的区间 （0~l）</li>
<li>和新区间合并的区间（可以没有）</li>
<li>起点比新区间终点大的区间（r~n-1）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">
</span><span class="cm">Definition for an interval.
</span><span class="cm">struct Interval {
</span><span class="cm">int start;
</span><span class="cm">int end;
</span><span class="cm">Interval() : start(0), end(0) {}
</span><span class="cm">Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span> <span class="n">insert</span><span class="p">(</span><span class="n">vector</span><span class="o">&amp;</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">Interval</span> <span class="n">newInterval</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="c1">// 计算参与合并的区间范围
</span><span class="c1"></span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="c1">//直到新区间的起点小于等于l+1区间的终点，新区间可以合并该区间，成为新的l+1区间
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="n">l</span> <span class="o">++</span><span class="p">;</span>
<span class="c1">//直到新区间的终点大于等于r-1区间的起点，新区间可以合并该区间，成为新的r-1区间
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">end</span><span class="p">)</span> <span class="n">r</span> <span class="err">–</span><span class="p">;</span>
<span class="c1">//如果找到能够进行合并的区间的话，将区间合并到新区间
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">newInterval</span><span class="p">.</span><span class="n">end</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">newInterval</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">start</span><span class="p">);</span>
<span class="n">vector</span> <span class="n">ans</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newInterval</span><span class="p">);</span><span class="c1">//放入新区间
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-495-teemo-attacking">LeetCode 495. Teemo Attacking<a hidden class="anchor" aria-hidden="true" href="#leetcode-495-teemo-attacking">#</a></h1>
<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p>
<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>
<p>Example 1: <br>
Input: [1,4], 2.<br>
Output: 4.<br>
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. <br>
This poisoned status will last 2 seconds until the end of time point 2. <br>
And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. <br>
So you finally need to output 4.</p>
<p>Example 2: <br>
Input: [1,2], 2.<br>
Output: 3.<br>
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. <br>
This poisoned status will last 2 seconds until the end of time point 2. <br>
However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.
Since the poisoned status won’t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. <br>
So you finally need to output 3.</p>
<p>Note:</p>
<p>You may assume the length of given time series array won’t exceed 10000.</p>
<p>You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</p>
<p>解析：给出了每个区间的起点和所有区间的长度，求区间有效长度（空位不算）。如果长度为0，输出-1。扫描数组，计算当前区间的终点，计算该区间增加的有效长度（当前终点减上一个终点）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">findPoisonedDuration</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">timeSeries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oldEnd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeSeries</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">newEnd</span> <span class="o">=</span> <span class="n">timeSeries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newEnd</span> <span class="o">&gt;</span> <span class="n">oldEnd</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">newEnd</span> <span class="o">-</span> <span class="n">oldEnd</span><span class="p">);</span>
            <span class="n">oldEnd</span> <span class="o">=</span> <span class="n">newEnd</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-436-find-right-interval">LeetCode 436. Find Right Interval<a hidden class="anchor" aria-hidden="true" href="#leetcode-436-find-right-interval">#</a></h1>
<p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.</p>
<p>For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p>
<p>Note:</p>
<p>You may assume the interval’s end point is always bigger than its start point.</p>
<p>You may assume none of these intervals have the same start point.</p>
<p>Example 1:</p>
<p>Input: [ [1,2] ]</p>
<p>Output: [-1]</p>
<p>Explanation: There is only one interval in the collection, so it outputs -1.</p>
<p>Example 2:</p>
<p>Input: [ [3,4], [2,3], [1,2] ]</p>
<p>Output: [-1, 0, 1]</p>
<p>Explanation: There is no satisfied “right” interval for [3,4].
For [2,3], the interval [3,4] has minimum-“right” start point;
For [1,2], the interval [2,3] has minimum-“right” start point.</p>
<p>Example 3:</p>
<p>Input: [ [1,4], [2,3], [3,4] ]       <br>
Output: [-1, 2, -1].</p>
<p>Explanation: There is no satisfied “right” interval for [1,4] and [3,4]. <br>
For [2,3], the interval [3,4] has minimum-“right” start point.</p>
<p>解析：</p>
<p>这个题目的意思是：给定一系列的区间，对于任意一个区间，在所有区间中找到一个区间的起始点大于等于当前区间的结束点，并且要求这两个点最接近。</p>
<p>用哈希表保存区间的起点和对应的区间号，然后枚举每个区间，在哈希表中查找终点大于等于该区间终点的迭代器。</p>
<p>因为要求两个区间最接近，所以哈希表使用map，自带排序功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for an interval.
</span><span class="cm"> * struct Interval {
</span><span class="cm"> *     int start;
</span><span class="cm"> *     int end;
</span><span class="cm"> *     Interval() : start(0), end(0) {}
</span><span class="cm"> *     Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findRightInterval</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;&amp;</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span><span class="c1">//利用map给区间起点排序。
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//记录区间起点所属的区间
</span><span class="c1"></span>        <span class="n">hash</span><span class="p">[</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">in</span> <span class="p">:</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">hash</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">itr</span> <span class="o">==</span> <span class="n">hash</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//如果找不到，返回-1
</span><span class="c1"></span>        <span class="k">else</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">itr</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span><span class="c1">//找到的话，加入结果
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-352-data-stream-as-disjoint-intervals">LeetCode 352. Data Stream as Disjoint Intervals<a hidden class="anchor" aria-hidden="true" href="#leetcode-352-data-stream-as-disjoint-intervals">#</a></h1>
<p>Given a data stream input of non-negative integers a1, a2, …, an, …, summarize the numbers seen so far as a list of disjoint intervals.</p>
<p>For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, …, then the summary will be:</p>
<pre><code>[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]
</code></pre>
<p>Follow up:</p>
<p>What if there are lots of merges and the number of disjoint intervals are small compared to the data stream’s size?</p>
<p>解析：</p>
<p>如果合并的操作非常多但是最后区间可能很少, 这种情况下不适合直接用vector, 因为他的合并操作需要移位,故时间复杂度是O(n), 频繁的移位会造成时间复杂度大大增加. 一个更好的解决办法是使用set, 因为二叉搜索树插入查找都可以在O(log n)完成, 只需要在返回结果的时候将set中的值放到vector中即可.</p>
<pre><code>if(it != st.begin() &amp;&amp; (--it)-&gt;end+1 &lt; val) it++;
</code></pre>
<p>这是一个技巧，set迭代器支持自加自减，但不支持随机访问，所以不能用it-1，这个语句其实表达的意思和下面的语句相同，但下面的语句无法通过编译。</p>
<pre><code>if(it != st.begin() &amp;&amp; (it-1)-&gt;end+1 &gt;= val) it--; 
</code></pre>
<p>如果符合条件，就it++，将it之前减的补回来，如果不符合条件，it-1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for an interval.
</span><span class="cm"> * struct Interval {
</span><span class="cm"> *     int start;
</span><span class="cm"> *     int end;
</span><span class="cm"> *     Interval() : start(0), end(0) {}
</span><span class="cm"> *     Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">SummaryRanges</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="cm">/** Initialize your data structure here. */</span>
<span class="kt">void</span> <span class="n">addNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span><span class="c1">//找到第一个大于等于要插入的值的区间
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="c1">//当前要插入的值可能会正好等于上个区间的end+1, 所以要考虑前一个区间。
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">st</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">--</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">st</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span><span class="c1">//如果找到了it，并且it可以将val吞并
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span><span class="c1">//新区间的起点和终点
</span><span class="c1"></span>        <span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="c1">//将it删除，并返回迭代器，该迭代器指向被删除元素后面的元素
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">st</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">Interval</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">));</span><span class="c1">//插入新区间
</span><span class="c1"></span><span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">getIntervals</span><span class="p">()</span> <span class="p">{</span><span class="c1">//输出结果
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">st</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="k">struct</span> <span class="n">Cmp</span><span class="p">{</span><span class="c1">//仿函数，使set中元素按照起点升序排列
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="n">Interval</span> <span class="n">a</span><span class="p">,</span> <span class="n">Interval</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">start</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">Interval</span><span class="p">,</span> <span class="n">Cmp</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/**
</span><span class="cm"> * Your SummaryRanges object will be instantiated and called as such:
</span><span class="cm"> * SummaryRanges obj = new SummaryRanges();
</span><span class="cm"> * obj.addNum(val);
</span><span class="cm"> * vector&lt;Interval&gt; param_2 = obj.getIntervals();
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/binary-search/">Binary Search</a></li>
      <li><a href="/tags/stl/">STL</a></li>
      <li><a href="/tags/heap/">heap</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
