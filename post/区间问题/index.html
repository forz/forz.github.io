<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>区间问题 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&amp;gt;2”,”4-&amp;gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.0 with theme even" />


<link rel="canonical" href="/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="区间问题" />
<meta property="og:description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T22:07:55+00:00" />
<meta property="article:modified_time" content="2017-06-24T22:07:55+00:00" />

<meta itemprop="name" content="区间问题">
<meta itemprop="description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别"><meta itemprop="datePublished" content="2017-06-24T22:07:55+00:00" />
<meta itemprop="dateModified" content="2017-06-24T22:07:55+00:00" />
<meta itemprop="wordCount" content="2885">
<meta itemprop="keywords" content="Binary Search,STL,Heap," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="区间问题"/>
<meta name="twitter:description" content="LeetCode 228. Summary Ranges Given a sorted integer array without duplicates, return the summary of its ranges. For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”]. 解析： 将一组数划分成若干的区间，用双指针分别"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">区间问题</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-06-24 </span>
        <div class="post-category">
            <a href="/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"> 解题报告 </a>
            </div>
          <span class="more-meta"> 约 2885 字 </span>
          <span class="more-meta"> 预计阅读 6 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="leetcode-228-summary-ranges">LeetCode 228. Summary Ranges</h1>
<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<p>解析：</p>
<p>将一组数划分成若干的区间，用双指针分别代表区间的起点和终点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">summaryRanges</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//初始双指针重合
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="c1">//high指针继续往下走
</span><span class="c1"></span>        <span class="n">high</span><span class="o">++</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span><span class="c1">//输出
</span><span class="c1"></span>        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">low</span> <span class="o">==</span> <span class="n">high</span> <span class="o">?</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">:</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">high</span><span class="p">));</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//更新low指针
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">low</span> <span class="o">==</span> <span class="n">high</span> <span class="o">?</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">:</span> <span class="n">to_string</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">high</span><span class="p">));</span>        <span class="c1">//最后一个区间或数
</span><span class="c1"></span><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-56-merge-intervals">LeetCode 56. Merge Intervals</h1>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example, <br>
Given [1,3],[2,6],[8,10],[15,18], <br>
return [1,6],[8,10],[15,18].</p>
<p>解析：合并区间问题，先把区间按照起点排序，如果当前区间的终点比后继区间的起点大，那么需要合并区间，起点不变，选择当前区间的终点和后继区间的终点两者之间的最大值作为新的区间的终点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for an interval.
</span><span class="cm"> * struct Interval {
</span><span class="cm"> *     int start;
</span><span class="cm"> *     int end;
</span><span class="cm"> *     Interval() : start(0), end(0) {}
</span><span class="cm"> *     Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">bool</span> <span class="n">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Interval</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Interval</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="c1">//区间按照起点排序
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">intervals</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span><span class="c1">//合并区间
</span><span class="c1"></span>            <span class="n">res</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">end</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-57-insert-interval">LeetCode 57. Insert Interval</h1>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2], [3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<p>解析：</p>
<p>该区间集合已经按起点排序。插入一个区间到区间集合中。本题不保证必定出现区间合并。
设l=-1，r=n。
整个区间集合可以分为三部分：</p>
<ol>
<li>终点比新区间起点小的区间 （0~l）</li>
<li>和新区间合并的区间（可以没有）</li>
<li>起点比新区间终点大的区间（r~n-1）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">
</span><span class="cm">Definition for an interval.
</span><span class="cm">struct Interval {
</span><span class="cm">int start;
</span><span class="cm">int end;
</span><span class="cm">Interval() : start(0), end(0) {}
</span><span class="cm">Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span> <span class="n">insert</span><span class="p">(</span><span class="n">vector</span><span class="o">&amp;</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">Interval</span> <span class="n">newInterval</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="c1">// 计算参与合并的区间范围
</span><span class="c1"></span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="c1">//直到新区间的起点小于等于l+1区间的终点，新区间可以合并该区间，成为新的l+1区间
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="n">l</span> <span class="o">++</span><span class="p">;</span>
<span class="c1">//直到新区间的终点大于等于r-1区间的起点，新区间可以合并该区间，成为新的r-1区间
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">end</span><span class="p">)</span> <span class="n">r</span> <span class="err">–</span><span class="p">;</span>
<span class="c1">//如果找到能够进行合并的区间的话，将区间合并到新区间
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">newInterval</span><span class="p">.</span><span class="n">end</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">newInterval</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">newInterval</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">start</span><span class="p">);</span>
<span class="n">vector</span> <span class="n">ans</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newInterval</span><span class="p">);</span><span class="c1">//放入新区间
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-495-teemo-attacking">LeetCode 495. Teemo Attacking</h1>
<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p>
<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>
<p>Example 1: <br>
Input: [1,4], 2.<br>
Output: 4.<br>
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. <br>
This poisoned status will last 2 seconds until the end of time point 2. <br>
And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. <br>
So you finally need to output 4.</p>
<p>Example 2: <br>
Input: [1,2], 2.<br>
Output: 3.<br>
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. <br>
This poisoned status will last 2 seconds until the end of time point 2. <br>
However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status.
Since the poisoned status won’t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. <br>
So you finally need to output 3.</p>
<p>Note:</p>
<p>You may assume the length of given time series array won’t exceed 10000.</p>
<p>You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</p>
<p>解析：给出了每个区间的起点和所有区间的长度，求区间有效长度（空位不算）。如果长度为0，输出-1。扫描数组，计算当前区间的终点，计算该区间增加的有效长度（当前终点减上一个终点）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">findPoisonedDuration</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">timeSeries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oldEnd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeSeries</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">newEnd</span> <span class="o">=</span> <span class="n">timeSeries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newEnd</span> <span class="o">&gt;</span> <span class="n">oldEnd</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">newEnd</span> <span class="o">-</span> <span class="n">oldEnd</span><span class="p">);</span>
            <span class="n">oldEnd</span> <span class="o">=</span> <span class="n">newEnd</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-436-find-right-interval">LeetCode 436. Find Right Interval</h1>
<p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.</p>
<p>For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p>
<p>Note:</p>
<p>You may assume the interval’s end point is always bigger than its start point.</p>
<p>You may assume none of these intervals have the same start point.</p>
<p>Example 1:</p>
<p>Input: [ [1,2] ]</p>
<p>Output: [-1]</p>
<p>Explanation: There is only one interval in the collection, so it outputs -1.</p>
<p>Example 2:</p>
<p>Input: [ [3,4], [2,3], [1,2] ]</p>
<p>Output: [-1, 0, 1]</p>
<p>Explanation: There is no satisfied “right” interval for [3,4].
For [2,3], the interval [3,4] has minimum-“right” start point;
For [1,2], the interval [2,3] has minimum-“right” start point.</p>
<p>Example 3:</p>
<p>Input: [ [1,4], [2,3], [3,4] ]       <br>
Output: [-1, 2, -1].</p>
<p>Explanation: There is no satisfied “right” interval for [1,4] and [3,4]. <br>
For [2,3], the interval [3,4] has minimum-“right” start point.</p>
<p>解析：</p>
<p>这个题目的意思是：给定一系列的区间，对于任意一个区间，在所有区间中找到一个区间的起始点大于等于当前区间的结束点，并且要求这两个点最接近。</p>
<p>用哈希表保存区间的起点和对应的区间号，然后枚举每个区间，在哈希表中查找终点大于等于该区间终点的迭代器。</p>
<p>因为要求两个区间最接近，所以哈希表使用map，自带排序功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for an interval.
</span><span class="cm"> * struct Interval {
</span><span class="cm"> *     int start;
</span><span class="cm"> *     int end;
</span><span class="cm"> *     Interval() : start(0), end(0) {}
</span><span class="cm"> *     Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findRightInterval</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;&amp;</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span><span class="c1">//利用map给区间起点排序。
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//记录区间起点所属的区间
</span><span class="c1"></span>        <span class="n">hash</span><span class="p">[</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">in</span> <span class="p">:</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">hash</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">itr</span> <span class="o">==</span> <span class="n">hash</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//如果找不到，返回-1
</span><span class="c1"></span>        <span class="k">else</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">itr</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span><span class="c1">//找到的话，加入结果
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-352-data-stream-as-disjoint-intervals">LeetCode 352. Data Stream as Disjoint Intervals</h1>
<p>Given a data stream input of non-negative integers a1, a2, …, an, …, summarize the numbers seen so far as a list of disjoint intervals.</p>
<p>For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, …, then the summary will be:</p>
<pre><code>[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]
</code></pre>
<p>Follow up:</p>
<p>What if there are lots of merges and the number of disjoint intervals are small compared to the data stream’s size?</p>
<p>解析：</p>
<p>如果合并的操作非常多但是最后区间可能很少, 这种情况下不适合直接用vector, 因为他的合并操作需要移位,故时间复杂度是O(n), 频繁的移位会造成时间复杂度大大增加. 一个更好的解决办法是使用set, 因为二叉搜索树插入查找都可以在O(log n)完成, 只需要在返回结果的时候将set中的值放到vector中即可.</p>
<pre><code>if(it != st.begin() &amp;&amp; (--it)-&gt;end+1 &lt; val) it++;
</code></pre>
<p>这是一个技巧，set迭代器支持自加自减，但不支持随机访问，所以不能用it-1，这个语句其实表达的意思和下面的语句相同，但下面的语句无法通过编译。</p>
<pre><code>if(it != st.begin() &amp;&amp; (it-1)-&gt;end+1 &gt;= val) it--; 
</code></pre>
<p>如果符合条件，就it++，将it之前减的补回来，如果不符合条件，it-1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * Definition for an interval.
</span><span class="cm"> * struct Interval {
</span><span class="cm"> *     int start;
</span><span class="cm"> *     int end;
</span><span class="cm"> *     Interval() : start(0), end(0) {}
</span><span class="cm"> *     Interval(int s, int e) : start(s), end(e) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="n">class</span> <span class="n">SummaryRanges</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="cm">/** Initialize your data structure here. */</span>
<span class="kt">void</span> <span class="n">addNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span><span class="c1">//找到第一个大于等于要插入的值的区间
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="c1">//当前要插入的值可能会正好等于上个区间的end+1, 所以要考虑前一个区间。
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">st</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">--</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">st</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">val</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span><span class="c1">//如果找到了it，并且it可以将val吞并
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span><span class="c1">//新区间的起点和终点
</span><span class="c1"></span>        <span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="c1">//将it删除，并返回迭代器，该迭代器指向被删除元素后面的元素
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">st</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">Interval</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">));</span><span class="c1">//插入新区间
</span><span class="c1"></span><span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">getIntervals</span><span class="p">()</span> <span class="p">{</span><span class="c1">//输出结果
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">val</span><span class="p">:</span> <span class="n">st</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="k">struct</span> <span class="n">Cmp</span><span class="p">{</span><span class="c1">//仿函数，使set中元素按照起点升序排列
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="n">Interval</span> <span class="n">a</span><span class="p">,</span> <span class="n">Interval</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">start</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">Interval</span><span class="p">,</span> <span class="n">Cmp</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/**
</span><span class="cm"> * Your SummaryRanges object will be instantiated and called as such:
</span><span class="cm"> * SummaryRanges obj = new SummaryRanges();
</span><span class="cm"> * obj.addNum(val);
</span><span class="cm"> * vector&lt;Interval&gt; param_2 = obj.getIntervals();
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-06-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/binary-search/">Binary Search</a>
          <a href="/tags/stl/">STL</a>
          <a href="/tags/heap/">Heap</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">路径问题</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/">
            <span class="next-text nav-default">文件路径</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
