<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>BBR自适应限流算法实现 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="TCP-BBR 算法 BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 近年来提出的拥塞控制算法，诞生后大幅度提高了在高延迟等情况下网络传输的吞吐。从命名就" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.3 with theme even" />


<link rel="canonical" href="/post/bbr%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="BBR自适应限流算法实现" />
<meta property="og:description" content="TCP-BBR 算法 BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 近年来提出的拥塞控制算法，诞生后大幅度提高了在高延迟等情况下网络传输的吞吐。从命名就" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/bbr%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-14T17:28:43+00:00" />
<meta property="article:modified_time" content="2021-11-14T17:28:43+00:00" />

<meta itemprop="name" content="BBR自适应限流算法实现">
<meta itemprop="description" content="TCP-BBR 算法 BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 近年来提出的拥塞控制算法，诞生后大幅度提高了在高延迟等情况下网络传输的吞吐。从命名就"><meta itemprop="datePublished" content="2021-11-14T17:28:43+00:00" />
<meta itemprop="dateModified" content="2021-11-14T17:28:43+00:00" />
<meta itemprop="wordCount" content="10575">
<meta itemprop="keywords" content="算法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BBR自适应限流算法实现"/>
<meta name="twitter:description" content="TCP-BBR 算法 BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 近年来提出的拥塞控制算法，诞生后大幅度提高了在高延迟等情况下网络传输的吞吐。从命名就"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">BBR自适应限流算法实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-14 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
          <span class="more-meta"> 约 10575 字 </span>
          <span class="more-meta"> 预计阅读 22 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#tcp-bbr-算法">TCP-BBR 算法</a>
      <ul>
        <li><a href="#算法核心解读">算法核心解读</a></li>
        <li><a href="#算法组成">算法组成</a></li>
        <li><a href="#利特尔法则">利特尔法则</a></li>
      </ul>
    </li>
    <li><a href="#bbr自适应限流算法">BBR自适应限流算法</a>
      <ul>
        <li><a href="#控制时机">控制时机</a></li>
        <li><a href="#控制信号">控制信号</a></li>
        <li><a href="#具体方案">具体方案</a></li>
        <li><a href="#线上效果与调优">线上效果与调优</a></li>
      </ul>
    </li>
    <li><a href="#bbr-struct">BBR struct</a></li>
    <li><a href="#公共接口-limiter">公共接口: Limiter</a></li>
    <li><a href="#cpu计算">CPU计算</a></li>
    <li><a href="#allow-方法">Allow 方法</a></li>
    <li><a href="#滑动窗口">滑动窗口</a>
      <ul>
        <li><a href="#单元节点-bucket">单元节点: Bucket</a></li>
        <li><a href="#环形数组-window">环形数组: Window</a></li>
        <li><a href="#滑动窗口-rollingpolicy">滑动窗口: RollingPolicy</a></li>
        <li><a href="#计数器-rollingcounter">计数器: RollingCounter</a></li>
        <li><a href="#瞬时统计-rollinggauge">瞬时统计: RollingGauge</a></li>
      </ul>
    </li>
    <li><a href="#maxpass--minrt">MaxPass &amp;&amp; MinRT</a></li>
    <li><a href="#判断规则">判断规则</a></li>
    <li><a href="#shoulddrop">shouldDrop</a></li>
    <li><a href="#流程图">流程图</a></li>
    <li><a href="#压测报告">压测报告</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="tcp-bbr-算法">TCP-BBR 算法</h2>
<p>BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 近年来提出的拥塞控制算法，诞生后大幅度提高了在高延迟等情况下网络传输的吞吐。从命名就可以看到带宽（Bandwidth）和往返时延（Round-trip time)关键字，在上述铺垫过程中，对应的就是 maxBW 和 minRTT。对于多变的网络环境 BBR 大胆的采用了以预期公式驱动，实时交替探测两个负载指标的办法，下文会对此详细解释。</p>
<h3 id="算法核心解读">算法核心解读</h3>
<p>BBR 认为：既然网络多变，且最佳带宽和时延不好同时测量，那么就采取实时交替探测的方式。通过滑动窗口细粒度的交替收集一段时间内的每秒最大传输量和最小的 RTT，通过计算就可以获得目前最佳的 BDP。即BestBDP = BtlBw (bottleneck bandwidth) * RTprop (round-trip propagation time)</p>
<p>BtlBw</p>
<p>表示目前网络中的瓶颈带宽，也就是上节中的 maxBW，是网络设施传输的上限。BBR 会取得一段时间内滑动窗口的统计的最大 BtlBw 值作为参考。其测量方式简述为一段时间内的数据包总量除以他们所抵达花费的时间。</p>
<p>RTprop</p>
<p>表示抛开任何外在噪音，如 ack 重发耗时，网络抖动等等导致 RTT 偏高情况。即在滑动窗口统计中的 RTT 最小值作为参考，其测量方式为数据包发送和回复耗时。</p>
<p>inflight</p>
<p>这指的是，在 BBR 工作期间内，已经发送至网络但是还是没有收到答复的数据包。也就说真实的，在网络设备里正在传输的数据量，即负载。有了预期公式计算出的 BestBDP 指导将 RTprop 与 BtlBW 相乘，BBR 就可以得出当前时刻外界网络最佳的负载量与实际 inflight 的关系。有了这样的简单的数值比对，算法就可以控制发包的最佳量以进行拥塞控制。</p>
<p>以下伪代码直观的体现了 BBR 算法在发包和收包时的处理逻辑。</p>
<p>收包 onAck</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117220411.png" alt=""></p>
<p>发包 send</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117220424.png" alt=""></p>
<h3 id="算法组成">算法组成</h3>
<p>了解了核心的算法逻辑，接下来将简述其运作周期，进一步了解算法是如何充分利用未知网络设备传输能力的。算法运行状态主要分为启动阶段（Startup）、排空阶段（Drain）、带宽探测（ProbeBW）、时延探测（ProbeRTT)。同样，本文将不会阐述具体细节，具体细节可以参考文末的 reference。我们回到核心关注点，BBR 是如何探测以及适应当前网络设备传输能力的。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117220613.png" alt=""></p>
<p>上图摘自 google BBR 论文，展示了在稳定网络传输节点下 BBR 算法中关键指标 RTT、BW、inflight 的变化图。其中灰色 cycle gain 数组，相当于滑动窗口。其中每个元素装载了带宽探测时的增益系数，通过与当前最大 BW 相乘可以实现增加/减少向网络中的数据发送，从而实现适应未知网络传输能力目的；同理，对于时延探测，简单来说 BBR 同样会周期性的发送小体量数据包收集最佳 RTT。</p>
<p>可见，基于预期的负载控制算法，即同时集合负载因子和关键结果的计算，相比只关注一个指标的实现方式在高吞吐场景下具备一定的优越性。同时，基于滑动窗口细粒度的动态探测极值，使得测量结果更具时效性与说服力。</p>
<h3 id="利特尔法则">利特尔法则</h3>
<p>应用层和传输层在应对负载时本质需求是相同的，那么关于应用层的核心预期公式的推导显然具有相似性，那就是最佳请求数TW（当前最佳处理任数目） = TPS * latency。如下所示</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117220734.png" alt=""></p>
<p>其实这个公式的依据是显赫有名的利特尔法则 little&rsquo;s law，为通过对工业中平均生产数量和对应耗时提供了理论基础，以进一步衡量生产能力。</p>
<h2 id="bbr自适应限流算法">BBR自适应限流算法</h2>
<p>我们已经具备充分的理论基础和传输层实现指导，下一步就是因地制宜的实施在应用层后台服务。在业内最初版目前所知是由阿里的 sentinel 组件引入，由 kratos 进行了进一步拓展。在此我们需要搞清楚两个关键问题，才能保证最大化吞吐的同时防止服务过载。</p>
<h3 id="控制时机">控制时机</h3>
<p>BBR 作为数据发送方，需要面临的问题未知网络设施传输能力。由于网络设施的传输能力、拥塞状态对发送方是非直接可见的，所以才有了上文提到的 BBR 带宽探测。滑动窗口内通过 cycle gain 变化，来适应不同时刻的传输能力。</p>
<p>应用层作为请求处理方，无论是在容器网络和物理机上部署，计算资源是相对固定的。这意味着存在着最佳处理量上限，我们要保证的是在流量上升或者因为其他因素导致计算资源紧张时，通过计算出的最佳 TW 来限制入口流量。</p>
<h3 id="控制信号">控制信号</h3>
<p>了解了控制时机，可就是当计算资源紧张时进行干预。那么该如何确定资源紧张信号呢？总的来说就是 CPU 利用率或者操作系统负载，或者内存、磁盘等资源。以入口流量特征来看（进程 RPC 调用下游服务按照业务需求进行组装、计算、返回），无论时内存资源不足导致的 GC（依赖 CPU）、磁盘 I/O 吞吐下降、调度抢占等等因素，都会导致用户请求增加、序列化成本增加（CPU）进而时延上升恶性循环。所以在 sentinel 和 kratos 的实现中都选择了适用 CPU 作为资源信号限流，只不过前者使用的是 cpu load1，后者使用的是服务基于 cgroup 对 CPU 的实时采样使用率。</p>
<p>两者使用各有千秋，但我们认为，基于 load1 作为控制信号仍不够敏感。在 linux 下操作系统 load1 表示一分钟内 CPU 的平均负载值，对于流量洪峰等过载的发生干预有效性较慢。</p>
<h3 id="具体方案">具体方案</h3>
<p>本部分屏蔽到绝大部分代码与设施细节，关注应用方式与过程中上线效果、遇到的问题以及优化。</p>
<p>CPU 利用率峰值信号</p>
<p>kratos 以是当前容器网络服务 CPU 利用率的 80%作为控制信号临界点，通过为此服务会开启独立的 goroutine 每隔 250ms 进行基于本服务的 cgroup(/sys/fs/cgroup/cpu/*)CPU 占用信息采集，以及系统总 cpu tick（proc/stat)占用采集。</p>
<p>对 CPU 占用率的计算本质是间隔内 本进程占用的 CPU 时间增量/系统的总 CPU 时间占用增量。显然 CPU 的变化是相当迅速的，会受到各种因素的影响来回抖动动。为此我们采用了滑动均值（算法原理参考）的办法进行降噪稳定。通过确定参考衰退率β(&lt;1)，使得最终结果等于：β*上次的CPU占用率 + (1-β)*本次的时机测得CPU占用率。如下所示：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117221012.png" alt=""></p>
<ol>
<li>深蓝色折线代表了正常实际测量下 CPU 的变化折线图，可以看到抖动十分不稳定。</li>
<li>橘色公式折线表示了在滑动均值算法下趋于平稳变动的 CPU 变化图，但是能看到前提 CPU 数值较低。</li>
<li>绿色公式折线是在具体滑动均值算法作用下，对前期数据量不足导致 CPU 起点低的问题进行的偏差修正。</li>
</ol>
<p>最终经过上述修正，我们得到线上具有参考使用价值的 CPU 占用率。</p>
<p>Pass&amp;RT</p>
<p>pass 和 RT 分别表示处理完成请求数和对应请求所消耗的时间，即 TPS 和 Latency。相应的，我们的测量办法同样是通过滑动窗口对 pass 和 RT 进行统计，如下图。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117221112.png" alt=""></p>
<p>sample window 表示窗口采样周期，sample bucket 表示周期内的采样批次。假设现在采样窗口时间为 1000ms，bucket 采样批次时间持续 500ms，那么就表示在前 500ms 内完成的请求数和这些请求消耗的平均时延都会被原子（atomic）统计在 bucket1 中。同理，当第 501ms 会被统计在 bucket2 中，当第 1001ms 时会再次回到 bucket1，以此类推。可见当 bucket 足够多，以及统计间隔足够小时最能够得到真实的数据，更有效的应对秒内流量洪峰。</p>
<p>流量干预</p>
<p>当 CPU 利用率过载时，就需要通过预期公式进行干预了。我们会在服务运行期间持续统计当前服务的请求数，即 inflight，通过在滑动窗口内的所有 buckets 中比较得出最多请求完成数 maxPass，以及最小的耗时 minRT，相乘就得出了预期的最佳请求数 maxFlight。通过 inflight 与 maxFlight 对比，如果前者大于后者那么就已经过载，进而拒绝后续到来的请求防止服务过载。</p>
<h3 id="线上效果与调优">线上效果与调优</h3>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211117221144.png" alt=""></p>
<p>上图是在线上部署了基于 kratos 的自适应算法后的效果图，其中蓝色曲线代表了并发访问的用户数，深黄色代表对应请求的时延，浅绿色则表示成功处理的请求数。左侧为最终版，右侧为第一版。</p>
<p>不难看出，第一版时当算法控制后黄色的时延仍然很高，成功处理的请求数也并非稳定。产生这样结果的原因其实依然是 CPU 利用率很敏感且粒度很细，当 CPU 大于 80%利用率阈值时算法生效，当微量请求被拒绝时算法便停止了干预。最终的结果便是算法会因为流量的涌入与拒绝中频繁开启与关闭，导致结果不符合预期。</p>
<p>优化手段</p>
<p>为此我们简单加入了 1s 的冷却时间，也就是说算法开启后会持续至少 1s 的冷却时间，在此期间保持算法开启。当冷却时间过后会再次统计当前 CPU 利用率，并根据阈值对比进行持续或者关闭。最终测试结果如最终版左图所示，在流量持续涌入的情况下请求的成功处理数和时延都十分稳定。</p>
<h2 id="bbr-struct">BBR struct</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// BBR implements bbr-like limiter.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is inspired by sentinel.
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/alibaba//wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">BBR</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cpu</span>             <span class="nx">cpuGetter</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// passStat：请求处理成功的量（滑动窗口计数器）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">passStat</span>        <span class="nx">metric</span><span class="p">.</span><span class="nx">RollingCounter</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// rtStat：请求成功的响应耗时（滑动窗口计数器）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rtStat</span>          <span class="nx">metric</span><span class="p">.</span><span class="nx">RollingCounter</span>
</span></span><span class="line"><span class="cl">	<span class="nx">inFlight</span>        <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">winBucketPerSec</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucketDuration</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
</span></span><span class="line"><span class="cl">	<span class="nx">winSize</span>         <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conf</span>            <span class="o">*</span><span class="nx">Config</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 对应于公式的 prevDrop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">prevDrop</span>        <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxPASSCache</span>    <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">minRtCache</span>      <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>cpu: cpu的指标函数，CPU的使用率， 这里为了减小误差，把数字扩大化，乘以1000，比如使用率60%，也就是0.6 cpu的值就为600</li>
<li>passStat: 请求数的采样数据，使用滑动窗口进行统计</li>
<li>rtStat: 响应时间的采样数据，同样使用滑动窗口进行统计</li>
<li>inFlight: 当前系统中的请求数，数据得来方法是：中间件原理在处理前+1，处理handle之后不管成功失败都减去1</li>
<li>bucketPerSecond: 一个 bucket 的时间</li>
<li>bucketSize: 桶的数量</li>
<li>prevDropTime: 上次触发限流时间</li>
<li>maxPASSCache: 单个采样窗口中最大的请求数的缓存数据</li>
<li>minRtCache: 单个采样窗口中最小的响应时间的缓存数据</li>
</ul>
<h2 id="公共接口-limiter">公共接口: Limiter</h2>
<p>Limter 公共接口 limiter.go 定义如下： 核心 Allow 方法，返回 error 不为 nil 表示需要限流，回调函数 func(info DoneInfo)，传入的参数为 Doneifno，有点类似于 gPRC 的 balancer.picker 实现，在 RPC 返回成功时调用的回调方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Success opertion type: success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Success</span> <span class="nx">Op</span> <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Ignore opertion type: ignore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Ignore</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Drop opertion type: drop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Drop</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// DoneInfo done info.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">DoneInfo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Op</span>  <span class="nx">Op</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Limiter limit interface.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Limiter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//func(info DoneInfo) 调用参数为 Doneinfo，返回值无
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Allow</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">AllowOption</span><span class="p">)</span> <span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">info</span> <span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>全局变量:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cpu</span>         <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">decay</span>       <span class="p">=</span> <span class="mf">0.95</span>
</span></span><span class="line"><span class="cl">	<span class="nx">initTime</span>    <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">defaultConf</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Window</span><span class="p">:</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">WinBucket</span><span class="p">:</span>    <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">CPUThreshold</span><span class="p">:</span> <span class="mi">800</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">cpuGetter</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int64</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 limiter 中，也有分组的概念，比如针对后端某个 CGI 或 RPC 方法，应用不通的限速策略及规则，这里直接就使用了 container/group 来进行封装： 封装 group.Group 的指针成员，作为 bbr.Group：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Group represents a class of BBRLimiter and forms a namespace in which
</span></span></span><span class="line"><span class="cl"><span class="c1">// units of BBRLimiter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">group</span> <span class="o">*</span><span class="nx">group</span><span class="p">.</span><span class="nx">Group</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化 bbr.Group：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NewGroup new a limiter group container, if conf nil use default conf.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewGroup</span><span class="p">(</span><span class="nx">conf</span> <span class="o">*</span><span class="nx">Config</span><span class="p">)</span><span class="o">*</span><span class="nx">Group</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">conf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 使用默认 group 配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">conf</span> <span class="p">=</span> <span class="nx">defaultConf</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建 group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">group</span> <span class="o">:=</span> <span class="nx">group</span><span class="p">.</span><span class="nf">NewGroup</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">newLimiter</span><span class="p">(</span><span class="nx">conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Group</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">group</span><span class="p">:</span> <span class="nx">group</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 key 获取对应的 limter 配置（不存在则创建），获取到 limter 对象之后，直接调用 limiter.Allow() 就可以进行限速判定了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Get get a limiter by a specified key, if limiter not exists then make a new one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">Limiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limiter</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">group</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">limiter</span><span class="p">.(</span><span class="nx">limit</span><span class="p">.</span><span class="nx">Limiter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 newLimiter 方法创建一个 bbr.Limiter 并返回，注意看初始化的参数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newLimiter</span><span class="p">(</span><span class="nx">conf</span> <span class="o">*</span><span class="nx">Config</span><span class="p">)</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">Limiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">conf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">conf</span> <span class="p">=</span> <span class="nx">defaultConf</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">WinBucket</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucketDuration</span> <span class="o">:=</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">Window</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">WinBucket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">passStat</span> <span class="o">:=</span> <span class="nx">metric</span><span class="p">.</span><span class="nf">NewRollingCounter</span><span class="p">(</span><span class="nx">metric</span><span class="p">.</span><span class="nx">RollingCounterOpts</span><span class="p">{</span><span class="nx">Size</span><span class="p">:</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">BucketDuration</span><span class="p">:</span> <span class="nx">bucketDuration</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rtStat</span> <span class="o">:=</span> <span class="nx">metric</span><span class="p">.</span><span class="nf">NewRollingCounter</span><span class="p">(</span><span class="nx">metric</span><span class="p">.</span><span class="nx">RollingCounterOpts</span><span class="p">{</span><span class="nx">Size</span><span class="p">:</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">BucketDuration</span><span class="p">:</span> <span class="nx">bucketDuration</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义了 cpu 为 func，直接返回全局变量 cpu 的值（atomic 方式）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cpu</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limiter</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">BBR</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cpu</span><span class="p">:</span>             <span class="nx">cpu</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">conf</span><span class="p">:</span>            <span class="nx">conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">passStat</span><span class="p">:</span>        <span class="nx">passStat</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rtStat</span><span class="p">:</span>          <span class="nx">rtStat</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">winBucketPerSec</span><span class="p">:</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">Window</span><span class="p">)</span> <span class="o">/</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">WinBucket</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">limiter</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cpu计算">CPU计算</h2>
<p>在包初始化函数 init 中，启动了一个新的子协程来计算 CPU 的利用率数据，此外，计算出的 CPU 使用率是一个 Gauge，使用 atomic 包存储在全局变量 cpu int64 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">cpuproc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// cpu = cpuᵗ⁻¹ * decay + cpuᵗ * (1 - decay)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">cpuproc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">250</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;rate.limit.cpuproc() err(%+v)&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 在 recover 中重启 CPU 监控
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">go</span> <span class="nf">cpuproc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// EMA algorithm: https://blog.csdn.net/m0_38106113/article/details/81542863
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="k">range</span> <span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stat</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cpustat</span><span class="p">.</span><span class="nx">Stat</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cpustat</span><span class="p">.</span><span class="nf">ReadStat</span><span class="p">(</span><span class="nx">stat</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获取前一个周期的 cpu 数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">prevCpu</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//decay = 0.95
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">curCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">prevCpu</span><span class="p">)</span><span class="o">*</span><span class="nx">decay</span> <span class="o">+</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">stat</span><span class="p">.</span><span class="nx">Usage</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="nx">decay</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 保存新的校准后的 CPU 数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cpu</span><span class="p">,</span> <span class="nx">curCpu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>CPU获取的是cgroup的cpu:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">cpu</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;bufio&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;path&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">cgroupRootDir</span> <span class="p">=</span> <span class="s">&#34;/sys/fs/cgroup&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// cgroup Linux cgroup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">cgroup</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cgroupSet</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CPUCFSQuotaUs cpu.cfs_quota_us
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cgroup</span><span class="p">)</span> <span class="nf">CPUCFSQuotaUs</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cgroupSet</span><span class="p">[</span><span class="s">&#34;cpu&#34;</span><span class="p">],</span> <span class="s">&#34;cpu.cfs_quota_us&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CPUCFSPeriodUs cpu.cfs_period_us
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cgroup</span><span class="p">)</span> <span class="nf">CPUCFSPeriodUs</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cgroupSet</span><span class="p">[</span><span class="s">&#34;cpu&#34;</span><span class="p">],</span> <span class="s">&#34;cpu.cfs_period_us&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">parseUint</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CPUAcctUsage cpuacct.usage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cgroup</span><span class="p">)</span> <span class="nf">CPUAcctUsage</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cgroupSet</span><span class="p">[</span><span class="s">&#34;cpuacct&#34;</span><span class="p">],</span> <span class="s">&#34;cpuacct.usage&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">parseUint</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CPUAcctUsagePerCPU cpuacct.usage_percpu
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cgroup</span><span class="p">)</span> <span class="nf">CPUAcctUsagePerCPU</span><span class="p">()</span> <span class="p">([]</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cgroupSet</span><span class="p">[</span><span class="s">&#34;cpuacct&#34;</span><span class="p">],</span> <span class="s">&#34;cpuacct.usage_percpu&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">usage</span> <span class="p">[]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">u</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parseUint</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// fix possible_cpu:https://www.ibm.com/support/knowledgecenter/en/linuxonibm/com.ibm.linux.z.lgdd/lgdd_r_posscpusparm.html
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">u</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">usage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">usage</span><span class="p">,</span> <span class="nx">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">usage</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CPUSetCPUs cpuset.cpus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cgroup</span><span class="p">)</span> <span class="nf">CPUSetCPUs</span><span class="p">()</span> <span class="p">([]</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cgroupSet</span><span class="p">[</span><span class="s">&#34;cpuset&#34;</span><span class="p">],</span> <span class="s">&#34;cpuset.cpus&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cpus</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">ParseUintList</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">sets</span> <span class="p">[]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cpus</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sets</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sets</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sets</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CurrentcGroup get current process cgroup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">currentcGroup</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">cgroup</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pid</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getpid</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cgroupFile</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;/proc/%d/cgroup&#34;</span><span class="p">,</span> <span class="nx">pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cgroupSet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">cgroupFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fp</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">fp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">line</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">col</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">line</span><span class="p">),</span> <span class="s">&#34;:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">col</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;invalid cgroup format %s&#34;</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dir</span> <span class="o">:=</span> <span class="nx">col</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// When dir is not equal to /, it must be in docker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">dir</span> <span class="o">!=</span> <span class="s">&#34;/&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">cgroupSet</span><span class="p">[</span><span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cgroupRootDir</span><span class="p">,</span> <span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;,&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;,&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">cgroupSet</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cgroupRootDir</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">cgroupSet</span><span class="p">[</span><span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cgroupRootDir</span><span class="p">,</span> <span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">col</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;,&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;,&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">cgroupSet</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">cgroupRootDir</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">col</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">cgroup</span><span class="p">{</span><span class="nx">cgroupSet</span><span class="p">:</span> <span class="nx">cgroupSet</span><span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="allow-方法">Allow 方法</h2>
<p>先看看 Allow 方法的实现，在每次的服务端请求中都会调用此方法，注意下面节点：</p>
<ul>
<li>passStat 及 rtStat 的数据上报的逻辑</li>
<li>rt–请求成功的响应耗时的计算方法</li>
</ul>
<p>rt 的计算方法比较巧妙：</p>
<ol>
<li>初始化全局变量 <code>initTime = time.Now()</code></li>
<li>请求开始前计算 <code>stime := time.Since(initTime)</code></li>
<li>Allow 返回一个函数对象 <code>func(info limit.DoneInfo)</code>，在函数对象中计算 <code>rt := int64((time.Since(initTime) - stime) / time.Millisecond)</code> 这样就成功的避免每次需要保存前一个周期计时点了，不过引入的成本就是需要取两次当前最新的时间戳。</li>
</ol>
<p>值得细品的是返回的这个函数对象，通过对这个函数对象的延迟调用，可以实现一些在 “某某事情（接口调用、请求执行）完成后再执行的” 功能，在 golang 中可以算是通用的解决方式了。比如，在 Warden 的服务端实现中，默认加载了 bbr.Limiter 作为服务端过载保护的手段，实现的 Limiter 拦截器代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Limit is a server interceptor that detects and rejects overloaded traffic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">RateLimiter</span><span class="p">)</span> <span class="nf">Limit</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">args</span><span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryHandler</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">uri</span> <span class="o">:=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">FullMethod</span>
</span></span><span class="line"><span class="cl">		<span class="nx">limiter</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">group</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">done</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">limiter</span><span class="p">.</span><span class="nf">Allow</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">_metricServerBBR</span><span class="p">.</span><span class="nf">Inc</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">done</span><span class="p">(</span><span class="nx">limit</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">Success</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">			<span class="nx">b</span><span class="p">.</span><span class="nf">printStats</span><span class="p">(</span><span class="nx">uri</span><span class="p">,</span> <span class="nx">limiter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意上面代码中的 <code>done, err := limiter.Allow(ctx)</code>，就是调用了 <code>bbr.Limiter</code> 实现的 <code>Allow()</code> 方法，然后在 <code>defer func() {......}</code> 中巧妙的调用了 <code>done</code> 方法。注意 <code>defer</code> 的调用位置在 <code>resp, err = handler(ctx, req)</code> 之后，这代表，在真正的 RPC 方法执行完之后才调用 <code>defer</code> 中的逻辑：<code>done(limit.DoneInfo{Op: limit.Success})</code>，这里就调用了函数对象里面的实现逻辑：</p>
<ol>
<li>计算 rt 的值</li>
<li>向 rtStat 滑动窗口计数器中累加 rt 及次数</li>
<li>当前正在处理请求数 inFlight 减 1</li>
<li>根据 do.Op 取值，若为 limit.Success，则向滑动窗口计数器 passStat 累加计数</li>
<li>返回</li>
</ol>
<p>代码片段如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="p">(</span><span class="nx">do</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取执行过程的耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rt</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">((</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">initTime</span><span class="p">)</span> <span class="o">-</span> <span class="nx">stime</span><span class="p">)</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 向 RollingCounter 中添加 rt（这是把 RollingCounter 当做累加器使用）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">l</span><span class="p">.</span><span class="nx">rtStat</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">inFlight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">do</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">Success</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">passStat</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>完整的 Allow 实现代码如下，注意是在 shouldDrop 方法是基于 bbr 的限流算法来判断是否应该丢弃请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Allow checks all inbound traffic.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Once overload is detected, it raises ecode.LimitExceed error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">BBR</span><span class="p">)</span> <span class="nf">Allow</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">limit</span><span class="p">.</span><span class="nx">AllowOption</span><span class="p">)</span> <span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">info</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">allowOpts</span> <span class="o">:=</span> <span class="nx">limit</span><span class="p">.</span><span class="nf">DefaultAllowOpts</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">opt</span><span class="p">.</span><span class="nf">Apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allowOpts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// shouldDrop 判断是否需要限流，如果true表示限流 之后重点讲
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nf">shouldDrop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ecode</span><span class="p">.</span><span class="nx">LimitExceed</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">inFlight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 之前说的，正在处理数+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">initTime</span><span class="p">)</span> <span class="c1">// 现在时间减去程序初始化时间 表示程序开始执行时刻
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">do</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// allow返回函数 在中间件（拦截器）中handle执行完成后调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">rt</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">((</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">initTime</span><span class="p">)</span> <span class="o">-</span> <span class="nx">stime</span><span class="p">)</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span> <span class="c1">// 执行完handle的时间减去stime 表示 程序执行的总时间 单位ms
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">l</span><span class="p">.</span><span class="nx">rtStat</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>	<span class="c1">// 把处理时间放进采样数据window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">inFlight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 正在处理数-1 便是处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">switch</span> <span class="nx">do</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">limit</span><span class="p">.</span><span class="nx">Success</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">passStat</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">// 成功了，把通过数的采样数据window加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Stats contains the metrics’s snapshot of bbr. type Stat struct { Cpu int64 InFlight int64 MaxInFlight int64 MinRt int64 MaxPass int64 }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Config contains configs of bbr limiter. type Config struct { Enabled bool Window time.Duration WinBucket int Rule string Debug bool CPUThreshold int64 }
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="滑动窗口">滑动窗口</h2>
<p>在自适应限流保护中，采集到的指标的时效性非常强，系统只需要采集最近一小段时间内的 qps、rt 即可，对于较老的数据，会自动丢弃。为了实现这个效果，kratos 使用了滑动窗口来保存采样数据。</p>
<h3 id="单元节点-bucket">单元节点: Bucket</h3>
<p>Bucket 提供了 Append 方法，用于向 Points 中添加数据，Points 是 float64 类型的 slice，主要存放单个指标的值，如延迟，错误次数等等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bucket</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Points</span> <span class="p">[]</span><span class="kt">float64</span> <span class="c1">// 单个节点中的统计数据（数组）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Count</span>  <span class="kt">int64</span>     <span class="c1">// 总数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">next</span>   <span class="o">*</span><span class="nx">Bucket</span>   <span class="c1">// 链表实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bucket 提供了两种数值添加的接口：Append 和 Add，这两个方法会被上层 Window 的方法调用：</p>
<p>Append 是在 Bucket 的 Points 数组中直接追加数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Append appends the given value to the bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">Points</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">Points</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">Count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Add 是在 Bucket 的 Points 数组中的指定 index 位置累加值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Add adds the given value to the point.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 给 []float64 指定位置累加值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span><span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">Points</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">Count</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bucket 的遍历方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Next returns the next bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 遍历链表用（返回当前 node 的下一个 node）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span><span class="o">*</span><span class="nx">Bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>bucket 提供了 iterator 的封装，用于滑动窗口的遍历。遍历的目的是为了对窗口的数据做提取和计算；比如，计算截至当前时间滑动窗口的请求失败率，就需要遍历从窗口 start 位置到目前时间的所有 Bucket 的错误总数/请求总数。</p>
<h3 id="环形数组-window">环形数组: Window</h3>
<p>Window 的结构，就是 Bucket 组成的 slice：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Window</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">window</span> <span class="p">[]</span><span class="nx">Bucket</span> <span class="c1">// 滑动窗口实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">size</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Window 的初始化逻辑，这里有个细节是将 Bucket 初始化为环形数组（RingQueue）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NewWindow creates a new Window based on WindowOpts.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 初始化滑动窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewWindow</span><span class="p">(</span><span class="nx">opts</span> <span class="nx">WindowOpts</span><span class="p">)</span> <span class="o">*</span><span class="nx">Window</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buckets</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Bucket</span><span class="p">,</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">Size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">offset</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buckets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 初始化每个 bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">buckets</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span> <span class="p">=</span> <span class="nx">Bucket</span><span class="p">{</span><span class="nx">Points</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">float64</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nextOffset</span> <span class="o">:=</span> <span class="nx">offset</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">nextOffset</span> <span class="o">==</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">Size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 构建一个 queue（环）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">nextOffset</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 初始化为一个链表（首尾相接）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">buckets</span><span class="p">[</span><span class="nx">offset</span><span class="p">].</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">nextOffset</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Window</span><span class="p">{</span><span class="nx">window</span><span class="p">:</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">:</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">Size</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样的，Window 的数值添加方法也只是对 Bucket 提供接口的进一步封装：</p>
<p>Window 的 Append 方法：向指定的偏移 offset（位于 offset 位置的 Bucket）添加值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Append appends the given value to the bucket where index equals the given offset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">Window</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用了 Bucket 的 Append 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">w</span><span class="p">.</span><span class="nx">window</span><span class="p">[</span><span class="nx">offset</span><span class="p">].</span><span class="nf">Append</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Window 的 Add 方法：向指定的偏移 offset 的 0 号位置累加值（和 Append 有稍许不同）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Add adds the given value to the latest point within bucket where index equals the given offset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span><span class="o">*</span><span class="nx">Window</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">window</span><span class="p">[</span><span class="nx">offset</span><span class="p">].</span><span class="nx">Count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果 bucket 是空的（没有统计值），直接 Append
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">w</span><span class="p">.</span><span class="nx">window</span><span class="p">[</span><span class="nx">offset</span><span class="p">].</span><span class="nf">Append</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// bucket 非空，在 Point[] 的 0 号位置累加值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">w</span><span class="p">.</span><span class="nx">window</span><span class="p">[</span><span class="nx">offset</span><span class="p">].</span><span class="nf">Add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Window 的迭代器生成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 需要提供传入的 offset 和 count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">Window</span><span class="p">)</span> <span class="nf">Iterator</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Iterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 构建 window 的 Iterator（迭代器），方便统计和遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">Iterator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">count</span><span class="p">:</span> <span class="nx">count</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cur</span><span class="p">:</span>   <span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">window</span><span class="p">[</span><span class="nx">offset</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>迭代器的结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Iterator iterates the buckets within the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Iterator</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">count</span>         <span class="kt">int</span> <span class="c1">// 遍历完成的条件（i.count != i.iteratedCount）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">iteratedCount</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cur</span>           <span class="o">*</span><span class="nx">Bucket</span> <span class="c1">// 当前迭代器的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面 Next 方法，定义了遍历器的退出条件：遍历完 count 个 Bucket（窗口）后完成，其中 iteratedCount 是计数器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 这里很重要，Iter 的迭代规则是，移动 count 的次数 == 当前移动次数
</span></span></span><span class="line"><span class="cl"><span class="c1">// Next returns true util all of the buckets has been iterated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">count</span> <span class="o">!=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">iteratedCount</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bucket 方法，获取当前的 Bucket，并且把指针指向下一个 Bucket</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Bucket gets current bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">)</span> <span class="nf">Bucket</span><span class="p">()</span> <span class="nx">Bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!(</span><span class="nx">i</span><span class="p">.</span><span class="nf">Next</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;stat/metric: iteration out of range iteratedCount: %d count: %d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">.</span><span class="nx">iteratedCount</span><span class="p">,</span> <span class="nx">i</span><span class="p">.</span><span class="nx">count</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucket</span> <span class="o">:=*</span><span class="nx">i</span><span class="p">.</span><span class="nx">cur</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span><span class="p">.</span><span class="nx">iteratedCount</span><span class="o">++</span>	<span class="c1">// 累加计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">i</span><span class="p">.</span><span class="nx">cur</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">cur</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">bucket</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="滑动窗口-rollingpolicy">滑动窗口: RollingPolicy</h3>
<p>在项目中，如何在滑动窗口中加入时间跨度，用来实现滑动窗口结构的实例化？答案就是 Rolling 结构。如下图，一个 Bucket 代表 500ms，一个滑动窗口占据 2 个 Bucket。这是一个非常精妙的数据结构，表现在以下几点：</p>
<ol>
<li>采集到的指标的时效性非常强，系统只需要采集最近一小段时间内关注的 Metrics 即可，对于较老的数据，会自动丢弃</li>
<li>如下图展示的的滑动窗口。整个滑动窗口用来保存最近 1s 的采样数据，每个小的桶用来保存 500ms 的采样数据。当时间流动之后，过期的桶会自动被新桶的数据覆盖掉，在图中，在 1000-1500ms 时，Bucket-1 的数据因为过期而被丢弃，之后 Bucket-3 的数据填到了窗口的头部。（由于在实现上滑动窗口被构造为一个环，所以 Bucket-3 的位置实际上在第 0 号位，即 Bucket-1 的位置）</li>
<li>由于滑动窗口以时间为 key，外部接口调用 Add 方法添加新的指标时，会根据时间跨度将不同（相近）时间戳的指标汇总到一个 “窗口” 中，从而可以使得统计结果更加趋于平滑，不会受到单次统计波动的影响</li>
</ol>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211115195400.png" alt=""></p>
<p>Rolling_policy 中，封装了滑动窗口，加入了互斥锁、单位时间跨度（单个桶）、最后一次更新时间等，使其成为外部可调用的结构体，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">RollingPolicy</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>		<span class="c1">//（子协程）并发的 add 操作必须加锁！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">size</span>   <span class="kt">int</span>			<span class="c1">// 滑动窗口的 size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">window</span> <span class="o">*</span><span class="nx">Window</span>			<span class="c1">// 滑动窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">offset</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">bucketDuration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>		<span class="c1">// 一个桶代表多长时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lastAppendTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>		<span class="c1">// 滑动窗口的 START 位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过，<code>time.Now()- 当前时间</code>、<code>bucketDuration</code> 以及 <code>lastAppendTime</code> 这几项时间因素的关联，是的 <code>RollingPolicy.window</code> 具有了基于时间的滑动窗口的概念。</p>
<p>RollingPolicy 中有 3 个核心方法，分别为 timespan、add 和 Reduce。</p>
<p>下面 timespan() 方法就是计算：当前调用此方法的时刻，距离上一次写入（lastAppendTime）滑过了几个 Bucket</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RollingPolicy</span><span class="p">)</span> <span class="nf">timespan</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">lastAppendTime</span><span class="p">)</span> <span class="o">/</span> <span class="nx">r</span><span class="p">.</span><span class="nx">bucketDuration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span> <span class="c1">// maybe time backwards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 时间调整了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>RollingPolicy 的添加数据方法，分别调用了 window 的 Append 和 Add 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Append appends the given points to the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RollingPolicy</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nx">Append</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Add adds the given value to the latest point within bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RollingPolicy</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nx">Add</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>add 方法：通过计算出当前时间 <code>time.Now()</code> 与 <code>lastAppendTime</code> 的跨度差，在环形滑动窗口中获取正确的位置，然后调用传入的 f 进行插入操作。请注意，跨度超过了 Window 的 End 位置需要从 Start 位置重新计算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RollingPolicy</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">float64</span><span class="p">),</span> <span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 计算时间跨度（跨过了几个 bucket）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timespan</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">timespan</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">timespan</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 当 timespan&gt;0 时，表示有跨度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 更新当前 append 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nx">lastAppendTime</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lastAppendTime</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">timespan</span><span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">bucketDuration</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">offset</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">offset</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// reset the expired buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">offset</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">//s 指向下一个位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">timespan</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 如果跨度超过了 window 的大小，timespan 最大为 window 的 size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">timespan</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">e</span><span class="p">,</span> <span class="nx">e1</span> <span class="o">:=</span> <span class="nx">s</span><span class="o">+</span><span class="nx">timespan</span><span class="p">,</span> <span class="mi">0</span> <span class="c1">// e: reset offset must start from offset+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">e</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">e1</span> <span class="p">=</span> <span class="nx">e</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">			<span class="nx">e</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">e</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 清理 offset1---&gt; s+timespan 的之间的 bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">r</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">ResetBucket</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">offset</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">e1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 如果超过一个跨度，那么说明时间跨度在两个区间上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">r</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">ResetBucket</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">offset</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nx">offset</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 添加到 offset 位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//（当 timespan==0 时，说明，当前时间未出现 span，直接操作 r.offset 位置即可）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">f</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Reduce 方法，非常有意思，它的传入参数是 reduce.go 中定义的求值操作，如 Sum、Avg、Min、Max 和 Couter。 该方法的作用是，在 timespan 这个区间进行遍历，计算遍历的起始位置 offset 和长度 count，会调用上面这个几个方法之一（对遍历的这些 Bucket）进行计算，最终得到 val。比如，求当前时间 time.Now() 到 lastAppendTime 之间，滑动窗口的 Sum 累加值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Reduce applies the reduction function to all buckets within the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RollingPolicy</span><span class="p">)</span> <span class="nf">Reduce</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Iterator</span><span class="p">)</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timespan</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">timespan</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">count</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">timespan</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">offset</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">offset</span> <span class="o">+</span> <span class="nx">timespan</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">offset</span> <span class="o">&gt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">offset</span> <span class="p">=</span> <span class="nx">offset</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 计算得到遍历的开始位置 offset 和遍历长度 count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//f 的参数，就是 Iterator 的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">val</span> <span class="p">=</span> <span class="nf">f</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">Iterator</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">count</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="计数器-rollingcounter">计数器: RollingCounter</h3>
<p>RollingCounter 就是基于滑动窗口的计数器。是 RollingPolicy 的上一层封装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">rollingCounter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">policy</span> <span class="o">*</span><span class="nx">RollingPolicy</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">RollingCounter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Metric</span>			<span class="c1">// with prometheus
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Aggregation</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Timespan</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Reduce applies the reduction function to all buckets within the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Reduce</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">Iterator</span><span class="p">)</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>RollingCounter 的 Add 方法，限制了计数器累加值不能为负数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">rollingCounter</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计数器不能为负数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">val</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;stat/metric: cannot decrease in value. val: %d&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">policy</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="瞬时统计-rollinggauge">瞬时统计: RollingGauge</h3>
<p>RollingGauge 是基于滑动窗口的瞬时数据统计器。它和 RollingCounter 的最大不同是向 Bucket 的 Points 数组，追加数据（Points 数组的每个 index 代表了一种维度的 gauge）。RollingGauge 的结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">rollingGauge</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">policy</span> <span class="o">*</span><span class="nx">RollingPolicy</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// RollingGauge represents a ring window based on time duration.
</span></span></span><span class="line"><span class="cl"><span class="c1">// e.g. [[1, 2], [1, 2, 3], [1,2, 3, 4]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">RollingGauge</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Metric</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Aggregation</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Reduce applies the reduction function to all buckets within the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Reduce</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">Iterator</span><span class="p">)</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>RollingGauge 调用了 Window 的 Append 方法来完成存值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">rollingGauge</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">policy</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Append appends the given points to the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RollingPolicy</span><span class="p">)</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">val</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nx">Append</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="maxpass--minrt">MaxPass &amp;&amp; MinRT</h2>
<p>MaxPass 表示最近 5s 内，单个采样窗口（window）中最大的请求数。换言之，就是找出当前时间戳的滑动窗口的所有桶中，最大的请求计数器的值（单个桶）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 单个采样窗口的最大的请求数, 默认的采样窗口是10s, 采样bucket数量100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">BBR</span><span class="p">)</span> <span class="nf">maxPASS</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rawMaxPass</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">rawMaxPASS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rawMaxPass</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">passStat</span><span class="p">.</span><span class="nf">Timespan</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 当前的时间跨度未超过一个单位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nx">rawMaxPass</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过 Reduce 方法来获取最大的 Pass 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 遍历100个采样bucket, 找到采样bucket中最大的请求数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rawMaxPass</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">passStat</span><span class="p">.</span><span class="nf">Reduce</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">iterator</span> <span class="nx">metric</span><span class="p">.</span><span class="nx">Iterator</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">result</span> <span class="p">=</span> <span class="mf">1.0</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">conf</span><span class="p">.</span><span class="nx">WinBucket</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">count</span> <span class="o">:=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">Points</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 叠加 bucket.Points，注意 Points 的类型是 Points []float64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">count</span> <span class="o">+=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">result</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">result</span>
</span></span><span class="line"><span class="cl">	<span class="p">}))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rawMaxPass</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rawMaxPass</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储在 rawMaxPASS 中并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">rawMaxPASS</span><span class="p">,</span> <span class="nx">rawMaxPass</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">rawMaxPass</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>MinRt 表示最近 5s 内，单个采样窗口中最小的响应时间。windows 表示一秒内采样窗口的数量，默认配置中是 5s 50 个采样，那么 windows 的值为 10。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 单个采样窗口中最小的响应时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">BBR</span><span class="p">)</span> <span class="nf">minRT</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rawMinRT</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">rawMinRt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rawMinRT</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">rtStat</span><span class="p">.</span><span class="nf">Timespan</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">rawMinRT</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 遍历100个采样bucket, 找到采样bucket中最小的响应时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rawMinRT</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">rtStat</span><span class="p">.</span><span class="nf">Reduce</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">iterator</span> <span class="nx">metric</span><span class="p">.</span><span class="nx">Iterator</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">result</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxFloat64</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">conf</span><span class="p">.</span><span class="nx">WinBucket</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">iterator</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">Points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">total</span> <span class="o">:=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">Points</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">total</span> <span class="o">+=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">avg</span> <span class="o">:=</span> <span class="nx">total</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">Count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">result</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">avg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">result</span>
</span></span><span class="line"><span class="cl">	<span class="p">})))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">rawMinRT</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rawMinRT</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">rawMinRt</span><span class="p">,</span> <span class="nx">rawMinRT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">rawMinRT</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="判断规则">判断规则</h2>
<p>我们使用 CPU 的滑动均值(CPU &gt; 800)作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass* rt) &lt; inflight</p>
<p>判断是否丢弃当前请求的算法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">cpu</span> <span class="o">&gt;</span> <span class="m">800</span> <span class="nf">AND </span><span class="p">(</span><span class="n">Now</span> <span class="o">-</span> <span class="n">PrevDrop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">1</span><span class="n">s</span> <span class="n">AND</span> <span class="n">maxFlight</span> <span class="o">&lt;</span> <span class="n">InFlight</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>(Now - PrevDrop) &lt; 1s 表示当前处于冷却时间内,限流效果生效后，CPU 会在临界值(800)附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU。</p>
<p>在冷却时间后，重新判断阈值(CPU &gt; 800 )，是否持续进入过载保护。</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210113213508.png" alt=""></p>
<p>maxInFlight()方法代表过去的负载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">BBR</span><span class="p">)</span> <span class="nf">maxFlight</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nf">maxPASS</span><span class="p">()</span><span class="o">*</span><span class="nx">l</span><span class="p">.</span><span class="nf">minRT</span><span class="p">()</span><span class="o">*</span><span class="nx">l</span><span class="p">.</span><span class="nx">winBucketPerSec</span><span class="p">)</span><span class="o">/</span><span class="mf">1000.0</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>l.maxPass() * bucketPerSecond/1000 为每毫秒处理的请求数</p>
<ul>
<li>l.maxPass() 表示在采样周期内,单个采样窗口的最大的请求数</li>
<li>l.minRT(): 表示在采样周期内,单个采样窗口中最小的响应时间</li>
<li>T ≈ QPS* Avg(RT)</li>
<li>+0.5为向上取整</li>
<li>l.winBucketPerSec: 每秒内的采样桶数量,其计算方式:int64(time.Second)/(int64(conf.Window)/int64(conf.WinBucket)), conf.Window默认值10s, conf.WinBucket默认值100. 简化下公式: 1/(10/100) = 10, 所以每秒内的采样桶数就是10</li>
</ul>
<h2 id="shoulddrop">shouldDrop</h2>
<p>shouldDrop 代码实现了前文的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">BBR</span><span class="p">)</span> <span class="nf">shouldDrop</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断目前cpu的使用率是否达到设置的CPU的限制, 默认值800
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nf">cpu</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">conf</span><span class="p">.</span><span class="nx">CPUThreshold</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果上一次舍弃请求的时间是0, 那么说明没有限流的需求, 直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">prevDrop</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">prevDrop</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">prevDrop</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果上一次请求的时间与当前的请求时间小于1s, 那么说明有限流的需求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">initTime</span><span class="p">)</span><span class="o">-</span><span class="nx">prevDrop</span> <span class="o">&lt;=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">prevDropHit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">prevDropHit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 增加正在处理的请求的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">inFlight</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">inFlight</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 判断正在处理的请求数是否达到系统的最大的请求数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">inFlight</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">inFlight</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nf">maxFlight</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 清空当前的prevDrop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">l</span><span class="p">.</span><span class="nx">prevDrop</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 增加正在处理的请求的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">inFlight</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">.</span><span class="nx">inFlight</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断正在处理的请求数是否达到系统的最大的请求数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">drop</span> <span class="o">:=</span> <span class="nx">inFlight</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">inFlight</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nf">maxFlight</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">drop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">prevDrop</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">prevDrop</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果判断达到了最大请求数量, 并且当前有限流需求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">prevDrop</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">drop</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">prevDrop</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">initTime</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">drop</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="流程图">流程图</h2>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211114230654.png" alt=""></p>
<h2 id="压测报告">压测报告</h2>
<p>场景1，请求以每秒增加1个的速度不停上升，压测效果如下：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20211114223828.png" alt=""></p>
<p>左测是没有限流的压测效果，右侧是带限流的压测效果。可以看到，没有限流的场景里，系统在 700qps 时开始抖动，在 1k qps 时被拖垮，几乎没有新的请求能被放行，然而在使用限流之后，系统请求能够稳定在 600 qps 左右，rt 没有暴增，服务也没有被打垮，可见，限流有效的保护了服务。</p>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/gLsdHw9E7Zp971ZhGXdHFA">Kratos 源码分析 - BBR限流源码实现</a></p>
<p><a href="https://juejin.cn/post/7004848252109455368">从kratos分析BBR限流源码实现</a></p>
<p><a href="https://www.haohongfan.com/posts/2020-07-05-bbr/">限流器系列(3)&ndash;自适应限流</a></p>
<p><a href="https://pandaychen.github.io/2020/05/12/KRATOS-METRICS-ANALYSIS-2/">Kratos 源码分析：理解 Kratos 的数据统计类型 Metrics（二）</a></p>
<p><a href="https://pandaychen.github.io/2020/04/12/KRATOS-METRICS-ANALYSIS/">Kratos 源码分析：理解 Kratos 的数据统计类型 Metrics（一）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1760199">Sentinel系统自适应限流【原理源码】</a></p>
<p><a href="https://www.infoq.cn/article/e6ohg7ljtttwszj0sdhi">深入理解云原生下自适应限流技术原理与应用</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-11-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AFgopsutil/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">获取系统和硬件信息:gopsutil</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9C%8D%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%8E%E5%A4%9A%E9%9B%86%E7%BE%A4%E8%AE%BE%E8%AE%A1/">
            <span class="next-text nav-default">服务隔离与多集群设计</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
