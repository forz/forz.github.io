<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的Finalizer源码剖析 - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="SetFinalizer runtime.SetFinalizer: 1 func SetFinalizer(obj interface{}, finalizer interface{}) 对象可以关联一个SetFinalizer函数， 当gc检测到unreachable对象有关联的SetFinalizer函数时，" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84finalizer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的Finalizer源码剖析" />
<meta property="og:description" content="SetFinalizer runtime.SetFinalizer: 1 func SetFinalizer(obj interface{}, finalizer interface{}) 对象可以关联一个SetFinalizer函数， 当gc检测到unreachable对象有关联的SetFinalizer函数时，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84finalizer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-17T20:50:34+00:00" />
<meta property="article:modified_time" content="2022-02-17T20:50:34+00:00" />

<meta itemprop="name" content="Go的Finalizer源码剖析">
<meta itemprop="description" content="SetFinalizer runtime.SetFinalizer: 1 func SetFinalizer(obj interface{}, finalizer interface{}) 对象可以关联一个SetFinalizer函数， 当gc检测到unreachable对象有关联的SetFinalizer函数时，"><meta itemprop="datePublished" content="2022-02-17T20:50:34+00:00" />
<meta itemprop="dateModified" content="2022-02-17T20:50:34+00:00" />
<meta itemprop="wordCount" content="10691">
<meta itemprop="keywords" content="Go源码," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的Finalizer源码剖析"/>
<meta name="twitter:description" content="SetFinalizer runtime.SetFinalizer: 1 func SetFinalizer(obj interface{}, finalizer interface{}) 对象可以关联一个SetFinalizer函数， 当gc检测到unreachable对象有关联的SetFinalizer函数时，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的Finalizer源码剖析</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-17 </span>
        <div class="post-category">
            <a href="/categories/go%E6%BA%90%E7%A0%81/"> Go源码 </a>
            </div>
          <span class="more-meta"> 约 10691 字 </span>
          <span class="more-meta"> 预计阅读 22 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#setfinalizer">SetFinalizer</a>
      <ul>
        <li><a href="#无保障性">无保障性</a></li>
        <li><a href="#工作流">工作流</a></li>
        <li><a href="#性能表现">性能表现</a></li>
      </ul>
    </li>
    <li><a href="#结构概览">结构概览</a></li>
    <li><a href="#全局变量">全局变量</a></li>
    <li><a href="#setfinalizer-1">SetFinalizer</a>
      <ul>
        <li><a href="#removefinalizer">removefinalizer</a></li>
        <li><a href="#addfinalizer">addfinalizer</a></li>
      </ul>
    </li>
    <li><a href="#createfing">createfing</a></li>
    <li><a href="#finq中插入finalizer">finq中插入finalizer</a>
      <ul>
        <li><a href="#sweep">sweep</a></li>
        <li><a href="#freespecial">freespecial</a></li>
      </ul>
    </li>
    <li><a href="#唤醒fing">唤醒fing</a>
      <ul>
        <li><a href="#findrunnable">findrunnable</a></li>
        <li><a href="#wakefing">wakefing</a></li>
      </ul>
    </li>
    <li><a href="#标准库应用">标准库应用</a></li>
    <li><a href="#业务场景">业务场景</a></li>
    <li><a href="#弊端">弊端</a>
      <ul>
        <li><a href="#runtimekeepalive">runtime.KeepAlive</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="setfinalizer">SetFinalizer</h2>
<p>runtime.SetFinalizer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">finalizer</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对象可以关联一个SetFinalizer函数， 当gc检测到unreachable对象有关联的SetFinalizer函数时，会执行关联的SetFinalizer函数， 同时取消关联。 这样当下一次gc的时候，对象重新处于unreachable状态并且没有SetFinalizer关联， 就会被回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// i 就是后面说的 数据对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里的func 就是后面一直说的 finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="o">*</span><span class="nx">i</span><span class="p">,</span> <span class="s">&#34;set finalizer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>SetFinalizer将x的终止器设置为f。当垃圾收集器发现一个不能接触的（即引用计数为零，程序中不能再直接或间接访问该对象）具有终止器的块时，它会清理该关联（对象到终止器）并在独立go程调用f(x)。这使x再次可以接触，但没有了绑定的终止器。如果SetFinalizer没有被再次调用，下一次垃圾收集器将视x为不可接触的，并释放x。</p>
<p><code>SetFinalizer(x, nil)</code>会清理任何绑定到x的终止器。</p>
<p>参数x必须是一个指向通过new申请的对象的指针，或者通过对复合字面值取址得到的指针。参数f必须是一个函数，它接受单个可以直接用x类型值赋值的参数，也可以有任意个被忽略的返回值。如果这两条任一条不被满足，本函数就会中断程序。</p>
<p>终止器会按依赖顺序执行：如果A指向B，两者都有终止器，且它们无法从其它方面接触，只有A的终止器执行；A被释放后，B的终止器就可以执行。如果一个循环结构包含一个具有终止器的块，该循环不能保证会被当垃圾收集，终止器也不能保证会执行；因为没有尊重依赖关系的顺序。</p>
<p>仔细看文档，还有几个需要注意的点：</p>
<ul>
<li>
<p>即使程序正常结束或者发生错误， 但是在对象被 gc 选中并被回收之前，SetFinalizer 都不会执行， 所以不要在SetFinalizer中执行将内存中的内容flush到磁盘这种操作</p>
</li>
<li>
<p>SetFinalizer 最大的问题是延长了对象生命周期。在第一次回收时执行 Finalizer 函数，且目标对象重新变成可达状态，直到第二次才真正 “销毁”。这对于有大量对象分配的高并发算法，可能会造成很大麻烦</p>
</li>
<li>
<p>指针构成的 &ldquo;循环引⽤&rdquo; 加上 <code>runtime.SetFinalizer</code> 会导致内存泄露</p>
</li>
</ul>
<h3 id="无保障性">无保障性</h3>
<p>x的终止器会在x变为不可接触之后的任意时间被调度执行。不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个<code>os.File</code>对象时没有调用其Close方法，该os.File对象可以使用终止器去关闭对应的操作系统文件描述符。但依靠终止器去刷新内存中的I/O缓冲如bufio.Writer是错误的，因为缓冲不会在程序退出时被刷新。</p>
<p>如果<code>*x</code>的大小为0字节，不保证终止器会执行。</p>
<p>举一个使用了 Finalizer 的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;math/rand&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">a</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span> <span class="o">:=</span> <span class="nf">NewFoo</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//go:noinline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewFoo</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">f</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Foo</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">50</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span><span class="o">*</span><span class="nx">Foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">`foo`</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">`has been garbage collected`</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段程序将会在这个循环中创建三个 struct 的的实例，并将每个实例都绑定一个 finalizer。之后垃圾回收器将会被调用,并回收之前创建的实例。运行这个程序，将会给到我们如下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="m">31</span>
</span></span><span class="line"><span class="cl"><span class="m">37</span>
</span></span><span class="line"><span class="cl"><span class="m">47</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在程序无法获取到一个 obj 所指向的对象后的任意时刻，finalizer 被调度运行，且无法保证 finalizer 运行在程序退出之前。因此一般情况下，因此它们仅用于在长时间运行的程序上释放一些与对象关联的非内存资源。</p>
<p>在调用 finalizer 之前，runtime 不提供有关延迟的任何保证。让我们试着去修改我们的程序，通过在调用垃圾回收器之后添加一个一秒的 sleep:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="m">31</span>
</span></span><span class="line"><span class="cl"><span class="m">37</span>
</span></span><span class="line"><span class="cl"><span class="m">47</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span> <span class="m">1</span> <span class="n">has</span> <span class="n">been</span> <span class="n">garbage</span> <span class="n">collected</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span> <span class="m">0</span> <span class="n">has</span> <span class="n">been</span> <span class="n">garbage</span> <span class="n">collected</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们的 finalizer 已经被调用了，然而，它们其中一个消失了。我们的 finalizers 与垃圾回收器相连接，并且垃圾回收器回收以及清理数据的方式将会对 finalizers 的调用产生影响。</p>
<h3 id="工作流">工作流</h3>
<p>之前的例子可能让我认为 Go 仅在释放我们所定义的 struct 的内存之前调用 finalizers。</p>
<p>让我们深入其中，看看在更多的 Allocation 中到底发生了些什么。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;math/rand&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;runtime/debug&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Foo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">a</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">debug</span><span class="p">.</span><span class="nf">SetGCPercent</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="kd">var</span> <span class="nx">ms</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl"> <span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ms</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Allocation: %f Mb, Number of allocation: %d\n&#34;</span><span class="p">,</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">ms</span><span class="p">.</span><span class="nx">HeapAlloc</span><span class="p">)</span><span class="o">/</span><span class="nb">float32</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1204</span><span class="p">),</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">HeapObjects</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span> <span class="o">:=</span> <span class="nf">NewFoo</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ms</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Allocation: %f Mb, Number of allocation: %d\n&#34;</span><span class="p">,</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">ms</span><span class="p">.</span><span class="nx">HeapAlloc</span><span class="p">)</span><span class="o">/</span><span class="nb">float32</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1204</span><span class="p">),</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">HeapObjects</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"> <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ms</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Allocation: %f Mb, Number of allocation: %d\n&#34;</span><span class="p">,</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">ms</span><span class="p">.</span><span class="nx">HeapAlloc</span><span class="p">)</span><span class="o">/</span><span class="nb">float32</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1204</span><span class="p">),</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">HeapObjects</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"> <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//go:noinline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewFoo</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">f</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Foo</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">50</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span><span class="o">*</span><span class="nx">Foo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;foo &#34;</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34; has been garbage collected&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一百万个 structs 和 finalizers 被创建出来，下面是输出:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">0.090862</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">137</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">31.107506</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">2390078</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">110.052666</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">4472742</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>让我们再试一次，这次不用 finalizers:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">0.090694</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">136</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">18.129814</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">1390078</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">0.094451</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">154</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看起来没有任何资源在内存中被清理掉，即使垃圾回收器被触发，且 finalizers 也运行。为了理解这一行为，让我们回到那篇关于 runtime 的文档:</p>
<p>当垃圾回收器发现了一个已关联 finalizer 的无法访问的块，这说明了关联操作与运行 finalizer 是在一个单独的 gorountine 下。这让 obj 再次可访问，不过现在没有了一个关联的 finalizer,假设 SetFinalizer 没有再次被调用，当下次垃圾回收器看到这个 obj 时，它是不可被访问的，并将回收它。</p>
<p>如我们所见，finalizers 首先会被移除，然后内存将在下一次循环中被释放，让我们再次运行第一个例子，并加上两个强制的垃圾回收操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">0.090862</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">137</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">31.107506</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">2390078</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">110.052666</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">4472742</span>
</span></span><span class="line"><span class="cl"><span class="n">Allocation</span><span class="o">:</span> <span class="m">0.099220</span> <span class="n">Mb</span><span class="p">,</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">allocation</span><span class="o">:</span> <span class="m">166</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以清楚地看到，第二次运行将会清理数据，finalizers 最终也对性能和内存使用产生了轻微的作用。</p>
<h3 id="性能表现">性能表现</h3>
<p>下文阐述了为何 finalizers 逐个运行：</p>
<p>一个单独 Goroutine 为了一个程序运行了所有的 finalizers,然而，如果一个 finalizer 必须长时间运行，则需要开启一个新的 gorountine。</p>
<p>仅一个 Goroutine 将会运行 finalizers，并且任何超重任务都需要开启一个新的 gorountine。当 finalizers 运行时，垃圾回收器并没有停止且并发运行中。因此 finalizer 并不该影响你的应用的性能表现。</p>
<p>同时，一旦 finalizer 不再被需要，Go 提供了一个方法来移除它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它允许我们根据使用情况动态地移除 finalizers。</p>
<h2 id="结构概览">结构概览</h2>
<p>heap:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前span上所有对象的special串成链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// special中有个offset，就是数据对象在span上的offset，通过offset，将数据对象和special关联起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">specials</span>    <span class="o">*</span><span class="nx">special</span>   <span class="c1">// linked list of special records sorted by offset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>special:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//go:notinheap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">special</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">next</span>   <span class="o">*</span><span class="nx">special</span> <span class="c1">// linked list in span
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 数据对象在span上的offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">offset</span> <span class="kt">uint16</span>   <span class="c1">// span offset of object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">kind</span>   <span class="kt">byte</span>     <span class="c1">// kind of special
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>specialfinalizer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The described object has a finalizer set for it.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// specialfinalizer is allocated from non-GC&#39;d memory, so any heap
</span></span></span><span class="line"><span class="cl"><span class="c1">// pointers must be specially handled.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:notinheap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">specialfinalizer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">special</span> <span class="nx">special</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fn</span>      <span class="o">*</span><span class="nx">funcval</span> <span class="c1">// May be a heap pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// return的数据的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nret</span>    <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 第一个参数的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fint</span>    <span class="o">*</span><span class="nx">_type</span>   <span class="c1">// May be a heap pointer, but always live.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 与finalizer关联的数据对象的指针类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ot</span>      <span class="o">*</span><span class="nx">ptrtype</span> <span class="c1">// May be a heap pointer, but always live.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>finalizer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NOTE: Layout known to queuefinalizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">finalizer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fn</span>   <span class="o">*</span><span class="nx">funcval</span>       <span class="c1">// function to call (may be a heap pointer)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">arg</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// ptr to object (may be a heap pointer)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nret</span> <span class="kt">uintptr</span>        <span class="c1">// bytes of return values from fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fint</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// type of first argument of fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ot</span>   <span class="o">*</span><span class="nx">ptrtype</span>       <span class="c1">// type of ptr to object (may be a heap pointer)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="全局变量">全局变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">finlock</span> <span class="nx">mutex</span>  <span class="c1">// protects the following variables
</span></span></span><span class="line"><span class="cl"><span class="c1">// 运行finalizer的g，只有一个g，不用的时候休眠，需要的时候再唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">fing</span><span class="o">*</span><span class="nx">g</span>        <span class="c1">// goroutine that runs finalizers
</span></span></span><span class="line"><span class="cl"><span class="c1">// finalizer的全局队列，这里是已经设置的finalizer串成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">finq</span><span class="o">*</span><span class="nx">finblock</span> <span class="c1">// list of finalizers that are to be executed
</span></span></span><span class="line"><span class="cl"><span class="c1">// 已经释放的finblock的链表，用finc缓存起来，以后需要使用的时候可以直接取走，避免再走一遍内存分配了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">finc</span><span class="o">*</span><span class="nx">finblock</span> <span class="c1">// cache of free blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">finptrmask</span> <span class="p">[</span><span class="nx">_FinBlockSize</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">fingwait</span> <span class="kt">bool</span>  <span class="c1">// fing的标志位，通过 fingwait和fingwake，来确定是否需要唤醒fing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">fingwake</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 所有的blocks串成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">allfin</span><span class="o">*</span><span class="nx">finblock</span> <span class="c1">// list of all blocks
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="setfinalizer-1">SetFinalizer</h2>
<p>根据 数据对象 ，生成一个<code>special</code>对象，并绑定到 数据对象 所在的span，串联到<code>span.specials</code>上，并且确保fing的存在</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// SetFinalizer sets the finalizer associated with obj to the provided
</span></span></span><span class="line"><span class="cl"><span class="c1">// finalizer function. When the garbage collector finds an unreachable block
</span></span></span><span class="line"><span class="cl"><span class="c1">// with an associated finalizer, it clears the association and runs
</span></span></span><span class="line"><span class="cl"><span class="c1">// finalizer(obj) in a separate goroutine. This makes obj reachable again,
</span></span></span><span class="line"><span class="cl"><span class="c1">// but now without an associated finalizer. Assuming that SetFinalizer
</span></span></span><span class="line"><span class="cl"><span class="c1">// is not called again, the next time the garbage collector sees
</span></span></span><span class="line"><span class="cl"><span class="c1">// that obj is unreachable, it will free obj.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// SetFinalizer(obj, nil) clears any finalizer associated with obj.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The argument obj must be a pointer to an object allocated by calling
</span></span></span><span class="line"><span class="cl"><span class="c1">// new, by taking the address of a composite literal, or by taking the
</span></span></span><span class="line"><span class="cl"><span class="c1">// address of a local variable.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The argument finalizer must be a function that takes a single argument
</span></span></span><span class="line"><span class="cl"><span class="c1">// to which obj&#39;s type can be assigned, and can have arbitrary ignored return
</span></span></span><span class="line"><span class="cl"><span class="c1">// values. If either of these is not true, SetFinalizer may abort the
</span></span></span><span class="line"><span class="cl"><span class="c1">// program.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Finalizers are run in dependency order: if A points at B, both have
</span></span></span><span class="line"><span class="cl"><span class="c1">// finalizers, and they are otherwise unreachable, only the finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1">// for A runs; once A is freed, the finalizer for B can run.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If a cyclic structure includes a block with a finalizer, that
</span></span></span><span class="line"><span class="cl"><span class="c1">// cycle is not guaranteed to be garbage collected and the finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1">// is not guaranteed to run, because there is no ordering that
</span></span></span><span class="line"><span class="cl"><span class="c1">// respects the dependencies.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The finalizer is scheduled to run at some arbitrary time after the
</span></span></span><span class="line"><span class="cl"><span class="c1">// program can no longer reach the object to which obj points.
</span></span></span><span class="line"><span class="cl"><span class="c1">// There is no guarantee that finalizers will run before a program exits,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so typically they are useful only for releasing non-memory resources
</span></span></span><span class="line"><span class="cl"><span class="c1">// associated with an object during a long-running program.
</span></span></span><span class="line"><span class="cl"><span class="c1">// For example, an os.File object could use a finalizer to close the
</span></span></span><span class="line"><span class="cl"><span class="c1">// associated operating system file descriptor when a program discards
</span></span></span><span class="line"><span class="cl"><span class="c1">// an os.File without calling Close, but it would be a mistake
</span></span></span><span class="line"><span class="cl"><span class="c1">// to depend on a finalizer to flush an in-memory I/O buffer such as a
</span></span></span><span class="line"><span class="cl"><span class="c1">// bufio.Writer, because the buffer would not be flushed at program exit.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is not guaranteed that a finalizer will run if the size of *obj is
</span></span></span><span class="line"><span class="cl"><span class="c1">// zero bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is not guaranteed that a finalizer will run for objects allocated
</span></span></span><span class="line"><span class="cl"><span class="c1">// in initializers for package-level variables. Such objects may be
</span></span></span><span class="line"><span class="cl"><span class="c1">// linker-allocated, not heap-allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A finalizer may run as soon as an object becomes unreachable.
</span></span></span><span class="line"><span class="cl"><span class="c1">// In order to use finalizers correctly, the program must ensure that
</span></span></span><span class="line"><span class="cl"><span class="c1">// the object is reachable until it is no longer required.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Objects stored in global variables, or that can be found by tracing
</span></span></span><span class="line"><span class="cl"><span class="c1">// pointers from a global variable, are reachable. For other objects,
</span></span></span><span class="line"><span class="cl"><span class="c1">// pass the object to a call of the KeepAlive function to mark the
</span></span></span><span class="line"><span class="cl"><span class="c1">// last point in the function where the object must be reachable.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// For example, if p points to a struct, such as os.File, that contains
</span></span></span><span class="line"><span class="cl"><span class="c1">// a file descriptor d, and p has a finalizer that closes that file
</span></span></span><span class="line"><span class="cl"><span class="c1">// descriptor, and if the last use of p in a function is a call to
</span></span></span><span class="line"><span class="cl"><span class="c1">// syscall.Write(p.d, buf, size), then p may be unreachable as soon as
</span></span></span><span class="line"><span class="cl"><span class="c1">// the program enters syscall.Write. The finalizer may run at that moment,
</span></span></span><span class="line"><span class="cl"><span class="c1">// closing p.d, causing syscall.Write to fail because it is writing to
</span></span></span><span class="line"><span class="cl"><span class="c1">// a closed file descriptor (or, worse, to an entirely different
</span></span></span><span class="line"><span class="cl"><span class="c1">// file descriptor opened by a different goroutine). To avoid this problem,
</span></span></span><span class="line"><span class="cl"><span class="c1">// call runtime.KeepAlive(p) after the call to syscall.Write.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A single goroutine runs all finalizers for a program, sequentially.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If a finalizer must run for a long time, it should do so by starting
</span></span></span><span class="line"><span class="cl"><span class="c1">// a new goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">finalizer</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">sbrk</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// debug.sbrk never frees memory, so no finalizers run
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// (and we don&#39;t have the data structures to record them).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nf">efaceOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">etyp</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">_type</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">etyp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: first argument is nil&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">etyp</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindMask</span> <span class="o">!=</span> <span class="nx">kindPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: first argument is &#34;</span> <span class="o">+</span> <span class="nx">etyp</span><span class="p">.</span><span class="nb">string</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;, not pointer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ---- 省略数据校验的逻辑 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ot</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">ptrtype</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">etyp</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ot</span><span class="p">.</span><span class="nx">elem</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;nil elem type!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// find the containing object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 在内存中找不到分配的地址时 base==0，setFinalizer 是在内存回收的时候调用，没有分配就不会回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">base</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 0-length objects are okay.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span> <span class="o">==</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Global initializers might be linker-allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//	var Foo = &amp;Object{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//	func main() {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//		runtime.SetFinalizer(Foo, nil)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//	}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// The relevant segments are: noptrdata, data, bss, noptrbss.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// We cannot assume they are in any order or even contiguous,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// due to external linking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">firstmoduledata</span><span class="p">;</span> <span class="nx">datap</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">datap</span> <span class="p">=</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">noptrdata</span> <span class="o">&lt;=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">enoptrdata</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="nx">datap</span><span class="p">.</span><span class="nx">data</span> <span class="o">&lt;=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span> <span class="o">&lt;=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">				<span class="nx">datap</span><span class="p">.</span><span class="nx">noptrbss</span> <span class="o">&lt;=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">enoptrbss</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: pointer not in allocated block&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// As an implementation detail we allow to set finalizers for an inner byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// of an object if it could come from tiny alloc (see mallocgc for details).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">ot</span><span class="p">.</span><span class="nx">elem</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">ot</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">ot</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: pointer not at beginning of allocated block&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">efaceOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finalizer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ftyp</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">_type</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果 finalizer type == nil，尝试移除（没有的话，就不需要移除了）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">ftyp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// switch to system stack and remove finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">removefinalizer</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// --- 对finalizer参数数量及类型进行校验 --
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">ftyp</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindMask</span> <span class="o">!=</span> <span class="nx">kindFunc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: second argument is &#34;</span> <span class="o">+</span> <span class="nx">ftyp</span><span class="p">.</span><span class="nb">string</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;, not a function&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ft</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">functype</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ftyp</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ft</span><span class="p">.</span><span class="nf">dotdotdot</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: cannot pass &#34;</span> <span class="o">+</span> <span class="nx">etyp</span><span class="p">.</span><span class="nb">string</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; to finalizer &#34;</span> <span class="o">+</span> <span class="nx">ftyp</span><span class="p">.</span><span class="nb">string</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; because dotdotdot&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ft</span><span class="p">.</span><span class="nx">inCount</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: cannot pass &#34;</span> <span class="o">+</span> <span class="nx">etyp</span><span class="p">.</span><span class="nb">string</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; to finalizer &#34;</span> <span class="o">+</span> <span class="nx">ftyp</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fint</span> <span class="o">:=</span> <span class="nx">ft</span><span class="p">.</span><span class="nf">in</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">fint</span> <span class="o">==</span> <span class="nx">etyp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ok - same type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">goto</span> <span class="nx">okarg</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">fint</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindMask</span> <span class="o">==</span> <span class="nx">kindPtr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nx">fint</span><span class="p">.</span><span class="nf">uncommon</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">etyp</span><span class="p">.</span><span class="nf">uncommon</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="nx">ptrtype</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fint</span><span class="p">)).</span><span class="nx">elem</span> <span class="o">==</span> <span class="nx">ot</span><span class="p">.</span><span class="nx">elem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// ok - not same type, but both pointers,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// one or the other is unnamed, and same element type, so assignable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">goto</span> <span class="nx">okarg</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">fint</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindMask</span> <span class="o">==</span> <span class="nx">kindInterface</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ityp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">interfacetype</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fint</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ityp</span><span class="p">.</span><span class="nx">mhdr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// ok - satisfies empty interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">goto</span> <span class="nx">okarg</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">iface</span> <span class="o">:=</span> <span class="nf">assertE2I2</span><span class="p">(</span><span class="nx">ityp</span><span class="p">,</span> <span class="o">*</span><span class="nf">efaceOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">obj</span><span class="p">));</span> <span class="nx">iface</span><span class="p">.</span><span class="nx">tab</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="nx">okarg</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: cannot pass &#34;</span> <span class="o">+</span> <span class="nx">etyp</span><span class="p">.</span><span class="nb">string</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; to finalizer &#34;</span> <span class="o">+</span> <span class="nx">ftyp</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="nx">okarg</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// compute size needed for return parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 计算返回参数的大小并进行对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nret</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ft</span><span class="p">.</span><span class="nf">out</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nret</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">nret</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">align</span><span class="p">))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nret</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">nret</span><span class="p">,</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// make sure we have a finalizer goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 确保 finalizer 有一个 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">createfing</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		 <span class="c1">// 切换到g0，添加finalizer，并且不能重复设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">addfinalizer</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">funcval</span><span class="p">)(</span><span class="nx">f</span><span class="p">.</span><span class="nx">data</span><span class="p">),</span> <span class="nx">nret</span><span class="p">,</span> <span class="nx">fint</span><span class="p">,</span> <span class="nx">ot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime.SetFinalizer: finalizer already set&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里逻辑没什么复杂的，只是在参数、类型的判断等上面，比较的麻烦</p>
<h3 id="removefinalizer">removefinalizer</h3>
<p>通过removespecial，找到数据对象p所对应的special对象，如果找到的话，释放mheap上对应的内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Removes the finalizer (if any) from the object p.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">removefinalizer</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	 <span class="c1">// 根据数据p找到对应的special对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">specialfinalizer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">removespecial</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">_KindSpecialFinalizer</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="c1">// there wasn&#39;t a finalizer to remove
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 释放找到的special所对应的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的函数，虽然叫removefinalizer， 但是这里暂时跟finalizer结构体没有关系，都是在跟special结构体打交道，后面的addfinalizer也是一样的</p>
<p>removespecial遍历数据所在的span的specials，如果找到了指定数据p的special的话，就从specials中移除，并返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Removes the Special record of the given kind for the object p.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns the record if the record existed, nil otherwise.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The caller must FixAlloc_Free the result.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">removespecial</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">kind</span> <span class="kt">uint8</span><span class="p">)</span> <span class="o">*</span><span class="nx">special</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 找到数据p所在的span
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">span</span> <span class="o">:=</span> <span class="nf">spanOfHeap</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">span</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;removespecial on invalid pointer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ensure that the span is swept.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Sweeping accesses the specials list w/o locks, so we have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to synchronize with it. And it&#39;s just much safer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 保证span被清扫过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">span</span><span class="p">.</span><span class="nf">ensureSwept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取数据p的偏移量，根据偏移量去寻找p对应的special
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">offset</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">-</span> <span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">result</span> <span class="o">*</span><span class="nx">special</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">specials</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 遍历span.specials这个链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">t</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// This function is used for finalizers only, so we don&#39;t check for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// &#34;interior&#34; specials (p must be exactly equal to s-&gt;offset).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">offset</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">kind</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 找到了，修改指针，将当前找到的special移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="o">*</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">			<span class="nx">result</span> <span class="p">=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">t</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">span</span><span class="p">.</span><span class="nx">specials</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">spanHasNoSpecials</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">result</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="addfinalizer">addfinalizer</h3>
<p>正好跟removefinalizer相反，这个就是根据数据对象p，创建对应的special，然后添加到span.specials链表上面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Adds a finalizer to the object p. Returns true if it succeeded.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">addfinalizer</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">f</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">nret</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">fint</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">ot</span> <span class="o">*</span><span class="nx">ptrtype</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 分配出来一块内存供finalizer使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">specialfinalizer</span><span class="p">)(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">special</span><span class="p">.</span><span class="nx">kind</span> <span class="p">=</span> <span class="nx">_KindSpecialFinalizer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">nret</span> <span class="p">=</span> <span class="nx">nret</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">fint</span> <span class="p">=</span> <span class="nx">fint</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">ot</span> <span class="p">=</span> <span class="nx">ot</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">addspecial</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">special</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// This is responsible for maintaining the same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// GC-related invariants as markrootSpans in any
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// situation where it&#39;s possible that markrootSpans
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// has already run but mark termination hasn&#39;t yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">base</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Mark everything reachable from the object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// so it&#39;s retained for the finalizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">scanobject</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Mark the finalizer itself, since the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// special isn&#39;t part of the GC&#39;d heap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">fn</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// There was an old finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 没有添加成功，是因为p已经有了一个special对象了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>addspecial添加special的主逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Adds the special record s to the list of special records for
</span></span></span><span class="line"><span class="cl"><span class="c1">// the object p. All fields of s should be filled in except for
</span></span></span><span class="line"><span class="cl"><span class="c1">// offset &amp; next, which this routine will fill in.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns true if the special was successfully added, false otherwise.
</span></span></span><span class="line"><span class="cl"><span class="c1">// (The add will fail only if a record with the same p and s-&gt;kind
</span></span></span><span class="line"><span class="cl"><span class="c1">//  already exists.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">addspecial</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">special</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">span</span> <span class="o">:=</span> <span class="nf">spanOfHeap</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">span</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;addspecial on invalid pointer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ensure that the span is swept.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Sweeping accesses the specials list w/o locks, so we have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to synchronize with it. And it&#39;s just much safer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 同 removerspecial一样，确保这个span已经清扫过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">span</span><span class="p">.</span><span class="nf">ensureSwept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">offset</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">-</span> <span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">kind</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">kind</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Find splice point, check for existing record.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">specials</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">t</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">offset</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">kind</span> <span class="o">==</span> <span class="nx">x</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 已经存在了，不能在增加了，一个数据对象，只能绑定一个finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span> <span class="c1">// already exists
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">offset</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">offset</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">kind</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">kind</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">t</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Splice in record, fill in offset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 添加到 specials 队列尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">offset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">*</span><span class="nx">t</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="nf">spanHasSpecials</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">span</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="createfing">createfing</h2>
<p>这个函数是保证，创建了finalizer之后，有一个goroutine去运行，这里只运行一次，这个goroutine会由全局变量 fing 记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">createfing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个goroutine，时刻监控运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// start the finalizer goroutine exactly once
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">fingCreate</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fingCreate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 开启一个goroutine运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">go</span> <span class="nf">runfinq</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来就分析一下执行流程runfinq吧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// This is the goroutine that runs all of the finalizers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">runfinq</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">frame</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">		<span class="nx">framecap</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">		<span class="nx">argRegs</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获取finq 全局队列，并清空全局队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fb</span> <span class="o">:=</span> <span class="nx">finq</span>
</span></span><span class="line"><span class="cl">		<span class="nx">finq</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">fb</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 如果全局队列为空，休眠当前g，等待被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fing</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 设置fing的状态标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fingwait</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">,</span> <span class="nx">waitReasonFinalizerWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">argRegs</span> <span class="p">=</span> <span class="nx">intArgRegs</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racefingo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 循环执行runq链表里的fin数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">fb</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">cnt</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">f</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="kd">var</span> <span class="nx">regs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegArgs</span>
</span></span><span class="line"><span class="cl">				<span class="kd">var</span> <span class="nx">framesz</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">argRegs</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// The args can always be passed in registers if they&#39;re
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// available, because platforms we support always have no
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// argument registers available, or more than 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// But unfortunately because we can have an arbitrary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// amount of returns and it would be complex to try and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// figure out how many of those can get passed in registers,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// just conservatively assume none of them do.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">framesz</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">nret</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// Need to pass arguments on the stack too.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// 获取存储当前finalizer的返回数据的大小，如果比之前大，则分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">framesz</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">((</span><span class="kd">interface</span><span class="p">{})(</span><span class="kc">nil</span><span class="p">))</span> <span class="o">+</span> <span class="nx">f</span><span class="p">.</span><span class="nx">nret</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">framecap</span> <span class="p">&lt;</span> <span class="nx">framesz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// The frame does not contain pointers interesting for GC,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// all not yet finalized objects are stored in finq.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// If we do not mark it as FlagNoScan,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// the last finalized object is not collected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">frame</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">framesz</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nx">framecap</span> <span class="p">=</span> <span class="nx">framesz</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">fint</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;missing type in runfinq&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">r</span> <span class="o">:=</span> <span class="nx">frame</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">argRegs</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">r</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">regs</span><span class="p">.</span><span class="nx">Ints</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// frame is effectively uninitialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// memory. That means we have to clear
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// it before writing to it to avoid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// confusing the write barrier.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// 清空frame内存存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">frame</span><span class="p">)</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">switch</span> <span class="nx">f</span><span class="p">.</span><span class="nx">fint</span><span class="p">.</span><span class="nx">kind</span> <span class="o">&amp;</span> <span class="nx">kindMask</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">kindPtr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// direct use of pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">r</span><span class="p">)</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">arg</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">kindInterface</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ityp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">interfacetype</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">fint</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// set up with empty interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="p">(</span><span class="o">*</span><span class="nx">eface</span><span class="p">)(</span><span class="nx">r</span><span class="p">).</span><span class="nx">_type</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">ot</span><span class="p">.</span><span class="nf">typ</span>
</span></span><span class="line"><span class="cl">					<span class="p">(</span><span class="o">*</span><span class="nx">eface</span><span class="p">)(</span><span class="nx">r</span><span class="p">).</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">arg</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ityp</span><span class="p">.</span><span class="nx">mhdr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="c1">// convert to interface with methods
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">// this conversion is guaranteed to succeed - we checked in SetFinalizer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="p">(</span><span class="o">*</span><span class="nx">iface</span><span class="p">)(</span><span class="nx">r</span><span class="p">).</span><span class="nx">tab</span> <span class="p">=</span> <span class="nf">assertE2I</span><span class="p">(</span><span class="nx">ityp</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">eface</span><span class="p">)(</span><span class="nx">r</span><span class="p">).</span><span class="nx">_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad kind in runfinq&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 调用finalizer函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">fingRunning</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">				<span class="nf">reflectcall</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">frame</span><span class="p">,</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">framesz</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">framesz</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">framesz</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">regs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fingRunning</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="c1">// Drop finalizer queue heap references
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// before hiding them from markroot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// This also ensures these will be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// clear if we reuse the finalizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// 清空finalizer的属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">f</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="nx">f</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="nx">f</span><span class="p">.</span><span class="nx">ot</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">cnt</span><span class="p">,</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 将已经完成的finalizer放入finc以作缓存，避免再次分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">next</span> <span class="o">:=</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fb</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">finc</span>
</span></span><span class="line"><span class="cl">			<span class="nx">finc</span> <span class="p">=</span> <span class="nx">fb</span>
</span></span><span class="line"><span class="cl">			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fb</span> <span class="p">=</span> <span class="nx">next</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="finq中插入finalizer">finq中插入finalizer</h2>
<h3 id="sweep">sweep</h3>
<p>在sweep 中有下面一段函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">sweep</span><span class="p">(</span><span class="nx">preserve</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="nx">specialp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">specials</span>
</span></span><span class="line"><span class="cl"><span class="nx">special</span> <span class="o">:=*</span><span class="nx">specialp</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">special</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="o">||</span> <span class="p">!</span><span class="nx">hasFin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Splice out special record.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">y</span> <span class="o">:=</span> <span class="nx">special</span>
</span></span><span class="line"><span class="cl">            <span class="nx">special</span> <span class="p">=</span> <span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span><span class="nx">specialp</span> <span class="p">=</span> <span class="nx">special</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 加入全局finq队列的入口就在这里了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">freespecial</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="freespecial">freespecial</h3>
<p>在gc的时候，不仅要把special对应的内存释放掉，而且把specials整理创建对应dinalizer对象，并插入到 finq队列里面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// freeSpecial performs any cleanup on special s and deallocates it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// s must already be unlinked from the specials list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">freeSpecial</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">special</span><span class="p">,</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">s</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">_KindSpecialFinalizer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 把这个finalizer加入到全局队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">sf</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">specialfinalizer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">queuefinalizer</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">nret</span><span class="p">,</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">fint</span><span class="p">,</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">ot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 下面两种情况不在分析范围内，省略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">case</span> <span class="nx">_KindSpecialProfile</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">specialprofile</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mProf_Free</span><span class="p">(</span><span class="nx">sp</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">specialprofilealloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">_KindSpecialReachable</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sp</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">specialReachable</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sp</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The creator frees these.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad special kind&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not reached&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">queuefinalizer</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">nret</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">fint</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">ot</span> <span class="o">*</span><span class="nx">ptrtype</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Currently we assume that the finalizer queue won&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// grow during marking so we don&#39;t have to rescan it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// during mark termination. If we ever need to lift
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// this assumption, we can do it by adding the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// necessary barriers to queuefinalizer (which it may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// have automatically).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;queuefinalizer during GC&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果finq为空或finq的内部数组已经满了，则从finc或重新分配 来获取block并插入到finq的链表头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">finq</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">finq</span><span class="p">.</span><span class="nx">cnt</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">finq</span><span class="p">.</span><span class="nx">fin</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">finc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">finc</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">finblock</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">_FinBlockSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gcMiscSys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">finc</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">=</span> <span class="nx">allfin</span>
</span></span><span class="line"><span class="cl">			<span class="nx">allfin</span> <span class="p">=</span> <span class="nx">finc</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">finptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// Build pointer mask for Finalizer array in block.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// Check assumptions made in finalizer1 array above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">{})</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">					<span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">{}.</span><span class="nx">fn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">					<span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">{}.</span><span class="nx">arg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">					<span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">{}.</span><span class="nx">nret</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">					<span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">{}.</span><span class="nx">fint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">					<span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">{}.</span><span class="nx">ot</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;finalizer out of sync&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">finptrmask</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">finptrmask</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">finalizer1</span><span class="p">[</span><span class="nx">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="nx">finalizer1</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 从finc中移除并获取链表头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">block</span> <span class="o">:=</span> <span class="nx">finc</span>
</span></span><span class="line"><span class="cl">		<span class="nx">finc</span> <span class="p">=</span> <span class="nx">block</span><span class="p">.</span><span class="nx">next</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 将从finc获取到的链表挂载到finq的队列头，finq指向新的block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">block</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">finq</span>
</span></span><span class="line"><span class="cl">		<span class="nx">finq</span> <span class="p">=</span> <span class="nx">block</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据finq.cnt获取索引对应的block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">f</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">finq</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="nx">finq</span><span class="p">.</span><span class="nx">cnt</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finq</span><span class="p">.</span><span class="nx">cnt</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Sync with markroots
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 设置相关属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">f</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">fn</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span><span class="p">.</span><span class="nx">nret</span> <span class="p">=</span> <span class="nx">nret</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span><span class="p">.</span><span class="nx">fint</span> <span class="p">=</span> <span class="nx">fint</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span><span class="p">.</span><span class="nx">ot</span> <span class="p">=</span> <span class="nx">ot</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置唤醒标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fingwake</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="唤醒fing">唤醒fing</h2>
<h3 id="findrunnable">findrunnable</h3>
<p>在 findrunnable 中有一段代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过状态位判断是否需要唤醒 fing， 通过wakefing来判断并返回fing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 唤醒g，并从休眠出继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="wakefing">wakefing</h3>
<p>这里不仅会对状态位 fingwait fingwake做二次判断，而且，如果状态位符合唤醒要求的话，需要重置两个状态位</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">wakefing</span><span class="p">()</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span><span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fingwait</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fingwake</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span> <span class="p">=</span> <span class="nx">fing</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">finlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="标准库应用">标准库应用</h2>
<p>内部上，Go 在 net 以及 net/http 包中确保文件先前的打开与关闭准确无误，并且在 os 包中确保之前创建的进程被正常地释放。这里有一个来自 os 包的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newProcess</span><span class="p">(</span><span class="nx">pid</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">handle</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">Process</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> 	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Process</span><span class="p">{</span><span class="nx">Pid</span><span class="p">:</span> <span class="nx">pid</span><span class="p">,</span> <span class="nx">handle</span><span class="p">:</span> <span class="nx">handle</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">Process</span><span class="p">).</span><span class="nx">Release</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">return</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当这个进程被释放，finalizer 也会被移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Process</span><span class="p">)</span> <span class="nf">release</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> 	<span class="c1">// NOOP for unix.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 	<span class="nx">p</span><span class="p">.</span><span class="nx">Pid</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"> 	<span class="c1">// no need for a finalizer anymore
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Go 同样也在测试中使用 finalizers 确保在垃圾回收器中期望的动作被执行，举个例子，sync 包使用了 finalizers 测试在垃圾回收循环中 pool 是否被清空。</p>
<h2 id="业务场景">业务场景</h2>
<p>在日常项目的开发过程中， 总会使用后台goroutine做一些定期清理或者更新的任务， 这就涉及到goroutine生命周期的管理。</p>
<p>处理方式</p>
<p>对于和主程序生命周期基本一致的后台goroutine，一般采用如下显式的<code>Stop()</code>来进行优雅退出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IApp</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">App</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// some vars
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">running</span>   <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stop</span>      <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">onStopped</span> <span class="kd">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">App</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">app</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">App</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">running</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stop</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="nf">watch</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">app</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">app</span> <span class="o">*</span><span class="nx">App</span><span class="p">)</span> <span class="nf">watch</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">app</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">app</span><span class="p">.</span><span class="nx">onStopped</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">app</span><span class="p">.</span><span class="nf">onStopped</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">app</span> <span class="o">*</span><span class="nx">App</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">app</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nb">close</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种方式除了需要在程序终止之前显式调用一下<code>Stop()</code>， 没有其他的问题。但是在其他的一些场景中， 你可能就会confuse了</p>
<p>比如我现在想实现一个cache模块，功能和接口都很简单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Cache</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于需要定时清理过期的缓存， 所以会使用一个后台goroutine来执行清理的工作， 但是这些应该是对使用者透明的， 不过往往总会出现一些意料之外的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;key1&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;key1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do other things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在使用者看来， cache已经没有引用了， 会在gc的时候被回收。 但实际上由于后台goroutine的存在， cache始终不能满足不可达的条件， 也就不会被gc回收， 从而产生了内存泄露的问题。</p>
<p>解决这个问题当前也可以按照上面的方式， 显式增加一个<code>Close()</code>方法， 靠channel通知关闭goroutine， 但是这无疑增加了使用成本， 而且也不能避免使用者忘记<code>Close()</code>这种场景。</p>
<p>还有没有更好的方式，不需要用户显式关闭， 在检查到没有引用之后， 主动终止goroutine，等待gc回收？ 当然。 <code>runtime.SetFinalizer</code> 可以帮助我们达到这个目的。如何利用SetFinalizer来进行cache后台goroutine的清理呢？</p>
<p>istio的中lrucache给了我们一种巧妙的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">lruWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">lruCache</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// We return a &#39;see-through&#39; wrapper for the real object such that
</span></span></span><span class="line"><span class="cl"><span class="c1">// the finalizer can trigger on the wrapper. We can&#39;t set a finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1">// on the main cache object because it would never fire, since the
</span></span></span><span class="line"><span class="cl"><span class="c1">// evicter goroutine is keeping it alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">result</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">lruWrapper</span><span class="p">{</span><span class="nx">c</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">lruWrapper</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nx">stopEvicter</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nx">evicterTerminated</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在lrucache外面加上一层wrapper， lrucache作为wrapper的匿名字段存在， 并且在wrapper上注册了SetFinalizer函数来终止后台的goroutine。 由于后台goroutine是和lrucache关联的， 当没有引用指向wrapper的时候， gc就会执行关联的SetFinalizer终止lrucache的后台goroutine，这样最终lrucache也会变成不可达的状态， 被gc回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Cache</span> <span class="p">=</span> <span class="o">*</span><span class="nx">wrapper</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">wrapper</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">cache</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">cache</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">content</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stop</span>    <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">onStopped</span> <span class="kd">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newCache</span><span class="p">()</span> <span class="o">*</span><span class="nx">cache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">cache</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">content</span><span class="p">:</span> <span class="s">&#34;some thing&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stop</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewCache</span><span class="p">()</span> <span class="nx">Cache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">w</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">wrapper</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cache</span> <span class="p">:</span> <span class="nf">newCache</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="nx">w</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">wrapper</span><span class="p">).</span><span class="nx">stop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">w</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">wrapper</span><span class="p">)</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">w</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nf">stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cache</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// do some thing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">onStopped</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">c</span><span class="p">.</span><span class="nf">onStopped</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cache</span><span class="p">)</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于对象是否被回收， 最靠谱的方式就是靠test来检测并保证这一行为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestFinalizer</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">assert</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">w</span> <span class="o">:=</span> <span class="nf">NewCache</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">cnt</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stopped</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">    <span class="nx">w</span><span class="p">.</span><span class="nx">onStopped</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cnt</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="nb">close</span><span class="p">(</span><span class="nx">stopped</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stopped</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nf">Fail</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="弊端">弊端</h2>
<p>有些同学喜欢利用 runtime.SetFinalizer 模拟析构函数，当变量被回收时，执行一些回收操作，加速一些资源的释放。在做性能优化的时候这样做确实有一定的效果，不过这样做是有一定的风险的。</p>
<p>比如下面这段代码，初始化一个文件描述符，当 GC 发生时释放掉无效的文件描述符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;syscall&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">d</span> <span class="kt">int</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">openFile</span><span class="p">(</span><span class="s">&#34;t.txt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">content</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;Here is the content: &#34;</span> <span class="o">+</span> <span class="nx">content</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">openFile</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">File</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">File</span><span class="p">{</span><span class="nx">d</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">syscall</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">descriptor</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">doSomeAllocation</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">1000</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[:])</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">doSomeAllocation</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// memory increase to force the GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">i</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个程序中一个函数打开文件，另一个函数读取文件。代表文件的结构体注册了一个 finalizer，在 gc 释放结构体时自动关闭文件。运行这个程序，会出现 panic：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">panic</span><span class="o">:</span> <span class="n">bad</span> <span class="n">file</span> <span class="n">descriptor</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">goroutine</span> <span class="m">1</span> <span class="n">[running]</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="nf">main.readFile</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">,</span> <span class="mh">0xc000078008</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">main.go</span><span class="o">:</span><span class="m">42</span> <span class="m">+0</span><span class="n">x103</span>
</span></span><span class="line"><span class="cl"><span class="nf">main.main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">main.go</span><span class="o">:</span><span class="m">14</span> <span class="m">+0</span><span class="n">x4b</span>
</span></span><span class="line"><span class="cl"><span class="n">exit</span> <span class="n">status</span> <span class="m">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是流程图：</p>
<ul>
<li>打开文件，返回一个文件描述符</li>
<li>这个文件描述符被传递给读取文件的函数</li>
<li>这个函数首先做一些繁重的工作：</li>
</ul>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202202181651632.png" alt=""></p>
<p>allocate 函数触发 gc：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202202181652047.png" alt=""></p>
<p>因为文件描述符是个整型，并以副本传递，所以打开文件的函数返回的结构体 <code>*File*</code> 不再被引用。Gc 把它标记为可以被回收的。之后触发这个变量注册的 finalizer，关闭文件。</p>
<p>然后，主协程读取文件：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202202181652374.png" alt=""></p>
<p>因为文件已经被 finalizer 关闭，所以会出现 panic。</p>
<h3 id="runtimekeepalive">runtime.KeepAlive</h3>
<p>runtime 包暴露了一个方法，用来在 Go 程序中避免出现这种情况，并显式地声明了让变量不被回收。在运行到这个调用这个方法的地方之前，gc 不会清除指定的变量。下面是加了对这个方法的调用的新代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="nf">openFile</span><span class="p">(</span><span class="s">&#34;t.txt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">content</span> <span class="o">:=</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">runtime</span><span class="p">.</span><span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;Here is the content: &#34;</span><span class="o">+</span><span class="nx">content</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>runtime.KeepAlive 能阻止 runtime.SetFinalizer 延迟发生，保证我们的变量不被 GC 所回收。</p>
<p>keepAlive 方法本身没有做什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Mark KeepAlive as noinline so that it is easily detectable as an intrinsic.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:noinline
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// KeepAlive marks its argument as currently reachable.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This ensures that the object is not freed, and its finalizer is not run,
</span></span></span><span class="line"><span class="cl"><span class="c1">// before the point in the program where KeepAlive is called.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A very simplified example showing where KeepAlive is required:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	type File struct { d int }
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	d, err := syscall.Open(&#34;/file/path&#34;, syscall.O_RDONLY, 0)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	// ... do something if err != nil ...
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	p := &amp;File{d}
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	var buf [10]byte
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	n, err := syscall.Read(p.d, buf[:])
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	// Ensure p is not finalized until Read returns.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	runtime.KeepAlive(p)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	// No more uses of p after this point.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Without the KeepAlive call, the finalizer could run at the start of
</span></span></span><span class="line"><span class="cl"><span class="c1">// syscall.Read, closing the file descriptor before syscall.Read makes
</span></span></span><span class="line"><span class="cl"><span class="c1">// the actual system call.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note: KeepAlive should only be used to prevent finalizers from
</span></span></span><span class="line"><span class="cl"><span class="c1">// running prematurely. In particular, when used with unsafe.Pointer,
</span></span></span><span class="line"><span class="cl"><span class="c1">// the rules for valid uses of unsafe.Pointer still apply.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Introduce a use of x that the compiler can&#39;t eliminate.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This makes sure x is alive on entry. We need x to be alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on entry for &#34;defer runtime.KeepAlive(x)&#34;; see issue 21402.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">cgoAlwaysFalse</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行时，Go 编译器会以很多种方式优化代码：函数内联，死码消除，等等。这个函数不会被内联，Go 编译器可以轻易地探测到哪里调用了 keepAlive。编译器很容易追踪到调用它的地方，它会发出一个特殊的 SSA 指令，以此来确保它不会被 gc 回收。</p>
<p>在生成的 SSA 代码中也可以看到这个 SSA 指令：</p>
<p><img src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/202202181700781.png" alt=""></p>
<p>实际上，它不是作为一个被调用的函数，而是由 ssa.go 实现的编译器内部实现，类似于 <code>unsafe.Pointer</code>。当你的代码中使用了 <code>runtime.KeepAlive()</code>，Go 编译器会设置一个名为 <code>OpKeepAlive</code> 的静态单赋值(SSA)，然后剩余的编译就会知道将这个变量的存活期保证到使用了 <code>runtime.KeepAlive()</code> 的时刻。</p>
<p>runtime.KeepAlive() 是一个特别的魔法有一个直接的后果就是你不能得到它的地址。如果你这样做的话， Go 会报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">./tst.go</span><span class="o">:</span><span class="m">20</span><span class="o">:</span><span class="m">22</span><span class="o">:</span> <span class="n">cannot</span> <span class="n">take</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">runtime.KeepAlive</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我不知道 Go 是否会聪明地优化掉一个只调用 runtime.KeepAlive 的函数, 但希望你永远不需要间接调用 <code>runtime.KeepAlive</code>。</p>
<h2 id="参考">参考</h2>
<p><a href="https://segmentfault.com/a/1190000020323654">深入理解Go-runtime.SetFinalizer原理剖析</a></p>
<p><a href="https://www.cnblogs.com/binHome/p/12901392.html">Go如何巧妙使用runtime.SetFinalizer</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/76504936">使用runtime.SetFinalizer优雅关闭后台goroutine</a></p>
<p><a href="https://mp.weixin.qq.com/s/H-VIhce4N3aH5HIhY-5UlQ">Go: Finalizers 怎么使用？</a></p>
<p><a href="https://studygolang.com/articles/28437">Go: 延长变量的生命周期</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2022-02-17
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go%E6%BA%90%E7%A0%81/">Go源码</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E4%B8%AD%E4%BC%98%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go中优化字符串比较操作</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/go%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96gc%E8%A7%A6%E5%8F%91%E9%A2%91%E7%8E%87/">
            <span class="next-text nav-default">Go如何优化GC触发频率</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
