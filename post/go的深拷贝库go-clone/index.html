<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go的深拷贝库:go-clone - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="背景 这个库是 github.com/huandu/go-clone，主要用途是对任意的 Go 结构进行深拷贝，创造一个内容完全相同的副本，得到的值可" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.2 with theme even" />


<link rel="canonical" href="/post/go%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%BA%93go-clone/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go的深拷贝库:go-clone" />
<meta property="og:description" content="背景 这个库是 github.com/huandu/go-clone，主要用途是对任意的 Go 结构进行深拷贝，创造一个内容完全相同的副本，得到的值可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%BA%93go-clone/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-08T23:26:17+00:00" />
<meta property="article:modified_time" content="2021-06-08T23:26:17+00:00" />

<meta itemprop="name" content="Go的深拷贝库:go-clone">
<meta itemprop="description" content="背景 这个库是 github.com/huandu/go-clone，主要用途是对任意的 Go 结构进行深拷贝，创造一个内容完全相同的副本，得到的值可"><meta itemprop="datePublished" content="2021-06-08T23:26:17+00:00" />
<meta itemprop="dateModified" content="2021-06-08T23:26:17+00:00" />
<meta itemprop="wordCount" content="8799">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的深拷贝库:go-clone"/>
<meta name="twitter:description" content="背景 这个库是 github.com/huandu/go-clone，主要用途是对任意的 Go 结构进行深拷贝，创造一个内容完全相同的副本，得到的值可"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go的深拷贝库:go-clone</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-08 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 8799 字 </span>
          <span class="more-meta"> 预计阅读 18 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#背景">背景</a></li>
    <li><a href="#实现思路">实现思路</a></li>
    <li><a href="#处理递归数据">处理递归数据</a></li>
    <li><a href="#提升深拷贝效率">提升深拷贝效率</a></li>
    <li><a href="#深拷贝私有字段">深拷贝私有字段</a></li>
    <li><a href="#减少反射使用的次数">减少反射使用的次数</a></li>
    <li><a href="#定义特殊的数值类型结构体">定义特殊的数值类型结构体</a></li>
    <li><a href="#拷贝函数指针">拷贝函数指针</a></li>
    <li><a href="#使用方法">使用方法</a>
      <ul>
        <li><a href="#安装">安装</a></li>
        <li><a href="#clone-和-slowly">Clone 和 Slowly</a></li>
        <li><a href="#将结构类型标记为标量">将结构类型标记为标量</a></li>
        <li><a href="#将指针类型标记为不透明">将指针类型标记为不透明</a></li>
        <li><a href="#克隆sync和syncatomic中定义的no-copy类型">克隆sync和sync/atomic中定义的“no-copy”类型</a></li>
        <li><a href="#设置自定义克隆功能">设置自定义克隆功能</a></li>
        <li><a href="#wrapunwrap和undo">Wrap，Unwrap和Undo</a></li>
      </ul>
    </li>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="背景">背景</h2>
<p>这个库是 <code>github.com/huandu/go-clone</code>，主要用途是对任意的 Go 结构进行深拷贝，创造一个内容完全相同的副本，得到的值可通过 <code>reflect.DeepEqual</code> 检查。</p>
<p>这个功能看起来挺常用的，不过很奇怪在 Go 世界里面可用的实现却很少，在动手实现之前我调查了几个类似的库或者可用来做深拷贝：</p>
<ul>
<li>encoding/gob 或 encoding/json：先将数据结构进行编码（gob.Encoder 或 json.Marshal），得到 []byte之后再解码（gob.Decoder 或 json.Unmarshal）。这种做法的好处是简单粗暴，基本上能够应对大部分的需求，缺点则是性能极低，且有各种限制，比如无法处理递归指针、无法处理 interface 类型数据，无法拷贝结构体私有字段,特别是 JSON，会丢失缺少大部分数据类型甚至精度。</li>
<li>github.com/jinzhu/copier 或 github.com/ulule/deepcopier ：这两个库都实现了基本的 struct 拷贝能力，不过缺乏递归指针的处理，也不能作为通用的深拷贝来使用。</li>
</ul>
<h2 id="实现思路">实现思路</h2>
<p>要实现深拷贝函数 <code>Clone(v interface{}) interface{}</code>，其基本思路很简单：</p>
<ol>
<li>首先通过函数 <code>val := reflect.ValueOf(v)</code> 拿到 v 的反射值；</li>
<li>根据 val.Kind() 区分各种类型，主要分两种：一种是 scala 类型，即数值类型，包括各种整型、浮点、虚数、字符串等，直接返回原值即可；一种是复杂类型，每种类型用对应的反射方法来创建，包括 <code>reflect.New/reflect.MakeMap/reflect.MakeSlice / reflect.MakeChan</code> 等方法；</li>
<li>通过各种反射方法来将新申请 <code>val.Set*</code> 方法将新值设置到新申请的变量里面。</li>
</ol>
<p>这里面比较麻烦的是处理 struct，为了深拷贝结构，必须首先通过 <code>val.NumField()</code> 得到 struct field 个数，然后用循环不断的将 <code>val.Field(i)</code> 的值拷贝到新申请的变量对应字段里面去，这里递归调用深拷贝方法即可。</p>
<p>思路看起来很简单，似乎都是些体力活，但做了之后就会发现有一些特殊情况还得多加小心，真要实现好不容易。</p>
<h2 id="处理递归数据">处理递归数据</h2>
<p>当我们使用循环链表的时候就会遇到递归数据。一个首尾相连的链表，如果一直跟着指针深拷贝所有数据，那么深拷贝函数一定会陷入死循环而无法退出。</p>
<p>下面是一个例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ListNode</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Next</span> <span class="o">*</span><span class="nx">ListNode</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node3</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node1</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node2</span>
</span></span><span class="line"><span class="cl"><span class="nx">node2</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node3</span>
</span></span><span class="line"><span class="cl"><span class="nx">node3</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <code>node1 -&gt; node2 -&gt; node3 -&gt; node1 -&gt; ...</code>形成了一个循环链表。</p>
<p>如果直接按照一般思路来实现 Clone，这个函数会因为不断的深度遍历 Next *ListNode 而陷入死循环，永远无法返回。</p>
<p>为了解决这个问题，应该使用经典的有向图检查环路的方法来实现，需要记下那些会产生循环的类型的访问记录，下次再访问到同样的数据时直接返回之前记录的结果即可打破循环。</p>
<p>可能会循环的类型其实不多，只有map、slice 和指针总共三种。 这个事实可能会有点违反直觉：struct 和 interface 都不会造成循环？这还真不会。</p>
<p>我们无法仅通过 struct 嵌套来构造出一个循环结构，这是无法通过编译器检查的。我们也无法通过 struct + interface 构造出循环结构，考虑以下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Loop</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 无法不使用 map、slice 和指针构造出循环结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">t</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">t</span><span class="p">.</span><span class="nx">Loop</span> <span class="p">=</span> <span class="nx">t</span>
</span></span><span class="line"><span class="cl"><span class="nx">t</span><span class="p">.</span><span class="nx">Loop</span> <span class="p">=</span> <span class="nx">t</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span> <span class="o">==</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Loop</span><span class="p">.(</span><span class="nx">T</span><span class="p">))</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// t 实际内容是：
</span></span></span><span class="line"><span class="cl"><span class="c1">// t == T{
</span></span></span><span class="line"><span class="cl"><span class="c1">//     Loop: T{
</span></span></span><span class="line"><span class="cl"><span class="c1">//         Loop: T{},
</span></span></span><span class="line"><span class="cl"><span class="c1">//     },
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在 Go 里面并不能把 interface 当做一种万能指针，当我们将一个结构 T 赋值给 interface{} 时候，Go 内部会将 T 的内容拷贝一份再赋值，而不是「引用」T 的原值。</p>
<p>在实现环路检查时还会遇到一个问题：虽然检查循环的关键是发现访问了一个访问过的值，但问题是怎么才知道两个值相等呢？我们总不能用 reflect.DeepEqual 来检查吧，那就太浪费性能了。我们也不能使用 <code>map[interface{}]struct{}</code> 来判断，虽然 Go 允许用 <code>interface{}</code> 作为 map 的 KeyType，但 Go 编译器和运行时都不允许将 map 类型作为 KeyType，而可循环类型包含 map，所以还得找其他办法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kt">bool</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">key</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// 可以被编译，但是运行时会 panic。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>容易想到，同样的问题 reflect.DeepEqual 也会遇到，那么直接去看一下官方实现就能得到答案。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// During deepValueEqual, must keep track of checks that are
</span></span></span><span class="line"><span class="cl"><span class="c1">// in progress. The comparison algorithm assumes that all
</span></span></span><span class="line"><span class="cl"><span class="c1">// checks in progress are true when it reencounters them.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Visited comparisons are stored in a map indexed by visit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">visit</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a1</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a2</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">typ</span> <span class="nx">Type</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deepValueEqual</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span> <span class="nx">Value</span><span class="p">,</span> <span class="nx">visited</span> <span class="kd">map</span><span class="p">[</span><span class="nx">visit</span><span class="p">]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">depth</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 略……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>继续看代码可以发现，官方使用的是 reflect.Value 的 Pointer 方法来得到 unsafe.Pointer，恰好 map、slice 和指针都可以调用这个方法，因此我们可以用类似手法实现。需要注意的是，reflect.DeepEqual 需要判断 v1 / v2 是否不同，所以在 visit 里面同时记录了两个指针，但我们在 Clone 的时候只需要知道变量是否已经遍历过，所以只需要一个指针就可以。</p>
<p>同时，我们也不需要使用 unsafe.Pointer 来记录指针，直接使用 uintptr 即可。这是因为在 Clone 结束前，新申请的变量一定能被当前 goroutine 的 stack 访问到，不会被 GC。当前 Go 的 GC 也不支持内存移动，可预见的将来也不会支持这种能力，所以无需多此一举用 unsafe.Pointer 平添 GC 压力。</p>
<p>还有一个细节必须注意：通过反射拿到的 slice 内部指针只是 slice 第一个元素的地址，不足以区分不同长度的 slice，这会造成误判。 reflect.DeepEqual 更注重的是数据「相等」，而不是精确「相同」，不做区分也没事，但 Clone 时候则必须区分同一个数组的不同 slice 的问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="nx">slice</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">s2</span> <span class="o">:=</span> <span class="nx">slice</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">p1</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">s1</span><span class="p">).</span><span class="nf">Pointer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">p2</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">s2</span><span class="p">).</span><span class="nf">Pointer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p1</span> <span class="o">==</span> <span class="nx">p2</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>综上，最后采用如下结构来记录访问过的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">visit</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span>     <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">extra</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span>     <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">visitMap</span> <span class="kd">map</span><span class="p">[</span><span class="nx">visit</span><span class="p">]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个 extra 里面存储的是 slice 的长度。</p>
<p>在记录时也需要注意，必须先将新数据放入 visitMap 然后再深度遍历和填充数值才行，否则依然会死循环。以指针为例，与 visitMap 相关的实现代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">clonePtr</span><span class="p">(</span><span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">visited</span> <span class="nx">visitMap</span><span class="p">)</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">visited</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">visit</span> <span class="o">:=</span> <span class="nx">visit</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">p</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">            <span class="nx">t</span><span class="p">:</span> <span class="nx">t</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">visited</span><span class="p">[</span><span class="nx">visit</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">elemType</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">elemType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">visited</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">visit</span> <span class="o">:=</span> <span class="nx">visit</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">p</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">            <span class="nx">t</span><span class="p">:</span> <span class="nx">t</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">visited</span><span class="p">[</span><span class="nx">visit</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nv</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略填充 nv 内容的过程……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">nv</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，由于记录 visitMap 会有额外内存和性能损耗，而绝大多数数据结构并不会包含任何循环结构，所以 clone.Clone 默认不做任何循环检查，专门提供的 clone.Slowly 则负责解决这种复杂问题。</p>
<h2 id="提升深拷贝效率">提升深拷贝效率</h2>
<p>前文所说的思路和方案，对于熟悉反射的开发者来说非常容易想到，属于常规解法了。不过我们都知道，反射的执行效率有限，对于字段较多的结构来说，深拷贝的效率会远低于浅拷贝。考虑到 Go 数据结构并不存在副作用，对于普通的数值类型可以直接浅拷贝，对于指针、接口、map 等类型也可以先浅拷贝再替换成新内容，这种拷贝方法会比通过反射来拷贝高效很多。</p>
<p>考虑以下数据结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">B</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">C</span> <span class="p">[]</span><span class="kt">float64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">d</span> <span class="kt">uint</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们手动进行深拷贝，最高效的方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">B</span><span class="p">:</span> <span class="s">&#34;test&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">C</span><span class="p">:</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">d</span><span class="p">:</span> <span class="mi">321</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">cloned</span> <span class="nx">T1</span>
</span></span><span class="line"><span class="cl"><span class="nx">cloned</span> <span class="p">=</span> <span class="o">*</span><span class="nx">t</span>                          <span class="c1">// 先做一次浅拷贝。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">cloned</span><span class="p">.</span><span class="nx">C</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">float64</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">))</span> <span class="c1">// 申请新的内存空间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">copy</span><span class="p">(</span><span class="nx">cloned</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">)</span>                  <span class="c1">// 将 t.C 内容拷贝过来。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要注意，B string 是可以直接浅拷贝的，在 Go 里面约定 string 是不可变（immutable）的，其中引用的字符串不会被轻易修改，甚至字面常量都放在了只读的内存空间中来确保真正的不可变。</p>
<h2 id="深拷贝私有字段">深拷贝私有字段</h2>
<p>在这个例子里面暗含了一个「彩蛋」：本来不可见的私有字段（unexported field）d 也被「顺便」深拷贝了。</p>
<p>如果按照反射的方法，所有私有字段都不可写（私有字段的 reflect.Value 中 CanSet 方法始终返回 false）， 从而也不能在深拷贝的时候写入数据，但现在使用这种先浅拷贝再深拷贝的方法会造成私有字段也被拷贝，假设其中包含指针之类类型，那么这个指针就会还指向老的数据结构，并没有真正达成深拷贝的目标，会造成潜在的问题。</p>
<p>想要提升拷贝效率，就得考虑怎么样才能完美的拷贝所有私有字段才行，要想做到这点就得了解 Go 数据结构的内存布局细节。</p>
<p>Go 为了能方便的与底层系统进行互操作，在数据结构的内存布局方面保持了非常严格的顺序性，使得我们可以有机会直接通过偏移量来得知每个字段，包括私有字段，在内存中的真实位置，借助 unsafe 库提供的不安全内存访问的能力就可以修改任意的私有字段。</p>
<p>下面这个例子展示了如何纯粹通过 reflect 和 unsafe 来深拷贝一个私有字段的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T2</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T2</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">:</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">tt</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span> <span class="c1">// 拿到类型 T。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fieldP</span> <span class="o">:=</span> <span class="nx">tt</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;p&#34;</span><span class="p">)</span>  <span class="c1">// 拿到 p 的字段信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">tv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>    <span class="c1">// 拿到 t 的反射值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">tv</span><span class="p">.</span><span class="nf">FieldByIndex</span><span class="p">(</span><span class="nx">fieldP</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span> <span class="c1">// 拿到 t.p 的反射值，虽然不让写，但是可以读。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">num</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">clonedP</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">MakeSlice</span><span class="p">(</span><span class="nx">fieldP</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// 构造一个新的 slice。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">src</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">())</span>       <span class="c1">// 拿到 p 数据指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">dst</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">clonedP</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">())</span> <span class="c1">// 拿到 clonedP 数据指针。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">sz</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">Elem</span><span class="p">().</span><span class="nf">Size</span><span class="p">())</span>        <span class="c1">// 计算出 []int 单个数组元素的长度，即 int 的长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">l</span> <span class="o">:=</span> <span class="nx">num</span> <span class="o">*</span><span class="nx">sz</span>                            <span class="c1">// 得到 p 的数据真实内存字节数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">cc</span> <span class="o">:=</span> <span class="nx">c</span><span class="o">*</span> <span class="nx">sz</span>                             <span class="c1">// 得到 p 的 cap 真实内存字节数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 直接无视类型进行内存拷贝，相当于 C 语言里面的 memcpy。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">copy</span><span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)[</span><span class="nx">dst</span><span class="p">](:</span><span class="nx">l</span><span class="p">:</span><span class="nx">cc</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)[</span><span class="nx">src</span><span class="p">](:</span><span class="nx">l</span><span class="p">:</span><span class="nx">cc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">cloned</span> <span class="nx">T2</span>
</span></span><span class="line"><span class="cl"><span class="nx">cloned</span> <span class="p">=</span> <span class="o">*</span><span class="nx">t</span> <span class="c1">// 先做一次浅拷贝。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cloned</span><span class="p">))</span> <span class="o">+</span> <span class="nx">fieldP</span><span class="p">.</span><span class="nx">Offset</span><span class="p">)</span> <span class="c1">// 拿到 p 的真实内存位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里已知 p 是一个 slice，用 `SliceHeader` 进行强制拷贝，相当于做了 cloned.p = clonedP。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span><span class="p">:</span> <span class="nx">dst</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Len</span><span class="p">:</span>  <span class="nx">num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Cap</span><span class="p">:</span>  <span class="nx">c</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>很显然上面这段代码非常的折腾，涉及不少 Go runtime 层面上的概念和技巧，我们来逐段仔细看一下。为了方便叙述，上面的代码里直接假定我们已经知道 p 是个 []int，这样就不用写大量 switch&hellip;case 判断 Kind，让本来就挺难理解的代码变得更难读了。如果希望看到完整的类型判断逻辑，可以参考源码 <a href="https://github.com/huandu/go-clone/blob/v1.1.2/clone.go#L291">https://github.com/huandu/go-clone/blob/v1.1.2/clone.go#L291</a>。</p>
<p>首先，能拷贝私有字段的前提是，我们可以通过 reflect 库读到私有字段的类型定义和数据，只读不能写，假如读都读不到，那就一点办法都没有了。</p>
<p>其次，在拿到字段 p 的类型信息 fieldP 之后，我们就可以轻松通过 field.Type 得知 p 的类型，从而可以通过 Kind 来区分不同类型的不同代码逻辑。在 fieldP 里面有个非常关键点字段 fieldP.Offset，它表示 p 相对结构指针的头部的偏移量。</p>
<p>下面这个等式是始终正确的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span> <span class="o">==</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="o">+</span> <span class="nx">fieldP</span><span class="p">.</span><span class="nx">Offset</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>知道 p 真实内存位置之后就能做很多事情了，比如直接进行内存拷贝。同理，由于 slice 数据的内存是连续的，一旦知道了真实的内存地址之后也可以直接进行数据拷贝，完成 slice 内容的复制。</p>
<p>具体内存拷贝的方法就是下面这段代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nb">copy</span><span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)[</span><span class="nx">dst</span><span class="p">](:</span><span class="nx">l</span><span class="p">:</span><span class="nx">cc</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)[</span><span class="nx">src</span><span class="p">](:</span><span class="nx">l</span><span class="p">:</span><span class="nx">cc</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它的原理是：先将 dst 和 src 这样的 unsafe.Pointer 强制转成 <code>[math.MaxInt32]byte</code> 类型，然后再对这个伪装的数组进行 slice 操作，将要拷贝的内容切出来生成合法的 []byte，最后交给 copy 来拷贝数据。</p>
<p>最后，还需要注意 slice 结构本身并不是一个指针，而是包含了几个字段的结构，具体定义放在 reflect.SliceHeader 这里。</p>
<h2 id="减少反射使用的次数">减少反射使用的次数</h2>
<p>反射使用过多就影响效率，我们可以看到，业务中大多数 Go 数据结构的字段类型都是数值类型（比如各种 int、float 等），特别是那些只包含数值类型的 Go 数据结构，简单的做一次浅拷贝就能完成所有工作，这样处理肯定比每次都用 reflect 遍历所有字段进行逐一拷贝来得快很多。</p>
<p>可以想到，如果能预先缓存类型信息，仅仅标记出类型中必须进行深拷贝的字段就好了，这样每个类型至多只做一次反射，剩下的拷贝就可以完全交给各种 unsafe 内存操作就好了。</p>
<p>在当前实现中，我们定义了一个类型 type structType，用于记录结构里面需要进行深拷贝的字段信息，没有记录在内的字段信息就是可以浅拷贝的数值字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">structType</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PointerFields</span> <span class="p">[]</span><span class="nx">structFieldType</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">structFieldType</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Offset</span> <span class="kt">uintptr</span> <span class="c1">// The offset from the beginning of the struct.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Index</span>  <span class="kt">int</span>     <span class="c1">// The index of the field.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体生成这个类型数据的代码放在 <a href="https://github.com/huandu/go-clone/blob/v1.1.2/structtype.go#L51">https://github.com/huandu/go-clone/blob/v1.1.2/structtype.go#L51</a> 这里，思路比较简单直接：遍历结构的每个字段，判断是否是数值类型，如果不是，生成 structFieldType 并放入到 structType 的 PointerFields 里面。</p>
<p>由于 Go 数据结构的类型定义不会在运行时进行修改，为了避免经常重复的分析一个类型，实际中我们用了一个 sync.Map 类型的全局变量 cachedStructTypes 类记录历史分析结果。</p>
<h2 id="定义特殊的数值类型结构体">定义特殊的数值类型结构体</h2>
<p>有一些 Go 结构体，看起来像是包含了指针需要深拷贝，但实际上应该始终当做值类型来使用。</p>
<p>这里面有下面几个典型的类型，我们正常使用的时候在函数中都是传值，而不是传指针：</p>
<ul>
<li>time.Time 表示时间，这里面虽然有一个 loc *time.Location 字段，但实际上不需要拷贝，这个 loc 指向的是一段只读的内容。</li>
<li>reflect.Value 表示反射值，这里面有比较复杂的指针信息，但由于这个值仅仅是一个实际类型的「代理」，深度拷贝这个数据并无实际意义。</li>
</ul>
<p>相信在业务代码中也可能会有类似的数值类型结构体，为了能争取处理这些情况，代码里提供了一个 MarkAsScalar 的函数，将这些类型统统加入到一个全局白名单里面，凡是这些类型的字段都会被看做简单的数值进行浅拷贝。</p>
<p>此外，还有 reflect.Type 这个特殊的 interface 也需要单独处理，它实际是 *reflect.rtype 类型，这个类型指向程序的只读内存空间，也不应该深度拷贝。不过由于它的独特性，没有任何一个类型与之相似，代码中就直接进行了特殊处理。</p>
<h2 id="拷贝函数指针">拷贝函数指针</h2>
<p>经过上面的探索，基本解决了大部分的深拷贝问题，但实际中发现还有一个非常难啃的硬骨头，即函数指针的拷贝。</p>
<p>如果我们有下面的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T3</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个 fn 本质上是一个指针，考虑到函数本身在运行时是只读的，一般情况下简单当做 uintptr 拷贝值就好了。</p>
<p>但凡是都有万一，当遇到下面这种非常复杂的情况时，浅拷贝并不可行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T4</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">t</span> <span class="o">:=</span> <span class="nx">T4</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
</span></span><span class="line"><span class="cl">        <span class="mi">0</span><span class="p">:</span> <span class="nx">T4</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">fn</span><span class="p">:</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewBuffer</span><span class="p">(</span><span class="kc">nil</span><span class="p">).</span><span class="nx">Len</span><span class="p">,</span> <span class="c1">// fn 指向一个绑定了 receiver 的方法。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>很显然，在拷贝 m 的时候必须遍历这个 map 所有元素，拿到 interface{} 具体值再进行拷贝。由于 reflect 接口的限制，在这个场景中我们无法拿到 T4 的内存位置，只能用老方法去遍历每个字段进行逐一拷贝，正常情况下一切都没问题，但很不幸的是，唯独只有当 fn 指向一个绑定了 receiver 的方法的时候，reflect.Value 的 Pointer 方法返回的地址是个假地址，这导致我们无法正确拷贝 fn 的值。</p>
<p>Go runtime 里面相关代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Pointer</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">k</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">kind</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">k</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">Func</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagMethod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// As the doc comment says, the returned pointer is an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// underlying code pointer but not necessarily enough to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// identify a single function uniquely. All method expressions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// created via reflect have the same underlying code pointer,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// so their Pointers are equal. The function used here must
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// match the one used in makeMethodValue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">f</span> <span class="o">:=</span> <span class="nx">methodValueCall</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，当 flagMethod 标记设上时，即上面所说的这种 fn 的值， Pointer 方法不会诚实的返回函数指针。 Go 这样设计很可能是为了掩盖 runtime 在函数指针上做的 trick：一般来说，fn 指向一个函数指针，即代码段的内存位置，但 Go 为了能让函数指针绑定 receiver， 在这种情况下 fn 会指向一个包含了上下文信息的结构，reflect 为了在这种状况下依然让调用者感觉 fn 是一个代码段地址就做了这个伪装。</p>
<p>关于 Go runtime 怎么实现函数指针，详见官方文档 <a href="https://golang.org/s/go11func">https://golang.org/s/go11func</a>。</p>
<p>为了解决这个问题，我们重新思考了这个细节的拷贝策略。如果拿不到真实的值同时又不想过度依赖 Go runtime 的具体实现，还有一个简单可行的方法是使用 reflect.Value 的 Set 方法直接设置值（回到最原始的方案），但这里面有个前提是字段必须 CanSet，且设置进去的值不能是私有字段。</p>
<p>以下是 Go reflect 库的相关代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Set assigns x to the value v.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It panics if CanSet returns false.
</span></span></span><span class="line"><span class="cl"><span class="c1">// As in Go, x&#39;s value must be assignable to v&#39;s type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span><span class="p">.</span><span class="nf">mustBeAssignable</span><span class="p">()</span> <span class="c1">// v 必须 CanSet。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">x</span><span class="p">.</span><span class="nf">mustBeExported</span><span class="p">()</span>   <span class="c1">// x 必须不能是私有字段。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// mustBeExported panics if f records that the value was obtained using
</span></span></span><span class="line"><span class="cl"><span class="c1">// an unexported field.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">flag</span><span class="p">)</span> <span class="nf">mustBeExported</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">f</span><span class="o">&amp;</span><span class="nx">flagRO</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 panic...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，为了能够正常的调用 Set 方法，我们不得不拿出终极大招，直接篡改 reflect.Value 里面的标志位，关键就是去掉 fn 这个私有字段的 flagRO 标志位。</p>
<p>直接去 hack reflect.Value 的私有字段是不靠谱的，未来太难以维护，考虑到我们可以相对安全的浅拷贝 interface{} ，可以通过一个空接口进行中转而间接的去掉这个标记位且不破坏其他的标记。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// typeOfInterface 是 interface{} 这种类型本身。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">typeOfInterface</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">((</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="kc">nil</span><span class="p">)).</span><span class="nf">Elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// forceClearROFlag clears all RO flags in v to make v accessible.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It&#39;s a hack based on the fact that InterfaceData is always available on RO data.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This hack can be broken in any Go version.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Don&#39;t use it unless we have no choice, e.g. copying func in some edge cases.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">forceClearROFlag</span><span class="p">(</span><span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Convert</span><span class="p">(</span><span class="nx">typeOfInterface</span><span class="p">)</span> <span class="c1">// 将任意的类型强制转成 interface{}，确保 v 内存布局可控。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>      <span class="c1">// i 是局部变量，不会设置 flagRO。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">nv</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">()))</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">InterfaceData</span><span class="p">()</span> <span class="c1">// 浅拷贝 v 的内容到 i.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">nv</span><span class="p">.</span><span class="nf">Elem</span><span class="p">().</span><span class="nf">Elem</span><span class="p">()</span> <span class="c1">// 返回原来 v 指向的真实内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，我们就可以正常的通过 Set 来设置这个反射值了，最后再将复制出来的值通过内存操作拷贝到结构里面去即可。</p>
<h2 id="使用方法">使用方法</h2>
<p>包clone提供了深度克隆任何 Go 数据的功能。它还提供了一个包装器来保护指针免受任何意外的变化。</p>
<p>Clone/Slowly也可以克隆未导出的字段和“无复制”结构。明智地使用此功能。</p>
<h3 id="安装">安装</h3>
<p>使用go get安装该软件包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">go</span> <span class="n">get</span> <span class="n">github.com</span><span class="o">/</span><span class="n">huandu</span><span class="o">/</span><span class="n">go</span><span class="o">-</span><span class="n">clone</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="clone-和-slowly">Clone 和 Slowly</h3>
<p>如果我们想克隆任何 Go 值，请使用Clone.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">v</span> <span class="o">:=</span> <span class="nx">clone</span><span class="p">.</span><span class="nf">Clone</span><span class="p">(</span><span class="nx">t</span><span class="p">).(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>出于性能考虑，Clone不处理包含指针循环的值。如果我们需要克隆这些值，请Slowly改用。</p>
<h4 id="func-clone">func Clone</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Clone</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>递归深度克隆v为新值。它假设 v 中没有指针循环，例如 v 有一个指向 v 本身的指针。如果存在指针循环，请使用 Slowly。</p>
<p>Clone 分配内存并以深度优先的顺序在 v 内部深度复制值。以下类型有一些特殊规则。</p>
<ul>
<li>标量类型：所有类似数字的类型都按值复制。</li>
<li>func：按值复制，因为 func 在运行时是一个不透明的指针。</li>
<li>字符串：按值复制，因为字符串在设计上是不可变的。</li>
<li>unsafe.Pointer：按值复制，因为我们不知道里面有什么。</li>
<li>chan：创建一个新的空 chan，因为我们无法读取旧 chan 中的数据。
与许多其他包不同，Clone 能够克隆任何结构体的未导出字段。明智地使用此功能。</li>
</ul>
<h4 id="func-slowly">func Slowly</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Slowly</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Slowly递归地将v 深度克隆到一个新值。它在内部标记所有克隆的值，因此它可以使用循环指针克隆 v。</p>
<p>Slowly与Clone完全相同。有关更多详细信息，请参阅克隆文档。</p>
<p>Example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ListNode</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Next</span> <span class="o">*</span><span class="nx">ListNode</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node3</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">node1</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node2</span>
</span></span><span class="line"><span class="cl"><span class="nx">node2</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node3</span>
</span></span><span class="line"><span class="cl"><span class="nx">node3</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// We must use `Slowly` to clone a circular linked list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">node</span> <span class="o">:=</span> <span class="nf">Slowly</span><span class="p">(</span><span class="nx">node1</span><span class="p">).(</span><span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="将结构类型标记为标量">将结构类型标记为标量</h3>
<p>一些结构类型可以被视为标量。</p>
<p>一个众所周知的案例是time.Time。虽然time.Time中有一个<code>loc *time.Location</code>指针，我们总是用time.Time的值。克隆time.Time时，返回一个浅拷贝副本应该是可以的。</p>
<p>目前，以下类型默认标记为标量。</p>
<ul>
<li>time.Time</li>
<li>reflect.Value</li>
</ul>
<p>如果内置包中定义的任何类型应视为标量，请打开新问题让我知道。我会更新默认值。</p>
<p>如果有任何自定义类型应视为标量，则调用MarkAsScalar手动标记它。</p>
<h4 id="func-markasscalar">func MarkAsScalar</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MarkAsScalar</span><span class="p">(</span><span class="nx">t</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>MarkAsScalar 将 t 标记为标量类型，以便所有克隆方法都将按值复制 t。如果 t 不是结构体或指向结构体的指针，MarkAsScalar 将忽略 t。</p>
<p>在大多数情况下，没有必要显式调用它。如果 struct 类型仅包含标量类型字段，则该结构将自动标记为标量。</p>
<p>以下是默认标记为标量的类型列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="o">*</span> <span class="n">time.Time</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span> <span class="n">reflect.Value</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ScalarType</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stderr</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MarkAsScalar</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">ScalarType</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">scalar</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ScalarType</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stderr</span><span class="p">:</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">cloned</span> <span class="o">:=</span> <span class="nf">Clone</span><span class="p">(</span><span class="nx">scalar</span><span class="p">).(</span><span class="o">*</span><span class="nx">ScalarType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// cloned is a shadow copy of scalar
</span></span></span><span class="line"><span class="cl"><span class="c1">// so that the pointer value should be the same.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">scalar</span><span class="p">.</span><span class="nx">stderr</span> <span class="o">==</span> <span class="nx">cloned</span><span class="p">.</span><span class="nx">stderr</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="将指针类型标记为不透明">将指针类型标记为不透明</h3>
<p>一些指针值用作可枚举的常量值。</p>
<p>一个众所周知的案例是<code>elliptic.Curve</code>。在<code>crypto/tls</code>包中，通过将值与预定义的曲线值进行比较来检查证书的曲线类型，例如elliptic.P521()。在这种情况下，作为指针或结构体的曲线值不能被深度克隆。</p>
<p>目前，以下类型默认标记为标量。</p>
<ul>
<li>elliptic.Curve，即<code>*elliptic.CurveParam</code>或<code>elliptic.p256Curve</code>。</li>
<li>reflect.Type，在<code>*reflect.rtype</code>中定义runtime。</li>
</ul>
<p>如果有任何自定义指针类型应该被认为是不透明的，请调用<code>MarkAsOpaquePointer</code>手动标记它。</p>
<h4 id="func-markasopaquepointer">func MarkAsOpaquePointer</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MarkAsOpaquePointer</span><span class="p">(</span><span class="nx">t</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">OpaquePointerType</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">foo</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">MarkAsOpaquePointer</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">OpaquePointerType</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">opaque</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">OpaquePointerType</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">cloned</span> <span class="o">:=</span> <span class="nf">Clone</span><span class="p">(</span><span class="nx">opaque</span><span class="p">).(</span><span class="o">*</span><span class="nx">OpaquePointerType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// cloned is a shadow copy of opaque.
</span></span></span><span class="line"><span class="cl"><span class="c1">// so that opaque and cloned should be the same.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">opaque</span> <span class="o">==</span> <span class="nx">cloned</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="n">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="克隆sync和syncatomic中定义的no-copy类型">克隆sync和sync/atomic中定义的“no-copy”类型</h3>
<p>有一些“no-copy”类型，如sync.Mutex、atomic.Value等。它们不能通过将所有字段一一复制来克隆，但我们可以分配一个新的零值并调用方法来进行适当的初始化。</p>
<p>目前，所有“不复制”类型的定义sync，并sync/atomic能正常使用以下策略来克隆。</p>
<ul>
<li>sync.Mutex：克隆值是新分配的零互斥锁。</li>
<li>sync.RWMutex：克隆值是新分配的零互斥锁。</li>
<li>sync.WaitGroup：克隆值是新分配的零等待组。</li>
<li>sync.Cond: 克隆值是一个带有新分配的零锁的 cond。</li>
<li>sync.Pool: 克隆值是一个具有相同New功能的空池。</li>
<li>sync.Map：克隆值是具有克隆键/值对的同步映射。</li>
<li>sync.Once: 克隆值是具有相同完成标志的一次类型。</li>
<li>atomic.Value: 克隆值是具有相同值的新原子值。</li>
</ul>
<p>如果内置包中定义的任何类型应视为“no-copy”类型，请打开新issue让我知道。我会更新默认值。</p>
<h3 id="设置自定义克隆功能">设置自定义克隆功能</h3>
<p>如果默认克隆策略不适用于结构类型，我们可以调用SetCustomFunc以实现自定义克隆逻辑。 Clone并且Slowly可以在自定义克隆函数中使用。</p>
<p>有关更多详细信息，请参阅SetCustomFunc 示例代码。</p>
<h3 id="wrapunwrap和undo">Wrap，Unwrap和Undo</h3>
<p>clone包提供Wrap/Unwrap函数来保护指针值免受任何意外变化。当我们想要保护一个设计为不可变的变量时，它很有用，例如全局配置、存储在上下文中的值、发送到 chan 的值等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Suppose we have a type T defined as following.
</span></span></span><span class="line"><span class="cl"><span class="c1">//     type T struct {
</span></span></span><span class="line"><span class="cl"><span class="c1">//         Foo int
</span></span></span><span class="line"><span class="cl"><span class="c1">//     }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">w</span> <span class="o">:=</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">v</span><span class="p">).(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="c1">// Wrap value to protect it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Use w freely. The type of w is the same as that of v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// It&#39;s OK to modify w. The change will not affect v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Foo</span> <span class="p">=</span> <span class="mi">456</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span> <span class="c1">// 456
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Once we need the original value stored in w, call `Unwrap`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">orig</span> <span class="o">:=</span> <span class="nf">Unwrap</span><span class="p">(</span><span class="nx">w</span><span class="p">).(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">orig</span> <span class="o">==</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">orig</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span>  <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Or, we can simply undo any change made in w.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that `Undo` is significantly slower than `Unwrap`, thus
</span></span></span><span class="line"><span class="cl"><span class="c1">// the latter is always preferred.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">Undo</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span> <span class="c1">// 123
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="func-undo">func Undo</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Undo</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Undo放弃对包装值所做的任何更改。如果 v 不是包装值，则什么也不会发生。</p>
<h4 id="func-unwrap">func Unwrap</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Unwrap</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 v 是一个包装值，则 Unwrap 返回 v 的原始值。否则，简单地返回 v 本身。</p>
<h4 id="func-wrap">func Wrap</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Wrap 创建 v 的包装器，它必须是一个指针。如果 v 不是指针，Wrap 只返回 v 并且什么都不做。</p>
<p>包装器是 v 值的深度克隆。它在内部保存了 v 的影子副本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="nx">Foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">v</span> <span class="o">:=</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">t</span><span class="p">).(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span>               <span class="c1">// v is a clone of t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="o">==</span> <span class="kc">true</span> <span class="c1">// v equals t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">v</span><span class="p">.</span><span class="nx">Foo</span> <span class="p">=</span> <span class="mi">456</span>                     <span class="c1">// v.Foo is changed, but t.Foo doesn&#39;t change.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">orig</span> <span class="o">:=</span> <span class="nf">Unwrap</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>               <span class="c1">// Use `Unwrap` to discard wrapper and return original value, which is t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">orig</span><span class="p">.(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="o">==</span> <span class="nx">t</span>                  <span class="c1">// orig and t is exactly the same.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">Undo</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>                         <span class="c1">// Use `Undo` to discard any change on v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">v</span><span class="p">.</span><span class="nx">Foo</span> <span class="o">==</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Foo</span>                  <span class="c1">// Now, the value of v and t are the same again.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Suppose we have a type T defined as following.
</span></span></span><span class="line"><span class="cl"><span class="c1">//     type T struct {
</span></span></span><span class="line"><span class="cl"><span class="c1">//         Foo int
</span></span></span><span class="line"><span class="cl"><span class="c1">//     }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Foo</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">w</span> <span class="o">:=</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">v</span><span class="p">).(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="c1">// Wrap value to protect it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Use w freely. The type of w is the same as that of v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// It&#39;s OK to modify w. The change will not affect v.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Foo</span> <span class="p">=</span> <span class="mi">456</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span> <span class="c1">// 456
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span> <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Once we need the original value stored in w, call `Unwrap`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">orig</span> <span class="o">:=</span> <span class="nf">Unwrap</span><span class="p">(</span><span class="nx">w</span><span class="p">).(</span><span class="o">*</span><span class="nx">T</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">orig</span> <span class="o">==</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">orig</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span>  <span class="c1">// 123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Or, we can simply undo any change made in w.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that `Undo` is significantly slower than `Unwrap`, thus
</span></span></span><span class="line"><span class="cl"><span class="c1">// the latter is always preferred.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">Undo</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">Foo</span><span class="p">)</span> <span class="c1">// 123
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="line"><span class="cl"><span class="m">456</span>
</span></span><span class="line"><span class="cl"><span class="m">123</span>
</span></span><span class="line"><span class="cl"><span class="n">true</span>
</span></span><span class="line"><span class="cl"><span class="m">123</span>
</span></span><span class="line"><span class="cl"><span class="m">123</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="转载">转载</h2>
<p><a href="https://zhuanlan.zhihu.com/p/107216411">go-clone：深拷贝 Go 数据结构</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/161210711">go-clone：极致优化深拷贝效率与拷贝私有字段</a></p>
<p><a href="https://github.com/huandu/go-clone">huandu/go-clone</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-06-08
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go-assert%E5%BA%93%E4%BB%8B%E7%BB%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">go-assert库介绍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E7%9A%84%E8%87%AA%E5%8A%A8dump/">
            <span class="next-text nav-default">自动dump库homles介绍</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
