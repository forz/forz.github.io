<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>购买股票问题 | Forz Blog</title>
<meta name="keywords" content="DP" />
<meta name="description" content="LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max.">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="购买股票问题" />
<meta property="og:description" content="LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-24T20:26:45&#43;00:00" />
<meta property="article:modified_time" content="2017-06-24T20:26:45&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="购买股票问题"/>
<meta name="twitter:description" content="LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "购买股票问题",
      "item": "/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "购买股票问题",
  "name": "购买股票问题",
  "description": "LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max.",
  "keywords": [
    "DP"
  ],
  "articleBody": "LeetCode 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\nExample 1:\nInput: [7, 1, 5, 3, 6, 4] Output: 5  max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1] Output: 0  In this case, no transaction is done, i.e. max profit = 0.\n解析：从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution { public: int maxProfit(vectorint \u0026prices) { int m = prices.size(); if(m == 0) return 0; int curMin = prices[0]; int ret = 0; for(int i = 1; i  m; i ++) { curMin = min(curMin, prices[i]); ret = max(ret, prices[i]-curMin); } return ret; } };   LeetCode 122. Best Time to Buy and Sell Stock II Say you have an array for which the i^th element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n解析：\n贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。\n我们可以这么考虑，对于每一笔交易 假设是从i天买入，j天卖出 ，如果有j+1天的价格高于j天，所以肯定是从i到j+1利润更高，同样的如果有第i-1天价格比第i天更低，肯定是从i-1天到j天利润更高。\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public: int maxProfit(vectorint\u0026 prices) { int total = 0; if(prices.size()==0) return total; for (int i=0; i prices.size()-1; i++) if (prices[i+1]prices[i]) total += prices[i+1]-prices[i]; return total; } };   LeetCode 123. Best Time to Buy and Sell Stock III Say you have an array for which the i^th element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n解析：\n类似最大连续和问题，我们需要变量来记录当前的一些状态信息，因为是2次交易，所以我们需要大小为2的数组记录每一次交易的信息，又因为一次交易包含买和卖两次操作，所以我们需要两个数组。分别命名为hold【】和sell【】。\n递推过程当天状态只与前一天有关，所以可以用滚动数组来优化。\nhold[i]表示第i次持有后的盈亏，也就是第i次买入后的状态，sell[i]表示第i次卖出后的盈亏状态。比如上个例子1,3,7,2,1,5.如果我们在第一天买入，那么hold[1]应该是-1，这里可能会问，为什么会是负数？那是因为我们买入了股票，钱已经花出去了，但我们还没有卖出，所以当前你手上是没有现金的，只有股票。\n交易过程肯定是先买后卖，一次性全买全卖。（第j次卖出与第j次买入有关，第j次买入与j-1次卖出有关）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int maxProfit(vectorint\u0026 prices) { int len = prices.size(); int hold[3];//hold[i]表示第i次买入后的状态  int sell[3];//sell[i]表示第i次卖出后的状态。  for (int i=0;i2;++i){//初始化dp值  hold[i] = INT_MIN; sell[i] = 0; } for (int i=0; ilen; ++i)//扫描数组  for(int j=1; j2; ++j){//枚举买卖次数  sell[j] = max(sell[j],hold[j] + prices[i]); hold[j] = max(hold[j],sell[j-1] - prices[i]); //注意两个语句的顺序，因为滚动数组的原因，第一维度被优化，所以不能判断hold[i][j]和hold[i-1][j]的区别，需要在hold没被覆盖的时候更新sell值  } return sell[2]; } };   LeetCode 188. Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\nNote: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n解析：\n本题和上题思路相同，只是要注意如果交易次数2*k超过数组长度，就可以任意买卖，转化为于一道普通贪心题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public: int maxProfit(int k, vectorint \u0026prices) { int len = prices.size(); if (len2) return 0; if (klen/2){ int ans = 0; for (int i=1; ilen; ++i)//贪心算法  ans += max(prices[i] - prices[i-1],0); return ans; } int hold[k+1];//hold[i]表示第i次买入后的状态  int sell[k+1];//sell[i]表示第i次卖出后的状态。  for (int i=0;ik;++i){//初始化dp值  hold[i] = INT_MIN; sell[i] = 0; } int cur; for (int i=0; ilen; ++i)//扫描天数  for(int j=1; jk; ++j){//枚举买卖次数，题设要求必须在再次购买之前卖掉股票  sell[j] = max(sell[j],hold[j] + prices[i]);//第j次买后面就是第j次卖  hold[j] = max(hold[j],sell[j-1] - prices[i]); } return sell[k]; } };   LeetCode 309. Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the i^th element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example:\nprices = [1, 2, 3, 0, 2] maxProfit = 3 transactions = [buy, sell, cooldown, buy, sell]\n解析：\n考虑用动态规划法解决问题，因为当前日期买卖股票的行为会受到之前日期买卖股票行为影响。\n对一天的状态有：buy买入，sell卖出，cooldown冷却。买和卖之间要有一天冷却。\n但是对于这一天是否持股只有两种状态：持股状态（buy），没有持股状态（sell，cooldown）。\n对于当天持股状态时，至当天的为止的最大利润有两种可能： 1、今天没有买入，跟昨天持股状态一样； 2、今天买入，昨天是冷却期，利润是前天卖出股票时候得到的利润减去今天股票的价钱。 二者取最大值。\n对于当天未持股状态，至当天为止的最大利润有两种可能： 1、今天没有卖出，跟昨天未持股状态一样； 2、昨天持有股票，今天卖出了，利润是昨天持有股票时候的利润加上今天股票的价钱。 二者取最大值。\n直至最后一天的状态应该是卖出状态。最终利润为sell[n-1];\n状态转移方程：\nsell[i] = max(sell[i-1], buy[i-1] + price[i]);\nbuy[i] = max(buy[i-1], sell[i-2] - price[i]);\n由于第i天的状态仅依赖于i-1和i-2，我们可以将O（n）空间减少到O（1）。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution { public: int maxProfit(vectorint \u0026prices) { int buy(INT_MIN), sell(0), prev_sell(0), prev_buy; for (int price : prices) { prev_buy = buy; buy = max(prev_sell - price, buy); prev_sell = sell; sell = max(prev_buy + price, sell); } return sell; } };   ",
  "wordCount" : "2148",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-24T20:26:45Z",
  "dateModified": "2017-06-24T20:26:45Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      购买股票问题
    </h1>
    <div class="post-meta">June 24, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="leetcode-121-best-time-to-buy-and-sell-stock">LeetCode 121. Best Time to Buy and Sell Stock<a hidden class="anchor" aria-hidden="true" href="#leetcode-121-best-time-to-buy-and-sell-stock">#</a></h1>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Example 1:</p>
<pre><code>Input: [7, 1, 5, 3, 6, 4]
Output: 5
</code></pre>
<p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p>
<p>Example 2:</p>
<pre><code>Input: [7, 6, 4, 3, 1]
Output: 0
</code></pre>
<p>In this case, no transaction is done, i.e. max profit = 0.</p>
<p>解析：从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">curMin</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">curMin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">curMin</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">curMin</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-122-best-time-to-buy-and-sell-stock-ii">LeetCode 122. Best Time to Buy and Sell Stock II<a hidden class="anchor" aria-hidden="true" href="#leetcode-122-best-time-to-buy-and-sell-stock-ii">#</a></h1>
<p>Say you have an array for which the i^th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>解析：</p>
<p>贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。</p>
<p>我们可以这么考虑，对于每一笔交易 假设是从i天买入，j天卖出 ，如果有j+1天的价格高于j天，所以肯定是从i到j+1利润更高，同样的如果有第i-1天价格比第i天更低，肯定是从i-1天到j天利润更高。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
            <span class="n">total</span> <span class="o">+=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-123-best-time-to-buy-and-sell-stock-iii">LeetCode 123. Best Time to Buy and Sell Stock III<a hidden class="anchor" aria-hidden="true" href="#leetcode-123-best-time-to-buy-and-sell-stock-iii">#</a></h1>
<p>Say you have an array for which the i^th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:</p>
<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>解析：</p>
<p>类似最大连续和问题，我们需要变量来记录当前的一些状态信息，因为是2次交易，所以我们需要大小为2的数组记录每一次交易的信息，又因为一次交易包含买和卖两次操作，所以我们需要两个数组。分别命名为hold【】和sell【】。</p>
<p>递推过程当天状态只与前一天有关，所以可以用滚动数组来优化。</p>
<p>hold[i]表示第i次持有后的盈亏，也就是第i次买入后的状态，sell[i]表示第i次卖出后的盈亏状态。比如上个例子1,3,7,2,1,5.如果我们在第一天买入，那么hold[1]应该是-1，这里可能会问，为什么会是负数？那是因为我们买入了股票，钱已经花出去了，但我们还没有卖出，所以当前你手上是没有现金的，只有股票。</p>
<p>交易过程肯定是先买后卖，一次性全买全卖。（第j次卖出与第j次买入有关，第j次买入与j-1次卖出有关）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">hold</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="c1">//hold[i]表示第i次买入后的状态
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">sell</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="c1">//sell[i]表示第i次卖出后的状态。
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="c1">//初始化dp值
</span><span class="c1"></span>            <span class="n">hold</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
            <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//扫描数组
</span><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span><span class="c1">//枚举买卖次数
</span><span class="c1"></span>                <span class="n">sell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sell</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">hold</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">hold</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hold</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">sell</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="c1">//注意两个语句的顺序，因为滚动数组的原因，第一维度被优化，所以不能判断hold[i][j]和hold[i-1][j]的区别，需要在hold没被覆盖的时候更新sell值
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-188-best-time-to-buy-and-sell-stock-iv">LeetCode 188. Best Time to Buy and Sell Stock IV<a hidden class="anchor" aria-hidden="true" href="#leetcode-188-best-time-to-buy-and-sell-stock-iv">#</a></h1>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:   <br>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>解析：</p>
<p>本题和上题思路相同，只是要注意如果交易次数2*k超过数组长度，就可以任意买卖，转化为于一道普通贪心题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxProfit</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">&gt;</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">){</span> 
            <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//贪心算法
</span><span class="c1"></span>                <span class="n">ans</span> <span class="o">+=</span> <span class="n">max</span><span class="p">(</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">hold</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="c1">//hold[i]表示第i次买入后的状态
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">sell</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="c1">//sell[i]表示第i次卖出后的状态。
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="c1">//初始化dp值
</span><span class="c1"></span>            <span class="n">hold</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
            <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//扫描天数
</span><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span><span class="c1">//枚举买卖次数，题设要求必须在再次购买之前卖掉股票
</span><span class="c1"></span>                <span class="n">sell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sell</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">hold</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//第j次买后面就是第j次卖
</span><span class="c1"></span>                <span class="n">hold</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hold</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">sell</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="leetcode-309-best-time-to-buy-and-sell-stock-with-cooldown">LeetCode 309. Best Time to Buy and Sell Stock with Cooldown<a hidden class="anchor" aria-hidden="true" href="#leetcode-309-best-time-to-buy-and-sell-stock-with-cooldown">#</a></h1>
<p>Say you have an array for which the i^th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:</p>
<p>prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]</p>
<p>解析：</p>
<p>考虑用动态规划法解决问题，因为当前日期买卖股票的行为会受到之前日期买卖股票行为影响。</p>
<p>对一天的状态有：buy买入，sell卖出，cooldown冷却。买和卖之间要有一天冷却。</p>
<p>但是对于这一天是否持股只有两种状态：持股状态（buy），没有持股状态（sell，cooldown）。</p>
<p>对于当天持股状态时，至当天的为止的最大利润有两种可能： <br>
1、今天没有买入，跟昨天持股状态一样；  <br>
2、今天买入，昨天是冷却期，利润是前天卖出股票时候得到的利润减去今天股票的价钱。 二者取最大值。</p>
<p>对于当天未持股状态，至当天为止的最大利润有两种可能：  <br>
1、今天没有卖出，跟昨天未持股状态一样； <br>
2、昨天持有股票，今天卖出了，利润是昨天持有股票时候的利润加上今天股票的价钱。 二者取最大值。</p>
<p>直至最后一天的状态应该是卖出状态。最终利润为sell[n-1];</p>
<p>状态转移方程：</p>
<p>sell[i] = max(sell[i-1], buy[i-1] + price[i]);</p>
<p>buy[i] = max(buy[i-1], sell[i-2] - price[i]);</p>
<p>由于第i天的状态仅依赖于i-1和i-2，我们可以将O（n）空间减少到O（1）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">buy</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">),</span> <span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">prev_sell</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">prev_buy</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">price</span> <span class="p">:</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">prev_buy</span> <span class="o">=</span> <span class="n">buy</span><span class="p">;</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">prev_sell</span> <span class="o">-</span> <span class="n">price</span><span class="p">,</span> <span class="n">buy</span><span class="p">);</span>
    <span class="n">prev_sell</span> <span class="o">=</span> <span class="n">sell</span><span class="p">;</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">prev_buy</span> <span class="o">+</span> <span class="n">price</span><span class="p">,</span> <span class="n">sell</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">sell</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/dp/">DP</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
