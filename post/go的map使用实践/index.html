<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go的map使用实践 | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[&#34;a&#34;]=&#34;sssss&#34; 上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行. 1 2 m:=make(map[string]string) m[&#34;a&#34;]=&#34;sssss&#34; key">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E7%9A%84map%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go的map使用实践" />
<meta property="og:description" content="初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[&#34;a&#34;]=&#34;sssss&#34; 上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行. 1 2 m:=make(map[string]string) m[&#34;a&#34;]=&#34;sssss&#34; key" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E7%9A%84map%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-16T19:29:21&#43;00:00" />
<meta property="article:modified_time" content="2019-08-16T19:29:21&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go的map使用实践"/>
<meta name="twitter:description" content="初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[&#34;a&#34;]=&#34;sssss&#34; 上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行. 1 2 m:=make(map[string]string) m[&#34;a&#34;]=&#34;sssss&#34; key"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go的map使用实践",
      "item": "/post/go%E7%9A%84map%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go的map使用实践",
  "name": "Go的map使用实践",
  "description": "初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作. 1 2 var m map[string]string m[\u0026#34;a\u0026#34;]=\u0026#34;sssss\u0026#34; 上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行. 1 2 m:=make(map[string]string) m[\u0026#34;a\u0026#34;]=\u0026#34;sssss\u0026#34; key",
  "keywords": [
    "Go"
  ],
  "articleBody": "初始化 使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作.\n1 2  var m map[string]string m[\"a\"]=\"sssss\"   上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行.\n1 2  m:=make(map[string]string) m[\"a\"]=\"sssss\"   key key类型 Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 == 和 != 操作符，k1 == k2 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。\nmap中的key可以是任何的类型，只要它的值能比较是否相等，Go的语言规范已精确定义，Key的类型可以是：\n 布尔值 数字 字符串 指针 通道 接口类型 结构体(struct必须是可比较的，才能作为key，否则编译时报错)  只包含上述类型的数组。\n但不能是：\n slice map function  Key类型只要能支持 == 和 != 操作符，即可以做为Key，当两个值==时，则认为是同一个Key。\n比较相等 我们先看一下样例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  package main import \"fmt\" type _key struct { } type point struct { x int y int } type pair struct { x int y int } type Sumer interface { Sum() int } type Suber interface { Sub() int } func (p *pair) Sum() int { return p.x + p.y } func (p *point) Sum() int { return p.x + p.y } func (p pair) Sub() int { return p.x - p.y } func (p point) Sub() int { return p.x - p.y } func main() { fmt.Println(\"_key{} == _key{}: \", _key{} == _key{}) // output: true  fmt.Println(\"point{} == point{}: \", point{x: 1, y: 2} == point{x: 1, y: 2}) // output: true \tfmt.Println(\"\u0026point{} == \u0026point{}: \", \u0026point{x: 1, y: 2} == \u0026point{x: 1, y: 2}) // output: false  fmt.Println(\"[2]point{} == [2]point{}: \", [2]point{point{x: 1, y: 2}, point{x: 2, y: 3}} == [2]point{point{x: 1, y: 2}, point{x: 2, y: 3}}) //output: true  var a Sumer = \u0026pair{x: 1, y: 2} var a1 Sumer = \u0026pair{x: 1, y: 2} var b Sumer = \u0026point{x: 1, y: 2} fmt.Println(\"Sumer.byptr == Sumer.byptr: \", a == b) // output: false \tfmt.Println(\"Sumer.sametype == Sumer.sametype: \", a == a1) // output: false  var c Suber = pair{x: 1, y: 2} var d Suber = point{x: 1, y: 2} var d1 point = point{x: 1, y: 2} fmt.Println(\"Suber.byvalue == Suber.byvalue: \", c == d) // output: false \tfmt.Println(\"Suber.byvalue == point.byvalue: \", d == d1) // output: true  ci1 := make(chan int, 1) ci2 := ci1 ci3 := make(chan int, 1) fmt.Println(\"chan int == chan int: \", ci1 == ci2) // output: true \tfmt.Println(\"chan int == chan int: \", ci1 == ci3) // output: false }   上面的例子让我们较直观地了解结构体，数组，指针，chan在什么场景下是相等。我们再来看Go语言规范中是怎么说的：\n Pointer values are comparable. Two pointer values are equal if they point to the same variable or if both have value nil. Pointers to distinct zero-size variables may or may not be equal.当指针指向同一变量，或同为nil时指针相等，但指针指向不同的零值时可能不相等。 Channel values are comparable. Two channel values are equal if they were created by the same call to make or if both have value nil.Channel当指向同一个make创建的或同为nil时才相等 Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.从上面的例子我们可以看出，当接口有相同的动态类型并且有相同的动态值，或者值为都为nil时相等。 A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t’s dynamic type is identical to X and t’s dynamic value is equal to x.如果一个是非接口类型X的变量x，也实现了接口T，与另一个接口T的变量t，只t的动态类型也是类型X，并且他们的动态值相同，则他们相等。 Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.结构体当所有字段的值相同，并且没有 相应的非空白字段时，则他们相等， Array values are comparable if values of the array element type are comparable. Two array values are equal if their corresponding elements are equal.两个数组只要他们包括的元素，每个元素的值相同，则他们相等。  注意：Go语言里是无法重载操作符的，struct是递归操作每个成员变量，struct也可以称为map的key，但如果struct的成员变量里有不能进行==操作的，例如slice，那么就不能作为map的key。\n类型判断 判断两个变量是否相等，首先是要判断变量的动态类型是否相同，在runtime中，_type结构是描述最为基础的类型（runtime/type.go），而map, slice, array等内置的复杂类型也都有对应的类型描述（如maptype，slicetype，arraytype）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  type _type struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldalign uint8 kind uint8 alg *typeAlg gcdata *byte str nameOff ptrToThis typeOff } ... type chantype struct { typ _type elem *_type dir uintptr } ... type slicetype struct { typ _type elem *_type } ...   其中对于类型的值是否相等，需要使用到成员alg *typeAlg(runtime/alg.go)，它则持有此类型值的hash与equal的算法，它也是一个结构体:\n1 2 3 4 5 6 7 8  type typeAlg struct { // function for hashing objects of this type \t// (ptr to object, seed) - hash \thash func(unsafe.Pointer, uintptr) uintptr // function for comparing objects of this type \t// (ptr to object A, ptr to object B) - ==? \tequal func(unsafe.Pointer, unsafe.Pointer) bool }   runtime/alg.go中提供了各种基础的hash func与 equal func，例如：\n1 2 3 4 5 6 7 8  func strhash(a unsafe.Pointer, h uintptr) uintptr { x := (*stringStruct)(a) return memhash(x.str, h, uintptr(x.len)) } func strequal(p, q unsafe.Pointer) bool { return *(*string)(p) == *(*string)(q) }   有了这些基础的hash func与 equal func，再复杂的结构体也可以按字段递归计算hash与相等比较了。那我们再来看一下，当访问map[key]时，其实现对应在runtime/hashmap.go中的mapaccess1函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { ... alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) // 1 \tm := uintptr(1)h.B - 1 b := (*bmap)(add(h.buckets, (hash\u0026m)*uintptr(t.bucketsize))) // 2 \t... top := uint8(hash  (sys.PtrSize*8 - 8)) if top  minTopHash { top += minTopHash } for { for i := uintptr(0); i  bucketCnt; i++ { ... k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if alg.equal(key, k) { // 3 \tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) ... return v } } ... } }   mapaccess1的代码还是比较多的，简化逻辑如下（参考注释上序列）：\n 调用key类型的hash方法，计算出key的hash值 根据hash值找到对应的桶bucket 在桶中找到key值相等的map的value。判断相等需调用key类型的equal方法  到现在我们也就有了初步了解，map中的key访问时同时需要使用该类型的hash func与 equal func，只要key值相等，当结构体即使不是同一对象，也可从map中获取相同的值，例如：\n1 2 3 4 5  m := make(map[interface{}]interface{}) m[_key{}] = \"value\" if v, ok := m[_key{}];ok { fmt.Println(\"%v\", v) // output: value }   key可以是float型吗 从语法上看，是可以的。\n来看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { m := make(map[float64]int) m[1.4] = 1 m[2.4] = 2 m[math.NaN()] = 3 m[math.NaN()] = 3 for k, v := range m { fmt.Printf(\"[%v, %d] \", k, v) } fmt.Printf(\"\\nk: %v, v: %d\\n\", math.NaN(), m[math.NaN()]) fmt.Printf(\"k: %v, v: %d\\n\", 2.400000000001, m[2.400000000001]) fmt.Printf(\"k: %v, v: %d\\n\", 2.4000000000000000000000001, m[2.4000000000000000000000001]) fmt.Println(math.NaN() == math.NaN()) }   程序的输出：\n1 2 3 4 5  [2.4, 2] [NaN, 3] [NaN, 3] [1.4, 1] k: NaN, v: 0 k: 2.400000000001, v: 0 k: 2.4, v: 2 false   例子中定义了一个 key 类型是 float 型的 map，并向其中插入了 4 个 key：1.4， 2.4， NAN，NAN。\n打印的时候也打印出了 4 个 key，如果你知道 NAN != NAN，也就不奇怪了。因为他们比较的结果不相等，自然，在 map 看来就是两个不同的 key 了。\n接着，我们查询了几个 key，发现 NAN 不存在，2.400000000001 也不存在，而 2.4000000000000000000000001 却存在。\n有点诡异，不是吗？\n接着，我通过汇编发现了如下的事实：\n当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。\n具体是通过 Float64frombits 函数完成：\n1 2 3  // Float64frombits returns the floating point number corresponding // the IEEE 754 binary representation b. func Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(\u0026b)) }   也就是将浮点数表示成 IEEE 754 规定的格式。如赋值语句：\n1 2 3 4  0x00bd 00189 (test18.go:9) LEAQ \"\".statictmp_0(SB), DX 0x00c4 00196 (test18.go:9) MOVQ DX, 16(SP) 0x00c9 00201 (test18.go:9) PCDATA $0, $2 0x00c9 00201 (test18.go:9) CALL runtime.mapassign(SB)   \"\".statictmp_0(SB) 变量是这样的：\n1 2 3 4 5 6  \"\".statictmp_0 SRODATA size=8 0x0000 33 33 33 33 33 33 03 40 \"\".statictmp_1 SRODATA size=8 0x0000 ff 3b 33 33 33 33 03 40 \"\".statictmp_2 SRODATA size=8 0x0000 33 33 33 33 33 33 03 40   我们再来输出点东西：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import ( \"fmt\" \"math\" ) func main() { m := make(map[float64]int) m[2.4] = 2 fmt.Println(math.Float64bits(2.4)) fmt.Println(math.Float64bits(2.400000000001)) fmt.Println(math.Float64bits(2.4000000000000000000000001)) }   1 2 3  4612586738352864255 4612586738352862003 4612586738352862003   转成十六进制为：\n1 2 3  0x4003333333333333 0x4003333333333BFF 0x4003333333333333   和前面的 “\".statictmp_0 比较一下，很清晰了吧。2.4 和 2.4000000000000000000000001 经过 math.Float64bits() 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。\n再来看一下 NAN（not a number）：\n1 2  // NaN returns an IEEE 754 ``not-a-number'' value. func NaN() float64 { return Float64frombits(uvnan) }   uvan 的定义为：\n1  uvnan = 0x7FF8000000000001   NAN() 直接调用 Float64frombits，传入写死的 const 型变量 0x7FF8000000000001，得到 NAN 型值。既然，NAN 是从一个常量解析得来的，为什么插入 map 时，会被认为是不同的 key？\n这是由类型的哈希函数决定的，例如，对于 64 位的浮点数，它的哈希函数如下：\n1 2 3 4 5 6 7 8 9 10 11  func f64hash(p unsafe.Pointer, h uintptr) uintptr { f := *(*float64)(p) switch { case f == 0: return c1 * (c0 ^ h) // +0, -0 \tcase f != f: return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN \tdefault: return memhash(p, h, 8) } }   第二个 case，f != f 就是针对 NAN，这里会再加一个随机数。\n这样，所有的谜题都解开了。\n由于 NAN 的特性：\n1 2  NAN != NAN hash(NAN) != hash(NAN)   因此向 map 中查找的 key 为 NAN 时，什么也查不到；如果向其中增加了 4 次 NAN，遍历会得到 4 个 NAN。\n最后说结论：float 型可以作为 key，但是由于精度的问题，会导致一些诡异的问题，慎用之。\nvalue 任何类型都可以作为 value，包括 map 类型。\nvalue不可达 看一个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import \"fmt\" type user struct { name string age int school map[string]school } type school struct { Teacher string Name string } func main() { s := map[string]school{\"primarySchool\":{Teacher:\"李老师\", Name:\"XX小学\"}, \"highSchool\":{Teacher:\"曹老师\", Name:\"XX中学\"}} u := user{name:\"张三\",age:12,school:s} u.school[\"highSchool\"].Name = \"XX第二中学\"//错误  fmt.Println(u) }   返回:\n1  cannot assign to struct field u.school[\"highSchool\"].Name in map   原因出在user 中的 map[string]school 这里， u.school[“highSchool”] 访问到这里都没有问题，问题在于后面的 “ .Name ” ，因为map[string]school 中储存的school是值拷贝，当要修改school里面的Name时，就发生了不可寻址的错误。\n正确的做法有：\n  重新覆盖，既然无法单独修改里面的某一项，那就全部都替换掉，u.school[“highSchool”] = school{Teacher:“曹老师”, Name:“XX第二中学”}\n  改为储存指针，把map[string]school 改为 map[string]*school，把school的指针存进去，这样go就可以寻址，从而可以修改里面的值\n  多维map 用到了一个二维 map，结果第一遍写的时候就碰到了那个 nil map 的问题。\n一开始的代码是这样的：\n1 2  m:=make(map[string]map[string]string) m[\"a\"][\"b\"]=\"ccc\"   后来才想明白如果插新加入的元素也是个 map 的话需要再次 make()或初始化,修正后的代码如下\n1 2 3 4 5 6 7 8 9 10 11  package main import \"fmt\" func main() { m := make(map[int]map[int]int) m[0] = map[int]int{1: 3} //重新make或直接初始化 \tm[0][3] = 2 //正确 \tfmt.Println(m[0]) }   参考 http://lanlingzi.cn/post/technical/2016/0904_go_map/\nhttps://barbery.me/post/2014-08-06-go%E5%A4%9A%E7%BB%B4map%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98/\n",
  "wordCount" : "3999",
  "inLanguage": "zh-cn",
  "datePublished": "2019-08-16T19:29:21Z",
  "dateModified": "2019-08-16T19:29:21Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E7%9A%84map%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go的map使用实践
    </h1>
    <div class="post-meta">August 16, 2019
</div>
  </header> 
  <div class="post-content"><h2 id="初始化">初始化<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h2>
<p>使用 map 的时候需要注意，你需要显式地初始化才能对 map 进行操作.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="nx">m</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">]=</span><span class="s">&#34;sssss&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码会报 panic: assignment to entry in nil map ，必须用内建的 make() 函数才行.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">m</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">]=</span><span class="s">&#34;sssss&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="key">key<a hidden class="anchor" aria-hidden="true" href="#key">#</a></h2>
<h3 id="key类型">key类型<a hidden class="anchor" aria-hidden="true" href="#key类型">#</a></h3>
<p>Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 == 和 != 操作符，k1 == k2 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。</p>
<p>map中的key可以是任何的类型，只要它的值能比较是否相等，Go的语言规范已精确定义，Key的类型可以是：</p>
<ul>
<li>布尔值</li>
<li>数字</li>
<li>字符串</li>
<li>指针</li>
<li>通道</li>
<li>接口类型</li>
<li>结构体(struct必须是可比较的，才能作为key，否则编译时报错)</li>
</ul>
<p>只包含上述类型的数组。</p>
<p>但不能是：</p>
<ul>
<li>slice</li>
<li>map</li>
<li>function</li>
</ul>
<p>Key类型只要能支持 == 和 != 操作符，即可以做为Key，当两个值==时，则认为是同一个Key。</p>
<h3 id="比较相等">比较相等<a hidden class="anchor" aria-hidden="true" href="#比较相等">#</a></h3>
<p>我们先看一下样例代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">_key</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">point</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="kt">int</span>
	<span class="nx">y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">pair</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="kt">int</span>
	<span class="nx">y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Sumer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Sum</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Suber</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Sub</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pair</span><span class="p">)</span> <span class="nf">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">point</span><span class="p">)</span> <span class="nf">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">pair</span><span class="p">)</span> <span class="nf">Sub</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">p</span><span class="p">.</span><span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">point</span><span class="p">)</span> <span class="nf">Sub</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">p</span><span class="p">.</span><span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;_key{} == _key{}: &#34;</span><span class="p">,</span> <span class="nx">_key</span><span class="p">{}</span> <span class="o">==</span> <span class="nx">_key</span><span class="p">{})</span> <span class="c1">// output: true
</span><span class="c1"></span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;point{} == point{}: &#34;</span><span class="p">,</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="o">==</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>     <span class="c1">// output: true
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&amp;point{} == &amp;point{}: &#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">// output: false
</span><span class="c1"></span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;[2]point{} == [2]point{}: &#34;</span><span class="p">,</span>
	  <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">point</span><span class="p">{</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">point</span><span class="p">{</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">3</span><span class="p">}})</span> <span class="c1">//output: true
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="nx">Sumer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pair</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">a1</span> <span class="nx">Sumer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pair</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="nx">Sumer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Sumer.byptr == Sumer.byptr: &#34;</span><span class="p">,</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">)</span>        <span class="c1">// output: false
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Sumer.sametype == Sumer.sametype: &#34;</span><span class="p">,</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">a1</span><span class="p">)</span> <span class="c1">// output: false
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Suber</span> <span class="p">=</span> <span class="nx">pair</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="nx">Suber</span> <span class="p">=</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">d1</span> <span class="nx">point</span> <span class="p">=</span> <span class="nx">point</span><span class="p">{</span><span class="nx">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Suber.byvalue == Suber.byvalue: &#34;</span><span class="p">,</span> <span class="nx">c</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span>  <span class="c1">// output: false
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Suber.byvalue == point.byvalue: &#34;</span><span class="p">,</span> <span class="nx">d</span> <span class="o">==</span> <span class="nx">d1</span><span class="p">)</span> <span class="c1">// output: true
</span><span class="c1"></span>
	<span class="nx">ci1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">ci2</span> <span class="o">:=</span> <span class="nx">ci1</span>
	<span class="nx">ci3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;chan int == chan int: &#34;</span><span class="p">,</span> <span class="nx">ci1</span> <span class="o">==</span> <span class="nx">ci2</span><span class="p">)</span> <span class="c1">// output: true
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;chan int == chan int: &#34;</span><span class="p">,</span> <span class="nx">ci1</span> <span class="o">==</span> <span class="nx">ci3</span><span class="p">)</span> <span class="c1">// output: false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的例子让我们较直观地了解结构体，数组，指针，chan在什么场景下是相等。我们再来看Go语言规范中是怎么说的：</p>
<ul>
<li>Pointer values are comparable. Two pointer values are equal if they point to the same variable or if both have value nil. Pointers to distinct zero-size variables may or may not be equal.当指针指向同一变量，或同为nil时指针相等，但指针指向不同的零值时可能不相等。</li>
<li>Channel values are comparable. Two channel values are equal if they were created by the same call to make or if both have value nil.Channel当指向同一个make创建的或同为nil时才相等</li>
<li>Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.从上面的例子我们可以看出，当接口有相同的动态类型并且有相同的动态值，或者值为都为nil时相等。</li>
<li>A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t’s dynamic type is identical to X and t’s dynamic value is equal to x.如果一个是非接口类型X的变量x，也实现了接口T，与另一个接口T的变量t，只t的动态类型也是类型X，并且他们的动态值相同，则他们相等。</li>
<li>Struct values are comparable if all their fields are comparable. Two struct values are equal if their corresponding non-blank fields are equal.结构体当所有字段的值相同，并且没有 相应的非空白字段时，则他们相等，</li>
<li>Array values are comparable if values of the array element type are comparable. Two array values are equal if their corresponding elements are equal.两个数组只要他们包括的元素，每个元素的值相同，则他们相等。</li>
</ul>
<p>注意：Go语言里是无法重载操作符的，struct是递归操作每个成员变量，struct也可以称为map的key，但如果struct的成员变量里有不能进行==操作的，例如slice，那么就不能作为map的key。</p>
<h3 id="类型判断">类型判断<a hidden class="anchor" aria-hidden="true" href="#类型判断">#</a></h3>
<p>判断两个变量是否相等，首先是要判断变量的动态类型是否相同，在runtime中，_type结构是描述最为基础的类型（runtime/type.go），而map, slice, array等内置的复杂类型也都有对应的类型描述（如maptype，slicetype，arraytype）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">_type</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">size</span>       <span class="kt">uintptr</span>
	<span class="nx">ptrdata</span>    <span class="kt">uintptr</span>
	<span class="nx">hash</span>       <span class="kt">uint32</span>
	<span class="nx">tflag</span>      <span class="nx">tflag</span>
	<span class="nx">align</span>      <span class="kt">uint8</span>
	<span class="nx">fieldalign</span> <span class="kt">uint8</span>
	<span class="nx">kind</span>       <span class="kt">uint8</span>
	<span class="nx">alg</span>        <span class="o">*</span><span class="nx">typeAlg</span>
	<span class="nx">gcdata</span>    <span class="o">*</span><span class="kt">byte</span>
	<span class="nx">str</span>       <span class="nx">nameOff</span>
	<span class="nx">ptrToThis</span> <span class="nx">typeOff</span>
<span class="p">}</span>
<span class="o">...</span>
<span class="kd">type</span> <span class="nx">chantype</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>  <span class="nx">_type</span>
	<span class="nx">elem</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">dir</span>  <span class="kt">uintptr</span>
<span class="p">}</span>
<span class="o">...</span>
<span class="kd">type</span> <span class="nx">slicetype</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>  <span class="nx">_type</span>
	<span class="nx">elem</span> <span class="o">*</span><span class="nx">_type</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>其中对于类型的值是否相等，需要使用到成员alg *typeAlg(runtime/alg.go)，它则持有此类型值的hash与equal的算法，它也是一个结构体:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">typeAlg</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// function for hashing objects of this type
</span><span class="c1"></span>	<span class="c1">// (ptr to object, seed) -&gt; hash
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="kd">func</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span>
	<span class="c1">// function for comparing objects of this type
</span><span class="c1"></span>	<span class="c1">// (ptr to object A, ptr to object B) -&gt; ==?
</span><span class="c1"></span>	<span class="nx">equal</span> <span class="kd">func</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>runtime/alg.go中提供了各种基础的hash func与 equal func，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">strhash</span><span class="p">(</span><span class="nx">a</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">h</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">stringStruct</span><span class="p">)(</span><span class="nx">a</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">memhash</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">str</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">len</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">strequal</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有了这些基础的hash func与 equal func，再复杂的结构体也可以按字段递归计算hash与相等比较了。那我们再来看一下，当访问map[key]时，其实现对应在runtime/hashmap.go中的mapaccess1函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">alg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">alg</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span> <span class="c1">// 2
</span><span class="c1"></span>	<span class="o">...</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
		<span class="nx">top</span> <span class="o">+=</span> <span class="nx">minTopHash</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 3
</span><span class="c1"></span>				<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
				<span class="o">...</span>
				<span class="k">return</span> <span class="nx">v</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="o">...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>mapaccess1的代码还是比较多的，简化逻辑如下（参考注释上序列）：</p>
<ol>
<li>调用key类型的hash方法，计算出key的hash值</li>
<li>根据hash值找到对应的桶bucket</li>
<li>在桶中找到key值相等的map的value。判断相等需调用key类型的equal方法</li>
</ol>
<p>到现在我们也就有了初步了解，map中的key访问时同时需要使用该类型的hash func与 equal func，只要key值相等，当结构体即使不是同一对象，也可从map中获取相同的值，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kd">interface</span><span class="p">{})</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">_key</span><span class="p">{}]</span> <span class="p">=</span> <span class="s">&#34;value&#34;</span>
<span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">_key</span><span class="p">{}];</span><span class="nx">ok</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// output: value
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="key可以是float型吗">key可以是float型吗<a hidden class="anchor" aria-hidden="true" href="#key可以是float型吗">#</a></h3>
<p>从语法上看，是可以的。</p>
<p>来看个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="mf">1.4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">m</span><span class="p">[</span><span class="mf">2.4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nf">NaN</span><span class="p">()]</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nf">NaN</span><span class="p">()]</span> <span class="p">=</span> <span class="mi">3</span>

	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%v, %d] &#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\nk: %v, v: %d\n&#34;</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nf">NaN</span><span class="p">(),</span> <span class="nx">m</span><span class="p">[</span><span class="nx">math</span><span class="p">.</span><span class="nf">NaN</span><span class="p">()])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;k: %v, v: %d\n&#34;</span><span class="p">,</span> <span class="mf">2.400000000001</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="mf">2.400000000001</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;k: %v, v: %d\n&#34;</span><span class="p">,</span> <span class="mf">2.4000000000000000000000001</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="mf">2.4000000000000000000000001</span><span class="p">])</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">NaN</span><span class="p">()</span> <span class="o">==</span> <span class="nx">math</span><span class="p">.</span><span class="nf">NaN</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">[2.4</span><span class="p">,</span> <span class="m">2</span><span class="n">]</span> <span class="n">[NaN</span><span class="p">,</span> <span class="m">3</span><span class="n">]</span> <span class="n">[NaN</span><span class="p">,</span> <span class="m">3</span><span class="n">]</span> <span class="n">[1.4</span><span class="p">,</span> <span class="m">1</span><span class="n">]</span>
<span class="n">k</span><span class="o">:</span> <span class="kc">NaN</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="m">0</span>
<span class="n">k</span><span class="o">:</span> <span class="m">2.400000000001</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="m">0</span>
<span class="n">k</span><span class="o">:</span> <span class="m">2.4</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="m">2</span>
<span class="n">false</span>
</code></pre></td></tr></table>
</div>
</div><p>例子中定义了一个 key 类型是 float 型的 map，并向其中插入了 4 个 key：<code>1.4， 2.4， NAN，NAN</code>。</p>
<p>打印的时候也打印出了 4 个 key，如果你知道 NAN != NAN，也就不奇怪了。因为他们比较的结果不相等，自然，在 map 看来就是两个不同的 key 了。</p>
<p>接着，我们查询了几个 key，发现 NAN 不存在，<code>2.400000000001</code> 也不存在，而 <code>2.4000000000000000000000001</code> 却存在。</p>
<p>有点诡异，不是吗？</p>
<p>接着，我通过汇编发现了如下的事实：</p>
<p>当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。</p>
<p>具体是通过 Float64frombits 函数完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Float64frombits returns the floating point number corresponding
</span><span class="c1">// the IEEE 754 binary representation b.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Float64frombits</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">float64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是将浮点数表示成 IEEE 754 规定的格式。如赋值语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="mh">0x00bd</span> <span class="m">00189</span> <span class="p">(</span><span class="n">test18.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="nf">.statictmp_0</span><span class="p">(</span><span class="n">SB</span><span class="p">),</span> <span class="n">DX</span>
<span class="mh">0x00c4</span> <span class="m">00196</span> <span class="p">(</span><span class="n">test18.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">MOVQ</span>    <span class="n">DX</span><span class="p">,</span> <span class="m">16</span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
<span class="mh">0x00c9</span> <span class="m">00201</span> <span class="p">(</span><span class="n">test18.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">PCDATA</span>  <span class="o">$</span><span class="m">0</span><span class="p">,</span> <span class="o">$</span><span class="m">2</span>
<span class="mh">0x00c9</span> <span class="m">00201</span> <span class="p">(</span><span class="n">test18.go</span><span class="o">:</span><span class="m">9</span><span class="p">)</span>      <span class="n">CALL</span>    <span class="nf">runtime.mapassign</span><span class="p">(</span><span class="n">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>&quot;&quot;.statictmp_0(SB)</code> 变量是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="s">&#34;&#34;</span><span class="n">.statictmp_0</span> <span class="n">SRODATA</span> <span class="n">size</span><span class="o">=</span><span class="m">8</span>
        <span class="mh">0x0000</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">03</span> <span class="m">40</span>
<span class="s">&#34;&#34;</span><span class="n">.statictmp_1</span> <span class="n">SRODATA</span> <span class="n">size</span><span class="o">=</span><span class="m">8</span>
        <span class="mh">0x0000</span> <span class="n">ff</span> <span class="m">3</span><span class="n">b</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">03</span> <span class="m">40</span>
<span class="s">&#34;&#34;</span><span class="n">.statictmp_2</span> <span class="n">SRODATA</span> <span class="n">size</span><span class="o">=</span><span class="m">8</span>
        <span class="mh">0x0000</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">33</span> <span class="m">03</span> <span class="m">40</span>
</code></pre></td></tr></table>
</div>
</div><p>我们再来输出点东西：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="mf">2.4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Float64bits</span><span class="p">(</span><span class="mf">2.4</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Float64bits</span><span class="p">(</span><span class="mf">2.400000000001</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Float64bits</span><span class="p">(</span><span class="mf">2.4000000000000000000000001</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="m">4612586738352864255</span>
<span class="m">4612586738352862003</span>
<span class="m">4612586738352862003</span>
</code></pre></td></tr></table>
</div>
</div><p>转成十六进制为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="mh">0x4003333333333333</span>
<span class="mh">0x4003333333333BFF</span>
<span class="mh">0x4003333333333333</span>
</code></pre></td></tr></table>
</div>
</div><p>和前面的 &ldquo;&quot;.statictmp_0 比较一下，很清晰了吧。<code>2.4</code> 和 <code>2.4000000000000000000000001</code> 经过 math.Float64bits() 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。</p>
<p>再来看一下 NAN（not a number）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NaN returns an IEEE 754 ``not-a-number&#39;&#39; value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NaN</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Float64frombits</span><span class="p">(</span><span class="nx">uvnan</span><span class="p">)</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>uvan 的定义为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">uvnan</span>    <span class="o">=</span> <span class="mh">0x7FF8000000000001</span>
</code></pre></td></tr></table>
</div>
</div><p>NAN() 直接调用 <code>Float64frombits</code>，传入写死的 const 型变量 0x7FF8000000000001，得到 NAN 型值。既然，NAN 是从一个常量解析得来的，为什么插入 map 时，会被认为是不同的 key？</p>
<p>这是由类型的哈希函数决定的，例如，对于 64 位的浮点数，它的哈希函数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f64hash</span><span class="p">(</span><span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">h</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">float64</span><span class="p">)(</span><span class="nx">p</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">c1</span> <span class="o">*</span> <span class="p">(</span><span class="nx">c0</span> <span class="p">^</span> <span class="nx">h</span><span class="p">)</span> <span class="c1">// +0, -0
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">f</span> <span class="o">!=</span> <span class="nx">f</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">c1</span> <span class="o">*</span> <span class="p">(</span><span class="nx">c0</span> <span class="p">^</span> <span class="nx">h</span> <span class="p">^</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">()))</span> <span class="c1">// any kind of NaN
</span><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">memhash</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第二个 case，f != f 就是针对 NAN，这里会再加一个随机数。</p>
<p>这样，所有的谜题都解开了。</p>
<p>由于 NAN 的特性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">NAN</span> <span class="o">!=</span> <span class="n">NAN</span>
<span class="nf">hash</span><span class="p">(</span><span class="n">NAN</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">NAN</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>因此向 map 中查找的 key 为 NAN 时，什么也查不到；如果向其中增加了 4 次 NAN，遍历会得到 4 个 NAN。</p>
<p>最后说结论：float 型可以作为 key，但是由于精度的问题，会导致一些诡异的问题，慎用之。</p>
<h2 id="value">value<a hidden class="anchor" aria-hidden="true" href="#value">#</a></h2>
<p>任何类型都可以作为 value，包括 map 类型。</p>
<h3 id="value不可达">value不可达<a hidden class="anchor" aria-hidden="true" href="#value不可达">#</a></h3>
<p>看一个例子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">user</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span>
    <span class="nx">age</span>  <span class="kt">int</span>
    <span class="nx">school</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">school</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">school</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Teacher</span> <span class="kt">string</span>
    <span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">school</span><span class="p">{</span><span class="s">&#34;primarySchool&#34;</span><span class="p">:{</span><span class="nx">Teacher</span><span class="p">:</span><span class="s">&#34;李老师&#34;</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span><span class="s">&#34;XX小学&#34;</span><span class="p">},</span> <span class="s">&#34;highSchool&#34;</span><span class="p">:{</span><span class="nx">Teacher</span><span class="p">:</span><span class="s">&#34;曹老师&#34;</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span><span class="s">&#34;XX中学&#34;</span><span class="p">}}</span>
    <span class="nx">u</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;张三&#34;</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span><span class="nx">school</span><span class="p">:</span><span class="nx">s</span><span class="p">}</span>
    <span class="nx">u</span><span class="p">.</span><span class="nx">school</span><span class="p">[</span><span class="s">&#34;highSchool&#34;</span><span class="p">].</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;XX第二中学&#34;</span><span class="c1">//错误
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>返回:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">cannot assign to struct field u.school[&#34;highSchool&#34;].Name in map
</code></pre></td></tr></table>
</div>
</div><p>原因出在user 中的 map[string]school 这里， u.school[“highSchool”] 访问到这里都没有问题，问题在于后面的 “ .Name ” ，因为map[string]school 中储存的school是值拷贝，当要修改school里面的Name时，就发生了不可寻址的错误。</p>
<p>正确的做法有：</p>
<ol>
<li>
<p>重新覆盖，既然无法单独修改里面的某一项，那就全部都替换掉，<code>u.school[“highSchool”] = school{Teacher:“曹老师”, Name:“XX第二中学”}</code></p>
</li>
<li>
<p>改为储存指针，把<code>map[string]school</code> 改为 <code>map[string]*school</code>，把school的指针存进去，这样go就可以寻址，从而可以修改里面的值</p>
</li>
</ol>
<h3 id="多维map">多维map<a hidden class="anchor" aria-hidden="true" href="#多维map">#</a></h3>
<p>用到了一个二维 map，结果第一遍写的时候就碰到了那个 nil map 的问题。</p>
<p>一开始的代码是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">m</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">][</span><span class="s">&#34;b&#34;</span><span class="p">]=</span><span class="s">&#34;ccc&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>后来才想明白如果插新加入的元素也是个 map 的话需要再次 make()或初始化,修正后的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span> <span class="c1">//重新make或直接初始化
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">//正确
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="http://lanlingzi.cn/post/technical/2016/0904_go_map/">http://lanlingzi.cn/post/technical/2016/0904_go_map/</a></p>
<p><a href="https://barbery.me/post/2014-08-06-go%E5%A4%9A%E7%BB%B4map%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98/">https://barbery.me/post/2014-08-06-go%E5%A4%9A%E7%BB%B4map%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98/</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
