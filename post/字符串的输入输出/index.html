<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>字符串的输入输出 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="scanf与printf scanf 原型：int scanf(char *format,&hellip;]); 头文件：stdio.h 返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0x">
<meta name="author" content="">
<link rel="canonical" href="/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="字符串的输入输出" />
<meta property="og:description" content="scanf与printf scanf 原型：int scanf(char *format,&hellip;]); 头文件：stdio.h 返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0x" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-23T21:10:17&#43;00:00" />
<meta property="article:modified_time" content="2017-06-23T21:10:17&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字符串的输入输出"/>
<meta name="twitter:description" content="scanf与printf scanf 原型：int scanf(char *format,&hellip;]); 头文件：stdio.h 返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0x"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "字符串的输入输出",
      "item": "/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "字符串的输入输出",
  "name": "字符串的输入输出",
  "description": "scanf与printf scanf 原型：int scanf(char *format,\u0026hellip;]); 头文件：stdio.h 返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0x",
  "keywords": [
    
  ],
  "articleBody": "scanf与printf scanf 原型：int scanf(char *format,…]);\n头文件：stdio.h\n返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0xff = -1）。\n如果scanf在开头遇到前次函数留下的空白符，scanf一律跳过, 继续运行；如果在中间遇到空白符，scanf将会停止，不读取空白符。\nscanf()自动在读入字符串最后补’\\0’，作为字符数组的最后一个字符，来结束字符串。\n空白符：空格(space)、制表符(tab)和新行符(newline)。\nprintf 原型：int printf(char *format,…]);\n头文件：stdio.h 返回值：printf实际控制输出的字符数 输出字符串，到’\\0’之前。注意要遇到’\\0’也就是字符结束符才停止，要保证需要输出的字符的末尾有’\\0’。\ncin与cout 与scanf和printf完全相同，cin还是不会读入字符串末尾的换行符。\ngetchar与putchar getchar 原型：int getchar(void);\n头文件：stdio.h\n返回值：getchar是一个宏，它定义为getc(stdin)，有一个int型的返回值，用于返回stdin输入流的下一个字符的ASCII码，如出错返回-1，且将用户输入的字符回显到屏幕。\ngetchar()函数的执行采用了行缓冲。程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在输入缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中，会被下个getchar()读取)。当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符。如果用户在按回车之前输入了不止一个字符，其他字符会保留在输入缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才重新等待用户按键。\ngetchar函数通常用在scanf和gets混合使用的时候，用getchar吃掉scanf未读入的’\\n’，然后用gets读取下一行字符串，如下例：\nscanf(\"%d\", \u0026t); getchar(); gets(s);  getchar函数还用在连续用2个getchar函数读取字符的时候，需要中间额外增加一个getchar来吃掉第一行字符剩下的回车，如下例：\nscanf(“%d”, \u0026t); int a=getchar(); getchar(); int b=getchar();  putchar putchar(c);  作用是向终端输出一个字符。\n其中c可以是\n  被单引号（英文状态下）引起来的一个字符，\n  介于0~127之间的一个十进制整型数（包含0和127），它会被视为对应字符的ASCII代码，输出该 ASCII代码对应的字符；和getchar返回的int值搭配。\n  用char定义好的一个字符型变量。\n  返回值：\n（1）当输出正确的时候，返回输出字符转换为的unsigned int 值；\n（2）当输出错误的时候，返回 EOF（End of file）文件结束符\ncin.get 和getchar基本没有分别。\n其实cin.get()存在的基本目的，就是为了从c移植到c++的时候，直接用cin.get()代替getchar()，也正因因此，cin.get()的返回值跟其它cin.get成员函数返回cin对象不同，跟getchar()一样返回int。\ngets与puts（被禁用） gets 原型：char * gets(char * buffer);\n参数：将读取的结果存放在buffer指针所指向的字符数组中\n头文件：stdio.h\n返回值：读入成功，返回与参数buffer相同的指针；读入过程中遇到EOF或发生错误，返回NULL指针。\n从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。\ngets()能够接受空格、制表符TAB，并不会因为字符串中有空格或者TAB而结束字符的获取，它每读入换行符就会返回，即使是一开始就遇到一个换行符。返回后会将换行符变为’\\0’。\ngets是个不安全的函数，可以无限读取，不会判断上限，如果缓存溢出，多出来的字符将被写入栈中，覆盖了栈原先的内容，破坏一个或多个不相关变量的值，使程序崩溃。\n对于gets来说，’\\n’是一个特别的字符，而’\\0’并无任何特别之处，如果读到’\\0’就当作普通字符读入。如果文件中存在’\\0’字符（或者0x00字节），调用gets之后就无法判断缓冲区中的’\\0’究竟是从文件读上来的字符还是由gets自动转换的结束符，所以gets只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有’\\0’。\nputs int puts(const char *string); 头文件：stdio.h 返回值：实际控制输出的字符数  输出字符串，到’\\0’之前，将’\\0’转换为’\\n’换行。注意要遇到’\\0’也就是字符结束符才停止，要保证需要输出的字符的末尾有’\\0’。\ngetline 函数声明 一个是在string头文件中，定义的是一个全局的函数，函数声明是\nistream\u0026 getline ( istream\u0026 is, string\u0026 str, char delim )  与\nistream\u0026 getline ( istream\u0026 is, string\u0026 str );  另一个则是istream的成员函数，函数声明是\nistream\u0026 getline (char* s, streamsize n )  与\nistream\u0026 getline (char* s, streamsize n, char delim );  注意第二个getline是将读取的字符串存储在char数组中而不可以将该参数声明为string类型，因为C++编译器无法执行此默认转换。\n如果规定了streamsize且保存位置为char数组,那么将只读入streamsize-1个字符,并且字符串保存到char数组后,字符串的末位将被自动修改为'\\0'\n它会生成一个包含一串从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束。\n 到文件结束 遇到函数的定界符 输入达到最大限度（优化gets）  如果getline没有读入字符，将返回false，可用于判断文件是否结束。\n该函数可读取一行字符直到定界符(包括定界符)，定界符默认为换行符.\n此点与gets相同，但是因为s的类型为string，以换行符为例,末尾不会将’\\n’转换为’\\0’，而是直接删去。定界符同理,直接删去.\n举例如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include #include  using namespace std; int main(){ char* s; s = new char[50]; //必须要分配空间  cin.getline(s,5); int i = 0; while(s[i] != '\\0'){ couts[i]; i++; } coutendliendl; cin.clear(); //当failbit位为1时需要clear，否则后面的getline读取为空字符串  string str; getline(cin,str); coutstrendl; getline(cin,str,'#'); coutstrendl; getline(cin,str); coutstrendl; return 0; }   输入输出：\n(input)slkdsa;34 slkd 4 sa;34 (input)hel#id hel id  函数流程   首先判断istream的failbit位是否为1，为1的话意味着输入流的状态有错误，则不进行读操作，getline函数结束执行\n  从当前位置开始从输入流中依次读取单个字符并拷贝到缓冲区，直到遇到下列条件满足时，循环结束。\n(1)遇到文件尾时停止读操作，并设置流对象的结束标记为1\n(2)读到调用者指定的分隔符时，此时将分隔符之前的字符拷贝到缓冲区中，但分隔符本身不拷贝进去，并且下次读操作将从分隔符后的下一个字符开始。\n(3)已经读了n-1个字符(n是调用者传入的第二个实参_Count的初值)，此时要把流对象的错误标志位置1\n  fgets与fputs fgets 原型：char * fgets(char * s, int n, FILE *stream);\n头文件：stdio.h\n参数：\n s: 字符型指针，指向存储读入数据的缓冲区的地址。 n: 从流中读入n-1个字符，第n个写入''表示字符串结束。 stream ： 指向读取的流。  返回值：\n 1. 当n 当遇到换行符或者缓冲区已满，fgets就会停止，返回读到的数据。注意’\\n’会被保存，只是后面再加个’\\0’。\n注意，对于fgets来说，’\\n’是一个特别的字符，而’\\0’并无任何特别之处，如果读到’\\0’就当作普通字符读入。如果文件中存在’\\0’字符（或者0x00字节），调用fgets之后就无法判断缓冲区中的’\\0’究竟是从文件读上来的字符还是由fgets自动添加的结束符，所以fgets只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有’\\0’。\nfputs int fputs ( const char * str, FILE * stream );  fputs向指定的文件写入一个字符串。成功写入一个字符串后，文件的位置指针会自动后移，函数返回值为非负整数；否则返回EOF(符号常量，其值为-1)。\n缓冲区s中保存的是以’\\0’结尾的字符串，fputs将该字符串写入文件stream，但并不写入结尾的’\\0’。\nread与write read read是一个系统调用，其他函数会调用该函数\n#include  ssize_t read(int fd, void *buf, size_t nbytes);  read 函数从 filedes 指定的已打开文件中读取 nbytes 字节到 buf 中。以下几种情况会导致读取到的字节数小于 nbytes ：\n  读取普通文件时，读到文件末尾还不够 nbytes 字节。例如：如果文件只有 30 字节，而我们想读取 100 字节，那么实际读到的只有 30 字节，read 函数返回 30 。此时再使用 read 函数作用于这个文件会导致 read 返回 0 。\n  从终端设备（terminal device）读取时，一般情况下每次只能读取一行。\n  从网络读取时，网络缓存可能导致读取的字节数小于 nbytes 字节。\n  读取 pipe 或者 FIFO 时，pipe 或 FIFO 里的字节数可能小于 nbytes 。\n  从面向记录（record-oriented）的设备读取时，某些面向记录的设备（如磁带）每次最多只能返回一个记录。\n  在读取了部分数据时被信号中断。\n  注意：read不会自动加上’\\0’；对于\\n，它也是原封不动的读入，当做普通字符。\nwrite #include  ssize_t write(int fd, const void *buf, size_t nbytes);  返回值：若成功，返回写的字节数；若出错，返回-1.\n其返回值通常与参数nbytes的的值相同，否则表示出错，write出错的一个常见原因是磁带写满，或者超过了一个给定进程的文件长度限制。\n对于普通文件，写操作从文件的当前偏移量开始。如果在打开该文件时，指出了O_APPEND选项，则在每次写操作之前，将文件偏移量设置为在文件当前结尾处。在一次成功写之前，该文件偏移量增加实际写的字节数。\n注意：write不会自动加上’\\0’；对于\\n，它也是原封不动的输出，当做普通字符。\n",
  "wordCount" : "3928",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-23T21:10:17Z",
  "dateModified": "2017-06-23T21:10:17Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      字符串的输入输出
    </h1>
    <div class="post-meta">June 23, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="scanf与printf">scanf与printf<a hidden class="anchor" aria-hidden="true" href="#scanf与printf">#</a></h1>
<h2 id="scanf">scanf<a hidden class="anchor" aria-hidden="true" href="#scanf">#</a></h2>
<p>原型：int scanf(char *format,&hellip;]);</p>
<p>头文件：stdio.h</p>
<p>返回值：返回成功读入的数据项的个数，读到文件末尾或者出错时则返回EOF（0xff = -1）。</p>
<p>如果scanf在开头遇到前次函数留下的空白符，scanf一律跳过, 继续运行；如果在中间遇到空白符，scanf将会停止，不读取空白符。</p>
<p>scanf()自动在读入字符串最后补’\0’，作为字符数组的最后一个字符，来结束字符串。</p>
<p>空白符：空格(space)、制表符(tab)和新行符(newline)。</p>
<h2 id="printf">printf<a hidden class="anchor" aria-hidden="true" href="#printf">#</a></h2>
<p>原型：int printf(char *format,&hellip;]);</p>
<p>头文件：stdio.h
返回值：printf实际控制输出的字符数
输出字符串，到’\0’之前。注意要遇到’\0’也就是字符结束符才停止，要保证需要输出的字符的末尾有’\0’。</p>
<h2 id="cin与cout">cin与cout<a hidden class="anchor" aria-hidden="true" href="#cin与cout">#</a></h2>
<p>与scanf和printf完全相同，cin还是不会读入字符串末尾的换行符。</p>
<h1 id="getchar与putchar">getchar与putchar<a hidden class="anchor" aria-hidden="true" href="#getchar与putchar">#</a></h1>
<h2 id="getchar">getchar<a hidden class="anchor" aria-hidden="true" href="#getchar">#</a></h2>
<p>原型：int getchar(void);</p>
<p>头文件：stdio.h</p>
<p>返回值：getchar是一个宏，它定义为getc(stdin)，有一个int型的返回值，用于返回stdin输入流的下一个字符的ASCII码，如出错返回-1，且将用户输入的字符回显到屏幕。</p>
<p>getchar()函数的执行采用了行缓冲。程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在输入缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中，会被下个getchar()读取)。当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符。如果用户在按回车之前输入了不止一个字符，其他字符会保留在输入缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才重新等待用户按键。</p>
<p>getchar函数通常用在scanf和gets混合使用的时候，用getchar吃掉scanf未读入的’\n’，然后用gets读取下一行字符串，如下例：</p>
<pre><code>scanf(&quot;%d&quot;, &amp;t);
getchar();
gets(s);
</code></pre>
<p>getchar函数还用在连续用2个getchar函数读取字符的时候，需要中间额外增加一个getchar来吃掉第一行字符剩下的回车，如下例：</p>
<pre><code>scanf(“%d”, &amp;t);
int a=getchar();
getchar();
int b=getchar();
</code></pre>
<h2 id="putchar">putchar<a hidden class="anchor" aria-hidden="true" href="#putchar">#</a></h2>
<pre><code>putchar(c);
</code></pre>
<p>作用是向终端输出一个字符。</p>
<p>其中c可以是</p>
<ol>
<li>
<p>被单引号（英文状态下）引起来的一个字符，</p>
</li>
<li>
<p>介于0~127之间的一个十进制整型数（包含0和127），它会被视为对应字符的ASCII代码，输出该 ASCII代码对应的字符；和getchar返回的int值搭配。</p>
</li>
<li>
<p>用char定义好的一个字符型变量。</p>
</li>
</ol>
<p>返回值：</p>
<p>（1）当输出正确的时候，返回输出字符转换为的unsigned int 值；</p>
<p>（2）当输出错误的时候，返回 EOF（End of file）文件结束符</p>
<h2 id="cinget">cin.get<a hidden class="anchor" aria-hidden="true" href="#cinget">#</a></h2>
<p>和getchar基本没有分别。</p>
<p>其实cin.get()存在的基本目的，就是为了从c移植到c++的时候，直接用cin.get()代替getchar()，也正因因此，cin.get()的返回值跟其它cin.get成员函数返回cin对象不同，跟getchar()一样返回int。</p>
<h1 id="gets与puts被禁用">gets与puts（被禁用）<a hidden class="anchor" aria-hidden="true" href="#gets与puts被禁用">#</a></h1>
<h2 id="gets">gets<a hidden class="anchor" aria-hidden="true" href="#gets">#</a></h2>
<p>原型：char * gets(char * buffer);</p>
<p>参数：将读取的结果存放在buffer指针所指向的字符数组中</p>
<p>头文件：stdio.h</p>
<p>返回值：读入成功，返回与参数buffer相同的指针；读入过程中遇到EOF或发生错误，返回NULL指针。</p>
<p>从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。</p>
<p>gets()能够接受空格、制表符TAB，并不会因为字符串中有空格或者TAB而结束字符的获取，它每读入换行符就会返回，即使是一开始就遇到一个换行符。返回后会将换行符变为’\0’。</p>
<p>gets是个不安全的函数，可以无限读取，不会判断上限，如果缓存溢出，多出来的字符将被写入栈中，覆盖了栈原先的内容，破坏一个或多个不相关变量的值，使程序崩溃。</p>
<p>对于gets来说，’\n’是一个特别的字符，而’\0’并无任何特别之处，如果读到’\0’就当作普通字符读入。如果文件中存在’\0’字符（或者0x00字节），调用gets之后就无法判断缓冲区中的’\0’究竟是从文件读上来的字符还是由gets自动转换的结束符，所以gets只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有’\0’。</p>
<h2 id="puts">puts<a hidden class="anchor" aria-hidden="true" href="#puts">#</a></h2>
<pre><code>int puts(const char *string);
头文件：stdio.h
返回值：实际控制输出的字符数
</code></pre>
<p>输出字符串，到’\0’之前，将’\0’转换为’\n’换行。注意要遇到’\0’也就是字符结束符才停止，要保证需要输出的字符的末尾有’\0’。</p>
<h1 id="getline">getline<a hidden class="anchor" aria-hidden="true" href="#getline">#</a></h1>
<h2 id="函数声明">函数声明<a hidden class="anchor" aria-hidden="true" href="#函数声明">#</a></h2>
<p>一个是在string头文件中，定义的是一个全局的函数，函数声明是</p>
<pre><code>istream&amp; getline ( istream&amp; is, string&amp; str, char delim )
</code></pre>
<p>与</p>
<pre><code>istream&amp; getline ( istream&amp; is, string&amp; str );
</code></pre>
<p>另一个则是istream的成员函数，函数声明是</p>
<pre><code>istream&amp; getline (char* s, streamsize n )
</code></pre>
<p>与</p>
<pre><code>istream&amp; getline (char* s, streamsize n, char delim );
</code></pre>
<p>注意第二个getline是将读取的字符串存储在char数组中而不可以将该参数声明为string类型，因为C++编译器无法执行此默认转换。</p>
<p><strong>如果规定了streamsize且保存位置为char数组,那么将只读入streamsize-1个字符,并且字符串保存到char数组后,字符串的末位将被自动修改为'\0'</strong></p>
<p>它会生成一个包含一串从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束。</p>
<ol>
<li>到文件结束</li>
<li>遇到函数的定界符</li>
<li>输入达到最大限度（优化gets）</li>
</ol>
<p>如果getline没有读入字符，将返回false，可用于判断文件是否结束。</p>
<p>该函数可读取一行字符直到定界符(包括定界符)，定界符默认为换行符.</p>
<p>此点与gets相同，但是因为s的类型为string，以换行符为例,末尾不会将’\n’转换为’\0’，而是直接删去。定界符同理,直接删去.</p>
<h2 id="举例如下">举例如下<a hidden class="anchor" aria-hidden="true" href="#举例如下">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span> <span class="c1">//必须要分配空间
</span><span class="c1"></span>    <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">//当failbit位为1时需要clear，否则后面的getline读取为空字符串
</span><span class="c1"></span>
    <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">str</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="sc">&#39;#&#39;</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">str</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">str</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输入输出：</p>
<pre><code>(input)slkdsa;34
slkd
4
sa;34
(input)hel#id
hel
id
</code></pre>
<h2 id="函数流程">函数流程<a hidden class="anchor" aria-hidden="true" href="#函数流程">#</a></h2>
<ol>
<li>
<p>首先判断istream的failbit位是否为1，为1的话意味着输入流的状态有错误，则不进行读操作，getline函数结束执行</p>
</li>
<li>
<p>从当前位置开始从输入流中依次读取单个字符并拷贝到缓冲区，直到遇到下列条件满足时，循环结束。</p>
<p>(1)遇到文件尾时停止读操作，并设置流对象的结束标记为1</p>
<p>(2)读到调用者指定的分隔符时，此时将分隔符之前的字符拷贝到缓冲区中，但分隔符本身不拷贝进去，并且下次读操作将从分隔符后的下一个字符开始。</p>
<p>(3)已经读了n-1个字符(n是调用者传入的第二个实参_Count的初值)，此时要把流对象的错误标志位置1</p>
</li>
</ol>
<h1 id="fgets与fputs">fgets与fputs<a hidden class="anchor" aria-hidden="true" href="#fgets与fputs">#</a></h1>
<h2 id="fgets">fgets<a hidden class="anchor" aria-hidden="true" href="#fgets">#</a></h2>
<p>原型：char *  fgets(char * s, int n, FILE *stream);</p>
<p>头文件：stdio.h</p>
<p>参数：</p>
<pre><code> s: 字符型指针，指向存储读入数据的缓冲区的地址。
 n: 从流中读入n-1个字符，第n个写入''表示字符串结束。
 stream ： 指向读取的流。
</code></pre>
<p>返回值：</p>
<pre><code>  1. 当n&lt;=0 时返回NULL，即空指针。
  2. 当n=1 时，返回空串&quot;&quot;。
  3. 如果读入成功，则返回缓冲区的地址。
  4. 如果读入错误或遇到文件结尾(EOF)，则返回NULL。
</code></pre>
<p>当遇到换行符或者缓冲区已满，fgets就会停止，返回读到的数据。注意’\n’会被保存，只是后面再加个’\0’。</p>
<p>注意，对于fgets来说，’\n’是一个特别的字符，而’\0’并无任何特别之处，如果读到’\0’就当作普通字符读入。如果文件中存在’\0’字符（或者0x00字节），调用fgets之后就无法判断缓冲区中的’\0’究竟是从文件读上来的字符还是由fgets自动添加的结束符，所以fgets只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有’\0’。</p>
<h2 id="fputs">fputs<a hidden class="anchor" aria-hidden="true" href="#fputs">#</a></h2>
<pre><code>int fputs ( const char * str, FILE * stream );
</code></pre>
<p>fputs向指定的文件写入一个字符串。成功写入一个字符串后，文件的位置指针会自动后移，函数返回值为非负整数；否则返回EOF(符号常量，其值为-1)。</p>
<p>缓冲区s中保存的是以’\0’结尾的字符串，fputs将该字符串写入文件stream，但并不写入结尾的’\0’。</p>
<h1 id="read与write">read与write<a hidden class="anchor" aria-hidden="true" href="#read与write">#</a></h1>
<h2 id="read">read<a hidden class="anchor" aria-hidden="true" href="#read">#</a></h2>
<p>read是一个系统调用，其他函数会调用该函数</p>
<pre><code>#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t nbytes); 
</code></pre>
<p>read 函数从 filedes 指定的已打开文件中读取 nbytes 字节到 buf 中。以下几种情况会导致读取到的字节数小于 nbytes ：</p>
<ol>
<li>
<p>读取普通文件时，读到文件末尾还不够 nbytes 字节。例如：如果文件只有 30 字节，而我们想读取 100 字节，那么实际读到的只有 30 字节，read 函数返回 30 。此时再使用 read 函数作用于这个文件会导致 read 返回 0 。</p>
</li>
<li>
<p>从终端设备（terminal device）读取时，一般情况下每次只能读取一行。</p>
</li>
<li>
<p>从网络读取时，网络缓存可能导致读取的字节数小于 nbytes 字节。</p>
</li>
<li>
<p>读取 pipe 或者 FIFO 时，pipe 或 FIFO 里的字节数可能小于 nbytes 。</p>
</li>
<li>
<p>从面向记录（record-oriented）的设备读取时，某些面向记录的设备（如磁带）每次最多只能返回一个记录。</p>
</li>
<li>
<p>在读取了部分数据时被信号中断。</p>
</li>
</ol>
<p><strong>注意：read不会自动加上’\0’；对于\n，它也是原封不动的读入，当做普通字符。</strong></p>
<h2 id="write">write<a hidden class="anchor" aria-hidden="true" href="#write">#</a></h2>
<pre><code>#include &lt;unistd.h&gt;
ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre>
<p>返回值：若成功，返回写的字节数；若出错，返回-1.</p>
<p>其返回值通常与参数nbytes的的值相同，否则表示出错，write出错的一个常见原因是磁带写满，或者超过了一个给定进程的文件长度限制。</p>
<p>对于普通文件，写操作从文件的当前偏移量开始。如果在打开该文件时，指出了O_APPEND选项，则在每次写操作之前，将文件偏移量设置为在文件当前结尾处。在一次成功写之前，该文件偏移量增加实际写的字节数。</p>
<p>注意：write不会自动加上’\0’；对于\n，它也是原封不动的输出，当做普通字符。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
