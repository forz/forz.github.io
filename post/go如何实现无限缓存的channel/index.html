<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go如何实现无限缓存的channel - Forz Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Forz" /><meta name="description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.92.1 with theme even" />


<link rel="canonical" href="/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.98f8e47918247c097fa26317cbb567fe9f05503485bf08d8547f5579543303b1.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go如何实现无限缓存的channel" />
<meta property="og:description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-20T16:58:13+00:00" />
<meta property="article:modified_time" content="2021-07-20T16:58:13+00:00" />

<meta itemprop="name" content="Go如何实现无限缓存的channel">
<meta itemprop="description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存"><meta itemprop="datePublished" content="2021-07-20T16:58:13+00:00" />
<meta itemprop="dateModified" content="2021-07-20T16:58:13+00:00" />
<meta itemprop="wordCount" content="2408">
<meta itemprop="keywords" content="Go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go如何实现无限缓存的channel"/>
<meta name="twitter:description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Forz Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Forz Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
      <a class="menu-item-link" href="/">Home</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/post/">Archives</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/tags/">Tags</a>
    </li><li class="menu-item">
      <a class="menu-item-link" href="/categories/">Categories</a>
    </li>
  </ul>
</nav><div class="docsearch-input__container">
  <input type="search" class="docsearch-input" placeholder="Search" />
</div>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go如何实现无限缓存的channel</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-07-20 </span>
        <div class="post-category">
            <a href="/categories/go/"> Go </a>
            </div>
          <span class="more-meta"> 约 2408 字 </span>
          <span class="more-meta"> 预计阅读 5 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#转载">转载</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>无限缓存的channel拥有下面的特性：</p>
<ol>
<li>不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存中</li>
<li>无数据时read会被阻塞。当没有可读的数据时，从channel中读取的goroutine会被阻塞</li>
<li>读写都是通过channel操作。 内部的缓存不会暴露出来</li>
<li>能够查询当前待读取的数据数量。因为缓存中可能也有待处理的数据，所以需要返回len(buffer)+len(chan)</li>
<li>关闭channel后，还未读取的channel还是能够被读取，读取完之后才能发现channel已经完毕。这和正常的channel的逻辑是一样的，这种情况叫&quot;drain&quot;未读的数据</li>
</ol>
<p>因为我们不能修改内部的channel结构，也不能重载 chan &lt;- 和 &lt;- chan 操作符,所以我们只能通过两个channel的方式封装一个数据结构,来提供读写。</p>
<p>这个数据结构为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnboundedChan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">In</span>     <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span> <span class="c1">// channel for write
</span><span class="c1"></span>	<span class="nx">Out</span>    <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span> <span class="c1">// channel for read
</span><span class="c1"></span>	<span class="nx">buffer</span> <span class="p">[]</span><span class="nx">T</span>      <span class="c1">// buffer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中In这个channel用来写入数据，而Out这个channel用来读取数据。你可以close In这个channel,等所有的数据都读取完后，Out channel也会被自动关闭。 用户是不能自己关闭Out这个channel的，你也关闭不了，因为它是&lt;-chan类型的。</p>
<p>你可以通过Len方法得到所有待读取的数据的长度，也可以通过BufLen只获取缓存中的数据的长度，不包含外发Out channel中数据的长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Len returns len of Out plus len of buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Out</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// BufLen returns len of the buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">BufLen</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>依照Go三巨头之一的设计，底层buffer最好采用ringbuffer的实现方式，如果buffer满了应该能自动扩容:</p>
<p>Such a library should do well in cases of very fast, &ldquo;bursty&rdquo; messages. A large enough buffered channel should be able to absorb bursts while a fast dedicated goroutine drains the channel into a ring buffer from which the messages are delivered at a slower pace to the final consumer of the messages. That ring buffer will need to be efficiently implemented, and will need to be able to grow efficiently (irrespective of size) and that will require some careful engineering. Better to leave that code to a library that can be tuned as needed than baking it into the runtime (and then possibly being at the mercy of release cycles).</p>
<p>所以我又实现了一个ringbuffer,这个ringbuffer比较简单，原因在这里我们不需要考虑并发的问题，这个ringbuffer只会在一个goroutine使用，所以它的实现就非常的简单了，需要注意&quot;读追上写&quot;，以及&quot;写满&quot;这两个边界问题就好了。通过使用ringbuffer，上面的实现就可以更改为下面的代码，可以进一步减少写爆发(burst)的时候分配过多的问题：</p>
<p>unbounded_chan.go:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chanx</span>

<span class="c1">// T defines interface{}, and will be used for generic type after go 1.18 is released.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">interface</span><span class="p">{}</span>

<span class="c1">// UnboundedChan is an unbounded chan.
</span><span class="c1">// In is used to write without blocking, which supports multiple writers.
</span><span class="c1">// and Out is used to read, which supports multiple readers.
</span><span class="c1">// You can close the in channel if you want.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnboundedChan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">In</span>     <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span>    <span class="c1">// channel for write
</span><span class="c1"></span>	<span class="nx">Out</span>    <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span>    <span class="c1">// channel for read
</span><span class="c1"></span>	<span class="nx">buffer</span> <span class="o">*</span><span class="nx">RingBuffer</span> <span class="c1">// buffer
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Len returns len of In plus len of Out plus len of buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">In</span><span class="p">)</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Out</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// BufLen returns len of the buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">BufLen</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// NewUnboundedChan creates the unbounded chan.
</span><span class="c1">// in is used to write without blocking, which supports multiple writers.
</span><span class="c1">// and out is used to read, which supports multiple readers.
</span><span class="c1">// You can close the in channel if you want.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewUnboundedChan</span><span class="p">(</span><span class="nx">initCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NewUnboundedChanSize is like NewUnboundedChan but you can set initial capacity for In, Out, Buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initInCapacity</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">,</span> <span class="nx">initBufCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
	<span class="c1">// 创建三个字段和无限缓存的chan类型
</span><span class="c1"></span>	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initInCapacity</span><span class="p">)</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">UnboundedChan</span><span class="p">{</span><span class="nx">In</span><span class="p">:</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">Out</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">:</span> <span class="nf">NewRingBuffer</span><span class="p">(</span><span class="nx">initBufCapacity</span><span class="p">)}</span>
	<span class="c1">// 通过一个goroutine,不断地从in中读取出来数据，放入到out或者buffer中
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">process</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">ch</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// in关闭，数据读取完后也把out关闭
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in</span>
		<span class="c1">// 如果in已经被closed, 退出loop
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// in is closed
</span><span class="c1"></span>			<span class="k">break</span> <span class="nx">loop</span>
		<span class="p">}</span>

		<span class="c1">// 否则尝试把从in中读取出来的数据放入到out中
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="c1">// 放入成功，说明out刚才还没有满，buffer中也没有额外的数据待处理，所以回到loop开始
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">val</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>

		<span class="c1">// out is full
</span><span class="c1"></span>		<span class="c1">// 如果out已经满了，需要把数据放入到缓存中
</span><span class="c1"></span>		<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
		<span class="c1">// 处理缓存，一直尝试把缓存中的数据放入到out,直到缓存中没有数据了,
</span><span class="c1"></span>           	<span class="c1">// 为了避免阻塞住in channel,还要尝试从in中读取数据，因为这个时候out是满的，所以就直接把数据放入到缓存中
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">!</span><span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="c1">// 从in读取数据，放入到缓存中，如果in被closed, 退出loop
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// in is closed
</span><span class="c1"></span>					<span class="k">break</span> <span class="nx">loop</span>
				<span class="p">}</span>
				<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
			<span class="c1">// 把缓存中最老的数据放入到out中，并移出第一个元素
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Peek</span><span class="p">():</span>
				<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
				<span class="c1">// 避免内存泄露. 如果缓存处理完了，恢复成原始的状态
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">initialSize</span> <span class="p">{</span> <span class="c1">// after burst
</span><span class="c1"></span>					<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// in被关闭，退出loop后，buffer中可能还有未处理的数据，需要把它们塞入到out中
</span><span class="c1"></span>        <span class="c1">// 这个逻辑叫做&#34;drain&#34;。
</span><span class="c1"></span>        <span class="c1">// 这一段逻辑处理完后，就可以把out关闭掉了
</span><span class="c1"></span>	<span class="c1">// drain
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ringbuffer.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chanx</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ErrIsEmpty</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ringbuffer is empty&#34;</span><span class="p">)</span>

<span class="c1">// RingBuffer is a ring buffer for common types.
</span><span class="c1">// It never is full and always grows if it will be full.
</span><span class="c1">// It is not thread-safe(goroutine-safe) so you must use Lock to use it in multiple writers and multiple readers.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RingBuffer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">buf</span>         <span class="p">[]</span><span class="nx">T</span>
	<span class="nx">initialSize</span> <span class="kt">int</span>
	<span class="nx">size</span>        <span class="kt">int</span>
	<span class="nx">r</span>           <span class="kt">int</span> <span class="c1">// read pointer
</span><span class="c1"></span>	<span class="nx">w</span>           <span class="kt">int</span> <span class="c1">// write pointer
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewRingBuffer</span><span class="p">(</span><span class="nx">initialSize</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">RingBuffer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">initialSize</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;initial size must be great than zero&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// initial size must &gt;= 2
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">initialSize</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">initialSize</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RingBuffer</span><span class="p">{</span>
		<span class="nx">buf</span><span class="p">:</span>         <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">initialSize</span><span class="p">),</span>
		<span class="nx">initialSize</span><span class="p">:</span> <span class="nx">initialSize</span><span class="p">,</span>
		<span class="nx">size</span><span class="p">:</span>        <span class="nx">initialSize</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Read</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrIsEmpty</span>
	<span class="p">}</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">]</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">v</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrIsEmpty</span> <span class="p">{</span> <span class="c1">// Empty
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">ErrIsEmpty</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Peek</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">{</span> <span class="c1">// Empty
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">ErrIsEmpty</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">w</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">w</span><span class="o">++</span>

	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">{</span> <span class="c1">// full
</span><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">size</span> <span class="kt">int</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="mi">2</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">+</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span><span class="o">/</span><span class="mi">4</span>
	<span class="p">}</span>

	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>

	<span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:],</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">:])</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">size</span><span class="o">-</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">:],</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">])</span>

	<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">size</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span>
<span class="p">}</span>

<span class="c1">// Capacity returns the size of the underlying buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Capacity</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="转载">转载</h2>
<p><a href="https://colobu.com/2021/05/11/unbounded-channel-in-go/">实现无限缓存的channel</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Forz</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-07-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/go%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go参数传递是传值还是传引用</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/http%E5%8D%8F%E8%AE%AE%E4%B8%ADheader%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/">
            <span class="next-text nav-default">HTTP协议的header的大小写问题</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="forz/forzblog.talk"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Forz</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>






<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
docsearch({
    apiKey: "b4b9da2eba53aa6dabe4b8ac9e8676e1",
    indexName: "forz.forzvina.com",
    appId: "IAR2EF5L65",
    inputSelector: '.docsearch-input',
    debug: false,
});
</script>
</body>
</html>
