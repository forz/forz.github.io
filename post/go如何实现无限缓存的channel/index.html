<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go如何实现无限缓存的channel | Forz Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存">
<meta name="author" content="">
<link rel="canonical" href="/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Go如何实现无限缓存的channel" />
<meta property="og:description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-20T16:58:13&#43;00:00" />
<meta property="article:modified_time" content="2021-07-20T16:58:13&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go如何实现无限缓存的channel"/>
<meta name="twitter:description" content="无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Go如何实现无限缓存的channel",
      "item": "/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go如何实现无限缓存的channel",
  "name": "Go如何实现无限缓存的channel",
  "description": "无限缓存的channel拥有下面的特性： 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存",
  "keywords": [
    "Go"
  ],
  "articleBody": "无限缓存的channel拥有下面的特性：\n 不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存中 无数据时read会被阻塞。当没有可读的数据时，从channel中读取的goroutine会被阻塞 读写都是通过channel操作。 内部的缓存不会暴露出来 能够查询当前待读取的数据数量。因为缓存中可能也有待处理的数据，所以需要返回len(buffer)+len(chan) 关闭channel后，还未读取的channel还是能够被读取，读取完之后才能发现channel已经完毕。这和正常的channel的逻辑是一样的，这种情况叫\"drain\"未读的数据  因为我们不能修改内部的channel结构，也不能重载 chan 这个数据结构为:\n1 2 3 4 5  type UnboundedChan struct { In chan T // channel for write \tOut chan T // channel for read \tbuffer []T // buffer }   其中In这个channel用来写入数据，而Out这个channel用来读取数据。你可以close In这个channel,等所有的数据都读取完后，Out channel也会被自动关闭。 用户是不能自己关闭Out这个channel的，你也关闭不了，因为它是你可以通过Len方法得到所有待读取的数据的长度，也可以通过BufLen只获取缓存中的数据的长度，不包含外发Out channel中数据的长度。\n1 2 3 4 5 6 7 8  // Len returns len of Out plus len of buffer. func (c UnboundedChan) Len() int { return len(c.buffer) + len(c.Out) } // BufLen returns len of the buffer. func (c UnboundedChan) BufLen() int { return len(c.buffer) }   依照Go三巨头之一的设计，底层buffer最好采用ringbuffer的实现方式，如果buffer满了应该能自动扩容:\nSuch a library should do well in cases of very fast, “bursty” messages. A large enough buffered channel should be able to absorb bursts while a fast dedicated goroutine drains the channel into a ring buffer from which the messages are delivered at a slower pace to the final consumer of the messages. That ring buffer will need to be efficiently implemented, and will need to be able to grow efficiently (irrespective of size) and that will require some careful engineering. Better to leave that code to a library that can be tuned as needed than baking it into the runtime (and then possibly being at the mercy of release cycles).\n所以我又实现了一个ringbuffer,这个ringbuffer比较简单，原因在这里我们不需要考虑并发的问题，这个ringbuffer只会在一个goroutine使用，所以它的实现就非常的简单了，需要注意\"读追上写\"，以及\"写满\"这两个边界问题就好了。通过使用ringbuffer，上面的实现就可以更改为下面的代码，可以进一步减少写爆发(burst)的时候分配过多的问题：\nunbounded_chan.go:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  package chanx // T defines interface{}, and will be used for generic type after go 1.18 is released. type T interface{} // UnboundedChan is an unbounded chan. // In is used to write without blocking, which supports multiple writers. // and Out is used to read, which supports multiple readers. // You can close the in channel if you want. type UnboundedChan struct { In chan T // channel for write \tOut chan T // channel for read \tbuffer *RingBuffer // buffer } // Len returns len of In plus len of Out plus len of buffer. func (c UnboundedChan) Len() int { return len(c.In) + c.buffer.Len() + len(c.Out) } // BufLen returns len of the buffer. func (c UnboundedChan) BufLen() int { return c.buffer.Len() } // NewUnboundedChan creates the unbounded chan. // in is used to write without blocking, which supports multiple writers. // and out is used to read, which supports multiple readers. // You can close the in channel if you want. func NewUnboundedChan(initCapacity int) UnboundedChan { return NewUnboundedChanSize(initCapacity, initCapacity, initCapacity) } // NewUnboundedChanSize is like NewUnboundedChan but you can set initial capacity for In, Out, Buffer. func NewUnboundedChanSize(initInCapacity, initOutCapacity, initBufCapacity int) UnboundedChan { // 创建三个字段和无限缓存的chan类型 \tin := make(chan T, initInCapacity) out := make(chan T, initOutCapacity) ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initBufCapacity)} // 通过一个goroutine,不断地从in中读取出来数据，放入到out或者buffer中 \tgo process(in, out, ch) return ch } func process(in, out chan T, ch UnboundedChan) { // in关闭，数据读取完后也把out关闭 \tdefer close(out) loop: for { val, ok := in // 如果in已经被closed, 退出loop \tif !ok { // in is closed \tbreak loop } // 否则尝试把从in中读取出来的数据放入到out中 \tselect { // 放入成功，说明out刚才还没有满，buffer中也没有额外的数据待处理，所以回到loop开始 \tcase out  val: continue default: } // out is full \t// 如果out已经满了，需要把数据放入到缓存中 \tch.buffer.Write(val) // 处理缓存，一直尝试把缓存中的数据放入到out,直到缓存中没有数据了,  // 为了避免阻塞住in channel,还要尝试从in中读取数据，因为这个时候out是满的，所以就直接把数据放入到缓存中 \tfor !ch.buffer.IsEmpty() { select { // 从in读取数据，放入到缓存中，如果in被closed, 退出loop \tcase val, ok := in: if !ok { // in is closed \tbreak loop } ch.buffer.Write(val) // 把缓存中最老的数据放入到out中，并移出第一个元素 \tcase out  ch.buffer.Peek(): ch.buffer.Pop() // 避免内存泄露. 如果缓存处理完了，恢复成原始的状态 \tif ch.buffer.IsEmpty() \u0026\u0026 ch.buffer.size  ch.buffer.initialSize { // after burst \tch.buffer.Reset() } } } } // in被关闭，退出loop后，buffer中可能还有未处理的数据，需要把它们塞入到out中  // 这个逻辑叫做\"drain\"。  // 这一段逻辑处理完后，就可以把out关闭掉了 \t// drain \tfor !ch.buffer.IsEmpty() { out  ch.buffer.Pop() } ch.buffer.Reset() }   ringbuffer.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  package chanx import ( \"errors\" ) var ErrIsEmpty = errors.New(\"ringbuffer is empty\") // RingBuffer is a ring buffer for common types. // It never is full and always grows if it will be full. // It is not thread-safe(goroutine-safe) so you must use Lock to use it in multiple writers and multiple readers. type RingBuffer struct { buf []T initialSize int size int r int // read pointer \tw int // write pointer } func NewRingBuffer(initialSize int) *RingBuffer { if initialSize  0 { panic(\"initial size must be great than zero\") } // initial size must = 2 \tif initialSize == 1 { initialSize = 2 } return \u0026RingBuffer{ buf: make([]T, initialSize), initialSize: initialSize, size: initialSize, } } func (r *RingBuffer) Read() (T, error) { if r.r == r.w { return nil, ErrIsEmpty } v := r.buf[r.r] r.r++ if r.r == r.size { r.r = 0 } return v, nil } func (r *RingBuffer) Pop() T { v, err := r.Read() if err == ErrIsEmpty { // Empty \tpanic(ErrIsEmpty.Error()) } return v } func (r *RingBuffer) Peek() T { if r.r == r.w { // Empty \tpanic(ErrIsEmpty.Error()) } v := r.buf[r.r] return v } func (r *RingBuffer) Write(v T) { r.buf[r.w] = v r.w++ if r.w == r.size { r.w = 0 } if r.w == r.r { // full \tr.grow() } } func (r *RingBuffer) grow() { var size int if r.size  1024 { size = r.size * 2 } else { size = r.size + r.size/4 } buf := make([]T, size) copy(buf[0:], r.buf[r.r:]) copy(buf[r.size-r.r:], r.buf[0:r.r]) r.r = 0 r.w = r.size r.size = size r.buf = buf } func (r *RingBuffer) IsEmpty() bool { return r.r == r.w } // Capacity returns the size of the underlying buffer. func (r *RingBuffer) Capacity() int { return r.size } func (r *RingBuffer) Len() int { if r.r == r.w { return 0 } if r.w  r.r { return r.w - r.r } return r.size - r.r + r.w } func (r *RingBuffer) Reset() { r.r = 0 r.w = 0 r.size = r.initialSize r.buf = make([]T, r.initialSize) }   转载 实现无限缓存的channel\n",
  "wordCount" : "2408",
  "inLanguage": "zh-cn",
  "datePublished": "2021-07-20T16:58:13Z",
  "dateModified": "2021-07-20T16:58:13Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/go%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84channel/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go如何实现无限缓存的channel
    </h1>
    <div class="post-meta">July 20, 2021
</div>
  </header> 
  <div class="post-content"><p>无限缓存的channel拥有下面的特性：</p>
<ol>
<li>不会阻塞write。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存中</li>
<li>无数据时read会被阻塞。当没有可读的数据时，从channel中读取的goroutine会被阻塞</li>
<li>读写都是通过channel操作。 内部的缓存不会暴露出来</li>
<li>能够查询当前待读取的数据数量。因为缓存中可能也有待处理的数据，所以需要返回len(buffer)+len(chan)</li>
<li>关闭channel后，还未读取的channel还是能够被读取，读取完之后才能发现channel已经完毕。这和正常的channel的逻辑是一样的，这种情况叫&quot;drain&quot;未读的数据</li>
</ol>
<p>因为我们不能修改内部的channel结构，也不能重载 chan &lt;- 和 &lt;- chan 操作符,所以我们只能通过两个channel的方式封装一个数据结构,来提供读写。</p>
<p>这个数据结构为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnboundedChan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">In</span>     <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span> <span class="c1">// channel for write
</span><span class="c1"></span>	<span class="nx">Out</span>    <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span> <span class="c1">// channel for read
</span><span class="c1"></span>	<span class="nx">buffer</span> <span class="p">[]</span><span class="nx">T</span>      <span class="c1">// buffer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中In这个channel用来写入数据，而Out这个channel用来读取数据。你可以close In这个channel,等所有的数据都读取完后，Out channel也会被自动关闭。 用户是不能自己关闭Out这个channel的，你也关闭不了，因为它是&lt;-chan类型的。</p>
<p>你可以通过Len方法得到所有待读取的数据的长度，也可以通过BufLen只获取缓存中的数据的长度，不包含外发Out channel中数据的长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Len returns len of Out plus len of buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Out</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// BufLen returns len of the buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">BufLen</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>依照Go三巨头之一的设计，底层buffer最好采用ringbuffer的实现方式，如果buffer满了应该能自动扩容:</p>
<p>Such a library should do well in cases of very fast, &ldquo;bursty&rdquo; messages. A large enough buffered channel should be able to absorb bursts while a fast dedicated goroutine drains the channel into a ring buffer from which the messages are delivered at a slower pace to the final consumer of the messages. That ring buffer will need to be efficiently implemented, and will need to be able to grow efficiently (irrespective of size) and that will require some careful engineering. Better to leave that code to a library that can be tuned as needed than baking it into the runtime (and then possibly being at the mercy of release cycles).</p>
<p>所以我又实现了一个ringbuffer,这个ringbuffer比较简单，原因在这里我们不需要考虑并发的问题，这个ringbuffer只会在一个goroutine使用，所以它的实现就非常的简单了，需要注意&quot;读追上写&quot;，以及&quot;写满&quot;这两个边界问题就好了。通过使用ringbuffer，上面的实现就可以更改为下面的代码，可以进一步减少写爆发(burst)的时候分配过多的问题：</p>
<p>unbounded_chan.go:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chanx</span>

<span class="c1">// T defines interface{}, and will be used for generic type after go 1.18 is released.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">interface</span><span class="p">{}</span>

<span class="c1">// UnboundedChan is an unbounded chan.
</span><span class="c1">// In is used to write without blocking, which supports multiple writers.
</span><span class="c1">// and Out is used to read, which supports multiple readers.
</span><span class="c1">// You can close the in channel if you want.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnboundedChan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">In</span>     <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span>    <span class="c1">// channel for write
</span><span class="c1"></span>	<span class="nx">Out</span>    <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span>    <span class="c1">// channel for read
</span><span class="c1"></span>	<span class="nx">buffer</span> <span class="o">*</span><span class="nx">RingBuffer</span> <span class="c1">// buffer
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Len returns len of In plus len of Out plus len of buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">In</span><span class="p">)</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Out</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// BufLen returns len of the buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="nf">BufLen</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// NewUnboundedChan creates the unbounded chan.
</span><span class="c1">// in is used to write without blocking, which supports multiple writers.
</span><span class="c1">// and out is used to read, which supports multiple readers.
</span><span class="c1">// You can close the in channel if you want.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewUnboundedChan</span><span class="p">(</span><span class="nx">initCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">,</span> <span class="nx">initCapacity</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NewUnboundedChanSize is like NewUnboundedChan but you can set initial capacity for In, Out, Buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewUnboundedChanSize</span><span class="p">(</span><span class="nx">initInCapacity</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">,</span> <span class="nx">initBufCapacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UnboundedChan</span> <span class="p">{</span>
	<span class="c1">// 创建三个字段和无限缓存的chan类型
</span><span class="c1"></span>	<span class="nx">in</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initInCapacity</span><span class="p">)</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">initOutCapacity</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">UnboundedChan</span><span class="p">{</span><span class="nx">In</span><span class="p">:</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">Out</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">buffer</span><span class="p">:</span> <span class="nf">NewRingBuffer</span><span class="p">(</span><span class="nx">initBufCapacity</span><span class="p">)}</span>
	<span class="c1">// 通过一个goroutine,不断地从in中读取出来数据，放入到out或者buffer中
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">process</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">ch</span> <span class="nx">UnboundedChan</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// in关闭，数据读取完后也把out关闭
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in</span>
		<span class="c1">// 如果in已经被closed, 退出loop
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// in is closed
</span><span class="c1"></span>			<span class="k">break</span> <span class="nx">loop</span>
		<span class="p">}</span>

		<span class="c1">// 否则尝试把从in中读取出来的数据放入到out中
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="c1">// 放入成功，说明out刚才还没有满，buffer中也没有额外的数据待处理，所以回到loop开始
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">val</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>

		<span class="c1">// out is full
</span><span class="c1"></span>		<span class="c1">// 如果out已经满了，需要把数据放入到缓存中
</span><span class="c1"></span>		<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
		<span class="c1">// 处理缓存，一直尝试把缓存中的数据放入到out,直到缓存中没有数据了,
</span><span class="c1"></span>           	<span class="c1">// 为了避免阻塞住in channel,还要尝试从in中读取数据，因为这个时候out是满的，所以就直接把数据放入到缓存中
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">!</span><span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="c1">// 从in读取数据，放入到缓存中，如果in被closed, 退出loop
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="c1">// in is closed
</span><span class="c1"></span>					<span class="k">break</span> <span class="nx">loop</span>
				<span class="p">}</span>
				<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
			<span class="c1">// 把缓存中最老的数据放入到out中，并移出第一个元素
</span><span class="c1"></span>			<span class="k">case</span> <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Peek</span><span class="p">():</span>
				<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
				<span class="c1">// 避免内存泄露. 如果缓存处理完了，恢复成原始的状态
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">initialSize</span> <span class="p">{</span> <span class="c1">// after burst
</span><span class="c1"></span>					<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// in被关闭，退出loop后，buffer中可能还有未处理的数据，需要把它们塞入到out中
</span><span class="c1"></span>        <span class="c1">// 这个逻辑叫做&#34;drain&#34;。
</span><span class="c1"></span>        <span class="c1">// 这一段逻辑处理完后，就可以把out关闭掉了
</span><span class="c1"></span>	<span class="c1">// drain
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Pop</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">ch</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ringbuffer.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chanx</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ErrIsEmpty</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;ringbuffer is empty&#34;</span><span class="p">)</span>

<span class="c1">// RingBuffer is a ring buffer for common types.
</span><span class="c1">// It never is full and always grows if it will be full.
</span><span class="c1">// It is not thread-safe(goroutine-safe) so you must use Lock to use it in multiple writers and multiple readers.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RingBuffer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">buf</span>         <span class="p">[]</span><span class="nx">T</span>
	<span class="nx">initialSize</span> <span class="kt">int</span>
	<span class="nx">size</span>        <span class="kt">int</span>
	<span class="nx">r</span>           <span class="kt">int</span> <span class="c1">// read pointer
</span><span class="c1"></span>	<span class="nx">w</span>           <span class="kt">int</span> <span class="c1">// write pointer
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewRingBuffer</span><span class="p">(</span><span class="nx">initialSize</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">RingBuffer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">initialSize</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;initial size must be great than zero&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// initial size must &gt;= 2
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">initialSize</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">initialSize</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RingBuffer</span><span class="p">{</span>
		<span class="nx">buf</span><span class="p">:</span>         <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">initialSize</span><span class="p">),</span>
		<span class="nx">initialSize</span><span class="p">:</span> <span class="nx">initialSize</span><span class="p">,</span>
		<span class="nx">size</span><span class="p">:</span>        <span class="nx">initialSize</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Read</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrIsEmpty</span>
	<span class="p">}</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">]</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">v</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrIsEmpty</span> <span class="p">{</span> <span class="c1">// Empty
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">ErrIsEmpty</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Peek</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">{</span> <span class="c1">// Empty
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">ErrIsEmpty</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">w</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">w</span><span class="o">++</span>

	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">{</span> <span class="c1">// full
</span><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">size</span> <span class="kt">int</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="mi">2</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">+</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span><span class="o">/</span><span class="mi">4</span>
	<span class="p">}</span>

	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>

	<span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:],</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">:])</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">size</span><span class="o">-</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">:],</span> <span class="nx">r</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">r</span><span class="p">.</span><span class="nx">r</span><span class="p">])</span>

	<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">size</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span>
<span class="p">}</span>

<span class="c1">// Capacity returns the size of the underlying buffer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Capacity</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">r</span><span class="p">.</span><span class="nx">w</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RingBuffer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">initialSize</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="转载">转载<a hidden class="anchor" aria-hidden="true" href="#转载">#</a></h2>
<p><a href="https://colobu.com/2021/05/11/unbounded-channel-in-go/">实现无限缓存的channel</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
