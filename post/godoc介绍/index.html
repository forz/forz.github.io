<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Godoc介绍 | Forz Blog</title>
<meta name="keywords" content="godoc" />
<meta name="description" content="go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 所谓Go语言的程">
<meta name="author" content="">
<link rel="canonical" href="/post/godoc%E4%BB%8B%E7%BB%8D/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="Godoc介绍" />
<meta property="og:description" content="go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 所谓Go语言的程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/godoc%E4%BB%8B%E7%BB%8D/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-03T16:23:49&#43;00:00" />
<meta property="article:modified_time" content="2021-01-03T16:23:49&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Godoc介绍"/>
<meta name="twitter:description" content="go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 所谓Go语言的程"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Godoc介绍",
      "item": "/post/godoc%E4%BB%8B%E7%BB%8D/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Godoc介绍",
  "name": "Godoc介绍",
  "description": "go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。 所谓Go语言的程",
  "keywords": [
    "godoc"
  ],
  "articleBody": "go doc go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。\n所谓Go语言的程序实体，是指变量、常量、函数、结构体以及接口。而程序实体的标识符即是代表它们的名称。标识符又分非限定标识符和限定标识符。其中，限定标识符一般用于表示某个代码包中的程序实体或者某个结构体类型中的方法或字段。例如，标准库代码包io中的名为EOF的变量用限定标识符表示即io.EOF。又例如，如果我有一个sync.WaitGroup类型的变量wg并且想调用它的Add方法，那么可以这样写wg.Add()。其中，wg.Add就是一个限定标识符，而后面的()则代表了调用操作。\n下面说明怎样使用go doc命令。先来看一下go doc命令课结束的标记。\n   标记名称 标记描述     -c 加入此标记后会使go doc命令区分参数中字母的大小写。默认情况下，命令是大小写不敏感的。   -cmd 加入此标记后会使go doc命令同时打印出main包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的。   -u 加入此标记后会使go doc命令同时打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的。    这几个标记的意图都非常简单和明确，大家可以根据实际情况选用。\ngo doc命令可以后跟一个或两个参数。当然，我们也可以不附加任务参数。如果不附加参数，那么go doc命令会试图打印出当前目录所代表的代码包的文档及其中的包级程序实体的列表。\n例如，我要在goc2p项目的loadgen代码包所在目录中运行go doc命令的话，那么就会是这样：\n1  hc@ubt:~/golang/goc2p/src/loadgen$ go doc   1 2 3 4 5 6 7 8  package loadgen // import \"loadgen\"  func NewGenerator( caller lib.Caller, timeoutNs time.Duration, lps uint32, durationNs time.Duration, resultCh chan *lib.CallResult) (lib.Generator, error)   如果你需要指定代码包或程序实体，那么就需要在go doc命令后附上参数了。例如，只要我本地的goc2p项目的所在目录存在于GOPATH环境变量中，我就可以在任意目录中敲入go doc loadgen。如此得到的输出一定是与上面那个示例一致的。\n看过loadgen代码包中源码的读者会知道，其中只有一个可导出的程序实体，即NewGenerator函数。这也是上述示例中如此输出的原因。该代码包中的结构体类型myGenerator是不可导出，但是我们只需附加-u标记便可查看它的文档了：\n1  hc@ubt:~$ go doc -u loadgen.myGenerator   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  type myGenerator struct { caller lib.Caller // 调用器。  timeoutNs time.Duration // 处理超时时间，单位：纳秒。  lps uint32 // 每秒载荷量。  durationNs time.Duration // 负载持续时间，单位：纳秒。  concurrency uint32 // 并发量。  tickets lib.GoTickets // Goroutine票池。  stopSign chan byte // 停止信号的传递通道。  cancelSign byte // 取消发送后续结果的信号。  endSign chan uint64 // 完结信号的传递通道，同时被用于传递调用执行计数。  callCount uint64 // 调用执行计数。  status lib.GenStatus // 状态。  resultCh chan *lib.CallResult // 调用结果通道。 } 载荷发生器的实现。 func (gen *myGenerator) Start() func (gen*myGenerator) Status() lib.GenStatus func (gen *myGenerator) Stop() (uint64, bool) func (gen*myGenerator) asyncCall() func (gen *myGenerator) genLoad(throttle chan time.Time) func (gen*myGenerator) handleStopSign(callCount uint64) func (gen *myGenerator) init() error func (gen*myGenerator) interact(rawReq *lib.RawReq)*lib.RawResp func (gen *myGenerator) sendResult(result*lib.CallResult) bool   如此一来，loadgen.myGenerator类型的文档、字段和方法都尽收眼底。注意，这里我们使用到了限定标识符。下面再进一步，如果你只想查看loadgen.myGenerator类型的init方法的文档，那么只要续写这个限定标识符就可以了，像这样：\n1  hc@ubt:~$ go doc -u loadgen.myGenerator.init   1 2 3  func (gen *myGenerator) init() error 初始化载荷发生器。   注意，结构体类型中的字段的文档是无法被单独打印的。另外，go doc命令根据参数查找代码包或程序实体的顺序是：先Go语言根目录（即GOROOT所环境变量指定的那个目录）后工作区目录（即GOPATH环境变量包含的那些目录）。并且，在前者或后者中，go doc命令的查找顺序遵循字典序。因此，如果某个工作区目录中的代码包与标准库中的包重名了，那么它是无法被打印出来的。go doc命令只会打印出第一个匹配的代码包或程序实体的文档。\n我们在前面说过，go doc命令还可以接受两个参数。这是一种更加精细的指定代码包或程序实体的方式。一个显著的区别是，如果你想打印标准库代码包net/http中的结构体类型Request的文档，那么可以这样敲入go doc命令：\n1  go doc http.Request   注意，这里并没有写入net/http代码包的导入路径，而只是写入了其中的最后一个元素http。但是如果你把http.Request拆成两个参数（即http Request）的话，命令程序就会什么也查不到了。因为这与前一种用法的解析方式是不一样的。正确的做法是，当你指定两个参数时，作为第一个参数的代码包名称必须是完整的导入路径，即：在敲入命令go doc net/http Request后，你会得到想要的结果。\n最后，在给定两个参数时，go doc会打印出所有匹配的文档，而不是像给定一个参数时那样只打印出第一个匹配的文档。这对于查找只有大小写不同的多个方法（如New和new）的文档来说非常有用。\n1  hc@ubt:~$ go doc fmt   为了节省篇幅，我们在这里略去了文档查询结果。读者可以自己运行一下上述命令。在该命令被执行之后，我们就可以看到编排整齐有序的文档内容了。这包括代码包fmt及其中所有可导出的包级程序实体的声明、文档和例子。\n有时候我们只是想查看某一个函数或者结构体类型的文档，那么我们可以将这个函数或者结构体的名称加入命令的后面，像这样：\n1  hc@ubt:~$ go doc fmt Printf   或者：\n1  hc@ubt:~$ go doc os File   godoc 顾名思义，godoc 就是 Go 语言的文档。在实际应用中，godoc 可能可以指以下含义：\n https://godoc.org 中的内容 Go 开发工具安装之后，自带的一个命令，就叫做 godoc Go 工具包的文档以及生成该文档所相关的格式  我们从 Go 自带的 godoc 工具讲起吧。前面我们说到的 godoc.org，是 Go 最为官方的文档网站。其中我们可以查阅 Go 原生 package 的文档说明。而 godoc 命令的作用，则是可以让我们在本地建立一个属于自己的 godoc 网站服务（官方的 godoc 其实也基本上是用同一个工具建立起来的）。\n本地安装godoc工具\n1  go get golang.org/x/tools/cmd/godoc   自建的 godoc 有两个作用，一是解决某局域网内无法访问 godoc.org 的尴尬，另一个则是可以本地调试自己的文档。\n我们可以用下面的命令在本地启动自己的 godoc 服务：\n1  godoc -http=127.0.0.1:6060 -play   或者简写为：\n1  godoc -http=:6060 -play   在浏览器输入 http://127.0.0.1:6060 之后，就可以看到熟悉的 Go 文档页面了：\n原理上，godoc 读取的包路径来自于 $GOROOT。因此，如果你要让本地的 godoc 认识并解析你自己的开发包，就应该在 $GOROOT 目录下按照路径结构放好自己的工程代码——软链接也是支持的。比如笔者的 jsonvalue 包，我放在了这个路径下：~/project/github.com/Andrew-M-C/go.jsonvalue，于是我就在 $GOROOT 下建了软链接：\n1 2  go env | grep GOROOT | sed 's/GOROOT=//g' | xargs cd ln -s ~/project/github.com ./   然后在浏览器中输入 http://127.0.0.1:6060/pkg/github.com/Andrew-M-C/go.jsonvalue/，就可以看到和 godoc.org 一样的页面了。\ngodoc 约定 约定   注释符//后面要加空格, 例如: // xxx\n  在package, const, type, func等关键字上面并且紧邻关键字的注释才会被展示\n1 2 3 4 5 6  // 此行注释被省略  // 此行注释被展示 // // 此行注释被展示2 package banana     type, const, func以名称为注释的开头, package以Package name为注释的开头\n1 2 3 4 5 6 7 8 9 10 11  // Package banana ... package banana // Xyz ... const Xyz = 1 // Abc ... type Abc struct {} // Bcd ... func Bcd() {}     有效的关键字注释不应该超过3行\n1 2 3 4 5  // Package banana ... // ... // ... // 最好不要超过三行 package banana     Package的注释如果超过3行, 应该放在当前包目录下一个单独的文件中, 如:doc.go\n  如果当前包目录下包含多个Package注释的go文件(包括doc.go), 那么按照文件名的字母数序优先显示\n1 2 3 4 5 6  //----- doc.go -----  /* ...第一个显示 */ package banana   1 2 3 4  //----- e.go -----  // Package banana ...第二个显示 package banana   1 2 3 4  //----- f.go -----  // Package banana ...第三个显示 package banana     Package的注释会出现在godoc的包列表中, 但只能展示大约523字节的长度\n  在无效注释中以BUG(who)开头的注释, 将被识别为已知bug, 显示在bugs区域, 示例\n1 2 3 4  // BUG(who): 我是bug说明  // Package banana ... package banana     如果bug注释和关键字注释中间无换行, 那么混合的注释将被显示在bugs和godoc列表两个区域内\n1 2 3  // BUG(who): 我是bug注释 // Package banana ...也是pkg注释 package banana     段落:\n1 2 3 4 5 6 7 8 9 10 11 12  /* abc ... bcd Basic(字体加粗变蓝需首字母大写, 中文加粗变蓝需要加上一个大写字母) abc ... ... 属于Basic的段落 ... bcd */ package banana     预格式化:\n1 2 3 4 5 6 7 8  /* abc ... bcd Abc(不会加粗变蓝, 预格式化和段落不能同时存在) abc ... 预格式化需要缩进 ... bcd */     URL将被转化为HTML链接\n  Example  文件必须放在当前包下 文件名以example开头, _连接, test结尾, 如:example_xxx_test.go 包名是当前包名 +_test, 如: strings_test 函数名称的格式func Example[FuncName][_tag]() 函数注释会展示在页面上 函数结尾加上// Output:注释, 说明函数返回的值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 文件必须放在 banana包目录下, 名字必须为example_xxx_test.go  // Package banana_test 为banana包的示例 package banana_test // 此注释将会被展示在页面上 // 此函数将被展示在OverView区域 func Example() { fmt.Println(\"Hello OverView\") // Output:  // Hello OverView } // 此函数将被展示在OverView区域, 并展示noOutput标签 func Example_noOutput() { fmt.Println(\"Hello OverView\") // (Output: )非必须, 存在时将会展示输出结果 } // 此函数将被展示在Function区域 // Peel必须是banana包实现的方法 func ExamplePeel() { fmt.Println(\"Hello Banana\") // Output:  // Hello Banana } // 此函数将被展示在Function区域 // Peel必须是banana包实现的方法, 并展示big标签 func ExamplePeel_big() { fmt.Println(\"Hello Banana\") // Output:  // Hello Banana }   godoc 一览 Go 秉承 “注释即文档” 的理念，符合 godoc 的文档均从 Go 代码中提取并生成。我们还是从 jsonvalue 的 godoc 来看，一个一个说明。在 godoc 中，文档包含三大部分：\n   组成 作用     Overview 总览 包含包的 import 语句和概要说明   Index 目录 包含包中可见性为 public 的常量、类型、方法、函数的总目录及说明   Examples 示例 包含文档中所有示例的快速跳转   Files 文件 列出了包中所有代码文件的超链接   其中第四部分无关紧要。下面我们按顺序说明前三部分     godoc 的 Overview Package jsonvalue 的 Overview 部分包含了三部分内容：\n import 语句 文字说明 代码部分  其中 import 部分是 godoc 自动按照 URL 生成的，这个不用管。至于文字部分和代码部分，godoc 都是从源码中提取出来的。提取的原则是：\n 在代码中所有 package jsonvalue 语句中，找到其上方紧跟着的 // jsonvalue XXX 或者是 /jsonvalue XXX/ 注释块 注释块可以有多行，但必须是连续的 // 或者 /XXX/ 开头。如果需要换行，则留一行空注释 如果找到多个符合条件的注释，则按照文件字母序显示——建议把 Overview 放在一个注释块中，而不要分散撰写。  比如 jsonvalue 的 Overview 说明，统一放在 doc.go 中，这个文件中只有 package jsonvalue 语句以及包说明——这也是不少文章中推荐的做法。\nOverview 的文字部分 请读者打开 doc.go，然后对比 godoc，就可以对照着看到文字部分是怎么被 godoc 呈现出来的。\nOverview 的代码部分 在注释中，如果在 // 后面的注释文本中，如果以 tab 进行了锁进，那么 godoc 会将这一行视为代码块。比如下面这一段：\n其中 “As a quick start:” 行的左边分别为：两个斜杠 + 一个空格。这一行，godoc 视为普通文字；而其余部分的左边为：两个斜杠 + 一个空格 + 一个tab，被 godoc 视为代码部分。于是我们在 godoc 网页上，就可以看到这样的显示结果了：\ngodoc 的代码文档 godoc 工具会搜寻代码中所有源码文件（自测文件除外），然后展示到页面上。搜索的依据如下：\n 搜寻对象是代码中所有的公共部分，包括常量、变量、接口、类型、函数 与 Overview 类似，紧跟着一个公共元素的、以该元素开头的注释段，会被 godoc 视为该元素的注释 换行逻辑和代码块逻辑的处理也与 Overview 相同  不过在源码说明中，更多的采用代码示例来说明逻辑，因此在这一环节中，代码块比较少用。\n这里我用 jsonvalue 的 At() 函数为例。在代码中，对于 Set() 函数我是这么写的（请无视我蹩脚的英文）：\n1 2 3 4 5 6  // At completes the following operation of Set(). It defines posttion of value in Set() and return the new value set. // // The usage of At() is perhaps the most important. This function will recursivly search for child value, and set the new value specified by Set() or SetXxx() series functions. Please unfold and read the following examples, they are important. func (s *Set) At(firstParam interface{}, otherParams ...interface{}) (*V, error) { ...... }   godoc 解析并格式化效果如下：\ngodoc 的代码示例 读者可以注意到，在我的 At() 函数下，除了上文提到的文档正文之外，还有五个代码示例。那么，文档中的代码示例又应该如何写呢？\n首先，我们应该新建至少一个文件，专门用来存放示例代码。比如我就把示例代码写在了 example_jsonvalue_test.go 文件中。这个文件的 package 名也不得与当前包名相同，而应该命名为 包名_test 的格式。\n示例代码的声明 如何声明一个示例代码，这里我举两个例子。首先是在 At() 函数下名为 “Example (1)” 的示例。在代码中，我把这个函数命名为：\n1 2 3  func ExampleSet_At_1() { ...... }   这个函数命名有几个部分：\n   函数名组成部分 说明     Example 这是示例代码的固有开头   Set 表示这是类型 Set 的示例   第一个下划线 _ 分隔符，在这个分隔符后面的，是 Set 类型的成员函数名   At 表示这是函数 At() 的示例，搭配前面的内容，则表示这是类型 Set 的成员函数 At() 的示例   第二个下划线_ 分隔符，在这个分隔符后面的内容，是示例代码的额外说明   1 这是示例代码的额外说明，也就是前面 “Example (1)” 括号里的部分    另外，示例代码中应该包含标准输出内容，这样便于读者了解执行情况。标准输出内容在函数内的最后，采用 // Output:单独起一行开头，剩下的每一行标准输出写一行注释。\n相对应地，如果你想要给（不属于任何一个类型的）函数写示例的话，则去掉上文中关于 “类型” 的字段；如果你不需要示例的额外说明符，则去掉 “额外说明” 字段。比如说，我给类型 Opt 写的示例就只有一个，在代码中，只有一行：\n1 2 3  func ExampleOpt() { ........ }   甚至连示例说明都没有。\n如果一个元素包含多个例子，那么 godoc 会按照字母序对示例及其相应的说明排序。这也就是为什么我干脆在 At() 函数中，示例标为一二三四五的原因，因为这是我希望读者阅读示例的顺序。\n在官网上发布 godoc 好了，当你写好了自己的 godoc 之后，总不是自己看自己自娱自乐吧，总归是要发布出来给大家看的。\n其实发布也很简单：当你将包含了 godox 的代码 push 之后（比如发布到 github 上），就可以在浏览器中输入 https://godoc/org/${package路径名}。比如 jsonvalue 的 Github 路径（也等同于 import 路径）为 github.com/Andrew-M-C/go.jsonvalue，因此输入 godoc.org/github.com/Andrew-M-C/go.jsonvalue。\n如果这是该页面第一次进入，那么 godoc.org 会首先获取、解析和更新代码仓库中的文档内容，并且格式化之后展示。在页面的底部，会列出该 godoc 的更新时间。\n如果你发现官网上的 godoc 内容已经落后了，那么可以点 “Refresh now” 链接刷新它。\n接下来更重要的是，把这份官网 godoc 的链接，附到你自己的 README 中。还是点上图的 “Tools” 链接，就可以在新页面中，看到相应的 godoc 徽标的链接了。有 html 和 markdown 格式任君选择。\n参考 如何写高大上的 godoc（Go 文档）\n",
  "wordCount" : "5888",
  "inLanguage": "zh-cn",
  "datePublished": "2021-01-03T16:23:49Z",
  "dateModified": "2021-01-03T16:23:49Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/godoc%E4%BB%8B%E7%BB%8D/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Godoc介绍
    </h1>
    <div class="post-meta">January 3, 2021
</div>
  </header> 
  <div class="post-content"><h2 id="go-doc">go doc<a hidden class="anchor" aria-hidden="true" href="#go-doc">#</a></h2>
<p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p>
<p>所谓Go语言的程序实体，是指变量、常量、函数、结构体以及接口。而程序实体的标识符即是代表它们的名称。标识符又分非限定标识符和限定标识符。其中，限定标识符一般用于表示某个代码包中的程序实体或者某个结构体类型中的方法或字段。例如，标准库代码包io中的名为EOF的变量用限定标识符表示即io.EOF。又例如，如果我有一个sync.WaitGroup类型的变量wg并且想调用它的Add方法，那么可以这样写wg.Add()。其中，wg.Add就是一个限定标识符，而后面的()则代表了调用操作。</p>
<p>下面说明怎样使用go doc命令。先来看一下go doc命令课结束的标记。</p>
<table>
<thead>
<tr>
<th>标记名称</th>
<th>标记描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>加入此标记后会使go doc命令区分参数中字母的大小写。默认情况下，命令是大小写不敏感的。</td>
</tr>
<tr>
<td>-cmd</td>
<td>加入此标记后会使go doc命令同时打印出main包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的。</td>
</tr>
<tr>
<td>-u</td>
<td>加入此标记后会使go doc命令同时打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的。</td>
</tr>
</tbody>
</table>
<p>这几个标记的意图都非常简单和明确，大家可以根据实际情况选用。</p>
<p>go doc命令可以后跟一个或两个参数。当然，我们也可以不附加任务参数。如果不附加参数，那么go doc命令会试图打印出当前目录所代表的代码包的文档及其中的包级程序实体的列表。</p>
<p>例如，我要在goc2p项目的loadgen代码包所在目录中运行go doc命令的话，那么就会是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">hc</span><span class="o">@</span><span class="n">ubt</span><span class="o">:~/</span><span class="n">golang</span><span class="o">/</span><span class="n">goc2p</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">loadgen</span><span class="o">$</span> <span class="n">go</span> <span class="n">doc</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">loadgen</span> <span class="c1">// import &#34;loadgen&#34;
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">NewGenerator</span><span class="p">(</span>
    <span class="nx">caller</span> <span class="nx">lib</span><span class="p">.</span><span class="nx">Caller</span><span class="p">,</span>
    <span class="nx">timeoutNs</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
    <span class="nx">lps</span> <span class="kt">uint32</span><span class="p">,</span>
    <span class="nx">durationNs</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span>
    <span class="nx">resultCh</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">lib</span><span class="p">.</span><span class="nx">CallResult</span><span class="p">)</span> <span class="p">(</span><span class="nx">lib</span><span class="p">.</span><span class="nx">Generator</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你需要指定代码包或程序实体，那么就需要在go doc命令后附上参数了。例如，只要我本地的goc2p项目的所在目录存在于GOPATH环境变量中，我就可以在任意目录中敲入go doc loadgen。如此得到的输出一定是与上面那个示例一致的。</p>
<p>看过loadgen代码包中源码的读者会知道，其中只有一个可导出的程序实体，即NewGenerator函数。这也是上述示例中如此输出的原因。该代码包中的结构体类型myGenerator是不可导出，但是我们只需附加-u标记便可查看它的文档了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">hc</span><span class="o">@</span><span class="n">ubt</span><span class="o">:~$</span> <span class="n">go</span> <span class="n">doc</span> <span class="o">-</span><span class="n">u</span> <span class="n">loadgen.myGenerator</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myGenerator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">caller</span>      <span class="nx">lib</span><span class="p">.</span><span class="nx">Caller</span>           <span class="c1">// 调用器。
</span><span class="c1"></span>    <span class="nx">timeoutNs</span>   <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>        <span class="c1">// 处理超时时间，单位：纳秒。
</span><span class="c1"></span>    <span class="nx">lps</span>         <span class="kt">uint32</span>               <span class="c1">// 每秒载荷量。
</span><span class="c1"></span>    <span class="nx">durationNs</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>        <span class="c1">// 负载持续时间，单位：纳秒。
</span><span class="c1"></span>    <span class="nx">concurrency</span> <span class="kt">uint32</span>               <span class="c1">// 并发量。
</span><span class="c1"></span>    <span class="nx">tickets</span>     <span class="nx">lib</span><span class="p">.</span><span class="nx">GoTickets</span>        <span class="c1">// Goroutine票池。
</span><span class="c1"></span>    <span class="nx">stopSign</span>    <span class="kd">chan</span> <span class="kt">byte</span>            <span class="c1">// 停止信号的传递通道。
</span><span class="c1"></span>    <span class="nx">cancelSign</span>  <span class="kt">byte</span>                 <span class="c1">// 取消发送后续结果的信号。
</span><span class="c1"></span>    <span class="nx">endSign</span>     <span class="kd">chan</span> <span class="kt">uint64</span>          <span class="c1">// 完结信号的传递通道，同时被用于传递调用执行计数。
</span><span class="c1"></span>    <span class="nx">callCount</span>   <span class="kt">uint64</span>               <span class="c1">// 调用执行计数。
</span><span class="c1"></span>    <span class="nx">status</span>      <span class="nx">lib</span><span class="p">.</span><span class="nx">GenStatus</span>        <span class="c1">// 状态。
</span><span class="c1"></span>    <span class="nx">resultCh</span>    <span class="kd">chan</span> <span class="o">*</span><span class="nx">lib</span><span class="p">.</span><span class="nx">CallResult</span> <span class="c1">// 调用结果通道。
</span><span class="c1"></span><span class="p">}</span>

    <span class="nx">载荷发生器的实现</span><span class="err">。</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span> <span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span><span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">Status</span><span class="p">()</span> <span class="nx">lib</span><span class="p">.</span><span class="nx">GenStatus</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span> <span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span><span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">asyncCall</span><span class="p">()</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span> <span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">genLoad</span><span class="p">(</span><span class="nx">throttle</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span><span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">handleStopSign</span><span class="p">(</span><span class="nx">callCount</span> <span class="kt">uint64</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span> <span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">init</span><span class="p">()</span> <span class="kt">error</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span><span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">interact</span><span class="p">(</span><span class="nx">rawReq</span> <span class="o">*</span><span class="nx">lib</span><span class="p">.</span><span class="nx">RawReq</span><span class="p">)</span><span class="o">*</span><span class="nx">lib</span><span class="p">.</span><span class="nx">RawResp</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span> <span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">sendResult</span><span class="p">(</span><span class="nx">result</span><span class="o">*</span><span class="nx">lib</span><span class="p">.</span><span class="nx">CallResult</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></td></tr></table>
</div>
</div><p>如此一来，loadgen.myGenerator类型的文档、字段和方法都尽收眼底。注意，这里我们使用到了限定标识符。下面再进一步，如果你只想查看loadgen.myGenerator类型的init方法的文档，那么只要续写这个限定标识符就可以了，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">hc</span><span class="o">@</span><span class="n">ubt</span><span class="o">:~$</span> <span class="n">go</span> <span class="n">doc</span> <span class="o">-</span><span class="n">u</span> <span class="n">loadgen.myGenerator.init</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">gen</span> <span class="o">*</span><span class="nx">myGenerator</span><span class="p">)</span> <span class="nf">init</span><span class="p">()</span> <span class="kt">error</span>

    <span class="nx">初始化载荷发生器</span><span class="err">。</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，结构体类型中的字段的文档是无法被单独打印的。另外，go doc命令根据参数查找代码包或程序实体的顺序是：先Go语言根目录（即GOROOT所环境变量指定的那个目录）后工作区目录（即GOPATH环境变量包含的那些目录）。并且，在前者或后者中，go doc命令的查找顺序遵循字典序。因此，如果某个工作区目录中的代码包与标准库中的包重名了，那么它是无法被打印出来的。go doc命令只会打印出第一个匹配的代码包或程序实体的文档。</p>
<p>我们在前面说过，go doc命令还可以接受两个参数。这是一种更加精细的指定代码包或程序实体的方式。一个显著的区别是，如果你想打印标准库代码包net/http中的结构体类型Request的文档，那么可以这样敲入go doc命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">doc</span> <span class="n">http.Request</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，这里并没有写入net/http代码包的导入路径，而只是写入了其中的最后一个元素http。但是如果你把http.Request拆成两个参数（即http Request）的话，命令程序就会什么也查不到了。因为这与前一种用法的解析方式是不一样的。正确的做法是，当你指定两个参数时，作为第一个参数的代码包名称必须是完整的导入路径，即：在敲入命令go doc net/http Request后，你会得到想要的结果。</p>
<p>最后，在给定两个参数时，go doc会打印出所有匹配的文档，而不是像给定一个参数时那样只打印出第一个匹配的文档。这对于查找只有大小写不同的多个方法（如New和new）的文档来说非常有用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">hc</span><span class="o">@</span><span class="n">ubt</span><span class="o">:~$</span> <span class="n">go</span> <span class="n">doc</span> <span class="n">fmt</span>
</code></pre></td></tr></table>
</div>
</div><p>为了节省篇幅，我们在这里略去了文档查询结果。读者可以自己运行一下上述命令。在该命令被执行之后，我们就可以看到编排整齐有序的文档内容了。这包括代码包fmt及其中所有可导出的包级程序实体的声明、文档和例子。</p>
<p>有时候我们只是想查看某一个函数或者结构体类型的文档，那么我们可以将这个函数或者结构体的名称加入命令的后面，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">hc</span><span class="o">@</span><span class="n">ubt</span><span class="o">:~$</span> <span class="n">go</span> <span class="n">doc</span> <span class="n">fmt</span> <span class="n">Printf</span>
</code></pre></td></tr></table>
</div>
</div><p>或者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">hc</span><span class="o">@</span><span class="n">ubt</span><span class="o">:~$</span> <span class="n">go</span> <span class="n">doc</span> <span class="n">os</span> <span class="n">File</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="godoc">godoc<a hidden class="anchor" aria-hidden="true" href="#godoc">#</a></h2>
<p>顾名思义，godoc 就是 Go 语言的文档。在实际应用中，godoc 可能可以指以下含义：</p>
<ol>
<li><a href="https://godoc.org">https://godoc.org</a> 中的内容</li>
<li>Go 开发工具安装之后，自带的一个命令，就叫做 godoc</li>
<li>Go 工具包的文档以及生成该文档所相关的格式</li>
</ol>
<p>我们从 Go 自带的 godoc 工具讲起吧。前面我们说到的 godoc.org，是 Go 最为官方的文档网站。其中我们可以查阅 Go 原生 package 的文档说明。而 godoc 命令的作用，则是可以让我们在本地建立一个属于自己的 godoc 网站服务（官方的 godoc 其实也基本上是用同一个工具建立起来的）。</p>
<p>本地安装godoc工具</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">get</span> <span class="nx">golang</span><span class="p">.</span><span class="nx">org</span><span class="o">/</span><span class="nx">x</span><span class="o">/</span><span class="nx">tools</span><span class="o">/</span><span class="nx">cmd</span><span class="o">/</span><span class="nx">godoc</span>
</code></pre></td></tr></table>
</div>
</div><p>自建的 godoc 有两个作用，一是解决某局域网内无法访问 godoc.org 的尴尬，另一个则是可以本地调试自己的文档。</p>
<p>我们可以用下面的命令在本地启动自己的 godoc 服务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">godoc</span> <span class="o">-</span><span class="n">http</span><span class="o">=</span><span class="m">127.0.0.1</span><span class="o">:</span><span class="m">6060</span> <span class="o">-</span><span class="n">play</span>
</code></pre></td></tr></table>
</div>
</div><p>或者简写为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">godoc -http=:6060 -play
</code></pre></td></tr></table>
</div>
</div><p>在浏览器输入 <a href="http://127.0.0.1:6060">http://127.0.0.1:6060</a> 之后，就可以看到熟悉的 Go 文档页面了：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210103181936.png" alt=""  />
</p>
<p>原理上，godoc 读取的包路径来自于 $GOROOT。因此，如果你要让本地的 godoc 认识并解析你自己的开发包，就应该在 $GOROOT 目录下按照路径结构放好自己的工程代码——软链接也是支持的。比如笔者的 jsonvalue 包，我放在了这个路径下：~/project/github.com/Andrew-M-C/go.jsonvalue，于是我就在 $GOROOT 下建了软链接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-s" data-lang="s"><span class="n">go</span> <span class="n">env</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">GOROOT</span> <span class="o">|</span> <span class="n">sed</span> <span class="s">&#39;s/GOROOT=//g&#39;</span> <span class="o">|</span> <span class="n">xargs</span> <span class="n">cd</span>
<span class="n">ln</span> <span class="o">-</span><span class="n">s</span> <span class="o">~/</span><span class="n">project</span><span class="o">/</span><span class="n">github.com</span> <span class="n">./</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在浏览器中输入 <a href="http://127.0.0.1:6060/pkg/github.com/Andrew-M-C/go.jsonvalue/">http://127.0.0.1:6060/pkg/github.com/Andrew-M-C/go.jsonvalue/</a>，就可以看到和 godoc.org 一样的页面了。</p>
<h2 id="godoc-约定">godoc 约定<a hidden class="anchor" aria-hidden="true" href="#godoc-约定">#</a></h2>
<h3 id="约定">约定<a hidden class="anchor" aria-hidden="true" href="#约定">#</a></h3>
<ol>
<li>
<p>注释符//后面要加空格, 例如: // xxx</p>
</li>
<li>
<p>在package, const, type, func等关键字上面并且紧邻关键字的注释才会被展示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 此行注释被省略
</span><span class="c1"></span>
<span class="c1">// 此行注释被展示
</span><span class="c1">//
</span><span class="c1">// 此行注释被展示2
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>type, const, func以名称为注释的开头, package以Package name为注释的开头</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Package banana ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>

<span class="c1">// Xyz ...
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">Xyz</span> <span class="p">=</span> <span class="mi">1</span>

<span class="c1">// Abc ...
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Abc</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// Bcd ...
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Bcd</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>有效的关键字注释不应该超过3行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Package banana ...
</span><span class="c1">// ...
</span><span class="c1">// ...
</span><span class="c1">// 最好不要超过三行
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Package的注释如果超过3行, 应该放在当前包目录下一个单独的文件中, 如:doc.go</p>
</li>
<li>
<p>如果当前包目录下包含多个Package注释的go文件(包括doc.go), 那么按照文件名的字母数序优先显示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//----- doc.go -----
</span><span class="c1"></span>
<span class="cm">/*
</span><span class="cm">...第一个显示
</span><span class="cm">*/</span>
<span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//----- e.go -----
</span><span class="c1"></span>
<span class="c1">// Package banana ...第二个显示
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//----- f.go -----
</span><span class="c1"></span>
<span class="c1">// Package banana ...第三个显示
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Package的注释会出现在godoc的包列表中, 但只能展示大约523字节的长度</p>
</li>
<li>
<p>在无效注释中以BUG(who)开头的注释, 将被识别为已知bug, 显示在bugs区域, 示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BUG(who): 我是bug说明
</span><span class="c1"></span>
<span class="c1">// Package banana ...
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>如果bug注释和关键字注释中间无换行, 那么混合的注释将被显示在bugs和godoc列表两个区域内</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BUG(who): 我是bug注释
</span><span class="c1">// Package banana ...也是pkg注释
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>段落:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/*
</span><span class="cm">abc ... bcd
</span><span class="cm">
</span><span class="cm">Basic(字体加粗变蓝需首字母大写, 中文加粗变蓝需要加上一个大写字母)
</span><span class="cm">
</span><span class="cm">abc
</span><span class="cm">...
</span><span class="cm">... 属于Basic的段落
</span><span class="cm">...
</span><span class="cm">bcd
</span><span class="cm">*/</span>
<span class="kn">package</span> <span class="nx">banana</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>预格式化:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/*
</span><span class="cm">abc ... bcd
</span><span class="cm">
</span><span class="cm">Abc(不会加粗变蓝, 预格式化和段落不能同时存在)
</span><span class="cm">
</span><span class="cm">    abc ... 预格式化需要缩进 ... bcd
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>URL将被转化为HTML链接</p>
</li>
</ol>
<h3 id="example">Example<a hidden class="anchor" aria-hidden="true" href="#example">#</a></h3>
<ul>
<li>文件必须放在当前包下</li>
<li>文件名以example开头, _连接, test结尾, 如:<code>example_xxx_test.go</code></li>
<li>包名是当前包名 +_test, 如: <code>strings_test</code></li>
<li>函数名称的格式<code>func Example[FuncName][_tag]()</code></li>
<li>函数注释会展示在页面上</li>
<li>函数结尾加上// Output:注释, 说明函数返回的值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 文件必须放在 banana包目录下, 名字必须为example_xxx_test.go
</span><span class="c1"></span>
<span class="c1">// Package banana_test 为banana包的示例
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">banana_test</span>

<span class="c1">// 此注释将会被展示在页面上
</span><span class="c1">// 此函数将被展示在OverView区域
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello OverView&#34;</span><span class="p">)</span>

    <span class="c1">// Output:
</span><span class="c1"></span>    <span class="c1">// Hello OverView
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 此函数将被展示在OverView区域, 并展示noOutput标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Example_noOutput</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello OverView&#34;</span><span class="p">)</span>
    <span class="c1">// (Output: )非必须, 存在时将会展示输出结果
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 此函数将被展示在Function区域
</span><span class="c1">// Peel必须是banana包实现的方法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ExamplePeel</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello Banana&#34;</span><span class="p">)</span>

    <span class="c1">// Output:
</span><span class="c1"></span>    <span class="c1">// Hello Banana
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 此函数将被展示在Function区域
</span><span class="c1">// Peel必须是banana包实现的方法, 并展示big标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ExamplePeel_big</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello Banana&#34;</span><span class="p">)</span>

    <span class="c1">// Output:
</span><span class="c1"></span>    <span class="c1">// Hello Banana
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="godoc-一览">godoc 一览<a hidden class="anchor" aria-hidden="true" href="#godoc-一览">#</a></h2>
<p>Go 秉承 “注释即文档” 的理念，符合 godoc 的文档均从 Go 代码中提取并生成。我们还是从 jsonvalue 的 godoc 来看，一个一个说明。在 godoc 中，文档包含三大部分：</p>
<table>
<thead>
<tr>
<th>组成</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Overview 总览</td>
<td>包含包的 import 语句和概要说明</td>
</tr>
<tr>
<td>Index 目录</td>
<td>包含包中可见性为 public 的常量、类型、方法、函数的总目录及说明</td>
</tr>
<tr>
<td>Examples 示例</td>
<td>包含文档中所有示例的快速跳转</td>
</tr>
<tr>
<td>Files 文件</td>
<td>列出了包中所有代码文件的超链接</td>
</tr>
<tr>
<td>其中第四部分无关紧要。下面我们按顺序说明前三部分</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="godoc-的-overview">godoc 的 Overview<a hidden class="anchor" aria-hidden="true" href="#godoc-的-overview">#</a></h2>
<p>Package jsonvalue 的 Overview 部分包含了三部分内容：</p>
<ul>
<li>import 语句</li>
<li>文字说明</li>
<li>代码部分</li>
</ul>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210103183739.png" alt=""  />
</p>
<p>其中 import 部分是 godoc 自动按照 URL 生成的，这个不用管。至于文字部分和代码部分，godoc 都是从源码中提取出来的。提取的原则是：</p>
<ul>
<li>在代码中所有 package jsonvalue 语句中，找到其上方紧跟着的 // jsonvalue XXX 或者是 /<em>jsonvalue XXX</em>/ 注释块</li>
<li>注释块可以有多行，但必须是连续的 // 或者 /<em>XXX</em>/ 开头。如果需要换行，则留一行空注释</li>
<li>如果找到多个符合条件的注释，则按照文件字母序显示——建议把 Overview 放在一个注释块中，而不要分散撰写。</li>
</ul>
<p>比如 jsonvalue 的 Overview 说明，统一放在 doc.go 中，这个文件中只有 package jsonvalue 语句以及包说明——这也是不少文章中推荐的做法。</p>
<h3 id="overview-的文字部分">Overview 的文字部分<a hidden class="anchor" aria-hidden="true" href="#overview-的文字部分">#</a></h3>
<p>请读者打开 doc.go，然后对比 godoc，就可以对照着看到文字部分是怎么被 godoc 呈现出来的。</p>
<h3 id="overview-的代码部分">Overview 的代码部分<a hidden class="anchor" aria-hidden="true" href="#overview-的代码部分">#</a></h3>
<p>在注释中，如果在 // 后面的注释文本中，如果以 tab 进行了锁进，那么 godoc 会将这一行视为代码块。比如下面这一段：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210103212550.png" alt=""  />
</p>
<p>其中 &ldquo;As a quick start:&rdquo; 行的左边分别为：两个斜杠 + 一个空格。这一行，godoc 视为普通文字；而其余部分的左边为：两个斜杠 + 一个空格 + 一个tab，被 godoc 视为代码部分。于是我们在 godoc 网页上，就可以看到这样的显示结果了：</p>
<h2 id="godoc-的代码文档">godoc 的代码文档<a hidden class="anchor" aria-hidden="true" href="#godoc-的代码文档">#</a></h2>
<p>godoc 工具会搜寻代码中所有源码文件（自测文件除外），然后展示到页面上。搜索的依据如下：</p>
<ul>
<li>搜寻对象是代码中所有的公共部分，包括常量、变量、接口、类型、函数</li>
<li>与 Overview 类似，紧跟着一个公共元素的、以该元素开头的注释段，会被 godoc 视为该元素的注释</li>
<li>换行逻辑和代码块逻辑的处理也与 Overview 相同</li>
</ul>
<p>不过在源码说明中，更多的采用代码示例来说明逻辑，因此在这一环节中，代码块比较少用。</p>
<p>这里我用 jsonvalue 的 At() 函数为例。在代码中，对于 Set() 函数我是这么写的（请无视我蹩脚的英文）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// At completes the following operation of Set(). It defines posttion of value in Set() and return the new value set.
</span><span class="c1">//
</span><span class="c1">// The usage of At() is perhaps the most important. This function will recursivly search for child value, and set the new value specified by Set() or SetXxx() series functions. Please unfold and read the following examples, they are important.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Set</span><span class="p">)</span> <span class="nf">At</span><span class="p">(</span><span class="nx">firstParam</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">otherParams</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">V</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>godoc 解析并格式化效果如下：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210103214124.png" alt=""  />
</p>
<h2 id="godoc-的代码示例">godoc 的代码示例<a hidden class="anchor" aria-hidden="true" href="#godoc-的代码示例">#</a></h2>
<p>读者可以注意到，在我的 At() 函数下，除了上文提到的文档正文之外，还有五个代码示例。那么，文档中的代码示例又应该如何写呢？</p>
<p>首先，我们应该新建至少一个文件，专门用来存放示例代码。比如我就把示例代码写在了 example_jsonvalue_test.go 文件中。这个文件的 package 名也不得与当前包名相同，而应该命名为 包名_test 的格式。</p>
<h3 id="示例代码的声明">示例代码的声明<a hidden class="anchor" aria-hidden="true" href="#示例代码的声明">#</a></h3>
<p>如何声明一个示例代码，这里我举两个例子。首先是在 At() 函数下名为 “Example (1)” 的示例。在代码中，我把这个函数命名为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ExampleSet_At_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数命名有几个部分：</p>
<table>
<thead>
<tr>
<th>函数名组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Example</td>
<td>这是示例代码的固有开头</td>
</tr>
<tr>
<td>Set</td>
<td>表示这是类型 Set 的示例</td>
</tr>
<tr>
<td>第一个下划线 _</td>
<td>分隔符，在这个分隔符后面的，是 Set 类型的成员函数名</td>
</tr>
<tr>
<td>At</td>
<td>表示这是函数 At() 的示例，搭配前面的内容，则表示这是类型 Set 的成员函数 At() 的示例</td>
</tr>
<tr>
<td>第二个下划线_</td>
<td>分隔符，在这个分隔符后面的内容，是示例代码的额外说明</td>
</tr>
<tr>
<td>1</td>
<td>这是示例代码的额外说明，也就是前面 “Example (1)” 括号里的部分</td>
</tr>
</tbody>
</table>
<p>另外，示例代码中应该包含标准输出内容，这样便于读者了解执行情况。标准输出内容在函数内的最后，采用 <code>// Output:</code>单独起一行开头，剩下的每一行标准输出写一行注释。</p>
<p>相对应地，如果你想要给（不属于任何一个类型的）函数写示例的话，则去掉上文中关于 “类型” 的字段；如果你不需要示例的额外说明符，则去掉 “额外说明” 字段。比如说，我给类型 Opt 写的示例就只有一个，在代码中，只有一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ExampleOpt</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">......</span><span class="p">..</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>甚至连示例说明都没有。</p>
<p>如果一个元素包含多个例子，那么 godoc 会按照字母序对示例及其相应的说明排序。这也就是为什么我干脆在 At() 函数中，示例标为一二三四五的原因，因为这是我希望读者阅读示例的顺序。</p>
<h2 id="在官网上发布-godoc">在官网上发布 godoc<a hidden class="anchor" aria-hidden="true" href="#在官网上发布-godoc">#</a></h2>
<p>好了，当你写好了自己的 godoc 之后，总不是自己看自己自娱自乐吧，总归是要发布出来给大家看的。</p>
<p>其实发布也很简单：当你将包含了 godox 的代码 push 之后（比如发布到 github 上），就可以在浏览器中输入 <a href="https://godoc/org/$%7Bpackage">https://godoc/org/${package</a>路径名}。比如 jsonvalue 的 Github 路径（也等同于 import 路径）为 github.com/Andrew-M-C/go.jsonvalue，因此输入 godoc.org/github.com/Andrew-M-C/go.jsonvalue。</p>
<p>如果这是该页面第一次进入，那么 godoc.org 会首先获取、解析和更新代码仓库中的文档内容，并且格式化之后展示。在页面的底部，会列出该 godoc 的更新时间。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210103214905.png" alt=""  />
</p>
<p>如果你发现官网上的 godoc 内容已经落后了，那么可以点 “Refresh now” 链接刷新它。</p>
<p>接下来更重要的是，把这份官网 godoc 的链接，附到你自己的 README 中。还是点上图的 “Tools” 链接，就可以在新页面中，看到相应的 godoc 徽标的链接了。有 html 和 markdown 格式任君选择。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20210103215322.png" alt=""  />
</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://cloud.tencent.com/developer/article/1526609">如何写高大上的 godoc（Go 文档）</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/godoc/">godoc</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
