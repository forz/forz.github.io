<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>猴子补丁:monkey | Forz Blog</title>
<meta name="keywords" content="Go, monkey" />
<meta name="description" content="前言 我们已经知道： 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过Go">
<meta name="author" content="">
<link rel="canonical" href="/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="猴子补丁:monkey" />
<meta property="og:description" content="前言 我们已经知道： 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过Go" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-01-25T23:36:00&#43;00:00" />
<meta property="article:modified_time" content="2020-01-25T23:36:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="猴子补丁:monkey"/>
<meta name="twitter:description" content="前言 我们已经知道： 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过Go"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "猴子补丁:monkey",
      "item": "/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "猴子补丁:monkey",
  "name": "猴子补丁:monkey",
  "description": "前言 我们已经知道： 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过Go",
  "keywords": [
    "Go", "monkey"
  ],
  "articleBody": "前言 我们已经知道：\n 全局变量可通过GoStub框架打桩 过程可通过GoStub框架打桩 函数可通过GoStub框架打桩 interface可通过GoMock框架打桩  但还有两个问题比较棘手：\n 方法（成员函数）无法通过GoStub框架打桩，当产品代码的OO设计比较多时，打桩点可能离被测函数比较远，导致UT用例写起来比较痛 过程或函数通过GoStub框架打桩时，对产品代码有侵入性  下面我们举两个例子，阐述GoStub框架对产品代码的侵入性\n例一：函数定义侵入\n1 2 3  func Exec(cmd string, args ...string) (string, error) { ... }   上面的函数Exec的定义为常规方式，但这时不能通过GoStub框架对函数Exec进行打桩，除非将函数Exec定义为非常规方式（侵入性）：\n1 2 3  var Exec = func(cmd string, args ...string) (string, error) { ... }   例二：适配层侵入\n产品代码中很多函数都会调用Golang的库函数或第三方的库函数，这些库函数的定义显然是常规方式，要想通过GoStub框架对这些函数打桩，一般会在适配层定义相关的变量（侵入性）：\n1 2 3 4 5 6  package adapter var Stat = os.Stat var Marshal = json.Marshal var UnMarshal = json.Unmarshal ...   本文将介绍第四个框架Monkey的使用方法，目的是解决这两个棘手的问题，同时考虑将GoStub的优点集成到Monkey。\n原理 monkey patch(猴子补丁)是一种在不改变原始源代码的情况下扩展或修改动态语言的运行时代码的方法。许多人认为猴子修补只限于Python等动态语言。但事实并非如此，我们可以在运行时来修改Go函数。主角就是github.com/bouk/monkey。\n猴子补丁主要有以下几个用处：\n 在运行时替换方法、属性等 在不修改第三方代码的情况下增加原来不支持的功能 在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加 增加钩子，在执行某个方法的同时执行一些其他的处理，如打印日志，实现AOP等。  调用函数的实现 看看下面的代码反编译之后的结果：\n1 2 3 4 5 6 7  package main func a() int { return 1 } func main() { print(a()) }   编译完成后通过Hopper查看，上面的代码将会展示下面的汇编代码：\n我将参考屏幕左侧显示的各种指令的地址。\n我们的代码从过程main.main开始，指令 0x2010 到 0x2026 初始化了栈。你可以参考这些扩展阅读，下面的文章将会忽略那些代码。\n0x202a 行调用了函数main.a，0x2000 行简单得把 0x1 压入栈返回。0x202f 到 0x2037 行把值传给了runtime.printint。\n够简单了！现在咱们一起看看 Go 里面的函数值是如何实现的。\n看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  package main import ( \"fmt\" \"unsafe\" ) func a() int { return 1 } func main() { f := a fmt.Printf(\"0x%x\\n\", *(*uintptr)(unsafe.Pointer(\u0026f))) }   在第11行把a赋值给了f，这就意味着调用f()将会调用a。接下来用unsafe包读取出存在f里面的值。如果你是有 C 语言背景的程序员你可能会认为简单得把指向函数a的指针打印出来将会得到 0x2000（就是上面汇编里面看到的地址）。当我运行上面的代码得到了 0x102c38，这个地址相差了十万八千里！反编译后，这是第11行的代码：\n这里引用了main.a.f，我们看看那个位置，可以发现：\n啊哈！main.a.f在 0x102c38 并且包含值 0x2000，它正好是main.a的地址。看起来f并不是指向函数的指针，而是指向函数的指针的指针。让我们修改代码证实：\n1 2 3 4 5 6 7 8 9 10 11 12 13  package main import ( \"fmt\" \"unsafe\" ) func a() int { return 1 } func main() { f := a fmt.Printf(\"0x%x\\n\", **(**uintptr)(unsafe.Pointer(\u0026f))) }   和我们期望的一样，将会打印 0x2000。在这里我们也能找到一些线索。Go 语言的函数值包含了额外的信息，这是闭包和绑定实例实现的方式。\n1 2 3 4  type funcval struct { fn uintptr // variable-size, fn-specific data here }   接下来看看调用函数值的实现。把代码改成下面这样，给f赋值之后调用它。\n1 2 3 4 5 6 7 8  package main func a() int { return 1 } func main() { f := a f() }   反编译后可以得到下面的结果：\nmain.a.f加载到寄存器rdx里，然后把rdx寄存器指向的地址存入rbx里，最后调用。函数的地址值总是会加载到rdx寄存器里面，当代码调用的时候可以用来加载一些可能会用到的额外信息。这里的额外信息是指向绑定的实例和匿名函数闭包的指针。如果你想了解更多我建议你深入研究一下反编译代码！\n运行时替换函数 让我们用新的知识实现 Go 语言里面的猴子补丁。\n我们是想实现的是让下面的代码打印出来2:\n1 2 3 4 5 6 7 8 9  package main func a() int { return 1 } func b() int { return 2 } func main() { replace(a, b) print(a()) }   如何实现replace?我们需要修改函数a，让它跳转到b的代码，跳过执行它自己的代码。实际上，我们需要通过这种方法来实现替换，加载函数b到寄存器rdx，然后执行时跳转到rdx上面。\n1 2  mov rdx, main.b.f ; 48 C7 C2 ?? ?? ?? ?? jmp [rdx] ; FF 22   我在汇编代码旁边附上了相应的机器码（你可以用这种在线汇编工具来模拟测试）。编写一个生成上面汇编代码的函数就很简单了，类似于下面这样：\n1 2 3 4 5 6 7 8 9 10 11  func assembleJump(f func() int) []byte { funcVal := *(*uintptr)(unsafe.Pointer(\u0026f)) return []byte{ 0x48, 0xC7, 0xC2, byte(funcval  0), byte(funcval  8), byte(funcval  16), byte(funcval  24), // MOV rdx, funcVal  0xFF, 0x22, // JMP [rdx]  } }   这样就能把a的函数体指向b了！下面的代码尝试复制机器代码到函数体上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package main import ( \"syscall\" \"unsafe\" ) func a() int { return 1 } func b() int { return 2 } func rawMemoryAccess(b uintptr) []byte { return (*(*[0xFF]byte)(unsafe.Pointer(b)))[:] } func assembleJump(f func() int) []byte { funcVal := *(*uintptr)(unsafe.Pointer(\u0026f)) return []byte{ 0x48, 0xC7, 0xC2, byte(funcVal  0), byte(funcVal  8), byte(funcVal  16), byte(funcVal  24), // MOV rdx, funcVal \t0xFF, 0x22, // JMP [rdx] \t} } func replace(orig, replacement func() int) { bytes := assembleJump(replacement) functionLocation := **(**uintptr)(unsafe.Pointer(\u0026orig)) window := rawMemoryAccess(functionLocation) copy(window, bytes) } func main() { replace(a, b) print(a()) }   运行上面的代码并不会工作，结果会是 segementation fault 段错误。这是因为加载后的二进制文件默认不允许修改。我们可以使用系统调用mprotect来关掉这个保护，这个最终版的代码终于可以像期望的那样，通过调用替换后的函数来打印出来 2。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import ( \"syscall\" \"unsafe\" ) func a() int { return 1 } func b() int { return 2 } func getPage(p uintptr) []byte { return (*(*[0xFFFFFF]byte)(unsafe.Pointer(p \u0026 ^uintptr(syscall.Getpagesize()-1))))[:syscall.Getpagesize()] } func rawMemoryAccess(b uintptr) []byte { return (*(*[0xFF]byte)(unsafe.Pointer(b)))[:] } func assembleJump(f func() int) []byte { funcVal := *(*uintptr)(unsafe.Pointer(\u0026f)) return []byte{ 0x48, 0xC7, 0xC2, byte(funcVal  0), byte(funcVal  8), byte(funcVal  16), byte(funcVal  24), // MOV rdx, funcVal \t0xFF, 0x22, // JMP rdx \t} } func replace(orig, replacement func() int) { bytes := assembleJump(replacement) functionLocation := **(**uintptr)(unsafe.Pointer(\u0026orig)) window := rawMemoryAccess(functionLocation) page := getPage(functionLocation) syscall.Mprotect(page, syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC) copy(window, bytes) } func main() { replace(a, b) print(a()) }   使用场景 Monkey框架的使用场景很多，依次为：\n 基本场景：为一个函数打桩 基本场景：为一个过程打桩 基本场景：为一个方法打桩 复合场景：由任意相同或不同的基本场景组合而成 特殊场景：桩中桩的一个案例  函数打桩 Exec是infra层的一个操作函数，实现很简单，代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // infra/os-encap/exec.go  func Exec(cmd string, args ...string) (string, error) { cmdpath, err := exec.LookPath(cmd) if err != nil { fmt.Errorf(\"exec.LookPath err: %v, cmd: %s\", err, cmd) return \"\", infra.ErrExecLookPathFailed } var output []byte output, err = exec.Command(cmdpath, args...).CombinedOutput() if err != nil { fmt.Errorf(\"exec.Command.CombinedOutput err: %v, cmd: %s\", err, cmd) return \"\", infra.ErrExecCombinedOutputFailed } fmt.Println(\"CMD[\", cmdpath, \"]ARGS[\", args, \"]OUT[\", string(output), \"]\") return string(output), nil }   Exec函数的实现中调用了库函数exec.LoopPath和exec.Command，因此Exec函数的返回值和运行时的底层环境密切相关。在UT中，如果被测函数调用了Exec函数，则应根据用例的场景对Exec函数打桩。\nMonkey的API非常简单和直接，我们直接看打桩代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import ( \"testing\" . \"github.com/smartystreets/goconvey/convey\" . \"github.com/bouk/monkey\" \"infra/osencap\" ) const any = \"any\" func TestExec(t *testing.T) { Convey(\"test has digit\", t, func() { Convey(\"for succ\", func() { outputExpect := \"xxx-vethName100-yyy\" guard := Patch(osencap.Exec, func(_ string, _ ...string) (string, error) { return outputExpect, nil }) defer guard.Unpatch() output, err := osencap.Exec(any, any) So(output, ShouldEqual, outputExpect) So(err, ShouldBeNil) }) }) }   Patch是Monkey提供给用户用于函数打桩的API：\n 第一个参数是目标函数的函数名 第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包 返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁  过程打桩 当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。\n我们对过程DestroyResource的打桩代码为：\n1 2 3 4  guard := Patch(DestroyResource, func(_ string) { }) defer guard.Unpatch()   方法打桩 当微服务有多个实例时，先通过Etcd选举一个Master实例，然后Master实例为所有实例较均匀的分配任务，并将任务分配结果Set到Etcd，最后Master和Node实例Watch到任务列表，并过滤出自身需要处理的任务列表。\n我们用类Etcd的方法Get来模拟获取任务列表的功能，入参为instanceId：\n1 2 3 4 5 6 7 8  type Etcd struct { } func (e *Etcd) Get(instanceId string) []string { taskList := make([]string, 0) ... return taskList   我们对Get方法的打桩代码如下：\n1 2 3 4 5  var e *Etcd guard := PatchInstanceMethod(reflect.TypeOf(e), \"Get\", func(_ *Etcd, _ string) []string { return []string{\"task1\", \"task5\", \"task8\"} }) defer guard.Unpatch()   PatchInstanceMethod API是Monkey提供给用户用于方法打桩的API：\n 在使用前，先要定义一个目标类的指针变量x 第一个参数是reflect.TypeOf(x) 第二个参数是字符串形式的函数名 返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁  场景组合 假设Px为用于函数、过程或方法打桩的API调用，则任意相同或不同基本场景组合的打桩过程形式化表达为：\n1 2 3 4 5  Px1 defer UnpatchAll() Px2 ... Pxn   该测试执行完后，函数UnpatchAll将删除所有的补丁。\n桩中桩 在某些特殊场景下（比如反序列化），函数或方法既有返回值，又有出参。出参一般为指针类型，包括具体的指针类型（比如*int)和抽象的指针类型（一般为interface{}）。我们常用的库函数json.Unmarshal就属于这种情况。\n笔者在实践中遇到的出参类型大多是具体的指针类型，其指针变量指向的内存不管在传入前确定还是在传入后确定，都将影响后面的代码逻辑。\n下面呈现桩中桩的一个案例，以便大家灵活使用Monkey框架。\n何谓桩中桩？\ninterface中声明了一个方法，既有返回值，又有出参。在测试中，先通过GoMock框架打桩多态到mock方法，然后又通过Monkey框架跳转到补丁方法，最终修改出参并返回。在这个过程中，mock方法可以看作一个桩，补丁方法又可以看作mock方法的一个桩，即补丁方法是一个桩中桩。\n定义一个具体类型Movie：\n1 2 3 4 5  type Movie struct { Name string Type string Score int }   定义一个interface类型Repository：\n1 2 3 4  type Repository interface { Retrieve(key string, movie *Movie) error ... }   桩中桩的一个测试用例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func TestDemo(t *testing.T) { Convey(\"test demo\", t, func() { Convey(\"retrieve movie\", func() { ctrl := NewController(t) defer ctrl.Finish() mockRepo := mock_db.NewMockRepository(ctrl) mockRepo.EXPECT().Retrieve(Any(), Any()).Return(nil) Patch(redisrepo.GetInstance, func() Repository { return mockRepo }) defer UnpatchAll() PatchInstanceMethod(reflect.TypeOf(mockRepo), \"Retrieve\", func(_ *mock_db.MockRepository, name string, movie *Movie) error { movie = \u0026Movie{Name: name, Type: \"Love\", Score: 95} return nil }) repo := redisrepo.GetInstance() var movie *Movie err := repo.Retrieve(\"Titanic\", movie) So(err, ShouldBeNil) So(movie.Name, ShouldEqual, \"Titanic\") So(movie.Type, ShouldEqual, \"Love\") So(movie.Score, ShouldEqual, 95) }) ... }) }   我们先通过Monkey框架的Patch API将mock对象注入，然后通过Monkey框架的PatchInstanceMethod API将mock方法跳转到补丁方法，间接完成对指针变量movie的内存分配及赋值，并返回nil。\n取消patch 有时候在我们不仅要mock函数，而且在patch方法里还需要调用原来的函数。这时候需要使用monkey库提供的 PatchGuard结构体。关键在于，调用原来的函数之前先调用一次Unpatch，恢复到mock之前的情况；然后在调用了原函数之后，调用一次Restore。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import ( \"fmt\" \"strings\" \"github.com/bouk/monkey\" ) func main() { var guard *monkey.PatchGuard guard = monkey.Patch(fmt.Println, func(a ...interface{}) (int, error) { s := make([]interface{}, len(a)) for i, v := range a { s[i] = strings.Replace(fmt.Sprint(v), \"hell\", \"*bleep*\", -1) } // 取消patch  guard.Unpatch() defer guard.Restore() // 使用默认的fmt.Println  return fmt.Println(s...) }) fmt.Println(\"what the hell?\") // what the *bleep*?  fmt.Println(\"what the hell?\") // what the *bleep*? }   Monkey的缺陷及解决方案 inline函数 Golang中虽然没有inline关键字，但仍存在inline函数，一个函数是否是inline函数由编译器决定。inline函数的特点是简单短小，在源代码的层次看有函数的结构，而在编译后却不具备函数的性质。inline函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处，所以inline函数在调用时没有地址。\ninline函数没有地址的特性导致了Monkey框架的第一个缺陷：对inline函数打桩无效。\n模拟一个简单的inline函数：\n1 2 3  func IsEqual(a, b string) bool { return a == b }   对HasDigit函数进行打桩测试：\n1 2 3 4 5 6 7 8 9 10 11 12  func TestIsEqual(t *testing.T) { Convey(\"test is equal\", t, func() { Convey(\"for patch true\", func() { guard := Patch(IsEqual, func(_, _ string) bool { return true }) defer guard.Unpatch() ok := IsEqual(\"hello\", \"world\") So(ok, ShouldBeTrue) }) }) }   在命令行运行这个测试，结果不符合期望：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ go test -v func_test.go -test.run TestIsEqual === RUN TestIsEqual test is equal for patch true ✘ Failures: * /Users/zhangxiaolong/Desktop/D/go-workspace/src/test/monkey/func_test.go Line 67: Expected: true Actual: false 1 total assertion --- FAIL: TestIsEqual (0.00s) FAIL exit status 1 FAIL command-line-arguments 0.006s   解决方案：通过命令行参数-gcflags=-l禁止inline\n在命令行增加参数-gcflags=-l重新运行测试，结果符合期望：\n1 2 3 4 5 6 7 8 9 10 11 12  go test -gcflags=-l -v func_test.go -test.run TestIsEqual === RUN TestIsEqual test is equal for patch true ✔ 1 total assertion --- PASS: TestIsEqual (0.00s) PASS ok command-line-arguments 0.007s   方法名首字母小写 这一年多，Golang的版本在快速演进，上个月已经发布了go1.9版本。然而，一些团队可能一直还在用go1.6版本，并有计划在近期升级到go1.7或以上版本。 Monkey框架的实现中大量使用了反射机制，尤其是方法的补丁实现函数PatchInstanceMethod。但是，go1.6版本和更高版本（比如go1.7）的反射机制有些差异：在go1.6版本中反射机制会导出所有方法（不论首字母是大写还是小写），而在更高版本中反射机制仅会导出首字母大写的方法。\n反射机制的这种差异导致了Monkey框架的第二个缺陷：在go1.6版本中可以成功打桩的首字母小写的方法，当go版本升级后Monkey框架会显式触发panic，表示unknown method:\n1 2 3 4  m, ok := target.MethodByName(methodName) if !ok { panic(fmt.Sprintf(\"unknown method %s\", methodName)) }   说明：反射机制的差异并不波及Patch函数的实现，所以go版本升级前后首字母小写的函数名的打桩不受影响。\n正交设计四原则告诉我们，要向稳定的方向依赖。首字母小写的方法或函数不是public的，仅在包内可见，不是一个稳定的依赖方向。如果在UT测试中对首字母小写的方法或函数打桩的话，会导致重构的成本比较大。\n解决方案：不管现在团队使用的go版本是哪一个，都不要对首字母小写的方法或函数打桩，不但可以确保测试用例在go版本升级前后的稳定性，而且能有效降低重构的成本。\nAPI不够简洁优雅 在讨论Monkey的API之前，我们先回顾一下GoStub框架的API。\nGoStub框架的API既包括函数API，也包括方法API。由于Monkey框架的API只涉及函数API，所以在这里我们只回顾GoStub框架的函数API。\n我们先看GoStub框架的第一个函数API：\n1  func Stub(varToStub interface{}, stubVal interface{}) *Stubs   这个API我们一般用于对全局变量打桩：\n1 2  stubs := Stub(\u0026num, 150) defer stubs.Reset()   然而，这个API也可以用于函数打桩：\n1 2 3 4  stubs := Stub(\u0026osencap.Exec, func(_ string, _ ...string) (string, error) { return \"xxx-vethName100-yyy\", nil }) defer stubs.Reset()   GoStub框架的Stub API对函数的打桩方法是不是和Monkey框架的API的使用方法很像？这是毋庸置疑的，这样的API才是原生的API，StubFunc API是专门针对函数或过程打桩的改进版：\n1  func StubFunc(funcVarToStub interface{}, stubVal ...interface{}) *Stubs   StubFunc替代Stub对函数的打桩示例：\n1 2  stubs := StubFunc(\u0026osencap.Exec,\"xxx-vethName100-yyy\", nil) defer stubs.Reset()   是不是简洁优雅了很多？\n说明：一般情况下，Golang的桩函数都关注的是返回值，所以这种封装很适用。但在特殊场景下，即桩函数在关注返回值的同时也关注出参，这时就要用原生的API。\n为了应对多次调用桩函数而呈现不同行为的复杂情况，笔者二次开发了GoStub框架，提供了下面的API：\n1 2 3 4 5 6 7  type Values []interface{} type Output struct { StubVals Values Times int } func (s *Stubs) StubFuncSeq(funcVarToStub interface{}, outputs []Output) *Stubs   只有原生的API导致了Monkey框架的第三个缺陷：API不够简洁优雅，同时不支持多次调用桩函数（方法）而呈现不同行为的复杂情况。\n解决方案：笔者计划二次开发Monkey框架，增加下面四个API：\n1 2 3 4  func PatchFunc(target interface{}, stubVal ...interface{}) *PatchGuard func PatchInstanceMethodFunc(target reflect.Type, methodName string, stubVal ...interface{}) *PatchGuard func PatchFuncSeq(target interface{}, outputs []Output) *PatchGuard func PatchInstanceMethodFuncSeq(target reflect.Type, methodName string, outputs []Output) *PatchGuard   小结 至此，我们已经知道：\n 全局变量可通过GoStub框架打桩 过程可通过Monkey框架打桩 函数可通过Monkey框架打桩 方法可通过Monkey框架打桩 interface可通过GoMock框架打桩  我们在产品代码中，尽量不要使用全局变量.\n参考：\nhttps://www.jianshu.com/p/2f675d5e334e\nhttps://blog.cyeam.com/golang/2018/08/07/monkey-patch\n",
  "wordCount" : "6174",
  "inLanguage": "zh-cn",
  "datePublished": "2020-01-25T23:36:00Z",
  "dateModified": "2020-01-25T23:36:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81monkey/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      猴子补丁:monkey
    </h1>
    <div class="post-meta">January 25, 2020
</div>
  </header> 
  <div class="post-content"><h1 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h1>
<p>我们已经知道：</p>
<ul>
<li>全局变量可通过GoStub框架打桩</li>
<li>过程可通过GoStub框架打桩</li>
<li>函数可通过GoStub框架打桩</li>
<li>interface可通过GoMock框架打桩</li>
</ul>
<p>但还有两个问题比较棘手：</p>
<ul>
<li>方法（成员函数）无法通过GoStub框架打桩，当产品代码的OO设计比较多时，打桩点可能离被测函数比较远，导致UT用例写起来比较痛</li>
<li>过程或函数通过GoStub框架打桩时，对产品代码有侵入性</li>
</ul>
<p>下面我们举两个例子，阐述GoStub框架对产品代码的侵入性</p>
<p>例一：函数定义侵入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">cmd</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的函数Exec的定义为常规方式，但这时不能通过GoStub框架对函数Exec进行打桩，除非将函数Exec定义为非常规方式（侵入性）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">Exec</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">cmd</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>例二：适配层侵入</p>
<p>产品代码中很多函数都会调用Golang的库函数或第三方的库函数，这些库函数的定义显然是常规方式，要想通过GoStub框架对这些函数打桩，一般会在适配层定义相关的变量（侵入性）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">adapter</span>

<span class="kd">var</span> <span class="nx">Stat</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span>
<span class="kd">var</span> <span class="nx">Marshal</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span>
<span class="kd">var</span> <span class="nx">UnMarshal</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span>
<span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>本文将介绍第四个框架Monkey的使用方法，目的是解决这两个棘手的问题，同时考虑将GoStub的优点集成到Monkey。</p>
<h1 id="原理">原理<a hidden class="anchor" aria-hidden="true" href="#原理">#</a></h1>
<p>monkey patch(猴子补丁)是一种在不改变原始源代码的情况下扩展或修改动态语言的运行时代码的方法。许多人认为猴子修补只限于Python等动态语言。但事实并非如此，我们可以在运行时来修改Go函数。主角就是github.com/bouk/monkey。</p>
<p>猴子补丁主要有以下几个用处：</p>
<ul>
<li>在运行时替换方法、属性等</li>
<li>在不修改第三方代码的情况下增加原来不支持的功能</li>
<li>在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加</li>
<li>增加钩子，在执行某个方法的同时执行一些其他的处理，如打印日志，实现AOP等。</li>
</ul>
<h2 id="调用函数的实现">调用函数的实现<a hidden class="anchor" aria-hidden="true" href="#调用函数的实现">#</a></h2>
<p>看看下面的代码反编译之后的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">print</span><span class="p">(</span><span class="nf">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译完成后通过Hopper查看，上面的代码将会展示下面的汇编代码：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200126233630.png" alt=""  />
</p>
<p>我将参考屏幕左侧显示的各种指令的地址。</p>
<p>我们的代码从过程main.main开始，指令 0x2010 到 0x2026 初始化了栈。你可以参考这些扩展阅读，下面的文章将会忽略那些代码。</p>
<p>0x202a 行调用了函数main.a，0x2000 行简单得把 0x1 压入栈返回。0x202f 到 0x2037 行把值传给了runtime.printint。</p>
<p>够简单了！现在咱们一起看看 Go 里面的函数值是如何实现的。</p>
<p>看下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="nx">a</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;0x%x\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在第11行把a赋值给了f，这就意味着调用f()将会调用a。接下来用unsafe包读取出存在f里面的值。如果你是有 C 语言背景的程序员你可能会认为简单得把指向函数a的指针打印出来将会得到 0x2000（就是上面汇编里面看到的地址）。当我运行上面的代码得到了 0x102c38，这个地址相差了十万八千里！反编译后，这是第11行的代码：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200127140106.png" alt=""  />
</p>
<p>这里引用了main.a.f，我们看看那个位置，可以发现：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200127140226.png" alt=""  />
</p>
<p>啊哈！main.a.f在 0x102c38 并且包含值 0x2000，它正好是main.a的地址。看起来f并不是指向函数的指针，而是指向函数的指针的指针。让我们修改代码证实：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>
 
<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="nx">a</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;0x%x\n&#34;</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>和我们期望的一样，将会打印 0x2000。在这里我们也能找到一些线索。Go 语言的函数值包含了额外的信息，这是闭包和绑定实例实现的方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">funcval</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fn</span> <span class="kt">uintptr</span>
	<span class="c1">// variable-size, fn-specific data here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来看看调用函数值的实现。把代码改成下面这样，给f赋值之后调用它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="nx">a</span>
	<span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>反编译后可以得到下面的结果：</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20200127142458.png" alt=""  />
</p>
<p>main.a.f加载到寄存器rdx里，然后把rdx寄存器指向的地址存入rbx里，最后调用。函数的地址值总是会加载到rdx寄存器里面，当代码调用的时候可以用来加载一些可能会用到的额外信息。这里的额外信息是指向绑定的实例和匿名函数闭包的指针。如果你想了解更多我建议你深入研究一下反编译代码！</p>
<h2 id="运行时替换函数">运行时替换函数<a hidden class="anchor" aria-hidden="true" href="#运行时替换函数">#</a></h2>
<p>让我们用新的知识实现 Go 语言里面的猴子补丁。</p>
<p>我们是想实现的是让下面的代码打印出来2:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">b</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">replace</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="nb">print</span><span class="p">(</span><span class="nf">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如何实现replace?我们需要修改函数a，让它跳转到b的代码，跳过执行它自己的代码。实际上，我们需要通过这种方法来实现替换，加载函数b到寄存器rdx，然后执行时跳转到rdx上面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mov rdx, main.b.f ; 48 C7 C2 ?? ?? ?? ??
jmp [rdx] ; FF 22
</code></pre></td></tr></table>
</div>
</div><p>我在汇编代码旁边附上了相应的机器码（你可以用这种在线汇编工具来模拟测试）。编写一个生成上面汇编代码的函数就很简单了，类似于下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">assembleJump</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
  <span class="nx">funcVal</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
    <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xC7</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span>
    <span class="nb">byte</span><span class="p">(</span><span class="nx">funcval</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">),</span>
    <span class="nb">byte</span><span class="p">(</span><span class="nx">funcval</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span>
    <span class="nb">byte</span><span class="p">(</span><span class="nx">funcval</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">),</span>
    <span class="nb">byte</span><span class="p">(</span><span class="nx">funcval</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">),</span> <span class="c1">// MOV rdx, funcVal
</span><span class="c1"></span>    <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span>          <span class="c1">// JMP [rdx]
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就能把a的函数体指向b了！下面的代码尝试复制机器代码到函数体上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">b</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">rawMemoryAccess</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mh">0xFF</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">)))[:]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">assembleJump</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">funcVal</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
		<span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xC7</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">),</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">),</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">),</span> <span class="c1">// MOV rdx, funcVal
</span><span class="c1"></span>		<span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span>          <span class="c1">// JMP [rdx]
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">replace</span><span class="p">(</span><span class="nx">orig</span><span class="p">,</span> <span class="nx">replacement</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nf">assembleJump</span><span class="p">(</span><span class="nx">replacement</span><span class="p">)</span>
	<span class="nx">functionLocation</span> <span class="o">:=</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">orig</span><span class="p">))</span>
	<span class="nx">window</span> <span class="o">:=</span> <span class="nf">rawMemoryAccess</span><span class="p">(</span><span class="nx">functionLocation</span><span class="p">)</span>
	
	<span class="nb">copy</span><span class="p">(</span><span class="nx">window</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">replace</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="nb">print</span><span class="p">(</span><span class="nf">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行上面的代码并不会工作，结果会是 segementation fault 段错误。这是因为加载后的二进制文件默认不允许修改。我们可以使用系统调用mprotect来关掉这个保护，这个最终版的代码终于可以像期望的那样，通过调用替换后的函数来打印出来 2。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">b</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">getPage</span><span class="p">(</span><span class="nx">p</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mh">0xFFFFFF</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span> <span class="o">&amp;</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nf">Getpagesize</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">))))[:</span><span class="nx">syscall</span><span class="p">.</span><span class="nf">Getpagesize</span><span class="p">()]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">rawMemoryAccess</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mh">0xFF</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">)))[:]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">assembleJump</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">funcVal</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
		<span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xC7</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">),</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">),</span>
		<span class="nb">byte</span><span class="p">(</span><span class="nx">funcVal</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">),</span> <span class="c1">// MOV rdx, funcVal
</span><span class="c1"></span>		<span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span>          <span class="c1">// JMP rdx
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">replace</span><span class="p">(</span><span class="nx">orig</span><span class="p">,</span> <span class="nx">replacement</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nf">assembleJump</span><span class="p">(</span><span class="nx">replacement</span><span class="p">)</span>
	<span class="nx">functionLocation</span> <span class="o">:=</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">orig</span><span class="p">))</span>
	<span class="nx">window</span> <span class="o">:=</span> <span class="nf">rawMemoryAccess</span><span class="p">(</span><span class="nx">functionLocation</span><span class="p">)</span>
	
	<span class="nx">page</span> <span class="o">:=</span> <span class="nf">getPage</span><span class="p">(</span><span class="nx">functionLocation</span><span class="p">)</span>
	<span class="nx">syscall</span><span class="p">.</span><span class="nf">Mprotect</span><span class="p">(</span><span class="nx">page</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">PROT_READ</span><span class="p">|</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">PROT_WRITE</span><span class="p">|</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">PROT_EXEC</span><span class="p">)</span>
	
	<span class="nb">copy</span><span class="p">(</span><span class="nx">window</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">replace</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="nb">print</span><span class="p">(</span><span class="nf">a</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="使用场景">使用场景<a hidden class="anchor" aria-hidden="true" href="#使用场景">#</a></h1>
<p>Monkey框架的使用场景很多，依次为：</p>
<ul>
<li>基本场景：为一个函数打桩</li>
<li>基本场景：为一个过程打桩</li>
<li>基本场景：为一个方法打桩</li>
<li>复合场景：由任意相同或不同的基本场景组合而成</li>
<li>特殊场景：桩中桩的一个案例</li>
</ul>
<h2 id="函数打桩">函数打桩<a hidden class="anchor" aria-hidden="true" href="#函数打桩">#</a></h2>
<p>Exec是infra层的一个操作函数，实现很简单，代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// infra/os-encap/exec.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">cmd</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cmdpath</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">LookPath</span><span class="p">(</span><span class="nx">cmd</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;exec.LookPath err: %v, cmd: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">infra</span><span class="p">.</span><span class="nx">ErrExecLookPathFailed</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">output</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="nx">output</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="nx">cmdpath</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">).</span><span class="nf">CombinedOutput</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;exec.Command.CombinedOutput err: %v, cmd: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">infra</span><span class="p">.</span><span class="nx">ErrExecCombinedOutputFailed</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;CMD[&#34;</span><span class="p">,</span> <span class="nx">cmdpath</span><span class="p">,</span> <span class="s">&#34;]ARGS[&#34;</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="s">&#34;]OUT[&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">output</span><span class="p">),</span> <span class="s">&#34;]&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">output</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Exec函数的实现中调用了库函数exec.LoopPath和exec.Command，因此Exec函数的返回值和运行时的底层环境密切相关。在UT中，如果被测函数调用了Exec函数，则应根据用例的场景对Exec函数打桩。</p>
<p>Monkey的API非常简单和直接，我们直接看打桩代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;testing&#34;</span>
    <span class="p">.</span> <span class="s">&#34;github.com/smartystreets/goconvey/convey&#34;</span>
    <span class="p">.</span> <span class="s">&#34;github.com/bouk/monkey&#34;</span>
    <span class="s">&#34;infra/osencap&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">any</span> <span class="p">=</span> <span class="s">&#34;any&#34;</span>

<span class="kd">func</span> <span class="nf">TestExec</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Convey</span><span class="p">(</span><span class="s">&#34;test has digit&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Convey</span><span class="p">(</span><span class="s">&#34;for succ&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">outputExpect</span> <span class="o">:=</span> <span class="s">&#34;xxx-vethName100-yyy&#34;</span>
            <span class="nx">guard</span> <span class="o">:=</span> <span class="nf">Patch</span><span class="p">(</span><span class="nx">osencap</span><span class="p">.</span><span class="nx">Exec</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">_</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">outputExpect</span><span class="p">,</span> <span class="kc">nil</span>
            <span class="p">})</span>
            <span class="k">defer</span> <span class="nx">guard</span><span class="p">.</span><span class="nf">Unpatch</span><span class="p">()</span>
            <span class="nx">output</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">osencap</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="nx">ShouldEqual</span><span class="p">,</span> <span class="nx">outputExpect</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">ShouldBeNil</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Patch是Monkey提供给用户用于函数打桩的API：</p>
<ul>
<li>第一个参数是目标函数的函数名</li>
<li>第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包</li>
<li>返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁</li>
</ul>
<h2 id="过程打桩">过程打桩<a hidden class="anchor" aria-hidden="true" href="#过程打桩">#</a></h2>
<p>当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。</p>
<p>我们对过程DestroyResource的打桩代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">guard</span> <span class="o">:=</span> <span class="nf">Patch</span><span class="p">(</span><span class="nx">DestroyResource</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>

<span class="p">})</span>
<span class="k">defer</span> <span class="nx">guard</span><span class="p">.</span><span class="nf">Unpatch</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="方法打桩">方法打桩<a hidden class="anchor" aria-hidden="true" href="#方法打桩">#</a></h2>
<p>当微服务有多个实例时，先通过Etcd选举一个Master实例，然后Master实例为所有实例较均匀的分配任务，并将任务分配结果Set到Etcd，最后Master和Node实例Watch到任务列表，并过滤出自身需要处理的任务列表。</p>
<p>我们用类Etcd的方法Get来模拟获取任务列表的功能，入参为instanceId：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Etcd</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Etcd</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">instanceId</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">taskList</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nx">taskList</span>
</code></pre></td></tr></table>
</div>
</div><p>我们对Get方法的打桩代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">e</span> <span class="o">*</span><span class="nx">Etcd</span>
<span class="nx">guard</span> <span class="o">:=</span> <span class="nf">PatchInstanceMethod</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span> <span class="s">&#34;Get&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">Etcd</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;task1&#34;</span><span class="p">,</span> <span class="s">&#34;task5&#34;</span><span class="p">,</span> <span class="s">&#34;task8&#34;</span><span class="p">}</span>
<span class="p">})</span>
<span class="k">defer</span> <span class="nx">guard</span><span class="p">.</span><span class="nf">Unpatch</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>PatchInstanceMethod API是Monkey提供给用户用于方法打桩的API：</p>
<ul>
<li>在使用前，先要定义一个目标类的指针变量x</li>
<li>第一个参数是reflect.TypeOf(x)</li>
<li>第二个参数是字符串形式的函数名</li>
<li>返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁</li>
</ul>
<h2 id="场景组合">场景组合<a hidden class="anchor" aria-hidden="true" href="#场景组合">#</a></h2>
<p>假设Px为用于函数、过程或方法打桩的API调用，则任意相同或不同基本场景组合的打桩过程形式化表达为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Px1</span>
<span class="k">defer</span> <span class="nf">UnpatchAll</span><span class="p">()</span>
<span class="nx">Px2</span>
<span class="o">...</span>
<span class="nx">Pxn</span>
</code></pre></td></tr></table>
</div>
</div><p>该测试执行完后，函数UnpatchAll将删除所有的补丁。</p>
<h2 id="桩中桩">桩中桩<a hidden class="anchor" aria-hidden="true" href="#桩中桩">#</a></h2>
<p>在某些特殊场景下（比如反序列化），函数或方法既有返回值，又有出参。出参一般为指针类型，包括具体的指针类型（比如<code>*int</code>)和抽象的指针类型（一般为<code>interface{}</code>）。我们常用的库函数<code>json.Unmarshal</code>就属于这种情况。</p>
<p>笔者在实践中遇到的出参类型大多是具体的指针类型，其指针变量指向的内存不管在传入前确定还是在传入后确定，都将影响后面的代码逻辑。</p>
<p>下面呈现桩中桩的一个案例，以便大家灵活使用Monkey框架。</p>
<p>何谓桩中桩？</p>
<p>interface中声明了一个方法，既有返回值，又有出参。在测试中，先通过GoMock框架打桩多态到mock方法，然后又通过Monkey框架跳转到补丁方法，最终修改出参并返回。在这个过程中，mock方法可以看作一个桩，补丁方法又可以看作mock方法的一个桩，即补丁方法是一个桩中桩。</p>
<p>定义一个具体类型Movie：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Movie</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span>
    <span class="nx">Type</span> <span class="kt">string</span>
    <span class="nx">Score</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>定义一个interface类型Repository：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Retrieve</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">movie</span> <span class="o">*</span><span class="nx">Movie</span><span class="p">)</span> <span class="kt">error</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>桩中桩的一个测试用例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestDemo</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Convey</span><span class="p">(</span><span class="s">&#34;test demo&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Convey</span><span class="p">(</span><span class="s">&#34;retrieve movie&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">ctrl</span> <span class="o">:=</span> <span class="nf">NewController</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
            <span class="k">defer</span> <span class="nx">ctrl</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>
            <span class="nx">mockRepo</span> <span class="o">:=</span> <span class="nx">mock_db</span><span class="p">.</span><span class="nf">NewMockRepository</span><span class="p">(</span><span class="nx">ctrl</span><span class="p">)</span>
            <span class="nx">mockRepo</span><span class="p">.</span><span class="nf">EXPECT</span><span class="p">().</span><span class="nf">Retrieve</span><span class="p">(</span><span class="nf">Any</span><span class="p">(),</span> <span class="nf">Any</span><span class="p">()).</span><span class="nf">Return</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
            <span class="nf">Patch</span><span class="p">(</span><span class="nx">redisrepo</span><span class="p">.</span><span class="nx">GetInstance</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">Repository</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">mockRepo</span>
            <span class="p">})</span>
            <span class="k">defer</span> <span class="nf">UnpatchAll</span><span class="p">()</span>
            <span class="nf">PatchInstanceMethod</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">mockRepo</span><span class="p">),</span> <span class="s">&#34;Retrieve&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">mock_db</span><span class="p">.</span><span class="nx">MockRepository</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">movie</span> <span class="o">*</span><span class="nx">Movie</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
                <span class="nx">movie</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Movie</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="s">&#34;Love&#34;</span><span class="p">,</span> <span class="nx">Score</span><span class="p">:</span> <span class="mi">95</span><span class="p">}</span>
                <span class="k">return</span> <span class="kc">nil</span>
            <span class="p">})</span>
            <span class="nx">repo</span> <span class="o">:=</span> <span class="nx">redisrepo</span><span class="p">.</span><span class="nf">GetInstance</span><span class="p">()</span>
            <span class="kd">var</span> <span class="nx">movie</span> <span class="o">*</span><span class="nx">Movie</span>
            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">repo</span><span class="p">.</span><span class="nf">Retrieve</span><span class="p">(</span><span class="s">&#34;Titanic&#34;</span><span class="p">,</span> <span class="nx">movie</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">ShouldBeNil</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">movie</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">ShouldEqual</span><span class="p">,</span> <span class="s">&#34;Titanic&#34;</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">movie</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ShouldEqual</span><span class="p">,</span> <span class="s">&#34;Love&#34;</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">movie</span><span class="p">.</span><span class="nx">Score</span><span class="p">,</span> <span class="nx">ShouldEqual</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="o">...</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们先通过Monkey框架的Patch API将mock对象注入，然后通过Monkey框架的PatchInstanceMethod API将mock方法跳转到补丁方法，间接完成对指针变量movie的内存分配及赋值，并返回nil。</p>
<h2 id="取消patch">取消patch<a hidden class="anchor" aria-hidden="true" href="#取消patch">#</a></h2>
<p>有时候在我们不仅要mock函数，而且在patch方法里还需要调用原来的函数。这时候需要使用monkey库提供的 PatchGuard结构体。关键在于，调用原来的函数之前先调用一次Unpatch，恢复到mock之前的情况；然后在调用了原函数之后，调用一次Restore。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;strings&#34;</span>

    <span class="s">&#34;github.com/bouk/monkey&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">guard</span> <span class="o">*</span><span class="nx">monkey</span><span class="p">.</span><span class="nx">PatchGuard</span>
    <span class="nx">guard</span> <span class="p">=</span> <span class="nx">monkey</span><span class="p">.</span><span class="nf">Patch</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{},</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
        <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="s">&#34;hell&#34;</span><span class="p">,</span> <span class="s">&#34;*bleep*&#34;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// 取消patch
</span><span class="c1"></span>        <span class="nx">guard</span><span class="p">.</span><span class="nf">Unpatch</span><span class="p">()</span>
        <span class="k">defer</span> <span class="nx">guard</span><span class="p">.</span><span class="nf">Restore</span><span class="p">()</span>
        <span class="c1">// 使用默认的fmt.Println
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="o">...</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;what the hell?&#34;</span><span class="p">)</span>  <span class="c1">// what the *bleep*?
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;what the hell?&#34;</span><span class="p">)</span>  <span class="c1">// what the *bleep*?
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="monkey的缺陷及解决方案">Monkey的缺陷及解决方案<a hidden class="anchor" aria-hidden="true" href="#monkey的缺陷及解决方案">#</a></h1>
<h2 id="inline函数">inline函数<a hidden class="anchor" aria-hidden="true" href="#inline函数">#</a></h2>
<p>Golang中虽然没有inline关键字，但仍存在inline函数，一个函数是否是inline函数由编译器决定。inline函数的特点是简单短小，在源代码的层次看有函数的结构，而在编译后却不具备函数的性质。inline函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处，所以inline函数在调用时没有地址。</p>
<p>inline函数没有地址的特性导致了Monkey框架的第一个缺陷：对inline函数打桩无效。</p>
<p>模拟一个简单的inline函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对HasDigit函数进行打桩测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestIsEqual</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Convey</span><span class="p">(</span><span class="s">&#34;test is equal&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Convey</span><span class="p">(</span><span class="s">&#34;for patch true&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">guard</span> <span class="o">:=</span> <span class="nf">Patch</span><span class="p">(</span><span class="nx">IsEqual</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">})</span>
            <span class="k">defer</span> <span class="nx">guard</span><span class="p">.</span><span class="nf">Unpatch</span><span class="p">()</span>
            <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">IsEqual</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;world&#34;</span><span class="p">)</span>
            <span class="nf">So</span><span class="p">(</span><span class="nx">ok</span><span class="p">,</span> <span class="nx">ShouldBeTrue</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在命令行运行这个测试，结果不符合期望：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ go <span class="nb">test</span> -v func_test.go -test.run <span class="nv">TestIsEqual</span>
<span class="o">===</span> RUN   TestIsEqual

  <span class="nb">test</span> is equal 
    <span class="k">for</span> patch <span class="nb">true</span> ✘


Failures:

  * /Users/zhangxiaolong/Desktop/D/go-workspace/src/test/monkey/func_test.go 
  Line 67:
  Expected: <span class="nb">true</span>
  Actual:   <span class="nb">false</span>


<span class="m">1</span> total assertion

--- FAIL: TestIsEqual <span class="o">(</span>0.00s<span class="o">)</span>
FAIL
<span class="nb">exit</span> status <span class="m">1</span>
FAIL    command-line-arguments  0.006s
</code></pre></td></tr></table>
</div>
</div><p>解决方案：通过命令行参数<code>-gcflags=-l</code>禁止inline</p>
<p>在命令行增加参数<code>-gcflags=-l</code>重新运行测试，结果符合期望：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">go <span class="nb">test</span> -gcflags<span class="o">=</span>-l -v func_test.go -test.run <span class="nv">TestIsEqual</span>
<span class="o">===</span> RUN   TestIsEqual

  <span class="nb">test</span> is equal 
    <span class="k">for</span> patch <span class="nb">true</span> ✔


<span class="m">1</span> total assertion

--- PASS: TestIsEqual <span class="o">(</span>0.00s<span class="o">)</span>
PASS
ok      command-line-arguments  0.007s
</code></pre></td></tr></table>
</div>
</div><h2 id="方法名首字母小写">方法名首字母小写<a hidden class="anchor" aria-hidden="true" href="#方法名首字母小写">#</a></h2>
<p>这一年多，Golang的版本在快速演进，上个月已经发布了go1.9版本。然而，一些团队可能一直还在用go1.6版本，并有计划在近期升级到go1.7或以上版本。
Monkey框架的实现中大量使用了反射机制，尤其是方法的补丁实现函数PatchInstanceMethod。但是，go1.6版本和更高版本（比如go1.7）的反射机制有些差异：在go1.6版本中反射机制会导出所有方法（不论首字母是大写还是小写），而在更高版本中反射机制仅会导出首字母大写的方法。</p>
<p>反射机制的这种差异导致了Monkey框架的第二个缺陷：在go1.6版本中可以成功打桩的首字母小写的方法，当go版本升级后Monkey框架会显式触发panic，表示unknown method:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">.</span><span class="nf">MethodByName</span><span class="p">(</span><span class="nx">methodName</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;unknown method %s&#34;</span><span class="p">,</span> <span class="nx">methodName</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>说明：反射机制的差异并不波及Patch函数的实现，所以go版本升级前后首字母小写的函数名的打桩不受影响。</p>
<p>正交设计四原则告诉我们，要向稳定的方向依赖。首字母小写的方法或函数不是public的，仅在包内可见，不是一个稳定的依赖方向。如果在UT测试中对首字母小写的方法或函数打桩的话，会导致重构的成本比较大。</p>
<p>解决方案：不管现在团队使用的go版本是哪一个，都不要对首字母小写的方法或函数打桩，不但可以确保测试用例在go版本升级前后的稳定性，而且能有效降低重构的成本。</p>
<h1 id="api不够简洁优雅">API不够简洁优雅<a hidden class="anchor" aria-hidden="true" href="#api不够简洁优雅">#</a></h1>
<p>在讨论Monkey的API之前，我们先回顾一下GoStub框架的API。</p>
<p>GoStub框架的API既包括函数API，也包括方法API。由于Monkey框架的API只涉及函数API，所以在这里我们只回顾GoStub框架的函数API。</p>
<p>我们先看GoStub框架的第一个函数API：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Stub</span><span class="p">(</span><span class="nx">varToStub</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">stubVal</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">Stubs</span>
</code></pre></td></tr></table>
</div>
</div><p>这个API我们一般用于对全局变量打桩：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">stubs</span> <span class="o">:=</span> <span class="nf">Stub</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="k">defer</span> <span class="nx">stubs</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>然而，这个API也可以用于函数打桩：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">stubs</span> <span class="o">:=</span> <span class="nf">Stub</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">osencap</span><span class="p">.</span><span class="nx">Exec</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">_</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&#34;xxx-vethName100-yyy&#34;</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">})</span>
<span class="k">defer</span> <span class="nx">stubs</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>GoStub框架的Stub API对函数的打桩方法是不是和Monkey框架的API的使用方法很像？这是毋庸置疑的，这样的API才是原生的API，StubFunc API是专门针对函数或过程打桩的改进版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StubFunc</span><span class="p">(</span><span class="nx">funcVarToStub</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">stubVal</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">Stubs</span>
</code></pre></td></tr></table>
</div>
</div><p>StubFunc替代Stub对函数的打桩示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">stubs</span> <span class="o">:=</span> <span class="nf">StubFunc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">osencap</span><span class="p">.</span><span class="nx">Exec</span><span class="p">,</span><span class="s">&#34;xxx-vethName100-yyy&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">defer</span> <span class="nx">stubs</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>是不是简洁优雅了很多？</p>
<p>说明：一般情况下，Golang的桩函数都关注的是返回值，所以这种封装很适用。但在特殊场景下，即桩函数在关注返回值的同时也关注出参，这时就要用原生的API。</p>
<p>为了应对多次调用桩函数而呈现不同行为的复杂情况，笔者二次开发了GoStub框架，提供了下面的API：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Values</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Output</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">StubVals</span> <span class="nx">Values</span>
    <span class="nx">Times</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Stubs</span><span class="p">)</span> <span class="nf">StubFuncSeq</span><span class="p">(</span><span class="nx">funcVarToStub</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">outputs</span> <span class="p">[]</span><span class="nx">Output</span><span class="p">)</span> <span class="o">*</span><span class="nx">Stubs</span>
</code></pre></td></tr></table>
</div>
</div><p>只有原生的API导致了Monkey框架的第三个缺陷：API不够简洁优雅，同时不支持多次调用桩函数（方法）而呈现不同行为的复杂情况。</p>
<p>解决方案：笔者计划二次开发Monkey框架，增加下面四个API：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">PatchFunc</span><span class="p">(</span><span class="nx">target</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">stubVal</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">PatchGuard</span>
<span class="kd">func</span> <span class="nf">PatchInstanceMethodFunc</span><span class="p">(</span><span class="nx">target</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">methodName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">stubVal</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">PatchGuard</span>
<span class="kd">func</span> <span class="nf">PatchFuncSeq</span><span class="p">(</span><span class="nx">target</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">outputs</span> <span class="p">[]</span><span class="nx">Output</span><span class="p">)</span> <span class="o">*</span><span class="nx">PatchGuard</span>
<span class="kd">func</span> <span class="nf">PatchInstanceMethodFuncSeq</span><span class="p">(</span><span class="nx">target</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">methodName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">outputs</span> <span class="p">[]</span><span class="nx">Output</span><span class="p">)</span> <span class="o">*</span><span class="nx">PatchGuard</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h1>
<p>至此，我们已经知道：</p>
<ul>
<li>全局变量可通过GoStub框架打桩</li>
<li>过程可通过Monkey框架打桩</li>
<li>函数可通过Monkey框架打桩</li>
<li>方法可通过Monkey框架打桩</li>
<li>interface可通过GoMock框架打桩</li>
</ul>
<p>我们在产品代码中，尽量不要使用全局变量.</p>
<p>参考：<br>
<a href="https://www.jianshu.com/p/2f675d5e334e">https://www.jianshu.com/p/2f675d5e334e</a><br>
<a href="https://blog.cyeam.com/golang/2018/08/07/monkey-patch">https://blog.cyeam.com/golang/2018/08/07/monkey-patch</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/go/">Go</a></li>
      <li><a href="/tags/monkey/">monkey</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
