<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>正则表达式详解 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或g">
<meta name="author" content="">
<link rel="canonical" href="/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="正则表达式详解" />
<meta property="og:description" content="定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或g" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-08-12T22:39:08&#43;00:00" />
<meta property="article:modified_time" content="2017-08-12T22:39:08&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="正则表达式详解"/>
<meta name="twitter:description" content="定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或g"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "正则表达式详解",
      "item": "/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "正则表达式详解",
  "name": "正则表达式详解",
  "description": "定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或g",
  "keywords": [
    
  ],
  "articleBody": "定义 正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或gawk程序)能够在处理数据时使用正则表达式对数据进行模式匹配。\n正则表达式的类型 使用正则表达式最大的问题在于有不止一种类型的正则表达式。Linux中的不同应用程序可 能会用不同类型的正则表达式。\n正则表达式是通过正则表达式引擎(regular expression engine)实现的。正则表达式引擎是 一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。\n在Linux中，有两种流行的正则表达式引擎:\n POSIX基础正则表达式(basic regular expression，BRE)引擎 POSIX扩展正则表达式(extended regular expression，ERE)引擎  大多数Linux工具都至少符合POSIX BRE引擎规范，能够识别该规范定义的所有模式符号。 遗憾的是，有些工具(比如sed编辑器)只符合了BRE引擎规范的子集。这是出于速度方面的考 虑导致的，因为sed编辑器希望能尽可能快地处理数据流中的文本。\nPOSIX BRE引擎通常出现在依赖正则表达式进行文本过滤的编程语言中。它为常见模式提供 了高级模式符号和特殊符号，比如匹配数字、单词以及按字母排序的字符。gawk程序用ERE引擎 来处理它的正则表达式模式。\n定义BRE模式 纯文本 正则表达式并不关心模式在数据流中的位置。它也不关心模式出现了多少次。一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具。\n关键在于将正则表达式模式匹配到数据流文本上。重要的是记住正则表达式对匹配的模式非 常挑剔。第一条原则就是:正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符 的模式。\n你也不用局限于在正则表达式中只用单个文本单词，可以在正则表达式中使用空格和数字。甚至可以创建匹配多个连续空格的正则表达式模式。\n特殊字符 正则表达式识别的特殊字符包括:\n.*[]^${}\\+?|()  如果要用某个特殊字符作为文本字符，就必须转义。在转义特殊字符时，你需要在它前面加 一个特殊字符来告诉正则表达式引擎应该将接下来的字符当作普通的文本字符。这个特殊字符就 是反斜线()。\n由于反斜线是特殊字符，如果要在正则表达式模式中使用它，你必须对其转义，这样就产生 了两个反斜线。\n要使用正斜线，也需要进行转义。\n锚字符 有两个特殊字符可以用来将模式锁定在数据流中的行首或行尾。\n1. 锁定在行首 脱字符(^)定义从数据流中文本行的行首开始的模式。如果模式出现在行首之外的位置， 正则表达式模式则无法匹配。\n要用脱字符，就必须将它放在正则表达式中指定的模式前面。\n$ echo \"The book store\" | sed -n '/^book/p'  脱字符会在每个由换行符决定的新数据行的行首检查模式。\n只要模式出现在新行的行首，脱字符就能够发现它。 如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了:\n$ echo \"This is a test\" | sed -n '/s ^/p'  如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。\n2. 锁定在行尾 跟在行首查找模式相反的就是在行尾查找。特殊字符美元符($)定义了行尾锚点。将这个 特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。\n$ echo \"This is a good book\" | sed -n '/book$/p'  3. 组合锚点 可以在同一行中将行首锚点和行尾锚点组合在一起使用。在第一种情况 中，假定你要查找只含有特定文本模式的数据行。\n$ sed -n '/^this is a test$/p' data4  sed编辑器忽略了那些不单单包含指定的文本的行。\n将两个锚点直接组合在一起，之间不加任何 文本，这样过滤出数据流中的空白行.\n$ sed '/ $/d' data5  点号字符 特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字 符的位置没有字符，那么模式就不成立。在正则表达式中， 空格也是字符.\n$ sed -n '/.at/p' data6  字符组 可以定义字符组用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据 流中，那它就匹配了该模式。\n使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。然后你 可以在模式中使用整个组，就跟使用其他通配符一样。\n$ sed -n '/[ch]at/p' data6  排除型字符组 在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，而不是去寻找组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符。\n$ sed -n '/[^ch]at/p' data6  通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字 符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at开头的行仍然未能匹配模式。\n区间 可以用单破折线符号在字符组 中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。根据Linux系统采用的字符集，正则表达式会包括此区间内的任意字符。\n现在你可以通过指定数字区间来简化邮编的例子。\n$ sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8  还可以在单个字符组指定多个不连续的区间。\n$ sed -n '/[a-ch-m]at/p' data6  该字符组允许区间a~c、h~m中的字母出现在at文本前，但不允许出现d~g的字母。\n特殊的字符组 除了定义自己的字符组外，BRE还包含了一些特殊的字符组，可用来匹配特定类型的字符。\n可以在正则表达式模式中将特殊字符组像普通字符组一样使用。\n$ echo \"abc\" | sed -n '/[[:digit:]]/p'  星号 在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次。\n$ echo \"ik\" | sed -n '/ie*k/p'  模式中的u*表明字母u可能出现或不出现在匹配模式的文本中。类似地，如果你知道一个单 词经常被拼错，你可以用星号来允许这种错误。\n星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。\n$ echo \"bt\" | sed -n '/b[ae]*t/p'  只要a和e字符以任何组合形式出现在b和t字符之间(就算完全不出现也行)，模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。\n扩展正则表达式 POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号。gawk程序能够识别ERE模式，但sed编辑器不能。\n记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多 数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器 所不具备的。但正因为如此，gawk程序在处理数据流时通常才比较慢。\n问号 问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于 此。它不会匹配多次出现的字符。\n$ echo \"bt\" | gawk '/be?t/{print $0}'  如果字符e并未在文本中出现，或者它只在文本中出现了1次，那么模式会匹配。 与星号一样，你可以将问号和字符组一起使用。\n加号 加号是类似于星号的另一个模式符号，但跟问号也有不同。加号表明前面的字符可以出现1次或多次，但必须至少出现1次。\n$ echo \"beeet\" | gawk '/be+t/{print $0}'  如果字符e没有出现，模式匹配就不成立。加号同样适用于字符组，与星号和问号的使用方 式相同。\n使用花括号 ERE中的花括号允许你为可重复的正则表达式指定一个上限。这通常称为间隔(interval)。 10 可以用两种格式来指定区间。\n m:正则表达式准确出现m次。 m, n:正则表达式至少出现m次，至多n次。  这个特性可以精确调整字符或字符集在模式中具体出现的次数。\n默认情况下，gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval 命令行选项才能识别正则表达式间隔。\n$ echo \"bet\" | gawk --re-interval '/be{1}t/{print $0}'  通过指定间隔为1，限定了该字符在匹配模式的字符串中出现的次数。如果该字符出现多次， 模式匹配就不成立。\n很多时候，同时指定下限和上限也很方便。\n$ echo \"bt\" | gawk --re-interval '/be{1,2}t/{print $0}'  管道符号 管道符号允许你在检查数据流时，用逻辑OR方式指定正则表达式引擎要用的两个或多个模 式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本 匹配失败。\n使用管道符号的格式如下:\nexpr1|expr2|...  这里有个例子。\n$ echo \"The cat is asleep\" | gawk '/cat|dog/{print $0}'  这个例子会在数据流中查找正则表达式cat或dog。正则表达式和管道符号之间不能有空格， 否则它们也会被认为是正则表达式模式的一部分。\n管道符号两侧的正则表达式可以采用任何正则表达式模式(包括字符组)来定义文本。\n表达式分组 正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一 个标准字符。可以像对普通字符一样给该组使用特殊字符。\n$ echo \"Sat\" | gawk '/Sat(urday)?/{print $0}'  结尾的urday分组以及问号，使得模式能够匹配完整的Saturday或缩写Sat。\n将分组和管道符号一起使用来创建可能的模式匹配组是很常见的做法。\n$ echo \"cat\" | gawk '/(c|b)a(b|t)/{print $0}'  模式(c|b)a(b|t)会匹配第一组中字母的任意组合以及第二组中字母的任意组合。\n",
  "wordCount" : "3464",
  "inLanguage": "zh-cn",
  "datePublished": "2017-08-12T22:39:08Z",
  "dateModified": "2017-08-12T22:39:08Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      正则表达式详解
    </h1>
    <div class="post-meta">August 12, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h1>
<p>正则表达式是你所定义的模式模板(pattern template)，Linux工具可以用它来过滤文本。Linux 工具(比如sed编辑器或gawk程序)能够在处理数据时使用正则表达式对数据进行模式匹配。</p>
<h1 id="正则表达式的类型">正则表达式的类型<a hidden class="anchor" aria-hidden="true" href="#正则表达式的类型">#</a></h1>
<p>使用正则表达式最大的问题在于有不止一种类型的正则表达式。Linux中的不同应用程序可 能会用不同类型的正则表达式。</p>
<p>正则表达式是通过正则表达式引擎(regular expression engine)实现的。正则表达式引擎是 一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。</p>
<p>在Linux中，有两种流行的正则表达式引擎:</p>
<ol>
<li>POSIX基础正则表达式(basic regular expression，BRE)引擎</li>
<li>POSIX扩展正则表达式(extended regular expression，ERE)引擎</li>
</ol>
<p>大多数Linux工具都至少符合POSIX BRE引擎规范，能够识别该规范定义的所有模式符号。 遗憾的是，有些工具(比如sed编辑器)只符合了BRE引擎规范的子集。这是出于速度方面的考 虑导致的，因为sed编辑器希望能尽可能快地处理数据流中的文本。</p>
<p>POSIX BRE引擎通常出现在依赖正则表达式进行文本过滤的编程语言中。它为常见模式提供 了高级模式符号和特殊符号，比如匹配数字、单词以及按字母排序的字符。gawk程序用ERE引擎 来处理它的正则表达式模式。</p>
<h1 id="定义bre模式">定义BRE模式<a hidden class="anchor" aria-hidden="true" href="#定义bre模式">#</a></h1>
<h2 id="纯文本">纯文本<a hidden class="anchor" aria-hidden="true" href="#纯文本">#</a></h2>
<p>正则表达式并不关心模式在数据流中的位置。它也不关心模式出现了多少次。一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具。</p>
<p>关键在于将正则表达式模式匹配到数据流文本上。重要的是记住正则表达式对匹配的模式非 常挑剔。第一条原则就是:正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符 的模式。</p>
<p>你也不用局限于在正则表达式中只用单个文本单词，可以在正则表达式中使用空格和数字。甚至可以创建匹配多个连续空格的正则表达式模式。</p>
<h2 id="特殊字符">特殊字符<a hidden class="anchor" aria-hidden="true" href="#特殊字符">#</a></h2>
<p>正则表达式识别的特殊字符包括:</p>
<pre><code>.*[]^${}\+?|()
</code></pre>
<p>如果要用某个特殊字符作为文本字符，就必须转义。在转义特殊字符时，你需要在它前面加 一个特殊字符来告诉正则表达式引擎应该将接下来的字符当作普通的文本字符。这个特殊字符就 是反斜线()。</p>
<p>由于反斜线是特殊字符，如果要在正则表达式模式中使用它，你必须对其转义，这样就产生 了两个反斜线。</p>
<p>要使用正斜线，也需要进行转义。</p>
<h2 id="锚字符">锚字符<a hidden class="anchor" aria-hidden="true" href="#锚字符">#</a></h2>
<p>有两个特殊字符可以用来将模式锁定在数据流中的行首或行尾。</p>
<h3 id="1-锁定在行首">1. 锁定在行首<a hidden class="anchor" aria-hidden="true" href="#1-锁定在行首">#</a></h3>
<p>脱字符(^)定义从数据流中文本行的行首开始的模式。如果模式出现在行首之外的位置， 正则表达式模式则无法匹配。</p>
<p>要用脱字符，就必须将它放在正则表达式中指定的模式前面。</p>
<pre><code>$ echo &quot;The book store&quot; | sed -n '/^book/p'
</code></pre>
<p>脱字符会在每个由换行符决定的新数据行的行首检查模式。</p>
<p>只要模式出现在新行的行首，脱字符就能够发现它。 如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了:</p>
<pre><code>$ echo &quot;This is a test&quot; | sed -n '/s ^/p'
</code></pre>
<p>如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。</p>
<h3 id="2-锁定在行尾">2. 锁定在行尾<a hidden class="anchor" aria-hidden="true" href="#2-锁定在行尾">#</a></h3>
<p>跟在行首查找模式相反的就是在行尾查找。特殊字符美元符($)定义了行尾锚点。将这个 特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。</p>
<pre><code>$ echo &quot;This is a good book&quot; | sed -n '/book$/p'
</code></pre>
<h3 id="3-组合锚点">3. 组合锚点<a hidden class="anchor" aria-hidden="true" href="#3-组合锚点">#</a></h3>
<p>可以在同一行中将行首锚点和行尾锚点组合在一起使用。在第一种情况 中，假定你要查找只含有特定文本模式的数据行。</p>
<pre><code>$ sed -n '/^this is a test$/p' data4
</code></pre>
<p>sed编辑器忽略了那些不单单包含指定的文本的行。</p>
<p>将两个锚点直接组合在一起，之间不加任何 文本，这样过滤出数据流中的空白行.</p>
<pre><code>$ sed '/ $/d' data5
</code></pre>
<h2 id="点号字符">点号字符<a hidden class="anchor" aria-hidden="true" href="#点号字符">#</a></h2>
<p>特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字 符的位置没有字符，那么模式就不成立。在正则表达式中， 空格也是字符.</p>
<pre><code>$ sed -n '/.at/p' data6
</code></pre>
<h2 id="字符组">字符组<a hidden class="anchor" aria-hidden="true" href="#字符组">#</a></h2>
<p>可以定义字符组用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据 流中，那它就匹配了该模式。</p>
<p>使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。然后你 可以在模式中使用整个组，就跟使用其他通配符一样。</p>
<pre><code>$ sed -n '/[ch]at/p' data6
</code></pre>
<h2 id="排除型字符组">排除型字符组<a hidden class="anchor" aria-hidden="true" href="#排除型字符组">#</a></h2>
<p>在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，而不是去寻找组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符。</p>
<pre><code>$ sed -n '/[^ch]at/p' data6
</code></pre>
<p>通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字 符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at开头的行仍然未能匹配模式。</p>
<h2 id="区间">区间<a hidden class="anchor" aria-hidden="true" href="#区间">#</a></h2>
<p>可以用单破折线符号在字符组 中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。根据Linux系统采用的字符集，正则表达式会包括此区间内的任意字符。</p>
<p>现在你可以通过指定数字区间来简化邮编的例子。</p>
<pre><code>$ sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8
</code></pre>
<p>还可以在单个字符组指定多个不连续的区间。</p>
<pre><code>$ sed -n '/[a-ch-m]at/p' data6
</code></pre>
<p>该字符组允许区间a~c、h~m中的字母出现在at文本前，但不允许出现d~g的字母。</p>
<h2 id="特殊的字符组">特殊的字符组<a hidden class="anchor" aria-hidden="true" href="#特殊的字符组">#</a></h2>
<p>除了定义自己的字符组外，BRE还包含了一些特殊的字符组，可用来匹配特定类型的字符。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ20170813-111044@2x.png" alt=""  />
</p>
<p>可以在正则表达式模式中将特殊字符组像普通字符组一样使用。</p>
<pre><code>$ echo &quot;abc&quot; | sed -n '/[[:digit:]]/p'
</code></pre>
<h2 id="星号">星号<a hidden class="anchor" aria-hidden="true" href="#星号">#</a></h2>
<p>在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次。</p>
<pre><code>$ echo &quot;ik&quot; | sed -n '/ie*k/p'
</code></pre>
<p>模式中的u*表明字母u可能出现或不出现在匹配模式的文本中。类似地，如果你知道一个单
词经常被拼错，你可以用星号来允许这种错误。</p>
<p>星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。</p>
<pre><code>$ echo &quot;bt&quot; | sed -n '/b[ae]*t/p'
</code></pre>
<p>只要a和e字符以任何组合形式出现在b和t字符之间(就算完全不出现也行)，模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。</p>
<h1 id="扩展正则表达式">扩展正则表达式<a hidden class="anchor" aria-hidden="true" href="#扩展正则表达式">#</a></h1>
<p>POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号。gawk程序能够识别ERE模式，但sed编辑器不能。</p>
<p>记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多 数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器 所不具备的。但正因为如此，gawk程序在处理数据流时通常才比较慢。</p>
<h2 id="问号">问号<a hidden class="anchor" aria-hidden="true" href="#问号">#</a></h2>
<p>问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于 此。它不会匹配多次出现的字符。</p>
<pre><code>$ echo &quot;bt&quot; | gawk '/be?t/{print $0}'
</code></pre>
<p>如果字符e并未在文本中出现，或者它只在文本中出现了1次，那么模式会匹配。 与星号一样，你可以将问号和字符组一起使用。</p>
<h2 id="加号">加号<a hidden class="anchor" aria-hidden="true" href="#加号">#</a></h2>
<p>加号是类似于星号的另一个模式符号，但跟问号也有不同。加号表明前面的字符可以出现1次或多次，但必须至少出现1次。</p>
<pre><code>$ echo &quot;beeet&quot; | gawk '/be+t/{print $0}'
</code></pre>
<p>如果字符e没有出现，模式匹配就不成立。加号同样适用于字符组，与星号和问号的使用方 式相同。</p>
<h2 id="使用花括号">使用花括号<a hidden class="anchor" aria-hidden="true" href="#使用花括号">#</a></h2>
<p>ERE中的花括号允许你为可重复的正则表达式指定一个上限。这通常称为间隔(interval)。 10 可以用两种格式来指定区间。</p>
<ol>
<li>m:正则表达式准确出现m次。</li>
<li>m, n:正则表达式至少出现m次，至多n次。</li>
</ol>
<p>这个特性可以精确调整字符或字符集在模式中具体出现的次数。</p>
<p>默认情况下，gawk程序不会识别正则表达式间隔。必须指定gawk程序的&ndash;re-interval 命令行选项才能识别正则表达式间隔。</p>
<pre><code>$ echo &quot;bet&quot; | gawk --re-interval '/be{1}t/{print $0}'
</code></pre>
<p>通过指定间隔为1，限定了该字符在匹配模式的字符串中出现的次数。如果该字符出现多次， 模式匹配就不成立。</p>
<p>很多时候，同时指定下限和上限也很方便。</p>
<pre><code>$ echo &quot;bt&quot; | gawk --re-interval '/be{1,2}t/{print $0}'
</code></pre>
<h2 id="管道符号">管道符号<a hidden class="anchor" aria-hidden="true" href="#管道符号">#</a></h2>
<p>管道符号允许你在检查数据流时，用逻辑OR方式指定正则表达式引擎要用的两个或多个模 式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本 匹配失败。</p>
<p>使用管道符号的格式如下:</p>
<pre><code>expr1|expr2|... 
</code></pre>
<p>这里有个例子。</p>
<pre><code>$ echo &quot;The cat is asleep&quot; | gawk '/cat|dog/{print $0}'
</code></pre>
<p>这个例子会在数据流中查找正则表达式cat或dog。正则表达式和管道符号之间不能有空格， 否则它们也会被认为是正则表达式模式的一部分。</p>
<p>管道符号两侧的正则表达式可以采用任何正则表达式模式(包括字符组)来定义文本。</p>
<h2 id="表达式分组">表达式分组<a hidden class="anchor" aria-hidden="true" href="#表达式分组">#</a></h2>
<p>正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一 个标准字符。可以像对普通字符一样给该组使用特殊字符。</p>
<pre><code>$ echo &quot;Sat&quot; | gawk '/Sat(urday)?/{print $0}'
</code></pre>
<p>结尾的urday分组以及问号，使得模式能够匹配完整的Saturday或缩写Sat。</p>
<p>将分组和管道符号一起使用来创建可能的模式匹配组是很常见的做法。</p>
<pre><code>$ echo &quot;cat&quot; | gawk '/(c|b)a(b|t)/{print $0}'
</code></pre>
<p>模式(c|b)a(b|t)会匹配第一组中字母的任意组合以及第二组中字母的任意组合。</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
