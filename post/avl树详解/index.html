<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>AVL树详解 | Forz Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787. 定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。 性质 AVL树本质上还">
<meta name="author" content="">
<link rel="canonical" href="/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="AVL树详解" />
<meta property="og:description" content="转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787. 定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。 性质 AVL树本质上还" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-25T22:44:51&#43;00:00" />
<meta property="article:modified_time" content="2017-06-25T22:44:51&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="AVL树详解"/>
<meta name="twitter:description" content="转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787. 定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。 性质 AVL树本质上还"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "AVL树详解",
      "item": "/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AVL树详解",
  "name": "AVL树详解",
  "description": "转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787. 定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。 性质 AVL树本质上还",
  "keywords": [
    
  ],
  "articleBody": "转载： http://www.cnblogs.com/QG-whz/p/5167238.html. http://blog.csdn.net/sp_programmer/article/details/41812787.\n定义 AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。\n性质 AVL树本质上还是一棵二叉搜索树（因此读者可以看到我后面的代码是继承自二叉搜索树的），它的特点是：\n  本身首先是一棵二叉搜索树。\n  带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。\n  例如：\n 5 5 / \\ / \\ 2 6 2 6 / \\ \\ / \\ 1 4 7 1 4 / / 3 3  上图中，左边的是AVL树，而右边的不是。因为左边的树的每个结点的左右子树的高度之差的绝对值都最多为1，而右边的树由于结点6没有子树，导致根结点5的平衡因子为2。\n效率 一棵AVL树有N个节点，其高度可以保持在lgN，插入/删除/查找的时间复杂度也是lgN。\n我们先来看看二叉搜索树吧（因为AVL树本质上是一棵二叉搜索树），假设有这么一种极端的情况：二叉搜索树的结点为1、2、3、4、5，也就是：\n1 \\ 2 \\ 3 \\ 4 \\ 5  这棵二叉搜索树其实等同于一个链表了，也就是说，它在查找上的优势已经全无了——在这种情况下，查找一个结点的时间复杂度是O(N)！\n好，那么假如是AVL树（别忘了AVL树还是二叉搜索树），则会是：\n 2 / \\ 1 4 / \\ 3 5  可以看出，AVL树的查找平均时间复杂度要比二叉搜索树低——它是O(logN)，但是插入操作可能会破坏平衡性另当别论了，也正是我们下面只讨论插入操作的原因。也就是说，在大量的随机数据中AVL树的表现要好得多。\n节点结构 1 2 3 4 5 6 7 8 9 10  struct AVLTreeNode { AVLTreeNode(T value, AVLTreeNodeT*l, AVLTreeNodeT*r) :key(value), lchild(l), rchild(r){} T key; int height;\t//节点的高度，用于计算父节点的平衡因子  AVLTreeNodeT* lchild; AVLTreeNodeT* rchild; };   旋转操作 假设有一个结点的平衡因子为2（在AVL树中，最大就是2，因为结点是一个一个地插入到树中的，一旦出现不平衡的状态就会立即进行调整，因此平衡因子最大不可能超过2），那么就需要进行调整。由于任意一个结点最多只有两个儿子，所以当高度不平衡时，只可能是以下四种情况造成的：\n  对该结点的左儿子的左子树进行了一次插入。\n  对该结点的左儿子的右子树进行了一次插入。\n  对该结点的右儿子的左子树进行了一次插入。\n  对该结点的右儿子的右子树进行了一次插入。\n  情况1和4是关于该点的镜像对称，同样，情况2和3也是一对镜像对称。因此，理论上只有两种情况，当然了，从编程的角度来看还是四种情况。\n第一种情况是插入发生在“外边”的情况（即左-左的情况或右-右的情况），该情况可以通过对树的一次单旋转来完成调整。第二种情况是插入发生在“内部”的情况（即左-右的情况或右-左的情况），该情况要通过稍微复杂些的双旋转来处理。注意所有旋转情况都是围绕着使得二叉树不平衡的第一个节点展开的。\n1. LL型 平衡二叉树某一节点的左孩子的左子树上插入一个新的节点，使得该节点不再平衡。这时只需要把树向右旋转一次即可，如图所示，原A的左孩子B变为父结点，A变为其右孩子，而原B的右子树变为A的左子树，注意旋转之后Brh是A的左子树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /*右旋转操作*/ /*pnode为最小失衡子树的根节点*/ /*返回旋转后的根节点*/ template typename T AVLTreeNodeT* AVLTreeT::rightRotation(AVLTreeNodeT*proot) { AVLTreeNodeT* plchild = proot-lchild; proot-lchild = plchild-rchild; plchild-rchild = proot; proot-height = max(height(proot-lchild), height(proot-rchild)) + 1; //更新节点的高度值  plchild-height = max(height(plchild-lchild), height(plchild-rchild)) + 1; //更新节点的高度值  return plchild; };   2. RR型 平衡二叉树某一节点的右孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时只需要把树向左旋转一次即可，如图所示，原A右孩子B变为父结点，A变为其左孩子，而原B的左子树Blh将变为A的右子树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /*左旋转操作*/ /*pnode为最小失衡子树的根节点*/ /*返回旋转后的根节点*/ templatetypename T AVLTreeNodeT* AVLTreeT::leftRotation(AVLTreeNodeT* proot) { AVLTreeNodeT* prchild = proot-rchild; proot-rchild = prchild-lchild; prchild-lchild = proot; proot-height = max(height(proot-lchild),height(proot-rchild))+1; //更新节点的高度值  prchild-height = max(height(prchild-lchild), height(prchild-rchild)) + 1; //更新节点的高度值  return prchild; };   3. LR型 平衡二叉树某一节点的左孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时需要旋转两次，仅一次的旋转是不能够使二叉树再次平衡。如图所示，在B节点按照RR型向左旋转一次之后，二叉树在A节点仍然不能保持平衡，这时还需要再向右旋转一次。\n1 2 3 4 5 6 7 8 9  /*先左后右做旋转*/ /*参数proot为最小失衡子树的根节点*/ /*返回旋转后的根节点*/ template typename T AVLTreeNodeT* AVLTreeT::leftRightRotation(AVLTreeNodeT* proot) { proot-lchild= leftRotation(proot-lchild); return rightRotation(proot); };   4. RL型 平衡二叉树某一节点的右孩子的左子树上插入一个新的节点，使得该节点不再平衡。同样，这时需要旋转两次，旋转方向刚好同LR型相反。\n1 2 3 4 5 6 7 8 9  /*先右旋再左旋*/ /*参数proot为最小失衡子树的根节点*/ /*返回旋转后的根节点*/ templatetypename T AVLTreeNodeT* AVLTreeT::rightLeftRotation(AVLTreeNodeT* proot) { proot-rchild = rightRotation(proot-rchild); return leftRotation(proot); };   插入操作 插入的核心思路是通过递归找到合适的位置，插入新结点，然后看新结点是否平衡（平衡因子是否为2），如果不平衡的话，就分成三种大情况以及两种小情况：\n  在结点的左儿子(X item)\n 在左儿子的左子树 (X l- item)，“外边”，要做单旋转。 在左儿子的右子树 (X  T-l- item)，“内部”，要做双旋转。    在结点的右儿子(X  T-item)\n 在右儿子的左子树(X r- item)，“内部”，要做双旋转。 在右儿子的右子树(X  T-r- item)，“外边”，要做单旋转。    (X == T-item) ，对该节点的计数进行更新。 实现代码：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /*插入操作*/ /*递归地进行插入*/ /*返回插入后的根节点*/ template typename T AVLTreeNodeT* AVLTreeT::insert(AVLTreeNodeT* \u0026pnode, T key) { if (pnode == nullptr) //寻找到插入的位置  { pnode = new AVLTreeNodeT(key, nullptr, nullptr); } else if (key  pnode-key) //插入值比当前结点值大，插入到当前结点的右子树上  { pnode-rchild = insert(pnode-rchild, key); if (height(pnode-rchild) - height(pnode-lchild) == 2) //插入后出现失衡  { if (key  pnode-rchild-key) //情况一：插入右子树的右节点，进行左旋  pnode=leftRotation(pnode); else if (key  pnode-rchild-key) //情况三：插入右子树的左节点,进行先右再左旋转  pnode=rightLeftRotation(pnode); } } else if (key  pnode-key) //插入值比当前节点值小，插入到当前结点的左子树上  { pnode-lchild = insert(pnode-lchild, key); if (height(pnode-lchild) - height(pnode-rchild) == 2) //如果插入导致失衡  { if (key  pnode-lchild-key) //情况二：插入到左子树的左孩子节点上，进行右旋  pnode = rightRotation(pnode); else if (keypnode-lchild-key) pnode = leftRightRotation(pnode);//情况四：插入到左子树的右孩子节点上，进行先左后右旋转  } } pnode-height = max(height(pnode-lchild), height(pnode-rchild)) + 1; return pnode; };   删除操作 删除节点也可能导致AVL树的失衡，实际上删除节点和插入节点是一种互逆的操作：\n删除右子树的节点导致AVL树失衡时，相当于在左子树插入节点导致AVL树失衡。\n删除左子树的节点导致AVL树失衡时，相当于在右子树插入节点导致AVL树失衡。\n另外，AVL树也是一棵二叉排序树，因此在删除节点时也要维护二叉排序树的性质。\n删除节点有三种情况分析：\n叶子节点；(直接删除即可) 仅有左或右子树的节点；（上移子树即可） 左右子树都有的节点。可以用删除节点在中序遍历时的直接前驱或者直接后继来替换当前节点，然后删除直接前驱或者直接后继的原位置。   如果从左子树中选，就应该选择左子树中最右边的那个叶子节点\n  如果从右子树中选，就应该选择有子树中最左边的那个叶子节点。\n  因为是在AVL树上进行删除，所以在高度较低的子树上选择最大（或最小）元素进行替换，这样能保证替换后不会再出现失衡的现象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  /*删除指定元素*/ templatetypename T AVLTreeNodeT* AVLTreeT::remove(AVLTreeNodeT* \u0026 pnode, T key) { if (pnode != nullptr) { if (key == pnode-key) //找到删除的节点  { //因AVL也是二叉排序树，删除节点要维护其二叉排序树的条件  if (pnode-lchild != nullptr\u0026\u0026pnode-rchild != nullptr) //若左右都不为空  { // 左子树比右子树高,在左子树上选择节点进行替换  if (height(pnode-lchild)  height(pnode-rchild)) { //使用左子树最大节点来代替被删节点，而删除该最大节点  AVLTreeNodeT* ppre = maximum(pnode-lchild); //左子树最大节点  pnode-key = ppre-key; //将最大节点的值覆盖当前结点  pnode-lchild = remove(pnode-lchild, ppre-key); //递归地删除最大节点  } else //在右子树上选择节点进行替换  { //使用最小节点来代替被删节点，而删除该最小节点  AVLTreeNodeT* psuc = minimum(pnode-rchild); //右子树的最小节点  pnode-key = psuc-key; //将最小节点值覆盖当前结点  pnode-rchild = remove(pnode-rchild, psuc-key); //递归地删除最小节点  } } else\t//至多有一个子树，上移子树或直接删除  { AVLTreeNodeT * ptemp = pnode; if (pnode-lchild != nullptr) pnode = pnode-lchild; else if (pnode-rchild != nullptr) pnode = pnode-rchild; delete ptemp; return nullptr; } } else if (key  pnode-key)//要删除的节点比当前节点大，则在右子树进行删除  { pnode-rchild = remove(pnode-rchild, key); //删除右子树节点导致不平衡:相当于增加左子树节点  if (height(pnode-lchild) - height(pnode-rchild) == 2) { //相当于在左子树上插入右节点造成的失衡（LR）  if (height(pnode-lchild-rchild)height(pnode-lchild-lchild)) pnode = leftRightRotation(pnode); else//相当于在左子树上插入左节点造成的失衡（LL）  pnode = rightRotation(pnode); } } else if (key  pnode-key)//要删除的节点比当前节点小，则在左子树进行删除  { pnode-lchild= remove(pnode-lchild, key); //删除左子树节点导致不平衡：相当于增加右子树节点  if (height(pnode-rchild) - height(pnode-lchild) == 2) { //相当于在右子树上插入左节点造成的失衡（RL）  if (height(pnode-rchild-lchild)height(pnode-rchild-rchild)) pnode = rightLeftRotation(pnode); else//相当于在右子树上插入右节点造成的失衡（RR）  pnode = leftRotation(pnode); } } return pnode; } return nullptr; };   ",
  "wordCount" : "3465",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-25T22:44:51Z",
  "dateModified": "2017-06-25T22:44:51Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      AVL树详解
    </h1>
    <div class="post-meta">June 25, 2017
</div>
  </header> 
  <div class="post-content"><p>转载：  <br>
<a href="">http://www.cnblogs.com/QG-whz/p/5167238.html</a>. <br>
<a href="">http://blog.csdn.net/sp_programmer/article/details/41812787</a>.</p>
<h1 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h1>
<p>AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。</p>
<h1 id="性质">性质<a hidden class="anchor" aria-hidden="true" href="#性质">#</a></h1>
<p>AVL树本质上还是一棵二叉搜索树（因此读者可以看到我后面的代码是继承自二叉搜索树的），它的特点是：</p>
<ol>
<li>
<p>本身首先是一棵二叉搜索树。</p>
</li>
<li>
<p>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</p>
</li>
</ol>
<p>例如：</p>
<pre><code>    5              5
   / \            / \
  2   6          2   6
 / \   \        / \
1   4   7      1   4
   /              /
  3              3
</code></pre>
<p>上图中，左边的是AVL树，而右边的不是。因为左边的树的每个结点的左右子树的高度之差的绝对值都最多为1，而右边的树由于结点6没有子树，导致根结点5的平衡因子为2。</p>
<h1 id="效率">效率<a hidden class="anchor" aria-hidden="true" href="#效率">#</a></h1>
<p>一棵AVL树有N个节点，其高度可以保持在lgN，插入/删除/查找的时间复杂度也是lgN。</p>
<p>我们先来看看二叉搜索树吧（因为AVL树本质上是一棵二叉搜索树），假设有这么一种极端的情况：二叉搜索树的结点为1、2、3、4、5，也就是：</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
</code></pre>
<p>这棵二叉搜索树其实等同于一个链表了，也就是说，它在查找上的优势已经全无了——在这种情况下，查找一个结点的时间复杂度是O(N)！</p>
<p>好，那么假如是AVL树（别忘了AVL树还是二叉搜索树），则会是：</p>
<pre><code>  2
 / \
1   4
   / \
  3   5
</code></pre>
<p>可以看出，AVL树的查找平均时间复杂度要比二叉搜索树低——它是O(logN)，但是插入操作可能会破坏平衡性另当别论了，也正是我们下面只讨论插入操作的原因。也就是说，在大量的随机数据中AVL树的表现要好得多。</p>
<h1 id="节点结构">节点结构<a hidden class="anchor" aria-hidden="true" href="#节点结构">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">AVLTreeNode</span>
<span class="p">{</span>
    <span class="n">AVLTreeNode</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="n">l</span><span class="p">,</span> <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="n">r</span><span class="p">)</span>
    <span class="o">:</span><span class="n">key</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">lchild</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">rchild</span><span class="p">(</span><span class="n">r</span><span class="p">){}</span>
 
    <span class="n">T</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>		<span class="c1">//节点的高度，用于计算父节点的平衡因子
</span><span class="c1"></span>    <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">lchild</span><span class="p">;</span>
    <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">rchild</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="旋转操作">旋转操作<a hidden class="anchor" aria-hidden="true" href="#旋转操作">#</a></h1>
<p>假设有一个结点的平衡因子为2（在AVL树中，最大就是2，因为结点是一个一个地插入到树中的，一旦出现不平衡的状态就会立即进行调整，因此平衡因子最大不可能超过2），那么就需要进行调整。由于任意一个结点最多只有两个儿子，所以当高度不平衡时，只可能是以下四种情况造成的：</p>
<ol>
<li>
<p>对该结点的左儿子的左子树进行了一次插入。</p>
</li>
<li>
<p>对该结点的左儿子的右子树进行了一次插入。</p>
</li>
<li>
<p>对该结点的右儿子的左子树进行了一次插入。</p>
</li>
<li>
<p>对该结点的右儿子的右子树进行了一次插入。</p>
</li>
</ol>
<p>情况1和4是关于该点的镜像对称，同样，情况2和3也是一对镜像对称。因此，理论上只有两种情况，当然了，从编程的角度来看还是四种情况。</p>
<p>第一种情况是插入发生在“外边”的情况（即左-左的情况或右-右的情况），该情况可以通过对树的一次单旋转来完成调整。第二种情况是插入发生在“内部”的情况（即左-右的情况或右-左的情况），该情况要通过稍微复杂些的双旋转来处理。注意所有旋转情况都是围绕着使得二叉树不平衡的第一个节点展开的。</p>
<h2 id="1-ll型">1. LL型<a hidden class="anchor" aria-hidden="true" href="#1-ll型">#</a></h2>
<p>平衡二叉树某一节点的左孩子的左子树上插入一个新的节点，使得该节点不再平衡。这时只需要把树向右旋转一次即可，如图所示，原A的左孩子B变为父结点，A变为其右孩子，而原B的右子树变为A的左子树，注意旋转之后Brh是A的左子树</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20141209000729203.jpg" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*右旋转操作*/</span>
<span class="cm">/*pnode为最小失衡子树的根节点*/</span>
<span class="cm">/*返回旋转后的根节点*/</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span>  <span class="n">T</span><span class="o">&gt;</span>
<span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">rightRotation</span><span class="p">(</span><span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="n">proot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">plchild</span> <span class="o">=</span> <span class="n">proot</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
    <span class="n">proot</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">plchild</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
    <span class="n">plchild</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">proot</span><span class="p">;</span>
 
    <span class="n">proot</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">proot</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">proot</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">//更新节点的高度值
</span><span class="c1"></span>    <span class="n">plchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">plchild</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">plchild</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//更新节点的高度值
</span><span class="c1"></span> 
    <span class="k">return</span> <span class="n">plchild</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-rr型">2. RR型<a hidden class="anchor" aria-hidden="true" href="#2-rr型">#</a></h2>
<p>平衡二叉树某一节点的右孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时只需要把树向左旋转一次即可，如图所示，原A右孩子B变为父结点，A变为其左孩子，而原B的左子树Blh将变为A的右子树。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20141209000811932.jpg" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*左旋转操作*/</span>
<span class="cm">/*pnode为最小失衡子树的根节点*/</span>
<span class="cm">/*返回旋转后的根节点*/</span>
<span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">leftRotation</span><span class="p">(</span><span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">proot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">prchild</span> <span class="o">=</span> <span class="n">proot</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
    <span class="n">proot</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">prchild</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
    <span class="n">prchild</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">proot</span><span class="p">;</span>
 
    <span class="n">proot</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">proot</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">),</span><span class="n">height</span><span class="p">(</span><span class="n">proot</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">//更新节点的高度值
</span><span class="c1"></span>    <span class="n">prchild</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">prchild</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">prchild</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//更新节点的高度值
</span><span class="c1"></span> 
    <span class="k">return</span> <span class="n">prchild</span><span class="p">;</span>                    
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-lr型">3. LR型<a hidden class="anchor" aria-hidden="true" href="#3-lr型">#</a></h2>
<p>平衡二叉树某一节点的左孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时需要旋转两次，仅一次的旋转是不能够使二叉树再次平衡。如图所示，在B节点按照RR型向左旋转一次之后，二叉树在A节点仍然不能保持平衡，这时还需要再向右旋转一次。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20141209000838640.jpg" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*先左后右做旋转*/</span>
<span class="cm">/*参数proot为最小失衡子树的根节点*/</span>
<span class="cm">/*返回旋转后的根节点*/</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">leftRightRotation</span><span class="p">(</span><span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">proot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">proot</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span> <span class="n">leftRotation</span><span class="p">(</span><span class="n">proot</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">rightRotation</span><span class="p">(</span><span class="n">proot</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-rl型">4. RL型<a hidden class="anchor" aria-hidden="true" href="#4-rl型">#</a></h2>
<p>平衡二叉树某一节点的右孩子的左子树上插入一个新的节点，使得该节点不再平衡。同样，这时需要旋转两次，旋转方向刚好同LR型相反。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20141209000901790.jpg" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*先右旋再左旋*/</span>
<span class="cm">/*参数proot为最小失衡子树的根节点*/</span>
<span class="cm">/*返回旋转后的根节点*/</span>
<span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">rightLeftRotation</span><span class="p">(</span><span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">proot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">proot</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">rightRotation</span><span class="p">(</span><span class="n">proot</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">leftRotation</span><span class="p">(</span><span class="n">proot</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="插入操作">插入操作<a hidden class="anchor" aria-hidden="true" href="#插入操作">#</a></h1>
<p>插入的核心思路是通过递归找到合适的位置，插入新结点，然后看新结点是否平衡（平衡因子是否为2），如果不平衡的话，就分成三种大情况以及两种小情况：</p>
<ol>
<li>
<p>在结点的左儿子(X &lt; T-&gt;item)</p>
<ol>
<li>在左儿子的左子树 (X &lt; T-&gt;l-&gt; item)，“外边”，要做单旋转。</li>
<li>在左儿子的右子树 (X &gt; T-&gt;l-&gt; item)，“内部”，要做双旋转。</li>
</ol>
</li>
<li>
<p>在结点的右儿子(X &gt; T-&gt;item)</p>
<ol>
<li>在右儿子的左子树(X &lt; T-&gt;r-&gt; item)，“内部”，要做双旋转。</li>
<li>在右儿子的右子树(X &gt; T-&gt;r-&gt; item)，“外边”，要做单旋转。</li>
</ol>
</li>
<li>
<p>(X == T-&gt;item) ，对该节点的计数进行更新。
实现代码：</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*插入操作*/</span>
<span class="cm">/*递归地进行插入*/</span>
<span class="cm">/*返回插入后的根节点*/</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="p">,</span> <span class="n">T</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span>    <span class="c1">//寻找到插入的位置
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">pnode</span> <span class="o">=</span> <span class="n">new</span> <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>    <span class="c1">//插入值比当前结点值大，插入到当前结点的右子树上
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">//插入后出现失衡
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="c1">//情况一：插入右子树的右节点，进行左旋
</span><span class="c1"></span>                <span class="n">pnode</span><span class="o">=</span><span class="n">leftRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>  <span class="c1">//情况三：插入右子树的左节点,进行先右再左旋转
</span><span class="c1"></span>                <span class="n">pnode</span><span class="o">=</span><span class="n">rightLeftRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="c1">//插入值比当前节点值小，插入到当前结点的左子树上
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">//如果插入导致失衡
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>        <span class="c1">//情况二：插入到左子树的左孩子节点上，进行右旋
</span><span class="c1"></span>                <span class="n">pnode</span> <span class="o">=</span> <span class="n">rightRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">key</span><span class="o">&gt;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
                <span class="n">pnode</span> <span class="o">=</span> <span class="n">leftRightRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span><span class="c1">//情况四：插入到左子树的右孩子节点上，进行先左后右旋转
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">pnode</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="删除操作">删除操作<a hidden class="anchor" aria-hidden="true" href="#删除操作">#</a></h1>
<p>删除节点也可能导致AVL树的失衡，实际上删除节点和插入节点是一种互逆的操作：</p>
<p>删除右子树的节点导致AVL树失衡时，相当于在左子树插入节点导致AVL树失衡。</p>
<p>删除左子树的节点导致AVL树失衡时，相当于在右子树插入节点导致AVL树失衡。</p>
<p>另外，AVL树也是一棵二叉排序树，因此在删除节点时也要维护二叉排序树的性质。</p>
<p>删除节点有三种情况分析：</p>
<h3 id="叶子节点直接删除即可">叶子节点；(直接删除即可)<a hidden class="anchor" aria-hidden="true" href="#叶子节点直接删除即可">#</a></h3>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20140414215005359.jpg" alt=""  />
</p>
<h3 id="仅有左或右子树的节点上移子树即可">仅有左或右子树的节点；（上移子树即可）<a hidden class="anchor" aria-hidden="true" href="#仅有左或右子树的节点上移子树即可">#</a></h3>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/20140414215009687.jpg" alt=""  />
</p>
<h3 id="左右子树都有的节点可以用删除节点在中序遍历时的直接前驱或者直接后继来替换当前节点然后删除直接前驱或者直接后继的原位置">左右子树都有的节点。可以用删除节点在中序遍历时的直接前驱或者直接后继来替换当前节点，然后删除直接前驱或者直接后继的原位置。<a hidden class="anchor" aria-hidden="true" href="#左右子树都有的节点可以用删除节点在中序遍历时的直接前驱或者直接后继来替换当前节点然后删除直接前驱或者直接后继的原位置">#</a></h3>
<ol>
<li>
<p>如果从左子树中选，就应该选择左子树中最右边的那个叶子节点</p>
</li>
<li>
<p>如果从右子树中选，就应该选择有子树中最左边的那个叶子节点。</p>
</li>
</ol>
<p>因为是在AVL树上进行删除，所以在高度较低的子树上选择最大（或最小）元素进行替换，这样能保证替换后不会再出现失衡的现象。</p>
<p><img loading="lazy" src="https://blog-1257321977.cos.ap-beijing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20170528145715.png" alt=""  />
</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*删除指定元素*/</span>
<span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">AVLTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="o">&amp;</span> <span class="n">pnode</span><span class="p">,</span> <span class="n">T</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>            <span class="c1">//找到删除的节点
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="c1">//因AVL也是二叉排序树，删除节点要维护其二叉排序树的条件
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="o">&amp;&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>        <span class="c1">//若左右都不为空
</span><span class="c1"></span>            <span class="p">{</span>
                <span class="c1">// 左子树比右子树高,在左子树上选择节点进行替换
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="c1">//使用左子树最大节点来代替被删节点，而删除该最大节点
</span><span class="c1"></span>                    <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ppre</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>        <span class="c1">//左子树最大节点
</span><span class="c1"></span>                    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">ppre</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>                                <span class="c1">//将最大节点的值覆盖当前结点
</span><span class="c1"></span>                    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">ppre</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>    <span class="c1">//递归地删除最大节点
</span><span class="c1"></span>                <span class="p">}</span>
                <span class="k">else</span>  <span class="c1">//在右子树上选择节点进行替换
</span><span class="c1"></span>                <span class="p">{</span>
                    <span class="c1">//使用最小节点来代替被删节点，而删除该最小节点
</span><span class="c1"></span>                    <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">psuc</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>        <span class="c1">//右子树的最小节点
</span><span class="c1"></span>                    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">psuc</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>                                <span class="c1">//将最小节点值覆盖当前结点
</span><span class="c1"></span>                    <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">psuc</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>    <span class="c1">//递归地删除最小节点
</span><span class="c1"></span>                <span class="p">}</span>
 
            <span class="p">}</span>
            <span class="k">else</span>	<span class="c1">//至多有一个子树，上移子树或直接删除
</span><span class="c1"></span>            <span class="p">{</span>
                <span class="n">AVLTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">ptemp</span> <span class="o">=</span> <span class="n">pnode</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
                <span class="n">delete</span> <span class="n">ptemp</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
 
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span><span class="c1">//要删除的节点比当前节点大，则在右子树进行删除
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span>  <span class="n">remove</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="c1">//删除右子树节点导致不平衡:相当于增加左子树节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="c1">//相当于在左子树上插入右节点造成的失衡（LR）
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span><span class="o">&gt;</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">))</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">leftRightRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
                <span class="k">else</span><span class="c1">//相当于在左子树上插入左节点造成的失衡（LL）
</span><span class="c1"></span>                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">rightRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span> 
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span><span class="c1">//要删除的节点比当前节点小，则在左子树进行删除
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
             <span class="c1">//删除左子树节点导致不平衡：相当于增加右子树节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//相当于在右子树上插入左节点造成的失衡（RL）
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span><span class="o">&gt;</span><span class="n">height</span><span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">))</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">rightLeftRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
                <span class="k">else</span><span class="c1">//相当于在右子树上插入右节点造成的失衡（RR）
</span><span class="c1"></span>                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">leftRotation</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span> 
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pnode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
