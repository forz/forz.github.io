<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>解析“const” | Forz Blog</title>
<meta name="keywords" content="键字" />
<meta name="description" content="const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的">
<meta name="author" content="">
<link rel="canonical" href="/post/%E8%A7%A3%E6%9E%90const/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.00d5d4fc479b1575183ee8d86b4fb372ba9d9b1904e96fa8e4c40ff7debe2b94.css" integrity="sha256-ANXU/EebFXUYPujYa0&#43;zcrqdmxkE6W&#43;o5MQP996&#43;K5Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.87.0" />
<meta property="og:title" content="解析“const”" />
<meta property="og:description" content="const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%A7%A3%E6%9E%90const/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-06-23T20:08:52&#43;00:00" />
<meta property="article:modified_time" content="2017-06-23T20:08:52&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="解析“const”"/>
<meta name="twitter:description" content="const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "解析“const”",
      "item": "/post/%E8%A7%A3%E6%9E%90const/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "解析“const”",
  "name": "解析“const”",
  "description": "const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的",
  "keywords": [
    "键字"
  ],
  "articleBody": "const的用法 修饰变量 修饰常量 与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的。\nint a=3; const int b=a;  修饰引用 指向常量的引用 const引用是指–指向const的引用，其实这样说也不恰当，和const指针一样，const引用可以与常量绑定，也可以与变量绑定，只是不能通过这个const引用来改变绑定对象的值，和const指针类似。\nconst int \u0026ra=a; a=5;//正确 ra=4;//错误，不能通过引用改变a的值  非const引用不能与const对象绑定，因为常量a的值不可改变，但却可以通过非const引用来改变常量a的值，这样做是错误的，如下：\nconst int a=10; int \u0026ra=a;//错误，非const引用不能绑定到const对象  **由于引用本身不是对象，所以其初始化只是将它绑定到初始值对象上，**而且引用一旦初始化完成，引用将始终和它的初始值对象绑定在一起。引用的类型必须与所引用的对象类型一致，但是有例外情况：在初始化常量引用时可以用任意的表达式作为初始值，只要表达式的结果能转换成引用的类型。\n1 2 3 4 5 6 7  const int ca = 1; int \u0026rca = ca;//类型不匹配，将一个普通引用绑定到一个常量 int i=42; const int \u0026r1=i;//正确 const int \u0026r2=42;//正确，r2是const引用 const int \u0026r3=r1*2;//正确，r3是const引用 int \u0026r4=32; //错误，32是字面值   若改成\n1 2  int r=32; int \u0026r4=i;   就可以正常运行\n引用在内部存放的是一个对象的地址，它是该对象的别名。对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，引用实际上指向该对象，但用户不能访问它。\n例如:\ndouble dval = 23; const int \u0026ri = dval;  编译器将其转换为:\nint tmp = dval; // double - int const int \u0026ri = tmp;  指向指针的引用 引用的对象可以为指针\nint *pa = \u0026a; int *\u0026rd = pa;  但是引用的对象不能为地址，如果一定要让引用绑定地址，需要让引用指向的对象和引用本身都为const\nint a = 1; int *\u0026ra = \u0026a; //错误，因为ra为非常量引用,而a的地址值不是对象，编译器会产生临时对象存储a的地址值 const int * const \u0026rc = \u0026a; //正确，rc为绑定到一个指向int常量的指针的常量引用  修饰指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14  #includeusing namespace std; int main(){ int a1=3; ///non-const data const int a2=a1; ///const data  int * a3 = \u0026a1; ///non-const data,non-const pointer const int * a4 = \u0026a1; ///const data,non-const pointer int * const a5 = \u0026a1; ///non-const data,const pointer int const * const a6 = \u0026a1; ///const data,const pointer const int * const a7 = \u0026a1; ///const data,const pointer  return 0; }   const在谁后面谁就不可修改，const在最前面则将其后移一位即可，二者等效\n修饰函数的参数   如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针。\n void StringCopy(char *strDestination, const char *strSource);    如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。\n 不要将函数void Func1(int x) 写成void Func1(const int x)。    对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。\n 例如：将void Func(A a) 改为void Func(const A \u0026a)。  因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间；“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。\n  对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。\n例如：void Func(int x) 不应该改为void Func(const int \u0026x)。\n因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。\n  修饰函数的返回值   如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。\n例如：函数const char * GetString(void); 正确的用法是: const char *str = GetString(); //写为char *str = GetString();将出现编译错误\n  如果函数返回值采用“值传递”方式，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。\n 例如：不要把函数int GetInt(void) 写成const int GetInt(void)。    函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数\n  修饰函数的定义体 任何不会修改数据成员的函数都应该声明为const 类型。如果在编写const 成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Stack { public: void Push(int elem); int Pop(void); int GetCount(void) const; // const 成员函数 private: int m_num; int m_data[100]; }; int Stack::GetCount(void) const { ++ m_num; // 编译错误，企图修改数据成员m_num Pop(); // 编译错误，企图调用非const 函数 return m_num; }   const关键字所起作用的本质，就是把隐藏着的默认的this指针参数，改成const类型。也就是说：假如void foo( )函数被编译器改写为 void foo(T pThis)，则void foo( ) const将会被改写为void foo(const T pThis) 。\n在函数末尾添加一个const，就相当于在隐藏的this参数类型前加一个const\nconst成员函数 const成员函数的调用 尽管函数名和参数列表都相同，char get( ) const成员函数是可以与char get( )并存的，可以形成重载!\n我们假设调用语句为cs.get()，如果cs为non-const对象，则调用foo()。如果cs为const对象，则调用foo()const。\n1 2 3 4 5 6 7 8 9  class Screen { public: char get(int x,int y); char get(int x,int y) const; }; const Screen cs; Screen cc2; char ch = cs.get(0, 0); // 调用const成员函数 ch = cs2.get(0, 0); // 调用非const成员函数   假如没有提供get()const，则const cs调用get()将会报错。但假如是没有提供foo()，则non-const obj调用foo()const是完全没有问题的。也就是说，non-const对象可以调用const函数，但const对象不能调用non-const函数.\n原因在于底层const和顶层const。当对象为const，调用函数时会传入一个const this指针，而函数的形参为非const指针，所以无法正确传入。而当对象为非const，调用函数时传入的非const指针可以被转换为const指针，所以能够正确传入。\n小结 类中二函数都存在的情况下：\n  const对象默认调用const成员函数，非const对象默认调用非const成员函数；\n  若非const对象想调用const成员函数，则需显式转化，如(const Student\u0026)obj.getAge();\n  若const对象想调用非const成员函数，同理const_cast(constObj).getAge();(注意：constObj要加括号)\n  类中只有一函数存在的情况下：\n  非const对象可以调用const成员函数或非const成员函数；\n  const对象只能调用const成员函数,直接调用非const函数时编译器会报错；\n  在const成员函数里面调用非const成员函数 直接在const成员函数里面调用非const成员函数会报错。\n  向const成员函数内传入一个非const对象指针或引用，然后通过该指针或引用来调用非const成员 数。\n  在const成员函数内部进行this指针的const_cast转换，将其变为非const指针，然后就可以直接调用非const成员函数。\n  使用mutable关键字直接忽略掉const函数的限制。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Test { public: Test() : num(0) {} ~Test(){} int Get(Test\u0026 t) const { t.foo(5); return num; } int Get(Test* p) const { p-foo(10); return num; } void foo(int n) { num = n; } private: int num; }; void main() { Test t; coutt.Get(t)t.Get(\u0026t)endl; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class foo{ public: void test1(){ cout  \"I am not a const member function\"  endl; } void test2()const{ foo *temp = const_castfoo*(this);//注意这个转换！！！ temp-test1(); } }; int main(){ foo f; f.test2(); return 0; }   在非const成员函数中调用const成员函数 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。若要在非const成员函数中调用const成员函数，可以用const_cast将this指针指向的对象转换为const类型，然后进行相应的函数调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class TextBlock{ public: //...  const char\u0026 operator[](size_t position) const { //...  return text[position]; } char\u0026 operator[](size_t positon) { return const_castchar\u0026(//该函数返回const char的引用，所以需要再进行一次const_cast  const_castconst TextBlock\u0026(*this)[position]//注意是先将this解引用，然后将this指向的对象强制转换为const类型  ); } private: char text[max_text_len]; };   const的作用 const意味着“只读”   关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。\n  通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。\n  合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。\n  转载：\nhttp://blog.csdn.net/lihao21/article/details/8634876\nhttp://blog.csdn.net/mysunshinetbg/article/details/48346195\n",
  "wordCount" : "3687",
  "inLanguage": "zh-cn",
  "datePublished": "2017-06-23T20:08:52Z",
  "dateModified": "2017-06-23T20:08:52Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/%E8%A7%A3%E6%9E%90const/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Forz Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Forz Blog (Alt + H)">Forz Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      解析“const”
    </h1>
    <div class="post-meta">June 23, 2017
</div>
  </header> 
  <div class="post-content"><h1 id="const的用法">const的用法<a hidden class="anchor" aria-hidden="true" href="#const的用法">#</a></h1>
<h2 id="修饰变量">修饰变量<a hidden class="anchor" aria-hidden="true" href="#修饰变量">#</a></h2>
<h3 id="修饰常量">修饰常量<a hidden class="anchor" aria-hidden="true" href="#修饰常量">#</a></h3>
<p>与变量不同，有const修饰的量是常量，常量的值不可改变，在定义的时候必须初始化，使用未初始化的常量是错误的。</p>
<pre><code>int a=3;  
const int b=a; 
</code></pre>
<h3 id="修饰引用">修饰引用<a hidden class="anchor" aria-hidden="true" href="#修饰引用">#</a></h3>
<h3 id="指向常量的引用">指向常量的引用<a hidden class="anchor" aria-hidden="true" href="#指向常量的引用">#</a></h3>
<p>const引用是指–指向const的引用，其实这样说也不恰当，和const指针一样，const引用可以与常量绑定，也可以与变量绑定，只是不能通过这个const引用来改变绑定对象的值，和const指针类似。</p>
<pre><code>const int &amp;ra=a;  
a=5;//正确  
ra=4;//错误，不能通过引用改变a的值 
</code></pre>
<p>非const引用不能与const对象绑定，因为常量a的值不可改变，但却可以通过非const引用来改变常量a的值，这样做是错误的，如下：</p>
<pre><code>const int a=10;  
int &amp;ra=a;//错误，非const引用不能绑定到const对象 
</code></pre>
<p>**由于引用本身不是对象，所以其初始化只是将它绑定到初始值对象上，**而且引用一旦初始化完成，引用将始终和它的初始值对象绑定在一起。引用的类型必须与所引用的对象类型一致，但是有例外情况：<strong>在初始化常量引用时可以用任意的表达式作为初始值，只要表达式的结果能转换成引用的类型。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">int</span> <span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">rca</span> <span class="o">=</span> <span class="n">ca</span><span class="p">;</span><span class="c1">//类型不匹配，将一个普通引用绑定到一个常量  
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>  
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="c1">//正确  
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span><span class="c1">//正确，r2是const引用  
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span><span class="o">=</span><span class="n">r1</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span><span class="c1">//正确，r3是const引用  
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span><span class="o">=</span><span class="mi">32</span><span class="p">;</span>        <span class="c1">//错误，32是字面值
</span></code></pre></td></tr></table>
</div>
</div><p>若改成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">32</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>就可以正常运行</p>
<p>引用在内部存放的是一个对象的地址，它是该对象的别名。对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，引用实际上指向该对象，但用户不能访问它。</p>
<p>例如:</p>
<pre><code>double dval = 23;
const int &amp;ri = dval; 
</code></pre>
<p>编译器将其转换为:</p>
<pre><code>int tmp = dval; // double -&gt; int
const int &amp;ri = tmp; 
</code></pre>
<h3 id="指向指针的引用">指向指针的引用<a hidden class="anchor" aria-hidden="true" href="#指向指针的引用">#</a></h3>
<p>引用的对象可以为指针</p>
<pre><code>int *pa = &amp;a;
int *&amp;rd = pa;
</code></pre>
<p>但是引用的对象不能为地址，如果一定要让引用绑定地址，需要让引用指向的对象和引用本身都为const</p>
<pre><code>int a = 1;  
int *&amp;ra = &amp;a; //错误，因为ra为非常量引用,而a的地址值不是对象，编译器会产生临时对象存储a的地址值  
const int * const &amp;rc = &amp;a; //正确，rc为绑定到一个指向int常量的指针的常量引用  
</code></pre>
<h3 id="修饰指针">修饰指针<a hidden class="anchor" aria-hidden="true" href="#修饰指针">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<span class="kt">int</span> <span class="n">a1</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>   <span class="c1">///non-const data
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">a2</span><span class="o">=</span><span class="n">a1</span><span class="p">;</span>    <span class="c1">///const data
</span><span class="c1"></span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">;</span>   <span class="c1">///non-const data,non-const pointer
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">;</span>   <span class="c1">///const data,non-const pointer
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">a5</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">;</span>   <span class="c1">///non-const data,const pointer
</span><span class="c1"></span><span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">a6</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">;</span>   <span class="c1">///const data,const pointer
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">a7</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">;</span>   <span class="c1">///const data,const pointer
</span><span class="c1"></span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>const在谁后面谁就不可修改，const在最前面则将其后移一位即可，二者等效</p>
<h2 id="修饰函数的参数">修饰函数的参数<a hidden class="anchor" aria-hidden="true" href="#修饰函数的参数">#</a></h2>
<ol>
<li>
<p>如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针。</p>
<pre><code> void StringCopy(char *strDestination, const char *strSource);
</code></pre>
</li>
<li>
<p>如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</p>
<pre><code> 不要将函数void Func1(int x) 写成void Func1(const int x)。
</code></pre>
</li>
<li>
<p>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。</p>
<pre><code> 例如：将void Func(A a) 改为void Func(const A &amp;a)。
</code></pre>
<p>因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间；“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。</p>
</li>
<li>
<p>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。</p>
<p>例如：void Func(int x) 不应该改为void Func(const int &amp;x)。</p>
<p>因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
</li>
</ol>
<h2 id="修饰函数的返回值">修饰函数的返回值<a hidden class="anchor" aria-hidden="true" href="#修饰函数的返回值">#</a></h2>
<ol>
<li>
<p>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。</p>
<p>例如：函数const char * GetString(void);
正确的用法是: const char *str = GetString();  //写为char *str = GetString();将出现编译错误</p>
</li>
<li>
<p>如果函数返回值采用“值传递”方式，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。</p>
<pre><code> 例如：不要把函数int GetInt(void) 写成const int GetInt(void)。
</code></pre>
</li>
<li>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数</p>
</li>
</ol>
<h2 id="修饰函数的定义体">修饰函数的定义体<a hidden class="anchor" aria-hidden="true" href="#修饰函数的定义体">#</a></h2>
<p>任何不会修改数据成员的函数都应该声明为const 类型。如果在编写const 成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Stack</span>  
<span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">void</span> <span class="n">Push</span><span class="p">(</span><span class="kt">int</span> <span class="n">elem</span><span class="p">);</span>  
<span class="kt">int</span> <span class="nf">Pop</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>  
<span class="kt">int</span> <span class="nf">GetCount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// const 成员函数  
</span><span class="c1"></span><span class="nl">private</span><span class="p">:</span>  
<span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>  
<span class="kt">int</span> <span class="n">m_data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>  
<span class="p">};</span>  
<span class="kt">int</span> <span class="n">Stack</span><span class="o">::</span><span class="n">GetCount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>  
<span class="p">{</span>  
<span class="o">++</span> <span class="n">m_num</span><span class="p">;</span> <span class="c1">// 编译错误，企图修改数据成员m_num  
</span><span class="c1"></span><span class="n">Pop</span><span class="p">();</span> <span class="c1">// 编译错误，企图调用非const 函数  
</span><span class="c1"></span><span class="k">return</span> <span class="n">m_num</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>const关键字所起作用的本质，就是把隐藏着的默认的this指针参数，改成const类型。也就是说：假如void foo( )函数被编译器改写为 void foo(T pThis)，则void foo( ) const将会被改写为void foo(const T pThis) 。</p>
<p>在函数末尾添加一个const，就相当于在隐藏的this参数类型前加一个const</p>
<h1 id="const成员函数">const成员函数<a hidden class="anchor" aria-hidden="true" href="#const成员函数">#</a></h1>
<h2 id="const成员函数的调用">const成员函数的调用<a hidden class="anchor" aria-hidden="true" href="#const成员函数的调用">#</a></h2>
<p>尽管函数名和参数列表都相同，char get( ) const成员函数是可以与char get( )并存的，可以形成重载!</p>
<p>我们假设调用语句为cs.get()，如果cs为non-const对象，则调用foo()。如果cs为const对象，则调用foo()const。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Screen</span> <span class="p">{</span>  
<span class="nl">public</span><span class="p">:</span>  
<span class="kt">char</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>  
<span class="kt">char</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  
<span class="p">};</span> 
<span class="k">const</span> <span class="n">Screen</span> <span class="n">cs</span><span class="p">;</span>  
<span class="n">Screen</span> <span class="n">cc2</span><span class="p">;</span>  
<span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">cs</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 调用const成员函数  
</span><span class="c1"></span><span class="n">ch</span> <span class="o">=</span> <span class="n">cs2</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>     <span class="c1">// 调用非const成员函数
</span></code></pre></td></tr></table>
</div>
</div><p>假如没有提供get()const，则const cs调用get()将会报错。但假如是没有提供foo()，则non-const obj调用foo()const是完全没有问题的。也就是说，non-const对象可以调用const函数，但const对象不能调用non-const函数.</p>
<p>原因在于底层const和顶层const。当对象为const，调用函数时会传入一个const this指针，而函数的形参为非const指针，所以无法正确传入。而当对象为非const，调用函数时传入的非const指针可以被转换为const指针，所以能够正确传入。</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>类中二函数都存在的情况下：</p>
<ol>
<li>
<p>const对象默认调用const成员函数，非const对象默认调用非const成员函数；</p>
</li>
<li>
<p>若非const对象想调用const成员函数，则需显式转化，如(const Student&amp;)obj.getAge();</p>
</li>
<li>
<p>若const对象想调用非const成员函数，同理const_cast(constObj).getAge();(注意：constObj要加括号)</p>
</li>
</ol>
<p>类中只有一函数存在的情况下：</p>
<ol>
<li>
<p>非const对象可以调用const成员函数或非const成员函数；</p>
</li>
<li>
<p>const对象只能调用const成员函数,直接调用非const函数时编译器会报错；</p>
</li>
</ol>
<h1 id="在const成员函数里面调用非const成员函数">在const成员函数里面调用非const成员函数<a hidden class="anchor" aria-hidden="true" href="#在const成员函数里面调用非const成员函数">#</a></h1>
<p>直接在const成员函数里面调用非const成员函数会报错。</p>
<ol>
<li>
<p>向const成员函数内传入一个非const对象指针或引用，然后通过该指针或引用来调用非const成员 数。</p>
</li>
<li>
<p>在const成员函数内部进行this指针的const_cast转换，将其变为非const指针，然后就可以直接调用非const成员函数。</p>
</li>
<li>
<p>使用mutable关键字直接忽略掉const函数的限制。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Test</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="n">Test</span><span class="p">()</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{}</span>
<span class="o">~</span><span class="n">Test</span><span class="p">(){}</span>
<span class="kt">int</span> <span class="n">Get</span><span class="p">(</span><span class="n">Test</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
<span class="n">t</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">Get</span><span class="p">(</span><span class="n">Test</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Test</span> <span class="n">t</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">foo</span><span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
<span class="kt">void</span> <span class="n">test1</span><span class="p">(){</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am not a const member function&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">test2</span><span class="p">()</span><span class="k">const</span><span class="p">{</span>
<span class="n">foo</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="c1">//注意这个转换！！！
</span><span class="c1"></span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">test1</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<span class="n">foo</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">test2</span><span class="p">();</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="在非const成员函数中调用const成员函数">在非const成员函数中调用const成员函数<a hidden class="anchor" aria-hidden="true" href="#在非const成员函数中调用const成员函数">#</a></h2>
<p>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。若要在非const成员函数中调用const成员函数，可以用const_cast将this指针指向的对象转换为const类型，然后进行相应的函数调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">TextBlock</span><span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
  <span class="c1">//...
</span><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
       <span class="c1">//...
</span><span class="c1"></span>       <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kt">char</span><span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">positon</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="c1">//该函数返回const char的引用，所以需要再进行一次const_cast
</span><span class="c1"></span>                <span class="n">const_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">)[</span><span class="n">position</span><span class="p">]</span><span class="c1">//注意是先将this解引用，然后将this指向的对象强制转换为const类型
</span><span class="c1"></span>             <span class="p">);</span>
  <span class="p">}</span>
<span class="nl">private</span><span class="p">:</span>
   <span class="kt">char</span> <span class="n">text</span><span class="p">[</span><span class="n">max_text_len</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="const的作用">const的作用<a hidden class="anchor" aria-hidden="true" href="#const的作用">#</a></h1>
<h2 id="const意味着只读">const意味着“只读”<a hidden class="anchor" aria-hidden="true" href="#const意味着只读">#</a></h2>
<ol>
<li>
<p>关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。</p>
</li>
<li>
<p>通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</p>
</li>
<li>
<p>合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>
</li>
</ol>
<p>转载：<br>
<a href="">http://blog.csdn.net/lihao21/article/details/8634876</a><br>
<a href="">http://blog.csdn.net/mysunshinetbg/article/details/48346195</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/%E9%94%AE%E5%AD%97/">键字</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="/">Forz Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
