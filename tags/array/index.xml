<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Array on Forz Blog</title>
    <link>/tags/array/</link>
    <description>Recent content in Array on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 03 Sep 2017 16:08:55 +0000</lastBuildDate><atom:link href="/tags/array/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>路径数组变为统计数组</title>
      <link>/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 03 Sep 2017 16:08:55 +0000</pubDate>
      
      <guid>/post/%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84/</guid>
      <description>题目: 要求: 如果paths长度为N，请达到时间复杂度为O(N),额外空间复杂度为0(1)。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description>
    </item>
    
    <item>
      <title>数组中未出现的最小正整数</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</link>
      <pubDate>Sat, 02 Sep 2017 11:57:54 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0/</guid>
      <description>题目: 给定一个无序整型数组arr,找到数组中未出现的最小正整数。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 public static int missNum(int[] arr) { int l = 0; int r = arr.length; while (l &amp;lt; r) { if (arr[l] ==</description>
    </item>
    
    <item>
      <title>打印N个数组整体最大的Top K</title>
      <link>/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/</link>
      <pubDate>Fri, 01 Sep 2017 23:54:58 +0000</pubDate>
      
      <guid>/post/%E6%89%93%E5%8D%B0n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%95%B4%E4%BD%93%E6%9C%80%E5%A4%A7%E7%9A%84top-k/</guid>
      <description>题目: 有N个长度不一的数组，所有的数组都是有序的，请从大到小打印这N个数组整体最大的前K个数。 例如，输入含有N行元素的二维数组可以代表N个一</description>
    </item>
    
    <item>
      <title>不包含本位置值的累乘数组</title>
      <link>/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 01 Sep 2017 23:07:27 +0000</pubDate>
      
      <guid>/post/%E4%B8%8D%E5%8C%85%E5%90%AB%E6%9C%AC%E4%BD%8D%E7%BD%AE%E5%80%BC%E7%9A%84%E7%B4%AF%E4%B9%98%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 238. Product of Array Except Self Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra</description>
    </item>
    
    <item>
      <title>未排序数组中累加和为定值的最长子数组</title>
      <link>/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 28 Aug 2017 16:50:52 +0000</pubDate>
      
      <guid>/post/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>未排序正数数组中累加和为给定值的最长子数组长度 题目: 给定一个数组arr,该数组无序，但每个值均为正数，再给定一个正数k,求arr的所有子数组</description>
    </item>
    
    <item>
      <title>最长的可整合子数组的长度</title>
      <link>/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 28 Aug 2017 15:16:49 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E7%9A%84%E5%8F%AF%E6%95%B4%E5%90%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目: 先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之</description>
    </item>
    
    <item>
      <title>需要排序的最短子数组长度</title>
      <link>/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 28 Aug 2017 14:16:17 +0000</pubDate>
      
      <guid>/post/%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</guid>
      <description>题目: 给定一个无序数组air,求出需要排序的最短子数组长度。 例如：arr = [1，5, 3，4，2, 6，7]返回4，因为只有[5，3, 4，2]需</description>
    </item>
    
    <item>
      <title>“之”字形打印矩阵</title>
      <link>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 27 Aug 2017 20:04:40 +0000</pubDate>
      
      <guid>/post/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>题目: 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public static void printMatrixZigZag(int[][] matrix) { int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length - 1; int endC = matrix[0].length</description>
    </item>
    
    <item>
      <title>求两个数组的交集</title>
      <link>/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Sun, 25 Jun 2017 22:45:21 +0000</pubDate>
      
      <guid>/post/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>有序数组 以下两种方法都可以适用于数组中数据重复的情况。 长度相似 采用二路归并法来进行求解交集 对于数组A,B分别以i,j从头遍历数组。如果当前位</description>
    </item>
    
    <item>
      <title>数组中和为定值的多元组</title>
      <link>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:52 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E5%A4%9A%E5%85%83%E7%BB%84/</guid>
      <description>LeetCode 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解析</description>
    </item>
    
    <item>
      <title>模拟数组/字符串/链表的相加与相乘</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:43 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</guid>
      <description>LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6</description>
    </item>
    
    <item>
      <title>在有序旋转数组中的查找</title>
      <link>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:09 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>LeetCode 153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. Subscribe to see which companies asked this question. 解析： 二分法，旋</description>
    </item>
    
    <item>
      <title>删除数组/链表的元素</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:59 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>LeetCode 27. Remove Element Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3],</description>
    </item>
    
    <item>
      <title>数组、字符串、链表的旋转判定</title>
      <link>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:25 +0000</pubDate>
      
      <guid>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</guid>
      <description>LeetCode 189. Rotate Array Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 解析： 循环移动数组k位：123</description>
    </item>
    
    <item>
      <title>合并有序链表/数组</title>
      <link>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:16 +0000</pubDate>
      
      <guid>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解析： 合并两个数组（</description>
    </item>
    
    <item>
      <title>转圈打印矩阵</title>
      <link>/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:38 +0000</pubDate>
      
      <guid>/post/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>LeetCode 54. Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] You should return [1,2,3,6,9,8,7,4,5]. 解析： 先找出矩阵的四个边界，然后将整</description>
    </item>
    
    <item>
      <title>找到无序数组中某一频率的数</title>
      <link>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:19 +0000</pubDate>
      
      <guid>/post/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%80%E9%A2%91%E7%8E%87%E7%9A%84%E6%95%B0/</guid>
      <description>LeetCode 451. Sort Characters By Frequency Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: “tree” Output: “eert” Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore</description>
    </item>
    
    <item>
      <title>子数组的最大累加和/累乘积</title>
      <link>/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:10 +0000</pubDate>
      
      <guid>/post/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E7%B4%AF%E4%B9%98%E7%A7%AF/</guid>
      <description>LeetCode 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解析：动态规划 每个元素有2种选择：加入之前的连续子序列；创建一个新</description>
    </item>
    
    <item>
      <title>删除有序数组/链表的重复值</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:39 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</guid>
      <description>LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:20 +0000</pubDate>
      
      <guid>/post/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>LeetCode 14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. 解析：求所有字符串的公共前缀，逐个字符比较，时间复杂度为O(N*L),N是字符串个数，L是最长前缀的</description>
    </item>
    
    <item>
      <title>数字翻译</title>
      <link>/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:10 +0000</pubDate>
      
      <guid>/post/%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91/</guid>
      <description>LeetCode 12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 解析：先是做了一个表，根据各个位的数字查表，然后组合罗马数字成字符串 1 2 3 4 5 6 7 8 9 10</description>
    </item>
    
    <item>
      <title>将正方形矩阵转动90度</title>
      <link>/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/</link>
      <pubDate>Sat, 24 Jun 2017 22:08:46 +0000</pubDate>
      
      <guid>/post/%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8A%A890%E5%BA%A6/</guid>
      <description>LeetCode 48. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 解析： 二维矩阵顺时针旋转90度，先转置，再把每一行翻转 二维矩阵逆时针旋转90度，</description>
    </item>
    
    <item>
      <title>划分数组/链表</title>
      <link>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:14 +0000</pubDate>
      
      <guid>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>/post/h-index/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:15 +0000</pubDate>
      
      <guid>/post/h-index/</guid>
      <description>LeetCode 274. H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have</description>
    </item>
    
    <item>
      <title>查找区间最大值</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 19:49:49 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>LeetCode 162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2,</description>
    </item>
    
    <item>
      <title>Bulls and Cows</title>
      <link>/post/bulls-and-cows/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:15 +0000</pubDate>
      
      <guid>/post/bulls-and-cows/</guid>
      <description>LeetCode 299. Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”)</description>
    </item>
    
    <item>
      <title>Patching Array</title>
      <link>/post/patching-array/</link>
      <pubDate>Sat, 24 Jun 2017 16:11:04 +0000</pubDate>
      
      <guid>/post/patching-array/</guid>
      <description>LeetCode 330. Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: nums = [1, 3], n = 6 Return 1. Combinations of nums are [1], [3], [1,3], which form possible sums</description>
    </item>
    
    <item>
      <title>Pacific Atlantic Water Flow</title>
      <link>/post/pacific-atlantic-water-flow/</link>
      <pubDate>Sat, 24 Jun 2017 15:34:21 +0000</pubDate>
      
      <guid>/post/pacific-atlantic-water-flow/</guid>
      <description>LeetCode 417. Pacific Atlantic Water Flow A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 A zero-indexed array A consisting of N</description>
    </item>
    
    <item>
      <title>两个数组的相交数字</title>
      <link>/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sat, 24 Jun 2017 15:31:24 +0000</pubDate>
      
      <guid>/post/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%A4%E6%95%B0%E5%AD%97/</guid>
      <description>LeetCode 349. Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 解析： 因为要求结果元素不重复，所以采用unord</description>
    </item>
    
  </channel>
</rss>
