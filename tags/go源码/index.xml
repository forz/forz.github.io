<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go源码 on Forz Blog</title>
    <link>/tags/go%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in Go源码 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 Nov 2020 14:34:06 +0000</lastBuildDate>
    
	<atom:link href="/tags/go%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go的程序生命周期源码剖析</title>
      <link>/post/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Wed, 18 Nov 2020 14:34:06 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>程序生命周期 在 proc.go 和 runtime2.go 文件中，有一些很重要全局的变量，我们先列出来： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 所有 g 的长度 allglen uintptr // 保</description>
    </item>
    
    <item>
      <title>Go的网络轮询器源码剖析</title>
      <link>/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Sat, 14 Nov 2020 22:52:29 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>导言 Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoller )，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的</description>
    </item>
    
    <item>
      <title>Go的系统监控源码剖析</title>
      <link>/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 12 Nov 2020 19:32:21 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>设计原理 Go 语言的系统监控起到了很重要的作用，它在内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触</description>
    </item>
    
    <item>
      <title>Go的调度器源码剖析</title>
      <link>/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 12 Jul 2019 13:29:52 +0000</pubDate>
      
      <guid>/post/go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>源码分析 根据源码实现,调度器有如下细节优化: G对象和M对象默认会复用.除P本地的复用链表外,还有全局链表在多个P之间共享. P分为本地队列和全</description>
    </item>
    
  </channel>
</rss>