<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DFS on Forz Blog</title>
    <link>/tags/dfs/</link>
    <description>Recent content in DFS on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 18 Aug 2017 22:03:48 +0000</lastBuildDate><atom:link href="/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>查找二叉树中的搜索二叉树</title>
      <link>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 22:03:48 +0000</pubDate>
      
      <guid>/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</guid>
      <description>查找二叉树中的最大搜索二叉子树 给定一棵二叉树的头节点head,己知其中所有节点的值都不一样，找到含有节点最多 的搜索二叉子树，并返回这棵子树的</description>
    </item>
    
    <item>
      <title>先序、中序、后序数组两两组合重构二叉树</title>
      <link>/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:54 +0000</pubDate>
      
      <guid>/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</guid>
      <description>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. 解析：可以发现的规律是：中序遍历中根节点是左子树右子树的分割点。前序遍历的第一个节点为根节点。同</description>
    </item>
    
    <item>
      <title>Binary Search Tree</title>
      <link>/post/binary-search-tree/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:31 +0000</pubDate>
      
      <guid>/post/binary-search-tree/</guid>
      <description>LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串</description>
    </item>
    
    <item>
      <title>镜像二叉树</title>
      <link>/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:02 +0000</pubDate>
      
      <guid>/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 226. Invert Binary Tree Invert a binary tree. 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1 解析：二叉树的镜像就是在遍历树的同时交换非叶节点的左右子节点 1 2 3 4</description>
    </item>
    
    <item>
      <title>判断t1树是否包含t2树全部的拓扑结构</title>
      <link>/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:50 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 100.Same Tree Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解析：直接DFS，注意两个节点中任何一个为空要直接返回，算是递归终止</description>
    </item>
    
    <item>
      <title>除法的化简</title>
      <link>/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:24 +0000</pubDate>
      
      <guid>/post/%E9%99%A4%E6%B3%95%E7%9A%84%E5%8C%96%E7%AE%80/</guid>
      <description>LeetCode 399. Evaluate Division Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example: Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a =</description>
    </item>
    
    <item>
      <title>二叉树节点间的公共祖先</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:13 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a</description>
    </item>
    
    <item>
      <title>滑动窗口</title>
      <link>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:40 +0000</pubDate>
      
      <guid>/post/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>LeetCode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 解析：用双指</description>
    </item>
    
    <item>
      <title>二叉树的深度</title>
      <link>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:10 +0000</pubDate>
      
      <guid>/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>LeetCode 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解析：找二叉树的最大深度，不断dfs，只要能dfs到下一层，就增加</description>
    </item>
    
    <item>
      <title>在二叉树中找到累加和为指定值的最长路径长度</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:01 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</guid>
      <description>LeetCode 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2</description>
    </item>
    
    <item>
      <title>删除有序数组/链表的重复值</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:39 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</guid>
      <description>LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and</description>
    </item>
    
    <item>
      <title>乱序字符串</title>
      <link>/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:19 +0000</pubDate>
      
      <guid>/post/%E4%B9%B1%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>LeetCode 87. Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = “great”: great / \ gr eat / \ / \ g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its</description>
    </item>
    
    <item>
      <title>重建搜索二叉树</title>
      <link>/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:50 +0000</pubDate>
      
      <guid>/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解析： 每次找到数组的中间位置，这个便是BST的 根节点。左右孩子也很好找，根节点左边区域的</description>
    </item>
    
    <item>
      <title>添加括号或运算符进行计算</title>
      <link>/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:04 +0000</pubDate>
      
      <guid>/post/%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97/</guid>
      <description>LeetCode 494. Target Sum You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1,</description>
    </item>
    
    <item>
      <title>Flatten Binary Tree to Linked List</title>
      <link>/post/flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:52 +0000</pubDate>
      
      <guid>/post/flatten-binary-tree-to-linked-list/</guid>
      <description>LeetCode 114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 解析： 可以看出变换后的树实际上是按照先序</description>
    </item>
    
    <item>
      <title>Pascal&#39;s Triangle</title>
      <link>/post/pascal-s-triangle/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:41 +0000</pubDate>
      
      <guid>/post/pascal-s-triangle/</guid>
      <description>LeetCode 118. Pascal’s Triangle Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5, Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解析： 杨辉三角形的构造方法：左右边界为1，中间num[i]</description>
    </item>
    
    <item>
      <title>在二叉树节点中添加新指针</title>
      <link>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:57 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</guid>
      <description>LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it</description>
    </item>
    
    <item>
      <title>Surrounded Regions</title>
      <link>/post/surrounded-regions/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:12 +0000</pubDate>
      
      <guid>/post/surrounded-regions/</guid>
      <description>LeetCode 130. Surrounded Regions Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. For example, X X X X X O O X X X O X X O X X After running your function,</description>
    </item>
    
    <item>
      <title>特殊数</title>
      <link>/post/%E7%89%B9%E6%AE%8A%E6%95%B0/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:48 +0000</pubDate>
      
      <guid>/post/%E7%89%B9%E6%AE%8A%E6%95%B0/</guid>
      <description>LeetCode 202. Happy Number Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which</description>
    </item>
    
    <item>
      <title>课程安排</title>
      <link>/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/</link>
      <pubDate>Sat, 24 Jun 2017 19:51:39 +0000</pubDate>
      
      <guid>/post/%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92/</guid>
      <description>LeetCode 207. Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:</description>
    </item>
    
    <item>
      <title>Reconstruct Itinerary</title>
      <link>/post/reconstruct-itinerary/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:53 +0000</pubDate>
      
      <guid>/post/reconstruct-itinerary/</guid>
      <description>LeetCode 332. Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example,</description>
    </item>
    
    <item>
      <title>树的叶子节点</title>
      <link>/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:08 +0000</pubDate>
      
      <guid>/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 404. Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example: 3 / 9 20 / 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解析： 判断一个节点是否为左叶子节点: 1.是父节点的左孩</description>
    </item>
    
  </channel>
</rss>
