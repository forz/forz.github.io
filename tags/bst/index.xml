<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BST on Forz Blog</title>
    <link>http://localhost:1313/tags/BST/</link>
    <description>Recent content in BST on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 19 Aug 2017 22:07:36 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/BST/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>判断二叉树的类型</title>
      <link>http://localhost:1313/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 19 Aug 2017 22:07:36 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>LeetCode 110. Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解析：dfs求每个节点的高度，在求高度的同时判断当前</description>
    </item>
    
    <item>
      <title>调整搜索二叉树中两个错误的节点</title>
      <link>http://localhost:1313/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 20:13:36 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 99. Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解析： 中序遍历二叉树，出现的节点的值会升序排序，如果有两</description>
    </item>
    
    <item>
      <title>查找二叉树中的搜索二叉树</title>
      <link>http://localhost:1313/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 22:03:48 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</guid>
      <description>查找二叉树中的最大搜索二叉子树 给定一棵二叉树的头节点head,己知其中所有节点的值都不一样，找到含有节点最多 的搜索二叉子树，并返回这棵子树的</description>
    </item>
    
    <item>
      <title>Binary Search Tree</title>
      <link>http://localhost:1313/post/Binary-Search-Tree/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:31 +0000</pubDate>
      
      <guid>http://localhost:1313/post/Binary-Search-Tree/</guid>
      <description>LeetCode 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. 解析：中序遍历BST就可以得到一个有序数组，题目要找Kth，就直接中序遍历，在输出的字符串</description>
    </item>
    
    <item>
      <title>重建搜索二叉树</title>
      <link>http://localhost:1313/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:28:50 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E9%87%8D%E5%BB%BA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解析： 每次找到数组的中间位置，这个便是BST的 根节点。左右孩子也很好找，根节点左边区域的</description>
    </item>
    
    <item>
      <title>二叉树的序列化与反序列化</title>
      <link>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>LeetCode 297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your</description>
    </item>
    
  </channel>
</rss>