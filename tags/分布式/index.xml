<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>分布式 on Forz Blog</title>
    <link>/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Oct 2019 17:02:02 +0000</lastBuildDate><atom:link href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分布式延时任务方案</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 16 Oct 2019 17:02:02 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/</guid>
      <description>引言 在开发中，往往会遇到一些关于延时任务的需求。例如 生成订单30分钟未支付，则自动取消 生成订单60秒后,给用户发短信 对上述的任务，我们给一</description>
    </item>
    
    <item>
      <title>Dcron:基于一致性哈希算法实现分布式定时任务</title>
      <link>/post/dcron%E5%9F%BA%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Wed, 16 Oct 2019 14:59:13 +0000</pubDate>
      
      <guid>/post/dcron%E5%9F%BA%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>背景 在开发过程中，往往需要系统执行一些定时的任务，例如我们需要将数据进行迁移，又或者需要做一些数据的离线统计工作，这些都需要定时任务来进行处</description>
    </item>
    
    <item>
      <title>分布式系统的死锁处理</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 23 Sep 2019 10:24:33 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/</guid>
      <description>产生死锁的必要条件 互斥使用：进程对其申请的资源进行排他控制，其他申请资源的进程必须等待。 不可剥夺：占用资源的进程只能自己释放资源，不能被其他</description>
    </item>
    
    <item>
      <title>理解CAP和ACID的一致性</title>
      <link>/post/%E7%90%86%E8%A7%A3cap%E5%92%8Cacid%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Fri, 20 Sep 2019 19:50:25 +0000</pubDate>
      
      <guid>/post/%E7%90%86%E8%A7%A3cap%E5%92%8Cacid%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>ACID和CAP定理中都有C，代表Consistent一致性，很多人容易将这两个C混为一谈，其实这两个一致性是有区别的。这里可以区分成“内部</description>
    </item>
    
    <item>
      <title>初识分布式系统</title>
      <link>/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 20 Sep 2019 15:47:40 +0000</pubDate>
      
      <guid>/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</guid>
      <description>集中式系统 在学习分布式之前，先了解一下与之相对应的集中式系统是什么样的。 集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力</description>
    </item>
    
    <item>
      <title>分布式理论:CAP定理</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-cap%E5%AE%9A%E7%90%86/</link>
      <pubDate>Thu, 19 Sep 2019 17:18:05 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-cap%E5%AE%9A%E7%90%86/</guid>
      <description>定义 CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partiti</description>
    </item>
    
    <item>
      <title>分布式锁的实现</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 06 Sep 2019 18:02:26 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>为何需要分布式锁 一般我们使用分布式锁有两个场景: 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可</description>
    </item>
    
    <item>
      <title>分布式ID生成:leaf算法浅析</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-leaf%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</link>
      <pubDate>Sun, 30 Jun 2019 14:29:50 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-leaf%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</guid>
      <description>Leaf-segment Leaf-segment方案，在使用数据库的方案上，做了如下改变： 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用prox</description>
    </item>
    
    <item>
      <title>分布式ID生成方案简单总结</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 29 Jun 2019 16:59:28 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</guid>
      <description>背景 在我们的业务需求中通常有需要一些唯一的ID，来记录我们某个数据的标识: 某个用户的ID 某个订单的单号 某个信息的ID 通常我们会调研各种各样的</description>
    </item>
    
    <item>
      <title>分布式ID生成:snowflake算法浅析</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-snowflake%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 27 Jun 2019 19:31:40 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-snowflake%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</guid>
      <description>snowflake 大部分分布式系统中，对一些互斥资源通常需要一个集群唯一的ID，比如消息id，订单号等。而且很多业务需求往往要求这些ID必须具有先后顺序，以</description>
    </item>
    
  </channel>
</rss>
