<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on Forz Blog</title>
    <link>/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Oct 2019 17:02:02 +0000</lastBuildDate><atom:link href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分布式延时任务方案</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 16 Oct 2019 17:02:02 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88/</guid>
      <description>引言 在开发中，往往会遇到一些关于延时任务的需求。例如 生成订单30分钟未支付，则自动取消 生成订单60秒后,给用户发短信 对上述的任务，我们给一个</description>
    </item>
    
    <item>
      <title>分布式系统的死锁处理</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 23 Sep 2019 10:24:33 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86/</guid>
      <description>产生死锁的必要条件 互斥使用：进程对其申请的资源进行排他控制，其他申请资源的进程必须等待。 不可剥夺：占用资源的进程只能自己释放资源，不能被其他</description>
    </item>
    
    <item>
      <title>初识分布式系统</title>
      <link>/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 20 Sep 2019 15:47:40 +0000</pubDate>
      
      <guid>/post/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</guid>
      <description>集中式系统 在学习分布式之前，先了解一下与之相对应的集中式系统是什么样的。 集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力</description>
    </item>
    
    <item>
      <title>分布式锁的实现</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 06 Sep 2019 18:02:26 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>为何需要分布式锁 一般我们使用分布式锁有两个场景: 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可</description>
    </item>
    
    <item>
      <title>分布式ID设计实现</title>
      <link>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 29 Jun 2019 16:59:28 +0000</pubDate>
      
      <guid>/post/%E5%88%86%E5%B8%83%E5%BC%8Fid%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</guid>
      <description>背景 在我们的业务需求中通常有需要一些唯一的ID，来记录我们某个数据的标识: 某个用户的ID 某个订单的单号 某个信息的ID 通常我们会调研各种各样的</description>
    </item>
    
  </channel>
</rss>
