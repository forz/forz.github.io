<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linked List on Forz Blog</title>
    <link>/tags/linked-list/</link>
    <description>Recent content in Linked List on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 17 Aug 2017 16:01:21 +0000</lastBuildDate><atom:link href="/tags/linked-list/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>向有序的环形单链表插入新节点</title>
      <link>/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 16:01:21 +0000</pubDate>
      
      <guid>/post/%E5%90%91%E6%9C%89%E5%BA%8F%E7%9A%84%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9/</guid>
      <description>题目: 一个环形单链表从头节点head幵始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节</description>
    </item>
    
    <item>
      <title>删除无序单链表中值重复出现的点</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 14:18:44 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%97%A0%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E7%82%B9/</guid>
      <description>删除无序单链表中值重复出现的点 给定一个无序单链表的头节点head,删除其中值重复出现的节点。 例如：1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;</description>
    </item>
    
    <item>
      <title>模拟数组/字符串/链表的相加与相乘</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:28:43 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%8A%A0%E4%B8%8E%E7%9B%B8%E4%B9%98/</guid>
      <description>LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6</description>
    </item>
    
    <item>
      <title>判断回文串</title>
      <link>/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</link>
      <pubDate>Sun, 25 Jun 2017 02:27:37 +0000</pubDate>
      
      <guid>/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2/</guid>
      <description>LeetCode 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Intege</description>
    </item>
    
    <item>
      <title>删除数组/链表的元素</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:59 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>LeetCode 27. Remove Element Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3],</description>
    </item>
    
    <item>
      <title>在单链表中删除倒数第N个节点</title>
      <link>/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:48 +0000</pubDate>
      
      <guid>/post/%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. Note: Given n will always be valid. Try to do this in one pass. 解析： 根据题意</description>
    </item>
    
    <item>
      <title>链表有环和相交问题</title>
      <link>/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:38 +0000</pubDate>
      
      <guid>/post/%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98/</guid>
      <description>LeetCode 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解析： FLOYD判圈算法(判断是否有环): 如何检测一个链表是否有环，如果有，那么如何确</description>
    </item>
    
    <item>
      <title>数组、字符串、链表的旋转判定</title>
      <link>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:25 +0000</pubDate>
      
      <guid>/post/%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%8B%E8%BD%AC%E5%88%A4%E5%AE%9A/</guid>
      <description>LeetCode 189. Rotate Array Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 解析： 循环移动数组k位：123</description>
    </item>
    
    <item>
      <title>反转链表</title>
      <link>/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Jun 2017 02:24:14 +0000</pubDate>
      
      <guid>/post/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解析：直接交换当前结点和其后继节点的</description>
    </item>
    
    <item>
      <title>合并有序链表/数组</title>
      <link>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:16 +0000</pubDate>
      
      <guid>/post/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84/</guid>
      <description>LeetCode 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解析： 合并两个数组（</description>
    </item>
    
    <item>
      <title>复制含有随机指针节点的链表</title>
      <link>/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:49 +0000</pubDate>
      
      <guid>/post/%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 解析： 此题有两种方法，一种是按照原链表next的顺序依次创建节</description>
    </item>
    
    <item>
      <title>删除有序数组/链表的重复值</title>
      <link>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</link>
      <pubDate>Sat, 24 Jun 2017 23:58:39 +0000</pubDate>
      
      <guid>/post/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC/</guid>
      <description>LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and</description>
    </item>
    
    <item>
      <title>单链表排序总结</title>
      <link>/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:28 +0000</pubDate>
      
      <guid>/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</guid>
      <description>插入排序 LeetCode 147. Insertion Sort List Sort a linked list using insertion sort. 解析： 链表排序最易理解的是插入排序。 插入排序的方法就是枚举数组中的每一个元素i，从头扫描数组，找到第一个比该</description>
    </item>
    
    <item>
      <title>划分数组/链表</title>
      <link>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 24 Jun 2017 20:31:14 +0000</pubDate>
      
      <guid>/post/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</guid>
      <description>LeetCode 75. Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library</description>
    </item>
    
    <item>
      <title>设计缓存结构</title>
      <link>/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 24 Jun 2017 19:50:14 +0000</pubDate>
      
      <guid>/post/%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should</description>
    </item>
    
  </channel>
</rss>
