<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stack on Forz Blog</title>
    <link>http://localhost:1313/tags/stack/</link>
    <description>Recent content in Stack on Forz Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 23 Aug 2017 17:30:52 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>公式字符串求值</title>
      <link>http://localhost:1313/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 23 Aug 2017 17:30:52 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%85%AC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%80%BC/</guid>
      <description>LeetCode 150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: 1 2 [&amp;#34;2&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;+&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;*&amp;#34;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9 [&amp;#34;4&amp;#34;, &amp;#34;13&amp;#34;, &amp;#34;5&amp;#34;, &amp;#34;/&amp;#34;, &amp;#34;+&amp;#34;] -&amp;gt; (4 + (13 / 5)) -&amp;gt; 6 解析：用栈来模</description>
    </item>
    
    <item>
      <title>如何仅用递归函数和栈操作逆序一个栈</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</link>
      <pubDate>Wed, 16 Aug 2017 17:05:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</guid>
      <description>题目: 一个栈依次压入1、2、3、4、5,那么从栈顶到栈底分别为5、4、3、2、1。将这个栈 转置后，从栈顶到桟底为1、2、3、4、5,也就是实</description>
    </item>
    
    <item>
      <title>汉诺塔问题分析</title>
      <link>http://localhost:1313/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 16 Aug 2017 16:39:46 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</guid>
      <description></description>
    </item>
    
    <item>
      <title>栈与队列的互相实现</title>
      <link>http://localhost:1313/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:20 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</guid>
      <description>LeetCode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty</description>
    </item>
    
    <item>
      <title>设计一个有getMin功能的栈</title>
      <link>http://localhost:1313/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:54 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getmin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</guid>
      <description>LeetCode 155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 1 2 3 4 5 6 7 8 MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin();</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>http://localhost:1313/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 24 Jun 2017 22:12:01 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</guid>
      <description>括号字符的有效性 给定一个字符串str,判断是不是整体有效的括号字符串。 解析: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static boolean isValid(String str) { if (str == null || str.equals(&amp;#34;&amp;#34;)) {</description>
    </item>
    
    <item>
      <title>文件路径</title>
      <link>http://localhost:1313/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 24 Jun 2017 22:07:44 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</guid>
      <description>LeetCode 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = “/home/“, =&amp;gt; “/home” path = “/a/./b/../../c/“, =&amp;gt; “/c” 解析： 字符串处理，而</description>
    </item>
    
    <item>
      <title>Nested List</title>
      <link>http://localhost:1313/post/nested-list/</link>
      <pubDate>Sat, 24 Jun 2017 16:10:30 +0000</pubDate>
      
      <guid>http://localhost:1313/post/nested-list/</guid>
      <description>LeetCode 341. Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1: Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Given the list [1,[4,[6]]], By calling next</description>
    </item>
    
  </channel>
</rss>