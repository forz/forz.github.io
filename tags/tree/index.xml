<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tree on Forz</title>
    <link>http://localhost:1313/tags/tree/</link>
    <description>Recent content in Tree on Forz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 19 Aug 2017 22:51:16 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>在二叉树中找到一个节点的后继节点</title>
      <link>http://localhost:1313/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 22:51:16 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/</guid>
      <description>题目: 现在有一种新的二叉树节点类型如下： 1 2 3 4 5 6 7 8 public class Node { public int value; public Node left; public Node right; public Node parent; public Node(int data) { this.value = data; } 该结构比普通二叉树节点结构多了一个指</description>
    </item>
    
    <item>
      <title>调整搜索二叉树中两个错误的节点</title>
      <link>http://localhost:1313/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 19 Aug 2017 20:13:36 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E8%B0%83%E6%95%B4%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 99. Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解析： 中序遍历二叉树，出现的节点的值会升序排序，如果有两</description>
    </item>
    
    <item>
      <title>查找二叉树中的搜索二叉树</title>
      <link>http://localhost:1313/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 22:03:48 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</guid>
      <description>查找二叉树中的最大搜索二叉子树 给定一棵二叉树的头节点head,己知其中所有节点的值都不一样，找到含有节点最多 的搜索二叉子树，并返回这棵子树的</description>
    </item>
    
    <item>
      <title>如何较为直观地打印二叉树</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 18 Aug 2017 14:16:02 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E8%BE%83%E4%B8%BA%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目: 二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树中有 重复值的时候，仅通过三种遍历的结果来构造二叉树的真实结构更是</description>
    </item>
    
    <item>
      <title>打印二叉树的边界节点</title>
      <link>http://localhost:1313/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 17 Aug 2017 17:32:32 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/</guid>
      <description>题目 给定一棵二叉树的头节点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。 标准一： 头节点为边界节点。 叶节点为边界节点。 如果节点</description>
    </item>
    
    <item>
      <title>先序、中序、后序数组两两组合重构二叉树</title>
      <link>http://localhost:1313/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:54 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91-/</guid>
      <description>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. 解析：可以发现的规律是：中序遍历中根节点是左子树右子树的分割点。前序遍历的第一个节点为根节点。同</description>
    </item>
    
    <item>
      <title>二叉树的前序/中序/后序遍历</title>
      <link>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 25 Jun 2017 02:26:40 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>LeetCode 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes’ values. 解析：递归太简单，直接上递推，用栈来模拟递归，找左孩子，保存路径，找不到就找右兄弟的左孩子。 1</description>
    </item>
    
    <item>
      <title>镜像二叉树</title>
      <link>http://localhost:1313/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 25 Jun 2017 02:23:02 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E9%95%9C%E5%83%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 226. Invert Binary Tree Invert a binary tree. 1 2 3 4 5 4 / \ 2 7 / \ / \ 1 3 6 9 to 1 2 3 4 5 4 / \ 7 2 / \ / \ 9 6 3 1 解析：二叉树的镜像就是在遍历树的同时交换非叶节点</description>
    </item>
    
    <item>
      <title>判断t1树是否包含t2树全部的拓扑结构</title>
      <link>http://localhost:1313/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:50 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%88%A4%E6%96%ADt1%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%ABt2%E6%A0%91%E5%85%A8%E9%83%A8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</guid>
      <description>LeetCode 100.Same Tree Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解析：直接DFS，注意两个节点中任何一个为空要直接返回，算是递归终止</description>
    </item>
    
    <item>
      <title>二叉树节点间的公共祖先</title>
      <link>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sun, 25 Jun 2017 02:22:13 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a</description>
    </item>
    
    <item>
      <title>二叉树的按层打印与ZigZig打印</title>
      <link>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/</link>
      <pubDate>Sun, 25 Jun 2017 02:21:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%B8%8Ezigzig%E6%89%93%E5%8D%B0/</guid>
      <description>LeetCode102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 1 2 3 4 5 3 / \ 9 20 / \ 15 7 return its level order traversal as: 1 2 3 4 5 [ [3], [9,20], [15,7] ] 解析</description>
    </item>
    
    <item>
      <title>二叉树的深度</title>
      <link>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:10 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>LeetCode 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解析：找二叉树的最大深度，不断dfs，只要能dfs到下一层，就增加</description>
    </item>
    
    <item>
      <title>在二叉树中找到累加和为指定值的最长路径长度</title>
      <link>http://localhost:1313/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sun, 25 Jun 2017 00:01:01 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</guid>
      <description>LeetCode 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 1 2 3 4 5 6 7 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true,</description>
    </item>
    
    <item>
      <title>统计和生成所有不同的二叉树</title>
      <link>http://localhost:1313/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 24 Jun 2017 20:29:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>LeetCode 96. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s. 1 2 3 4 5 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / /</description>
    </item>
    
    <item>
      <title>Flatten Binary Tree to Linked List</title>
      <link>http://localhost:1313/post/flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:52 +0000</pubDate>
      
      <guid>http://localhost:1313/post/flatten-binary-tree-to-linked-list/</guid>
      <description>LeetCode 114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, Given 1 2 3 4 5 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 2 3 4 5 6 7 8 9 10 11 1 \ 2 \ 3 \ 4 \ 5 \ 6 解析： 可</description>
    </item>
    
    <item>
      <title>Pascal&#39;s Triangle</title>
      <link>http://localhost:1313/post/pascal-s-triangle/</link>
      <pubDate>Sat, 24 Jun 2017 20:27:41 +0000</pubDate>
      
      <guid>http://localhost:1313/post/pascal-s-triangle/</guid>
      <description>LeetCode 118. Pascal’s Triangle Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5, Return 1 2 3 4 5 6 7 [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解析： 杨辉三角形的构造方法：左右边界为1，中</description>
    </item>
    
    <item>
      <title>在二叉树节点中添加新指针</title>
      <link>http://localhost:1313/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 24 Jun 2017 20:26:57 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%8C%87%E9%92%88/</guid>
      <description>LeetCode 116. Populating Next Right Pointers in Each Node Given a binary tree 1 2 3 4 5 struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.</description>
    </item>
    
    <item>
      <title>二叉树的序列化与反序列化</title>
      <link>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Sat, 24 Jun 2017 16:12:28 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>LeetCode 297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your</description>
    </item>
    
    <item>
      <title>树的叶子节点</title>
      <link>http://localhost:1313/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 24 Jun 2017 15:38:08 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9/</guid>
      <description>LeetCode 404. Sum of Left Leaves Find the sum of all left leaves in a given binary tree. Example: 3 / 9 20 / 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解析： 判断一个节点是否为左叶子节点: 1.是父节点的左孩</description>
    </item>
    
  </channel>
</rss>